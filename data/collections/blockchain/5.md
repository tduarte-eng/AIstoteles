# [合约的元数据 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/metadata.html) 
 _https://docs.soliditylang.org/zh-cn/latest/metadata.html_

## 合约的元数据[](#metadata "此标题的永久链接")
Solidity编译器会自动生成一个JSON文件。该文件包含关于编译合约的两种信息：
* 如何与合约进行交互：ABI和NatSpec文档。
 
* 如何重现编译并验证已部署的合约：编译器版本，编译器设置和使用的源文件。
 
编译器默认会将元数据文件的IPFS哈希附加到每个合约的运行字节码（不一定是创建字节码）的末尾， 这样，如果发布了合约，您可以以经过身份验证的方式检索该文件，而无需依赖于集中式数据提供者。 其他可用选项包括Swarm哈希和不将元数据哈希附加到字节码中。 这些选项可以通过 [标准JSON接口](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#compiler-api) 的配置进行设置。
您必须将元数据文件发布到IPFS，Swarm或其他服务， 以便其他人可以访问它。您可以通过使用 `solc --metadata` 命令 和 `--output-dir` 参数来创建该文件。如果没有这个参数， 元数据将被写到标准输出。 元数据包含 IPFS 和 Swarm 对源代码的引用， 所以除了元数据文件外，您还必须上传所有的源文件。 对于IPFS， `ipfs add` 返回的 CID 中包含的哈希值（不是文件的直接sha2-256哈希值） 应与字节码中包含的哈希值相匹配。
元数据文件的格式如下所示。下面的例子是以人类可读的方式呈现的。 正确格式化的元数据应正确地使用引号， 将空格减少到最小，并按字母顺序对所有对象的键进行排序， 以达到规范化的格式。是不允许有注释的，这里的目的只是为了解释。
{
 // 必选：编译器的详情，内容视语言而定。
 "compiler": {
 // 可选：生成此输出的编译器二进制文件的哈希值。
 "keccak256": "0x123...",
 // 对 Solidity 语言来说是必选的：编译器的版本
 "version": "0.8.2+commit.661d1103"
 },
 // 必选：源代码语言，基本上是选择规范中的一个“子版本”。
 "language": "Solidity",
 // 必选：关于合约生成的信息。
 "output": {
 // 必选：合约的ABI定义。参见“合约ABI规范”。
 "abi": \[/\* ... \*/\],
 // 必选：合约的NatSpec开发者文档。请参阅 https://docs.soliditylang.org/en/latest/natspec-format.html 获取详细信息。
 "devdoc": {
 // 合约中 @author NatSpec字段的内容
 "author": "John Doe",
 // 合约中 @dev NatSpec字段的内容
 "details": "Interface of the ERC20 standard as defined in the EIP. See https://eips.ethereum.org/EIPS/eip-20 for details",
 "errors": {
 "MintToZeroAddress()" : {
 "details": "Cannot mint to zero address"
 }
 },
 "events": {
 "Transfer(address,address,uint256)": {
 "details": "Emitted when \`value\` tokens are moved from one account (\`from\`) toanother (\`to\`).",
 "params": {
 "from": "The sender address",
 "to": "The receiver address",
 "value": "The token amount"
 }
 }
 },
 "kind": "dev",
 "methods": {
 "transfer(address,uint256)": {
 // @dev NatSpec字段的内容
 "details": "Returns a boolean value indicating whether the operation succeeded. Must be called by the token holder address",
 // @param NatSpec字段的内容
 "params": {
 "\_value": "The amount tokens to be transferred",
 "\_to": "The receiver address"
 },
 // @return NatSpec字段的内容
 "returns": {
 // 如果存在，返回var名称（这里是 “success”）。如果返回的var是未命名的，“\_0” 作为键。
 "success": "a boolean value indicating whether the operation succeeded"
 }
 }
 },
 "stateVariables": {
 "owner": {
 // 状态变量的 @dev NatSpec 字段的内容
 "details": "Must be set during contract creation. Can then only be changed by the owner"
 }
 },
 // 合约中 @title NatSpec字段的内容
 "title": "MyERC20: an example ERC20",
 "version": 1 // NatSpec 版本
 },
 // 必选：合约的NatSpec用户文档。请参阅”NatSpec格式“
 "userdoc": {
 "errors": {
 "ApprovalCallerNotOwnerNorApproved()": \[
 {
 "notice": "The caller must own the token or be an approved operator."
 }
 \]
 },
 "events": {
 "Transfer(address,address,uint256)": {
 "notice": "\`\_value\` tokens have been moved from \`from\` to \`to\`"
 }
 },
 "kind": "user",
 "methods": {
 "transfer(address,uint256)": {
 "notice": "Transfers \`\_value\` tokens to address \`\_to\`"
 }
 },
 "version": 1 // NatSpec版本
 }
 },
 // 必选：编译器设置。反映了编译过程中JSON输入中的设置。
 // 请查阅标准JSON输入的文档中的“settings”字段
 "settings": {
 // Solidity所需的内容：元数据所创建的文件路径和合约或库的名称。
 "compilationTarget": {
 "myDirectory/myFile.sol": "MyContract"
 },
 // Solidity所需的内容。
 "evmVersion": "london",
 // Solidity所需的内容：所使用的库合约的地址。
 "libraries": {
 "MyLib": "0x123123..."
 },
 "metadata": {
 // 反映了输入JSON中使用的设置，默认为“true”
 "appendCBOR": true,
 // 反映了输入JSON中使用的设置，默认为“ipfs”
 "bytecodeHash": "ipfs",
 // 反映了输入JSON中使用的设置，默认为“false”
 "useLiteralContent": true
 },
 // 可选：优化器设置。字段“enabled”和“runs”已被弃用，仅用于向后兼容。
 "optimizer": {
 "details": {
 "constantOptimizer": false,
 "cse": false,
 "deduplicate": false,
 // inliner的默认值为“false”
 "inliner": false,
 // jumpdestRemover的默认值为“true”
 "jumpdestRemover": true,
 "orderLiterals": false,
 // peephole的默认值为“true”
 "peephole": true,
 "yul": true,
 // 可选：仅在“yul”为“true”时出现
 "yulDetails": {
 "optimizerSteps": "dhfoDgvulfnTUtnIf...",
 "stackAllocation": false
 }
 },
 "enabled": true,
 "runs": 500
 },
 // Solidity所需的内容：按顺序排列的导入重映射列表。
 "remappings": \[ ":g=/dir" \]
 },
 // 必选：编译源文件/源单元，键为文件路径
 "sources": {
 "destructible": {
 // 必选（除非使用“url”）：源文件的字面内容
 "content": "contract destructible is owned { function destroy() { if (msg.sender == owner) selfdestruct(owner); } }",
 // 必选：源文件的keccak256哈希值
 "keccak256": "0x234..."
 },
 "myDirectory/myFile.sol": {
 // 必选：源文件的keccak256哈希值
 "keccak256": "0x123...",
 // 可选：源文件中提供的SPDX许可证标识符
 "license": "MIT",
 // 必选（除非使用“content”，参见上文）：指向源文件的按顺序排列的URL（或URLs），
 // 协议可以是任意的，但建议使用IPFS URL
 "urls": \[ "bzz-raw://7d7a...", "dweb:/ipfs/QmN..." \]
 }
 },
 // 必选：元数据格式的版本
 "version": 1
}
警告
由于产生的合约的字节码默认包含元数据哈希值， 对元数据的任何改变都可能导致字节码的改变。 这包括对文件名或路径的改变，而且由于元数据包括所有使用的源的哈希值， 一个空白的改变就会导致不同的元数据和不同的字节码。
备注
上面的ABI定义没有固定的顺序。它可以随着编译器的版本而改变。 不过，从Solidity 0.5.12版本开始，该数组保持一定的顺序。
## 在字节码中对元数据哈希值进行编码[](#encoding-of-the-metadata-hash-in-the-bytecode "此标题的永久链接")
编译器目前默认将 IPFS 哈希值（在 CID v0 中）<[https://docs.ipfs.tech/concepts/content-addressing/#version-0-v0](https://docs.ipfs.tech/concepts/content-addressing/#version-0-v0)\>\`\_ 的规范元数据文件和编译器版本附加到字节码的末尾。 也可以使用 Swarm 哈希值代替 IPFS，或使用实验标志。 以下是所有可能的字段：
{
 "ipfs": "<metadata hash>",
 // 如果编译器设置中的 “bytecodeHash” 是 “bzzr1”，那就没有使用 “ipfs”，而是 “bzzr1”
 "bzzr1": "<metadata hash>",
 // 以前的版本使用的是 “bzzr0” 而不是 “bzzr1”
 "bzzr0": "<metadata hash>",
 // 如果使用了任何影响代码生成的实验功能
 "experimental": true,
 "solc": "<compiler version>"
}
由于我们将来可能会支持以其他方式检索元数据文件， 因此这些信息被存储为 [CBOR](https://tools.ietf.org/html/rfc7049)\-编码。 字节码中的最后两个字节表示 CBOR 编码信息的长度。通过观察这个长度， 可以用 CBOR 解码器对字节码的相关部分进行解码。
请查看 [元数据游乐场（Metadata Playground）](https://playground.sourcify.dev/) 以了解其运行情况。
solc的发布版本使用如上所示的3个字节的版本编码 （主要、次要和补丁版本号各一个字节）， 而预发布版本将使用一个完整的版本字符串，包括提交哈希和构建日期。
命令行标志 `--no-cbor-metadata` 可以用来跳过元数据在部署的字节码末端的附加。 同样地，标准JSON输入中的布尔字段 `settings.metadata.appendCBOR` 可以设置为false。
备注
CBOR映射也可能包含其他键， 因此最好通过查看字节码末尾的CBOR长度来完全解码数据， 并使用适当的CBOR分析器。不要依赖以 `0xa264` 或 `0xa2 0x64 'i' 'p' 'f' 's'` 开头的数据。
## 自动化接口生成和NatSpec 的使用方法[](#natspec "此标题的永久链接")
元数据的使用方式如下：一个想要与合约交互的组件 （例如钱包）会检索合约的代码。 它对包含元数据文件的 IPFS/Swarm 哈希的 CBOR 编码部分进行解码。 通过该哈希值，元数据文件被检索出来。该文件被 JSON 解码成一个类似于上述的结构。
然后，该组件可以使用ABI为合约自动生成一个基本的用户界面。
此外，钱包可以使用 NatSpec 用户文档，每当用户与合约交互时， 就会向用户显示一条可读的确认信息，同时请求对交易签名进行授权。
有关其他信息，请阅读 [以太坊自然语言规范（NatSpec）格式](https://docs.soliditylang.org/zh-cn/latest/natspec-format.html)。
## 源代码验证的用法[](#id3 "此标题的永久链接")
如果已固定/发布，则可以从 IPFS/Swarm 获取合约的元数据。 元数据文件还包含源文件的URLs或IPFS哈希值， 以及编译设置，即重现编译所需的一切信息。
有了这些信息，就可以通过重现编译过程来验证合约的源代码， 并将编译的字节码与已部署合约的字节码进行比较。
由于源代码的哈希值是元数据的一部分，因此也会自动验证源代码。 文件或设置的任何变化都会导致不同的元数据哈希值。 元数据是整个编译过程的指纹。
[Sourcify](https://sourcify.dev/) 利用这一功能进行 “完全/完美验证”， 并将文件公开固定在IPFS上，以便使用元数据哈希值进行访问。

# [Akıllı Sözleşmelere Giriş — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html) 
 _https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html_

## Basit Bir Akıllı Sözleşme[](#basit-bir-akilli-sozlesme "Permalink to this heading")
Bir değişkenin değerini atayan ve bunu diğer sözleşmelerin erişimine sunan temel bir örnekle başlayalım. Şu an her şeyi anlamadıysanız sorun değil, birazdan daha fazla ayrıntıya gireceğiz.
### Depolama[](#depolama "Permalink to this heading")
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZVN0b3JhZ2UgewogICAgdWludCBzdG9yZWREYXRhOwoKICAgIGZ1bmN0aW9uIHNldCh1aW50IHgpIHB1YmxpYyB7CiAgICAgICAgc3RvcmVkRGF0YSA9IHg7CiAgICB9CgogICAgZnVuY3Rpb24gZ2V0KCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBzdG9yZWREYXRhOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract SimpleStorage {
 uint storedData;
 function set(uint x) public {
 storedData \= x;
 }
 function get() public view returns (uint) {
 return storedData;
 }
}
İlk satır size kaynak kodunun GPL 3.0 sürümü altında lisanslanmış olduğunu söyler. Kaynak kodu yayınlamanın standart olduğu bir ortamda makine tarafından okunabilen lisans belirleyicileri önemlidir.
Bir sonraki satır, kaynak kodun Solidity 0.4.16’dan başlayarak 0.9.0’a kadar (0.9.0 hariç) olan sürümler için yazıldığını belirtir. Bu, sözleşmenin farklı sonuçlar verebileceği yeni bir derleyici sürümü ile derlenemez olmasını sağlamak içindir. [Pragmalar](https://docs.soliditylang.org/tr/latest/layout-of-source-files.html#pragma), derleyiciler için kaynak kodun nasıl ele alınacağına ilişkin ortak talimatlardır (ör. [pragma once](https://en.wikipedia.org/wiki/Pragma_once)).
Solidity kapsamında olan bir sözleşme, Ethereum blok zinciri ağında belirli bir adreste bulunan kod (_fonksiyonlar_) ve veri (_durum_) bütünüdür. `uint storeData;` satırı, `uint` türünde (_256_ bitlik bir _u_nsigned (pozitif) _int_eger ) `storedData` adlı bir durum değişkeni tanımlar . Bunu, veritabanını yöneten kodun fonksiyonlarını çağırarak sorgulayabileceğiniz ve değiştirebileceğiniz, veritabanındaki bir bilgi olarak düşünebilirsiniz. Ve bu örnektede, “set” ve “get” fonksiyonları değişkenin değerini değiştirmek veya çağırmak için tanımlanmıştır.
Mevcut sözleşmenizde bulunan bir durum değişkenine erişmek için genellikle `this.` önekini eklemezsiniz, doğrudan adı üzerinden erişirsiniz. Diğer bazı dillerin aksine, bu öneki atlamak sadece kodun görünüşünü iyileştirmek için değildir. Bu düzenleme değişkene erişmek için de tamamen farklı sonuçlar doğurabilir, fakat bu konuya daha sonra detaylıca değineceğiz.
Bu sözleşme, (Ethereum temel yapısı nedeniyle) herhangi birinin, tanımladığınız bu değişkenin (yayınlamanızı engelleyecek (uygulanabilir) bir yol olmadan) dünyadaki herkes tarafından erişilebilmesi için saklamaktan başka pek bir işe yaramıyor. Herhangi biri `set` fonksiyonunu farklı bir değer tanımlamak için tekrar çağırabilir ve değişkeninizin üzerine yazdırabilir, fakat bu değiştirilen değişkenin kayıtları blok zincirinin geçmişinde saklanmaya devam eder. İlerleyen zamanlarda, değişkeni yalnızca sizin değiştirebilmeniz için nasıl erişim kısıtlamalarını koyabileceğinizi göreceksiniz.
Uyarı
Unicode metni kullanırken dikkatli olunması gerekir, çünkü benzer görünümlü (hatta aynı) karakterler farklı kod işlevlerine sahip olabilir ve farklı bir bayt dizisi olarak kodlanabilirler.
Not
Sözleşmenizin tüm tanımlayıcı değerleri (sözleşme isimleri, fonksiyon isimleri ve değişken isimleri) ASCII karakter seti ile sınırlıdır. UTF-8 ile kodlanmış verileri string değişkenlerinde saklamak mümkündür.
### Alt Para Birimi Örneği[](#alt-para-birimi-ornegi "Permalink to this heading")
Aşağıdaki sözleşme, bir kripto para biriminin en basit biçiminin bir örneğidir. Bu sözleşme, yalnızca sözleşme sahibinin (oluşturucusunun) yeni paralar oluşturmasına izin verir (farklı para oluşturma planları ayarlamak mümkündür). Herkes kullanıcı adı ve parolayla kayıt olmadan birbirine para gönderebilir. Tüm bunlar için tek ihtiyacınız olan şey sadece Ethereum anahtar çiftidir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IENvaW4gewogICAgLy8gInB1YmxpYyIgYW5haHRhciBrZWxpbWVzaSwgZGXEn2nFn2tlbmxlcmkKICAgIC8vIGRpxJ9lciBzw7Z6bGXFn21lbGVyIHRhcmFmxLFuZGFuIGVyacWfaWxlYmlsaXIga8SxbGFyCiAgICBhZGRyZXNzIHB1YmxpYyBtaW50ZXI7CiAgICBtYXBwaW5nIChhZGRyZXNzID0+IHVpbnQpIHB1YmxpYyBiYWxhbmNlczsKCiAgICAvLyBFdmVudCdsZXIgaXN0ZW1jaWxlcmluIHPDtnpsZcWfbWUgw7x6ZXJpbmRlIHlhcHTEscSfxLFuxLF6CiAgICAvLyBkZcSfacWfaWtsaWtsZXJlIHRlcGtpIHZlcm1lbGVyaW5pIHNhxJ9sYXIKICAgIGV2ZW50IFNlbnQoYWRkcmVzcyBmcm9tLCBhZGRyZXNzIHRvLCB1aW50IGFtb3VudCk7CgogICAgLy8gQ29uc3RydWN0b3Iga29kdSBzYWRlY2Ugc8O2emxlxZ9tZQogICAgLy8gb2x1xZ90dXJ1bGR1xJ91bmRhIMOnYWzEscWfxLFyCiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgICBtaW50ZXIgPSBtc2cuc2VuZGVyOwogICAgfQoKICAgIC8vIFllbmkgb2x1xZ90dXJ1bGFuIGJpciBtaWt0YXIgcGFyYXnEsSBhZHJlc2UgZ8O2bmRlcmlyCiAgICAvLyBZYWxuxLF6Y2Egc8O2emxlxZ9tZSB5YXJhdMSxY8Sxc8SxIHRhcmFmxLFuZGFuIMOnYcSfcsSxbGFiaWxpcgogICAgZnVuY3Rpb24gbWludChhZGRyZXNzIHJlY2VpdmVyLCB1aW50IGFtb3VudCkgcHVibGljIHsKICAgICAgICByZXF1aXJlKG1zZy5zZW5kZXIgPT0gbWludGVyKTsKICAgICAgICBiYWxhbmNlc1tyZWNlaXZlcl0gKz0gYW1vdW50OwogICAgfQoKICAgIC8vIEVycm9yJ2xlciBiaXIgacWfbGVtaW4gbmVkZW4gYmHFn2FyxLFzxLF6IG9sZHXEn3UgaGFra8SxbmRhCiAgICAvLyBiaWxnaSBhbG1hbsSxesSxIHNhxJ9sYXIuIEZvbmtzaXlvbnUgw6dhxJ/EsXJhbiBracWfaXllCiAgICAvLyBiaWxnaWxlbmRpcm1lIGFtYWPEsXlsYSBiaXIgc29udcOnIGTDtm5kw7xyw7xybGVyLgogICAgZXJyb3IgSW5zdWZmaWNpZW50QmFsYW5jZSh1aW50IHJlcXVlc3RlZCwgdWludCBhdmFpbGFibGUpOwoKICAgIC8vIEZvbmtzaXlvbnUgw6dhxJ/EsXJhbiBracWfaW5pbiB2YXIgb2xhbiBwYXJhbGFyxLFuZGFuCiAgICAvLyBhbMSxY8SxIGFkcmVzZSBwYXJhIGfDtm5kZXJpci4KICAgIGZ1bmN0aW9uIHNlbmQoYWRkcmVzcyByZWNlaXZlciwgdWludCBhbW91bnQpIHB1YmxpYyB7CiAgICAgICAgaWYgKGFtb3VudCA+IGJhbGFuY2VzW21zZy5zZW5kZXJdKQogICAgICAgICAgICByZXZlcnQgSW5zdWZmaWNpZW50QmFsYW5jZSh7CiAgICAgICAgICAgICAgICByZXF1ZXN0ZWQ6IGFtb3VudCwKICAgICAgICAgICAgICAgIGF2YWlsYWJsZTogYmFsYW5jZXNbbXNnLnNlbmRlcl0KICAgICAgICAgICAgfSk7CgogICAgICAgIGJhbGFuY2VzW21zZy5zZW5kZXJdIC09IGFtb3VudDsKICAgICAgICBiYWxhbmNlc1tyZWNlaXZlcl0gKz0gYW1vdW50OwogICAgICAgIGVtaXQgU2VudChtc2cuc2VuZGVyLCByZWNlaXZlciwgYW1vdW50KTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract Coin {
 // "public" anahtar kelimesi, değişkenleri
 // diğer sözleşmeler tarafından erişilebilir kılar
 address public minter;
 mapping (address \=> uint) public balances;
 // Event'ler istemcilerin sözleşme üzerinde yaptığınız
 // değişikliklere tepki vermelerini sağlar
 event Sent(address from, address to, uint amount);
 // Constructor kodu sadece sözleşme
 // oluşturulduğunda çalışır
 constructor() {
 minter \= msg.sender;
 }
 // Yeni oluşturulan bir miktar parayı adrese gönderir
 // Yalnızca sözleşme yaratıcısı tarafından çağrılabilir
 function mint(address receiver, uint amount) public {
 require(msg.sender \== minter);
 balances\[receiver\] += amount;
 }
 // Error'ler bir işlemin neden başarısız olduğu hakkında
 // bilgi almanızı sağlar. Fonksiyonu çağıran kişiye
 // bilgilendirme amacıyla bir sonuç döndürürler.
 error InsufficientBalance(uint requested, uint available);
 // Fonksiyonu çağıran kişinin var olan paralarından
 // alıcı adrese para gönderir.
 function send(address receiver, uint amount) public {
 if (amount \> balances\[msg.sender\])
 revert InsufficientBalance({
 requested: amount,
 available: balances\[msg.sender\]
 });
 balances\[msg.sender\] \-= amount;
 balances\[receiver\] += amount;
 emit Sent(msg.sender, receiver, amount);
 }
}
Bu sözleşmede bazı yeni kavramlar tanıtılıyor, hadi hepsini teker teker inceleyelim.
`address public minter;` satırı [address](https://docs.soliditylang.org/tr/latest/types.html#address) türündeki bir durum değişkenini tanımlıyor. `address` değişken türü, herhangi bir aritmetik işlemin uygulanmasına izin vermeyen 160 bitlik bir değerdir. Sözleşmelerin adreslerini veya [harici hesaplar](#accounts)’a ait bir anahtar çiftinin teki olan public key hash’ini saklamak için uygundur.
`public` anahtar sözcüğü otomatik olarak durum değişkeninin mevcut değerine sözleşme dışından da erişmenizi sağlayan bir fonksiyonu oluşturur. Bu anahtar kelime olmadan, diğer sözleşmelerin bu değişkene erişme yolu yoktur. Derleyici tarafından oluşturulan fonksiyonun kodu aşağıdakine eşdeğerdir (şimdilik `external` ve `view` i göz ardı edin):
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=ZnVuY3Rpb24gbWludGVyKCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChhZGRyZXNzKSB7IHJldHVybiBtaW50ZXI7IH0=)
function minter() external view returns (address) { return minter; }
Yukarıdaki gibi bir fonksiyonu koda kendiniz de ekleyebilirsiniz, fakat aynı isimde olan bir fonksiyon ve durum değişkeniniz olur. Bunu yapmanıza gerek yoktur, bu işi derleyici sizin yerinize halleder.
Diğer satır olan `mapping (address => uint) public balances;` de bir public durum değişkeni oluşturuyor, fakat bu değişken biraz daha karmaşık bir veri yapısına sahip. Burada bulunan ref:mapping <mapping-types> türü adresleri [unsigned integers](https://docs.soliditylang.org/tr/latest/types.html#integers) ile eşliyor.
Mapping’ler, sanal bir şekilde tanımlanıp değer atanan [hash tabloları](https://en.wikipedia.org/wiki/Hash_table) olarak görülebilir. Bu yapıda mümkün olan her anahtar değeri tanımlandığı andan itibaren bulunur ve bu anahtarların eşlendiği değer (byte gösterminde) sıfırdır. Ancak, bir mapping’in ne tüm anahtarlarının ne de tüm değerlerinin bir listesini elde etmek mümkün değildir. Bunun için mapping’e eklediğiniz değerleri kaydedin veya buna gerek duyulmayacak bir durumda kullanın. Hatta daha da iyisi bir liste tutun ya da daha uygun bir veri türünü kullanmayı deneyin.
`public` anahtar kelimesi ile oluşturulmuş aşağıda bulunan [çağırıcı fonksiyon](https://docs.soliditylang.org/tr/latest/contracts.html#getter-functions), mapping örneğine göre biraz daha karmaşık bir yapıya sahiptir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=ZnVuY3Rpb24gYmFsYW5jZXMoYWRkcmVzcyBfYWNjb3VudCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICByZXR1cm4gYmFsYW5jZXNbX2FjY291bnRdOwp9)
function balances(address \_account) external view returns (uint) {
 return balances\[\_account\];
}
Bu fonksiyonu tek bir hesabın bakiyesini sorgulamak için kullanabilirsiniz.
`event Sent(address from, address to, uint amount);` satırı `send` fonksiyonunun son satırında yayılan (emit) bir [”olay (event)”](https://docs.soliditylang.org/tr/latest/contracts.html#events) bildirir. Web uygulamaları gibi Ethereum istemcileri, blok zincirinde yayılan (emit) bu olaylardan (event) fazla maliyet olmadan veri alabilir. Event yayılır yayılmaz, veri alıcısı `from`, `to` ve `amount` argümanlarını alır, bu da alım satım işlemlerinin takip edilmesini mümkün kılar.
Bu olayı(event) dinlemek amacıyla, `Coin` sözleşme nesnesini oluşturmak için [web3.js](https://github.com/ethereum/web3.js/) kütüphanesini kullanan aşağıdaki JavaScript kodunu kullanabilirsiniz. Ve herhangi bir kullanıcı arayüzü (user interface), otomatik olarak oluşturulan `balances` fonksiyonunu yukarıdan sizin için çağırır:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Q29pbi5TZW50KCkud2F0Y2goe30sICcnLCBmdW5jdGlvbihlcnJvciwgcmVzdWx0KSB7CiAgICBpZiAoIWVycm9yKSB7CiAgICAgICAgY29uc29sZS5sb2coIkNvaW4gdHJhbnNmZXI6ICIgKyByZXN1bHQuYXJncy5hbW91bnQgKwogICAgICAgICAgICAiIGNvaW5zIHdlcmUgc2VudCBmcm9tICIgKyByZXN1bHQuYXJncy5mcm9tICsKICAgICAgICAgICAgIiB0byAiICsgcmVzdWx0LmFyZ3MudG8gKyAiLiIpOwogICAgICAgIGNvbnNvbGUubG9nKCJCYWxhbmNlcyBub3c6XG4iICsKICAgICAgICAgICAgIlNlbmRlcjogIiArIENvaW4uYmFsYW5jZXMuY2FsbChyZXN1bHQuYXJncy5mcm9tKSArCiAgICAgICAgICAgICJSZWNlaXZlcjogIiArIENvaW4uYmFsYW5jZXMuY2FsbChyZXN1bHQuYXJncy50bykpOwogICAgfQp9KQ==)
Coin.Sent().watch({}, '', function(error, result) {
 if (!error) {
 console.log("Coin transfer: " + result.args.amount +
 " coins were sent from " + result.args.from +
 " to " + result.args.to + ".");
 console.log("Balances now:\\n" +
 "Sender: " + Coin.balances.call(result.args.from) +
 "Receiver: " + Coin.balances.call(result.args.to));
 }
})
[constructor](https://docs.soliditylang.org/tr/latest/contracts.html#constructor) fonksiyonu, sözleşmenin oluşturulması sırasında çalıştırılan ve daha sonra çağırılamayan özel bir fonksiyondur. Bu örnekte ise constructor fonksiyonu sözleşmeyi oluşturan kişinin adresini kalıcı olarak depoluyor. `msg` değişkeni (`tx` ve `block` ile birlikte), blok zincirine erişim izini veren özellikleri olan [özel bir global değişken](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#special-variables-functions) dir. `msg.sender` her zaman varsayılan fonksiyonu (external) çağıran kişinin adresini döndürür.
Sözleşmeyi oluşturan ve hem kullanıcıların hemde sözleşmelerin çağırabileceği fonksiyonlar `mint` ve `send` dir.
`mint` fonksiyonu yeni oluşturulan bir miktar parayı başka bir adrese gönderir. ref:require <assert-and-require> fonksiyon çağrısı, karşılanmadığı takdirde tüm değişiklikleri geri döndüren koşulları tanımlar. Bu örnekte, `require(msg.sender == minter);` yalnızca sözleşme yaratıcısının `mint` fonksiyonunu çağırabilmesini sağlar. Genel olarak, sözleşme yaratıcısı istediği kadar para basabilir, fakat belirili bir noktadan sonra bu durum “owerflow” adı verilen bir olaya yol açacaktır. Varsayılan [Checked arithmetic](https://docs.soliditylang.org/tr/latest/control-structures.html#unchecked) nedeniyle, `balances[receiver] += amount;` ifadesi taşarsa, yani `balances[receiver] + amount` ifadesi `uint` maksimum değerinden (`2**256 - 1`) büyükse işlemin geri döndürüleceğini unutmayın. Bu, `send` fonksiyonundaki `balances[receiver] += amount;` ifadesi için de geçerlidir.
[Hatalar](https://docs.soliditylang.org/tr/latest/contracts.html#errors), bir koşulun veya işlemin neden başarısız olduğu hakkında fonksiyonu çağıran kişiye daha fazla bilgi sağlamanıza olanak tanır. Hatalar [revert ifadesi](https://docs.soliditylang.org/tr/latest/control-structures.html#revert-statement) ile birlikte kullanılır. `revert` ifadesi, `require` fonksiyonuna benzer bir şekilde tüm değişiklikleri koşulsuz olarak iptal eder ve geri alır, ancak aynı zamanda bir hatanın daha kolay hata ayıklanabilmesi veya tepki verilebilmesi için hatanın adını ve çağıran kişiye (ve nihayetinde ön uç uygulamaya veya blok gezginine) sağlanacak ek verileri sağlamanıza olanak tanır.
`send` fonksiyonu, herhangi biri tarafından (hali hazırda bir miktar paraya sahip olan) başka birine para göndermek için kullanılabilir. Gönderen kişinin göndermek için yeterli bakiyesi yoksa, `if` koşulu doğru (true) olarak değerlendirilir. Sonuç olarak `revert` fonksiyonu, `InsufficientBalance` (Yetersiz bakiye) hatasını kullanarak göndericiye hata ayrıntılarını sağlarken işlemin başarısız olmasına neden olacaktır.
Not
Bu sözleşmeyi bir adrese para (coin) göndermek için kullanırsanız, bir blok zinciri gezgininde (explorer) o adrese baktığınızda hiçbir şey göremezsiniz, çünkü para (coin) gönderdiğiniz kayıt ve değişen bakiyeler yalnızca bu coin sözleşmesinin veri deposunda saklanır. Event’leri kullanarak, yeni coin’inizin işlemlerini ve bakiyelerini izleyen bir “blok zinciri gezgini (explorer)” oluşturabilirsiniz, ancak coin sahiplerinin adreslerini değil, coin’in sözleşme adresini incelemeniz gerekir.
## Blok Zinciri Temelleri[](#blok-zinciri-temelleri "Permalink to this heading")
Bir kavram olarak blok zincirleri anlamak programcılar için çok zor değildir. Bunun nedeni, komplikasyonların (madencilik (mining), [hashing](https://en.wikipedia.org/wiki/Cryptographic_hash_function), [elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic_curve_cryptography), [peer-to-peer networks](https://en.wikipedia.org/wiki/Peer-to-peer), etc.) çoğunun sadece platform için belirli bir dizi özellik ve vaat sağlamak için orada olmasıdır. Bu özellikleri olduğu gibi kabul ettiğinizde, altta yatan teknoloji hakkında endişelenmenize gerek kalmaz - yoksa Amazon’un AWS’sini kullanmak için dahili olarak nasıl çalıştığını bilmek zorunda mısınız?
### İşlemler (Transactions)[](#islemler-transactions "Permalink to this heading")
Blok zinciri, küresel olarak paylaşılan, işlemsel bir veritabanıdır. Bu, herkesin yalnızca ağa katılarak veritabanındaki girdileri okuyabileceği anlamına gelir. Veritabanındaki bir şeyi değiştirmek istiyorsanız, diğerleri tarafından kabul edilmesi gereken bir “işlem” oluşturmanız gerekir. İşlem kelimesi, yapmak istediğiniz değişikliğin (aynı anda iki değeri değiştirmek istediğinizi varsayın) ya hiç yapılmadığını ya da tamamen uygulanmasını ifade eder. Ayrıca, işleminiz veritabanına uygulanırken başka hiçbir işlem onu değiştiremez.
Örnek olarak, elektronik para birimindeki tüm hesapların bakiyelerini listeleyen bir tablo hayal düşünün. Bir hesaptan diğerine transfer talep edilirse, veri tabanının işlemsel yapısı, tutar bir hesaptan çıkarılırsa, her zaman diğer hesaba eklenmesini sağlar. Herhangi bir nedenden dolayı tutarın hedef hesaba eklenmesi mümkün değilse, kaynak hesaptaki bakiye de değiştirilmez.
Ayrıca, bir işlem her zaman gönderen (yaratıcı) tarafından şifreli olarak imzalanır. Bu, veritabanındaki belirli değişikliklere erişimi korumayı kolaylaştırır. Kripto para birimi örneğinde, basit bir kontrol, yalnızca anahtarları hesaba katan bir kişinin hesaptan para aktarabilmesini sağlar.
### Bloklar[](#bloklar "Permalink to this heading")
Üstesinden gelinmesi gereken en büyük engellerden biri (Bitcoin açısından) “çifte harcama saldırısı” olarak adlandırılan bir olaydır: Ağda bir cüzdanı boşaltmak isteyen eşzamanlı iki işlem varsa ne olur? İşlemlerden sadece biri geçerli olabilir, tipik olarak önce kabul edilmiş olanı. Sorun, “ilk” in eşler arası ağda (peer-to-peer network) nesnel bir terim olmamasıdır.
Özetle tüm bunları düşünmenize gerk yoktur. İşlemlerin global olarak kabul edilen bir sırası sizin için seçilecek ve çatışma çözülecektir. İşlemler “blok” adı verilen bir yapıda bir araya getirilecek ve daha sonra yürütülerek tüm katılımcı düğümler arasında dağıtılacaktır. Eğer iki işlem birbiriyle çelişirse, ikinci olan işlem reddedilecek ve bloğun bir parçası olmayacaktır.
Bu bloklar zaman içinde doğrusal bir dizi oluşturur ve “blok zinciri” kelimesi de zaten buradan türemiştir. Bloklar zincire oldukça düzenli aralıklarla eklenir - Ethereum için bu süre kabaca her 17 saniye birdir.
“Sıra seçim mekanizmasının” (“madencilik” olarak adlandırılır) bir parçası olarak zaman zaman bloklar geri alınabilir, ancak bu sadece zincirin en “ucunda” gerçekleşir. Belirli bir bloğun üzerine ne kadar çok blok eklenirse, bu bloğun geri döndürülme olasılığı o kadar azalır. Yani işlemleriniz geri alınabilir ve hatta blok zincirinden kaldırılabilir, ancak ne kadar uzun süre beklerseniz, bu olasılık o kadar azalacaktır.
Not
İşlemlerin bir sonraki bloğa veya gelecekteki herhangi bir bloğa dahil edileceği garanti edilmez, çünkü işlemin hangi bloğa dahil edileceğini belirlemek, işlemi gönderen kişiye değil madencilere bağlıdır.
Sözleşmenizin gelecekteki çağrılarını planlamak istiyorsanız, bir akıllı sözleşme otomasyon aracı veya bir oracle hizmeti kullanabilirsiniz.
## Ethereum Sanal Makinası[](#ethereum-sanal-makinasi "Permalink to this heading")
### Genel Bakış[](#genel-bakis "Permalink to this heading")
Ethereum Sanal Makinesi veya ESM, Ethereum’daki akıllı sözleşmeler için çalışma ortamıdır. Bu alan yalnızca korumalı bir alan değil, aynı zamanda tamamen yalıtılmış bir alandır; yani ESM içinde çalışan kodun ağa, dosya sistemine ya da diğer süreçlere erişimi yoktur. Akıllı sözleşmelerin diğer akıllı sözleşmelere erişimi bile sınırlıdır.
### Hesaplar[](#hesaplar "Permalink to this heading")
Ethereum’da aynı adres alanını paylaşan iki tür hesap vardır: Public anahtar çiftleri (yani insanlar) tarafından kontrol edilen **harici hesaplar** ve hesapla birlikte depolanan kod tarafından kontrol edilen **sözleşme hesapları**.
Harici bir hesabın adresi açık (public) anahtardan belirlenirken, bir sözleşmenin adresi sözleşmenin oluşturulduğu anda belirlenir (“nonce” olarak adlandırılan yaratıcı adres ve bu adresten gönderilen işlem sayısından türetilir).
Hesabın kod depolayıp depolamadığına bakılmaksızın, iki tür ESM tarafından eşit olarak değerlendirilir.
Her hesabın, 256-bit sözcükleri **storage** adı verilen 256-bit sözcüklere eşleyen kalıcı bir anahtar-değer deposu vardır.
Ayrıca, her hesabın Ether cinsinden bir **bakiyesi** vardır (tam olarak “Wei” cinsinden, `1 ether` `10**18 wei` dir) ve bu Ether içeren işlemler gönderilerek değiştirilebilir.
### İşlemler[](#islemler "Permalink to this heading")
İşlem, bir hesaptan diğerine gönderilen bir mesajdır (aynı veya boş olabilir, aşağıya bakınız). İkili verileri (“yük” olarak adlandırılır) ve Ether içerebilir.
Hedef hesap kod içeriyorsa, bu kod çalıştırılır ve sonucunda elde erilen veri yükü girdi olarak kabul edilir.
Hedef hesap ayarlanmamışsa (işlemin alıcısı yoksa veya alıcı `null` olarak ayarlanmışsa), işlem **yeni bir sözleşme** oluşturur. Daha önce de belirtildiği gibi, bu sözleşmenin adresi sıfır adres değil, göndericiden ve gönderilen işlem sayısından (“nonce”) türetilen bir adrestir. Böyle bir sözleşme oluşturma işleminin yükü ESM bytecode’u olarak alınır ve çalıştırılır. Bu uygulamanın çıktı verileri kalıcı olarak sözleşmenin kodu olarak saklanır. Bu, bir sözleşme oluşturmak için sözleşmenin gerçek kodunu değil, aslında yürütüldüğünde bu kodu döndüren kodu gönderdiğiniz anlamına gelir.
Not
Bir sözleşme oluşturulurken, kodu hala boştur. Bu nedenle, constructor fonksiyonu çalışmayı bitirene kadar yapım aşamasındaki sözleşmeyi geri çağırmamalısınız.
### Gas[](#gas "Permalink to this heading")
Oluşturulduktan sonra, her işlem, işlemin kaynağı (`tx.origin`) tarafından ödenmesi gereken belirli bir **gas** miktarı ile ücretlendirilir. ESM işlemi gerçekleştirirken, gas belirli kurallara göre kademeli olarak tüketilir. Gas herhangi bir noktada tükenirse (yani negatif olursa), yürütmeyi sona erdiren ve mevcut çağrı çerçevesinde durumunda yapılan tüm değişiklikleri geri alan bir out-of-gas (gas bitti) istisnası tetiklenir.
Bu mekanizma, ESM’in çalışma süresinin tasarruflu bir şekilde kullanılmasını teşvik eder ve aynı zamanda ESM yürütücülerinin (yani madencilerin / stakerların) çalışmalarını telafi eder. Her blok maksimum miktarda gaza sahip olduğundan, bir bloğu doğrulamak için gereken iş miktarını da sınırlanmış olur.
**Gas ücreti**, işlemin yaratıcısı tarafından yani gönderen hesabından `gaz_ücreti * gaz` miktarında ödemek zorunda olduğu bir değerdir. Uygulamadan sonra bir miktar gaz kalırsa, bu miktar işlemi çalıştıran kişiye iade edilir. Değişikliği geri döndüren bir istisna olması durumunda, kullanılmış gas’ın iadesi yapılmaz.
ESM yürütücüleri bir işlemi ağa dahil edip etmemeyi seçebildiğinden, işlem gönderenler düşük bir gas fiyatı belirleyerek sistemi kötüye kullanamazlar.
### Depolama, Bellek ve Yığın[](#depolama-bellek-ve-yigin "Permalink to this heading")
Ethereum Sanal Makinesi’nin veri depolayabileceği üç alan vardır: storage (depolama), memory (bellek) ve stack (yığın).
Her hesap, fonksiyon çağrıları ve işlemler arasında kalıcı olan **storage** adlı bir veri alanına sahiptir. Depolama, 256 bit kelimeleri 256 bit kelimelerle eşleyen bir anahtar/değer deposudur. Bir sözleşmenin içinden depolamayı belirtmek mümkün değildir, depolamayı okumak da maliyetlidir ancak depolamayı başlatmak ve değiştirmek daha da maliyetlidir. Bu maliyet nedeniyle, kalıcı depolama alanında depoladığınız verinin miktarını sözleşmenin çalışması için gereken en azami miktara indirmelisiniz. Ayrıca türetilmiş hesaplamalar, önbelleğe alma ve toplamalar gibi verileri sözleşmenin dışında depolamalısınız. Bir sözleşme, kendi depolama alanı dışında herhangi bir depolama alanını ne okuyabilir ne de bu alandaki verileri değiştirebilir.
İkincisi ise, **memory** (bellek) olarak adlandırılan ve bir sözleşmenin her ileti çağrısı için yeniden oluşturulmuş bir örneğini alan bir veri alanıdır. Bellek doğrusaldır ve bayt düzeyinde adreslenebilir, ancak okumalar 256 bit genişlikle sınırlıyken, yazmalar 8 bit veya 256 bit genişliğinde olabilir. Daha önceden dokunulmamış bir bellek kelimesine (yani bir kelime içindeki herhangi bir ofsete) erişirken (okurken veya yazarken) bellek bir kelime (256 bit) kadar genişletilir. Bu genişletilme sırasında gas maliyeti ödenmelidir. Bellek büyüdükçe daha maliyetli olmaya başlıyacaktır (söz konusu artış maliyetin karesi olarak artmaya devam edecektir).
ESM, kayıt makinesi değil yığın makinesi olduğundan tüm hesaplamalar **stack** (yığın) adı verilen bir veri alanında gerçekleştirilir. Bu alan maksimum 1024 eleman boyutuna sahiptir ve 256 bitlik kelimeler içerir. Yığına erişim aşağıdaki şekilde üst uçla sınırlıdır: En üstteki 16 elemandan birini yığının en üstüne kopyalamak veya en üstteki elemanı altındaki 16 elemandan biriyle değiştirmek mümkündür. Diğer tüm işlemler yığından en üstteki iki (veya işleme bağlı olarak bir veya daha fazla) elemanı alır ve sonucu yığının üzerine iter. Elbette yığına daha derin erişim sağlamak için yığın elemanlarını depolama alanına veya belleğe taşımak mümkündür, ancak önce yığının üst kısmını çıkarmadan yığının daha derinlerindeki rastgele elemanlara erişmek mümkün değildir.
### Yönerge Seti[](#yonerge-seti "Permalink to this heading")
ESM’nin komut seti, uzlaşma sorunlarına neden olabilecek yanlış veya tutarsız uygulamalardan kaçınmak için minimum düzeyde tutulmuştur. Tüm komutlar temel veri tipi olan 256 bitlik kelimeler veya bellek dilimleri (veya diğer bayt dizileri) üzerinde çalışır. Her zamanki aritmetik, bit, mantıksal ve karşılaştırma işlemleri mevcuttur. Koşullu ve koşulsuz atlamalar mümkündür. Ayrıca, sözleşmeler mevcut bloğun numarası ve zaman bilgisi gibi ilgili özelliklerine erişebilir.
Tam bir liste için lütfen satır içi montaj belgelerinin bir parçası olarak [işlem kodu (opcode) listeleri](https://docs.soliditylang.org/tr/latest/yul.html#opcodes) belgesine bakın.
### Mesaj Çağırıları[](#mesaj-cagirilari "Permalink to this heading")
Sözleşmeler, mesaj çağrıları aracılığıyla diğer sözleşmeleri çağırabilir veya sözleşme dışı hesaplara Ether gönderebilir. Mesaj çağrıları, bir kaynak, bir hedef, veri yükü, Ether, gas ve geri dönüş verilerine sahip olmaları bakımından işlemlere benzerler. Aslında, her işlem üst düzey bir mesaj çağrısından oluşur ve bu da başka mesaj çağrıları oluşturabilir.
Bir sözleşme, kalan **gas’ın** ne kadarının iç mesaj çağrısı ile gönderilmesi gerektiğine ve ne kadarını tutmak istediğine karar verebilir. İç çağrıda yetersiz-gas dışında bir istisna meydana gelirse (veya başka bir istisna), bu durum yığına yerleştirilen bir hata değeri ile bildirilir. Bu durumda, sadece çağrı ile birlikte gönderilen gas miktarı kullanılır. Solidity dilinde, bu gibi istisnaların oluşması varsayılan olarak manuel başka zincirleme istisnalar da yaratmaya meyilli olduğundan totalde yığınını “kabarcıklandıran” durum olarak nitelendirilir.
Daha önce de belirtildiği gibi, çağrılan sözleşme (arayan ile aynı olabilir) belleğin yeni temizlenmiş bir örneğini alır ve **calldata** adı verilen ayrı bir alanda sağlanacak olan çağrı yüküne (payload) erişebilir. Yürütmeyi tamamladıktan sonra, arayanın belleğinde arayan tarafından önceden ayrılmış bir konumda saklanacak olan verileri döndürebilir. Tüm bu çağrılar tamamen eşzamanlıdır.
Çağrılar, 1024 bitlik alanla ile sınırlıdır; bu, daha karmaşık işlemler için tekrarlamalı çağrılar yerine döngüler tercih edileceği anlamına gelir. Ayrıca, bir mesaj çağrısında gazın sadece 63 / 64’ü iletilebilir; bu, pratikte 1000 bit’ten daha az bir alan sınırlamasına neden olur.
### Delegatecall / Çağrı Kodu ve Kütüphaneler[](#delegatecall-cagri-kodu-ve-kutuphaneler "Permalink to this heading")
Bir mesaj çağrısı ile temelde aynı anlama gelen **delegatecall**, hedef adresteki kodun arama sözleşmesi bağlamında (yani adresinde) yürütülmesi ve `msg.sender` ve `msg.value` değerlerinin değiştirilememesi gibi özellikleri ile mesaj çağrısının özel bir çeşidi olarak kabul edilir.
Bu, bir sözleşmenin çalışma zamanında farklı bir adresten dinamik olarak kod yükleyebileceği anlamına gelir. Depolama, geçerli adres ve bakiye hala çağıran sözleşmeye atıfta bulunurken, yalnızca kod çağrılan adresten aktarılır.
Karmaşık bir veri yapısını uygulamak için bir sözleşmenin depolama alanına uygulanabilen ve yeniden kullanılabilen bir kütüphane kodu örnek olarak verilebilir.
### Kayıtlar (Logs)[](#kayitlar-logs "Permalink to this heading")
Verileri, tamamen blok seviyesine kadar haritalayan özel olarak indekslenmiş bir veri yapısında depolamak mümkündür. **Kayıtlar** (log) olarak adlandırılan bu özellik, Solidity tarafından [event’lerin](https://docs.soliditylang.org/tr/latest/contracts.html#events) uygulanmasını için kullanılır. Sözleşmeler, oluşturulduktan sonra kayıt verilerine erişemez, ancak bunlara blok zincirinin dışından etkin bir şekilde erişilebilir. Kayıt edilen verilerinin bir kısmı [bloom filtrelerinde](https://en.wikipedia.org/wiki/Bloom_filter) depolandığından, bu verileri verimli ve kriptografik olarak güvenli bir şekilde aramak mümkündür, böylece tüm zinciri indirmek zorunda kalmayan ağ elemanları(peer) (“hafif istemciler” olarak adlandırılır) yine de bu günlükleri bulabilir.
### Create[](#create "Permalink to this heading")
Sözleşmeler, özel bir opcode kullanarak başka sözleşmeler bile oluşturabilir (bunu, hedef adresi boş bırakarak yaparlar). Bu arama çağrıları ve normal mesaj çağrıları arasındaki tek fark, açığa çıkan veri yükünün yürütülmesi ve sonucun kod olarak saklanarak arayan tarafın(yaratıcının) yığındaki yeni sözleşmenin adresini almasıdır.
### Devre Dışı Bırakma ve Kendini İmha[](#devre-disi-birakma-ve-kendini-imha "Permalink to this heading")
Blok zincirinden bir kodu kaldırmanın tek yolu, söz konusu adresteki bir sözleşmenin selfdestruct işlemini gerçekleştirmesidir. Bu adreste depolanan kalan Ether belirlenen bir hedefe gönderilir ve ardından depolama ve kod durumdan kaldırılır. Teoride sözleşmeyi kaldırmak iyi bir fikir gibi görünse de, biri kaldırılan sözleşmelere Ether gönderirse, Ether sonsuza dek kaybolacağından potansiyel olarak tehlikelidir.
Uyarı
Bir sözleşme `selfdestruct` ile kaldırılsa bile, hala blok zinciri geçmişinin bir parçasıdır ve muhtemelen çoğu Ethereum node\`u tarafından saklanmaktadır. Yani `selfdestruct` kullanmak sabit diskten veri silmekle aynı şey değildir.
Not
Bir sözleşmenin kodu `selfdestruct` çağrısı içermese bile, `delegatecall` veya `callcode` kullanarak bu işlemi gerçekleştirebilir.
Sözleşmelerinizi devre dışı bırakmak istiyorsanız, bunun yerine tüm fonksiyonların geri alınmasına neden olan bazı iç durumları değiştirerek bunları devre dışı bırakmalısınız. Bu, Ether’i derhal iade ettiğinden sözleşmeyi kullanmayı imkansız kılar.
### Önceden Derlenmiş Sözleşmeler (Precompiled Contracts)[](#onceden-derlenmis-sozlesmeler-precompiled-contracts "Permalink to this heading")
Özel olan bir dizi küçük sözleşme adresi vardır: `1` ile (`8` dahil) `8` arasındaki adres aralığı, diğer sözleşmeler gibi çağrılabilen “önceden derlenmiş sözleşmeler” içerir, ancak davranışları (ve gaz tüketimleri) bu adreste saklanan ESM kodu tarafından tanımlanmaz (kod içermezler), bunun yerine ESM kendi yürütme ortamında yürütülür.
Farklı ESM uyumlu zincirler, önceden derlenmiş farklı bir sözleşme seti kullanabilir. Gelecekte Ethereum ana zincirine önceden derlenmiş yeni sözleşmelerin eklenmesi de mümkün olabilir, ancak mantıklı olarak bunların her zaman `1` ile `0xffff` (dahil) aralığında olmasını beklemelisiniz.

# [Types — Solidity 0.4.26 documentation](https://docs.soliditylang.org/en/v0.4.26/types.html) 
 _https://docs.soliditylang.org/en/v0.4.26/types.html_

[Solidity](https://docs.soliditylang.org/en/v0.4.26/index.html)
Solidity is a statically typed language, which means that the type of each variable (state and local) needs to be specified (or at least known - see [Type Deduction](#type-deduction) below) at compile-time. Solidity provides several elementary types which can be combined to form complex types.
In addition, types can interact with each other in expressions containing operators. For a quick reference of the various operators, see [Order of Precedence of Operators](https://docs.soliditylang.org/en/v0.4.26/miscellaneous.html#order).
## Value Types[¶](#value-types "Permalink to this headline")
The following types are also called value types because variables of these types will always be passed by value, i.e. they are always copied when they are used as function arguments or in assignments.
### Booleans[¶](#booleans "Permalink to this headline")
`bool`: The possible values are constants `true` and `false`.
Operators:
* `!` (logical negation)
* `&&` (logical conjunction, “and”)
* `||` (logical disjunction, “or”)
* `==` (equality)
* `!=` (inequality)
The operators `||` and `&&` apply the common short-circuiting rules. This means that in the expression `f(x) || g(y)`, if `f(x)` evaluates to `true`, `g(y)` will not be evaluated even if it may have side-effects.
### Integers[¶](#integers "Permalink to this headline")
`int` / `uint`: Signed and unsigned integers of various sizes. Keywords `uint8` to `uint256` in steps of `8` (unsigned of 8 up to 256 bits) and `int8` to `int256`. `uint` and `int` are aliases for `uint256` and `int256`, respectively.
Operators:
* Comparisons: `<=`, `<`, `==`, `!=`, `>=`, `>` (evaluate to `bool`)
* Bit operators: `&`, `|`, `^` (bitwise exclusive or), `~` (bitwise negation)
* Arithmetic operators: `+`, `-`, unary `-`, unary `+`, `*`, `/`, `%` (remainder), `**` (exponentiation), `<<` (left shift), `>>` (right shift)
Division always truncates (it is just compiled to the `DIV` opcode of the EVM), but it does not truncate if both operators are [literals](#rational-literals) (or literal expressions).
Division by zero and modulus with zero throws a runtime exception.
The result of a shift operation is the type of the left operand. The expression `x << y` is equivalent to `x * 2**y`, and `x >> y` is equivalent to `x / 2**y`. This means that shifting negative numbers sign extends. Shifting by a negative amount throws a runtime exception.
Warning
The results produced by shift right of negative values of signed integer types is different from those produced by other programming languages. In Solidity, shift right maps to division so the shifted negative values are going to be rounded towards zero (truncated). In other programming languages the shift right of negative values works like division with rounding down (towards negative infinity).
### Fixed Point Numbers[¶](#fixed-point-numbers "Permalink to this headline")
Warning
Fixed point numbers are not fully supported by Solidity yet. They can be declared, but cannot be assigned to or from.
`fixed` / `ufixed`: Signed and unsigned fixed point number of various sizes. Keywords `ufixedMxN` and `fixedMxN`, where `M` represents the number of bits taken by the type and `N` represents how many decimal points are available. `M` must be divisible by 8 and goes from 8 to 256 bits. `N` must be between 0 and 80, inclusive. `ufixed` and `fixed` are aliases for `ufixed128x18` and `fixed128x18`, respectively.
Operators:
* Comparisons: `<=`, `<`, `==`, `!=`, `>=`, `>` (evaluate to `bool`)
* Arithmetic operators: `+`, `-`, unary `-`, unary `+`, `*`, `/`, `%` (remainder)
Note
The main difference between floating point (`float` and `double` in many languages, more precisely IEEE 754 numbers) and fixed point numbers is that the number of bits used for the integer and the fractional part (the part after the decimal dot) is flexible in the former, while it is strictly defined in the latter. Generally, in floating point almost the entire space is used to represent the number, while only a small number of bits define where the decimal point is.
### Address[¶](#address "Permalink to this headline")
`address`: Holds a 20 byte value (size of an Ethereum address). Address types also have members and serve as a base for all contracts.
Operators:
* `<=`, `<`, `==`, `!=`, `>=` and `>`
Note
Starting with version 0.5.0 contracts do not derive from the address type, but can still be explicitly converted to address.
#### Members of Addresses[¶](#members-of-addresses "Permalink to this headline")
* `balance` and `transfer`
For a quick reference, see [Address Related](https://docs.soliditylang.org/en/v0.4.26/units-and-global-variables.html#address-related).
It is possible to query the balance of an address using the property `balance` and to send Ether (in units of wei) to an address using the `transfer` function:
address x \= 0x123;
address myAddress \= this;
if (x.balance < 10 && myAddress.balance \>= 10) x.transfer(10);
Note
If `x` is a contract address, its code (more specifically: its fallback function, if present) will be executed together with the `transfer` call (this is a feature of the EVM and cannot be prevented). If that execution runs out of gas or fails in any way, the Ether transfer will be reverted and the current contract will stop with an exception.
* `send`
Send is the low-level counterpart of `transfer`. If the execution fails, the current contract will not stop with an exception, but `send` will return `false`.
Warning
There are some dangers in using `send`: The transfer fails if the call stack depth is at 1024 (this can always be forced by the caller) and it also fails if the recipient runs out of gas. So in order to make safe Ether transfers, always check the return value of `send`, use `transfer` or even better: use a pattern where the recipient withdraws the money.
* `call`, `callcode` and `delegatecall`
Furthermore, to interface with contracts that do not adhere to the ABI, the function `call` is provided which takes an arbitrary number of arguments of any type. These arguments are padded to 32 bytes and concatenated. One exception is the case where the first argument is encoded to exactly four bytes. In this case, it is not padded to allow the use of function signatures here.
address nameReg \= 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;
nameReg.call("register", "MyName");
nameReg.call(bytes4(keccak256("fun(uint256)")), a);
`call` returns a boolean indicating whether the invoked function terminated (`true`) or caused an EVM exception (`false`). It is not possible to access the actual data returned (for this we would need to know the encoding and size in advance).
It is possible to adjust the supplied gas with the `.gas()` modifier:
namReg.call.gas(1000000)("register", "MyName");
Similarly, the supplied Ether value can be controlled too:
nameReg.call.value(1 ether)("register", "MyName");
Lastly, these modifiers can be combined. Their order does not matter:
nameReg.call.gas(1000000).value(1 ether)("register", "MyName");
Note
It is not yet possible to use the gas or value modifiers on overloaded functions.
A workaround is to introduce a special case for gas and value and just re-check whether they are present at the point of overload resolution.
In a similar way, the function `delegatecall` can be used: the difference is that only the code of the given address is used, all other aspects (storage, balance, …) are taken from the current contract. The purpose of `delegatecall` is to use library code which is stored in another contract. The user has to ensure that the layout of storage in both contracts is suitable for delegatecall to be used. Prior to homestead, only a limited variant called `callcode` was available that did not provide access to the original `msg.sender` and `msg.value` values.
All three functions `call`, `delegatecall` and `callcode` are very low-level functions and should only be used as a _last resort_ as they break the type-safety of Solidity.
The `.gas()` option is available on all three methods, while the `.value()` option is not supported for `delegatecall`.
Note
All contracts can be converted to `address` type, so it is possible to query the balance of the current contract using `address(this).balance`.
Note
The use of `callcode` is discouraged and will be removed in the future.
Warning
All these functions are low-level functions and should be used with care. Specifically, any unknown contract might be malicious and if you call it, you hand over control to that contract which could in turn call back into your contract, so be prepared for changes to your state variables when the call returns.
### Fixed-size byte arrays[¶](#fixed-size-byte-arrays "Permalink to this headline")
`bytes1`, `bytes2`, `bytes3`, …, `bytes32`. `byte` is an alias for `bytes1`.
Operators:
* Comparisons: `<=`, `<`, `==`, `!=`, `>=`, `>` (evaluate to `bool`)
* Bit operators: `&`, `|`, `^` (bitwise exclusive or), `~` (bitwise negation), `<<` (left shift), `>>` (right shift)
* Index access: If `x` is of type `bytesI`, then `x[k]` for `0 <= k < I` returns the `k` th byte (read-only).
The shifting operator works with any integer type as right operand (but will return the type of the left operand), which denotes the number of bits to shift by. Shifting by a negative amount will cause a runtime exception.
Members:
* `.length` yields the fixed length of the byte array (read-only).
Note
It is possible to use an array of bytes as `byte[]`, but it is wasting a lot of space, 31 bytes every element, to be exact, when passing in calls. It is better to use `bytes`.
### Dynamically-sized byte array[¶](#dynamically-sized-byte-array "Permalink to this headline")
`bytes`:
Dynamically-sized byte array, see [Arrays](#arrays). Not a value-type!
`string`:
Dynamically-sized UTF-8-encoded string, see [Arrays](#arrays). Not a value-type!
As a rule of thumb, use `bytes` for arbitrary-length raw byte data and `string` for arbitrary-length string (UTF-8) data. If you can limit the length to a certain number of bytes, always use one of `bytes1` to `bytes32` because they are much cheaper.
### Address Literals[¶](#address-literals "Permalink to this headline")
Hexadecimal literals that pass the address checksum test, for example `0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF` are of `address` type. Hexadecimal literals that are between 39 and 41 digits long and do not pass the checksum test produce a warning and are treated as regular rational number literals.
Note
The mixed-case address checksum format is defined in [EIP-55](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md).
### Rational and Integer Literals[¶](#rational-and-integer-literals "Permalink to this headline")
Integer literals are formed from a sequence of numbers in the range 0-9. They are interpreted as decimals. For example, `69` means sixty nine. Octal literals do not exist in Solidity and leading zeros are invalid.
Decimal fraction literals are formed by a `.` with at least one number on one side. Examples include `1.`, `.1` and `1.3`.
Scientific notation is also supported, where the base can have fractions, while the exponent cannot. Examples include `2e10`, `-2e10`, `2e-10`, `2.5e1`.
Number literal expressions retain arbitrary precision until they are converted to a non-literal type (i.e. by using them together with a non-literal expression). This means that computations do not overflow and divisions do not truncate in number literal expressions.
For example, `(2**800 + 1) - 2**800` results in the constant `1` (of type `uint8`) although intermediate results would not even fit the machine word size. Furthermore, `.5 * 8` results in the integer `4` (although non-integers were used in between).
Any operator that can be applied to integers can also be applied to number literal expressions as long as the operands are integers. If any of the two is fractional, bit operations are disallowed and exponentiation is disallowed if the exponent is fractional (because that might result in a non-rational number).
Note
Solidity has a number literal type for each rational number. Integer literals and rational number literals belong to number literal types. Moreover, all number literal expressions (i.e. the expressions that contain only number literals and operators) belong to number literal types. So the number literal expressions `1 + 2` and `2 + 1` both belong to the same number literal type for the rational number three.
Warning
Division on integer literals used to truncate in earlier versions, but it will now convert into a rational number, i.e. `5 / 2` is not equal to `2`, but to `2.5`.
Note
Number literal expressions are converted into a non-literal type as soon as they are used with non-literal expressions. Even though we know that the value of the expression assigned to `b` in the following example evaluates to an integer, but the partial expression `2.5 + a` does not type check so the code does not compile
uint128 a \= 1;
uint128 b \= 2.5 + a + 0.5;
### String Literals[¶](#string-literals "Permalink to this headline")
String literals are written with either double or single-quotes (`"foo"` or `'bar'`). They do not imply trailing zeroes as in C; `"foo"` represents three bytes not four. As with integer literals, their type can vary, but they are implicitly convertible to `bytes1`, …, `bytes32`, if they fit, to `bytes` and to `string`.
String literals support escape characters, such as `\n`, `\xNN` and `\uNNNN`. `\xNN` takes a hex value and inserts the appropriate byte, while `\uNNNN` takes a Unicode codepoint and inserts an UTF-8 sequence.
### Hexadecimal Literals[¶](#hexadecimal-literals "Permalink to this headline")
Hexademical Literals are prefixed with the keyword `hex` and are enclosed in double or single-quotes (`hex"001122FF"`). Their content must be a hexadecimal string and their value will be the binary representation of those values.
Hexademical Literals behave like String Literals and have the same convertibility restrictions.
### Enums[¶](#enums "Permalink to this headline")
Enums are one way to create a user-defined type in Solidity. They are explicitly convertible to and from all integer types but implicit conversion is not allowed. The explicit conversions check the value ranges at runtime and a failure causes an exception. Enums needs at least one member.
pragma solidity ^0.4.16;
contract test {
 enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }
 ActionChoices choice;
 ActionChoices constant defaultChoice \= ActionChoices.GoStraight;
 function setGoStraight() public {
 choice \= ActionChoices.GoStraight;
 }
 // Since enum types are not part of the ABI, the signature of "getChoice"
 // will automatically be changed to "getChoice() returns (uint8)"
 // for all matters external to Solidity. The integer type used is just
 // large enough to hold all enum values, i.e. if you have more values,
 // \`uint16\` will be used and so on.
 function getChoice() public view returns (ActionChoices) {
 return choice;
 }
 function getDefaultChoice() public pure returns (uint) {
 return uint(defaultChoice);
 }
}
### Function Types[¶](#function-types "Permalink to this headline")
Function types are the types of functions. Variables of function type can be assigned from functions and function parameters of function type can be used to pass functions to and return functions from function calls. Function types come in two flavours - _internal_ and _external_ functions:
Internal functions can only be called inside the current contract (more specifically, inside the current code unit, which also includes internal library functions and inherited functions) because they cannot be executed outside of the context of the current contract. Calling an internal function is realized by jumping to its entry label, just like when calling a function of the current contract internally.
External functions consist of an address and a function signature and they can be passed via and returned from external function calls.
Function types are notated as follows:
function (<parameter types\>) {internal|external} \[pure|constant|view|payable\] \[returns (<return types\>)\]
In contrast to the parameter types, the return types cannot be empty - if the function type should not return anything, the whole `returns (<return types>)` part has to be omitted.
By default, function types are internal, so the `internal` keyword can be omitted. In contrast, contract functions themselves are public by default, only when used as the name of a type, the default is internal.
There are two ways to access a function in the current contract: Either directly by its name, `f`, or using `this.f`. The former will result in an internal function, the latter in an external function.
If a function type variable is not initialized, calling it will result in an exception. The same happens if you call a function after using `delete` on it.
If external function types are used outside of the context of Solidity, they are treated as the `function` type, which encodes the address followed by the function identifier together in a single `bytes24` type.
Note that public functions of the current contract can be used both as an internal and as an external function. To use `f` as an internal function, just use `f`, if you want to use its external form, use `this.f`.
Additionally, public (or external) functions also have a special member called `selector`, which returns the [ABI function selector](https://docs.soliditylang.org/en/v0.4.26/abi-spec.html#abi-function-selector):
pragma solidity ^0.4.16;
contract Selector {
 function f() public view returns (bytes4) {
 return this.f.selector;
 }
}
Example that shows how to use internal function types:
pragma solidity ^0.4.16;
library ArrayUtils {
 // internal functions can be used in internal library functions because
 // they will be part of the same code context
 function map(uint\[\] memory self, function (uint) pure returns (uint) f)
 internal
 pure
 returns (uint\[\] memory r)
 {
 r \= new uint\[\](self.length);
 for (uint i \= 0; i < self.length; i++) {
 r\[i\] \= f(self\[i\]);
 }
 }
 function reduce(
 uint\[\] memory self,
 function (uint, uint) pure returns (uint) f
 )
 internal
 pure
 returns (uint r)
 {
 r \= self\[0\];
 for (uint i \= 1; i < self.length; i++) {
 r \= f(r, self\[i\]);
 }
 }
 function range(uint length) internal pure returns (uint\[\] memory r) {
 r \= new uint\[\](length);
 for (uint i \= 0; i < r.length; i++) {
 r\[i\] \= i;
 }
 }
}
contract Pyramid {
 using ArrayUtils for \*;
 function pyramid(uint l) public pure returns (uint) {
 return ArrayUtils.range(l).map(square).reduce(sum);
 }
 function square(uint x) internal pure returns (uint) {
 return x \* x;
 }
 function sum(uint x, uint y) internal pure returns (uint) {
 return x + y;
 }
}
Another example that uses external function types:
pragma solidity ^0.4.22;
contract Oracle {
 struct Request {
 bytes data;
 function(bytes memory) external callback;
 }
 Request\[\] requests;
 event NewRequest(uint);
 function query(bytes data, function(bytes memory) external callback) public {
 requests.push(Request(data, callback));
 emit NewRequest(requests.length \- 1);
 }
 function reply(uint requestID, bytes response) public {
 // Here goes the check that the reply comes from a trusted source
 requests\[requestID\].callback(response);
 }
}
contract OracleUser {
 Oracle constant oracle \= Oracle(0x1234567); // known contract
 function buySomething() {
 oracle.query("USD", this.oracleResponse);
 }
 function oracleResponse(bytes response) public {
 require(
 msg.sender \== address(oracle),
 "Only oracle can call this."
 );
 // Use the data
 }
}
Note
Lambda or inline functions are planned but not yet supported.
## Reference Types[¶](#reference-types "Permalink to this headline")
Complex types, i.e. types which do not always fit into 256 bits have to be handled more carefully than the value-types we have already seen. Since copying them can be quite expensive, we have to think about whether we want them to be stored in **memory** (which is not persisting) or **storage** (where the state variables are held).
### Data location[¶](#data-location "Permalink to this headline")
Every complex type, i.e. _arrays_ and _structs_, has an additional annotation, the “data location”, about whether it is stored in memory or in storage. Depending on the context, there is always a default, but it can be overridden by appending either `storage` or `memory` to the type. The default for function parameters (including return parameters) is `memory`, the default for local variables is `storage` and the location is forced to `storage` for state variables (obviously).
There is also a third data location, `calldata`, which is a non-modifiable, non-persistent area where function arguments are stored. Function parameters (not return parameters) of external functions are forced to `calldata` and behave mostly like `memory`.
Data locations are important because they change how assignments behave: assignments between storage and memory and also to a state variable (even from other state variables) always create an independent copy. Assignments to local storage variables only assign a reference though, and this reference always points to the state variable even if the latter is changed in the meantime. On the other hand, assignments from a memory stored reference type to another memory-stored reference type do not create a copy.
pragma solidity ^0.4.0;
contract C {
 uint\[\] x; // the data location of x is storage
 // the data location of memoryArray is memory
 function f(uint\[\] memoryArray) public {
 x \= memoryArray; // works, copies the whole array to storage
 var y \= x; // works, assigns a pointer, data location of y is storage
 y\[7\]; // fine, returns the 8th element
 y.length \= 2; // fine, modifies x through y
 delete x; // fine, clears the array, also modifies y
 // The following does not work; it would need to create a new temporary /
 // unnamed array in storage, but storage is "statically" allocated:
 // y = memoryArray;
 // This does not work either, since it would "reset" the pointer, but there
 // is no sensible location it could point to.
 // delete y;
 g(x); // calls g, handing over a reference to x
 h(x); // calls h and creates an independent, temporary copy in memory
 }
 function g(uint\[\] storage storageArray) internal {}
 function h(uint\[\] memoryArray) public {}
}
#### Summary[¶](#summary "Permalink to this headline")
Forced data location:
* parameters (not return) of external functions: calldata
* state variables: storage
Default data location:
* parameters (also return) of functions: memory
* all other local variables: storage
### Arrays[¶](#arrays "Permalink to this headline")
Arrays can have a compile-time fixed size or they can be dynamic. For storage arrays, the element type can be arbitrary (i.e. also other arrays, mappings or structs). For memory arrays, it cannot be a mapping and has to be an ABI type if it is an argument of a publicly-visible function.
An array of fixed size `k` and element type `T` is written as `T[k]`, an array of dynamic size as `T[]`. As an example, an array of 5 dynamic arrays of `uint` is `uint[][5]` (note that the notation is reversed when compared to some other languages). To access the second uint in the third dynamic array, you use `x[2][1]` (indices are zero-based and access works in the opposite way of the declaration, i.e. `x[2]` shaves off one level in the type from the right).
Variables of type `bytes` and `string` are special arrays. A `bytes` is similar to `byte[]`, but it is packed tightly in calldata. `string` is equal to `bytes` but does not allow length or index access (for now).
So `bytes` should always be preferred over `byte[]` because it is cheaper.
Note
If you want to access the byte-representation of a string `s`, use `bytes(s).length` / `bytes(s)[7] = 'x';`. Keep in mind that you are accessing the low-level bytes of the UTF-8 representation, and not the individual characters!
It is possible to mark arrays `public` and have Solidity create a [getter](https://docs.soliditylang.org/en/v0.4.26/contracts.html#visibility-and-getters). The numeric index will become a required parameter for the getter.
#### Allocating Memory Arrays[¶](#allocating-memory-arrays "Permalink to this headline")
Creating arrays with variable length in memory can be done using the `new` keyword. As opposed to storage arrays, it is **not** possible to resize memory arrays by assigning to the `.length` member.
pragma solidity ^0.4.16;
contract C {
 function f(uint len) public pure {
 uint\[\] memory a \= new uint\[\](7);
 bytes memory b \= new bytes(len);
 // Here we have a.length == 7 and b.length == len
 a\[6\] \= 8;
 }
}
#### Array Literals / Inline Arrays[¶](#array-literals-inline-arrays "Permalink to this headline")
Array literals are arrays that are written as an expression and are not assigned to a variable right away.
pragma solidity ^0.4.16;
contract C {
 function f() public pure {
 g(\[uint(1), 2, 3\]);
 }
 function g(uint\[3\] \_data) public pure {
 // ...
 }
}
The type of an array literal is a memory array of fixed size whose base type is the common type of the given elements. The type of `[1, 2, 3]` is `uint8[3] memory`, because the type of each of these constants is `uint8`. Because of that, it was necessary to convert the first element in the example above to `uint`. Note that currently, fixed size memory arrays cannot be assigned to dynamically-sized memory arrays, i.e. the following is not possible:
// This will not compile.
pragma solidity ^0.4.0;
contract C {
 function f() public {
 // The next line creates a type error because uint\[3\] memory
 // cannot be converted to uint\[\] memory.
 uint\[\] x \= \[uint(1), 3, 4\];
 }
}
It is planned to remove this restriction in the future but currently creates some complications because of how arrays are passed in the ABI.
#### Members[¶](#members "Permalink to this headline")
**length**:
Arrays have a `length` member to hold their number of elements. Dynamic arrays can be resized in storage (not in memory) by changing the `.length` member. This does not happen automatically when attempting to access elements outside the current length. The size of memory arrays is fixed (but dynamic, i.e. it can depend on runtime parameters) once they are created.
**push**:
Dynamic storage arrays and `bytes` (not `string`) have a member function called `push` that can be used to append an element at the end of the array. The function returns the new length.
Warning
It is not yet possible to use arrays of arrays in external functions.
Warning
Due to limitations of the EVM, it is not possible to return dynamic content from external function calls. The function `f` in `contract C { function f() returns (uint[]) { ... } }` will return something if called from web3.js, but not if called from Solidity.
The only workaround for now is to use large statically-sized arrays.
pragma solidity ^0.4.16;
contract ArrayContract {
 uint\[2\*\*20\] m\_aLotOfIntegers;
 // Note that the following is not a pair of dynamic arrays but a
 // dynamic array of pairs (i.e. of fixed size arrays of length two).
 bool\[2\]\[\] m\_pairsOfFlags;
 // newPairs is stored in memory - the default for function arguments
 function setAllFlagPairs(bool\[2\]\[\] newPairs) public {
 // assignment to a storage array replaces the complete array
 m\_pairsOfFlags \= newPairs;
 }
 function setFlagPair(uint index, bool flagA, bool flagB) public {
 // access to a non-existing index will throw an exception
 m\_pairsOfFlags\[index\]\[0\] \= flagA;
 m\_pairsOfFlags\[index\]\[1\] \= flagB;
 }
 function changeFlagArraySize(uint newSize) public {
 // if the new size is smaller, removed array elements will be cleared
 m\_pairsOfFlags.length \= newSize;
 }
 function clear() public {
 // these clear the arrays completely
 delete m\_pairsOfFlags;
 delete m\_aLotOfIntegers;
 // identical effect here
 m\_pairsOfFlags.length \= 0;
 }
 bytes m\_byteData;
 function byteArrays(bytes data) public {
 // byte arrays ("bytes") are different as they are stored without padding,
 // but can be treated identical to "uint8\[\]"
 m\_byteData \= data;
 m\_byteData.length += 7;
 m\_byteData\[3\] \= byte(8);
 delete m\_byteData\[2\];
 }
 function addFlag(bool\[2\] flag) public returns (uint) {
 return m\_pairsOfFlags.push(flag);
 }
 function createMemoryArray(uint size) public pure returns (bytes) {
 // Dynamic memory arrays are created using \`new\`:
 uint\[2\]\[\] memory arrayOfPairs \= new uint\[2\]\[\](size);
 // Create a dynamic byte array:
 bytes memory b \= new bytes(200);
 for (uint i \= 0; i < b.length; i++)
 b\[i\] \= byte(i);
 return b;
 }
}
### Structs[¶](#structs "Permalink to this headline")
Solidity provides a way to define new types in the form of structs, which is shown in the following example:
pragma solidity ^0.4.11;
contract CrowdFunding {
 // Defines a new type with two fields.
 struct Funder {
 address addr;
 uint amount;
 }
 struct Campaign {
 address beneficiary;
 uint fundingGoal;
 uint numFunders;
 uint amount;
 mapping (uint \=> Funder) funders;
 }
 uint numCampaigns;
 mapping (uint \=> Campaign) campaigns;
 function newCampaign(address beneficiary, uint goal) public returns (uint campaignID) {
 campaignID \= numCampaigns++; // campaignID is return variable
 // Creates new struct and saves in storage. We leave out the mapping type.
 campaigns\[campaignID\] \= Campaign(beneficiary, goal, 0, 0);
 }
 function contribute(uint campaignID) public payable {
 Campaign storage c \= campaigns\[campaignID\];
 // Creates a new temporary memory struct, initialised with the given values
 // and copies it over to storage.
 // Note that you can also use Funder(msg.sender, msg.value) to initialise.
 c.funders\[c.numFunders++\] \= Funder({addr: msg.sender, amount: msg.value});
 c.amount += msg.value;
 }
 function checkGoalReached(uint campaignID) public returns (bool reached) {
 Campaign storage c \= campaigns\[campaignID\];
 if (c.amount < c.fundingGoal)
 return false;
 uint amount \= c.amount;
 c.amount \= 0;
 c.beneficiary.transfer(amount);
 return true;
 }
}
The contract does not provide the full functionality of a crowdfunding contract, but it contains the basic concepts necessary to understand structs. Struct types can be used inside mappings and arrays and they can itself contain mappings and arrays.
It is not possible for a struct to contain a member of its own type, although the struct itself can be the value type of a mapping member. This restriction is necessary, as the size of the struct has to be finite.
Note how in all the functions, a struct type is assigned to a local variable (of the default storage data location). This does not copy the struct but only stores a reference so that assignments to members of the local variable actually write to the state.
Of course, you can also directly access the members of the struct without assigning it to a local variable, as in `campaigns[campaignID].amount = 0`.
## Mappings[¶](#mappings "Permalink to this headline")
Mapping types are declared as `mapping(_KeyType => _ValueType)`. Here `_KeyType` can be almost any type except for a mapping, a dynamically sized array, a contract, an enum and a struct. `_ValueType` can actually be any type, including mappings.
Mappings can be seen as [hash tables](https://en.wikipedia.org/wiki/Hash_table) which are virtually initialized such that every possible key exists and is mapped to a value whose byte-representation is all zeros: a type’s [default value](https://docs.soliditylang.org/en/v0.4.26/control-structures.html#default-value). The similarity ends here, though: The key data is not actually stored in a mapping, only its `keccak256` hash used to look up the value.
Because of this, mappings do not have a length or a concept of a key or value being “set”.
Mappings are only allowed for state variables (or as storage reference types in internal functions).
It is possible to mark mappings `public` and have Solidity create a [getter](https://docs.soliditylang.org/en/v0.4.26/contracts.html#visibility-and-getters). The `_KeyType` will become a required parameter for the getter and it will return `_ValueType`.
The `_ValueType` can be a mapping too. The getter will have one parameter for each `_KeyType`, recursively.
pragma solidity ^0.4.0;
contract MappingExample {
 mapping(address \=> uint) public balances;
 function update(uint newBalance) public {
 balances\[msg.sender\] \= newBalance;
 }
}
contract MappingUser {
 function f() public returns (uint) {
 MappingExample m \= new MappingExample();
 m.update(100);
 return m.balances(this);
 }
}
Note
Mappings are not iterable, but it is possible to implement a data structure on top of them. For an example, see [iterable mapping](https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol).
## Operators Involving LValues[¶](#operators-involving-lvalues "Permalink to this headline")
If `a` is an LValue (i.e. a variable or something that can be assigned to), the following operators are available as shorthands:
`a += e` is equivalent to `a = a + e`. The operators `-=`, `*=`, `/=`, `%=`, `|=`, `&=` and `^=` are defined accordingly. `a++` and `a--` are equivalent to `a += 1` / `a -= 1` but the expression itself still has the previous value of `a`. In contrast, `--a` and `++a` have the same effect on `a` but return the value after the change.
### delete[¶](#delete "Permalink to this headline")
`delete a` assigns the initial value for the type to `a`. I.e. for integers it is equivalent to `a = 0`, but it can also be used on arrays, where it assigns a dynamic array of length zero or a static array of the same length with all elements reset. For structs, it assigns a struct with all members reset.
`delete` has no effect on whole mappings (as the keys of mappings may be arbitrary and are generally unknown). So if you delete a struct, it will reset all members that are not mappings and also recurse into the members unless they are mappings. However, individual keys and what they map to can be deleted.
It is important to note that `delete a` really behaves like an assignment to `a`, i.e. it stores a new object in `a`.
pragma solidity ^0.4.0;
contract DeleteExample {
 uint data;
 uint\[\] dataArray;
 function f() public {
 uint x \= data;
 delete x; // sets x to 0, does not affect data
 delete data; // sets data to 0, does not affect x which still holds a copy
 uint\[\] storage y \= dataArray;
 delete dataArray; // this sets dataArray.length to zero, but as uint\[\] is a complex object, also
 // y is affected which is an alias to the storage object
 // On the other hand: "delete y" is not valid, as assignments to local variables
 // referencing storage objects can only be made from existing storage objects.
 }
}
## Conversions between Elementary Types[¶](#conversions-between-elementary-types "Permalink to this headline")
### Implicit Conversions[¶](#implicit-conversions "Permalink to this headline")
If an operator is applied to different types, the compiler tries to implicitly convert one of the operands to the type of the other (the same is true for assignments). In general, an implicit conversion between value-types is possible if it makes sense semantically and no information is lost: `uint8` is convertible to `uint16` and `int128` to `int256`, but `int8` is not convertible to `uint256` (because `uint256` cannot hold e.g. `-1`). Furthermore, unsigned integers can be converted to bytes of the same or larger size, but not vice-versa. Any type that can be converted to `uint160` can also be converted to `address`.
### Explicit Conversions[¶](#explicit-conversions "Permalink to this headline")
If the compiler does not allow implicit conversion but you know what you are doing, an explicit type conversion is sometimes possible. Note that this may give you some unexpected behaviour so be sure to test to ensure that the result is what you want! Take the following example where you are converting a negative `int8` to a `uint`:
int8 y \= \-3;
uint x \= uint(y);
At the end of this code snippet, `x` will have the value `0xfffff..fd` (64 hex characters), which is -3 in the two’s complement representation of 256 bits.
If a type is explicitly converted to a smaller type, higher-order bits are cut off:
uint32 a \= 0x12345678;
uint16 b \= uint16(a); // b will be 0x5678 now
## Type Deduction[¶](#type-deduction "Permalink to this headline")
For convenience, it is not always necessary to explicitly specify the type of a variable, the compiler automatically infers it from the type of the first expression that is assigned to the variable:
uint24 x \= 0x123;
var y \= x;
Here, the type of `y` will be `uint24`. Using `var` is not possible for function parameters or return parameters.
Warning
The type is only deduced from the first assignment, so the loop in the following snippet is infinite, as `i` will have the type `uint8` and the highest value of this type is smaller than `2000`. `for (var i = 0; i < 2000; i++) { ... }`

# [Solidity Brand Guide — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/brand-guide.html) 
 _https://docs.soliditylang.org/en/v0.8.30/brand-guide.html_

This brand guide features information on Solidity’s brand policy and logo usage guidelines.
## The Solidity Brand[](#the-solidity-brand "Link to this heading")
The Solidity programming language is an open-source, community project governed by a core team. The core team is sponsored by the [Ethereum Foundation](https://ethereum.foundation/).
This document aims to provide information about how to best use the Solidity brand name and logo.
We encourage you to read this document carefully before using the brand name or the logo. Your cooperation is highly appreciated!
## Solidity Brand Name[](#solidity-brand-name "Link to this heading")
“Solidity” should be used to refer to the Solidity programming language solely.
Please do not use “Solidity”:
* To refer to any other programming language.
 
* In a way that is misleading or may imply association of unrelated modules, tools, documentation, or other resources with the Solidity programming language.
 
* In ways that confuse the community as to whether the Solidity programming language is open-source and free to use.
 
## Solidity Logo License[](#solidity-logo-license "Link to this heading")
The Solidity logo is distributed and licensed under a [Creative Commons Attribution 4.0 International License](https://creativecommons.org/licenses/by/4.0/).
This is the most permissive Creative Commons license and allows reuse and modifications for any purpose.
You are free to:
* **Share** — Copy and redistribute the material in any medium or format.
 
* **Adapt** — Remix, transform, and build upon the material for any purpose, even commercially.
 
Under the following terms:
* **Attribution** — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests that the Solidity core team endorses you or your use.
 
When using the Solidity logo, please respect the Solidity logo guidelines.
## Solidity Logo Guidelines[](#solidity-logo-guidelines "Link to this heading")
_(Right click on the logo to download it.)_
Please do not:
* Change the ratio of the logo (do not stretch it or cut it).
 
* Change the colors of the logo, unless it is absolutely necessary.
 
## Credits[](#credits "Link to this heading")
This document was, in parts, derived from the [Python Software Foundation Trademark Usage Policy](https://www.python.org/psf/trademarks/) and the [Rust Media Guide](https://www.rust-lang.org/policies/media-guide).

# [Solidity — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/) 
 _https://docs.soliditylang.org/tr/latest/_

Uyarı
You are reading a community translation of the Solidity documentation. The Solidity team can give no guarantees on the quality and accuracy of the translations provided. The English reference version is and will remain the only officially supported version by the Solidity team and will always be the most accurate and most up-to-date one. When in doubt, please always refer to the [English (original) documentation](https://docs.soliditylang.org/en/latest/).
Solidity akıllı sözleşmelerin (smart contracts) uygulanması için geliştirilen nesne yönelimli, üst düzey bir programlama dilidir. Akıllı sözleşmeler Ethereum ağı içindeki hesapların hareketlerini ve davranışlarını yöneten programlardır.
Solidity Ethereum Sanal Makinası (ESM) (Ethereum Virtual Machine) hedeflenerek dizayn edilmiş bir [curly-bracket dilidir](https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Curly-bracket_languages). C++, Python ve JavaScript gibi dillerden ilham alınarak oluşturulmuştur. Solidity’nin başka hangi dillerden ilham aldığı hakkındaki detaylı bilgiyi [ilham alınan diller](https://docs.soliditylang.org/tr/latest/language-influences.html) bölümünde bulabilirsiniz.
Solidity statik olarak yazılmış olmasının yanı sıra, kütüphaneleri, kullanıcı tanımlı karmaşık türleri ve kalıtımsallığı destekler.
Solidity’le kullanıcılar için oylama, crowdfunding, blind auctions ve çoklu-imza cüzdanları gibi kullanımlara yönelik akıllı sözleşmeler oluşturabilirsiniz.
Sözleşmelerin gönderimini yaparken, en son yayınlanan Solidity sürümünü kullanmalısınız. İstisnai durumlar dışında, yalnızca son sürüm [güvenlik düzeltmeleri](https://github.com/ethereum/solidity/security/policy#supported-versions) güncellemelerini alır. Ayrıca, önemli değişikliklerinin yanı sıra yeni özellikler düzenli olarak tanıtılmaktadır. Bu hızlı [değişimleri belirtmek için](https://semver.org/#spec-item-4) bir 0.y.z sürüm numarası kullanıyoruz.
İpucu
Solidity kısa bir süre önce birçok yenilik ve önemli değişiklikler getiren 0.8.x sürümünü yayınladı. Değişiklikleri mutlaka okuyun [tam liste](https://docs.soliditylang.org/tr/latest/080-breaking-changes.html).
Solidity’yi veya bu dokümantasyonu geliştirmek için fikirlere her zaman açığız, Daha fazla ayrıntı için [katkıda bulunanlar rehberi](https://docs.soliditylang.org/tr/latest/contributing.html) sayfamızı okuyun.
Uyarı
Bu belgeyi, sol alt köşedeki sürümler menüsüne tıklayarak ve tercih edilen indirme biçimini seçerek PDF, HTML veya Epub olarak indirebilirsiniz.
## Hadi Başlayalım[](#hadi-baslayalim "Permalink to this heading")
**1\. Akıllı Sözleşmelerin Temellerini Anlama**
Eğer akıllı sözleşmeler kavramında yeniyseniz “Akıllı Sözleşmelere Giriş” bölümünü araştırarak başlamanızı öneririz. Bu bölüm aşağıdakileri kapsar:
* Solidity ile yazılmış [Basit bir akıllı sözleşme örneği](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#simple-smart-contract).
 
* [Blockchain Temelleri](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#blockchain-basics).
 
* [Ethereum Sanal Makinası (Ethereum Virtual Machine)](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#the-ethereum-virtual-machine).
 
**2\. Solidity ile Tanışın**
Temel bilgilere alıştıktan sonra, [“Örneklerle Solidity”](https://docs.soliditylang.org/tr/latest/solidity-by-example.html) bölümünü okumanızı öneririz. Ve ayrıca “Dil Tanımları” bölümünü inceleyerek dilin temel kavramlarını anlayabilirsiniz..
**3\. Solidity Derleyicisini İndirme**
Solidity derleyicisini indirmenin birçok yolu vardır, tercih edeceğiniz yola göre [indirme sayfası](https://docs.soliditylang.org/tr/latest/installing-solidity.html#installing-solidity) ‘da bulunan adımları izleyin.
İpucu
[Remix IDE](https://remix.ethereum.org/) ile birlikte kod örneklerini doğrudan tarayıcınızda deneyebilirsiniz. Remix, Solidity’yi yerel olarak yüklemenize gerek kalmadan Solidity akıllı sözleşmelerini yazmanıza, dağıtmanıza ve yönetmenize olanak tanıyan web tarayıcısı tabanlı bir IDE’dir.
Uyarı
İnsanlar kodlama yaparken, hataları olabilir. Akıllı sözleşmelerinizi yazarken belirlenmiş en iyi yazılım geliştirme uygulamalarını izlemelisiniz. Buna kod incelemesi, kodunuzu test etme, denetimler ve correctness proofs dahildir. Akıllı sözleşme kullanıcıları bazen kod konusunda yazarlarından daha emin olabilirler, blockchain ve akıllı sözleşmelerin dikkat edilmesi gereken kendine özgü sorunları vardır, bu nedenle üretim kodu(production code) üzerinde çalışmadan önce [Güvenlikle İlgili Değerlendirmeler](https://docs.soliditylang.org/tr/latest/security-considerations.html#security-considerations) bölümünü okuduğunuzdan emin olun.
**4\. Daha Fazla Bilgi Edinin**
Ethereum ağı üzerinde merkeziyetsiz uygulamalar oluşturma hakkında daha fazla bilgi edinmek istiyorsanız, [Ethereum Geliştirici Kaynakları](https://ethereum.org/en/developers/) size Ethereum ile ilgili daha fazla genel dokümantasyon, çok çeşitli öğreticiler, araçlar ve framework’ler(Yazılım iskeleti) konusunda yardımcı olabilir.
Eğer herhangi bir sorunuz varsa, [Ethereum StackExchange](https://ethereum.stackexchange.com/), veya [Gitter kanalımıza](https://gitter.im/ethereum/solidity/) sorabilirsiniz.
## Çeviriler[](#ceviriler "Permalink to this heading")
Topluluk’tan bazı gönüllüler bu belgeyi farklı dillere çevirmemize yardımcı oluyor. Bu sebeple çevirilerin farklı derecelerde bütünlük ve güncelliğe sahip olduğunu unutmayın. İngilizce versiyonunu referans olarak alın.
Sol alt köşedeki açılır menüye tıklayarak ve tercih ettiğiniz dili seçerek diller arasında geçiş yapabilirsiniz.
* [Fransızce](https://docs.soliditylang.org/fr/latest/)
 
* [Endonezya Dili](https://github.com/solidity-docs/id-indonesian)
 
* [Farsça](https://github.com/solidity-docs/fa-persian)
 
* [Japonca](https://github.com/solidity-docs/ja-japanese)
 
* [Korece](https://github.com/solidity-docs/ko-korean)
 
* [Çince](https://github.com/solidity-docs/zh-cn-chinese/)
 
Not
Kısa süre önce topluluk çalışmalarını kolaylaştırmak ve düzene koymak için yeni bir GitHub organizasyonu ve çeviri için bir iş akışı(workflow) kurduk. Yeni bir dile nasıl başlayacağınız veya var olan çevirilere nasıl katkıda bulunacağınız hakkında bilgi için lütfen [çeviri kılavuzuna](https://github.com/solidity-docs/translation-guide) bakın.

# [Credits and Attribution — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/credits-and-attribution.html) 
 _https://docs.soliditylang.org/en/latest/credits-and-attribution.html_

* [](https://docs.soliditylang.org/en/latest/index.html)
* Credits and Attribution
* [Edit on GitHub](https://github.com/ethereum/solidity/blob/develop/docs/credits-and-attribution.rst)
* * *
## Website icons[](#website-icons "Link to this heading")
Icon
Attribution
* Source: [share icon](https://fontawesome.com/v5.15/icons/share?style=solid) from Font Awesome 5.15.0.
 
* License: [Font Awesome Free License](https://fontawesome.com/license/free) (CC BY 4.0).

# [速查表 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html) 
 _https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html_

## 速查表[](#id1 "此标题的永久链接")
## 操作符的优先顺序[](#index-0 "此标题的永久链接")
以下是按评估顺序列出的操作符优先级。
优先级
描述
操作符
_1_
后置自增和自减
`++`， `--`
创建类型实例
`new <类型名>`
数组元素
`<数组>[<索引>]`
访问成员
`<对象>.<成员名>`
函数调用
`<函数>(<参数...>)`
小括号
`(<表达式>)`
_2_
前置自增和自减
`++`， `--`
一元运算减
`-`
一元操作符
`delete`
逻辑非
`!`
按位非
`~`
_3_
乘方
`**`
_4_
乘、除和模运算
`*`， `/`， `%`
_5_
算术加和减
`+`， `-`
_6_
移位操作符
`<<`， `>>`
_7_
按位与
`&`
_8_
按位异或
`^`
_9_
按位或
`|`
_10_
非等操作符
`<`， `>`， `<=`， `>=`
_11_
等于操作符
`==`， `!=`
_12_
逻辑与
`&&`
_13_
逻辑或
`==`
_14_
三元操作符
`<判断条件> ? <如果为真时执行的表达式> : <如果为假时执行的表达式>`
赋值操作符
`=`， `|=`， `^=`， `&=`， `<<=`， `>>=`， `+=`， `-=`， `*=`， `/=`， `%=`
_15_
逗号
`,`
## ABI 编码和解码函数[](#abi "此标题的永久链接")
* `abi.decode(bytes memory encodedData, (...)) returns (...)`： [ABI](https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi) - 对提供的数据进行解码。类型在括号中作为第二个参数给出。 示例： `(uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))`
 
* `abi.encode(...) returns (bytes memory)`： [ABI](https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi) - 对给定的参数进行编码。
 
* `abi.encodePacked(...) returns (bytes memory)`： 对给定的参数执行 [紧密打包](https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi-packed-mode)。 请注意，这种编码可能是不明确的!
 
* `abi.encodeWithSelector(bytes4 selector, ...) returns (bytes memory)`： [ABI](https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi) - 对给定参数进行编码， 并以给定的函数选择器作为起始的 4 字节数据一起返回
 
* `abi.encodeCall(function functionPointer, (...)) returns (bytes memory)`： 对 `functionPointer` 的调用进行ABI编码， 参数在元组中找到。执行全面的类型检查，确保类型与函数签名相符。结果等于 `abi.encodeWithSelector(functionPointer.selector(..))`。
 
* `abi.encodeWithSignature(string memory signature, ...) returns (bytes memory)`： 等价于 `abi.encodeWithSelector(bytes4(keccak256(bytes(signature))), ...)`
 
## `bytes` 和 `string` 的成员方法[](#bytes-string "此标题的永久链接")
* `bytes.concat(...) returns (bytes memory)`： [将可变数量的参数连接成一个字节数组](https://docs.soliditylang.org/zh-cn/latest/types.html#bytes-concat)。
 
* `string.concat(...) returns (string memory)`： [将可变数量的参数连接成一个字符串数组](https://docs.soliditylang.org/zh-cn/latest/types.html#string-concat)。
 
## `address` 的成员方法[](#address "此标题的永久链接")
* `<address>.balance` (`uint256`)： [地址类型](https://docs.soliditylang.org/zh-cn/latest/types.html#address) 的余额，以 Wei 为单位
 
* `<address>.code` (`bytes memory`)： 在 [地址类型](https://docs.soliditylang.org/zh-cn/latest/types.html#address) 的代码（可以是空的）。
 
* `<address>.codehash` (`bytes32`)： [地址类型](https://docs.soliditylang.org/zh-cn/latest/types.html#address) 的代码哈希值。
 
* `<address>.call(bytes memory) returns (bool, bytes memory)`： 用给定的数据执行低阶 `CALL`， 返回执行结果和执行后返回的数据
 
* `<address>.delegatecall(bytes memory) returns (bool, bytes memory)`: 用给定的数据执行低阶 `DELEGATECALL`, 返回执行结果和执行后返回的数据
 
* `<address>.staticcall(bytes memory) returns (bool, bytes memory)`: 用给定的数据执行低阶 `STATICCALL`, 返回执行结果和执行后返回的数据
 
* `<address payable>.send(uint256 amount) returns (bool)`： 向 [地址类型](https://docs.soliditylang.org/zh-cn/latest/types.html#address) 发送给定数量的 Wei，失败时返回 `false`
 
* `<address payable>.transfer(uint256 amount)`： 向 [地址类型](https://docs.soliditylang.org/zh-cn/latest/types.html#address) 发送给定数量的 Wei，失败时会抛出错误
 
## 区块和交易属性[](#index-5 "此标题的永久链接")
* `blockhash(uint blockNumber) returns (bytes32)`： 给定区块的哈希值 - 只对最近的256个区块有效
 
* `blobhash(uint index) returns (bytes32)`： 与当前交易相关联的第 `index` 个blob。 此带版本的哈希值是由一个表示版本的单字节（当前为 `0x01` ）和紧随其后的KZG证明的SHA256哈希的最后31个字节组成。 （ [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844) ）。
 
* `block.basefee` (`uint`)： 当前区块的基本费用 （ [EIP-3198](https://eips.ethereum.org/EIPS/eip-3198) 和 [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) ）
 
* `block.blobbasefee` (`uint`): 当前区块的blob基础费用（ [EIP-7516](https://eips.ethereum.org/EIPS/eip-7516) 和 [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844)）
 
* `block.chainid` (`uint`)： 当前链的ID
 
* `block.coinbase` (`address payable`)： 当前区块矿工的地址
 
* `block.difficulty` (`uint`)： 当前区块的难度值（ `EVM < Paris` ）。对于其他EVM版本，它是 `block.prevrandao` 的一个废弃的别名，将在下一个重大改变版本中被删除。
 
* `block.gaslimit` (`uint`)： 当前区块的燃料上限
 
* `block.number` (`uint`)： 当前区块的区块号
 
* `block.prevrandao` (`uint`)： 由信标链提供的随机数（ `EVM >= Paris` ）（见 [EIP-4399](https://eips.ethereum.org/EIPS/eip-4399) ）。
 
* `block.timestamp` (`uint`)： 当前区块的时间戳，自Unix epoch以来的秒数
 
* `gasleft() returns (uint256)`： 剩余燃料
 
* `msg.data` (`bytes`)： 完整的调用数据
 
* `msg.sender` (`address`)： 消息发送方（当前调用）
 
* `msg.sig` (`bytes4`)： 调用数据的前四个字节（即函数标识符）。
 
* `msg.value` (`uint`)： 随消息发送的 wei 的数量
 
* `tx.gasprice` (`uint`)： 交易的燃料价格
 
* `tx.origin` (`address`)： 交易发送方（完整调用链上的原始发送方）
 
## 验证和断言[](#index-6 "此标题的永久链接")
* `assert(bool condition)`： 如果条件为 `false`，则中止执行并恢复状态变化（用于内部错误）。
 
* `require(bool condition)`： 如果条件为 `false`，则中止执行并恢复状态变化（用于错误的输入或外部组件的错误）。
 
* `require(bool condition, string memory message)`： 如果条件为 `false`，则中止执行并恢复状态变化（用于错误的输入或外部组件的错误）。同时提供错误信息。
 
* `revert()`： 中止执行并恢复状态变化
 
* `revert(string memory message)`： 中止执行并恢复状态变化，提供一个解释性的字符串
 
## 数学和密码方法[](#index-7 "此标题的永久链接")
* `keccak256(bytes memory) returns (bytes32)`： 计算输入的Keccak-256哈希值
 
* `sha256(bytes memory) returns (bytes32)`： 计算输入的SHA-256哈希值
 
* `ripemd160(bytes memory) returns (bytes20)`： 计算输入的RIPEMD-160的哈希值
 
* `ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)`： 从椭圆曲线签名中恢复与公钥相关的地址，错误时返回0
 
* `addmod(uint x, uint y, uint k) returns (uint)`： 计算 `(x + y) % k` 的值，其中加法的结果即使超过 `2**256` 也不会被截取。 从 0.5.0 版本开始会加入对 `k != 0` 的 assert（即会在此函数开头执行 `assert(k != 0);` 作为参数检查，译者注）。
 
* `mulmod(uint x, uint y, uint k) returns (uint)`： 计算 `(x * y) % k` 的值，其中乘法的结果即使超过 `2**256` 也不会被截取。 从 0.5.0 版本开始会加入对 `k != 0` 的 assert（即会在此函数开头执行 `assert(k != 0);` 作为参数检查，译者注）。
 
## 合约相关方法[](#index-8 "此标题的永久链接")
* `this` （当前合约的类型）： 当前合约，可明确转换为 `address` 或 `address payable`。
 
* `super`： 继承层次中高一级的合约
 
* `selfdestruct(address payable recipient)`： 销毁当前合约，将其资金发送到给定的地址。
 
## 类型相关信息[](#index-9 "此标题的永久链接")
* `type(C).name` (`string`)： 合约的名称
 
* `type(C).creationCode` (`bytes memory`)： 给定合约的创建字节码，参见 [类型信息](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#meta-type)。
 
* `type(C).runtimeCode` (`bytes memory`)： 给定合约的运行时字节码，参见 [类型信息](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#meta-type)。
 
* `type(I).interfaceId` (`bytes4`)： 包含给定接口的EIP-165接口标识符的值，参见 [类型信息](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#meta-type)。
 
* `type(T).min` (`T`)： 整数类型 `T` 所能代表的最小值，参见 [类型信息](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#meta-type)。
 
* `type(T).max` (`T`)： 整数类型 `T` 所能代表的最大值，参见 [类型信息](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#meta-type)。
 
## 函数可见性说明符[](#index-10 "此标题的永久链接")
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=ZnVuY3Rpb24gbXlGdW5jdGlvbigpIDx2aXNpYmlsaXR5IHNwZWNpZmllcj4gcmV0dXJucyAoYm9vbCkgewogICAgcmV0dXJuIHRydWU7Cn0=)
function myFunction() <visibility specifier\> returns (bool) {
 return true;
}
* `public`： 内部、外部均可见（参考为存储/状态变量创建 [getter function](https://docs.soliditylang.org/zh-cn/latest/contracts.html#getter-functions) 函数）
 
* `private`： 仅在当前合约内可见
 
* `external`： 仅在外部可见（仅可修饰函数）——就是说，仅可用于消息调用（即使在合约内调用，也只能通过 `this.func` 的方式）
 
* `internal`： 仅在内部可见（也就是在当前 Solidity 源代码文件内均可见，不仅限于当前合约内，译者注）
 
## 修饰器[](#index-11 "此标题的永久链接")
* `pure` 修饰函数时：不允许修改或访问状态变量。
 
* `view` 修饰函数时：不允许修改状态变量。
 
* `payable` 修饰函数时：允许从调用中接收以太币。
 
* `constant` 修饰状态变量时：不允许赋值（除初始化以外），不会占据存储插槽（storage slot）。
 
* `immutable` 修饰状态变量时：允许在构造时分配并在部署时保持不变。存储在代码中。
 
* `anonymous` 修饰事件时：不把事件签名作为 topic 存储。
 
* `indexed` 修饰事件参数时：将参数作为 topic 存储。
 
* `virtual` 修饰函数和修改时：允许在派生合约中改变函数或修改器的行为。
 
* `override` 表示该函数、修改器或公共状态变量改变了基类合约中的函数或修改器的行为。

# [Solidity par l’exemple — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/solidity-by-example.html) 
 _https://docs.soliditylang.org/fr/latest/solidity-by-example.html_

## Contrat de Vote[](#contrat-de-vote "Lien permanent vers cette rubrique")
Le contrat suivant est assez complexe, mais met en valeur de nombreuses fonctionnalités de Solidity. Il met en place un Contrat de Vote. Bien sûr, les principaux problèmes du vote électronique est la façon d’attribuer des droits de vote au bon personnes et comment prévenir la manipulation. Nous n’allons pas résoudre tous les problèmes ici, mais au moins nous montrerons comment le vote délégué peut être fait pour que le décompte des voix est **automatique et complètement transparent** en même temps.
L’idée est de créer un contrat par scrutin, fournissant un nom court pour chaque option. Ensuite, le créateur du contrat qui sert de président donnera le droit de vote à chacun adresse individuellement.
Les personnes derrière les adresses peuvent alors choisir de voter eux-mêmes ou de déléguer leur vote pour une personne de confiance.
A la fin du temps de vote, `winningProposal()` renverra la proposition avec le plus grand nombre de suffrages.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwovLy8gQHRpdGxlIFZvdGUgYXZlYyBkw6lsw6lnYXRpb24uCmNvbnRyYWN0IEJhbGxvdCB7CiAgICAvLyBDZWNpIGTDqWNsYXJlIHVuIG5vdXZlYXUgdHlwZSBjb21wbGV4ZSBxdWkgdmEKICAgIC8vIMOqdHJlIHV0aWxpc8OpIHBvdXIgbGVzIHZhcmlhYmxlcyBwbHVzIHRhcmQuCiAgICAvLyBJbCByZXByw6lzZW50ZXJhIHVuIHNldWwgw6lsZWN0ZXVyLgogICAgc3RydWN0IFZvdGVyIHsKICAgICAgICB1aW50IHdlaWdodDsgLy8gbGUgcG9pZHMgZXN0IGN1bXVsw6kgcGFyIGTDqWzDqWdhdGlvbgogICAgICAgIGJvb2wgdm90ZWQ7ICAvLyBzaSB2cmFpLCBjZXR0ZSBwZXJzb25uZSBhIGTDqWrDoCB2b3TDqQogICAgICAgIGFkZHJlc3MgZGVsZWdhdGU7IC8vIHBlcnNvbm5lIGTDqWzDqWd1w6llIMOgCiAgICAgICAgdWludCB2b3RlOyAgIC8vIGluZGV4IGRlIGxhIHByb3Bvc2l0aW9uIHZvdMOpZQogICAgfQoKICAgIC8vIElsIHMnYWdpdCBkJ3VuIHR5cGUgcG91ciB1bmUgc2V1bGUgcHJvcG9zaXRpb24uCiAgICBzdHJ1Y3QgUHJvcG9zYWwgewogICAgICAgIGJ5dGVzMzIgbmFtZTsgICAvLyBub20gY291cnQgKGp1c3F1J8OgIDMyIG9jdGV0cykKICAgICAgICB1aW50IHZvdGVDb3VudDsgLy8gbm9tYnJlIGRlIHZvdGVzIGN1bXVsw6lzCiAgICB9CgogICAgYWRkcmVzcyBwdWJsaWMgY2hhaXJwZXJzb247CgogICAgLy8gQ2VjaSBkw6ljbGFyZSB1bmUgdmFyaWFibGUgZCfDqXRhdCBxdWkKICAgIC8vIHN0b2NrZSB1bmUgc3RydWN0dXJlIGBWb3RlcmAgcG91ciBjaGFxdWUgYWRyZXNzZSBwb3NzaWJsZS4KICAgIG1hcHBpbmcoYWRkcmVzcyA9PiBWb3RlcikgcHVibGljIHZvdGVyczsKCiAgICAvLyBVbiB0YWJsZWF1IGRlIHRhaWxsZSBkeW5hbWlxdWUgZGUgc3RydWN0dXJlcyBgUHJvcG9zYWxgLgogICAgUHJvcG9zYWxbXSBwdWJsaWMgcHJvcG9zYWxzOwoKICAgIC8vLyBDcsOpZXogdW4gbm91dmVhdSBidWxsZXRpbiBkZSB2b3RlIHBvdXIgY2hvaXNpciBsJ3VuIGRlcyBgcHJvcG9zYWxOYW1lc2AuCiAgICBjb25zdHJ1Y3RvcihieXRlczMyW10gbWVtb3J5IHByb3Bvc2FsTmFtZXMpIHsKICAgICAgICBjaGFpcnBlcnNvbiA9IG1zZy5zZW5kZXI7CiAgICAgICAgdm90ZXJzW2NoYWlycGVyc29uXS53ZWlnaHQgPSAxOwoKICAgICAgICAvLyBQb3VyIGNoYWN1biBkZXMgbm9tcyBkZSBwcm9wb3NpdGlvbiBmb3VybmlzLAogICAgICAgIC8vIGNyw6llIHVuIG5vdXZlbCBvYmpldCBkZSBwcm9wb3NpdGlvbiBldCBsJ2Fqb3V0ZQogICAgICAgIC8vIMOgIGxhIGZpbiBkdSB0YWJsZWF1LgogICAgICAgIGZvciAodWludCBpID0gMDsgaSA8IHByb3Bvc2FsTmFtZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgLy8gYFByb3Bvc2FsKHsuLi59KWAgY3LDqWUgdW4gdGVtcG9yYWlyZQogICAgICAgICAgICAvLyBPYmpldCBkZSBwcm9wb3NpdGlvbiBldCBgcHJvcG9zYWxzLnB1c2goLi4uKWAKICAgICAgICAgICAgLy8gbCdham91dGUgw6AgbGEgZmluIGRlIGBwcm9wb3NhbHNgLgogICAgICAgICAgICBwcm9wb3NhbHMucHVzaChQcm9wb3NhbCh7CiAgICAgICAgICAgICAgICBuYW1lOiBwcm9wb3NhbE5hbWVzW2ldLAogICAgICAgICAgICAgICAgdm90ZUNvdW50OiAwCiAgICAgICAgICAgIH0pKTsKICAgICAgICB9CiAgICB9CgogICAgLy8gRG9ubmUgw6AgYHZvdGVyYCBsZSBkcm9pdCBkZSB2b3RlciBzdXIgY2UgYnVsbGV0aW4gZGUgdm90ZS4KICAgIC8vIE5lIHBldXQgw6p0cmUgYXBwZWzDqSBxdWUgcGFyIGBjaGFpcnBlcnNvbmAuCiAgICBmdW5jdGlvbiBnaXZlUmlnaHRUb1ZvdGUoYWRkcmVzcyB2b3RlcikgZXh0ZXJuYWwgewogICAgICAgIC8vIFNpIGxlIHByZW1pZXIgYXJndW1lbnQgZGUgYHJlcXVpcmVgIGVzdAogICAgICAgIC8vIGBmYWxzZWAsIGwnZXjDqWN1dGlvbiBzZSB0ZXJtaW5lIGV0IHRvdXQKICAgICAgICAvLyBtb2RpZmljYXRpb25zIGRlIGwnw6l0YXQgZXQgZGVzIHNvbGRlcyBFdGhlcgogICAgICAgIC8vIHNvbnQgYW5udWzDqXMuCiAgICAgICAgLy8gQ2VsYSBjb25zb21tYWl0IHRvdXQgbGUgZ2F6IGRhbnMgbGVzIGFuY2llbm5lcyB2ZXJzaW9ucyBkJ0VWTSwgbWFpcwogICAgICAgIC8vIHBsdXMgbWFpbnRlbmFudC4KICAgICAgICAvLyBDJ2VzdCBzb3V2ZW50IHVuZSBib25uZSBpZMOpZSBkJ3V0aWxpc2VyIGByZXF1aXJlYCBwb3VyIHbDqXJpZmllciBzaQogICAgICAgIC8vIGxlcyBmb25jdGlvbnMgc29udCBhcHBlbMOpZXMgY29ycmVjdGVtZW50LgogICAgICAgIC8vIENvbW1lIGRldXhpw6htZSBhcmd1bWVudCwgdm91cyBwb3V2ZXogw6lnYWxlbWVudCBmb3VybmlyIHVuCiAgICAgICAgLy8gZXhwbGljYXRpb24gZGUgY2UgcXVpIHMnZXN0IG1hbCBwYXNzw6kuCiAgICAgICAgcmVxdWlyZSgKICAgICAgICAgICAgbXNnLnNlbmRlciA9PSBjaGFpcnBlcnNvbiwKICAgICAgICAgICAgIlNldWwgbGUgcHLDqXNpZGVudCBwZXV0IGRvbm5lciBkcm9pdCBkZSB2b3RlLiIKICAgICAgICApOwogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgICF2b3RlcnNbdm90ZXJdLnZvdGVkLAogICAgICAgICAgICAiTCfDqWxlY3RldXIgYSBkw6lqw6Agdm90w6kuIgogICAgICAgICk7CiAgICAgICAgcmVxdWlyZSh2b3RlcnNbdm90ZXJdLndlaWdodCA9PSAwKTsKICAgICAgICB2b3RlcnNbdm90ZXJdLndlaWdodCA9IDE7CiAgICB9CgogICAgLy8vIETDqWzDqWd1ZXogdm90cmUgdm90ZSBhdSB2b3RhbnQgYHRvYC4KICAgIGZ1bmN0aW9uIGRlbGVnYXRlKGFkZHJlc3MgdG8pIGV4dGVybmFsIHsKICAgICAgICAvLyBhdHRyaWJ1ZSB1bmUgcsOpZsOpcmVuY2UKICAgICAgICBWb3RlciBzdG9yYWdlIHNlbmRlciA9IHZvdGVyc1ttc2cuc2VuZGVyXTsKCiAgICAgICAgcmVxdWlyZSghc2VuZGVyLnZvdGVkLCAiVm91cyBhdmV6IGTDqWrDoCB2b3TDqS4iKTsKICAgICAgICByZXF1aXJlKHRvICE9IG1zZy5zZW5kZXIsICJMJ2F1dG9kw6lsw6lnYXRpb24gZXN0IGludGVyZGl0ZS4iKTsKCiAgICAgICAgLy8gVHJhbnNmw6lyZXIgbGEgZMOpbMOpZ2F0aW9uIHRhbnQgcXVlCiAgICAgICAgLy8gYHRvYCDDqWdhbGVtZW50IGTDqWzDqWd1w6kuCiAgICAgICAgLy8gRW4gZ8OpbsOpcmFsLCBkZSB0ZWxsZXMgYm91Y2xlcyBzb250IHRyw6hzIGRhbmdlcmV1c2VzLAogICAgICAgIC8vIHBhcmNlIHF1ZSBzJ2lscyB0b3VybmVudCB0cm9wIGxvbmd0ZW1wcywgaWxzIHBvdXJyYWllbnQKICAgICAgICAvLyBxdm9pciBiZXNvaW4gZGUgcGx1cyBkZSBnYXogcXVlIGNlIHF1aSBlc3QgZGlzcG9uaWJsZSBkYW5zIHVuIGJsb2MuCiAgICAgICAgLy8gRGFucyBjZSBjYXMsIGxhIGTDqWzDqWdhdGlvbiBuZSBzZXJhIHBhcyBleMOpY3V0w6llLAogICAgICAgIC8vIG1haXMgZGFucyBkJ2F1dHJlcyBzaXR1YXRpb25zLCBkZSB0ZWxsZXMgYm91Y2xlcyBwb3VycmFpZW50CiAgICAgICAgLy8gcHJvdm9xdWVyIGxlICJibG9jYWdlIiBjb21wbGV0IGQndW4gY29udHJhdC4KICAgICAgICB3aGlsZSAodm90ZXJzW3RvXS5kZWxlZ2F0ZSAhPSBhZGRyZXNzKDApKSB7CiAgICAgICAgICAgIHRvID0gdm90ZXJzW3RvXS5kZWxlZ2F0ZTsKCiAgICAgICAgICAgIC8vIE5vdXMgYXZvbnMgdHJvdXbDqSB1bmUgYm91Y2xlIGRhbnMgbGEgZMOpbMOpZ2F0aW9uLCBub24gYXV0b3Jpc8OpZS4KICAgICAgICAgICAgcmVxdWlyZSh0byAhPSBtc2cuc2VuZGVyLCAiRm91bmQgbG9vcCBpbiBkZWxlZ2F0aW9uLiIpOwogICAgICAgIH0KCiAgICAgICAgLy8gUHVpc3F1ZSBgc2VuZGVyYCBlc3QgdW5lIHLDqWbDqXJlbmNlLCBjZWxhCiAgICAgICAgLy8gbW9kaWZpZSBgdm90ZXJzW21zZy5zZW5kZXJdLnZvdGVkYAogICAgICAgIHNlbmRlci52b3RlZCA9IHRydWU7CiAgICAgICAgc2VuZGVyLmRlbGVnYXRlID0gdG87CiAgICAgICAgVm90ZXIgc3RvcmFnZSBkZWxlZ2F0ZV8gPSB2b3RlcnNbdG9dOwogICAgICAgIGlmIChkZWxlZ2F0ZV8udm90ZWQpIHsKICAgICAgICAgICAgLy8gU2kgbGUgZMOpbMOpZ3XDqSBhIGTDqWrDoCB2b3TDqSwKICAgICAgICAgICAgLy8gYWpvdXRlciBkaXJlY3RlbWVudCBhdSBub21icmUgZGUgdm90ZXMKICAgICAgICAgICAgcHJvcG9zYWxzW2RlbGVnYXRlXy52b3RlXS52b3RlQ291bnQgKz0gc2VuZGVyLndlaWdodDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAvLyBTaSBsZSBkw6lsw6lndcOpIG4nYSBwYXMgZW5jb3JlIHZvdMOpLAogICAgICAgICAgICAvLyBham91dGUgw6Agc29uIHBvaWRzLgogICAgICAgICAgICBkZWxlZ2F0ZV8ud2VpZ2h0ICs9IHNlbmRlci53ZWlnaHQ7CiAgICAgICAgfQogICAgfQoKICAgIC8vLyBEb25uZXogdm90cmUgdm90ZSAoeSBjb21wcmlzIGxlcyB2b3RlcyBxdWkgdm91cyBzb250IGTDqWzDqWd1w6lzKQogICAgLy8vIMOgIGxhIHByb3Bvc2l0aW9uIGBwcm9wb3NpdGlvbnNbcHJvcG9zaXRpb25dLm5vbWAuCiAgICBmdW5jdGlvbiB2b3RlKHVpbnQgcHJvcG9zYWwpIGV4dGVybmFsIHsKICAgICAgICBWb3RlciBzdG9yYWdlIHNlbmRlciA9IHZvdGVyc1ttc2cuc2VuZGVyXTsKCiAgICAgICAgcmVxdWlyZShzZW5kZXIud2VpZ2h0ICE9IDAsICJOJ2EgcGFzIGxlIGRyb2l0IGRlIHZvdGVyIik7CiAgICAgICAgcmVxdWlyZSghc2VuZGVyLnZvdGVkLCAiRMOpasOgIHZvdMOpLiIpOwoKICAgICAgICBzZW5kZXIudm90ZWQgPSB0cnVlOwogICAgICAgIHNlbmRlci52b3RlID0gcHJvcG9zYWw7CgogICAgICAgIC8vIFNpIGBwcm9wb3NhbGAgZXN0IGhvcnMgZGUgbGEgcGxhZ2UgZHUgdGFibGVhdSwKICAgICAgICAvLyBjZWxhIGxhbmNlcmEgYXV0b21hdGlxdWVtZW50IGV0IGFubnVsZXJhIHRvdXQKICAgICAgICAvLyBjaGFuZ2VtZW50cy4KICAgICAgICBwcm9wb3NhbHNbcHJvcG9zYWxdLnZvdGVDb3VudCArPSBzZW5kZXIud2VpZ2h0OwogICAgfQoKICAgIC8vLyBAZGV2IENhbGN1bGUgbGEgcHJvcG9zaXRpb24gZ2FnbmFudGUgZW4gcHJlbmFudCB0b3VzCiAgICAvLy8gbGVzIHZvdGVzIHByw6ljw6lkZW50cyBlbiBjb21wdGUuCiAgICBmdW5jdGlvbiB3aW5uaW5nUHJvcG9zYWwoKSBwdWJsaWMgdmlldwogICAgICAgICAgICByZXR1cm5zICh1aW50IHdpbm5pbmdQcm9wb3NhbF8pCiAgICB7CiAgICAgICAgdWludCB3aW5uaW5nVm90ZUNvdW50ID0gMDsKICAgICAgICBmb3IgKHVpbnQgcCA9IDA7IHAgPCBwcm9wb3NhbHMubGVuZ3RoOyBwKyspIHsKICAgICAgICAgICAgaWYgKHByb3Bvc2Fsc1twXS52b3RlQ291bnQgPiB3aW5uaW5nVm90ZUNvdW50KSB7CiAgICAgICAgICAgICAgICB3aW5uaW5nVm90ZUNvdW50ID0gcHJvcG9zYWxzW3BdLnZvdGVDb3VudDsKICAgICAgICAgICAgICAgIHdpbm5pbmdQcm9wb3NhbF8gPSBwOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQoKICAgIC8vIEFwcGVsbGUgbGEgZm9uY3Rpb24gd2luUHJvcG9zYWwoKSBwb3VyIG9idGVuaXIgbCdpbmRleAogICAgLy8gZHUgZ2FnbmFudCBjb250ZW51IGRhbnMgbGUgdGFibGVhdSBkZSBwcm9wb3NpdGlvbnMgcHVpcwogICAgLy8gcmVudm9pZSBsZSBub20gZHUgZ2FnbmFudAogICAgZnVuY3Rpb24gd2lubmVyTmFtZSgpIGV4dGVybmFsIHZpZXcKICAgICAgICAgICAgcmV0dXJucyAoYnl0ZXMzMiB3aW5uZXJOYW1lXykKICAgIHsKICAgICAgICB3aW5uZXJOYW1lXyA9IHByb3Bvc2Fsc1t3aW5uaW5nUHJvcG9zYWwoKV0ubmFtZTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
/// @title Vote avec délégation.
contract Ballot {
 // Ceci déclare un nouveau type complexe qui va
 // être utilisé pour les variables plus tard.
 // Il représentera un seul électeur.
 struct Voter {
 uint weight; // le poids est cumulé par délégation
 bool voted; // si vrai, cette personne a déjà voté
 address delegate; // personne déléguée à
 uint vote; // index de la proposition votée
 }
 // Il s'agit d'un type pour une seule proposition.
 struct Proposal {
 bytes32 name; // nom court (jusqu'à 32 octets)
 uint voteCount; // nombre de votes cumulés
 }
 address public chairperson;
 // Ceci déclare une variable d'état qui
 // stocke une structure \`Voter\` pour chaque adresse possible.
 mapping(address \=> Voter) public voters;
 // Un tableau de taille dynamique de structures \`Proposal\`.
 Proposal\[\] public proposals;
 /// Créez un nouveau bulletin de vote pour choisir l'un des \`proposalNames\`.
 constructor(bytes32\[\] memory proposalNames) {
 chairperson \= msg.sender;
 voters\[chairperson\].weight \= 1;
 // Pour chacun des noms de proposition fournis,
 // crée un nouvel objet de proposition et l'ajoute
 // à la fin du tableau.
 for (uint i \= 0; i < proposalNames.length; i++) {
 // \`Proposal({...})\` crée un temporaire
 // Objet de proposition et \`proposals.push(...)\`
 // l'ajoute à la fin de \`proposals\`.
 proposals.push(Proposal({
 name: proposalNames\[i\],
 voteCount: 0
 }));
 }
 }
 // Donne à \`voter\` le droit de voter sur ce bulletin de vote.
 // Ne peut être appelé que par \`chairperson\`.
 function giveRightToVote(address voter) external {
 // Si le premier argument de \`require\` est
 // \`false\`, l'exécution se termine et tout
 // modifications de l'état et des soldes Ether
 // sont annulés.
 // Cela consommait tout le gaz dans les anciennes versions d'EVM, mais
 // plus maintenant.
 // C'est souvent une bonne idée d'utiliser \`require\` pour vérifier si
 // les fonctions sont appelées correctement.
 // Comme deuxième argument, vous pouvez également fournir un
 // explication de ce qui s'est mal passé.
 require(
 msg.sender \== chairperson,
 "Seul le président peut donner droit de vote."
 );
 require(
 !voters\[voter\].voted,
 "L'électeur a déjà voté."
 );
 require(voters\[voter\].weight \== 0);
 voters\[voter\].weight \= 1;
 }
 /// Déléguez votre vote au votant \`to\`.
 function delegate(address to) external {
 // attribue une référence
 Voter storage sender \= voters\[msg.sender\];
 require(!sender.voted, "Vous avez déjà voté.");
 require(to != msg.sender, "L'autodélégation est interdite.");
 // Transférer la délégation tant que
 // \`to\` également délégué.
 // En général, de telles boucles sont très dangereuses,
 // parce que s'ils tournent trop longtemps, ils pourraient
 // qvoir besoin de plus de gaz que ce qui est disponible dans un bloc.
 // Dans ce cas, la délégation ne sera pas exécutée,
 // mais dans d'autres situations, de telles boucles pourraient
 // provoquer le "blocage" complet d'un contrat.
 while (voters\[to\].delegate != address(0)) {
 to \= voters\[to\].delegate;
 // Nous avons trouvé une boucle dans la délégation, non autorisée.
 require(to != msg.sender, "Found loop in delegation.");
 }
 // Puisque \`sender\` est une référence, cela
 // modifie \`voters\[msg.sender\].voted\`
 sender.voted \= true;
 sender.delegate \= to;
 Voter storage delegate\_ \= voters\[to\];
 if (delegate\_.voted) {
 // Si le délégué a déjà voté,
 // ajouter directement au nombre de votes
 proposals\[delegate\_.vote\].voteCount += sender.weight;
 } else {
 // Si le délégué n'a pas encore voté,
 // ajoute à son poids.
 delegate\_.weight += sender.weight;
 }
 }
 /// Donnez votre vote (y compris les votes qui vous sont délégués)
 /// à la proposition \`propositions\[proposition\].nom\`.
 function vote(uint proposal) external {
 Voter storage sender \= voters\[msg.sender\];
 require(sender.weight != 0, "N'a pas le droit de voter");
 require(!sender.voted, "Déjà voté.");
 sender.voted \= true;
 sender.vote \= proposal;
 // Si \`proposal\` est hors de la plage du tableau,
 // cela lancera automatiquement et annulera tout
 // changements.
 proposals\[proposal\].voteCount += sender.weight;
 }
 /// @dev Calcule la proposition gagnante en prenant tous
 /// les votes précédents en compte.
 function winningProposal() public view
 returns (uint winningProposal\_)
 {
 uint winningVoteCount \= 0;
 for (uint p \= 0; p < proposals.length; p++) {
 if (proposals\[p\].voteCount \> winningVoteCount) {
 winningVoteCount \= proposals\[p\].voteCount;
 winningProposal\_ \= p;
 }
 }
 }
 // Appelle la fonction winProposal() pour obtenir l'index
 // du gagnant contenu dans le tableau de propositions puis
 // renvoie le nom du gagnant
 function winnerName() external view
 returns (bytes32 winnerName\_)
 {
 winnerName\_ \= proposals\[winningProposal()\].name;
 }
}
### Améliorations possibles[](#ameliorations-possibles "Lien permanent vers cette rubrique")
Actuellement, de nombreuses transactions sont nécessaires pour céder les droits de voter à tous les participants. Pouvez-vous penser à une meilleure façon?
## Enchères à l’aveugle[](#encheres-a-l-aveugle "Lien permanent vers cette rubrique")
Dans cette section, nous allons montrer à quel point il est facile de créer un smart contrat d’enchères sur Ethereum. Nous allons commencer par un contrat d’enchère où tout le monde peut voir les offres qui sont faites, puis nous étendrons ce contrat pour des d’enchères à aveugles où il n’est pas possible de voir l’offre réelle jusqu’à la fin de la période d’enchères.
### Simple Enchères[](#simple-encheres "Lien permanent vers cette rubrique")
L’idée générale d’une enchères est que chacun peut envoyer ses offres pendant une période d’enchères. Les offres doivent comprendre avec l’envoi un certain nombre Ether pour valider leur enchère. Si l’offre la plus élevée est augmentée, le précédent enchérisseur le plus élevé récupère son argent. Après la fin de la période d’enchères, le contrat doit être appelé manuellement pour que le bénéficiaire reçoive son argent - les contrats ne peuvent pas s’activer eux-mêmes.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKY29udHJhY3QgU2ltcGxlQXVjdGlvbiB7CiAgICAvLyBQYXJhbcOodHJlcyBkZXMgZW5jaMOocmVzLiBMZSB0ZW1wcyBlc3Qgc29pdAogICAgLy8gdW4gdGltZXN0YW1wIHVuaXggKG5vbWJyZXMgZGUgc2Vjb25kZXMgZGVwdWlzIGxlIDAxLTAxLTE5NzApCiAgICAvLyBvdSB1bmUgcMOpcmlvZGUgZW4gc2Vjb25kZXMuCiAgICBhZGRyZXNzIHBheWFibGUgcHVibGljIGJlbmVmaWNpYXJ5OwogICAgdWludCBwdWJsaWMgYXVjdGlvbkVuZFRpbWU7CgogICAgLy8gw4l0YXQgYWN0dWVsIGRlIGwnZW5jaMOocmUuCiAgICBhZGRyZXNzIHB1YmxpYyBoaWdoZXN0QmlkZGVyOwogICAgdWludCBwdWJsaWMgaGlnaGVzdEJpZDsKCiAgICAvLyBMaXN0ZXMgZGUgdG91cyBsZXMgZW5yaWNoaXNzZXVycyBwb3V2YW50IHJldGlyZXIgbGV1cnMgZW5jaMOocmVzCiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gdWludCkgcGVuZGluZ1JldHVybnM7CgogICAgLy8gRMOpZmluaXQgc3VyIGB0cnVlYCDDoCBsYSBmaW4gZGUgbCdlbmNow6hyZSwgcG91ciByZWZ1c2VyIGxlcyBjaGFuZ2VtZW50cwogICAgLy8gQnkgZGVmYXVsdCBpbml0aWFsaXplZCB0byBgZmFsc2VgLgogICAgYm9vbCBlbmRlZDsKCiAgICAvLyBFdsOpbmVtZW50cyBxdWkgdm9udCDDqnRyZSDDqW1pcyBsb3JzIGRlcyBlbmNow6hyZXMgKHBvdXIgdm90cmUgZnJvbnQtZW5kLCBwYXIgZXhlbXBsZSkKICAgIGV2ZW50IEhpZ2hlc3RCaWRJbmNyZWFzZWQoYWRkcmVzcyBiaWRkZXIsIHVpbnQgYW1vdW50KTsKICAgIGV2ZW50IEF1Y3Rpb25FbmRlZChhZGRyZXNzIHdpbm5lciwgdWludCBhbW91bnQpOwoKICAgIC8vIEVycmV1cnMgcXVpIGTDqWNyaXZlbnQgbGVzIHBvdGVudGllbGxlcyBwcm9ibMOobWVzIHJlbmNvbnRyw6lzLgoKICAgIC8vIExlcyBjb21tZW50YWlyZXMgw6AgdHJpcGxlIGJhcnJlIG9ibGlxdWUgc29udCBhcHBlbMOpcyBjb21tZW50YWlyZXMgbmF0c3BlYy4KICAgIC8vIElscyBzZXJvbnQgYWZmaWNow6lzIGxvcnNxdWUgbCd1dGlsaXNhdGV1cgogICAgLy8gZXN0IGludml0w6kgw6AgY29uZmlybWVyIHVuZSB0cmFuc2FjdGlvbiBvdSDDoCBjb25maXJtZXIgdW5lIG9ww6lyYXRpb24uCiAgICAvLyBsb3JzcXUndW5lIGVycmV1ciBlc3QgYWZmaWNow6llLgoKICAgIC8vLyBMJ2VuY2jDqHJlIGVzdCB0ZXJtaW7DqWUuCiAgICBlcnJvciBBdWN0aW9uQWxyZWFkeUVuZGVkKCk7CiAgICAvLy8gSWwgZXhpc3RlIGTDqWrDoCB1bmUgb2ZmcmUgc3Vww6lyaWV1cmUgb3Ugw6lnYWxlLgogICAgZXJyb3IgQmlkTm90SGlnaEVub3VnaCh1aW50IGhpZ2hlc3RCaWQpOwogICAgLy8vIEwnZW5jaMOocmUgbidlc3QgcGFzIGVuY29yZSB0ZXJtaW7DqWUuCiAgICBlcnJvciBBdWN0aW9uTm90WWV0RW5kZWQoKTsKICAgIC8vLyBMYSBmb25jdGlvbiBhdWN0aW9uRW5kIGEgZMOpasOgIMOpdMOpIGFwcGVsw6llLgogICAgZXJyb3IgQXVjdGlvbkVuZEFscmVhZHlDYWxsZWQoKTsKCiAgICAvLy8gQ3LDqWVyIHVuZSBzaW1wbGUgZW5jaMOocmUgYXZlYyBgYmlkZGluZ1RpbWVgCiAgICAvLy8gZW4gc2Vjb25kZXMgYXZhbnQgbGEgZmluIGRlIGwnZW5jaMOocmUgKDM2MDA9MUgpCiAgICAvLy8gZXQgYGJlbmVmaWNpYXJ5QWRkcmVzc2AgYXUgbm9tIGRlIGwnYWRyZXNzZSBsJ2F1dGV1ciBkZSBsJ2VuY2jDqHJlLgogICAgY29uc3RydWN0b3IoCiAgICAgICAgdWludCBiaWRkaW5nVGltZSwKICAgICAgICBhZGRyZXNzIHBheWFibGUgYmVuZWZpY2lhcnlBZGRyZXNzCiAgICApIHsKICAgICAgICBiZW5lZmljaWFyeSA9IGJlbmVmaWNpYXJ5QWRkcmVzczsKICAgICAgICBhdWN0aW9uRW5kVGltZSA9IGJsb2NrLnRpbWVzdGFtcCArIGJpZGRpbmdUaW1lOwogICAgfQoKICAgIC8vLyBFbmNow6lyaXIgc3VyIGwnZW5jaMOocmUgYXZlYyBsYSB2YWxldXIgZW52b3nDqWUKICAgIC8vLyBhdmVjIGNldHRlIHRyYW5zYWN0aW9uLgogICAgLy8vIExhIHZhbGV1ciBuZSBzZXJhIHJlbWJvdXJzw6llIHF1ZSBzaSBsZQogICAgLy8vIGwnZW5jaMOocmUgbidlc3QgcGFzIGdhZ27DqWUuCiAgICBmdW5jdGlvbiBiaWQoKSBleHRlcm5hbCBwYXlhYmxlIHsKICAgICAgICAvLyBBdWN1biBhcmd1bWVudCBuJ2VzdCBuw6ljZXNzYWlyZSwgdG91dGVzCiAgICAgICAgLy8gaW5mb3JtYXRpb25zIGZhaXQgZMOpasOgIHBhcnRpZSBkZQogICAgICAgIC8vIGxhIHRyYW5zYWN0aW9uLiBMZSBtb3QgY2zDqSAicGF5YWJsZSIKICAgICAgICAvLyBlc3QgcmVxdWlzIHBvdXIgcXVlIGxhIGZvbmN0aW9uCiAgICAgICAgLy8gcHVpc3NlIHJlY2V2b2lyIEV0aGVyLgoKICAgICAgICAvLyBSZW52b2llIChyZXZlcnQpIGwnYXBwZWwgc2kgbGEgcMOpZGlvZGUKICAgICAgICAvLyBkZSBsJ2VuY2jDqHJlIGVzdCB0ZXJtaW7DqWUuCiAgICAgICAgaWYgKGJsb2NrLnRpbWVzdGFtcCA+IGF1Y3Rpb25FbmRUaW1lKQogICAgICAgICAgICByZXZlcnQgQXVjdGlvbkFscmVhZHlFbmRlZCgpOwoKICAgICAgICAvLyBTaSBsJ2VuY2jDqHJlIG4nZXN0IHBhcyBwbHVzIMOpbGV2w6llLCBsZQogICAgICAgIC8vIHJlbWJvdXJzZW1lbnQgZXN0IGVudm95w6kKICAgICAgICAvLyAoInJldmVydCIgYW5udWxlcmEgdG91cyBsZXMgY2hhbmdlbWVudHMgIGluY2x1YW50CiAgICAgICAgLy8gbCdhcmdlbnQgcmXDp3UsIHF1aSBzZXJhIGF1dG9tYXRpcXVlbWVudCByZW52b3llciBhdSBwcm9wcmnDqXRhaXJlKS4KICAgICAgICBpZiAobXNnLnZhbHVlIDw9IGhpZ2hlc3RCaWQpCiAgICAgICAgICAgIHJldmVydCBCaWROb3RIaWdoRW5vdWdoKGhpZ2hlc3RCaWQpOwoKICAgICAgICBpZiAoaGlnaGVzdEJpZCAhPSAwKSB7CiAgICAgICAgICAgIC8vIFJlbnZveWVyIGwnYXJnZW50IGVuIHV0aWxpc2FudCBzaW1wbGVtZW50CiAgICAgICAgICAgIC8vICJtb3N0YmlkZGVyLnNlbmQoaGlnaGVzdEJpZCkiIGVzdCB1biByaXNxdWUgZGUgc8OpY3VyaXTDqQogICAgICAgICAgICAvLyBjYXIgaWwgw6dhIHBvdXJyYWl0IGV4w6ljdXRlciB1biBjb250cmF0IG5vbiBmaWFibGUuCiAgICAgICAgICAgIC8vIElsIGVzdCB0b3Vqb3VycyBwbHVzIHPDu3IgZGUgbGFpc3NlciBsZXMgZGVzdGluYXRhaXJlcwogICAgICAgICAgICAvLyByZXRpcmVyIGxldXIgYXJnZW50IGV1eC1tw6ptZXMuCiAgICAgICAgICAgIHBlbmRpbmdSZXR1cm5zW2hpZ2hlc3RCaWRkZXJdICs9IGhpZ2hlc3RCaWQ7CiAgICAgICAgfQogICAgICAgIGhpZ2hlc3RCaWRkZXIgPSBtc2cuc2VuZGVyOwogICAgICAgIGhpZ2hlc3RCaWQgPSBtc2cudmFsdWU7CiAgICAgICAgZW1pdCBIaWdoZXN0QmlkSW5jcmVhc2VkKG1zZy5zZW5kZXIsIG1zZy52YWx1ZSk7CiAgICB9CgogICAgLy8vIFJldGlyZXIgdW5lIGVuY2jDqHJlIHF1aSBhIMOpdMOpIHN1cmVuY2jDqXJpZS4KICAgIGZ1bmN0aW9uIHdpdGhkcmF3KCkgZXh0ZXJuYWwgcmV0dXJucyAoYm9vbCkgewogICAgICAgIHVpbnQgYW1vdW50ID0gcGVuZGluZ1JldHVybnNbbXNnLnNlbmRlcl07CiAgICAgICAgaWYgKGFtb3VudCA+IDApIHsKICAgICAgICAgICAgLy8gSWwgZXN0IGltcG9ydGFudCBkZSByZW1ldHRyZSDDoCB6w6lybyBsJ2VuY2jDqHJlIGR1IGRlc3RpbmF0YWlyZQogICAgICAgICAgICAvLyBjYXIgaWwgcGV1dCByYXBwZWxlciBjZXR0ZSBmb25jdGlvbiBldCByw6ljdXDDqXJlciB1biBzZWNvbmRlIGZvaXMgc29udCBlbmNow6hyZQogICAgICAgICAgICAvLyBwdWlzIHVuZSB0cm9pc2nDqG1lLCBxdWF0cmnDqG1lIGZvaXMuLi4KICAgICAgICAgICAgcGVuZGluZ1JldHVybnNbbXNnLnNlbmRlcl0gPSAwOwoKICAgICAgICAgICAgLy8gbXNnLnNlbmRlciBuJ2VzdCBwYXMgZGUgdHlwZSBgYWRkcmVzcyBwYXlhYmxlYCBtYWlzIGlsIGxlIGRvaXQKICAgICAgICAgICAgLy8gZHUgdHlwZSBhZHJlc3NlIHBheWFibGUgKHBvdXIgZGlyZSDDoCBzb2xpZGl0eSBxdSdpbCBwZXV0IGVudm95ZXIgZGUgbCdhcmdlbnQgZGVzc3VzCiAgICAgICAgICAgIC8vIGdyw6JjZSDDoCBgc2VuZCgpYCkKICAgICAgICAgICAgLy8gTGEgY29udmVydGlvbiBgYWRkcmVzc2AgLT4gYGFkZHJlc3MgcGF5YWJsZWAgcGV1dCBzZSBmYWlyZSBncsOiY2UKICAgICAgICAgICAgLy8gw6AgYHBheWFibGUobXNnLnNlbmRlcilgCiAgICAgICAgICAgIGlmICghcGF5YWJsZShtc2cuc2VuZGVyKS5zZW5kKGFtb3VudCkpIHsKICAgICAgICAgICAgICAgIC8vIFNpIGxhIHR4IG5lIHMnZXhlY3V0ZSBwYXM6CiAgICAgICAgICAgICAgICAvLyBQYXMgYmVzb2luIGRlIHJlbnZveWVyIHVuZSBlcnJldXIgaWNpLCByZW1ldHRleiBqdXN0ZSBsJ2FyZ2VudCDDoCBsJ2VuY2hlcnJpc2V1ciwKICAgICAgICAgICAgICAgIC8vIGlsIHBvdXJyYSByZXZlbmlyIHBsdXMgdGFyZAogICAgICAgICAgICAgICAgcGVuZGluZ1JldHVybnNbbXNnLnNlbmRlcl0gPSBhbW91bnQ7CiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICB9CgogICAgLy8vIFRlcm1pbmV6IGwnZW5jaMOocmUgZXQgZW52b3lleiBsJ29mZnJlIGxhIHBsdXMgw6lsZXbDqWUKICAgIC8vLyBhdSBiw6luw6lmaWNpYWlyZS4KICAgIGZ1bmN0aW9uIGF1Y3Rpb25FbmQoKSBleHRlcm5hbCB7CiAgICAgICAgLy8gQydlc3QgdW4gYm9uIGd1aWRlIHBvdXIgc3RydWN0dXJlciBsZXMgZm9uY3Rpb25zIHF1aSBpbnRlcmFnaXNzZW50CiAgICAgICAgLy8gYXZlYyBkJ2F1dHJlcyBjb250cmF0cyAoYydlc3Qtw6AtZGlyZSBxdSdpbHMgYXBwZWxsZW50IGRlcyBmb25jdGlvbnMgb3UgZW52b2llbnQgZGUgbCdFdGhlcikKICAgICAgICAvLyBlbiB0cm9pcyBwaGFzZXPCoDoKICAgICAgICAvLyAxLiBjb25kaXRpb25zIGRlIHbDqXJpZmljYXRpb24KICAgICAgICAvLyAyLiBlZmZlY3R1ZXIgZGVzIGFjdGlvbnMKICAgICAgICAvLyAzLiBpbnRlcmFjdGlvbiBhdmVjIGQnYXV0cmVzIGNvbnRyYXRzCiAgICAgICAgLy8gU2kgY2VzIHBoYXNlcyBzb250IG3DqWxhbmfDqWVzLCBkJ2F1dHJlIGNvbnRyYXQgcG91cnJhaXQKICAgICAgICAvLyBtb2RpZmllciBsJ8OpdGF0IG91CiAgICAgICAgLy8gcHJlbmRyZSBkZXMgYWN0aW9ucyAocGFpZW1lbnQgZCfDqXRoZXIpIMOgIGVmZmVjdHVlciBwbHVzaWV1cnMgZm9pcy4KICAgICAgICAvLyBTaSBsZXMgZm9uY3Rpb25zIGFwcGVsw6llcyBlbiBpbnRlcm5lIGluY2x1ZW50IGwnaW50ZXJhY3Rpb24gYXZlYyBkZXMKICAgICAgICAvLyBjb250cmF0cywgaWxzIGRvaXZlbnQgw6lnYWxlbWVudCDDqnRyZSBjb25zaWTDqXLDqXMgY29tbWUgdW5lIGludGVyYWN0aW9uIGF2ZWMKICAgICAgICAvLyBkZXMgY29udHJhdHMgZXh0ZXJuZXMuCgogICAgICAgIC8vIDEuIENvbmRpdGlvbnMKICAgICAgICBpZiAoYmxvY2sudGltZXN0YW1wIDwgYXVjdGlvbkVuZFRpbWUpCiAgICAgICAgICAgIHJldmVydCBBdWN0aW9uTm90WWV0RW5kZWQoKTsKICAgICAgICBpZiAoZW5kZWQpCiAgICAgICAgICAgIHJldmVydCBBdWN0aW9uRW5kQWxyZWFkeUNhbGxlZCgpOwoKICAgICAgICAvLyAyLiBFZmZldHMKICAgICAgICBlbmRlZCA9IHRydWU7CiAgICAgICAgZW1pdCBBdWN0aW9uRW5kZWQoaGlnaGVzdEJpZGRlciwgaGlnaGVzdEJpZCk7CgogICAgICAgIC8vIDMuIEludGVyYWN0aW9ucwogICAgICAgIGJlbmVmaWNpYXJ5LnRyYW5zZmVyKGhpZ2hlc3RCaWQpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract SimpleAuction {
 // Paramètres des enchères. Le temps est soit
 // un timestamp unix (nombres de secondes depuis le 01-01-1970)
 // ou une période en secondes.
 address payable public beneficiary;
 uint public auctionEndTime;
 // État actuel de l'enchère.
 address public highestBidder;
 uint public highestBid;
 // Listes de tous les enrichisseurs pouvant retirer leurs enchères
 mapping(address \=> uint) pendingReturns;
 // Définit sur \`true\` à la fin de l'enchère, pour refuser les changements
 // By default initialized to \`false\`.
 bool ended;
 // Evénements qui vont être émis lors des enchères (pour votre front-end, par exemple)
 event HighestBidIncreased(address bidder, uint amount);
 event AuctionEnded(address winner, uint amount);
 // Erreurs qui décrivent les potentielles problèmes rencontrés.
 // Les commentaires à triple barre oblique sont appelés commentaires natspec.
 // Ils seront affichés lorsque l'utilisateur
 // est invité à confirmer une transaction ou à confirmer une opération.
 // lorsqu'une erreur est affichée.
 /// L'enchère est terminée.
 error AuctionAlreadyEnded();
 /// Il existe déjà une offre supérieure ou égale.
 error BidNotHighEnough(uint highestBid);
 /// L'enchère n'est pas encore terminée.
 error AuctionNotYetEnded();
 /// La fonction auctionEnd a déjà été appelée.
 error AuctionEndAlreadyCalled();
 /// Créer une simple enchère avec \`biddingTime\`
 /// en secondes avant la fin de l'enchère (3600=1H)
 /// et \`beneficiaryAddress\` au nom de l'adresse l'auteur de l'enchère.
 constructor(
 uint biddingTime,
 address payable beneficiaryAddress
 ) {
 beneficiary \= beneficiaryAddress;
 auctionEndTime \= block.timestamp + biddingTime;
 }
 /// Enchérir sur l'enchère avec la valeur envoyée
 /// avec cette transaction.
 /// La valeur ne sera remboursée que si le
 /// l'enchère n'est pas gagnée.
 function bid() external payable {
 // Aucun argument n'est nécessaire, toutes
 // informations fait déjà partie de
 // la transaction. Le mot clé "payable"
 // est requis pour que la fonction
 // puisse recevoir Ether.
 // Renvoie (revert) l'appel si la pédiode
 // de l'enchère est terminée.
 if (block.timestamp \> auctionEndTime)
 revert AuctionAlreadyEnded();
 // Si l'enchère n'est pas plus élevée, le
 // remboursement est envoyé
 // ("revert" annulera tous les changements incluant
 // l'argent reçu, qui sera automatiquement renvoyer au propriétaire).
 if (msg.value <= highestBid)
 revert BidNotHighEnough(highestBid);
 if (highestBid != 0) {
 // Renvoyer l'argent en utilisant simplement
 // "mostbidder.send(highestBid)" est un risque de sécurité
 // car il ça pourrait exécuter un contrat non fiable.
 // Il est toujours plus sûr de laisser les destinataires
 // retirer leur argent eux-mêmes.
 pendingReturns\[highestBidder\] += highestBid;
 }
 highestBidder \= msg.sender;
 highestBid \= msg.value;
 emit HighestBidIncreased(msg.sender, msg.value);
 }
 /// Retirer une enchère qui a été surenchérie.
 function withdraw() external returns (bool) {
 uint amount \= pendingReturns\[msg.sender\];
 if (amount \> 0) {
 // Il est important de remettre à zéro l'enchère du destinataire
 // car il peut rappeler cette fonction et récupérer un seconde fois sont enchère
 // puis une troisième, quatrième fois...
 pendingReturns\[msg.sender\] \= 0;
 // msg.sender n'est pas de type \`address payable\` mais il le doit
 // du type adresse payable (pour dire à solidity qu'il peut envoyer de l'argent dessus
 // grâce à \`send()\`)
 // La convertion \`address\` -> \`address payable\` peut se faire grâce
 // à \`payable(msg.sender)\`
 if (!payable(msg.sender).send(amount)) {
 // Si la tx ne s'execute pas:
 // Pas besoin de renvoyer une erreur ici, remettez juste l'argent à l'encherriseur,
 // il pourra revenir plus tard
 pendingReturns\[msg.sender\] \= amount;
 return false;
 }
 }
 return true;
 }
 /// Terminez l'enchère et envoyez l'offre la plus élevée
 /// au bénéficiaire.
 function auctionEnd() external {
 // C'est un bon guide pour structurer les fonctions qui interagissent
 // avec d'autres contrats (c'est-à-dire qu'ils appellent des fonctions ou envoient de l'Ether)
 // en trois phases :
 // 1. conditions de vérification
 // 2. effectuer des actions
 // 3. interaction avec d'autres contrats
 // Si ces phases sont mélangées, d'autre contrat pourrait
 // modifier l'état ou
 // prendre des actions (paiement d'éther) à effectuer plusieurs fois.
 // Si les fonctions appelées en interne incluent l'interaction avec des
 // contrats, ils doivent également être considérés comme une interaction avec
 // des contrats externes.
 // 1. Conditions
 if (block.timestamp < auctionEndTime)
 revert AuctionNotYetEnded();
 if (ended)
 revert AuctionEndAlreadyCalled();
 // 2. Effets
 ended \= true;
 emit AuctionEnded(highestBidder, highestBid);
 // 3. Interactions
 beneficiary.transfer(highestBid);
 }
}
### Blind Auction[](#blind-auction "Lien permanent vers cette rubrique")
Nous allons maintenant étendre ce contract à une enchère à l’aveugle. L’avantage d’une enchère à l’aveugle c’est qu’il n’y a pas de pression temporelle vers la fin de la période d’enchère. La création d’une enchère à l’aveugle sur une plateforme transparente peut sembler contradictoire, mais la cryptographie vient à la rescousse.
Pendant la **période d’enchère**, un enchérisseur n’envoie pas réellement son offre, mais seulement une version hachée de celle-ci. Étant donné qu’il est actuellement considéré comme pratiquement impossible de trouver deux valeurs (suffisamment longues) dont les hash sont égales, l’enchérisseur s’engage à faire son offre par ce biais. À la fin de la période d’enchères, les enchérisseurs doivent révéler leurs offres : Ils envoient leurs valeurs non cryptées et le contrat vérifie que le hash est le même que celui fournie pendant la période d’enchères.
Un autre défi est de savoir comment rendre l’enchère **liante et aveugle** en même temps. La seule façon d’empêcher l’enchérisseur de ne pas envoyer l’argent après avoir remporté l’enchère après avoir remporté l’enchère est de l’obliger à l’envoyer en même temps que l’offre. Puisque les transferts de valeur ne peuvent pas être censurée dans Ethereum, tout le monde peut voir leur valeur.
Le contrat suivant résout ce problème en acceptant toute valeur qui est supérieure à l’offre la plus élevée. Puisque cela ne peut bien sûr être vérifié que pendant la phase de révélation, certaines offres peuvent être **invalides**, et c’est voulu (il y a même un drapeau explicite pour placer des offres invalides avec des transferts de grande valeur) : Les enchérisseurs peuvent confondre la concurrence en plaçant plusieurs offres non valides, hautes ou basses.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKY29udHJhY3QgQmxpbmRBdWN0aW9uIHsKICAgIHN0cnVjdCBCaWQgewogICAgICAgIGJ5dGVzMzIgYmxpbmRlZEJpZDsKICAgICAgICB1aW50IGRlcG9zaXQ7CiAgICB9CgogICAgYWRkcmVzcyBwYXlhYmxlIHB1YmxpYyBiZW5lZmljaWFyeTsKICAgIHVpbnQgcHVibGljIGJpZGRpbmdFbmQ7CiAgICB1aW50IHB1YmxpYyByZXZlYWxFbmQ7CiAgICBib29sIHB1YmxpYyBlbmRlZDsKCiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gQmlkW10pIHB1YmxpYyBiaWRzOwoKICAgIGFkZHJlc3MgcHVibGljIGhpZ2hlc3RCaWRkZXI7CiAgICB1aW50IHB1YmxpYyBoaWdoZXN0QmlkOwoKICAgIC8vIFBlcm1ldHRyZSBsZSByZXRyYWl0IGRlcyBvZmZyZXMgcHLDqWPDqWRlbnRlcwogICAgbWFwcGluZyhhZGRyZXNzID0+IHVpbnQpIHBlbmRpbmdSZXR1cm5zOwoKICAgIGV2ZW50IEF1Y3Rpb25FbmRlZChhZGRyZXNzIHdpbm5lciwgdWludCBoaWdoZXN0QmlkKTsKCiAgICAvLyBFcnJldXJzIHF1aSBkw6ljcml2ZW50IGRlcyDDqWNoZWNzLgoKICAgIC8vLyBMYSBmb25jdGlvbiBhIMOpdMOpIGFwcGVsw6llIHRyb3AgdMO0dC4KICAgIC8vLyBFc3NheWV6IMOgIG5vdXZlYXUgw6AgYHRpbWVgLgogICAgZXJyb3IgVG9vRWFybHkodWludCB0aW1lKTsKICAgIC8vLyBMYSBmb25jdGlvbiBhIMOpdMOpIGFwcGVsw6llIHRyb3AgdGFyZC4KICAgIC8vLyBFbGxlIG5lIHBldXQgcGFzIMOqdHJlIGFwcGVsw6llIGFwcsOocyBgdGltZWAuCiAgICBlcnJvciBUb29MYXRlKHVpbnQgdGltZSk7CiAgICAvLy8gTGEgZm9uY3Rpb24gYXVjdGlvbkVuZCBhIGTDqWrDoCDDqXTDqSBhcHBlbMOpZS4KICAgIGVycm9yIEF1Y3Rpb25FbmRBbHJlYWR5Q2FsbGVkKCk7CgogICAgLy8gTGVzIG1vZGlmaWNhdGV1cnMgc29udCB1biBtb3llbiBwcmF0aXF1ZSBkZSB2YWxpZGVyIGxlcyBlbnRyw6llcyBkZQogICAgLy8gZm9uY3Rpb25zLiBgb25seUJlZm9yZWAgZXN0IGFwcGxpcXXDqSDDoCBgYmlkYCBjaS1kZXNzb3VzIDoKICAgIC8vIExlIG5vdXZlYXUgY29ycHMgZGUgbGEgZm9uY3Rpb24gZXN0IGxlIGNvcnBzIGR1IG1vZGlmaWNhdGV1ciBvw7kKICAgIC8vIGBfYCBlc3QgcmVtcGxhY8OpIHBhciBsJ2FuY2llbiBjb3JwcyBkZSBsYSBmb25jdGlvbi4KICAgIG1vZGlmaWVyIG9ubHlCZWZvcmUodWludCB0aW1lKSB7CiAgICAgICAgaWYgKGJsb2NrLnRpbWVzdGFtcCA+PSB0aW1lKSByZXZlcnQgVG9vTGF0ZSh0aW1lKTsKICAgICAgICBfOwogICAgfQogICAgbW9kaWZpZXIgb25seUFmdGVyKHVpbnQgdGltZSkgewogICAgICAgIGlmIChibG9jay50aW1lc3RhbXAgPD0gdGltZSkgcmV2ZXJ0IFRvb0Vhcmx5KHRpbWUpOwogICAgICAgIF87CiAgICB9CgogICAgY29uc3RydWN0b3IoCiAgICAgICAgdWludCBiaWRkaW5nVGltZSwKICAgICAgICB1aW50IHJldmVhbFRpbWUsCiAgICAgICAgYWRkcmVzcyBwYXlhYmxlIGJlbmVmaWNpYXJ5QWRkcmVzcwogICAgKSB7CiAgICAgICAgYmVuZWZpY2lhcnkgPSBiZW5lZmljaWFyeUFkZHJlc3M7CiAgICAgICAgYmlkZGluZ0VuZCA9IGJsb2NrLnRpbWVzdGFtcCArIGJpZGRpbmdUaW1lOwogICAgICAgIHJldmVhbEVuZCA9IGJpZGRpbmdFbmQgKyByZXZlYWxUaW1lOwogICAgfQoKICAgIC8vLyBQbGFjZXogdW5lIGVuY2jDqHJlIGF2ZXVnbGUgYXZlYyBgYmxpbmRlZEJpZGAgPQogICAgLy8vIGtlY2NhazI1NihhYmkuZW5jb2RlUGFja2VkKHZhbHVlLCBmYWtlLCBzZWNyZXQpKS4KICAgIC8vLyBMJ8OpdGhlciBlbnZvecOpIG4nZXN0IHJlbWJvdXJzw6kgcXVlIHNpIGwnb2ZmcmUgZXN0CiAgICAvLy8gY29ycmVjdGVtZW50IHLDqXbDqWzDqWUgbG9ycyBkZSBsYSBwaGFzZSBkZSByw6l2w6lsYXRpb24uIEwnb2ZmcmUgZXN0IHZhbGlkZSBzaQogICAgLy8vIGwnw6l0aGVyIGVudm95w6kgYXZlYyBsJ29mZnJlIGVzdCBhdSBtb2lucyDDqWdhbCDDoCAidmFsdWUiIGV0IHF1ZQogICAgLy8vICJmYWtlIiBuJ2VzdCBwYXMgdnJhaS4gTWV0dHJlICJmYWtlIiDDoCB0cnVlIGV0IG5lIHBhcyBlbnZveWVyCiAgICAvLy8gbGUgbW9udGFudCBleGFjdCBzb250IGRlcyBtb3llbnMgZGUgY2FjaGVyIGxhIHbDqXJpdGFibGUgZW5jaMOocmUgbWFpcwogICAgLy8vIHRvdXQgZW4gZWZmZWN0dWFudCBsZSBkw6lww7R0IHJlcXVpcy4gVW5lIG3Dqm1lIGFkcmVzc2UgcGV1dAogICAgLy8vIHBsYWNlciBwbHVzaWV1cnMgZW5jaMOocmVzLgogICAgZnVuY3Rpb24gYmlkKGJ5dGVzMzIgYmxpbmRlZEJpZCkKICAgICAgICBleHRlcm5hbAogICAgICAgIHBheWFibGUKICAgICAgICBvbmx5QmVmb3JlKGJpZGRpbmdFbmQpCiAgICB7CiAgICAgICAgYmlkc1ttc2cuc2VuZGVyXS5wdXNoKEJpZCh7CiAgICAgICAgICAgIGJsaW5kZWRCaWQ6IGJsaW5kZWRCaWQsCiAgICAgICAgICAgIGRlcG9zaXQ6IG1zZy52YWx1ZQogICAgICAgIH0pKTsKICAgIH0KCiAgICAvLy8gUsOpdsOpbGV6IHZvcyBlbmNow6hyZXMgYXZldWdsZXMuIFZvdXMgb2J0aWVuZHJleiB1biByZW1ib3Vyc2VtZW50IHBvdXIgdG91dGVzCiAgICAvLy8gbGVzIG9mZnJlcyBpbnZhbGlkZXMgY29ycmVjdGVtZW50IG1hc3F1w6llcyBldCBwb3VyIHRvdXRlcyBsZXMgb2ZmcmVzIHNhdWYgcG91cgogICAgLy8vIGwnZW5jaMOocmUgbGEgcGx1cyDDqWxldsOpZS4KICAgIGZ1bmN0aW9uIHJldmVhbCgKICAgICAgICB1aW50W10gY2FsbGRhdGEgdmFsdWVzLAogICAgICAgIGJvb2xbXSBjYWxsZGF0YSBmYWtlcywKICAgICAgICBieXRlczMyW10gY2FsbGRhdGEgc2VjcmV0cwogICAgKQogICAgICAgIGV4dGVybmFsCiAgICAgICAgb25seUFmdGVyKGJpZGRpbmdFbmQpCiAgICAgICAgb25seUJlZm9yZShyZXZlYWxFbmQpCiAgICB7CiAgICAgICAgdWludCBsZW5ndGggPSBiaWRzW21zZy5zZW5kZXJdLmxlbmd0aDsKICAgICAgICByZXF1aXJlKHZhbHVlcy5sZW5ndGggPT0gbGVuZ3RoKTsKICAgICAgICByZXF1aXJlKGZha2VzLmxlbmd0aCA9PSBsZW5ndGgpOwogICAgICAgIHJlcXVpcmUoc2VjcmV0cy5sZW5ndGggPT0gbGVuZ3RoKTsKCiAgICAgICAgdWludCByZWZ1bmQ7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgQmlkIHN0b3JhZ2UgYmlkVG9DaGVjayA9IGJpZHNbbXNnLnNlbmRlcl1baV07CiAgICAgICAgICAgICh1aW50IHZhbHVlLCBib29sIGZha2UsIGJ5dGVzMzIgc2VjcmV0KSA9CiAgICAgICAgICAgICAgICAgICAgKHZhbHVlc1tpXSwgZmFrZXNbaV0sIHNlY3JldHNbaV0pOwogICAgICAgICAgICBpZiAoYmlkVG9DaGVjay5ibGluZGVkQmlkICE9IGtlY2NhazI1NihhYmkuZW5jb2RlUGFja2VkKHZhbHVlLCBmYWtlLCBzZWNyZXQpKSkgewogICAgICAgICAgICAgICAgLy8gTCdlbmNow6hyZSBuJ2EgcGFzIMOpdMOpIHLDqWVsbGVtZW50IHLDqXbDqWzDqWUuCiAgICAgICAgICAgICAgICAvLyBOZSBwYXMgcmVtYm91cnNlciBsZSBkw6lww7R0LgogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmVmdW5kICs9IGJpZFRvQ2hlY2suZGVwb3NpdDsKICAgICAgICAgICAgaWYgKCFmYWtlICYmIGJpZFRvQ2hlY2suZGVwb3NpdCA+PSB2YWx1ZSkgewogICAgICAgICAgICAgICAgaWYgKHBsYWNlQmlkKG1zZy5zZW5kZXIsIHZhbHVlKSkKICAgICAgICAgICAgICAgICAgICByZWZ1bmQgLT0gdmFsdWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8gUmVuZHJlIGltcG9zc2libGUgcG91ciBsJ2V4cMOpZGl0ZXVyIGRlIHLDqWNsYW1lciDDoCBub3V2ZWF1CiAgICAgICAgICAgIC8vIGxlIG3Dqm1lIGTDqXDDtHQuCiAgICAgICAgICAgIGJpZFRvQ2hlY2suYmxpbmRlZEJpZCA9IGJ5dGVzMzIoMCk7CiAgICAgICAgfQogICAgICAgIHBheWFibGUobXNnLnNlbmRlcikudHJhbnNmZXIocmVmdW5kKTsKICAgIH0KCiAgICAvLy8gUmV0aXJlciB1bmUgb2ZmcmUgcXVpIGEgw6l0w6kgc3VyZW5jaMOpcmllLgogICAgZnVuY3Rpb24gd2l0aGRyYXcoKSBleHRlcm5hbCB7CiAgICAgICAgdWludCBhbW91bnQgPSBwZW5kaW5nUmV0dXJuc1ttc2cuc2VuZGVyXTsKICAgICAgICBpZiAoYW1vdW50ID4gMCkgewogICAgICAgICAgICAvLyBJbCBlc3QgaW1wb3J0YW50IGRlIG1ldHRyZSBjZXR0ZSB2YWxldXIgw6AgesOpcm8gY2FyIGxlIGRlc3RpbmF0YWlyZQogICAgICAgICAgICAvLyBwZXV0IGFwcGVsZXIgY2V0dGUgZm9uY3Rpb24gw6Agbm91dmVhdSBkYW5zIGxlIGNhZHJlIGRlIGwnYXBwZWwgZGUgcsOpY2VwdGlvbgogICAgICAgICAgICAvLyBhdmFudCBxdWUgYHRyYW5zZmVyYCBuZSByZXZpZW5uZSAodm9pciBsYSByZW1hcnF1ZSBjaS1kZXNzdXMgw6AgcHJvcG9zIGRlcwogICAgICAgICAgICAvLyBjb25kaXRpb25zIC0+IGVmZmV0cyAtPiBpbnRlcmFjdGlvbikuCiAgICAgICAgICAgIHBlbmRpbmdSZXR1cm5zW21zZy5zZW5kZXJdID0gMDsKCiAgICAgICAgICAgIHBheWFibGUobXNnLnNlbmRlcikudHJhbnNmZXIoYW1vdW50KTsKICAgICAgICB9CiAgICB9CgogICAgLy8vIE1ldHRyZSBmaW4gw6AgbCdlbmNow6hyZSBldCBlbnZveWVyIGwnb2ZmcmUgbGEgcGx1cyDDqWxldsOpZQogICAgLy8vIGF1IGLDqW7DqWZpY2lhaXJlLgogICAgZnVuY3Rpb24gYXVjdGlvbkVuZCgpCiAgICAgICAgZXh0ZXJuYWwKICAgICAgICBvbmx5QWZ0ZXIocmV2ZWFsRW5kKQogICAgewogICAgICAgIGlmIChlbmRlZCkgcmV2ZXJ0IEF1Y3Rpb25FbmRBbHJlYWR5Q2FsbGVkKCk7CiAgICAgICAgZW1pdCBBdWN0aW9uRW5kZWQoaGlnaGVzdEJpZGRlciwgaGlnaGVzdEJpZCk7CiAgICAgICAgZW5kZWQgPSB0cnVlOwogICAgICAgIGJlbmVmaWNpYXJ5LnRyYW5zZmVyKGhpZ2hlc3RCaWQpOwogICAgfQoKICAgIC8vIElsIHMnYWdpdCBkJ3VuZSBmb25jdGlvbiAiaW50ZXJuZSIsIGNlIHF1aSBzaWduaWZpZSBxdSdlbGxlCiAgICAvLyBuZSBwZXV0IMOqdHJlIGFwcGVsw6llIHF1J8OgIHBhcnRpciBkdSBjb250cmF0IGx1aS1tw6ptZSAob3Ugw6AgcGFydGlyIGRlCiAgICAvLyBjb250cmF0cyBkw6lyaXbDqXMpLgogICAgZnVuY3Rpb24gcGxhY2VCaWQoYWRkcmVzcyBiaWRkZXIsIHVpbnQgdmFsdWUpIGludGVybmFsCiAgICAgICAgICAgIHJldHVybnMgKGJvb2wgc3VjY2VzcykKICAgIHsKICAgICAgICBpZiAodmFsdWUgPD0gaGlnaGVzdEJpZCkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIGlmIChoaWdoZXN0QmlkZGVyICE9IGFkZHJlc3MoMCkpIHsKICAgICAgICAgICAgLy8gUmVmdW5kIHRoZSBwcmV2aW91c2x5IGhpZ2hlc3QgYmlkZGVyLgogICAgICAgICAgICBwZW5kaW5nUmV0dXJuc1toaWdoZXN0QmlkZGVyXSArPSBoaWdoZXN0QmlkOwogICAgICAgIH0KICAgICAgICBoaWdoZXN0QmlkID0gdmFsdWU7CiAgICAgICAgaGlnaGVzdEJpZGRlciA9IGJpZGRlcjsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract BlindAuction {
 struct Bid {
 bytes32 blindedBid;
 uint deposit;
 }
 address payable public beneficiary;
 uint public biddingEnd;
 uint public revealEnd;
 bool public ended;
 mapping(address => Bid\[\]) public bids;
 address public highestBidder;
 uint public highestBid;
 // Permettre le retrait des offres précédentes
 mapping(address => uint) pendingReturns;
 event AuctionEnded(address winner, uint highestBid);
 // Erreurs qui décrivent des échecs.
 /// La fonction a été appelée trop tôt.
 /// Essayez à nouveau à \`time\`.
 error TooEarly(uint time);
 /// La fonction a été appelée trop tard.
 /// Elle ne peut pas être appelée après \`time\`.
 error TooLate(uint time);
 /// La fonction auctionEnd a déjà été appelée.
 error AuctionEndAlreadyCalled();
 // Les modificateurs sont un moyen pratique de valider les entrées de
 // fonctions. \`onlyBefore\` est appliqué à \`bid\` ci-dessous :
 // Le nouveau corps de la fonction est le corps du modificateur où
 // \`\_\` est remplacé par l'ancien corps de la fonction.
 modifier onlyBefore(uint time) {
 if (block.timestamp >= time) revert TooLate(time);
 \_;
 }
 modifier onlyAfter(uint time) {
 if (block.timestamp <= time) revert TooEarly(time);
 \_;
 }
 constructor(
 uint biddingTime,
 uint revealTime,
 address payable beneficiaryAddress
 ) {
 beneficiary = beneficiaryAddress;
 biddingEnd = block.timestamp + biddingTime;
 revealEnd = biddingEnd + revealTime;
 }
 /// Placez une enchère aveugle avec \`blindedBid\` =
 /// keccak256(abi.encodePacked(value, fake, secret)).
 /// L'éther envoyé n'est remboursé que si l'offre est
 /// correctement révélée lors de la phase de révélation. L'offre est valide si
 /// l'éther envoyé avec l'offre est au moins égal à "value" et que
 /// "fake" n'est pas vrai. Mettre "fake" à true et ne pas envoyer
 /// le montant exact sont des moyens de cacher la véritable enchère mais
 /// tout en effectuant le dépôt requis. Une même adresse peut
 /// placer plusieurs enchères.
 function bid(bytes32 blindedBid)
 external
 payable
 onlyBefore(biddingEnd)
 {
 bids\[msg.sender\].push(Bid({
 blindedBid: blindedBid,
 deposit: msg.value
 }));
 }
 /// Révélez vos enchères aveugles. Vous obtiendrez un remboursement pour toutes
 /// les offres invalides correctement masquées et pour toutes les offres sauf pour
 /// l'enchère la plus élevée.
 function reveal(
 uint\[\] calldata values,
 bool\[\] calldata fakes,
 bytes32\[\] calldata secrets
 )
 external
 onlyAfter(biddingEnd)
 onlyBefore(revealEnd)
 {
 uint length = bids\[msg.sender\].length;
 require(values.length == length);
 require(fakes.length == length);
 require(secrets.length == length);
 uint refund;
 for (uint i = 0; i < length; i++) {
 Bid storage bidToCheck = bids\[msg.sender\]\[i\];
 (uint value, bool fake, bytes32 secret) =
 (values\[i\], fakes\[i\], secrets\[i\]);
 if (bidToCheck.blindedBid != keccak256(abi.encodePacked(value, fake, secret))) {
 // L'enchère n'a pas été réellement révélée.
 // Ne pas rembourser le dépôt.
 continue;
 }
 refund += bidToCheck.deposit;
 if (!fake && bidToCheck.deposit >= value) {
 if (placeBid(msg.sender, value))
 refund -= value;
 }
 // Rendre impossible pour l'expéditeur de réclamer à nouveau
 // le même dépôt.
 bidToCheck.blindedBid = bytes32(0);
 }
 payable(msg.sender).transfer(refund);
 }
 /// Retirer une offre qui a été surenchérie.
 function withdraw() external {
 uint amount = pendingReturns\[msg.sender\];
 if (amount > 0) {
 // Il est important de mettre cette valeur à zéro car le destinataire
 // peut appeler cette fonction à nouveau dans le cadre de l'appel de réception
 // avant que \`transfer\` ne revienne (voir la remarque ci-dessus à propos des
 // conditions -> effets -> interaction).
 pendingReturns\[msg.sender\] = 0;
 payable(msg.sender).transfer(amount);
 }
 }
 /// Mettre fin à l'enchère et envoyer l'offre la plus élevée
 /// au bénéficiaire.
 function auctionEnd()
 external
 onlyAfter(revealEnd)
 {
 if (ended) revert AuctionEndAlreadyCalled();
 emit AuctionEnded(highestBidder, highestBid);
 ended = true;
 beneficiary.transfer(highestBid);
 }
 // Il s'agit d'une fonction "interne", ce qui signifie qu'elle
 // ne peut être appelée qu'à partir du contrat lui-même (ou à partir de
 // contrats dérivés).
 function placeBid(address bidder, uint value) internal
 returns (bool success)
 {
 if (value <= highestBid) {
 return false;
 }
 if (highestBidder != address(0)) {
 // Refund the previously highest bidder.
 pendingReturns\[highestBidder\] += highestBid;
 }
 highestBid = value;
 highestBidder = bidder;
 return true;
 }
}
## Achat à distance sécurisé[](#achat-a-distance-securise "Lien permanent vers cette rubrique")
L’achat de biens à distance nécessite actuellement plusieurs parties qui doivent se faire confiance. La configuration la plus simple implique un vendeur et un acheteur. L’acheteur souhaite recevoir un article du vendeur et le vendeur souhaite obtenir de l’argent (ou un équivalent) en retour. La partie problématique est l’expédition ici : il n’y a aucun moyen de déterminer pour sûr que l’article est arrivé à l’acheteur.
Il existe plusieurs façons de résoudre ce problème, mais toutes échouent d’une manière ou d’une autre. Dans l’exemple suivant, les deux parties doivent mettre deux fois la valeur de l’article dans le contrat en tant qu’entiercement. Dès que cela s’est produit, l’argent restera enfermé à l’intérieur le contrat jusqu’à ce que l’acheteur confirme qu’il a bien reçu l’objet. Après ça, l’acheteur reçoit la valeur (la moitié de son acompte) et le vendeur reçoit trois fois la valeur (leur dépôt plus la valeur). L’idée derrière c’est que les deux parties ont une incitation à résoudre la situation ou autrement leur argent est verrouillé pour toujours.
Bien entendu, ce contrat ne résout pas le problème, mais donne un aperçu de la manière dont vous pouvez utiliser des constructions de type machine d’état dans un contrat.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKY29udHJhY3QgUHVyY2hhc2UgewogICAgdWludCBwdWJsaWMgdmFsdWU7CiAgICBhZGRyZXNzIHBheWFibGUgcHVibGljIHNlbGxlcjsKICAgIGFkZHJlc3MgcGF5YWJsZSBwdWJsaWMgYnV5ZXI7CgogICAgZW51bSBTdGF0ZSB7IENyZWF0ZWQsIExvY2tlZCwgUmVsZWFzZSwgSW5hY3RpdmUgfQogICAgLy8gTGEgdmFyaWFibGUgZCfDqXRhdCBhIHVuZSB2YWxldXIgcGFyIGTDqWZhdXQgZHUgcHJlbWllciBtZW1icmUsIGBTdGF0ZS5jcmVhdGVkYAogICAgU3RhdGUgcHVibGljIHN0YXRlOwoKICAgIG1vZGlmaWVyIGNvbmRpdGlvbihib29sIGNvbmRpdGlvbl8pIHsKICAgICAgICByZXF1aXJlKGNvbmRpdGlvbl8pOwogICAgICAgIF87CiAgICB9CgogICAgLy8vIFNldWwgbCdhY2hldGV1ciBwZXV0IGFwcGVsZXIgY2V0dGUgZm9uY3Rpb24uCiAgICBlcnJvciBPbmx5QnV5ZXIoKTsKICAgIC8vLyBTZXVsIGxlIHZlbmRldXIgcGV1dCBhcHBlbGVyIGNldHRlIGZvbmN0aW9uLgogICAgZXJyb3IgT25seVNlbGxlcigpOwogICAgLy8vIExhIGZvbmN0aW9uIG5lIHBldXQgcGFzIMOqdHJlIGFwcGVsw6llIMOgIGwnw6l0YXQgYWN0dWVsLgogICAgZXJyb3IgSW52YWxpZFN0YXRlKCk7CiAgICAvLy8gTGEgdmFsZXVyIGZvdXJuaWUgZG9pdCDDqnRyZSBwYWlyZS4KICAgIGVycm9yIFZhbHVlTm90RXZlbigpOwoKICAgIG1vZGlmaWVyIG9ubHlCdXllcigpIHsKICAgICAgICBpZiAobXNnLnNlbmRlciAhPSBidXllcikKICAgICAgICAgICAgcmV2ZXJ0IE9ubHlCdXllcigpOwogICAgICAgIF87CiAgICB9CgogICAgbW9kaWZpZXIgb25seVNlbGxlcigpIHsKICAgICAgICBpZiAobXNnLnNlbmRlciAhPSBzZWxsZXIpCiAgICAgICAgICAgIHJldmVydCBPbmx5U2VsbGVyKCk7CiAgICAgICAgXzsKICAgIH0KCiAgICBtb2RpZmllciBpblN0YXRlKFN0YXRlIHN0YXRlXykgewogICAgICAgIGlmIChzdGF0ZSAhPSBzdGF0ZV8pCiAgICAgICAgICAgIHJldmVydCBJbnZhbGlkU3RhdGUoKTsKICAgICAgICBfOwogICAgfQoKICAgIGV2ZW50IEFib3J0ZWQoKTsKICAgIGV2ZW50IFB1cmNoYXNlQ29uZmlybWVkKCk7CiAgICBldmVudCBJdGVtUmVjZWl2ZWQoKTsKICAgIGV2ZW50IFNlbGxlclJlZnVuZGVkKCk7CgogICAgLy8gQXNzdXJlei12b3VzIHF1ZSBgbXNnLnZhbHVlYCBlc3QgdW4gbm9tYnJlIHBhaXIuCiAgICAvLyBMYSBkaXZpc2lvbiBzZXJhIHRyb25xdcOpZSBzaSBjJ2VzdCB1biBub21icmUgaW1wYWlyLgogICAgLy8gVsOpcmlmaWUgcGFyIG11bHRpcGxpY2F0aW9uIHF1J2lsIG5lIHMnYWdpdCBwYXMgZCd1biBub21icmUgaW1wYWlyLgogICAgY29uc3RydWN0b3IoKSBwYXlhYmxlIHsKICAgICAgICBzZWxsZXIgPSBwYXlhYmxlKG1zZy5zZW5kZXIpOwogICAgICAgIHZhbHVlID0gbXNnLnZhbHVlIC8gMjsKICAgICAgICBpZiAoKDIgKiB2YWx1ZSkgIT0gbXNnLnZhbHVlKQogICAgICAgICAgICByZXZlcnQgVmFsdWVOb3RFdmVuKCk7CiAgICB9CgogICAgLy8vIEFiYW5kb25uZXogbCdhY2hhdCBldCByw6ljdXDDqXJleiBsJ8OpdGhlci4KICAgIC8vLyBOZSBwZXV0IMOqdHJlIGFwcGVsw6kgcXVlIHBhciBsZSB2ZW5kZXVyIGF2YW50CiAgICAvLy8gbGUgY29udHJhdCBlc3QgdmVycm91aWxsw6kuCiAgICBmdW5jdGlvbiBhYm9ydCgpCiAgICAgICAgZXh0ZXJuYWwKICAgICAgICBvbmx5U2VsbGVyCiAgICAgICAgaW5TdGF0ZShTdGF0ZS5DcmVhdGVkKQogICAgewogICAgICAgIGVtaXQgQWJvcnRlZCgpOwogICAgICAgIHN0YXRlID0gU3RhdGUuSW5hY3RpdmU7CiAgICAgICAgLy8gTm91cyB1dGlsaXNvbnMgZGlyZWN0ZW1lbnQgbGUgdHJhbnNmZXJ0IGljaS4gSWwgZXN0CiAgICAgICAgLy8gYW50aS1yw6llbnRyYW5jZSwgY2FyIGMnZXN0IGxlCiAgICAgICAgLy8gZGVybmllciBhcHBlbCBkYW5zIGNldHRlIGZvbmN0aW9uIGV0IG5vdXMKICAgICAgICAvLyBhIGTDqWrDoCBjaGFuZ8OpIGwnw6l0YXQuCiAgICAgICAgc2VsbGVyLnRyYW5zZmVyKGFkZHJlc3ModGhpcykuYmFsYW5jZSk7CiAgICB9CgogICAgLy8vIENvbmZpcm1leiBsJ2FjaGF0IGVuIHRhbnQgcXUnYWNoZXRldXIuCiAgICAvLy8gTGEgdHJhbnNhY3Rpb24gZG9pdCBpbmNsdXJlIGAyICogdmFsdWVgIGV0aGVyLgogICAgLy8vIEwnw6l0aGVyIHNlcmEgdmVycm91aWxsw6kganVzcXUnw6AgY29uZmlybWF0aW9uUmVjZWl2ZWQKICAgIC8vLyBzb2l0IGFwcGVsw6kuCiAgICBmdW5jdGlvbiBjb25maXJtUHVyY2hhc2UoKQogICAgICAgIGV4dGVybmFsCiAgICAgICAgaW5TdGF0ZShTdGF0ZS5DcmVhdGVkKQogICAgICAgIGNvbmRpdGlvbihtc2cudmFsdWUgPT0gKDIgKiB2YWx1ZSkpCiAgICAgICAgcGF5YWJsZQogICAgewogICAgICAgIGVtaXQgUHVyY2hhc2VDb25maXJtZWQoKTsKICAgICAgICBidXllciA9IHBheWFibGUobXNnLnNlbmRlcik7CiAgICAgICAgc3RhdGUgPSBTdGF0ZS5Mb2NrZWQ7CiAgICB9CgogICAgLy8vIENvbmZpcm1leiBxdWUgdm91cyAobCdhY2hldGV1cikgYXZleiByZcOndSBsJ2FydGljbGUuCiAgICAvLy8gQ2VsYSBsaWLDqXJlcmEgbCfDqXRoZXIgdmVycm91aWxsw6kuCiAgICBmdW5jdGlvbiBjb25maXJtUmVjZWl2ZWQoKQogICAgICAgIGV4dGVybmFsCiAgICAgICAgb25seUJ1eWVyCiAgICAgICAgaW5TdGF0ZShTdGF0ZS5Mb2NrZWQpCiAgICB7CiAgICAgICAgZW1pdCBJdGVtUmVjZWl2ZWQoKTsKICAgICAgICAvLyBJbCBlc3QgaW1wb3J0YW50IGRlIGNoYW5nZXIgZCdhYm9yZCBsJ8OpdGF0IGNhcgogICAgICAgIC8vIHNpbm9uLCBsZXMgY29udHJhdHMgYXBwZWzDqXMgZW4gdXRpbGlzYW50IGBzZW5kYCBjaS1kZXNzb3VzCiAgICAgICAgLy8gcGV1dCByYXBwZWxlciBpY2kuCiAgICAgICAgc3RhdGUgPSBTdGF0ZS5SZWxlYXNlOwoKICAgICAgICBidXllci50cmFuc2Zlcih2YWx1ZSk7CiAgICB9CgogICAgLy8vIENldHRlIGZvbmN0aW9uIHJlbWJvdXJzZSBsZSB2ZW5kZXVyLCBjJ2VzdC3DoC1kaXJlCiAgICAvLy8gcmVtYm91cnNlIGxlcyBmb25kcyBibG9xdcOpcyBkdSB2ZW5kZXVyLgogICAgZnVuY3Rpb24gcmVmdW5kU2VsbGVyKCkKICAgICAgICBleHRlcm5hbAogICAgICAgIG9ubHlTZWxsZXIKICAgICAgICBpblN0YXRlKFN0YXRlLlJlbGVhc2UpCiAgICB7CiAgICAgICAgZW1pdCBTZWxsZXJSZWZ1bmRlZCgpOwogICAgICAgIC8vIElsIGVzdCBpbXBvcnRhbnQgZGUgY2hhbmdlciBkJ2Fib3JkIGwnw6l0YXQgY2FyCiAgICAgICAgLy8gc2lub24sIGxlcyBjb250cmF0cyBhcHBlbMOpcyBlbiB1dGlsaXNhbnQgYHNlbmRgIGNpLWRlc3NvdXMKICAgICAgICAvLyBwZXV0IHJhcHBlbGVyIGljaS4KICAgICAgICBzdGF0ZSA9IFN0YXRlLkluYWN0aXZlOwoKICAgICAgICBzZWxsZXIudHJhbnNmZXIoMyAqIHZhbHVlKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract Purchase {
 uint public value;
 address payable public seller;
 address payable public buyer;
 enum State { Created, Locked, Release, Inactive }
 // La variable d'état a une valeur par défaut du premier membre, \`State.created\`
 State public state;
 modifier condition(bool condition\_) {
 require(condition\_);
 \_;
 }
 /// Seul l'acheteur peut appeler cette fonction.
 error OnlyBuyer();
 /// Seul le vendeur peut appeler cette fonction.
 error OnlySeller();
 /// La fonction ne peut pas être appelée à l'état actuel.
 error InvalidState();
 /// La valeur fournie doit être paire.
 error ValueNotEven();
 modifier onlyBuyer() {
 if (msg.sender != buyer)
 revert OnlyBuyer();
 \_;
 }
 modifier onlySeller() {
 if (msg.sender != seller)
 revert OnlySeller();
 \_;
 }
 modifier inState(State state\_) {
 if (state != state\_)
 revert InvalidState();
 \_;
 }
 event Aborted();
 event PurchaseConfirmed();
 event ItemReceived();
 event SellerRefunded();
 // Assurez-vous que \`msg.value\` est un nombre pair.
 // La division sera tronquée si c'est un nombre impair.
 // Vérifie par multiplication qu'il ne s'agit pas d'un nombre impair.
 constructor() payable {
 seller \= payable(msg.sender);
 value \= msg.value / 2;
 if ((2 \* value) != msg.value)
 revert ValueNotEven();
 }
 /// Abandonnez l'achat et récupérez l'éther.
 /// Ne peut être appelé que par le vendeur avant
 /// le contrat est verrouillé.
 function abort()
 external
 onlySeller
 inState(State.Created)
 {
 emit Aborted();
 state \= State.Inactive;
 // Nous utilisons directement le transfert ici. Il est
 // anti-réentrance, car c'est le
 // dernier appel dans cette fonction et nous
 // a déjà changé l'état.
 seller.transfer(address(this).balance);
 }
 /// Confirmez l'achat en tant qu'acheteur.
 /// La transaction doit inclure \`2 \* value\` ether.
 /// L'éther sera verrouillé jusqu'à confirmationReceived
 /// soit appelé.
 function confirmPurchase()
 external
 inState(State.Created)
 condition(msg.value \== (2 \* value))
 payable
 {
 emit PurchaseConfirmed();
 buyer \= payable(msg.sender);
 state \= State.Locked;
 }
 /// Confirmez que vous (l'acheteur) avez reçu l'article.
 /// Cela libérera l'éther verrouillé.
 function confirmReceived()
 external
 onlyBuyer
 inState(State.Locked)
 {
 emit ItemReceived();
 // Il est important de changer d'abord l'état car
 // sinon, les contrats appelés en utilisant \`send\` ci-dessous
 // peut rappeler ici.
 state \= State.Release;
 buyer.transfer(value);
 }
 /// Cette fonction rembourse le vendeur, c'est-à-dire
 /// rembourse les fonds bloqués du vendeur.
 function refundSeller()
 external
 onlySeller
 inState(State.Release)
 {
 emit SellerRefunded();
 // Il est important de changer d'abord l'état car
 // sinon, les contrats appelés en utilisant \`send\` ci-dessous
 // peut rappeler ici.
 state \= State.Inactive;
 seller.transfer(3 \* value);
 }
}
## Canal de micropaiement[](#canal-de-micropaiement "Lien permanent vers cette rubrique")
Dans cette section, nous allons apprendre à construire un exemple d’implémentation d’un canal de paiement. Il utilisera des signatures cryptographiques pour faire des transferts répétés d’Ether entre les mêmes parties sécurisés, instantanés et sans frais de transaction. Pour l’exemple, nous devons comprendre comment signer et vérifier les signatures, et configurer le canal de paiement.
### Création et vérification de signatures[](#creation-et-verification-de-signatures "Lien permanent vers cette rubrique")
Imaginez qu’Alice veuille envoyer de l’éther à Bob, c’est-à-dire Alice est l’expéditeur et Bob est le destinataire.
Alice n’a besoin que d’envoyer des messages signés cryptographiquement off-chain (exemple: par e-mail) à Bob et c’est similaire à la rédaction de chèques.
Alice et Bob utilisent des signatures pour autoriser les transactions, ce qui est possible avec les Smart Contract d’Ethereum. Alice construira un simple Smart Contract qui lui permettra de transmettre Ether, mais au lieu d’appeler elle-même une fonction pour initier un paiement, elle laissera Bob le faire, qui paiera donc les frais de transaction.
Le contrat fonctionnera comme ça:
> 1. Alice déploie le contrat `ReceiverPays`, avec suffisamment d’Ether pour couvrir les paiements qui seront effectués.
> 
> 2. Alice autorise un paiement en signant un message avec sa clé privée.
> 
> 3. Alice envoie le message signé cryptographiquement à Bob. Le message n’a pas besoin d’être gardé secret
> 
> (expliqué plus loin), et le mécanisme pour l’envoyer n’a pas d’importance.
> 
> 4. Bob réclame son paiement en présentant le message signé au smart contract, celui-ci vérifie le
> 
> l’authenticité du message, puis débloque les fonds.
> 
#### Création de la signature:[](#creation-de-la-signature "Lien permanent vers cette rubrique")
Alice n’a pas besoin d’interagir avec le réseau Ethereum pour signer la transaction, le processus est complètement hors ligne. Dans ce tutoriel, nous allons signer des messages dans le navigateur en utilisant [web3.js](https://github.com/ethereum/web3.js) et [MetaMask](https://metamask.io/), avec la methode decrite dans l”[EIP-712](https://github.com/ethereum/EIPs/pull/712), car il offre un certain nombre d’autres avantages en matière de sécurité.
/// Hasher en premier, va nous facilité les choses
const hash \= web3.utils.sha3("message to sign");
web3.eth.personal.sign(hash, web3.eth.defaultAccount, function () { console.log("Signed"); });
Note
Le `web3.eth.personal.sign` ajoute la longueur du message aux données signées. Puisque nous hachons d’abord, le message fera toujours exactement 32 octets, et donc cette longueur le préfixe est toujours le même.
#### Quoi signer ?[](#quoi-signer "Lien permanent vers cette rubrique")
Pour qu’un contrat exécute des paiements, le message signé doit inclure :
> 1. L’adresse du destinataire.
> 
> 2. Le montant à transférer.
> 
> 3. Protection contre les attaques par rejeu (replay attacks in English).
> 
[\*](#id1)Une attaque par rejeu se produit lorsqu’un message signé est réutilisé pour réclamer une seconde fois l’autorisation de la même action (exemple: réenvoyer le même montant d’Eth). Pour éviter ces attaques nous utilisons la même technique que dans les transactions Ethereum elles-mêmes, le fameux `nonce`, qui est le nombre de transactions envoyées par un compte. Le Smart Contract vérifie si le nonce est utilisé plusieurs fois.
Un autre type d’attaque par rejeu peut se produire lorsque le propriétaire déploie un Smart Contract `ReceiverPays`, fait quelques paiements, puis détruit le contrat. Plus tard, ils décident de déployer à nouveau le Smart Contract `RecipientPays`, mais le nouveau contrat ne connaît pas les nonces utilisés dans le précédent déploiement, donc les attaquants peuvent à nouveau utiliser les anciens messages.
Alice peut se protéger contre cette attaque en incluant le l’adresse du contrat dans le message, et seuls les messages contenant l’adresse du contrat seront acceptés. Tu peux trouver un exemple de ceci dans les deux premières lignes de la fonction `claimPayment()` du contrat complet à la fin de cette section.
#### Packing arguments[](#packing-arguments "Lien permanent vers cette rubrique")
Maintenant que nous avons identifié les informations à inclure dans le message signé, nous sommes prêts à construire le message, à le hacher et à le signer. Par question de simplicité, nous concaténons les données. Le [ethereumjs-abi](https://github.com/ethereumjs/ethereumjs-abi) fournit une fonction appelée `soliditySHA3` qui imite le comportement de la fonction `keccak256` de Solidity en appliquant aux arguments encodés la fonction `abi.encodePacked`. Voici une fonction JavaScript qui crée la bonne signature pour l’exemple `ReceiverPays` :
// le "recipient" est l'adresse qui doit être payée.
// Le "amount" est en wei et spécifie la quantité d'éther à envoyer.
// "nonce" peut être n'importe quel nombre unique pour empêcher les attaques par rejeu
// "contractAddress" est utilisé pour empêcher les attaques de relecture de contrats croisés
function signPayment(recipient, amount, nonce, contractAddress, callback) {
 var hash \= "0x" + abi.soliditySHA3(
 \["address", "uint256", "uint256", "address"\],
 \[recipient, amount, nonce, contractAddress\]
 ).toString("hex");
 web3.eth.personal.sign(hash, web3.eth.defaultAccount, callback);
}
#### Récupération du signataire du message dans Solidity[](#recuperation-du-signataire-du-message-dans-solidity "Lien permanent vers cette rubrique")
En général, les signatures ECDSA se composent de deux paramètres, `r` et `s`. Les signatures dans Ethereum incluent un troisième paramètre appelé `v`, que vous pouvez utiliser pour vérifier quel clé privée du compte a été utilisée pour signer le message, et l’expéditeur de la transaction. Solidity fournit une fonction ecrecover qui accepte un message avec les paramètres `r`, `s` et `v` et renvoie l’adresse qui a été utilisée pour signer le message.
#### Haché le message[](#hache-le-message "Lien permanent vers cette rubrique")
Le Smart Contract doit savoir exactement quels paramètres ont été signés, et donc il doit recréer le message à partir des paramètres et l’utiliser pour la vérification de la signature. Les fonctions `prefixed` et `recoverSigner` le font dans la fonction `claimPayment`.
#### Le contrat complet[](#le-contrat-complet "Lien permanent vers cette rubrique")
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwpjb250cmFjdCBSZWNlaXZlclBheXMgewogICAgYWRkcmVzcyBvd25lciA9IG1zZy5zZW5kZXI7CgogICAgbWFwcGluZyh1aW50MjU2ID0+IGJvb2wpIHVzZWROb25jZXM7CgogICAgY29uc3RydWN0b3IoKSBwYXlhYmxlIHt9CgogICAgZnVuY3Rpb24gY2xhaW1QYXltZW50KHVpbnQyNTYgYW1vdW50LCB1aW50MjU2IG5vbmNlLCBieXRlcyBtZW1vcnkgc2lnbmF0dXJlKSBleHRlcm5hbCB7CiAgICAgICAgcmVxdWlyZSghdXNlZE5vbmNlc1tub25jZV0pOwogICAgICAgIHVzZWROb25jZXNbbm9uY2VdID0gdHJ1ZTsKCiAgICAgICAgLy8gY2VjaSByZWNyw6llIGxlIG1lc3NhZ2UgcXVpIGEgw6l0w6kgc2lnbsOpIHN1ciBsZSBjbGllbnQKICAgICAgICBieXRlczMyIG1lc3NhZ2UgPSBwcmVmaXhlZChrZWNjYWsyNTYoYWJpLmVuY29kZVBhY2tlZChtc2cuc2VuZGVyLCBhbW91bnQsIG5vbmNlLCB0aGlzKSkpOwoKICAgICAgICByZXF1aXJlKHJlY292ZXJTaWduZXIobWVzc2FnZSwgc2lnbmF0dXJlKSA9PSBvd25lcik7CgogICAgICAgIHBheWFibGUobXNnLnNlbmRlcikudHJhbnNmZXIoYW1vdW50KTsKICAgIH0KCiAgICAvLy8gZMOpdHJ1aXQgbGUgY29udHJhdCBldCByw6ljdXDDqXJlIGxlcyBmb25kcyByZXN0YW50cy4KICAgIGZ1bmN0aW9uIHNodXRkb3duKCkgZXh0ZXJuYWwgewogICAgICAgIHJlcXVpcmUobXNnLnNlbmRlciA9PSBvd25lcik7CiAgICAgICAgc2VsZmRlc3RydWN0KHBheWFibGUobXNnLnNlbmRlcikpOwogICAgfQoKICAgIC8vLyBMYSBtZXRob2QgZGUgc2lnbmF0dXJlLgogICAgZnVuY3Rpb24gc3BsaXRTaWduYXR1cmUoYnl0ZXMgbWVtb3J5IHNpZykKICAgICAgICBpbnRlcm5hbAogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50OCB2LCBieXRlczMyIHIsIGJ5dGVzMzIgcykKICAgIHsKICAgICAgICByZXF1aXJlKHNpZy5sZW5ndGggPT0gNjUpOwoKICAgICAgICBhc3NlbWJseSB7CiAgICAgICAgICAgIC8vIDMyIHByZW1pZXJzIG9jdGV0cywgYXByw6hzIGxlIHByw6lmaXhlIGRlIGxvbmd1ZXVyLgogICAgICAgICAgICByIDo9IG1sb2FkKGFkZChzaWcsIDMyKSkKICAgICAgICAgICAgLy8gMzIgb2N0ZXRzIHN1aXZhbnQuCiAgICAgICAgICAgIHMgOj0gbWxvYWQoYWRkKHNpZywgNjQpKQogICAgICAgICAgICAvLyBEZXJybmllcnMgb2N0ZXRzIChwcmVtaWVyIG9jdGV0IGRlcyAzMiBvY3RldHMgc3VpdmFudHMpLgogICAgICAgICAgICB2IDo9IGJ5dGUoMCwgbWxvYWQoYWRkKHNpZywgOTYpKSkKICAgICAgICB9CgogICAgICAgIHJldHVybiAodiwgciwgcyk7CiAgICB9CgogICAgZnVuY3Rpb24gcmVjb3ZlclNpZ25lcihieXRlczMyIG1lc3NhZ2UsIGJ5dGVzIG1lbW9yeSBzaWcpCiAgICAgICAgaW50ZXJuYWwKICAgICAgICBwdXJlCiAgICAgICAgcmV0dXJucyAoYWRkcmVzcykKICAgIHsKICAgICAgICAodWludDggdiwgYnl0ZXMzMiByLCBieXRlczMyIHMpID0gc3BsaXRTaWduYXR1cmUoc2lnKTsKCiAgICAgICAgcmV0dXJuIGVjcmVjb3ZlcihtZXNzYWdlLCB2LCByLCBzKTsKICAgIH0KCiAgICAvLy8gY29uc3RydWl0IHVuIGhhY2hhZ2UgcHLDqWZpeMOpIHBvdXIgaW1pdGVyIGxlIGNvbXBvcnRlbWVudCBkZSBldGhfc2lnbi4KICAgIGZ1bmN0aW9uIHByZWZpeGVkKGJ5dGVzMzIgaGFzaCkgaW50ZXJuYWwgcHVyZSByZXR1cm5zIChieXRlczMyKSB7CiAgICAgICAgcmV0dXJuIGtlY2NhazI1NihhYmkuZW5jb2RlUGFja2VkKCJceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XG4zMiIsIGhhc2gpKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract ReceiverPays {
 address owner \= msg.sender;
 mapping(uint256 \=> bool) usedNonces;
 constructor() payable {}
 function claimPayment(uint256 amount, uint256 nonce, bytes memory signature) external {
 require(!usedNonces\[nonce\]);
 usedNonces\[nonce\] \= true;
 // ceci recrée le message qui a été signé sur le client
 bytes32 message \= prefixed(keccak256(abi.encodePacked(msg.sender, amount, nonce, this)));
 require(recoverSigner(message, signature) \== owner);
 payable(msg.sender).transfer(amount);
 }
 /// détruit le contrat et récupére les fonds restants.
 function shutdown() external {
 require(msg.sender \== owner);
 selfdestruct(payable(msg.sender));
 }
 /// La method de signature.
 function splitSignature(bytes memory sig)
 internal
 pure
 returns (uint8 v, bytes32 r, bytes32 s)
 {
 require(sig.length \== 65);
 assembly {
 // 32 premiers octets, après le préfixe de longueur.
 r :\= mload(add(sig, 32))
 // 32 octets suivant.
 s :\= mload(add(sig, 64))
 // Derrniers octets (premier octet des 32 octets suivants).
 v :\= byte(0, mload(add(sig, 96)))
 }
 return (v, r, s);
 }
 function recoverSigner(bytes32 message, bytes memory sig)
 internal
 pure
 returns (address)
 {
 (uint8 v, bytes32 r, bytes32 s) \= splitSignature(sig);
 return ecrecover(message, v, r, s);
 }
 /// construit un hachage préfixé pour imiter le comportement de eth\_sign.
 function prefixed(bytes32 hash) internal pure returns (bytes32) {
 return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));
 }
}
### Écrire un canal de paiement simplifié[](#ecrire-un-canal-de-paiement-simplifie "Lien permanent vers cette rubrique")
Alice construit maintenant une implémentation simple mais complète d’un paiement canaliser. Les canaux de paiement utilisent des signatures cryptographiques pour effectuer transferts répétés d’Ether en toute sécurité, instantanément et sans frais de transaction.
#### Qu’est-ce qu’un canal de paiement ?[](#qu-est-ce-qu-un-canal-de-paiement "Lien permanent vers cette rubrique")
Les canaux de paiement permettent aux participants d’effectuer des transferts répétés d’Ether sans utiliser de transactions. Cela signifie que vous pouvez éviter les retards et les frais liés aux transactions. Nous allons explorer un simple canal de paiement unidirectionnel entre deux parties (Alice et Bob). Cela implique trois étapes :
> 1. Alice finance un contrat intelligent avec Ether. Cela « ouvre » le canal de paiement.
> 
> 2. Alice signe des messages qui précisent combien de cet Ether est dû au destinataire. Cette étape est répétée pour chaque paiement.
> 
> 3. Bob « ferme » le canal de paiement, retire sa part de l’Ether et renvoie le reste à l’expéditeur.
> 
Note
Seules les étapes 1 et 3 nécessitent des transactions Ethereum, l’étape 2 signifie que l’expéditeur transmet un message signé cryptographiquement au destinataire via des méthodes off-chain (exemple: par e-mail). Cela signifie que seules deux transactions sont nécessaires pour prendre en charge n’importe quel nombre de transferts.
Bob est assuré de recevoir ses fonds car le Smart Contract garde l’Ether et honore un message signé valide. Le Smart Contract impose également un délai d’attente, donc Alice est garantie de récupérer éventuellement ses fonds même si le le destinataire refuse de fermer le canal. C’est l’initiateur du paiement qui décide combien de temps il gardera le canal ouvert. Pour une transaction de courte durée, comme payer un cybercafé pour chaque minute d’accès au réseau, le paiement sera maintenu ouvert pendant une durée limitée. En revanche, pour un paiement récurrent, comme le paiement d’un salaire à un employé, le canal de paiement peuvent rester ouverts pendant plusieurs mois ou années.
#### Ouverture du canal de paiement[](#ouverture-du-canal-de-paiement "Lien permanent vers cette rubrique")
Pour ouvrir le canal de paiement, Alice déploie le Smart Contract, attachant l’Ether à garder et en précisant le destinataire prévu et une durée maximale d’existence du canal. C’est la fonction `SimplePaymentChannel` dans le contrat, à la fin de cette section.
#### Effectuer des paiements[](#effectuer-des-paiements "Lien permanent vers cette rubrique")
Alice effectue des paiements en envoyant des messages signés à Bob. Cette étape est effectuée entièrement en dehors du réseau Ethereum. Les messages sont signés cryptographiquement par l’expéditeur, puis transmis directement au destinataire.
Chaque message comprend les informations suivantes :
> * L’adresse du Smart Contract, utilisée pour empêcher les attaques de relecture de contrats croisés.
> 
> * Le montant total d’Ether qui est dû au destinataire jusqu’à présent.
> 
Un canal de paiement n’est fermé qu’une seule fois, à la fin d’une série de virements. Pour cette raison, seul un des messages envoyés est racheté. C’est pourquoi chaque message spécifie un montant total cumulé d’Ether dû, plutôt que le montant du micropaiement individuel. Le destinataire choisira naturellement de racheter le message le plus récent car c’est celui avec le total le plus élevé. Le nonce par message n’est plus nécessaire, car le Smart Contrat n’honore qu’un seul message. L’adresse du contrat intelligent est toujours utilisée pour empêcher qu’un message destiné à un canal de paiement ne soit utilisé pour un autre canal.
Voici le code JavaScript modifié pour signer cryptographiquement un message de la section précédente :
function constructPaymentMessage(contractAddress, amount) {
 return abi.soliditySHA3(
 \["address", "uint256"\],
 \[contractAddress, amount\]
 );
}
function signMessage(message, callback) {
 web3.eth.personal.sign(
 "0x" + message.toString("hex"),
 web3.eth.defaultAccount,
 callback
 );
}
// contractAddress est utilisé pour empêcher les attaques de relecture de contrats croisés.
// Le montant, en wei, spécifie la quantité d'Ether à envoyer.
function signPayment(contractAddress, amount, callback) {
 var message \= constructPaymentMessage(contractAddress, amount);
 signMessage(message, callback);
}
#### Fermeture du canal de paiement[](#fermeture-du-canal-de-paiement "Lien permanent vers cette rubrique")
Lorsque Bob est prêt à recevoir ses fonds, il est temps de fermez le canal de paiement en appelant une fonction `close` sur le Smart Contrat. La fermeture du canal paie au destinataire l’éther qui lui est dû et détruit le contrat, renvoyant tout Ether restant à Alice. À fermer le canal, Bob doit fournir un message signé par Alice.
Le Smart Contrat doit vérifier que le message contient une signature valide de l’expéditeur. Le processus pour effectuer cette vérification est le même que celui utilisé par le destinataire. Les fonctions `isValidSignature` et `recoverSigner` (Solidity) fonctionnent exactement comme leur les fonctions JavaScript dans la section précédente, cette dernière fonction étant empruntée au contrat `ReceiverPays`.
Seul le destinataire du canal de paiement peut appeler la fonction `close`, qui transmet naturellement le message de paiement le plus récent parce que ce message porte le total dû le plus élevé. Si l’expéditeur était autorisé à appeler cette fonction, ils pourraient fournir un message avec un montant inférieur et tromper le destinataire sur ce qui lui est dû.
La fonction vérifie que le message signé correspond aux paramètres donnés. Si tout se vérifie, le destinataire reçoit sa part de l’Ether, et l’expéditeur reçoit le reste via un `selfdestruction`. Vous pouvez voir la fonction `close` dans le contrat complet.
#### Expiration du canal[](#expiration-du-canal "Lien permanent vers cette rubrique")
Bob peut fermer le canal de paiement à tout moment, mais s’il ne le fait pas, Alice a besoin d’un moyen de récupérer ses fonds bloqués. Un délai d”_expiration_ a été défini au moment du déploiement du contrat. Une fois ce délai atteint, Alice peut appeler `claimTimeout` pour récupérer ses fonds. Vous pouvez voir la fonction `claimTimeout` dans le contrat complet.
Après l’appel de cette fonction, Bob ne peut plus recevoir d’Ether, il est donc important que Bob ferme le canal avant que l’expiration ne soit atteinte.
#### Le contrat complet[](#id3 "Lien permanent vers cette rubrique")
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwpjb250cmFjdCBTaW1wbGVQYXltZW50Q2hhbm5lbCB7CiAgICBhZGRyZXNzIHBheWFibGUgcHVibGljIHNlbmRlcjsgICAgICAvLyBUaGUgYWNjb3VudCBzZW5kaW5nIHBheW1lbnRzLgogICAgYWRkcmVzcyBwYXlhYmxlIHB1YmxpYyByZWNpcGllbnQ7ICAgLy8gVGhlIGFjY291bnQgcmVjZWl2aW5nIHRoZSBwYXltZW50cy4KICAgIHVpbnQyNTYgcHVibGljIGV4cGlyYXRpb247ICAvLyBUaW1lb3V0IGluIGNhc2UgdGhlIHJlY2lwaWVudCBuZXZlciBjbG9zZXMuCgogICAgY29uc3RydWN0b3IgKGFkZHJlc3MgcGF5YWJsZSByZWNpcGllbnRBZGRyZXNzLCB1aW50MjU2IGR1cmF0aW9uKQogICAgICAgIHBheWFibGUKICAgIHsKICAgICAgICBzZW5kZXIgPSBwYXlhYmxlKG1zZy5zZW5kZXIpOwogICAgICAgIHJlY2lwaWVudCA9IHJlY2lwaWVudEFkZHJlc3M7CiAgICAgICAgZXhwaXJhdGlvbiA9IGJsb2NrLnRpbWVzdGFtcCArIGR1cmF0aW9uOwogICAgfQoKICAgIC8vLyBsZSBkZXN0aW5hdGFpcmUgcGV1dCBmZXJtZXIgbGUgY2FuYWwgw6AgdG91dCBtb21lbnQgZW4gcHLDqXNlbnRhbnQgdW4KICAgIC8vLyBtb250YW50IHNpZ27DqSBkZSBsJ2V4cMOpZGl0ZXVyLiBsZSBkZXN0aW5hdGFpcmUgcmVjZXZyYSBjZSBtb250YW50LAogICAgLy8vIGV0IGxlIHJlc3RlIHJldmllbmRyYSDDoCBsJ2V4cMOpZGl0ZXVyCiAgICBmdW5jdGlvbiBjbG9zZSh1aW50MjU2IGFtb3VudCwgYnl0ZXMgbWVtb3J5IHNpZ25hdHVyZSkgZXh0ZXJuYWwgewogICAgICAgIHJlcXVpcmUobXNnLnNlbmRlciA9PSByZWNpcGllbnQpOwogICAgICAgIHJlcXVpcmUoaXNWYWxpZFNpZ25hdHVyZShhbW91bnQsIHNpZ25hdHVyZSkpOwoKICAgICAgICByZWNpcGllbnQudHJhbnNmZXIoYW1vdW50KTsKICAgICAgICBzZWxmZGVzdHJ1Y3Qoc2VuZGVyKTsKICAgIH0KCiAgICAvLy8gbCdleHDDqWRpdGV1ciBwZXV0IHByb2xvbmdlciBsJ2V4cGlyYXRpb24gw6AgdG91dCBtb21lbnQKICAgIGZ1bmN0aW9uIGV4dGVuZCh1aW50MjU2IG5ld0V4cGlyYXRpb24pIGV4dGVybmFsIHsKICAgICAgICByZXF1aXJlKG1zZy5zZW5kZXIgPT0gc2VuZGVyKTsKICAgICAgICByZXF1aXJlKG5ld0V4cGlyYXRpb24gPiBleHBpcmF0aW9uKTsKCiAgICAgICAgZXhwaXJhdGlvbiA9IG5ld0V4cGlyYXRpb247CiAgICB9CgogICAgLy8vIHNpIGxlIHRpbWVvdXQgZXN0IGF0dGVpbnQgc2FucyBxdWUgbGUgZGVzdGluYXRhaXJlIGZlcm1lIGxlIGNhbmFsLAogICAgLy8vIHB1aXMgbCdFdGhlciBlc3QgcmVudm95w6kgw6AgbCdleHDDqWRpdGV1ci4KICAgIGZ1bmN0aW9uIGNsYWltVGltZW91dCgpIGV4dGVybmFsIHsKICAgICAgICByZXF1aXJlKGJsb2NrLnRpbWVzdGFtcCA+PSBleHBpcmF0aW9uKTsKICAgICAgICBzZWxmZGVzdHJ1Y3Qoc2VuZGVyKTsKICAgIH0KCiAgICBmdW5jdGlvbiBpc1ZhbGlkU2lnbmF0dXJlKHVpbnQyNTYgYW1vdW50LCBieXRlcyBtZW1vcnkgc2lnbmF0dXJlKQogICAgICAgIGludGVybmFsCiAgICAgICAgdmlldwogICAgICAgIHJldHVybnMgKGJvb2wpCiAgICB7CiAgICAgICAgYnl0ZXMzMiBtZXNzYWdlID0gcHJlZml4ZWQoa2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQodGhpcywgYW1vdW50KSkpOwoKICAgICAgICAvLyB2w6lyaWZpZSBxdWUgbGEgc2lnbmF0dXJlIHByb3ZpZW50IGRlIGwnZXhww6lkaXRldXIgZHUgcGFpZW1lbnQKICAgICAgICByZXR1cm4gcmVjb3ZlclNpZ25lcihtZXNzYWdlLCBzaWduYXR1cmUpID09IHNlbmRlcjsKICAgIH0KCiAgICAvLy8gVG91dGVzIGxlcyBmb25jdGlvbnMgY2ktZGVzc291cyBzb250IGV4dHJhaXRlcyBkdSBjaGFwaXRyZQogICAgLy8vIGNoYXBpdHJlICdDcsOpYXRpb24gZXQgdsOpcmlmaWNhdGlvbiBkZSBzaWduYXR1cmVzJy4KCiAgICBmdW5jdGlvbiBzcGxpdFNpZ25hdHVyZShieXRlcyBtZW1vcnkgc2lnKQogICAgICAgIGludGVybmFsCiAgICAgICAgcHVyZQogICAgICAgIHJldHVybnMgKHVpbnQ4IHYsIGJ5dGVzMzIgciwgYnl0ZXMzMiBzKQogICAgewogICAgICAgIHJlcXVpcmUoc2lnLmxlbmd0aCA9PSA2NSk7CgogICAgICAgIGFzc2VtYmx5IHsKICAgICAgICAgICAgLy8gZmlyc3QgMzIgYnl0ZXMsIGFmdGVyIHRoZSBsZW5ndGggcHJlZml4CiAgICAgICAgICAgIHIgOj0gbWxvYWQoYWRkKHNpZywgMzIpKQogICAgICAgICAgICAvLyBzZWNvbmQgMzIgYnl0ZXMKICAgICAgICAgICAgcyA6PSBtbG9hZChhZGQoc2lnLCA2NCkpCiAgICAgICAgICAgIC8vIGZpbmFsIGJ5dGUgKGZpcnN0IGJ5dGUgb2YgdGhlIG5leHQgMzIgYnl0ZXMpCiAgICAgICAgICAgIHYgOj0gYnl0ZSgwLCBtbG9hZChhZGQoc2lnLCA5NikpKQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuICh2LCByLCBzKTsKICAgIH0KCiAgICBmdW5jdGlvbiByZWNvdmVyU2lnbmVyKGJ5dGVzMzIgbWVzc2FnZSwgYnl0ZXMgbWVtb3J5IHNpZykKICAgICAgICBpbnRlcm5hbAogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zIChhZGRyZXNzKQogICAgewogICAgICAgICh1aW50OCB2LCBieXRlczMyIHIsIGJ5dGVzMzIgcykgPSBzcGxpdFNpZ25hdHVyZShzaWcpOwoKICAgICAgICByZXR1cm4gZWNyZWNvdmVyKG1lc3NhZ2UsIHYsIHIsIHMpOwogICAgfQoKICAgIC8vLyBjb25zdHJ1aXQgdW4gaGFjaGFnZSBwcsOpZml4w6kgcG91ciBpbWl0ZXIgbGUgY29tcG9ydGVtZW50IGRlIGV0aF9zaWduLgogICAgZnVuY3Rpb24gcHJlZml4ZWQoYnl0ZXMzMiBoYXNoKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKGJ5dGVzMzIpIHsKICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQoIlx4MTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcbjMyIiwgaGFzaCkpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract SimplePaymentChannel {
 address payable public sender; // The account sending payments.
 address payable public recipient; // The account receiving the payments.
 uint256 public expiration; // Timeout in case the recipient never closes.
 constructor (address payable recipientAddress, uint256 duration)
 payable
 {
 sender \= payable(msg.sender);
 recipient \= recipientAddress;
 expiration \= block.timestamp + duration;
 }
 /// le destinataire peut fermer le canal à tout moment en présentant un
 /// montant signé de l'expéditeur. le destinataire recevra ce montant,
 /// et le reste reviendra à l'expéditeur
 function close(uint256 amount, bytes memory signature) external {
 require(msg.sender \== recipient);
 require(isValidSignature(amount, signature));
 recipient.transfer(amount);
 selfdestruct(sender);
 }
 /// l'expéditeur peut prolonger l'expiration à tout moment
 function extend(uint256 newExpiration) external {
 require(msg.sender \== sender);
 require(newExpiration \> expiration);
 expiration \= newExpiration;
 }
 /// si le timeout est atteint sans que le destinataire ferme le canal,
 /// puis l'Ether est renvoyé à l'expéditeur.
 function claimTimeout() external {
 require(block.timestamp \>= expiration);
 selfdestruct(sender);
 }
 function isValidSignature(uint256 amount, bytes memory signature)
 internal
 view
 returns (bool)
 {
 bytes32 message \= prefixed(keccak256(abi.encodePacked(this, amount)));
 // vérifie que la signature provient de l'expéditeur du paiement
 return recoverSigner(message, signature) \== sender;
 }
 /// Toutes les fonctions ci-dessous sont extraites du chapitre
 /// chapitre 'Création et vérification de signatures'.
 function splitSignature(bytes memory sig)
 internal
 pure
 returns (uint8 v, bytes32 r, bytes32 s)
 {
 require(sig.length \== 65);
 assembly {
 // first 32 bytes, after the length prefix
 r :\= mload(add(sig, 32))
 // second 32 bytes
 s :\= mload(add(sig, 64))
 // final byte (first byte of the next 32 bytes)
 v :\= byte(0, mload(add(sig, 96)))
 }
 return (v, r, s);
 }
 function recoverSigner(bytes32 message, bytes memory sig)
 internal
 pure
 returns (address)
 {
 (uint8 v, bytes32 r, bytes32 s) \= splitSignature(sig);
 return ecrecover(message, v, r, s);
 }
 /// construit un hachage préfixé pour imiter le comportement de eth\_sign.
 function prefixed(bytes32 hash) internal pure returns (bytes32) {
 return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));
 }
}
Note
La fonction `splitSignature` n’utilise pas toutes les sécurités nécessaires pour un Smart Contrat sécurisé. Une véritable implémentation devrait utiliser une bibliothèque plus rigoureusement testée, comme la [version d’openzepplin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol) de ce code.
#### Vérification des paiements[](#verification-des-paiements "Lien permanent vers cette rubrique")
Contrairement à la section précédente, les messages d’un canal de paiement ne sont pas racheté tout de suite. Le destinataire garde une trace du dernier message et l’échange lorsqu’il est temps de fermer le canal de paiement. Cela signifie que c’est critique que le destinataire effectue sa propre vérification de chaque message. Sinon, il n’y a aucune garantie que le destinataire pourra être payé à la fin.
Le destinataire doit vérifier chaque message en utilisant le processus suivant :
> 1. Vérifiez que l’adresse du contrat dans le message correspond au canal de paiement.
> 
> 2. Vérifiez que le nouveau total correspond au montant attendu.
> 
> 3. Vérifiez que le nouveau total ne dépasse pas le montant d’Ether bloqué.
> 
> 4. Vérifiez que la signature est valide et provient de l’expéditeur du canal de paiement.
> 
Nous utiliserons la librairie [ethereumjs-util](https://github.com/ethereumjs/ethereumjs-util) pour écrire cette vérification. L’étape finale peut être effectuée de plusieurs façons, et nous utilisons JavaScript. Le code suivant emprunte la fonction `constructPaymentMessage` au **code JavaScript** de signature ci-dessus :
// cela imite le comportement de préfixation de la méthode eth\_sign JSON-RPC.
function prefixed(hash) {
 return ethereumjs.ABI.soliditySHA3(
 \["string", "bytes32"\],
 \["\\x19Ethereum Signed Message:\\n32", hash\]
 );
}
function recoverSigner(message, signature) {
 var split \= ethereumjs.Util.fromRpcSig(signature);
 var publicKey \= ethereumjs.Util.ecrecover(message, split.v, split.r, split.s);
 var signer \= ethereumjs.Util.pubToAddress(publicKey).toString("hex");
 return signer;
}
function isValidSignature(contractAddress, amount, signature, expectedSigner) {
 var message \= prefixed(constructPaymentMessage(contractAddress, amount));
 var signer \= recoverSigner(message, signature);
 return signer.toLowerCase() \==
 ethereumjs.Util.stripHexPrefix(expectedSigner).toLowerCase();
}
## Contrats modulaires (Librairie)[](#contrats-modulaires-librairie "Lien permanent vers cette rubrique")
Une approche modulaire de la construction de vos contrats vous aide à réduire la complexité et améliorer la lisibilité ce qui aidera à identifier les bugs et les vulnérabilités pendant le développement et la relecture de code. Si vous spécifiez et contrôlez le comportement de chaque module, les interactions que vous devrez prendre en compte sont uniquement celles entre les spécifications du module et non toutes les autres parties mobiles du contrat. Dans l’exemple ci-dessous, le contrat utilise la méthode `move` des `Balances` (library) pour vérifier que les soldes envoyés entre les adresses correspondent à ce que vous attendez. Ainsi, la library `Balances` fournit un composant isolé des contrats qui suit correctement les soldes des comptes. Il est facile de vérifier que la library `Balances` ne produise jamais de soldes négatifs ou de débordements grâce au terme `require()` De ce faites, la somme de tous les soldes est un invariant sur la durée de vie du contrat.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKbGlicmFyeSBCYWxhbmNlcyB7CiAgICBmdW5jdGlvbiBtb3ZlKG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50MjU2KSBzdG9yYWdlIGJhbGFuY2VzLCBhZGRyZXNzIGZyb20sIGFkZHJlc3MgdG8sIHVpbnQgYW1vdW50KSBpbnRlcm5hbCB7CiAgICAgICAgcmVxdWlyZShiYWxhbmNlc1tmcm9tXSA+PSBhbW91bnQpOwogICAgICAgIHJlcXVpcmUoYmFsYW5jZXNbdG9dICsgYW1vdW50ID49IGJhbGFuY2VzW3RvXSk7CiAgICAgICAgYmFsYW5jZXNbZnJvbV0gLT0gYW1vdW50OwogICAgICAgIGJhbGFuY2VzW3RvXSArPSBhbW91bnQ7CiAgICB9Cn0KCmNvbnRyYWN0IFRva2VuIHsKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50MjU2KSBiYWxhbmNlczsKICAgIHVzaW5nIEJhbGFuY2VzIGZvciAqOwogICAgbWFwcGluZyhhZGRyZXNzID0+IG1hcHBpbmcgKGFkZHJlc3MgPT4gdWludDI1NikpIGFsbG93ZWQ7CgogICAgZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBmcm9tLCBhZGRyZXNzIHRvLCB1aW50IGFtb3VudCk7CiAgICBldmVudCBBcHByb3ZhbChhZGRyZXNzIG93bmVyLCBhZGRyZXNzIHNwZW5kZXIsIHVpbnQgYW1vdW50KTsKCiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIHRvLCB1aW50IGFtb3VudCkgZXh0ZXJuYWwgcmV0dXJucyAoYm9vbCBzdWNjZXNzKSB7CiAgICAgICAgYmFsYW5jZXMubW92ZShtc2cuc2VuZGVyLCB0bywgYW1vdW50KTsKICAgICAgICBlbWl0IFRyYW5zZmVyKG1zZy5zZW5kZXIsIHRvLCBhbW91bnQpOwogICAgICAgIHJldHVybiB0cnVlOwoKICAgIH0KCiAgICBmdW5jdGlvbiB0cmFuc2ZlckZyb20oYWRkcmVzcyBmcm9tLCBhZGRyZXNzIHRvLCB1aW50IGFtb3VudCkgZXh0ZXJuYWwgcmV0dXJucyAoYm9vbCBzdWNjZXNzKSB7CiAgICAgICAgcmVxdWlyZShhbGxvd2VkW2Zyb21dW21zZy5zZW5kZXJdID49IGFtb3VudCk7CiAgICAgICAgYWxsb3dlZFtmcm9tXVttc2cuc2VuZGVyXSAtPSBhbW91bnQ7CiAgICAgICAgYmFsYW5jZXMubW92ZShmcm9tLCB0bywgYW1vdW50KTsKICAgICAgICBlbWl0IFRyYW5zZmVyKGZyb20sIHRvLCBhbW91bnQpOwogICAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICAgIGZ1bmN0aW9uIGFwcHJvdmUoYWRkcmVzcyBzcGVuZGVyLCB1aW50IHRva2VucykgZXh0ZXJuYWwgcmV0dXJucyAoYm9vbCBzdWNjZXNzKSB7CiAgICAgICAgcmVxdWlyZShhbGxvd2VkW21zZy5zZW5kZXJdW3NwZW5kZXJdID09IDAsICIiKTsKICAgICAgICBhbGxvd2VkW21zZy5zZW5kZXJdW3NwZW5kZXJdID0gdG9rZW5zOwogICAgICAgIGVtaXQgQXBwcm92YWwobXNnLnNlbmRlciwgc3BlbmRlciwgdG9rZW5zKTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBiYWxhbmNlT2YoYWRkcmVzcyB0b2tlbk93bmVyKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKHVpbnQgYmFsYW5jZSkgewogICAgICAgIHJldHVybiBiYWxhbmNlc1t0b2tlbk93bmVyXTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
library Balances {
 function move(mapping(address \=> uint256) storage balances, address from, address to, uint amount) internal {
 require(balances\[from\] \>= amount);
 require(balances\[to\] + amount \>= balances\[to\]);
 balances\[from\] \-= amount;
 balances\[to\] += amount;
 }
}
contract Token {
 mapping(address \=> uint256) balances;
 using Balances for \*;
 mapping(address \=> mapping (address \=> uint256)) allowed;
 event Transfer(address from, address to, uint amount);
 event Approval(address owner, address spender, uint amount);
 function transfer(address to, uint amount) external returns (bool success) {
 balances.move(msg.sender, to, amount);
 emit Transfer(msg.sender, to, amount);
 return true;
 }
 function transferFrom(address from, address to, uint amount) external returns (bool success) {
 require(allowed\[from\]\[msg.sender\] \>= amount);
 allowed\[from\]\[msg.sender\] \-= amount;
 balances.move(from, to, amount);
 emit Transfer(from, to, amount);
 return true;
 }
 function approve(address spender, uint tokens) external returns (bool success) {
 require(allowed\[msg.sender\]\[spender\] \== 0, "");
 allowed\[msg.sender\]\[spender\] \= tokens;
 emit Approval(msg.sender, spender, tokens);
 return true;
 }
 function balanceOf(address tokenOwner) external view returns (uint balance) {
 return balances\[tokenOwner\];
 }
}

# [Source Mappings — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/internals/source_mappings.html) 
 _https://docs.soliditylang.org/en/v0.8.30/internals/source_mappings.html_

As part of the AST output, the compiler provides the range of the source code that is represented by the respective node in the AST. This can be used for various purposes ranging from static analysis tools that report errors based on the AST and debugging tools that highlight local variables and their uses.
Furthermore, the compiler can also generate a mapping from the bytecode to the range in the source code that generated the instruction. This is again important for static analysis tools that operate on bytecode level and for displaying the current position in the source code inside a debugger or for breakpoint handling. This mapping also contains other information, like the jump type and the modifier depth (see below).
Both kinds of source mappings use integer identifiers to refer to source files. The identifier of a source file is stored in `output['sources'][sourceName]['id']` where `output` is the output of the standard-json compiler interface parsed as JSON. For some utility routines, the compiler generates “internal” source files that are not part of the original input but are referenced from the source mappings. These source files together with their identifiers can be obtained via `output['contracts'][sourceName][contractName]['evm']['bytecode']['generatedSources']`.
Note
In the case of instructions that are not associated with any particular source file, the source mapping assigns an integer identifier of `-1`. This may happen for bytecode sections stemming from compiler-generated inline assembly statements.
The source mappings inside the AST use the following notation:
`s:l:f`
Where `s` is the byte-offset to the start of the range in the source file, `l` is the length of the source range in bytes and `f` is the source index mentioned above.
The encoding in the source mapping for the bytecode is more complicated: It is a list of `s:l:f:j:m` separated by `;`. Each of these elements corresponds to an instruction, i.e. you cannot use the byte offset but have to use the instruction offset (push instructions are longer than a single byte). The fields `s`, `l` and `f` are as above. `j` can be either `i`, `o` or `-` signifying whether a jump instruction goes into a function, returns from a function or is a regular jump as part of e.g. a loop. The last field, `m`, is an integer that denotes the “modifier depth”. This depth is increased whenever the placeholder statement (`_`) is entered in a modifier and decreased when it is left again. This allows debuggers to track tricky cases like the same modifier being used twice or multiple placeholder statements being used in a single modifier.
In order to compress these source mappings especially for bytecode, the following rules are used:
* If a field is empty, the value of the preceding element is used.
 
* If a `:` is missing, all following fields are considered empty.
 
This means the following source mappings represent the same information:
`1:2:1;1:9:1;2:1:2;2:1:2;2:1:2`
`1:2:1;:9;2:1:2;;`
Important to note is that when the [verbatim](https://docs.soliditylang.org/en/v0.8.30/yul.html#yul-verbatim) builtin is used, the source mappings will be invalid: The builtin is considered a single instruction instead of potentially multiple.

# [Layout of a Solidity Source File — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/layout-of-source-files.html) 
 _https://docs.soliditylang.org/en/latest/layout-of-source-files.html_

Source files can contain an arbitrary number of [contract definitions](https://docs.soliditylang.org/en/latest/structure-of-a-contract.html#contract-structure), [import](#import) , [pragma](#pragma) and [using for](https://docs.soliditylang.org/en/latest/contracts.html#using-for) directives and [struct](https://docs.soliditylang.org/en/latest/types.html#structs), [enum](https://docs.soliditylang.org/en/latest/types.html#enums), [function](https://docs.soliditylang.org/en/latest/contracts.html#functions), [error](https://docs.soliditylang.org/en/latest/contracts.html#errors) and [constant variable](https://docs.soliditylang.org/en/latest/contracts.html#constants) definitions.
## SPDX License Identifier[](#spdx-license-identifier "Link to this heading")
Trust in smart contracts can be better established if their source code is available. Since making source code available always touches on legal problems with regards to copyright, the Solidity compiler encourages the use of machine-readable [SPDX license identifiers](https://spdx.org/). Every source file should start with a comment indicating its license:
`// SPDX-License-Identifier: MIT`
The compiler does not validate that the license is part of the [list allowed by SPDX](https://spdx.org/licenses/), but it does include the supplied string in the [bytecode metadata](https://docs.soliditylang.org/en/latest/metadata.html#metadata).
If you do not want to specify a license or if the source code is not open-source, please use the special value `UNLICENSED`. Note that `UNLICENSED` (no usage allowed, not present in SPDX license list) is different from `UNLICENSE` (grants all rights to everyone). Solidity follows [the npm recommendation](https://docs.npmjs.com/cli/v7/configuring-npm/package-json#license).
Supplying this comment of course does not free you from other obligations related to licensing like having to mention a specific license header in each source file or the original copyright holder.
The comment is recognized by the compiler anywhere in the file at the file level, but it is recommended to put it at the top of the file.
More information about how to use SPDX license identifiers can be found at the [SPDX website](https://spdx.dev/learn/handling-license-info/#how).
## Pragmas[](#pragmas "Link to this heading")
The `pragma` keyword is used to enable certain compiler features or checks. A pragma directive is always local to a source file, so you have to add the pragma to all your files if you want to enable it in your whole project. If you [import](#import) another file, the pragma from that file does _not_ automatically apply to the importing file.
### Version Pragma[](#version-pragma "Link to this heading")
Source files can (and should) be annotated with a version pragma to reject compilation with future compiler versions that might introduce incompatible changes. We try to keep these to an absolute minimum and introduce them in a way that changes in semantics also require changes in the syntax, but this is not always possible. Because of this, it is always a good idea to read through the changelog at least for releases that contain breaking changes. These releases always have versions of the form `0.x.0` or `x.0.0`.
The version pragma is used as follows: `pragma solidity ^0.5.2;`
A source file with the line above does not compile with a compiler earlier than version 0.5.2, and it also does not work on a compiler starting from version 0.6.0 (this second condition is added by using `^`). Because there will be no breaking changes until version `0.6.0`, you can be sure that your code compiles the way you intended. The exact version of the compiler is not fixed, so that bugfix releases are still possible.
It is possible to specify more complex rules for the compiler version, these follow the same syntax used by [npm](https://docs.npmjs.com/cli/v6/using-npm/semver).
Note
Using the version pragma _does not_ change the version of the compiler. It also _does not_ enable or disable features of the compiler. It just instructs the compiler to check whether its version matches the one required by the pragma. If it does not match, the compiler issues an error.
### ABI Coder Pragma[](#abi-coder-pragma "Link to this heading")
By using `pragma abicoder v1` or `pragma abicoder v2` you can select between the two implementations of the ABI encoder and decoder.
The new ABI coder (v2) is able to encode and decode arbitrarily nested arrays and structs. Apart from supporting more types, it involves more extensive validation and safety checks, which may result in higher gas costs, but also heightened security. It is considered non-experimental as of Solidity 0.6.0 and it is enabled by default starting with Solidity 0.8.0. The old ABI coder can still be selected using `pragma abicoder v1;`.
The set of types supported by the new encoder is a strict superset of the ones supported by the old one. Contracts that use it can interact with ones that do not without limitations. The reverse is possible only as long as the non-`abicoder v2` contract does not try to make calls that would require decoding types only supported by the new encoder. The compiler can detect this and will issue an error. Simply enabling `abicoder v2` for your contract is enough to make the error go away.
Note
This pragma applies to all the code defined in the file where it is activated, regardless of where that code ends up eventually. This means that a contract whose source file is selected to compile with ABI coder v1 can still contain code that uses the new encoder by inheriting it from another contract. This is allowed if the new types are only used internally and not in external function signatures.
Note
Up to Solidity 0.7.4, it was possible to select the ABI coder v2 by using `pragma experimental ABIEncoderV2`, but it was not possible to explicitly select coder v1 because it was the default.
### Experimental Pragma[](#experimental-pragma "Link to this heading")
The second pragma is the experimental pragma. It can be used to enable features of the compiler or language that are not yet enabled by default. The following experimental pragmas are currently supported:
#### ABIEncoderV2[](#abiencoderv2 "Link to this heading")
Because the ABI coder v2 is not considered experimental anymore, it can be selected via `pragma abicoder v2` (please see above) since Solidity 0.7.4.
#### SMTChecker[](#smtchecker "Link to this heading")
This component has to be enabled when the Solidity compiler is built and therefore it is not available in all Solidity binaries. The [build instructions](https://docs.soliditylang.org/en/latest/installing-solidity.html#smt-solvers-build) explain how to activate this option. It is activated for the Ubuntu PPA releases in most versions, but not for the Docker images, Windows binaries or the statically-built Linux binaries. It can be activated for solc-js via the [smtCallback](https://github.com/ethereum/solc-js#example-usage-with-smtsolver-callback) if you have an SMT solver installed locally and run solc-js via node (not via the browser).
If you use `pragma experimental SMTChecker;`, then you get additional [safety warnings](https://docs.soliditylang.org/en/latest/smtchecker.html#formal-verification) which are obtained by querying an SMT solver. The component does not yet support all features of the Solidity language and likely outputs many warnings. In case it reports unsupported features, the analysis may not be fully sound.
## Importing other Source Files[](#importing-other-source-files "Link to this heading")
### Syntax and Semantics[](#syntax-and-semantics "Link to this heading")
Solidity supports import statements to help modularise your code that are similar to those available in JavaScript (from ES6 on). However, Solidity does not support the concept of a [default export](https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export#description).
At a global level, you can use import statements of the following form:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=aW1wb3J0ICJmaWxlbmFtZSI7)
The `filename` part is called an _import path_. This statement imports all global symbols from “filename” (and symbols imported there) into the current global scope (different than in ES6 but backwards-compatible for Solidity). This form is not recommended for use, because it unpredictably pollutes the namespace. If you add new top-level items inside “filename”, they automatically appear in all files that import like this from “filename”. It is better to import specific symbols explicitly.
The following example creates a new global symbol `symbolName` whose members are all the global symbols from `"filename"`:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=aW1wb3J0ICogYXMgc3ltYm9sTmFtZSBmcm9tICJmaWxlbmFtZSI7)
import \* as symbolName from "filename";
which results in all global symbols being available in the format `symbolName.symbol`.
A variant of this syntax that is not part of ES6, but possibly useful is:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=aW1wb3J0ICJmaWxlbmFtZSIgYXMgc3ltYm9sTmFtZTs=)
import "filename" as symbolName;
which is equivalent to `import * as symbolName from "filename";`.
If there is a naming collision, you can rename symbols while importing. For example, the code below creates new global symbols `alias` and `symbol2` which reference `symbol1` and `symbol2` from inside `"filename"`, respectively.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=aW1wb3J0IHtzeW1ib2wxIGFzIGFsaWFzLCBzeW1ib2wyfSBmcm9tICJmaWxlbmFtZSI7)
import {symbol1 as alias, symbol2} from "filename";
### Import Paths[](#import-paths "Link to this heading")
In order to be able to support reproducible builds on all platforms, the Solidity compiler has to abstract away the details of the filesystem where source files are stored. For this reason import paths do not refer directly to files in the host filesystem. Instead the compiler maintains an internal database (_virtual filesystem_ or _VFS_ for short) where each source unit is assigned a unique _source unit name_ which is an opaque and unstructured identifier. The import path specified in an import statement is translated into a source unit name and used to find the corresponding source unit in this database.
Using the [Standard JSON](https://docs.soliditylang.org/en/latest/using-the-compiler.html#compiler-api) API it is possible to directly provide the names and content of all the source files as a part of the compiler input. In this case source unit names are truly arbitrary. If, however, you want the compiler to automatically find and load source code into the VFS, your source unit names need to be structured in a way that makes it possible for an [import callback](https://docs.soliditylang.org/en/latest/path-resolution.html#import-callback) to locate them. When using the command-line compiler the default import callback supports only loading source code from the host filesystem, which means that your source unit names must be paths. Some environments provide custom callbacks that are more versatile. For example the [Remix IDE](https://remix.ethereum.org/) provides one that lets you [import files from HTTP, IPFS and Swarm URLs or refer directly to packages in NPM registry](https://remix-ide.readthedocs.io/en/latest/import.html).
For a complete description of the virtual filesystem and the path resolution logic used by the compiler see [Path Resolution](https://docs.soliditylang.org/en/latest/path-resolution.html#path-resolution).

# [Layout of State Variables in Storage and Transient Storage — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/internals/layout_in_storage.html) 
 _https://docs.soliditylang.org/en/v0.8.30/internals/layout_in_storage.html_

Note
The rules described in this section apply for both storage and transient storage data locations. The layouts are completely independent and don’t interfere with each other’s variable locations. Thus storage and transient storage state variables can be safely interleaved without any side effects. Only value types are supported for transient storage.
State variables of contracts are stored in storage in a compact way such that multiple values sometimes use the same storage slot. Except for dynamically-sized arrays and mappings (see below), data is stored contiguously item after item starting with the first state variable, which is stored in slot `0`. For each variable, a size in bytes is determined according to its type. Multiple, contiguous items that need less than 32 bytes are packed into a single storage slot if possible, according to the following rules:
* The first item in a storage slot is stored lower-order aligned.
 
* Value types use only as many bytes as are necessary to store them.
 
* If a value type does not fit the remaining part of a storage slot, it is stored in the next storage slot.
 
* Structs and array data always start a new slot and their items are packed tightly according to these rules.
 
* Items following struct or array data always start a new storage slot.
 
For contracts that use inheritance, the ordering of state variables is determined by the C3-linearized order of contracts starting with the most base-ward contract. If allowed by the above rules, state variables from different contracts do share the same storage slot.
The elements of structs and arrays are stored after each other, just as if they were given as individual values.
If a contract specifies a [custom storage layout](https://docs.soliditylang.org/en/v0.8.30/contracts.html#custom-storage-layout), the slots assigned to static storage variables are shifted according the value defined as the layout base. Locations of dynamic arrays and mappings are also indirectly affected by this due to shifting of the static slots they are based on. The custom layout is specified in the most derived contract and, following the order explained above, starting from the most base-ward contract’s variables, all storage slots are adjusted.
In the following example, contract `C` inherits from contracts `A` and `B` and also specifies a custom storage base slot. The result is that all storage variable slots of the inheritance tree are adjusted according to the value specified by `C`.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjk7CgpzdHJ1Y3QgUyB7CiAgICBpbnQzMiB4OwogICAgYm9vbCB5Owp9Cgpjb250cmFjdCBBIHsKICAgIHVpbnQgYTsKICAgIHVpbnQxMjggdHJhbnNpZW50IGI7CiAgICB1aW50IGNvbnN0YW50IGMgPSAxMDsKICAgIHVpbnQgaW1tdXRhYmxlIGQgPSAxMjsKfQoKY29udHJhY3QgQiB7CiAgICB1aW50OFtdIGU7CiAgICBtYXBwaW5nKHVpbnQgPT4gUykgZjsKICAgIHVpbnQxNiBnOwogICAgdWludDE2IGg7CiAgICBieXRlczE2IHRyYW5zaWVudCBpOwogICAgUyBzOwogICAgaW50OCBrOwp9Cgpjb250cmFjdCBDIGlzIEEsIEIgbGF5b3V0IGF0IDQyIHsKICAgIGJ5dGVzMjEgbDsKICAgIHVpbnQ4WzEwXSBtOwogICAgYnl0ZXM1WzhdIG47CiAgICBieXRlczUgbzsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.29;
struct S {
 int32 x;
 bool y;
}
contract A {
 uint a;
 uint128 transient b;
 uint constant c \= 10;
 uint immutable d \= 12;
}
contract B {
 uint8\[\] e;
 mapping(uint \=> S) f;
 uint16 g;
 uint16 h;
 bytes16 transient i;
 S s;
 int8 k;
}
contract C is A, B layout at 42 {
 bytes21 l;
 uint8\[10\] m;
 bytes5\[8\] n;
 bytes5 o;
}
In the example, the storage layout starts with the inherited state variable `a` stored directly inside the base slot (slot `42`). Transient, constant and immutable variables are stored in separate locations, and thus, `b`, `i`, `c` and `d` have no effect on the storage layout. Then we get to the dynamic array `e` and mapping `f`. They both reserve a whole slot whose address will be used to [calculate](#storage-hashed-encoding) the location where their data is actually stored. The slot cannot be shared with any other variable, because the resulting addresses must be unique. The next two variables, `g` and `h`, need 2 bytes each and can be packed together into slot `45`, at offsets `0` and `2` respectively. Since `s` is a struct, its two members are packed contiguously, each taking up 5 bytes. Even though they both would still fit in slot `45`, structs and arrays always start a new slot. Therefore, `s` is placed in slot `46` and the next variable, `k`, in slot `47`. Base contracts, on the other hand, can share slots with derived ones, so `l` does not require an new one. Then variable `m`, which is an array of 10 items, gets into slot `48` and takes up 10 bytes. `n` is an array as well, but due to the size of its items, cannot fill its first slot perfectly and spills over to the next one. Finally, variable `o` ends up in slot `51`, even though it is of the same type as items of `n`. As explained before, variables after structs and arrays always start a new slot.
Putting it all together, the storage and transient storage layouts of contract `C` can be illustrated as follows:
* Storage:
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=NDIgW2FhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhXQo0MyBbZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVdCjQ0IFtmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZl0KNDUgWyAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaGdnXQo0NiBbICAgICAgICAgICAgICAgICAgICAgICAgICAgeXh4eHhdCjQ3IFsgICAgICAgICAgbGxsbGxsbGxsbGxsbGxsbGxsbGxsa10KNDggWyAgICAgICAgICAgICAgICAgICAgICBtbW1tbW1tbW1tXQo0OSBbICBubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5dCjUwIFsgICAgICAgICAgICAgICAgICAgICAgbm5ubm5ubm5ubl0KNTEgWyAgICAgICAgICAgICAgICAgICAgICAgICAgIG9vb29vXQ==)
 
 42 \[aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\]
 43 \[eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\]
 44 \[ffffffffffffffffffffffffffffffff\]
 45 \[ hhgg\]
 46 \[ yxxxx\]
 47 \[ lllllllllllllllllllllk\]
 48 \[ mmmmmmmmmm\]
 49 \[ nnnnnnnnnnnnnnnnnnnnnnnnnnnnnn\]
 50 \[ nnnnnnnnnn\]
 51 \[ ooooo\]
 
* Transient storage:
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=MDAgW2lpaWlpaWlpaWlpaWlpaWliYmJiYmJiYmJiYmJiYmJiXQ==)
 
 00 \[iiiiiiiiiiiiiiiibbbbbbbbbbbbbbbb\]
 
Note that the storage specifier affects `A` and `B` only as a part of `C`’s inheritance hierarchy. When deployed independently, their storage starts at `0`:
* Storage layout of `A`:
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=MDAgW2FhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhXQ==)
 
 00 \[aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\]
 
* Storage layout of `B`:
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=MDAgW2VlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlXQowMSBbZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZdCjAyIFsgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGhnZ10KMDMgWyAgICAgICAgICAgICAgICAgICAgICAgICAgIHl4eHh4XQowNCBbICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtd)
 
 00 \[eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\]
 01 \[ffffffffffffffffffffffffffffffff\]
 02 \[ hhgg\]
 03 \[ yxxxx\]
 04 \[ k\]
 
Warning
When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.
It might be beneficial to use reduced-size types if you are dealing with storage values because the compiler will pack multiple elements into one storage slot, and thus, combine multiple reads or writes into a single operation. If you are not reading or writing all the values in a slot at the same time, this can have the opposite effect, though: When one value is written to a multi-value storage slot, the storage slot has to be read first and then combined with the new value such that other data in the same slot is not destroyed.
When dealing with function arguments or memory values, there is no inherent benefit because the compiler does not pack these values.
Finally, in order to allow the EVM to optimize for this, ensure that you try to order your storage variables and `struct` members such that they can be packed tightly. For example, declaring your storage variables in the order of `uint128, uint128, uint256` instead of `uint128, uint256, uint128`, as the former will only take up two slots of storage whereas the latter will take up three.
Note
The layout of state variables in storage is considered to be part of the external interface of Solidity due to the fact that storage pointers can be passed to libraries. This means that any change to the rules outlined in this section is considered a breaking change of the language and due to its critical nature should be considered very carefully before being executed. In the event of such a breaking change, we would want to release a compatibility mode in which the compiler would generate bytecode supporting the old layout.
## Mappings and Dynamic Arrays[](#mappings-and-dynamic-arrays "Link to this heading")
Due to their unpredictable size, mappings and dynamically-sized array types cannot be stored “in between” the state variables preceding and following them. Instead, they are considered to occupy only 32 bytes with regards to the [rules above](#storage-inplace-encoding) and the elements they contain are stored starting at a different storage slot that is computed using a Keccak-256 hash.
Assume the storage location of the mapping or array ends up being a slot `p` after applying [the storage layout rules](#storage-inplace-encoding). For dynamic arrays, this slot stores the number of elements in the array (byte arrays and strings are an exception, see [below](#bytes-and-string)). For mappings, the slot stays empty, but it is still needed to ensure that even if there are two mappings next to each other, their content ends up at different storage locations.
Array data is located starting at `keccak256(p)` and it is laid out in the same way as statically-sized array data would: One element after the other, potentially sharing storage slots if the elements are not longer than 16 bytes. Dynamic arrays of dynamic arrays apply this rule recursively. The location of element `x[i][j]`, where the type of `x` is `uint24[][]`, is computed as follows (again, assuming `x` itself is stored at slot `p`): The slot is `keccak256(keccak256(p) + i) + floor(j / floor(256 / 24))` and the element can be obtained from the slot data `v` using `(v >> ((j % floor(256 / 24)) * 24)) & type(uint24).max`.
The value corresponding to a mapping key `k` is located at `keccak256(h(k) . p)` where `.` is concatenation and `h` is a function that is applied to the key depending on its type:
* for value types, `h` pads the value to 32 bytes in the same way as when storing the value in memory.
 
* for strings and byte arrays, `h(k)` is just the unpadded data.
 
If the mapping value is a non-value type, the computed slot marks the start of the data. If the value is of struct type, for example, you have to add an offset corresponding to the struct member to reach the member.
As an example, consider the following contract:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKCmNvbnRyYWN0IEMgewogICAgc3RydWN0IFMgeyB1aW50MTYgYTsgdWludDE2IGI7IHVpbnQyNTYgYzsgfQogICAgdWludCB4OwogICAgbWFwcGluZyh1aW50ID0+IG1hcHBpbmcodWludCA9PiBTKSkgZGF0YTsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract C {
 struct S { uint16 a; uint16 b; uint256 c; }
 uint x;
 mapping(uint \=> mapping(uint \=> S)) data;
}
Let us compute the storage location of `data[4][9].c`. The position of the mapping itself is `1` (the variable `x` with 32 bytes precedes it). This means `data[4]` is stored at `keccak256(uint256(4) . uint256(1))`. The type of `data[4]` is again a mapping and the data for `data[4][9]` starts at slot `keccak256(uint256(9) . keccak256(uint256(4) . uint256(1)))`. The slot offset of the member `c` inside the struct `S` is `1` because `a` and `b` are packed in a single slot. This means the slot for `data[4][9].c` is `keccak256(uint256(9) . keccak256(uint256(4) . uint256(1))) + 1`. The type of the value is `uint256`, so it uses a single slot.
### `bytes` and `string`[](#bytes-and-string "Link to this heading")
`bytes` and `string` are encoded identically. In general, the encoding is similar to `bytes1[]`, in the sense that there is a slot for the array itself and a data area that is computed using a `keccak256` hash of that slot’s position. However, for short values (shorter than 32 bytes) the array elements are stored together with the length in the same slot.
In particular: if the data is at most `31` bytes long, the elements are stored in the higher-order bytes (left aligned) and the lowest-order byte stores the value `length * 2`. For byte arrays that store data which is `32` or more bytes long, the main slot `p` stores `length * 2 + 1` and the data is stored as usual in `keccak256(p)`. This means that you can distinguish a short array from a long array by checking if the lowest bit is set: short (not set) and long (set).
Note
Handling invalidly encoded slots is currently not supported but may be added in the future. If you are compiling via IR, reading an invalidly encoded slot results in a `Panic(0x22)` error.
## JSON Output[](#json-output "Link to this heading")
The storage (or transient storage) layout of a contract can be requested via the [standard JSON interface](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#compiler-api). The output is a JSON object containing two keys, `storage` and `types`. The `storage` object is an array where each element has the following form:
{
 "astId": 2,
 "contract": "fileA:A",
 "label": "x",
 "offset": 0,
 "slot": "0",
 "type": "t\_uint256"
}
The example above is the storage layout of `contract A { uint x; }` from source unit `fileA` and
* `astId` is the id of the AST node of the state variable’s declaration
 
* `contract` is the name of the contract including its path as prefix
 
* `label` is the name of the state variable
 
* `offset` is the offset in bytes within the storage slot according to the encoding
 
* `slot` is the storage slot where the state variable resides or starts. This number may be very large and therefore its JSON value is represented as a string.
 
* `type` is an identifier used as key to the variable’s type information (described in the following)
 
The given `type`, in this case `t_uint256` represents an element in `types`, which has the form:
{
 "encoding": "inplace",
 "label": "uint256",
 "numberOfBytes": "32",
}
where
* `encoding` how the data is encoded in storage, where the possible values are:
 
 * `inplace`: data is laid out contiguously in storage (see [above](#storage-inplace-encoding)).
 
 * `mapping`: Keccak-256 hash-based method (see [above](#storage-hashed-encoding)).
 
 * `dynamic_array`: Keccak-256 hash-based method (see [above](#storage-hashed-encoding)).
 
 * `bytes`: single slot or Keccak-256 hash-based depending on the data size (see [above](#bytes-and-string)).
 
* `label` is the canonical type name.
 
* `numberOfBytes` is the number of used bytes (as a decimal string). Note that if `numberOfBytes > 32` this means that more than one slot is used.
 
Some types have extra information besides the four above. Mappings contain its `key` and `value` types (again referencing an entry in this mapping of types), arrays have its `base` type, and structs list their `members` in the same format as the top-level `storage` (see [above](#storage-layout-top-level)).
Note
The JSON output format of a contract’s storage layout is still considered experimental and is subject to change in non-breaking releases of Solidity.
The following example shows a contract and both its storage and transient storage layout, containing value and reference types, types that are encoded packed, and nested types.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjg7CmNvbnRyYWN0IEEgewogICAgc3RydWN0IFMgewogICAgICAgIHVpbnQxMjggYTsKICAgICAgICB1aW50MTI4IGI7CiAgICAgICAgdWludFsyXSBzdGF0aWNBcnJheTsKICAgICAgICB1aW50W10gZHluQXJyYXk7CiAgICB9CgogICAgdWludCB4OwogICAgdWludCB0cmFuc2llbnQgeTsKICAgIHVpbnQgdzsKICAgIHVpbnQgdHJhbnNpZW50IHo7CgogICAgUyBzOwogICAgYWRkcmVzcyBhZGRyOwogICAgYWRkcmVzcyB0cmFuc2llbnQgdGFkZHI7CiAgICBtYXBwaW5nKHVpbnQgPT4gbWFwcGluZyhhZGRyZXNzID0+IGJvb2wpKSBtYXA7CiAgICB1aW50W10gYXJyYXk7CiAgICBzdHJpbmcgczE7CiAgICBieXRlcyBiMTsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.28;
contract A {
 struct S {
 uint128 a;
 uint128 b;
 uint\[2\] staticArray;
 uint\[\] dynArray;
 }
 uint x;
 uint transient y;
 uint w;
 uint transient z;
 S s;
 address addr;
 address transient taddr;
 mapping(uint \=> mapping(address \=> bool)) map;
 uint\[\] array;
 string s1;
 bytes b1;
}
### Storage Layout[](#storage-layout "Link to this heading")
{
 "storage": \[
 {
 "astId": 15,
 "contract": "fileA:A",
 "label": "x",
 "offset": 0,
 "slot": "0",
 "type": "t\_uint256"
 },
 {
 "astId": 19,
 "contract": "fileA:A",
 "label": "w",
 "offset": 0,
 "slot": "1",
 "type": "t\_uint256"
 },
 {
 "astId": 24,
 "contract": "fileA:A",
 "label": "s",
 "offset": 0,
 "slot": "2",
 "type": "t\_struct(S)13\_storage"
 },
 {
 "astId": 26,
 "contract": "fileA:A",
 "label": "addr",
 "offset": 0,
 "slot": "6",
 "type": "t\_address"
 },
 {
 "astId": 34,
 "contract": "fileA:A",
 "label": "map",
 "offset": 0,
 "slot": "7",
 "type": "t\_mapping(t\_uint256,t\_mapping(t\_address,t\_bool))"
 },
 {
 "astId": 37,
 "contract": "fileA:A",
 "label": "array",
 "offset": 0,
 "slot": "8",
 "type": "t\_array(t\_uint256)dyn\_storage"
 },
 {
 "astId": 39,
 "contract": "fileA:A",
 "label": "s1",
 "offset": 0,
 "slot": "9",
 "type": "t\_string\_storage"
 },
 {
 "astId": 41,
 "contract": "fileA:A",
 "label": "b1",
 "offset": 0,
 "slot": "10",
 "type": "t\_bytes\_storage"
 }
 \],
 "types": {
 "t\_address": {
 "encoding": "inplace",
 "label": "address",
 "numberOfBytes": "20"
 },
 "t\_array(t\_uint256)2\_storage": {
 "base": "t\_uint256",
 "encoding": "inplace",
 "label": "uint256\[2\]",
 "numberOfBytes": "64"
 },
 "t\_array(t\_uint256)dyn\_storage": {
 "base": "t\_uint256",
 "encoding": "dynamic\_array",
 "label": "uint256\[\]",
 "numberOfBytes": "32"
 },
 "t\_bool": {
 "encoding": "inplace",
 "label": "bool",
 "numberOfBytes": "1"
 },
 "t\_bytes\_storage": {
 "encoding": "bytes",
 "label": "bytes",
 "numberOfBytes": "32"
 },
 "t\_mapping(t\_address,t\_bool)": {
 "encoding": "mapping",
 "key": "t\_address",
 "label": "mapping(address => bool)",
 "numberOfBytes": "32",
 "value": "t\_bool"
 },
 "t\_mapping(t\_uint256,t\_mapping(t\_address,t\_bool))": {
 "encoding": "mapping",
 "key": "t\_uint256",
 "label": "mapping(uint256 => mapping(address => bool))",
 "numberOfBytes": "32",
 "value": "t\_mapping(t\_address,t\_bool)"
 },
 "t\_string\_storage": {
 "encoding": "bytes",
 "label": "string",
 "numberOfBytes": "32"
 },
 "t\_struct(S)13\_storage": {
 "encoding": "inplace",
 "label": "struct A.S",
 "members": \[
 {
 "astId": 3,
 "contract": "fileA:A",
 "label": "a",
 "offset": 0,
 "slot": "0",
 "type": "t\_uint128"
 },
 {
 "astId": 5,
 "contract": "fileA:A",
 "label": "b",
 "offset": 16,
 "slot": "0",
 "type": "t\_uint128"
 },
 {
 "astId": 9,
 "contract": "fileA:A",
 "label": "staticArray",
 "offset": 0,
 "slot": "1",
 "type": "t\_array(t\_uint256)2\_storage"
 },
 {
 "astId": 12,
 "contract": "fileA:A",
 "label": "dynArray",
 "offset": 0,
 "slot": "3",
 "type": "t\_array(t\_uint256)dyn\_storage"
 }
 \],
 "numberOfBytes": "128"
 },
 "t\_uint128": {
 "encoding": "inplace",
 "label": "uint128",
 "numberOfBytes": "16"
 },
 "t\_uint256": {
 "encoding": "inplace",
 "label": "uint256",
 "numberOfBytes": "32"
 }
 }
}
### Transient Storage Layout[](#transient-storage-layout "Link to this heading")
{
 "storage": \[
 {
 "astId": 17,
 "contract": "fileA:A",
 "label": "y",
 "offset": 0,
 "slot": "0",
 "type": "t\_uint256"
 },
 {
 "astId": 21,
 "contract": "fileA:A",
 "label": "z",
 "offset": 0,
 "slot": "1",
 "type": "t\_uint256"
 },
 {
 "astId": 28,
 "contract": "fileA:A",
 "label": "taddr",
 "offset": 0,
 "slot": "2",
 "type": "t\_address"
 }
 \],
 "types": {
 "t\_address": {
 "encoding": "inplace",
 "label": "address",
 "numberOfBytes": "20"
 },
 "t\_uint256": {
 "encoding": "inplace",
 "label": "uint256",
 "numberOfBytes": "32"
 }
 }
}

# [Dilbilgisi (Language Grammar) — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/grammar.html) 
 _https://docs.soliditylang.org/tr/latest/grammar.html_

[Solidity](https://docs.soliditylang.org/tr/latest/index.html)
_parser grammar_ SolidityParser[](#a4.SolidityParser "Bu tanım için kalıcı bağlantı")
Solidity, Ethereum platformunda akıllı sözleşmelerin uygulanması için statik olarak yazılan, sözleşme odaklı, yüksek seviyeli bir programlama dilidir.
_rule_ source-unit[](#a4.SolidityParser.sourceUnit "Bu tanım için kalıcı bağlantı")
Solidity en üst seviyede pragmalara, import direktiflerine ve sözleşmelerin, arayüzlerin, kütüphanelerin, structların, enumların ve constantların tanımlanmasına izin verir.
pragmapragma-token;import-directiveusing-directivecontract-definitioninterface-definitionlibrary-definitionfunction-definitionconstant-variable-declarationstruct-definitionenum-definitionuser-defined-value-type-definitionerror-definitioneof
_rule_ import-directive[](#a4.SolidityParser.importDirective "Bu tanım için kalıcı bağlantı")
İçe aktarma direktifleri farklı dosyalardan tanımlayıcıları içe aktarır.
importpathasidentifiersymbol-aliasesfrompath\*asidentifierfrompath;
_rule_ path[](#a4.SolidityParser.path "Bu tanım için kalıcı bağlantı")
İçeri aktarılacak dosyanın yolu.
non-empty-string-literal
_rule_ symbol-aliases[](#a4.SolidityParser.symbolAliases "Bu tanım için kalıcı bağlantı")
İçe aktarılacak semboller için takma adların listesi.
{identifierasidentifier,}
_rule_ contract-definition[](#a4.SolidityParser.contractDefinition "Bu tanım için kalıcı bağlantı")
Bir sözleşmenin en üst düzey tanımı.
abstractcontractidentifierisinheritance-specifier,{contract-body-element}
_rule_ interface-definition[](#a4.SolidityParser.interfaceDefinition "Bu tanım için kalıcı bağlantı")
Bir arayüzün en üst düzey tanımı.
interfaceidentifierisinheritance-specifier,{contract-body-element}
_rule_ library-definition[](#a4.SolidityParser.libraryDefinition "Bu tanım için kalıcı bağlantı")
Bir kütüphanenin en üst düzey tanımı.
libraryidentifier{contract-body-element}
_rule_ inheritance-specifier[](#a4.SolidityParser.inheritanceSpecifier "Bu tanım için kalıcı bağlantı")
Sözleşmeler ve arayüzler için kalıtım belirleyicisi. İsteğe bağlı olarak temel constructor argümanları sağlayabilir.
identifier-pathcall-argument-list
_rule_ contract-body-element[](#a4.SolidityParser.contractBodyElement "Bu tanım için kalıcı bağlantı")
Sözleşmelerde, arayüzlerde ve kütüphanelerde kullanılabilen tanımlamalar.
Arayüzlerin ve kütüphanelerin constructor, arayüzlerin durum değişkenleri ve kütüphanelerin fallback, receive fonksiyonları veya sabit olmayan durum değişkenleri içermeyebileceğini unutmayın.
constructor-definitionfunction-definitionmodifier-definitionfallback-function-definitionreceive-function-definitionstruct-definitionenum-definitionuser-defined-value-type-definitionstate-variable-declarationevent-definitionerror-definitionusing-directive
_rule_ call-argument-list[](#a4.SolidityParser.callArgumentList "Bu tanım için kalıcı bağlantı")
Bir fonksiyonu veya benzer bir çağrılabilir nesneyi çağırırken mevcut olan argümanlar. Bağımsız değişkenler ya virgülle ayrılmış liste olarak ya da adlandırılmış bağımsız değişkenlerin haritası olarak verilir.
(expression,{identifier:expression,})
_rule_ identifier-path[](#a4.SolidityParser.identifierPath "Bu tanım için kalıcı bağlantı")
Nitelikli isim.
identifier.
_rule_ modifier-invocation[](#a4.SolidityParser.modifierInvocation "Bu tanım için kalıcı bağlantı")
Bir modifier’a çağrı yapın. Modifier hiçbir argüman almazsa, argüman listesi tamamen atlanabilir (açılış ve kapanış parantezleri dahil).
identifier-pathcall-argument-list
_rule_ visibility[](#a4.SolidityParser.visibility "Bu tanım için kalıcı bağlantı")
Fonksiyonlar ve fonksiyon türleri için görünürlük.
internalexternalprivatepublic
_rule_ parameter-list[](#a4.SolidityParser.parameterList "Bu tanım için kalıcı bağlantı")
Fonksiyon argümanları veya dönüş değerleri gibi parametrelerin bir listesi.
type-namedata-locationidentifier,
_rule_ constructor-definition[](#a4.SolidityParser.constructorDefinition "Bu tanım için kalıcı bağlantı")
Constructor’ın tanımı: Her zaman bir uygulama sağlamalıdır. Internal veya Public görünürlük belirtmenin kullanımdan kaldırıldığını unutmayın.
constructor(parameter-list)modifier-invocationpayableinternalpublicblock
_rule_ state-mutability[](#a4.SolidityParser.stateMutability "Bu tanım için kalıcı bağlantı")
Fonksiyon tipleri için durum değiştirilebilirliği. Herhangi bir değişebilirlik belirtilmezse varsayılan değişebilirlik ‘non-payable’ olarak kabul edilir.
pureviewpayable
_rule_ override-specifier[](#a4.SolidityParser.overrideSpecifier "Bu tanım için kalıcı bağlantı")
Fonksiyonlar, modifier’lar veya durum değişkenleri için kullanılan bir geçersiz kılma belirteci. Geçersiz kılınan birden fazla temel sözleşmede belirsiz tanımlamalar olduğu durumlarda, temel sözleşmelerin tam bir listesi verilmelidir.
override(identifier-path,)
_rule_ function-definition[](#a4.SolidityParser.functionDefinition "Bu tanım için kalıcı bağlantı")
Sözleşme, kütüphane ve arayüz fonksiyonlarının tanımı. Fonksiyonun tanımlandığı bağlama bağlı olarak, başka kısıtlamalar da uygulanabilir; örneğin, arayüzlerdeki fonksiyonlar uygulanmamış olmalıdır, yani bir gövde bloğu içermemelidir.
functionidentifierfallbackreceive(parameter-list)visibilitystate-mutabilitymodifier-invocationvirtualoverride-specifierreturns(parameter-list);block
_rule_ modifier-definition[](#a4.SolidityParser.modifierDefinition "Bu tanım için kalıcı bağlantı")
Bir modifier’ın tanımı. Bir modifier’ın gövde bloğu içinde, alt çizginin tanımlayıcı olarak kullanılamayacağını, ancak modifier’ın uygulandığı bir fonksiyonun gövdesi için yer tutucu ifade olarak kullanıldığını unutmayın.
modifieridentifier(parameter-list)virtualoverride-specifier;block
_rule_ fallback-function-definition[](#a4.SolidityParser.fallbackFunctionDefinition "Bu tanım için kalıcı bağlantı")
Özel fallback fonksiyonunun tanımı.
fallback(parameter-list)externalstate-mutabilitymodifier-invocationvirtualoverride-specifierreturns(parameter-list);block
_rule_ receive-function-definition[](#a4.SolidityParser.receiveFunctionDefinition "Bu tanım için kalıcı bağlantı")
Özel receive fonksiyonunun tanımı.
receive()externalpayablemodifier-invocationvirtualoverride-specifier;block
_rule_ struct-definition[](#a4.SolidityParser.structDefinition "Bu tanım için kalıcı bağlantı")
Bir struct’ın tanımı. Bir kaynak birimin içinde üst seviyede veya bir sözleşme, kütüphane veya arayüz içinde oluşabilir.
structidentifier{struct-member}
_rule_ struct-member[](#a4.SolidityParser.structMember "Bu tanım için kalıcı bağlantı")
Adlandırılmış bir struct üyesinin tanımı.
type-nameidentifier;
_rule_ enum-definition[](#a4.SolidityParser.enumDefinition "Bu tanım için kalıcı bağlantı")
Bir enum tanımı. Bir kaynak birim içinde üst seviyede veya bir sözleşme, kütüphane veya arayüz içinde oluşabilir.
enumidentifier{identifier,}
_rule_ user-defined-value-type-definition[](#a4.SolidityParser.userDefinedValueTypeDefinition "Bu tanım için kalıcı bağlantı")
Kullanıcı tanımlı bir değer türünün tanımı. Bir kaynak birim içinde üst seviyede veya bir sözleşme, kütüphane veya arayüz içinde oluşabilir.
typeidentifieriselementary-type-name;
_rule_ state-variable-declaration[](#a4.SolidityParser.stateVariableDeclaration "Bu tanım için kalıcı bağlantı")
Bir durum değişkeninin tanımı.
type-namepublicprivateinternalconstantoverride-specifierimmutableidentifier\=expression;
_rule_ constant-variable-declaration[](#a4.SolidityParser.constantVariableDeclaration "Bu tanım için kalıcı bağlantı")
Sabit bir değişkenin tanımı.
type-nameconstantidentifier\=expression;
_rule_ event-parameter[](#a4.SolidityParser.eventParameter "Bu tanım için kalıcı bağlantı")
Bir eventin parametresi.
type-nameindexedidentifier
_rule_ event-definition[](#a4.SolidityParser.eventDefinition "Bu tanım için kalıcı bağlantı")
Bir event tanımı. Sözleşmelerde, kütüphanelerde veya arayüzlerde meydana gelebilir.
eventidentifier(event-parameter,)anonymous;
_rule_ error-parameter[](#a4.SolidityParser.errorParameter "Bu tanım için kalıcı bağlantı")
Error parametresi.
type-nameidentifier
_rule_ error-definition[](#a4.SolidityParser.errorDefinition "Bu tanım için kalıcı bağlantı")
Bir error tanımı.
erroridentifier(error-parameter,);
_rule_ using-directive[](#a4.SolidityParser.usingDirective "Bu tanım için kalıcı bağlantı")
Kütüphane işlevlerini ve serbest işlevleri türlere bağlamak için yönerge kullanma. Sözleşmeler ve kütüphaneler içinde ve dosya düzeyinde meydana gelebilir.
usingidentifier-path{identifier-path,}for\*type-nameglobal;
_rule_ type-name[](#a4.SolidityParser.typeName "Bu tanım için kalıcı bağlantı")
Bir türün adı, temel tür, fonksiyon türü, mapping türü, kullanıcı tanımlı tür olabilir. (örneğin bir sözleşme veya struct) veya bir dizi türü.
elementary-type-namefunction-type-namemapping-typeidentifier-pathtype-name\[expression\]
_rule_ elementary-type-name[](#a4.SolidityParser.elementaryTypeName "Bu tanım için kalıcı bağlantı")
addressaddresspayableboolstringbytessigned-integer-typeunsigned-integer-typefixed-bytesfixedufixed
_rule_ function-type-name[](#a4.SolidityParser.functionTypeName "Bu tanım için kalıcı bağlantı")
function(parameter-list)visibilitystate-mutabilityreturns(parameter-list)
_rule_ variable-declaration[](#a4.SolidityParser.variableDeclaration "Bu tanım için kalıcı bağlantı")
Tek bir değişkenin tanımı.
type-namedata-locationidentifier
_rule_ data-location[](#a4.SolidityParser.dataLocation "Bu tanım için kalıcı bağlantı")
memorystoragecalldata
_rule_ expression[](#a4.SolidityParser.expression "Bu tanım için kalıcı bağlantı")
Karmaşık bir ifade. Bir dizin erişimi, bir dizin aralığı erişimi, bir üye erişimi, bir fonksiyon çağrısı (isteğe bağlı fonksiyon çağrısı seçenekleriyle), bir tür dönüştürme, bir tekli veya ikili ifade, bir karşılaştırma veya atama, bir üçlü ifade, bir yeni ifade (yani bir sözleşme oluşturma veya bir dinamik bellek dizisinin tahsisi), bir tuple, bir inline dizi veya bir birincil ifade (yani bir tanımlayıcı, literal veya tür adı) olabilir.
expression\[expression\]expression\[expression:expression\]expression.identifieraddressexpression{identifier:expression,}expressioncall-argument-listpayablecall-argument-listtype(type-name)++\--!~delete\-expressionexpression++\--expression\*\*expressionexpression\*/%expressionexpression+\-expressionexpression<<\>>\>>>expressionexpression&expressionexpression^expressionexpression|expressionexpression<\><=\>=expressionexpression\==!=expressionexpression&&expressionexpression||expressionexpression?expression:expressionexpression\=|=^=&=<<=\>>=\>>>=+=\-=\*=/=%=expressionnewtype-nametuple-expressioninline-array-expressionidentifierliteralelementary-type-name
_rule_ tuple-expression[](#a4.SolidityParser.tupleExpression "Bu tanım için kalıcı bağlantı")
(expression,)
_rule_ inline-array-expression[](#a4.SolidityParser.inlineArrayExpression "Bu tanım için kalıcı bağlantı")
Inline dizi ifadesi, içerdiği ifadelerin ortak türünde statik olarak boyutlandırılmış bir diziyi belirtir.
\[expression,\]
_rule_ identifier[](#a4.SolidityParser.identifier "Bu tanım için kalıcı bağlantı")
Normal anahtar kelime olmayan Tanımlayıcıların yanı sıra, ‘from’ ve ‘error’ gibi bazı anahtar kelimeler de tanımlayıcı olarak kullanılabilir.
identifierfromerrorrevertglobal
_rule_ literal[](#a4.SolidityParser.literal "Bu tanım için kalıcı bağlantı")
string-literalnumber-literalboolean-literalhex-string-literalunicode-string-literal
_rule_ boolean-literal[](#a4.SolidityParser.booleanLiteral "Bu tanım için kalıcı bağlantı")
truefalse
_rule_ string-literal[](#a4.SolidityParser.stringLiteral "Bu tanım için kalıcı bağlantı")
Tam bir dize literali, bir veya birkaç ardışık alıntılanmış dizeden oluşur.
non-empty-string-literalempty-string-literal
_rule_ hex-string-literal[](#a4.SolidityParser.hexStringLiteral "Bu tanım için kalıcı bağlantı")
Bir veya birkaç ardışık onaltılık dizeden oluşan tam onaltılık dize literali.
hex-string
_rule_ unicode-string-literal[](#a4.SolidityParser.unicodeStringLiteral "Bu tanım için kalıcı bağlantı")
Bir veya birkaç ardışık unicode string’den oluşan tam bir unicode string literal.
unicode-string-literal
_rule_ number-literal[](#a4.SolidityParser.numberLiteral "Bu tanım için kalıcı bağlantı")
Sayı literalleri isteğe bağlı bir birimle birlikte ondalık veya onaltılık sayılar olabilir.
decimal-numberhex-numbernumber-unit
_rule_ block[](#a4.SolidityParser.block "Bu tanım için kalıcı bağlantı")
Kıvrımlı parantezli ifadeler bloğu. Kendi kapsamını açar.
{statementunchecked-block}
_rule_ unchecked-block[](#a4.SolidityParser.uncheckedBlock "Bu tanım için kalıcı bağlantı")
uncheckedblock
_rule_ statement[](#a4.SolidityParser.statement "Bu tanım için kalıcı bağlantı")
blockvariable-declaration-statementexpression-statementif-statementfor-statementwhile-statementdo-while-statementcontinue-statementbreak-statementtry-statementreturn-statementemit-statementrevert-statementassembly-statement
_rule_ if-statement[](#a4.SolidityParser.ifStatement "Bu tanım için kalıcı bağlantı")
İsteğe bağlı olarak “else” kısmı olan if ifadesi.
if(expression)statementelsestatement
_rule_ for-statement[](#a4.SolidityParser.forStatement "Bu tanım için kalıcı bağlantı")
İsteğe bağlı init, condition ve post-loop kısmı olan for ifadesi.
for(variable-declaration-statementexpression-statement;expression-statement;expression)statement
_rule_ while-statement[](#a4.SolidityParser.whileStatement "Bu tanım için kalıcı bağlantı")
while(expression)statement
_rule_ do-while-statement[](#a4.SolidityParser.doWhileStatement "Bu tanım için kalıcı bağlantı")
dostatementwhile(expression);
_rule_ continue-statement[](#a4.SolidityParser.continueStatement "Bu tanım için kalıcı bağlantı")
Bir devam ifadesi. Yalnızca for, while veya do-while döngüleri içinde izin verilir.
continue;
_rule_ break-statement[](#a4.SolidityParser.breakStatement "Bu tanım için kalıcı bağlantı")
Bir break ifadesi. Yalnızca for, while veya do-while döngüleri içinde izin verilir.
break;
_rule_ try-statement[](#a4.SolidityParser.tryStatement "Bu tanım için kalıcı bağlantı")
Bir try ifadesi. İçerilen ifadenin harici bir işlev çağrısı veya bir sözleşme oluşturma olması gerekir.
tryexpressionreturns(parameter-list)blockcatch-clause
_rule_ catch-clause[](#a4.SolidityParser.catchClause "Bu tanım için kalıcı bağlantı")
Bir try ifadesinin catch cümlesi.
catchidentifier(parameter-list)block
_rule_ return-statement[](#a4.SolidityParser.returnStatement "Bu tanım için kalıcı bağlantı")
returnexpression;
_rule_ emit-statement[](#a4.SolidityParser.emitStatement "Bu tanım için kalıcı bağlantı")
Bir emit ifadesi. İçerilen ifadenin bir event’e referans vermesi gerekir.
emitexpressioncall-argument-list;
_rule_ revert-statement[](#a4.SolidityParser.revertStatement "Bu tanım için kalıcı bağlantı")
Bir revert ifadesi. İçerilen ifadenin bir error’e referans vermesi gerekir.
revertexpressioncall-argument-list;
_rule_ assembly-statement[](#a4.SolidityParser.assemblyStatement "Bu tanım için kalıcı bağlantı")
Bir inline assembly bloğu. Inline assembly bloğunun içeriği ayrı bir tarayıcı/lexer kullanır, yani bir inline assembly bloğunun içinde anahtar sözcükler ve izin verilen tanımlayıcılar kümesi farklıdır.
assembly'"evmasm"'assembly-flags{yul-statement}
_rule_ assembly-flags[](#a4.SolidityParser.assemblyFlags "Bu tanım için kalıcı bağlantı")
Assembly bayrakları. Bayrak olarak çift tırnaklı stringlerin virgülle ayrılmış listesi.
(assembly-flag-string,)
_rule_ variable-declaration-tuple[](#a4.SolidityParser.variableDeclarationTuple "Bu tanım için kalıcı bağlantı")
Değişken tanımlamalarında kullanılacak bir dizi değişken adı. Boş alanlar içerebilir.
(,variable-declaration,variable-declaration)
_rule_ variable-declaration-statement[](#a4.SolidityParser.variableDeclarationStatement "Bu tanım için kalıcı bağlantı")
Bir değişken tanımlama ifadesi. Tek bir değişken başlangıç değeri olmadan tanımlanabilirken, değişken çiftleri yalnızca başlangıç değeriyle tanımlanabilir.
variable-declaration\=expressionvariable-declaration-tuple\=expression;
_rule_ expression-statement[](#a4.SolidityParser.expressionStatement "Bu tanım için kalıcı bağlantı")
expression;
_rule_ mapping-type[](#a4.SolidityParser.mappingType "Bu tanım için kalıcı bağlantı")
mapping(mapping-key-type\=>type-name)
_rule_ mapping-key-type[](#a4.SolidityParser.mappingKeyType "Bu tanım için kalıcı bağlantı")
Eşleme anahtarları olarak yalnızca temel tipler veya kullanıcı tanımlı tipler kullanılabilir.
elementary-type-nameidentifier-path
_rule_ yul-statement[](#a4.SolidityParser.yulStatement "Bu tanım için kalıcı bağlantı")
Inline assembly bloğu içinde bir Yul ifadesi. continue ve break ifadeleri yalnızca for döngüleri içinde geçerlidir. leave ifadeleri yalnızca fonksiyon gövdeleri içinde geçerlidir.
yul-blockyul-variable-declarationyul-assignmentyul-function-callyul-if-statementyul-for-statementyul-switch-statementleavebreakcontinueyul-function-definition
_rule_ yul-block[](#a4.SolidityParser.yulBlock "Bu tanım için kalıcı bağlantı")
{yul-statement}
_rule_ yul-variable-declaration[](#a4.SolidityParser.yulVariableDeclaration "Bu tanım için kalıcı bağlantı")
İsteğe bağlı başlangıç değerine sahip bir veya daha fazla Yul değişkeninin tanımlanması. Birden fazla değişken tanımlanmışsa, yalnızca bir fonksiyon çağrısı geçerli bir başlangıç değeridir.
letyul-identifier:=yul-expressionletyul-identifier,:=yul-function-call
_rule_ yul-assignment[](#a4.SolidityParser.yulAssignment "Bu tanım için kalıcı bağlantı")
Herhangi bir ifade tek bir Yul değişkenine atanabilirken, çoklu atamalar için bir yandan bir fonksiyon çağrısı yapılması gerekir.
yul-path:=yul-expressionyul-path,yul-path:=yul-function-call
_rule_ yul-if-statement[](#a4.SolidityParser.yulIfStatement "Bu tanım için kalıcı bağlantı")
ifyul-expressionyul-block
_rule_ yul-for-statement[](#a4.SolidityParser.yulForStatement "Bu tanım için kalıcı bağlantı")
foryul-blockyul-expressionyul-blockyul-block
_rule_ yul-switch-statement[](#a4.SolidityParser.yulSwitchStatement "Bu tanım için kalıcı bağlantı")
Bir Yul switch ifadesi yalnızca bir varsayılan durumdan (kullanımdan kaldırılmıştır) veya isteğe bağlı olarak bir varsayılan durum tarafından takip edilen bir veya daha fazla varsayılan olmayan durumdan oluşabilir.
switchyul-expressioncaseyul-literalyul-blockdefaultyul-blockdefaultyul-block
_rule_ yul-function-definition[](#a4.SolidityParser.yulFunctionDefinition "Bu tanım için kalıcı bağlantı")
functionyul-identifier(yul-identifier,)\->yul-identifier,yul-block
_rule_ yul-path[](#a4.SolidityParser.yulPath "Bu tanım için kalıcı bağlantı")
Inline assembly içinde yalnızca noktasız tanımlayıcılar bildirilebilirken, nokta içeren yollar inline assembly bloğunun dışındaki bildirimlere başvurabilir.
yul-identifier.yul-identifieryul-evm-builtin
_rule_ yul-function-call[](#a4.SolidityParser.yulFunctionCall "Bu tanım için kalıcı bağlantı")
Dönüş değerlerine sahip bir fonksiyon çağrısı yalnızca bir atama veya değişken bildiriminin sağ tarafı olarak gerçekleşebilir.
yul-identifieryul-evm-builtin(yul-expression,)
_rule_ yul-boolean[](#a4.SolidityParser.yulBoolean "Bu tanım için kalıcı bağlantı")
truefalse
_rule_ yul-literal[](#a4.SolidityParser.yulLiteral "Bu tanım için kalıcı bağlantı")
yul-decimal-numberyul-string-literalyul-hex-numberyul-booleanhex-string
_rule_ yul-expression[](#a4.SolidityParser.yulExpression "Bu tanım için kalıcı bağlantı")
yul-pathyul-function-callyul-literal
_lexer grammar_ SolidityLexer[](#a4.SolidityLexer "Bu tanım için kalıcı bağlantı")
_rule_ fixed-bytes[](#a4.SolidityLexer.FixedBytes "Bu tanım için kalıcı bağlantı")
Sabit uzunluktaki bayt tipleri.
'bytes1''bytes2''bytes3''bytes4''bytes5''bytes6''bytes7''bytes8''bytes9''bytes10''bytes11''bytes12''bytes13''bytes14''bytes15''bytes16''bytes17''bytes18''bytes19''bytes20''bytes21''bytes22''bytes23''bytes24''bytes25''bytes26''bytes27''bytes28''bytes29''bytes30''bytes31''bytes32'
_rule_ number-unit[](#a4.SolidityLexer.NumberUnit "Bu tanım için kalıcı bağlantı")
Sayılar için birim gösterimi.
'wei''gwei''ether''seconds''minutes''hours''days''weeks''years'
_rule_ signed-integer-type[](#a4.SolidityLexer.SignedIntegerType "Bu tanım için kalıcı bağlantı")
Boyutlandırılmış işaretli tamsayı(int) türleri. int, int256’nın takma adıdır.
'int''int8''int16''int24''int32''int40''int48''int56''int64''int72''int80''int88''int96''int104''int112''int120''int128''int136''int144''int152''int160''int168''int176''int184''int192''int200''int208''int216''int224''int232''int240''int248''int256'
_rule_ unsigned-integer-type[](#a4.SolidityLexer.UnsignedIntegerType "Bu tanım için kalıcı bağlantı")
Boyutlandırılmış işaretsiz tamsayı(uint) türleri. uint, uint256’nın takma adıdır.
'uint''uint8''uint16''uint24''uint32''uint40''uint48''uint56''uint64''uint72''uint80''uint88''uint96''uint104''uint112''uint120''uint128''uint136''uint144''uint152''uint160''uint168''uint176''uint184''uint192''uint200''uint208''uint216''uint224''uint232''uint240''uint248''uint256'
_rule_ non-empty-string-literal[](#a4.SolidityLexer.NonEmptyStringLiteral "Bu tanım için kalıcı bağlantı")
Yazdırılabilir karakterlerle sınırlandırılmış, boş olmayan alıntılanmış bir string literali.
'"'double-quoted-printableescape-sequence'"''\\''single-quoted-printableescape-sequence'\\''
_rule_ empty-string-literal[](#a4.SolidityLexer.EmptyStringLiteral "Bu tanım için kalıcı bağlantı")
Boş bir string literali
'"''"''\\'''\\''
_rule_ single-quoted-printable[](#a4.SolidityLexer.SingleQuotedPrintable "Bu tanım için kalıcı bağlantı")
Tek tırnak veya ters eğik çizgi dışında yazdırılabilir herhangi bir karakter.
\[\\u0020-\\u0026\\u0028-\\u005B\\u005D-\\u007E\]
_rule_ double-quoted-printable[](#a4.SolidityLexer.DoubleQuotedPrintable "Bu tanım için kalıcı bağlantı")
Çift tırnak veya ters eğik çizgi dışında yazdırılabilir herhangi bir karakter.
\[\\u0020-\\u0021\\u0023-\\u005B\\u005D-\\u007E\]
_rule_ escape-sequence[](#a4.SolidityLexer.EscapeSequence "Bu tanım için kalıcı bağlantı")
Kaçış sırası. Yaygın tek karakterli kaçış sıralarının yanı sıra, satır sonları da kaçabilir ve dört onaltılık basamaklı unicode kaçışlarına \\uXXXX ve iki basamaklı onaltılık kaçış sıralarına \\xXX izin verilir.
'\\\\'\['"\\\\nrt\\n\\r\]'u'\[0-9A-Fa-f\]\[0-9A-Fa-f\]\[0-9A-Fa-f\]\[0-9A-Fa-f\]'x'\[0-9A-Fa-f\]\[0-9A-Fa-f\]
_rule_ unicode-string-literal[](#a4.SolidityLexer.UnicodeStringLiteral "Bu tanım için kalıcı bağlantı")
Rastgele unicode karakterlere izin veren tek tırnaklı bir string literal.
'unicode"'~\["\\r\\n\\\\\]escape-sequence'"''unicode\\''~\['\\r\\n\\\\\]escape-sequence'\\''
_rule_ hex-string[](#a4.SolidityLexer.HexString "Bu tanım için kalıcı bağlantı")
Onaltılı dizelerin, alt çizgi kullanılarak gruplandırılabilen çift sayıda onaltılı rakamlardan oluşması gerekir.
'hex''"'\[0-9A-Fa-f\]\[0-9A-Fa-f\]'\_''"''\\''\[0-9A-Fa-f\]\[0-9A-Fa-f\]'\_''\\''
_rule_ hex-number[](#a4.SolidityLexer.HexNumber "Bu tanım için kalıcı bağlantı")
Onaltılı sayılar bir önek ve alt çizgilerle sınırlandırılabilen rastgele sayıda onaltılı rakamlardan oluşur.
'0''x'\[0-9A-Fa-f\]'\_'
_rule_ decimal-number[](#a4.SolidityLexer.DecimalNumber "Bu tanım için kalıcı bağlantı")
Bir ondalık sayı literali, alt çizgilerle sınırlandırılabilen ondalık basamaklardan ve isteğe bağlı bir pozitif veya negatif üstel sayıdan oluşur. Rakamlar bir ondalık nokta içeriyorsa, literal sabit nokta tipine sahiptir.
\[0-9\]'\_'\[0-9\]'\_''.'\[0-9\]'\_'\[eE\]'-'\[0-9\]'\_'
_rule_ identifier[](#a4.SolidityLexer.Identifier "Bu tanım için kalıcı bağlantı")
Solidity’de bir tanımlayıcı bir harf, bir dolar işareti veya bir alt çizgi ile başlamalıdır ve ilk sembolden sonra ek olarak sayılar içerebilir.
\[a-zA-Z$\_\]\[a-zA-Z0-9$\_\]
_rule_ yul-evm-builtin[](#a4.SolidityLexer.YulEVMBuiltin "Bu tanım için kalıcı bağlantı")
EVM Yul diyalektinde bulunan dahili fonksiyonlar.
'stop''add''sub''mul''div''sdiv''mod''smod''exp''not''lt''gt''slt''sgt''eq''iszero''and''or''xor''byte''shl''shr''sar''addmod''mulmod''signextend''keccak256''pop''mload''mstore''mstore8''sload''sstore''msize''gas''address''balance''selfbalance''caller''callvalue''calldataload''calldatasize''calldatacopy''extcodesize''extcodecopy''returndatasize''returndatacopy''extcodehash''create''create2''call''callcode''delegatecall''staticcall''return''revert''selfdestruct''invalid''log0''log1''log2''log3''log4''chainid''origin''gasprice''blockhash''coinbase''timestamp''number''difficulty''gaslimit''basefee'
_rule_ yul-identifier[](#a4.SolidityLexer.YulIdentifier "Bu tanım için kalıcı bağlantı")
Yul tanımlayıcıları harflerden, dolar işaretlerinden, alt çizgilerden ve sayılardan oluşur, ancak bir sayı ile başlamayabilir. Satır içi assembly’de kullanıcı tanımlı tanımlayıcılarda nokta olamaz. Bunun yerine noktalı tanımlayıcılardan oluşan ifadeler için yulPath bölümüne bakın.
\[a-zA-Z$\_\]\[a-zA-Z0-9$\_\]
_rule_ yul-hex-number[](#a4.SolidityLexer.YulHexNumber "Bu tanım için kalıcı bağlantı")
Yul’daki onaltılık değişmezler bir önek ve bir veya daha fazla onaltılık basamaktan oluşur.
'0''x'\[0-9a-fA-F\]
_rule_ yul-decimal-number[](#a4.SolidityLexer.YulDecimalNumber "Bu tanım için kalıcı bağlantı")
Yul’daki ondalık literaller sıfır veya başlarında sıfır olmayan herhangi bir ondalık basamak sırası olabilir.
'0'\[1-9\]\[0-9\]
_rule_ yul-string-literal[](#a4.SolidityLexer.YulStringLiteral "Bu tanım için kalıcı bağlantı")
Yul’da bulunan string literalleri, kaçış sıralarını ve yazılmamış satır sonları veya kaçış sırasız çift tırnaklar veya tek tırnaklar dışındaki yazdırılabilir karakterleri içerebilen bir veya daha fazla çift tırnaklı veya tek tırnaklı stringlerden oluşur.
'"'double-quoted-printableescape-sequence'"''\\''single-quoted-printableescape-sequence'\\''
_rule_ pragma-token[](#a4.SolidityLexer.PragmaToken "Bu tanım için kalıcı bağlantı")
Pragma belirteci. Noktalı virgül hariç her türlü sembolü içerebilir. Şu andaki solidity çözümleyicisinin bunun yalnızca bir alt kümesine izin verdiğini unutmayın.

# [Solidity v0.8.0 重大变化 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/080-breaking-changes.html) 
 _https://docs.soliditylang.org/zh-cn/latest/080-breaking-changes.html_

本节强调了 Solidity 0.8.0 版本中引入的主要重大变化。对于完整的列表，请查看 [版本更新日志](https://github.com/ethereum/solidity/releases/tag/v0.8.0)。
## 语义的微小变化[](#id2 "此标题的永久链接")
本节列出了现有代码在编译器没有通知您的情况下改变其行为的更改。
* 算术操作在下溢和溢出时都会恢复。您可以使用 `unchecked { ... }` 来使用以前的包装行为。
 
 溢出的检查是非常普遍的，所以我们把它作为默认的检查， 以增加代码的可读性，即使它是以略微增加燃料成本为代价的。
 
* ABI编码器v2默认是激活的。
 
 您可以使用 `pragma abicoder v1;` 来选择使用旧的行为。 语句 `pragma experimental ABIEncoderV2;` 仍然有效，但它已被废弃，没有效果。 如果您想显式使用，请使用 `pragma abicoder v2;` 代替。
 
 请注意，ABI coder v2比v1支持更多的类型，并对输入进行更多的合理性检查。 ABI coder v2使一些函数调用更加昂贵，而且当合约中包含不符合参数类型的数据时，它还会使合约调用回退， 而在ABI coder v1中则没有回退。
 
* 指数是右联的，也就是说，表达式 `a**b**c` 被解析为 `a**（b**c）`。 在0.8.0之前，它被解析为 `(a**b)**c`。
 
 这是解析指数运算符的常用方法。
 
* 失败的断言和其他内部检查，如除以零或算术溢出，不使用无效的操作码，而是使用恢复操作码。 更具体地说，它们将使用等于对 `Panic(uint256)` 的函数调用的错误数据，其错误代码是针对具体情况的。
 
 这将节省错误的燃料，同时它仍然允许静态分析工具将这些情况与无效输入的恢复区分开来， 比如一个失败的 `require`。
 
* 如果访问存储中的一个字节数组，其长度被错误地编码，就会引起panic错误。 合约不会出现这种情况，除非使用内联汇编来修改存储字节数组的原始表示。
 
* 如果常数被用于数组长度表达式中，Solidity 的先前版本将在评估树的所有分支中使用任意精度。 现在，如果常量变量被用作中间表达式，它们的值将以与它们在运行时表达式中使用时相同的方式被正确舍入。
 
* 类型 `byte` 已经被删除。它是 `bytes1` 的别名。
 
## 新的限制条件[](#id3 "此标题的永久链接")
本节列出了可能导致现有合约不再编译的变化。
* 有一些与字面常量的显式转换有关的新限制。以前在以下情况下的行为可能是模糊的：
 
 1. 不允许从负数字段和大于 `type(uint160).max` 的字段显式转换为 `address`。
 
 2. 只有当字面常量位于 `type(T).min` 和 `type(T).max` 之间时， 才允许字面常量与整数类型 `T` 之间的明确转换。 特别的是，用 `type(uint).max` 代替 `uint(-1)` 的使用。
 
 3. 只有当字面常量能够代表枚举中的一个值时，才允许字面常量和枚举之间的显式转换。
 
 4. 字面常量和 `address` 类型之间的显式转换（例如， `address(literal)`）是 `address` 类型， 而不是 `address payable` 类型。通过使用显式转换，即 `payable(literal)`， 可以得到一个payable类型的地址类型。
 
* [地址字面常量](https://docs.soliditylang.org/zh-cn/latest/types.html#address-literals) 的类型是 `address`，而不是 `address payable`。 它们可以通过显式的转换转换为 `address payable` 类型， 例如： `payable(0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF)`。
 
* 对显式类型转换有新的限制。只有当符号，宽度或类型类别（ `int`， `address`， `bytesNN` 等） 有最多一次变化时，才允许进行转换。要执行多个变化，请使用多个转换。
 
 让我们使用符号 `T(S)` 来表示显式转换 `T(x)`，其中， `T` 和 `S` 是类型， `x` 是 `S` 类型的任何任意变量。这种不允许的转换的例子是 `uint16(int8)`， 因为它同时改变了宽度（8位到16位）和符号（有符号整数到无符号整数）。为了进行转换，我们必须通过一个中间类型。 在前面的例子中，这将是 `uint16(uint8(int8))` 或者 `uint16(int16(int8))`。 请注意，这两种转换方式将产生不同的结果，例如，对于 `-1`。下面是这个规则不允许的一些转换的例子。
 
 * `address(uint)` 和 `uint(address)`：同时转换类型和宽度。 分别用 `address(uint160(uint))` 和 `uint(uint160(address))` 代替。
 
 * `payable(uint160)`， `payable(bytes20)` 和 `payable(integer-literal)`： 同时转换了类型和状态可变性。 分别用 `payable(address(uint160))`， `payable(address(bytes20))` 和 `payable(address(integer-literal))` 代替。请注意， `payable(0)` 是有效的，是规则的例外。
 
 * `int80(bytes10)` 和 `bytes10(int80)`：同时转换了类型和符号。 分别用 `int80(uint80(bytes10))` 和 `bytes10(uint80(int80))` 代替。
 
 * `Contract(uint)`: 同时转换类型和宽度。用 `Contract(address(uint160(uint)))` 代替。
 
 
 这些转换是不允许的，以避免歧义。例如，在表达式 `uint16 x = uint16(int8(-1))` 中， `x` 的值取决于是先应用符号还是宽度转换。
 
* 函数调用选项只能给出一次，即 `c.f{gas: 10000}{value: 1}()` 是无效的， 必须改成 `c.f{gas: 10000, value: 1}()`。
 
* 全局函数 `log0`， `log1`， `log2`， `log3` 和 `log4` 已被删除。
 
 这些都是低级别的函数，基本上没有被使用过。它们的行为可以通过内联汇编访问。
 
* `enum` 定义包含的成员不能超过256个。
 
 这将使我们可以安全地假设ABI中的底层类型总是 `uint8`。
 
* 除了公共函数和事件之外，不允许使用 `this`， `super` 和 `_` 的名称进行声明。 这个例外是为了使声明用Solidity以外的语言实现的合约的接口成为可能，这些语言确实允许这种函数名称。
 
* 移除对代码中的 `\b`， `\f` 和 `\v` 转义序列的支持。 它们仍然可以通过十六进制转义插入，例如：分别是 `\x08`， `\x0c`， 和 `\x0b`。
 
* 全局变量 `tx.origin` 和 `msg.sender` 的类型是 `address` 而不是 `address payable`。 我们可以通过显式转换将它们转换为 `address payable` 类型， 即 `payable(tx.origin)` 或 `payable(msg.sender)`。
 
 做这个改变是因为编译器不能确定这些地址是否可以支付，所以现在需要一个明确的转换来使这个要求可见。
 
* 显式转换为 `address` 类型总是返回一个非-payable类型的 `address`。 特别是，以下显式转换的类型是 `address` 而不是 `address payable`：
 
 * `address(u)` 其中 `u` 是一个 `uint160` 类型的变量。 我们可以通过两个显式转换将 `u` 转换为 `address payable` 类型，即 `payable(address(u))`。
 
 * `address(b)` 其中 `b` 是一个 `bytes20` 类型的变量。 我们可以通过两个显式转换将 `b` 转换为 `address payable` 类型，即 `payable(address(b))`。
 
 * `address(c)` 其中 `c` 是一个合约。以前，这种转换的返回类型取决于合约是否可以接收以太 （要么有一个receive函数，要么有一个payable类型的fallback函数）。 转换 `payable(c)` 的类型为 `address payable`，只有当合约 `c` 可以接收以太时才允许。 一般来说，人们总是可以通过使用以下显式转换将 `c` 转换为 `address payable` 的类型： `payable(address(c))`。请注意， `address(this)` 与 `address(c)` 属于同一类别， 同样的规则也适用于它。
 
* 内联汇编中的 `chainid` 现在被认为是 `view` 而不是 `pure`。
 
* 一元求反不能再用于无符号整数，只能用于有符号整数。
 
## 接口变化[](#id4 "此标题的永久链接")
* `--combined-json` 的输出已经改变。JSON字段 `abi`, `devdoc`, `userdoc` 和 `storage-layout` 现在是子对象。在0.8.0之前，它们曾被序列化为字符串。
 
* “传统AST“ 已被删除（ `--ast-json` 在命令行界面， `legacyAST` 用于标准JSON）。 使用 “紧凑型AST”（ `--ast-compact-json` 参数. `AST`）作为替代。
 
* 旧的错误报告器（ `--old-reporter` ）已经被删除。
 
## 如何更新您的代码[](#id5 "此标题的永久链接")
* 如果您依赖包装算术，请用 `unchecked { ... }` 包裹每个操作。
 
* 可选：如果您使用SafeMath或类似的库，将 `x.add(y)` 改为 `x + y`， `x.mul(y)` 改为 `x * y` 等等。
 
* 如果您想继续使用旧的ABI编码器，请添加 `pragma abicoder v1;`。
 
* 可以选择删除 `pragma experimental ABIEncoderV2` 或 `pragma abicoder v2` 因为它是多余的。
 
* 将 `byte` 改为 `bytes1`。
 
* 如果需要的话，添加中间显式类型转换。
 
* 将 `c.f{gas: 10000}{value: 1}()` 合并为 `c.f{gas: 10000, value: 1}()`。
 
* 将 `msg.sender.transfer(x)` 改为 `payable(msg.sender).transfer(x)` 或者使用 `address payable` 类型的存储变量。
 
* 将 `x**y**z` 改为 `(x**y)**z`。
 
* Use inline assembly as a replacement for `log0`, …, `log4`.
 
* 使用内联汇编作为 `log0`， …， `log4` 的替代。
 
* 将无符号整数取反的方法是从该类型的最大值中减去该整数，并加上1（例如， `type(uint256).max - x + 1`，同时确保 x 不为零）。

# [Solidity v0.8.0 Changements de rupture — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/080-breaking-changes.html) 
 _https://docs.soliditylang.org/fr/latest/080-breaking-changes.html_

Cette section met en évidence les principaux changements de rupture introduits dans Solidity version 0.8.0. Pour la liste complète, consultez le changelog de la version [0.8.0](https://github.com/ethereum/solidity/releases/tag/v0.8.0).
## Changements silencieux de la sémantique[](#changements-silencieux-de-la-semantique "Lien permanent vers cette rubrique")
Cette section répertorie les modifications où le code existant change de comportement sans que le compilateur vous en informe.
* Les opérations arithmétiques s’inversent en cas de sous-dépassement et de dépassement. Vous pouvez utiliser `unchecked { ... }` pour utiliser le comportement d’enveloppement précédent.
 
 Les vérifications pour le débordement sont très communes, donc nous les avons faites par défaut pour augmenter la lisibilité du code, même si cela entraîne une légère augmentation du coût de l’essence.
 
* ABI coder v2 est activé par défaut.
 
 Vous pouvez choisir d’utiliser l’ancien comportement en utilisant `pragma abicoder v1;`. Le pragma `pragma experimental ABIEncoderV2;` est toujours valide, mais il est déprécié et n’a aucun effet. Si vous voulez être explicite, veuillez utiliser le pragma `pragma abicoder v2;` à la place.
 
 Notez que ABI coder v2 supporte plus de types que v1 et effectue plus de contrôles d’intégrité sur les entrées. ABI coder v2 rend certains appels de fonctions plus coûteux et il peut aussi faire des appels de contrats réversibles qui n’étaient pas réversibles avec ABI coder v1 lorsqu’ils contiennent des données qui ne sont pas conformes aux types de paramètres. types de paramètres.
 
* L’exponentiation est associative à droite, c’est-à-dire que l’expression `a**b**c` est interprétée comme `a**(b**c)`. Avant la version 0.8.0, elle était interprétée comme `(a**b)**c`.
 
 C’est la façon courante d’analyser l’opérateur d’exponentiation.
 
* Les assertions qui échouent et d’autres vérifications internes comme la division par zéro ou le dépassement arithmétique n’utilisent pas l’opcode invalide mais plutôt l’opcode de retour. Plus précisément, ils utiliseront des données d’erreur égales à un appel de fonction à `Panic(uint256)` avec un code d’erreur spécifique aux circonstances. aux circonstances.
 
 Cela permettra d’économiser du gaz sur les erreurs tout en permettant aux outils d’analyse statique de distinguer ces situations d’un retour sur invalidité. distinguer ces situations d’un retour en arrière sur une entrée invalide, comme un `require` échoué.
 
* Si l’on accède à un tableau d’octets en stockage dont la longueur est mal codée, une panique est provoquée. Un contrat ne peut pas se retrouver dans cette situation à moins que l’assemblage en ligne soit utilisé pour modifier la représentation brute des tableaux d’octets de stockage.
 
* Si des constantes sont utilisées dans les expressions de longueur de tableau, les versions précédentes de Solidity utilisaient une précision arbitraire dans toutes les branches de l’arbre d’évaluation. dans toutes les branches de l’arbre d’évaluation. Maintenant, si des variables constantes sont utilisées comme expressions intermédiaires, leurs valeurs seront correctement arrondies de la même manière que lorsqu’elles sont utilisées dans des expressions d’exécution.
 
* Le type `byte` a été supprimé. C’était un alias de `bytes1`.
 
## Nouvelles restrictions[](#nouvelles-restrictions "Lien permanent vers cette rubrique")
Cette section énumère les changements qui pourraient empêcher les contrats existants de se compiler.
* Il existe de nouvelles restrictions liées aux conversions explicites de littéraux. Le comportement précédent dans les cas suivants était probablement ambigu :
 
 1. Les conversions explicites de littéraux négatifs et de littéraux plus grands que `type(uint160).max` en `adresse` sont interdites.
 
 2. Les conversions explicites entre des littéraux et un type de nombre entier `T` ne sont autorisées que si le littéral se situe entre `type(T).min` et `type(T).max`. En particulier, remplacez les utilisations de `uint(-1)` par `type(uint)`. par `type(uint).max`.
 
 3. Les conversions explicites entre les littéraux et les énumérations ne sont autorisées que si le littéral peut représenter une valeur de l’énumération.
 
 4. Les conversions explicites entre les littéraux et le type `adresse` (par exemple `address(literal)`) ont le type `address`. type `adresse` au lieu de `adresse payable`. On peut obtenir un type d’adresse payable en utilisant une conversion explicite, c’est-à-dire `payable(literal)`.
 
* [Les littéraux d’adresse](https://docs.soliditylang.org/fr/latest/types.html#address-literals) ont le type `address` au lieu de `address payable`. Ils peuvent être convertis en `adresse payable` en utilisant une conversion explicite, par exemple `payable(0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF)`.
 
* Il y a de nouvelles restrictions sur les conversions de type explicites. La conversion n’est autorisée que lorsqu’il y a lorsqu’il y a au plus un changement de signe, de largeur ou de catégorie de type (`int`, `address`, `bytesNN`, etc.). Pour effectuer plusieurs changements, il faut utiliser plusieurs conversions.
 
 Utilisons la notation `T(S)` pour désigner la conversion explicite `T(x)`, où, `T` et `S` sont des types, et `x` est une variable arbitraire de type `S`. Un exemple d’une telle exemple d’une telle conversion non autorisée serait `uint16(int8)` puisqu’elle change à la fois la largeur (8 bits à 16 bits) et le signe (d’entier signé à entier non signé). Pour effectuer la conversion, il faut passer par un type intermédiaire. passer par un type intermédiaire. Dans l’exemple précédent, ce serait `uint16(uint8(int8))` ou `uint16(int16(int8))`. Notez que les deux façons de convertir produiront des résultats différents, par ex, pour `-1`. Voici quelques exemples de conversions qui ne sont pas autorisées par cette règle.
 
 * `address(uint)` et `uint(address)` : conversion à la fois de la catégorie de type et de la largeur. Remplacez-les par `address(uint160(uint))` et `uint(uint160(address))` respectivement.
 
 * `payable(uint160)`, `payable(bytes20)` et `payable(integer-literal)` : conversion de la catégorie de type et de la la catégorie de type et la mutabilité d’état. Remplacez-les par `payable(address(uint160))`, `payable(address(bytes20))` et `payable(address(integer-literal))` respectivement. Notez que `payable(0)` est valide et constitue une exception à la règle.
 
 * `int80(bytes10)` et `bytes10(int80)` : conversion de la catégorie de type et du signe. Remplacez-les par `int80(uint80(bytes10))` et `bytes10(uint80(int80)` respectivement.
 
 * `Contract(uint)` : convertit à la fois la catégorie de type et le signe. Remplacez-la par `Contract(adresse(uint160(uint)))`.
 
 
 Ces conversions ont été interdites pour éviter toute ambiguïté. Par exemple, dans l’expression `uint16 x = uint16(int8(-1))`, la valeur de `x` dépendrait de la conversion du signe ou de la largeur appliquée en premier lieu. a été appliquée en premier.
 
* Les options d’appel de fonction ne peuvent être données qu’une seule fois, c’est-à-dire que `c.f{gas : 10000}{value : 1}()` est invalide et doit être changé en `c.f{gas : 10000, value : 1}()`.
 
* Les fonctions globales `log0`, `log1`, `log2`, `log3` et `log4` ont été supprimées.
 
 Ce sont des fonctions de bas niveau qui étaient largement inutilisées. Leur comportement est accessible depuis l’assemblage en ligne.
 
* Les définitions de `enum` ne peuvent pas contenir plus de 256 membres.
 
 Cela permet de supposer que le type sous-jacent dans l’ABI est toujours `uint8`.
 
* Les déclarations portant les noms « this », « super » et « \_ » ne sont pas autorisées, à l’exception des fonctions et événements publics. fonctions et événements publics. Cette exception a pour but de permettre la déclaration d’interfaces de contrats implémentées dans des langages autres que Solidity qui autorisent de tels noms de fonctions.
 
* Suppression de la prise en charge des séquences d’échappement `b`, `f` et ```v`'' dans le code. Elles peuvent toujours être insérées par le biais d'échappements hexadécimaux, par exemple, respectivement, " ``X08```,  » `X0c` et  » `X0b`.
 
* Les variables globales `tx.origin` et `msg.sender` ont le type `address` au lieu de `adresse payable`. On peut les convertir en `adresse payable` en utilisant une conversion explicite, c’est-à-dire `payable(tx.origin)` ou `payable(msg.sender)`.
 
 Ce changement a été fait car le compilateur ne peut pas déterminer si ces adresses sont payables ou non. sont payables ou non, donc il faut maintenant une conversion explicite pour rendre cette exigence visible.
 
* La conversion explicite en type `adresse` retourne toujours un type `adresse` non payable. Dans En particulier, les conversions explicites suivantes ont le type `adresse` au lieu de [\`\`](#id2)adresse payable  » :
 
 * `adresse(u)` où `u` est une variable de type `uint160`. On peut convertir `u` dans le type `adresse payable` en utilisant deux conversions explicites, c’est-à-dire, `payable(adresse(u))`.
 
 * `adresse(b)` où `b` est une variable de type `bytes20`. On peut convertir `b` dans le type `adresse payable` en utilisant deux conversions explicites, c’est-à-dire, `payable(adresse(b))`.
 
 * `adresse(c)` où `c` est un contrat. Auparavant, le type de retour de cette conversion dépendait de la possibilité pour le contrat de recevoir de l’Ether (soit en ayant une fonction de réception ou une fonction de repli payable). La conversion `payable(c)` a le type `adresse payable" et n'est autorisée que si le contrat "c" peut recevoir de l'éther. En général, on peut convertir ``c` en type `adresse payable` en utilisant la conversion explicite suivante explicite suivante : `payable(adresse(c))`. Notez que `address(this)` tombe sous la même catégorie que `address(c)` et les mêmes règles s’appliquent pour elle.
 
* La construction de « chainid » dans l’assemblage en ligne est maintenant considérée comme une « vue » au lieu d’une « pure ».
 
* La négation unaire ne peut plus être utilisée sur les entiers non signés, seulement sur les entiers signés.
 
## Changements d’interface[](#changements-d-interface "Lien permanent vers cette rubrique")
* La sortie de `--combined-json` a changé : Les champs JSON `abi`, `devdoc`, `userdoc` et `storage-layout` sont maintenant des sous-objets. Avant la version 0.8.0, ils étaient sérialisés sous forme de chaînes de caractères.
 
* L“« ancien AST » a été supprimé (`--ast-json` sur l’interface de la ligne de commande et `legacyAST` pour le JSON standard). Utilisez l“« AST compact » (`--ast-compact--json` resp. `AST`) en remplacement.
 
* L’ancien rapporteur d’erreurs (`--old-reporter`) a été supprimé.

# [NatSpec Format — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/natspec-format.html) 
 _https://docs.soliditylang.org/en/v0.8.30/natspec-format.html_

Solidity contracts can use a special form of comments to provide rich documentation for functions, return variables and more. This special form is named the Ethereum Natural Language Specification Format (NatSpec).
Note
NatSpec was inspired by [Doxygen](https://en.wikipedia.org/wiki/Doxygen). While it uses Doxygen-style comments and tags, there is no intention to keep strict compatibility with Doxygen. Please carefully examine the supported tags listed below.
This documentation is segmented into developer-focused messages and end-user-facing messages. These messages may be shown to the end user (the human) at the time that they will interact with the contract (i.e. sign a transaction).
It is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI).
NatSpec includes the formatting for comments that the smart contract author will use, and which are understood by the Solidity compiler. Also detailed below is output of the Solidity compiler, which extracts these comments into a machine-readable format.
NatSpec may also include annotations used by third-party tools. These are most likely accomplished via the `@custom:<name>` tag, and a good use case is analysis and verification tools.
## Documentation Example[](#documentation-example "Link to this heading")
Documentation is inserted above each `contract`, `interface`, `library`, `function`, `enum`, `enum` value and `event` using the Doxygen notation format. A `public` state variable is equivalent to a `function` for the purposes of NatSpec.
* For Solidity you may choose `///` for single or multi-line comments, or `/**` and ending with `*/`.
 
* For Vyper, use `"""` indented to the inner contents with bare comments. See the [Vyper documentation](https://docs.vyperlang.org/en/latest/natspec.html).
 
The following example shows a contract and a function using all available tags.
Note
The Solidity compiler only interprets tags if they are external or public. You are welcome to use similar comments for your internal and private functions, but those will not be parsed.
This may change in the future.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjIgPCAwLjkuMDsKCi8vLyBAdGl0bGUgQSBzaW11bGF0b3IgZm9yIHRyZWVzCi8vLyBAYXV0aG9yIExhcnJ5IEEuIEdhcmRuZXIKLy8vIEBub3RpY2UgWW91IGNhbiB1c2UgdGhpcyBjb250cmFjdCBmb3Igb25seSB0aGUgbW9zdCBiYXNpYyBzaW11bGF0aW9uCi8vLyBAZGV2IEFsbCBmdW5jdGlvbiBjYWxscyBhcmUgY3VycmVudGx5IGltcGxlbWVudGVkIHdpdGhvdXQgc2lkZSBlZmZlY3RzCi8vLyBAY3VzdG9tOmV4cGVyaW1lbnRhbCBUaGlzIGlzIGFuIGV4cGVyaW1lbnRhbCBjb250cmFjdC4KY29udHJhY3QgVHJlZSB7CiAgICAvLy8gQG5vdGljZSBDYWxjdWxhdGUgdHJlZSBhZ2UgaW4geWVhcnMsIHJvdW5kZWQgdXAsIGZvciBsaXZlIHRyZWVzCiAgICAvLy8gQGRldiBUaGUgQWxleGFuZHIgTi4gVGV0ZWFyaW5nIGFsZ29yaXRobSBjb3VsZCBpbmNyZWFzZSBwcmVjaXNpb24KICAgIC8vLyBAcGFyYW0gcmluZ3MgVGhlIG51bWJlciBvZiByaW5ncyBmcm9tIGRlbmRyb2Nocm9ub2xvZ2ljYWwgc2FtcGxlCiAgICAvLy8gQHJldHVybiBBZ2UgaW4geWVhcnMsIHJvdW5kZWQgdXAgZm9yIHBhcnRpYWwgeWVhcnMKICAgIC8vLyBAcmV0dXJuIE5hbWUgb2YgdGhlIHRyZWUKICAgIGZ1bmN0aW9uIGFnZSh1aW50MjU2IHJpbmdzKSBleHRlcm5hbCB2aXJ0dWFsIHB1cmUgcmV0dXJucyAodWludDI1Niwgc3RyaW5nIG1lbW9yeSkgewogICAgICAgIHJldHVybiAocmluZ3MgKyAxLCAidHJlZSIpOwogICAgfQoKICAgIC8vLyBAbm90aWNlIFJldHVybnMgdGhlIGFtb3VudCBvZiBsZWF2ZXMgdGhlIHRyZWUgaGFzLgogICAgLy8vIEBkZXYgUmV0dXJucyBvbmx5IGEgZml4ZWQgbnVtYmVyLgogICAgZnVuY3Rpb24gbGVhdmVzKCkgZXh0ZXJuYWwgdmlydHVhbCBwdXJlIHJldHVybnModWludDI1NikgewogICAgICAgIHJldHVybiAyOwogICAgfQp9Cgpjb250cmFjdCBQbGFudCB7CiAgICBmdW5jdGlvbiBsZWF2ZXMoKSBleHRlcm5hbCB2aXJ0dWFsIHB1cmUgcmV0dXJucyh1aW50MjU2KSB7CiAgICAgICAgcmV0dXJuIDM7CiAgICB9Cn0KCmNvbnRyYWN0IEt1bXF1YXRUcmVlIGlzIFRyZWUsIFBsYW50IHsKICAgIGZ1bmN0aW9uIGFnZSh1aW50MjU2IHJpbmdzKSBleHRlcm5hbCBvdmVycmlkZSBwdXJlIHJldHVybnMgKHVpbnQyNTYsIHN0cmluZyBtZW1vcnkpIHsKICAgICAgICByZXR1cm4gKHJpbmdzICsgMiwgIkt1bXF1YXQiKTsKICAgIH0KCiAgICAvLy8gUmV0dXJuIHRoZSBhbW91bnQgb2YgbGVhdmVzIHRoYXQgdGhpcyBzcGVjaWZpYyBraW5kIG9mIHRyZWUgaGFzCiAgICAvLy8gQGluaGVyaXRkb2MgVHJlZQogICAgZnVuY3Rpb24gbGVhdmVzKCkgZXh0ZXJuYWwgb3ZlcnJpZGUoVHJlZSwgUGxhbnQpIHB1cmUgcmV0dXJucyh1aW50MjU2KSB7CiAgICAgICAgcmV0dXJuIDM7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.2 < 0.9.0;
/// @title A simulator for trees
/// @author Larry A. Gardner
/// @notice You can use this contract for only the most basic simulation
/// @dev All function calls are currently implemented without side effects
/// @custom:experimental This is an experimental contract.
contract Tree {
 /// @notice Calculate tree age in years, rounded up, for live trees
 /// @dev The Alexandr N. Tetearing algorithm could increase precision
 /// @param rings The number of rings from dendrochronological sample
 /// @return Age in years, rounded up for partial years
 /// @return Name of the tree
 function age(uint256 rings) external virtual pure returns (uint256, string memory) {
 return (rings + 1, "tree");
 }
 /// @notice Returns the amount of leaves the tree has.
 /// @dev Returns only a fixed number.
 function leaves() external virtual pure returns(uint256) {
 return 2;
 }
}
contract Plant {
 function leaves() external virtual pure returns(uint256) {
 return 3;
 }
}
contract KumquatTree is Tree, Plant {
 function age(uint256 rings) external override pure returns (uint256, string memory) {
 return (rings + 2, "Kumquat");
 }
 /// Return the amount of leaves that this specific kind of tree has
 /// @inheritdoc Tree
 function leaves() external override(Tree, Plant) pure returns(uint256) {
 return 3;
 }
}
## Tags[](#tags "Link to this heading")
All tags are optional. The following table explains the purpose of each NatSpec tag and where it may be used. As a special case, if no tags are used then the Solidity compiler will interpret a `///` or `/**` comment in the same way as if it were tagged with `@notice`.
Tag
Context
`@title`
A title that should describe the contract/interface
contract, library, interface, struct, enum, enum values
`@author`
The name of the author
contract, library, interface, struct, enum, enum values
`@notice`
Explain to an end user what this does
contract, library, interface, function, public state variable, event, struct, enum, enum values error
`@dev`
Explain to a developer any extra details
contract, library, interface, function, state variable, event, struct, enum, enum values, error
`@param`
Documents a parameter just like in Doxygen (must be followed by parameter name)
function, event, enum values, error
`@return`
Documents the return variables of a contract’s function
function, enum, enum values, public state variable
`@inheritdoc`
Copies all missing tags from the base function (must be followed by the contract name)
function, enum, enum values, public state variable
`@custom:...`
Custom tag, semantics is application-defined
everywhere
If your function returns multiple values, like `(int quotient, int remainder)` then use multiple `@return` statements in the same format as the `@param` statements.
Custom tags start with `@custom:` and must be followed by one or more lowercase letters or hyphens. It cannot start with a hyphen however. They can be used everywhere and are part of the developer documentation.
### Dynamic expressions[](#dynamic-expressions "Link to this heading")
The Solidity compiler will pass through NatSpec documentation from your Solidity source code to the JSON output as described in this guide. The consumer of this JSON output, for example the end-user client software, may present this to the end-user directly or it may apply some pre-processing.
For example, some client software will render:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8vIEBub3RpY2UgVGhpcyBmdW5jdGlvbiB3aWxsIG11bHRpcGx5IGBhYCBieSA3)
/// @notice This function will multiply \`a\` by 7
to the end-user as:
This function will multiply 10 by 7
if a function is being called and the input `a` is assigned a value of 10.
### Inheritance Notes[](#inheritance-notes "Link to this heading")
Functions without NatSpec will automatically inherit the documentation of their base function. Exceptions to this are:
* When the parameter names are different.
 
* When there is more than one base function.
 
* When there is an explicit `@inheritdoc` tag which specifies which contract should be used to inherit.
 
## Documentation Output[](#documentation-output "Link to this heading")
When parsed by the compiler, documentation such as the one from the above example will produce two different JSON files. One is meant to be consumed by the end user as a notice when a function is executed and the other to be used by the developer.
If the above contract is saved as `ex1.sol` then you can generate the documentation using:
solc \--userdoc \--devdoc ex1.sol
And the output is below.
Note
Starting Solidity version 0.6.11 the NatSpec output also contains a `version` and a `kind` field. Currently the `version` is set to `1` and `kind` must be one of `user` or `dev`. In the future it is possible that new versions will be introduced, deprecating older ones.
### User Documentation[](#user-documentation "Link to this heading")
The above documentation will produce the following user documentation JSON file as output for the `Tree` contract:
{
 "version" : 1,
 "kind" : "user",
 "methods" :
 {
 "age(uint256)" :
 {
 "notice" : "Calculate tree age in years, rounded up, for live trees"
 },
 "leaves()" :
 {
 "notice" : "Returns the amount of leaves the tree has."
 }
 },
 "notice" : "You can use this contract for only the most basic simulation"
}
Note that the key by which to find the methods is the function’s canonical signature as defined in the [Contract ABI](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#abi-function-selector) and not simply the function’s name.
### Developer Documentation[](#developer-documentation "Link to this heading")
Apart from the user documentation file, a developer documentation JSON file should also be produced and should look like this:
{
 "version" : 1,
 "kind" : "dev",
 "author" : "Larry A. Gardner",
 "details" : "All function calls are currently implemented without side effects",
 "custom:experimental" : "This is an experimental contract.",
 "methods" :
 {
 "age(uint256)" :
 {
 "details" : "The Alexandr N. Tetearing algorithm could increase precision",
 "params" :
 {
 "rings" : "The number of rings from dendrochronological sample"
 },
 "returns" : {
 "\_0" : "Age in years, rounded up for partial years",
 "\_1" : "Name of the tree"
 }
 },
 "leaves()" :
 {
 "details" : "Returns only a fixed number."
 }
 },
 "title" : "A simulator for trees"
}

# [Solidity Assembly — Solidity 0.4.26 documentation](https://docs.soliditylang.org/en/v0.4.26/assembly.html) 
 _https://docs.soliditylang.org/en/v0.4.26/assembly.html_

[Solidity](https://docs.soliditylang.org/en/v0.4.26/index.html)
Solidity defines an assembly language that can also be used without Solidity. This assembly language can also be used as “inline assembly” inside Solidity source code. We start with describing how to use inline assembly and how it differs from standalone assembly and then specify assembly itself.
## Inline Assembly[¶](#inline-assembly "Permalink to this headline")
For more fine-grained control especially in order to enhance the language by writing libraries, it is possible to interleave Solidity statements with inline assembly in a language close to the one of the virtual machine. Due to the fact that the EVM is a stack machine, it is often hard to address the correct stack slot and provide arguments to opcodes at the correct point on the stack. Solidity’s inline assembly tries to facilitate that and other issues arising when writing manual assembly by the following features:
* functional-style opcodes: `mul(1, add(2, 3))` instead of `push1 3 push1 2 add push1 1 mul`
* assembly-local variables: `let x := add(2, 3)  let y := mload(0x40)  x := add(x, y)`
* access to external variables: `function f(uint x) public { assembly { x := sub(x, 1) } }`
* labels: `let x := 10  repeat: x := sub(x, 1) jumpi(repeat, eq(x, 0))`
* loops: `for { let i := 0 } lt(i, x) { i := add(i, 1) } { y := mul(2, y) }`
* if statements: `if slt(x, 0) { x := sub(0, x) }`
* switch statements: `switch x case 0 { y := mul(x, 2) } default { y := 0 }`
* function calls: `function f(x) -> y { switch x case 0 { y := 1 } default { y := mul(x, f(sub(x, 1))) }   }`
We now want to describe the inline assembly language in detail.
Warning
Inline assembly is a way to access the Ethereum Virtual Machine at a low level. This discards several important safety features of Solidity.
Note
TODO: Write about how scoping rules of inline assembly are a bit different and the complications that arise when for example using internal functions of libraries. Furthermore, write about the symbols defined by the compiler.
### Example[¶](#example "Permalink to this headline")
The following example provides library code to access the code of another contract and load it into a `bytes` variable. This is not possible at all with “plain Solidity” and the idea is that assembly libraries will be used to enhance the language in such ways.
pragma solidity ^0.4.0;
library GetCode {
 function at(address \_addr) public view returns (bytes o\_code) {
 assembly {
 // retrieve the size of the code, this needs assembly
 let size := extcodesize(\_addr)
 // allocate output byte array - this could also be done without assembly
 // by using o\_code = new bytes(size)
 o\_code := mload(0x40)
 // new "memory end" including padding
 mstore(0x40, add(o\_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))
 // store length in memory
 mstore(o\_code, size)
 // actually retrieve the code, this needs assembly
 extcodecopy(\_addr, add(o\_code, 0x20), 0, size)
 }
 }
}
Inline assembly could also be beneficial in cases where the optimizer fails to produce efficient code. Please be aware that assembly is much more difficult to write because the compiler does not perform checks, so you should use it for complex things only if you really know what you are doing.
pragma solidity ^0.4.16;
library VectorSum {
 // This function is less efficient because the optimizer currently fails to
 // remove the bounds checks in array access.
 function sumSolidity(uint\[\] \_data) public view returns (uint o\_sum) {
 for (uint i \= 0; i < \_data.length; ++i)
 o\_sum += \_data\[i\];
 }
 // We know that we only access the array in bounds, so we can avoid the check.
 // 0x20 needs to be added to an array because the first slot contains the
 // array length.
 function sumAsm(uint\[\] \_data) public view returns (uint o\_sum) {
 for (uint i \= 0; i < \_data.length; ++i) {
 assembly {
 o\_sum := add(o\_sum, mload(add(add(\_data, 0x20), mul(i, 0x20))))
 }
 }
 }
 // Same as above, but accomplish the entire code within inline assembly.
 function sumPureAsm(uint\[\] \_data) public view returns (uint o\_sum) {
 assembly {
 // Load the length (first 32 bytes)
 let len := mload(\_data)
 // Skip over the length field.
 //
 // Keep temporary variable so it can be incremented in place.
 //
 // NOTE: incrementing \_data would result in an unusable
 // \_data variable after this assembly block
 let data := add(\_data, 0x20)
 // Iterate until the bound is not met.
 for
 { let end := add(data, len) }
 lt(data, end)
 { data := add(data, 0x20) }
 {
 o\_sum := add(o\_sum, mload(data))
 }
 }
 }
}
### Syntax[¶](#syntax "Permalink to this headline")
Assembly parses comments, literals and identifiers exactly as Solidity, so you can use the usual `//` and `/* */` comments. Inline assembly is marked by `assembly { ... }` and inside these curly braces, the following can be used (see the later sections for more details)
> * literals, i.e. `0x123`, `42` or `"abc"` (strings up to 32 characters)
> * opcodes (in “instruction style”), e.g. `mload sload dup1 sstore`, for a list see below
> * opcodes in functional style, e.g. `add(1, mlod(0))`
> * labels, e.g. `name:`
> * variable declarations, e.g. `let x := 7`, `let x := add(y, 3)` or `let x` (initial value of empty (0) is assigned)
> * identifiers (labels or assembly-local variables and externals if used as inline assembly), e.g. `jump(name)`, `3 x add`
> * assignments (in “instruction style”), e.g. `3 =: x`
> * assignments in functional style, e.g. `x := add(y, 3)`
> * blocks where local variables are scoped inside, e.g. `{ let x := 3 { let y := add(x, 1) } }`
### Opcodes[¶](#opcodes "Permalink to this headline")
This document does not want to be a full description of the Ethereum virtual machine, but the following list can be used as a reference of its opcodes.
If an opcode takes arguments (always from the top of the stack), they are given in parentheses. Note that the order of arguments can be seen to be reversed in non-functional style (explained below). Opcodes marked with `-` do not push an item onto the stack, those marked with `*` are special and all others push exactly one item onto the stack. Opcodes marked with `F`, `H`, `B` or `C` are present since Frontier, Homestead, Byzantium or Constantinople, respectively. Constantinople is still in planning and all instructions marked as such will result in an invalid instruction exception.
In the following, `mem[a...b)` signifies the bytes of memory starting at position `a` up to (excluding) position `b` and `storage[p]` signifies the storage contents at position `p`.
The opcodes `pushi` and `jumpdest` cannot be used directly.
In the grammar, opcodes are represented as pre-defined identifiers.
 
Instruction
 
 
Explanation
stop
\-
F
stop execution, identical to return(0,0)
add(x, y)
 
F
x + y
sub(x, y)
 
F
x - y
mul(x, y)
 
F
x \* y
div(x, y)
 
F
x / y
sdiv(x, y)
 
F
x / y, for signed numbers in two’s complement
mod(x, y)
 
F
x % y
smod(x, y)
 
F
x % y, for signed numbers in two’s complement
exp(x, y)
 
F
x to the power of y
not(x)
 
F
~x, every bit of x is negated
lt(x, y)
 
F
1 if x < y, 0 otherwise
gt(x, y)
 
F
1 if x > y, 0 otherwise
slt(x, y)
 
F
1 if x < y, 0 otherwise, for signed numbers in two’s complement
sgt(x, y)
 
F
1 if x > y, 0 otherwise, for signed numbers in two’s complement
eq(x, y)
 
F
1 if x == y, 0 otherwise
iszero(x)
 
F
1 if x == 0, 0 otherwise
and(x, y)
 
F
bitwise and of x and y
or(x, y)
 
F
bitwise or of x and y
xor(x, y)
 
F
bitwise xor of x and y
byte(n, x)
 
F
nth byte of x, where the most significant byte is the 0th byte
shl(x, y)
 
C
logical shift left y by x bits
shr(x, y)
 
C
logical shift right y by x bits
sar(x, y)
 
C
arithmetic shift right y by x bits
addmod(x, y, m)
 
F
(x + y) % m with arbitrary precision arithmetics
mulmod(x, y, m)
 
F
(x \* y) % m with arbitrary precision arithmetics
signextend(i, x)
 
F
sign extend from (i\*8+7)th bit counting from least significant
keccak256(p, n)
 
F
keccak(mem\[p…(p+n)))
sha3(p, n)
 
F
keccak(mem\[p…(p+n)))
jump(label)
\-
F
jump to label / code position
jumpi(label, cond)
\-
F
jump to label if cond is nonzero
pc
 
F
current position in code
pop(x)
\-
F
remove the element pushed by x
dup1 … dup16
 
F
copy ith stack slot to the top (counting from top)
swap1 … swap16
\*
F
swap topmost and ith stack slot below it
mload(p)
 
F
mem\[p..(p+32))
mstore(p, v)
\-
F
mem\[p..(p+32)) := v
mstore8(p, v)
\-
F
mem\[p\] := v & 0xff (only modifies a single byte)
sload(p)
 
F
storage\[p\]
sstore(p, v)
\-
F
storage\[p\] := v
msize
 
F
size of memory, i.e. largest accessed memory index
gas
 
F
gas still available to execution
address
 
F
address of the current contract / execution context
balance(a)
 
F
wei balance at address a
caller
 
F
call sender (excluding `delegatecall`)
callvalue
 
F
wei sent together with the current call
calldataload(p)
 
F
call data starting from position p (32 bytes)
calldatasize
 
F
size of call data in bytes
calldatacopy(t, f, s)
\-
F
copy s bytes from calldata at position f to mem at position t
codesize
 
F
size of the code of the current contract / execution context
codecopy(t, f, s)
\-
F
copy s bytes from code at position f to mem at position t
extcodesize(a)
 
F
size of the code at address a
extcodecopy(a, t, f, s)
\-
F
like codecopy(t, f, s) but take code at address a
returndatasize
 
B
size of the last returndata
returndatacopy(t, f, s)
\-
B
copy s bytes from returndata at position f to mem at position t
create(v, p, s)
 
F
create new contract with code mem\[p..(p+s)) and send v wei and return the new address
create2(v, n, p, s)
 
C
create new contract with code mem\[p..(p+s)) at address keccak256(<address> . n . keccak256(mem\[p..(p+s))) and send v wei and return the new address
call(g, a, v, in, insize, out, outsize)
 
F
call contract at address a with input mem\[in..(in+insize)) providing g gas and v wei and output area mem\[out..(out+outsize)) returning 0 on error (eg. out of gas) and 1 on success
callcode(g, a, v, in, insize, out, outsize)
 
F
identical to `call` but only use the code from a and stay in the context of the current contract otherwise
delegatecall(g, a, in, insize, out, outsize)
 
H
identical to `callcode` but also keep `caller` and `callvalue`
staticcall(g, a, in, insize, out, outsize)
 
B
identical to `call(g, a, 0, in, insize, out, outsize)` but do not allow state modifications
return(p, s)
\-
F
end execution, return data mem\[p..(p+s))
revert(p, s)
\-
B
end execution, revert state changes, return data mem\[p..(p+s))
selfdestruct(a)
\-
F
end execution, destroy current contract and send funds to a
invalid
\-
F
end execution with invalid instruction
log0(p, s)
\-
F
log without topics and data mem\[p..(p+s))
log1(p, s, t1)
\-
F
log with topic t1 and data mem\[p..(p+s))
log2(p, s, t1, t2)
\-
F
log with topics t1, t2 and data mem\[p..(p+s))
log3(p, s, t1, t2, t3)
\-
F
log with topics t1, t2, t3 and data mem\[p..(p+s))
log4(p, s, t1, t2, t3, t4)
\-
F
log with topics t1, t2, t3, t4 and data mem\[p..(p+s))
origin
 
F
transaction sender
gasprice
 
F
gas price of the transaction
blockhash(b)
 
F
hash of block nr b - only for last 256 blocks excluding current
coinbase
 
F
current mining beneficiary
timestamp
 
F
timestamp of the current block in seconds since the epoch
number
 
F
current block number
difficulty
 
F
difficulty of the current block
gaslimit
 
F
block gas limit of the current block
### Literals[¶](#literals "Permalink to this headline")
You can use integer constants by typing them in decimal or hexadecimal notation and an appropriate `PUSHi` instruction will automatically be generated. The following creates code to add 2 and 3 resulting in 5 and then computes the bitwise and with the string “abc”. Strings are stored left-aligned and cannot be longer than 32 bytes.
assembly { 2 3 add "abc" and }
### Functional Style[¶](#functional-style "Permalink to this headline")
You can type opcode after opcode in the same way they will end up in bytecode. For example adding `3` to the contents in memory at position `0x80` would be
3 0x80 mload add 0x80 mstore
As it is often hard to see what the actual arguments for certain opcodes are, Solidity inline assembly also provides a “functional style” notation where the same code would be written as follows
mstore(0x80, add(mload(0x80), 3))
Functional style expressions cannot use instructional style internally, i.e. `1 2 mstore(0x80, add)` is not valid assembly, it has to be written as `mstore(0x80, add(2, 1))`. For opcodes that do not take arguments, the parentheses can be omitted.
Note that the order of arguments is reversed in functional-style as opposed to the instruction-style way. If you use functional-style, the first argument will end up on the stack top.
### Access to External Variables and Functions[¶](#access-to-external-variables-and-functions "Permalink to this headline")
Solidity variables and other identifiers can be accessed by simply using their name. For memory variables, this will push the address and not the value onto the stack. Storage variables are different: Values in storage might not occupy a full storage slot, so their “address” is composed of a slot and a byte-offset inside that slot. To retrieve the slot pointed to by the variable `x`, you used `x_slot` and to retrieve the byte-offset you used `x_offset`.
In assignments (see below), we can even use local Solidity variables to assign to.
Functions external to inline assembly can also be accessed: The assembly will push their entry label (with virtual function resolution applied). The calling semantics in solidity are:
> * the caller pushes `return label`, `arg1`, `arg2`, …, `argn`
> * the call returns with `ret1`, `ret2`, …, `retm`
This feature is still a bit cumbersome to use, because the stack offset essentially changes during the call, and thus references to local variables will be wrong.
pragma solidity ^0.4.11;
contract C {
 uint b;
 function f(uint x) public returns (uint r) {
 assembly {
 r := mul(x, sload(b\_slot)) // ignore the offset, we know it is zero
 }
 }
}
Note
If you access variables of a type that spans less than 256 bits (for example `uint64`, `address`, `bytes16` or `byte`), you cannot make any assumptions about bits not part of the encoding of the type. Especially, do not assume them to be zero. To be safe, always clear the data properly before you use it in a context where this is important: `uint32 x = f(); assembly { x := and(x, 0xffffffff) /* now use x */ }` To clean signed types, you can use the `signextend` opcode.
### Labels[¶](#labels "Permalink to this headline")
Note
Labels are deprecated. Please use functions, loops, if or switch statements instead.
Another problem in EVM assembly is that `jump` and `jumpi` use absolute addresses which can change easily. Solidity inline assembly provides labels to make the use of jumps easier. Note that labels are a low-level feature and it is possible to write efficient assembly without labels, just using assembly functions, loops, if and switch instructions (see below). The following code computes an element in the Fibonacci series.
{
 let n := calldataload(4)
 let a := 1
 let b := a
loop:
 jumpi(loopend, eq(n, 0))
 a add swap1
 n := sub(n, 1)
 jump(loop)
loopend:
 mstore(0, a)
 return(0, 0x20)
}
Please note that automatically accessing stack variables can only work if the assembler knows the current stack height. This fails to work if the jump source and target have different stack heights. It is still fine to use such jumps, but you should just not access any stack variables (even assembly variables) in that case.
Furthermore, the stack height analyser goes through the code opcode by opcode (and not according to control flow), so in the following case, the assembler will have a wrong impression about the stack height at label `two`:
{
 let x := 8
 jump(two)
 one:
 // Here the stack height is 2 (because we pushed x and 7),
 // but the assembler thinks it is 1 because it reads
 // from top to bottom.
 // Accessing the stack variable x here will lead to errors.
 x := 9
 jump(three)
 two:
 7 // push something onto the stack
 jump(one)
 three:
}
### Declaring Assembly-Local Variables[¶](#declaring-assembly-local-variables "Permalink to this headline")
You can use the `let` keyword to declare variables that are only visible in inline assembly and actually only in the current `{...}`\-block. What happens is that the `let` instruction will create a new stack slot that is reserved for the variable and automatically removed again when the end of the block is reached. You need to provide an initial value for the variable which can be just `0`, but it can also be a complex functional-style expression.
pragma solidity ^0.4.16;
contract C {
 function f(uint x) public view returns (uint b) {
 assembly {
 let v := add(x, 1)
 mstore(0x80, v)
 {
 let y := add(sload(v), 1)
 b := y
 } // y is "deallocated" here
 b := add(b, v)
 } // v is "deallocated" here
 }
}
### Assignments[¶](#assignments "Permalink to this headline")
Assignments are possible to assembly-local variables and to function-local variables. Take care that when you assign to variables that point to memory or storage, you will only change the pointer and not the data.
There are two kinds of assignments: functional-style and instruction-style. For functional-style assignments (`variable := value`), you need to provide a value in a functional-style expression that results in exactly one stack value and for instruction-style (`=: variable`), the value is just taken from the stack top. For both ways, the colon points to the name of the variable. The assignment is performed by replacing the variable’s value on the stack by the new value.
{
 let v := 0 // functional-style assignment as part of variable declaration
 let g := add(v, 2)
 sload(10)
 \=: v // instruction style assignment, puts the result of sload(10) into v
}
Note
Instruction-style assignment is deprecated.
### If[¶](#if "Permalink to this headline")
The if statement can be used for conditionally executing code. There is no “else” part, consider using “switch” (see below) if you need multiple alternatives.
{
 if eq(value, 0) { revert(0, 0) }
}
The curly braces for the body are required.
### Switch[¶](#switch "Permalink to this headline")
You can use a switch statement as a very basic version of “if/else”. It takes the value of an expression and compares it to several constants. The branch corresponding to the matching constant is taken. Contrary to the error-prone behaviour of some programming languages, control flow does not continue from one case to the next. There can be a fallback or default case called `default`.
{
 let x := 0
 switch calldataload(4)
 case 0 {
 x := calldataload(0x24)
 }
 default {
 x := calldataload(0x44)
 }
 sstore(0, div(x, 2))
}
The list of cases does not require curly braces, but the body of a case does require them.
### Loops[¶](#loops "Permalink to this headline")
Assembly supports a simple for-style loop. For-style loops have a header containing an initializing part, a condition and a post-iteration part. The condition has to be a functional-style expression, while the other two are blocks. If the initializing part declares any variables, the scope of these variables is extended into the body (including the condition and the post-iteration part).
The following example computes the sum of an area in memory.
{
 let x := 0
 for { let i := 0 } lt(i, 0x100) { i := add(i, 0x20) } {
 x := add(x, mload(i))
 }
}
For loops can also be written so that they behave like while loops: Simply leave the initialization and post-iteration parts empty.
{
 let x := 0
 let i := 0
 for { } lt(i, 0x100) { } { // while(i < 0x100)
 x := add(x, mload(i))
 i := add(i, 0x20)
 }
}
### Functions[¶](#functions "Permalink to this headline")
Assembly allows the definition of low-level functions. These take their arguments (and a return PC) from the stack and also put the results onto the stack. Calling a function looks the same way as executing a functional-style opcode.
Functions can be defined anywhere and are visible in the block they are declared in. Inside a function, you cannot access local variables defined outside of that function. There is no explicit `return` statement.
If you call a function that returns multiple values, you have to assign them to a tuple using `a, b := f(x)` or `let a, b := f(x)`.
The following example implements the power function by square-and-multiply.
{
 function power(base, exponent) \-> result {
 switch exponent
 case 0 { result := 1 }
 case 1 { result := base }
 default {
 result := power(mul(base, base), div(exponent, 2))
 switch mod(exponent, 2)
 case 1 { result := mul(base, result) }
 }
 }
}
### Things to Avoid[¶](#things-to-avoid "Permalink to this headline")
Inline assembly might have a quite high-level look, but it actually is extremely low-level. Function calls, loops, ifs and switches are converted by simple rewriting rules and after that, the only thing the assembler does for you is re-arranging functional-style opcodes, managing jump labels, counting stack height for variable access and removing stack slots for assembly-local variables when the end of their block is reached. Especially for those two last cases, it is important to know that the assembler only counts stack height from top to bottom, not necessarily following control flow. Furthermore, operations like swap will only swap the contents of the stack but not the location of variables.
### Conventions in Solidity[¶](#conventions-in-solidity "Permalink to this headline")
In contrast to EVM assembly, Solidity knows types which are narrower than 256 bits, e.g. `uint24`. In order to make them more efficient, most arithmetic operations just treat them as 256-bit numbers and the higher-order bits are only cleaned at the point where it is necessary, i.e. just shortly before they are written to memory or before comparisons are performed. This means that if you access such a variable from within inline assembly, you might have to manually clean the higher order bits first.
Solidity manages memory in a very simple way: There is a “free memory pointer” at position `0x40` in memory. If you want to allocate memory, just use the memory from that point on and update the pointer accordingly.
The first 64 bytes of memory can be used as “scratch space” for short-term allocation. The 32 bytes after the free memory pointer (i.e. starting at `0x60`) is meant to be zero permanently and is used as the initial value for empty dynamic memory arrays.
Elements in memory arrays in Solidity always occupy multiples of 32 bytes (yes, this is even true for `byte[]`, but not for `bytes` and `string`). Multi-dimensional memory arrays are pointers to memory arrays. The length of a dynamic array is stored at the first slot of the array and then only the array elements follow.
Warning
Statically-sized memory arrays do not have a length field, but it will be added soon to allow better convertibility between statically- and dynamically-sized arrays, so please do not rely on that.
## Standalone Assembly[¶](#standalone-assembly "Permalink to this headline")
The assembly language described as inline assembly above can also be used standalone and in fact, the plan is to use it as an intermediate language for the Solidity compiler. In this form, it tries to achieve several goals:
1. Programs written in it should be readable, even if the code is generated by a compiler from Solidity.
2. The translation from assembly to bytecode should contain as few “surprises” as possible.
3. Control flow should be easy to detect to help in formal verification and optimization.
In order to achieve the first and last goal, assembly provides high-level constructs like `for` loops, `if` and `switch` statements and function calls. It should be possible to write assembly programs that do not make use of explicit `SWAP`, `DUP`, `JUMP` and `JUMPI` statements, because the first two obfuscate the data flow and the last two obfuscate control flow. Furthermore, functional statements of the form `mul(add(x, y), 7)` are preferred over pure opcode statements like `7 y x add mul` because in the first form, it is much easier to see which operand is used for which opcode.
The second goal is achieved by compiling the higher level constructs to bytecode in a very regular way. The only non-local operation performed by the assembler is name lookup of user-defined identifiers (functions, variables, …), which follow very simple and regular scoping rules and cleanup of local variables from the stack.
Scoping: An identifier that is declared (label, variable, function, assembly) is only visible in the block where it was declared (including nested blocks inside the current block). It is not legal to access local variables across function borders, even if they would be in scope. Shadowing is not allowed. Local variables cannot be accessed before they were declared, but labels, functions and assemblies can. Assemblies are special blocks that are used for e.g. returning runtime code or creating contracts. No identifier from an outer assembly is visible in a sub-assembly.
If control flow passes over the end of a block, pop instructions are inserted that match the number of local variables declared in that block. Whenever a local variable is referenced, the code generator needs to know its current relative position in the stack and thus it needs to keep track of the current so-called stack height. Since all local variables are removed at the end of a block, the stack height before and after the block should be the same. If this is not the case, a warning is issued.
Using `switch`, `for` and functions, it should be possible to write complex code without using `jump` or `jumpi` manually. This makes it much easier to analyze the control flow, which allows for improved formal verification and optimization.
Furthermore, if manual jumps are allowed, computing the stack height is rather complicated. The position of all local variables on the stack needs to be known, otherwise neither references to local variables nor removing local variables automatically from the stack at the end of a block will work properly.
Example:
We will follow an example compilation from Solidity to assembly. We consider the runtime bytecode of the following Solidity program:
pragma solidity ^0.4.16;
contract C {
 function f(uint x) public pure returns (uint y) {
 y \= 1;
 for (uint i \= 0; i < x; i++)
 y \= 2 \* y;
 }
}
The following assembly will be generated:
{
 mstore(0x40, 0x60) // store the "free memory pointer"
 // function dispatcher
 switch div(calldataload(0), exp(2, 226))
 case 0xb3de648b {
 let r := f(calldataload(4))
 let ret := $allocate(0x20)
 mstore(ret, r)
 return(ret, 0x20)
 }
 default { revert(0, 0) }
 // memory allocator
 function $allocate(size) \-> pos {
 pos := mload(0x40)
 mstore(0x40, add(pos, size))
 }
 // the contract function
 function f(x) \-> y {
 y := 1
 for { let i := 0 } lt(i, x) { i := add(i, 1) } {
 y := mul(2, y)
 }
 }
}
### Assembly Grammar[¶](#assembly-grammar "Permalink to this headline")
The tasks of the parser are the following:
* Turn the byte stream into a token stream, discarding C++-style comments (a special comment exists for source references, but we will not explain it here).
* Turn the token stream into an AST according to the grammar below
* Register identifiers with the block they are defined in (annotation to the AST node) and note from which point on, variables can be accessed.
The assembly lexer follows the one defined by Solidity itself.
Whitespace is used to delimit tokens and it consists of the characters Space, Tab and Linefeed. Comments are regular JavaScript/C++ comments and are interpreted in the same way as Whitespace.
Grammar:
AssemblyBlock \= '{' AssemblyItem\* '}'
AssemblyItem \=
 Identifier |
 AssemblyBlock |
 AssemblyExpression |
 AssemblyLocalDefinition |
 AssemblyAssignment |
 AssemblyStackAssignment |
 LabelDefinition |
 AssemblyIf |
 AssemblySwitch |
 AssemblyFunctionDefinition |
 AssemblyFor |
 'break' |
 'continue' |
 SubAssembly
AssemblyExpression \= AssemblyCall | Identifier | AssemblyLiteral
AssemblyLiteral \= NumberLiteral | StringLiteral | HexLiteral
Identifier \= \[a\-zA\-Z\_$\] \[a\-zA\-Z\_0\-9\]\*
AssemblyCall \= Identifier '(' ( AssemblyExpression ( ',' AssemblyExpression )\* )? ')'
AssemblyLocalDefinition \= 'let' IdentifierOrList ( ':=' AssemblyExpression )?
AssemblyAssignment \= IdentifierOrList ':=' AssemblyExpression
IdentifierOrList \= Identifier | '(' IdentifierList ')'
IdentifierList \= Identifier ( ',' Identifier)\*
AssemblyStackAssignment \= '=:' Identifier
LabelDefinition \= Identifier ':'
AssemblyIf \= 'if' AssemblyExpression AssemblyBlock
AssemblySwitch \= 'switch' AssemblyExpression AssemblyCase\*
 ( 'default' AssemblyBlock )?
AssemblyCase \= 'case' AssemblyExpression AssemblyBlock
AssemblyFunctionDefinition \= 'function' Identifier '(' IdentifierList? ')'
 ( '->' '(' IdentifierList ')' )? AssemblyBlock
AssemblyFor \= 'for' ( AssemblyBlock | AssemblyExpression )
 AssemblyExpression ( AssemblyBlock | AssemblyExpression ) AssemblyBlock
SubAssembly \= 'assembly' Identifier AssemblyBlock
NumberLiteral \= HexNumber | DecimalNumber
HexLiteral \= 'hex' ('"' (\[0\-9a\-fA\-F\]{2})\* '"' | '\\'' (\[0\-9a\-fA\-F\]{2})\* '\\'')
StringLiteral \= '"' (\[^"\\r\\n\\\\\] | '\\\\' .)\* '"'
HexNumber = '0x' \[0\-9a\-fA\-F\]+
DecimalNumber \= \[0\-9\]+

# [Using the compiler — Solidity 0.4.26 documentation](https://docs.soliditylang.org/en/v0.4.26/using-the-compiler.html) 
 _https://docs.soliditylang.org/en/v0.4.26/using-the-compiler.html_

[Solidity](https://docs.soliditylang.org/en/v0.4.26/index.html)
## Using the Commandline Compiler[¶](#using-the-commandline-compiler "Permalink to this headline")
Note
This section doesn’t apply to [solcjs](https://docs.soliditylang.org/en/v0.4.26/installing-solidity.html#solcjs).
One of the build targets of the Solidity repository is `solc`, the solidity commandline compiler. Using `solc --help` provides you with an explanation of all options. The compiler can produce various outputs, ranging from simple binaries and assembly over an abstract syntax tree (parse tree) to estimations of gas usage. If you only want to compile a single file, you run it as `solc --bin sourceFile.sol` and it will print the binary. If you want to get some of the more advanced output variants of `solc`, it is probably better to tell it to output everything to separate files using `solc -o outputDirectory --bin --ast --asm sourceFile.sol`.
Before you deploy your contract, activate the optimizer while compiling using `solc --optimize --bin sourceFile.sol`. By default, the optimizer will optimize the contract for 200 runs. If you want to optimize for initial contract deployment and get the smallest output, set it to `--runs=1`. If you expect many transactions and don’t care for higher deployment cost and output size, set `--runs` to a high number.
The commandline compiler will automatically read imported files from the filesystem, but it is also possible to provide path redirects using `prefix=path` in the following way:
solc github.com/ethereum/dapp\-bin/=/usr/local/lib/dapp-bin/ =/usr/local/lib/fallback file.sol
This essentially instructs the compiler to search for anything starting with `github.com/ethereum/dapp-bin/` under `/usr/local/lib/dapp-bin` and if it does not find the file there, it will look at `/usr/local/lib/fallback` (the empty prefix always matches). `solc` will not read files from the filesystem that lie outside of the remapping targets and outside of the directories where explicitly specified source files reside, so things like `import "/etc/passwd";` only work if you add `=/` as a remapping.
If there are multiple matches due to remappings, the one with the longest common prefix is selected.
For security reasons the compiler has restrictions what directories it can access. Paths (and their subdirectories) of source files specified on the commandline and paths defined by remappings are allowed for import statements, but everything else is rejected. Additional paths (and their subdirectories) can be allowed via the `--allow-paths /sample/path,/another/sample/path` switch.
If your contracts use [libraries](https://docs.soliditylang.org/en/v0.4.26/contracts.html#libraries), you will notice that the bytecode contains substrings of the form `__LibraryName______`. You can use `solc` as a linker meaning that it will insert the library addresses for you at those points:
Either add `--libraries "Math:0x12345678901234567890 Heap:0xabcdef0123456"` to your command to provide an address for each library or store the string in a file (one library per line) and run `solc` using `--libraries fileName`.
If `solc` is called with the option `--link`, all input files are interpreted to be unlinked binaries (hex-encoded) in the `__LibraryName____`\-format given above and are linked in-place (if the input is read from stdin, it is written to stdout). All options except `--libraries` are ignored (including `-o`) in this case.
If `solc` is called with the option `--standard-json`, it will expect a JSON input (as explained below) on the standard input, and return a JSON output on the standard output.
## Compiler Input and Output JSON Description[¶](#compiler-input-and-output-json-description "Permalink to this headline")
These JSON formats are used by the compiler API as well as are available through `solc`. These are subject to change, some fields are optional (as noted), but it is aimed at to only make backwards compatible changes.
The compiler API expects a JSON formatted input and outputs the compilation result in a JSON formatted output.
Comments are of course not permitted and used here only for explanatory purposes.
### Input Description[¶](#input-description "Permalink to this headline")
{
 // Required: Source code language, such as "Solidity", "serpent", "lll", "assembly", etc.
 language: "Solidity",
 // Required
 sources:
 {
 // The keys here are the "global" names of the source files,
 // imports can use other files via remappings (see below).
 "myFile.sol":
 {
 // Optional: keccak256 hash of the source file
 // It is used to verify the retrieved content if imported via URLs.
 "keccak256": "0x123...",
 // Required (unless "content" is used, see below): URL(s) to the source file.
 // URL(s) should be imported in this order and the result checked against the
 // keccak256 hash (if available). If the hash doesn't match or none of the
 // URL(s) result in success, an error should be raised.
 "urls":
 \[
 "bzzr://56ab...",
 "ipfs://Qma...",
 "file:///tmp/path/to/file.sol"
 \]
 },
 "mortal":
 {
 // Optional: keccak256 hash of the source file
 "keccak256": "0x234...",
 // Required (unless "urls" is used): literal contents of the source file
 "content": "contract mortal is owned { function kill() { if (msg.sender == owner) selfdestruct(owner); } }"
 }
 },
 // Optional
 settings:
 {
 // Optional: Sorted list of remappings
 remappings: \[ ":g/dir" \],
 // Optional: Optimizer settings
 optimizer: {
 // disabled by default
 enabled: true,
 // Optimize for how many times you intend to run the code.
 // Lower values will optimize more for initial deployment cost, higher values will optimize more for high-frequency usage.
 runs: 200
 },
 evmVersion: "byzantium", // Version of the EVM to compile for. Affects type checking and code generation. Can be homestead, tangerineWhistle, spuriousDragon, byzantium or constantinople
 // Metadata settings (optional)
 metadata: {
 // Use only literal content and not URLs (false by default)
 useLiteralContent: true
 },
 // Addresses of the libraries. If not all libraries are given here, it can result in unlinked objects whose output data is different.
 libraries: {
 // The top level key is the the name of the source file where the library is used.
 // If remappings are used, this source file should match the global path after remappings were applied.
 // If this key is an empty string, that refers to a global level.
 "myFile.sol": {
 "MyLib": "0x123123..."
 }
 }
 // The following can be used to select desired outputs.
 // If this field is omitted, then the compiler loads and does type checking, but will not generate any outputs apart from errors.
 // The first level key is the file name and the second is the contract name, where empty contract name refers to the file itself,
 // while the star refers to all of the contracts.
 //
 // The available output types are as follows:
 // abi - ABI
 // ast - AST of all source files
 // legacyAST - legacy AST of all source files
 // devdoc - Developer documentation (natspec)
 // userdoc - User documentation (natspec)
 // metadata - Metadata
 // ir - New assembly format before desugaring
 // evm.assembly - New assembly format after desugaring
 // evm.legacyAssembly - Old-style assembly format in JSON
 // evm.bytecode.object - Bytecode object
 // evm.bytecode.opcodes - Opcodes list
 // evm.bytecode.sourceMap - Source mapping (useful for debugging)
 // evm.bytecode.linkReferences - Link references (if unlinked object)
 // evm.deployedBytecode\* - Deployed bytecode (has the same options as evm.bytecode)
 // evm.methodIdentifiers - The list of function hashes
 // evm.gasEstimates - Function gas estimates
 // ewasm.wast - eWASM S-expressions format (not supported atm)
 // ewasm.wasm - eWASM binary format (not supported atm)
 //
 // Note that using a using \`evm\`, \`evm.bytecode\`, \`ewasm\`, etc. will select every
 // target part of that output. Additionally, \`\*\` can be used as a wildcard to request everything.
 //
 outputSelection: {
 // Enable the metadata and bytecode outputs of every single contract.
 "\*": {
 "\*": \[ "metadata", "evm.bytecode" \]
 },
 // Enable the abi and opcodes output of MyContract defined in file def.
 "def": {
 "MyContract": \[ "abi", "evm.bytecode.opcodes" \]
 },
 // Enable the source map output of every single contract.
 "\*": {
 "\*": \[ "evm.bytecode.sourceMap" \]
 },
 // Enable the legacy AST output of every single file.
 "\*": {
 "": \[ "legacyAST" \]
 }
 }
 }
}
### Output Description[¶](#output-description "Permalink to this headline")
{
 // Optional: not present if no errors/warnings were encountered
 errors: \[
 {
 // Optional: Location within the source file.
 sourceLocation: {
 file: "sourceFile.sol",
 start: 0,
 end: 100
 \],
 // Mandatory: Error type, such as "TypeError", "InternalCompilerError", "Exception", etc.
 // See below for complete list of types.
 type: "TypeError",
 // Mandatory: Component where the error originated, such as "general", "ewasm", etc.
 component: "general",
 // Mandatory ("error" or "warning")
 severity: "error",
 // Mandatory
 message: "Invalid keyword"
 // Optional: the message formatted with source location
 formattedMessage: "sourceFile.sol:100: Invalid keyword"
 }
 \],
 // This contains the file-level outputs. In can be limited/filtered by the outputSelection settings.
 sources: {
 "sourceFile.sol": {
 // Identifier (used in source maps)
 id: 1,
 // The AST object
 ast: {},
 // The legacy AST object
 legacyAST: {}
 }
 },
 // This contains the contract-level outputs. It can be limited/filtered by the outputSelection settings.
 contracts: {
 "sourceFile.sol": {
 // If the language used has no contract names, this field should equal to an empty string.
 "ContractName": {
 // The Ethereum Contract ABI. If empty, it is represented as an empty array.
 // See https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI
 abi: \[\],
 // See the Metadata Output documentation (serialised JSON string)
 metadata: "{...}",
 // User documentation (natspec)
 userdoc: {},
 // Developer documentation (natspec)
 devdoc: {},
 // Intermediate representation (string)
 ir: "",
 // EVM-related outputs
 evm: {
 // Assembly (string)
 assembly: "",
 // Old-style assembly (object)
 legacyAssembly: {},
 // Bytecode and related details.
 bytecode: {
 // The bytecode as a hex string.
 object: "00fe",
 // Opcodes list (string)
 opcodes: "",
 // The source mapping as a string. See the source mapping definition.
 sourceMap: "",
 // If given, this is an unlinked object.
 linkReferences: {
 "libraryFile.sol": {
 // Byte offsets into the bytecode. Linking replaces the 20 bytes located there.
 "Library1": \[
 { start: 0, length: 20 },
 { start: 200, length: 20 }
 \]
 }
 }
 },
 // The same layout as above.
 deployedBytecode: { },
 // The list of function hashes
 methodIdentifiers: {
 "delegate(address)": "5c19a95c"
 },
 // Function gas estimates
 gasEstimates: {
 creation: {
 codeDepositCost: "420000",
 executionCost: "infinite",
 totalCost: "infinite"
 },
 external: {
 "delegate(address)": "25000"
 },
 internal: {
 "heavyLifting()": "infinite"
 }
 }
 },
 // eWASM related outputs
 ewasm: {
 // S-expressions format
 wast: "",
 // Binary format (hex string)
 wasm: ""
 }
 }
 }
 }
}
#### Error types[¶](#error-types "Permalink to this headline")
1. `JSONError`: JSON input doesn’t conform to the required format, e.g. input is not a JSON object, the language is not supported, etc.
2. `IOError`: IO and import processing errors, such as unresolvable URL or hash mismatch in supplied sources.
3. `ParserError`: Source code doesn’t conform to the language rules.
4. `DocstringParsingError`: The NatSpec tags in the comment block cannot be parsed.
5. `SyntaxError`: Syntactical error, such as `continue` is used outside of a `for` loop.
6. `DeclarationError`: Invalid, unresolvable or clashing identifier names. e.g. `Identifier not found`
7. `TypeError`: Error within the type system, such as invalid type conversions, invalid assignments, etc.
8. `UnimplementedFeatureError`: Feature is not supported by the compiler, but is expected to be supported in future versions.
9. `InternalCompilerError`: Internal bug triggered in the compiler - this should be reported as an issue.
10. `Exception`: Unknown failure during compilation - this should be reported as an issue.
11. `CompilerError`: Invalid use of the compiler stack - this should be reported as an issue.
12. `FatalError`: Fatal error not processed correctly - this should be reported as an issue.
13. `Warning`: A warning, which didn’t stop the compilation, but should be addressed if possible.

# [Crédits et attribution — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/credits-and-attribution.html) 
 _https://docs.soliditylang.org/fr/latest/credits-and-attribution.html_

## Icônes du site web[](#icones-du-site-web "Lien permanent vers cette rubrique")
 
Icône
Attribution
* Source: [share icon](https://fontawesome.com/v5.15/icons/share?style=solid) depuis Font Awesome 5.15.0.
 
* Licence: [Font Awesome Free License](https://fontawesome.com/license/free) (CC BY 4.0).

# [内存中的存储结构 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/internals/layout_in_memory.html) 
 _https://docs.soliditylang.org/zh-cn/latest/internals/layout_in_memory.html_

## 内存中的存储结构[](#id1 "此标题的永久链接")
Solidity保留了四个32字节的插槽，具体的字节范围（包括端点）使用如下：
* `0x00` - `0x3f` （64字节）： 用于哈希方法的临时空间
 
* `0x40` - `0x5f` （32字节）： 当前分配的内存大小（又称空闲内存指针）。
 
* `0x60` - `0x7f` （32字节）： 0 值插槽
 
临时空间可以在语句之间使用（即在内联汇编之中）。 0 值插槽则用来对动态内存数组进行初始化，且永远不会写入数据 （因而可用的初始内存指针为 `0x80`）。
Solidity 总会把新对象保存在空闲内存指针的位置， 所以这段内存实际上从来不会空闲（在未来可能会修改这个机制）。
Solidity中内存数组中的元素总是占据32字节的倍数 （对于 `bytes1[]` 来说也是如此，但对于 `bytes` 和 `string` 来说不是这样）。 多维内存数组是指向内存数组的指针. 一个动态数组的长度被存储在数组的第一个槽里，后面是数组元素。
警告
在Solidity中，有一些操作需要一个大于64字节的临时内存区域， 因此将不适合放在默认的临时空间中。它们将被放置在空闲内存指向的位置， 但由于这种数据的生命周期较短，这个指针不会即时更新。 这部分内存可能会被清零也可能不会。 所以我们不应该期望这些所谓的空闲内存总会被清零。
虽然使用 `msize` 来到达一个绝对清零的内存区域似乎是个好主意， 但在不更新空闲内存指针的情况下，非临时性地使用这样的指针会产生意想不到的结果。
## 与存储结构的区别[](#id2 "此标题的永久链接")
如上所述，内存中的存储结构与 [存储（storage）](https://docs.soliditylang.org/zh-cn/latest/internals/layout_in_storage.html#storage-inplace-encoding) 中的存储结构是不同的。 下面是一些例子。
### 在数组中的差异的例子[](#id3 "此标题的永久链接")
下面的数组在存储中占用32字节（1个槽），但在内存中占用128字节（4项，每个32字节）。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=dWludDhbNF0gYTs=)
### 在结构体中存储结构差异的例子[](#id4 "此标题的永久链接")
以下结构体在存储中占用96字节（3个32字节的槽）， 但在内存中占用128字节（4项，每个32字节）。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=c3RydWN0IFMgewogICAgdWludCBhOwogICAgdWludCBiOwogICAgdWludDggYzsKICAgIHVpbnQ4IGQ7Cn0=)
struct S {
 uint a;
 uint b;
 uint8 c;
 uint8 d;
}

# [Mise en page en mémoire — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/internals/layout_in_memory.html) 
 _https://docs.soliditylang.org/fr/latest/internals/layout_in_memory.html_

Solidity réserve quatre emplacements de 32 octets, avec des plages d’octets spécifiques (y compris les points de terminaison) utilisées comme suit :
* `0x00` - `0x3f` (64 octets) : espace de grattage pour les méthodes de hachage
 
* `0x40` - `0x5f` (32 octets) : taille de la mémoire actuellement allouée (alias pointeur de mémoire libre)
 
* `0x60` - `0x7f` (32 octets) : emplacement zéro
 
L’espace d’effacement peut être utilisé entre les instructions (c’est-à-dire dans l’assemblage en ligne). L’emplacement zéro est utilisé comme valeur initiale pour les tableaux de mémoire dynamique et ne devrait jamais être écrit dans (le pointeur de mémoire libre pointe initialement sur `0x80`).
Solidity place toujours les nouveaux objets sur le pointeur de mémoire libre et la mémoire n’est jamais libérée (cela pourrait changer à l’avenir).
Les éléments des tableaux de mémoire dans Solidity occupent toujours des multiples de 32 octets (ceci est est même vrai pour `bytes1[]`, mais pas pour `bytes` et `string`). Les tableaux de mémoire multidimensionnels sont des pointeurs vers des tableaux de mémoire. La longueur d’un tableau dynamique est stockée dans le premier emplacement du tableau, suivie des éléments du tableau.
Avertissement
Il y a certaines opérations dans Solidity qui nécessitent une zone de mémoire temporaire plus grande que 64 octets et qui ne peuvent donc pas être placées dans l’espace scratch. Elles seront placées là où la mémoire libre pointe, mais étant donné leur courte durée de vie, le pointeur n’est pas mis à jour. La mémoire peut être mise à zéro. Pour cette raison, il ne faut pas s’attendre à ce que la mémoire libre pointe vers une mémoire mise à zéro.
Bien que cela puisse sembler être une bonne idée d’utiliser `msize` pour arriver à une zone de mémoire définitivement mise à zéro, l’utilisation d’un tel pointeur de façon non-temporelle sans mettre à jour le pointeur de mémoire libre peut avoir des résultats inattendus.
## Différences par rapport à l’agencement du stockage[](#differences-par-rapport-a-l-agencement-du-stockage "Lien permanent vers cette rubrique")
Comme décrit ci-dessus, la disposition en mémoire est différente de la disposition en [storage](https://docs.soliditylang.org/fr/latest/internals/layout_in_storage.html#storage-inplace-encoding). Vous trouverez ci-dessous quelques exemples.
### Exemple de différence dans les tableaux[](#exemple-de-difference-dans-les-tableaux "Lien permanent vers cette rubrique")
Le tableau suivant occupe 32 octets (1 emplacement) en stockage, mais 128 octets (4 éléments de 32 octets chacun) en mémoire.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=dWludDhbNF0gYTs=)
### Exemple d’écart de structure[](#exemple-d-ecart-de-structure "Lien permanent vers cette rubrique")
La structure suivante occupe 96 octets (3 emplacements de 32 octets) en stockage, mais 128 octets (4 éléments de 32 octets chacun) en mémoire.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=c3RydWN0IFMgewogICAgdWludCBhOwogICAgdWludCBiOwogICAgdWludDggYzsKICAgIHVpbnQ4IGQ7Cn0=)
struct S {
 uint a;
 uint b;
 uint8 c;
 uint8 d;
}

# [Inline Assembly — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/assembly.html) 
 _https://docs.soliditylang.org/en/v0.8.30/assembly.html_

You can interleave Solidity statements with inline assembly in a language close to the one of the Ethereum Virtual Machine. This gives you more fine-grained control, which is especially useful when you are enhancing the language by writing libraries or optimizing gas usage.
The language used for inline assembly in Solidity is called [Yul](https://docs.soliditylang.org/en/v0.8.30/yul.html#yul) and it is documented in its own section. This section will only cover how the inline assembly code can interface with the surrounding Solidity code.
Warning
Inline assembly is a way to access the Ethereum Virtual Machine at a low level. This bypasses several important safety features and checks of Solidity. You should only use it for tasks that need it, and only if you are confident with using it.
An inline assembly block is marked by `assembly { ... }`, where the code inside the curly braces is code in the [Yul](https://docs.soliditylang.org/en/v0.8.30/yul.html#yul) language.
The inline assembly code can access local Solidity variables as explained below.
Different inline assembly blocks share no namespace, i.e. it is not possible to call a Yul function or access a Yul variable defined in a different inline assembly block.
## Example[](#example "Link to this heading")
The following example provides library code to access the code of another contract and load it into a `bytes` variable. This is possible with “plain Solidity” too, by using `<address>.code`. But the point here is that reusable assembly libraries can enhance the Solidity language without a compiler change.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmxpYnJhcnkgR2V0Q29kZSB7CiAgICBmdW5jdGlvbiBhdChhZGRyZXNzIGFkZHIpIHB1YmxpYyB2aWV3IHJldHVybnMgKGJ5dGVzIG1lbW9yeSBjb2RlKSB7CiAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICAvLyByZXRyaWV2ZSB0aGUgc2l6ZSBvZiB0aGUgY29kZSwgdGhpcyBuZWVkcyBhc3NlbWJseQogICAgICAgICAgICBsZXQgc2l6ZSA6PSBleHRjb2Rlc2l6ZShhZGRyKQogICAgICAgICAgICAvLyBhbGxvY2F0ZSBvdXRwdXQgYnl0ZSBhcnJheSAtIHRoaXMgY291bGQgYWxzbyBiZSBkb25lIHdpdGhvdXQgYXNzZW1ibHkKICAgICAgICAgICAgLy8gYnkgdXNpbmcgY29kZSA9IG5ldyBieXRlcyhzaXplKQogICAgICAgICAgICBjb2RlIDo9IG1sb2FkKDB4NDApCiAgICAgICAgICAgIC8vIG5ldyAibWVtb3J5IGVuZCIgaW5jbHVkaW5nIHBhZGRpbmcKICAgICAgICAgICAgbXN0b3JlKDB4NDAsIGFkZChjb2RlLCBhbmQoYWRkKGFkZChzaXplLCAweDIwKSwgMHgxZiksIG5vdCgweDFmKSkpKQogICAgICAgICAgICAvLyBzdG9yZSBsZW5ndGggaW4gbWVtb3J5CiAgICAgICAgICAgIG1zdG9yZShjb2RlLCBzaXplKQogICAgICAgICAgICAvLyBhY3R1YWxseSByZXRyaWV2ZSB0aGUgY29kZSwgdGhpcyBuZWVkcyBhc3NlbWJseQogICAgICAgICAgICBleHRjb2RlY29weShhZGRyLCBhZGQoY29kZSwgMHgyMCksIDAsIHNpemUpCiAgICAgICAgfQogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
library GetCode {
 function at(address addr) public view returns (bytes memory code) {
 assembly {
 // retrieve the size of the code, this needs assembly
 let size := extcodesize(addr)
 // allocate output byte array - this could also be done without assembly
 // by using code = new bytes(size)
 code := mload(0x40)
 // new "memory end" including padding
 mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f))))
 // store length in memory
 mstore(code, size)
 // actually retrieve the code, this needs assembly
 extcodecopy(addr, add(code, 0x20), 0, size)
 }
 }
}
Inline assembly is also beneficial in cases where the optimizer fails to produce efficient code, for example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCgpsaWJyYXJ5IFZlY3RvclN1bSB7CiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGxlc3MgZWZmaWNpZW50IGJlY2F1c2UgdGhlIG9wdGltaXplciBjdXJyZW50bHkgZmFpbHMgdG8KICAgIC8vIHJlbW92ZSB0aGUgYm91bmRzIGNoZWNrcyBpbiBhcnJheSBhY2Nlc3MuCiAgICBmdW5jdGlvbiBzdW1Tb2xpZGl0eSh1aW50W10gbWVtb3J5IGRhdGEpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQgc3VtKSB7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkKICAgICAgICAgICAgc3VtICs9IGRhdGFbaV07CiAgICB9CgogICAgLy8gV2Uga25vdyB0aGF0IHdlIG9ubHkgYWNjZXNzIHRoZSBhcnJheSBpbiBib3VuZHMsIHNvIHdlIGNhbiBhdm9pZCB0aGUgY2hlY2suCiAgICAvLyAweDIwIG5lZWRzIHRvIGJlIGFkZGVkIHRvIGFuIGFycmF5IGJlY2F1c2UgdGhlIGZpcnN0IHNsb3QgY29udGFpbnMgdGhlCiAgICAvLyBhcnJheSBsZW5ndGguCiAgICBmdW5jdGlvbiBzdW1Bc20odWludFtdIG1lbW9yeSBkYXRhKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IHN1bSkgewogICAgICAgIGZvciAodWludCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHsKICAgICAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICAgICAgc3VtIDo9IGFkZChzdW0sIG1sb2FkKGFkZChhZGQoZGF0YSwgMHgyMCksIG11bChpLCAweDIwKSkpKQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQoKICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2NvbXBsaXNoIHRoZSBlbnRpcmUgY29kZSB3aXRoaW4gaW5saW5lIGFzc2VtYmx5LgogICAgZnVuY3Rpb24gc3VtUHVyZUFzbSh1aW50W10gbWVtb3J5IGRhdGEpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQgc3VtKSB7CiAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICAvLyBMb2FkIHRoZSBsZW5ndGggKGZpcnN0IDMyIGJ5dGVzKQogICAgICAgICAgICBsZXQgbGVuIDo9IG1sb2FkKGRhdGEpCgogICAgICAgICAgICAvLyBTa2lwIG92ZXIgdGhlIGxlbmd0aCBmaWVsZC4KICAgICAgICAgICAgLy8KICAgICAgICAgICAgLy8gS2VlcCB0ZW1wb3JhcnkgdmFyaWFibGUgc28gaXQgY2FuIGJlIGluY3JlbWVudGVkIGluIHBsYWNlLgogICAgICAgICAgICAvLwogICAgICAgICAgICAvLyBOT1RFOiBpbmNyZW1lbnRpbmcgZGF0YSB3b3VsZCByZXN1bHQgaW4gYW4gdW51c2FibGUKICAgICAgICAgICAgLy8gICAgICAgZGF0YSB2YXJpYWJsZSBhZnRlciB0aGlzIGFzc2VtYmx5IGJsb2NrCiAgICAgICAgICAgIGxldCBkYXRhRWxlbWVudExvY2F0aW9uIDo9IGFkZChkYXRhLCAweDIwKQoKICAgICAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCB0aGUgYm91bmQgaXMgbm90IG1ldC4KICAgICAgICAgICAgZm9yCiAgICAgICAgICAgICAgICB7IGxldCBlbmQgOj0gYWRkKGRhdGFFbGVtZW50TG9jYXRpb24sIG11bChsZW4sIDB4MjApKSB9CiAgICAgICAgICAgICAgICBsdChkYXRhRWxlbWVudExvY2F0aW9uLCBlbmQpCiAgICAgICAgICAgICAgICB7IGRhdGFFbGVtZW50TG9jYXRpb24gOj0gYWRkKGRhdGFFbGVtZW50TG9jYXRpb24sIDB4MjApIH0KICAgICAgICAgICAgewogICAgICAgICAgICAgICAgc3VtIDo9IGFkZChzdW0sIG1sb2FkKGRhdGFFbGVtZW50TG9jYXRpb24pKQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
library VectorSum {
 // This function is less efficient because the optimizer currently fails to
 // remove the bounds checks in array access.
 function sumSolidity(uint\[\] memory data) public pure returns (uint sum) {
 for (uint i \= 0; i < data.length; ++i)
 sum += data\[i\];
 }
 // We know that we only access the array in bounds, so we can avoid the check.
 // 0x20 needs to be added to an array because the first slot contains the
 // array length.
 function sumAsm(uint\[\] memory data) public pure returns (uint sum) {
 for (uint i \= 0; i < data.length; ++i) {
 assembly {
 sum := add(sum, mload(add(add(data, 0x20), mul(i, 0x20))))
 }
 }
 }
 // Same as above, but accomplish the entire code within inline assembly.
 function sumPureAsm(uint\[\] memory data) public pure returns (uint sum) {
 assembly {
 // Load the length (first 32 bytes)
 let len := mload(data)
 // Skip over the length field.
 //
 // Keep temporary variable so it can be incremented in place.
 //
 // NOTE: incrementing data would result in an unusable
 // data variable after this assembly block
 let dataElementLocation := add(data, 0x20)
 // Iterate until the bound is not met.
 for
 { let end := add(dataElementLocation, mul(len, 0x20)) }
 lt(dataElementLocation, end)
 { dataElementLocation := add(dataElementLocation, 0x20) }
 {
 sum := add(sum, mload(dataElementLocation))
 }
 }
 }
}
## Access to External Variables, Functions and Libraries[](#access-to-external-variables-functions-and-libraries "Link to this heading")
You can access Solidity variables and other identifiers by using their name.
Local variables of value type are directly usable in inline assembly. They can both be read and assigned to.
Local variables that refer to memory evaluate to the address of the variable in memory, not the value itself. Such variables can also be assigned to, but note that an assignment will only change the pointer and not the data and that it is your responsibility to respect Solidity’s memory management. See [Conventions in Solidity](#conventions-in-solidity).
Similarly, local variables that refer to statically-sized calldata arrays or calldata structs evaluate to the address of the variable in calldata, not the value itself. The variable can also be assigned a new offset, but note that no validation is performed to ensure that the variable will not point beyond `calldatasize()`.
For external function pointers the address and the function selector can be accessed using `x.address` and `x.selector`. The selector consists of four right-aligned bytes. Both values can be assigned to. For example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjEwIDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgLy8gQXNzaWducyBhIG5ldyBzZWxlY3RvciBhbmQgYWRkcmVzcyB0byB0aGUgcmV0dXJuIHZhcmlhYmxlIEBmdW4KICAgIGZ1bmN0aW9uIGNvbWJpbmVUb0Z1bmN0aW9uUG9pbnRlcihhZGRyZXNzIG5ld0FkZHJlc3MsIHVpbnQgbmV3U2VsZWN0b3IpIHB1YmxpYyBwdXJlIHJldHVybnMgKGZ1bmN0aW9uKCkgZXh0ZXJuYWwgZnVuKSB7CiAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICBmdW4uc2VsZWN0b3IgOj0gbmV3U2VsZWN0b3IKICAgICAgICAgICAgZnVuLmFkZHJlc3MgIDo9IG5ld0FkZHJlc3MKICAgICAgICB9CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.10 <0.9.0;
contract C {
 // Assigns a new selector and address to the return variable @fun
 function combineToFunctionPointer(address newAddress, uint newSelector) public pure returns (function() external fun) {
 assembly {
 fun.selector := newSelector
 fun.address := newAddress
 }
 }
}
For dynamic calldata arrays, you can access their calldata offset (in bytes) and length (number of elements) using `x.offset` and `x.length`. Both expressions can also be assigned to, but as for the static case, no validation will be performed to ensure that the resulting data area is within the bounds of `calldatasize()`.
For local storage variables or state variables (including transient storage) a single Yul identifier is not sufficient, since they do not necessarily occupy a single full storage slot. Therefore, their “address” is composed of a slot and a byte-offset inside that slot. To retrieve the slot pointed to by the variable `x`, you use `x.slot`, and to retrieve the byte-offset you use `x.offset`. Using `x` itself will result in an error.
You can also assign to the `.slot` part of a local storage variable pointer. For these (structs, arrays or mappings), the `.offset` part is always zero. It is not possible to assign to the `.slot` or `.offset` part of a state variable, though.
Local Solidity variables are available for assignments, for example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjI4IDwwLjkuMDsKCi8vIFRoaXMgd2lsbCByZXBvcnQgYSB3YXJuaW5nCmNvbnRyYWN0IEMgewogICAgYm9vbCB0cmFuc2llbnQgYTsKICAgIHVpbnQgYjsKICAgIGZ1bmN0aW9uIGYodWludCB4KSBwdWJsaWMgcmV0dXJucyAodWludCByKSB7CiAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICAvLyBXZSBpZ25vcmUgdGhlIHN0b3JhZ2Ugc2xvdCBvZmZzZXQsIHdlIGtub3cgaXQgaXMgemVybwogICAgICAgICAgICAvLyBpbiB0aGlzIHNwZWNpYWwgY2FzZS4KICAgICAgICAgICAgciA6PSBtdWwoeCwgc2xvYWQoYi5zbG90KSkKICAgICAgICAgICAgdHN0b3JlKGEuc2xvdCwgdHJ1ZSkKICAgICAgICB9CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.28 <0.9.0;
// This will report a warning
contract C {
 bool transient a;
 uint b;
 function f(uint x) public returns (uint r) {
 assembly {
 // We ignore the storage slot offset, we know it is zero
 // in this special case.
 r := mul(x, sload(b.slot))
 tstore(a.slot, true)
 }
 }
}
Warning
If you access variables of a type that spans less than 256 bits (for example `uint64`, `address`, or `bytes16`), you cannot make any assumptions about bits not part of the encoding of the type. Especially, do not assume them to be zero. To be safe, always clear the data properly before you use it in a context where this is important: `uint32 x = f(); assembly { x := and(x, 0xffffffff) /* now use x */ }` To clean signed types, you can use the `signextend` opcode: `assembly { signextend(<num_bytes_of_x_minus_one>, x) }`
Since Solidity 0.6.0, the name of an inline assembly variable may not shadow any declaration visible in the scope of the inline assembly block (including variable, contract and function declarations).
Since Solidity 0.7.0, variables and functions declared inside the inline assembly block may not contain `.`, but using `.` is valid to access Solidity variables from outside the inline assembly block.
## Things to Avoid[](#things-to-avoid "Link to this heading")
Inline assembly might have a quite high-level look, but it actually is extremely low-level. Function calls, loops, ifs and switches are converted by simple rewriting rules and after that, the only thing the assembler does for you is re-arranging functional-style opcodes, counting stack height for variable access and removing stack slots for assembly-local variables when the end of their block is reached.
## Conventions in Solidity[](#conventions-in-solidity "Link to this heading")
### Values of Typed Variables[](#values-of-typed-variables "Link to this heading")
In contrast to EVM assembly, Solidity has types which are narrower than 256 bits, e.g. `uint24`. For efficiency, most arithmetic operations ignore the fact that types can be shorter than 256 bits, and the higher-order bits are cleaned when necessary, i.e., shortly before they are written to memory or before comparisons are performed. This means that if you access such a variable from within inline assembly, you might have to manually clean the higher-order bits first.
### Memory Management[](#memory-management "Link to this heading")
Solidity manages memory in the following way. There is a “free memory pointer” at position `0x40` in memory. If you want to allocate memory, use the memory starting from where this pointer points at and update it. There is no guarantee that the memory has not been used before and thus you cannot assume that its contents are zero bytes. There is no built-in mechanism to release or free allocated memory. Solidity does not guarantee and does not require that the values in memory are placed at positions aligned to a multiple of any value. Here is an assembly snippet you can use for allocating memory that follows the process outlined above:
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ZnVuY3Rpb24gYWxsb2NhdGUobGVuZ3RoKSAtPiBwb3MgewogIHBvcyA6PSBtbG9hZCgweDQwKQogIG1zdG9yZSgweDQwLCBhZGQocG9zLCBsZW5ndGgpKQp9)
function allocate(length) \-> pos {
 pos := mload(0x40)
 mstore(0x40, add(pos, length))
}
The first 64 bytes of memory can be used as “scratch space” for short-term allocation. The 32 bytes after the free memory pointer (i.e., starting at `0x60`) are meant to be zero permanently and is used as the initial value for empty dynamic memory arrays. This means that the allocatable memory starts at `0x80`, which is the initial value of the free memory pointer.
Elements in memory arrays in Solidity always occupy multiples of 32 bytes (this is even true for `bytes1[]`, but not for `bytes` and `string`). Multi-dimensional memory arrays are pointers to memory arrays. The length of a dynamic array is stored at the first slot of the array and followed by the array elements.
Warning
Statically-sized memory arrays do not have a length field, but it might be added later to allow better convertibility between statically and dynamically-sized arrays; so, do not rely on this.
### Memory Safety[](#memory-safety "Link to this heading")
Without the use of inline assembly, the compiler can rely on memory to remain in a well-defined state at all times. This is especially relevant for [the new code generation pipeline via Yul IR](https://docs.soliditylang.org/en/v0.8.30/ir-breaking-changes.html#ir-breaking-changes): this code generation path can move local variables from stack to memory to avoid stack-too-deep errors and perform additional memory optimizations, if it can rely on certain assumptions about memory use.
While we recommend to always respect Solidity’s memory model, inline assembly allows you to use memory in an incompatible way. Therefore, moving stack variables to memory and additional memory optimizations are, by default, globally disabled in the presence of any inline assembly block that contains a memory operation or assigns to Solidity variables in memory.
However, you can specifically annotate an assembly block to indicate that it in fact respects Solidity’s memory model as follows:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=YXNzZW1ibHkgKCJtZW1vcnktc2FmZSIpIHsKICAgIC4uLgp9)
assembly ("memory-safe") {
 ...
}
In particular, a memory-safe assembly block may only access the following memory ranges:
* Memory allocated by yourself using a mechanism like the `allocate` function described above.
 
* Memory allocated by Solidity, e.g. memory within the bounds of a memory array you reference.
 
* The scratch space between memory offset 0 and 64 mentioned above.
 
* Temporary memory that is located _after_ the value of the free memory pointer at the beginning of the assembly block, i.e. memory that is “allocated” at the free memory pointer without updating the free memory pointer.
 
Furthermore, if the assembly block assigns to Solidity variables in memory, you need to assure that accesses to the Solidity variables only access these memory ranges.
Since this is mainly about the optimizer, these restrictions still need to be followed, even if the assembly block reverts or terminates. As an example, the following assembly snippet is not memory safe, because the value of `returndatasize()` may exceed the 64 byte scratch space:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=YXNzZW1ibHkgewogIHJldHVybmRhdGFjb3B5KDAsIDAsIHJldHVybmRhdGFzaXplKCkpCiAgcmV2ZXJ0KDAsIHJldHVybmRhdGFzaXplKCkpCn0=)
assembly {
 returndatacopy(0, 0, returndatasize())
 revert(0, returndatasize())
}
On the other hand, the following code _is_ memory safe, because memory beyond the location pointed to by the free memory pointer can safely be used as temporary scratch space:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=YXNzZW1ibHkgKCJtZW1vcnktc2FmZSIpIHsKICBsZXQgcCA6PSBtbG9hZCgweDQwKQogIHJldHVybmRhdGFjb3B5KHAsIDAsIHJldHVybmRhdGFzaXplKCkpCiAgcmV2ZXJ0KHAsIHJldHVybmRhdGFzaXplKCkpCn0=)
assembly ("memory-safe") {
 let p := mload(0x40)
 returndatacopy(p, 0, returndatasize())
 revert(p, returndatasize())
}
Note that you do not need to update the free memory pointer if there is no following allocation, but you can only use memory starting from the current offset given by the free memory pointer.
If the memory operations use a length of zero, it is also fine to just use any offset (not only if it falls into the scratch space):
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=YXNzZW1ibHkgKCJtZW1vcnktc2FmZSIpIHsKICByZXZlcnQoMCwgMCkKfQ==)
assembly ("memory-safe") {
 revert(0, 0)
}
Note that not only memory operations in inline assembly itself can be memory-unsafe, but also assignments to Solidity variables of reference type in memory. For example the following is not memory-safe:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ynl0ZXMgbWVtb3J5IHg7CmFzc2VtYmx5IHsKICB4IDo9IDB4NDAKfQp4WzB4MjBdID0gMHg0Mjs=)
bytes memory x;
assembly {
 x := 0x40
}
x\[0x20\] \= 0x42;
Inline assembly that neither involves any operations that access memory nor assigns to any Solidity variables in memory is automatically considered memory-safe and does not need to be annotated.
Warning
It is your responsibility to make sure that the assembly actually satisfies the memory model. If you annotate an assembly block as memory-safe, but violate one of the memory assumptions, this **will** lead to incorrect and undefined behavior that cannot easily be discovered by testing.
In case you are developing a library that is meant to be compatible across multiple versions of Solidity, you can use a special comment to annotate an assembly block as memory-safe:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8vIEBzb2xpZGl0eSBtZW1vcnktc2FmZS1hc3NlbWJseQphc3NlbWJseSB7CiAgICAuLi4KfQ==)
/// @solidity memory-safe-assembly
assembly {
 ...
}
Note that we will disallow the annotation via comment in a future breaking release; so, if you are not concerned with backward-compatibility with older compiler versions, prefer using the dialect string.
## Advanced Safe Use of Memory[](#advanced-safe-use-of-memory "Link to this heading")
Beyond the strict definition of memory-safety given above, there are cases in which you may want to use more than 64 bytes of scratch space starting at memory offset `0`. If you are careful, it can be admissible to use memory up to (and not including) offset `0x80` and still safely declare the assembly block as `memory-safe`. This is admissible under either of the following conditions:
* By the end of the assembly block, the free memory pointer at offset `0x40` is restored to a sane value (i.e. it is either restored to its original value or an increment of it due to a manual memory allocation), and the memory word at offset `0x60` is restored to a value of zero.
 
* The assembly block terminates, i.e. execution can never return to high-level Solidity code. This is the case, for example, if your assembly block unconditionally ends in calling the `revert` opcode.
 
Furthermore, you need to be aware that the default-value of dynamic arrays in Solidity point to memory offset `0x60`, so for the duration of temporarily changing the value at memory offset `0x60`, you can no longer rely on getting accurate length values when reading dynamic arrays, until you restore the zero value at `0x60`. To be more precise, we only guarantee safety when overwriting the zero pointer, if the remainder of the assembly snippet does not interact with the memory of high-level Solidity objects (including by reading from offsets previously stored in variables).

# [Cheatsheet — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html) 
 _https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html_

## Order of Precedence of Operators[](#order-of-precedence-of-operators "Link to this heading")
The following is the order of precedence for operators, listed in order of evaluation.
Precedence
Description
Operator
_1_
Postfix increment and decrement
`++`, `--`
New expression
`new <typename>`
Array subscripting
`<array>[<index>]`
Member access
`<object>.<member>`
Function-like call
`<func>(<args...>)`
Parentheses
`(<statement>)`
_2_
Prefix increment and decrement
`++`, `--`
Unary minus
`-`
Unary operations
`delete`
Logical NOT
`!`
Bitwise NOT
`~`
_3_
Exponentiation
`**`
_4_
Multiplication, division and modulo
`*`, `/`, `%`
_5_
Addition and subtraction
`+`, `-`
_6_
Bitwise shift operators
`<<`, `>>`
_7_
Bitwise AND
`&`
_8_
Bitwise XOR
`^`
_9_
Bitwise OR
`|`
_10_
Inequality operators
`<`, `>`, `<=`, `>=`
_11_
Equality operators
`==`, `!=`
_12_
Logical AND
`&&`
_13_
Logical OR
`||`
_14_
Ternary operator
`<conditional> ? <if-true> : <if-false>`
Assignment operators
`=`, `|=`, `^=`, `&=`, `<<=`, `>>=`, `+=`, `-=`, `*=`, `/=`, `%=`
_15_
Comma operator
`,`
## ABI Encoding and Decoding Functions[](#abi-encoding-and-decoding-functions "Link to this heading")
* `abi.decode(bytes memory encodedData, (...)) returns (...)`: [ABI](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#abi)\-decodes the provided data. The types are given in parentheses as second argument. Example: `(uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))`
 
* `abi.encode(...) returns (bytes memory)`: [ABI](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#abi)\-encodes the given arguments
 
* `abi.encodePacked(...) returns (bytes memory)`: Performs [packed encoding](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#abi-packed-mode) of the given arguments. Note that this encoding can be ambiguous!
 
* `abi.encodeWithSelector(bytes4 selector, ...) returns (bytes memory)`: [ABI](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#abi)\-encodes the given arguments starting from the second and prepends the given four-byte selector
 
* `abi.encodeCall(function functionPointer, (...)) returns (bytes memory)`: ABI-encodes a call to `functionPointer` with the arguments found in the tuple. Performs a full type-check, ensuring the types match the function signature. Result equals `abi.encodeWithSelector(functionPointer.selector, ...)`
 
* `abi.encodeWithSignature(string memory signature, ...) returns (bytes memory)`: Equivalent to `abi.encodeWithSelector(bytes4(keccak256(bytes(signature))), ...)`
 
## Members of `bytes` and `string`[](#members-of-bytes-and-string "Link to this heading")
* `bytes.concat(...) returns (bytes memory)`: [Concatenates variable number of arguments to one byte array](https://docs.soliditylang.org/en/v0.8.30/types.html#bytes-concat)
 
* `string.concat(...) returns (string memory)`: [Concatenates variable number of arguments to one string array](https://docs.soliditylang.org/en/v0.8.30/types.html#string-concat)
 
## Members of `address`[](#members-of-address "Link to this heading")
* `<address>.balance` (`uint256`): balance of the [Address](https://docs.soliditylang.org/en/v0.8.30/types.html#address) in Wei
 
* `<address>.code` (`bytes memory`): code at the [Address](https://docs.soliditylang.org/en/v0.8.30/types.html#address) (can be empty)
 
* `<address>.codehash` (`bytes32`): the codehash of the [Address](https://docs.soliditylang.org/en/v0.8.30/types.html#address)
 
* `<address>.call(bytes memory) returns (bool, bytes memory)`: issue low-level `CALL` with the given payload, returns success condition and return data
 
* `<address>.delegatecall(bytes memory) returns (bool, bytes memory)`: issue low-level `DELEGATECALL` with the given payload, returns success condition and return data
 
* `<address>.staticcall(bytes memory) returns (bool, bytes memory)`: issue low-level `STATICCALL` with the given payload, returns success condition and return data
 
* `<address payable>.send(uint256 amount) returns (bool)`: send given amount of Wei to [Address](https://docs.soliditylang.org/en/v0.8.30/types.html#address), returns `false` on failure
 
* `<address payable>.transfer(uint256 amount)`: send given amount of Wei to [Address](https://docs.soliditylang.org/en/v0.8.30/types.html#address), throws on failure
 
## Block and Transaction Properties[](#block-and-transaction-properties "Link to this heading")
* `blockhash(uint blockNumber) returns (bytes32)`: hash of the given block - only works for 256 most recent blocks
 
* `blobhash(uint index) returns (bytes32)`: versioned hash of the `index`\-th blob associated with the current transaction. A versioned hash consists of a single byte representing the version (currently `0x01`), followed by the last 31 bytes of the SHA256 hash of the KZG commitment ([EIP-4844](https://eips.ethereum.org/EIPS/eip-4844)). Returns zero if no blob with the given index exists.
 
* `block.basefee` (`uint`): current block’s base fee ([EIP-3198](https://eips.ethereum.org/EIPS/eip-3198) and [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559))
 
* `block.blobbasefee` (`uint`): current block’s blob base fee ([EIP-7516](https://eips.ethereum.org/EIPS/eip-7516) and [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844))
 
* `block.chainid` (`uint`): current chain id
 
* `block.coinbase` (`address payable`): current block miner’s address
 
* `block.difficulty` (`uint`): current block difficulty (`EVM < Paris`). For other EVM versions it behaves as a deprecated alias for `block.prevrandao` that will be removed in the next breaking release
 
* `block.gaslimit` (`uint`): current block gaslimit
 
* `block.number` (`uint`): current block number
 
* `block.prevrandao` (`uint`): random number provided by the beacon chain (`EVM >= Paris`) (see [EIP-4399](https://eips.ethereum.org/EIPS/eip-4399) )
 
* `block.timestamp` (`uint`): current block timestamp in seconds since Unix epoch
 
* `gasleft() returns (uint256)`: remaining gas
 
* `msg.data` (`bytes`): complete calldata
 
* `msg.sender` (`address`): sender of the message (current call)
 
* `msg.sig` (`bytes4`): first four bytes of the calldata (i.e. function identifier)
 
* `msg.value` (`uint`): number of wei sent with the message
 
* `tx.gasprice` (`uint`): gas price of the transaction
 
* `tx.origin` (`address`): sender of the transaction (full call chain)
 
## Validations and Assertions[](#validations-and-assertions "Link to this heading")
* `assert(bool condition)`: abort execution and revert state changes if condition is `false` (use for internal error)
 
* `require(bool condition)`: abort execution and revert state changes if condition is `false` (use for malformed input or error in external component)
 
* `require(bool condition, string memory message)`: abort execution and revert state changes if condition is `false` (use for malformed input or error in external component). Also provide error message.
 
* `revert()`: abort execution and revert state changes
 
* `revert(string memory message)`: abort execution and revert state changes providing an explanatory string
 
## Mathematical and Cryptographic Functions[](#mathematical-and-cryptographic-functions "Link to this heading")
* `keccak256(bytes memory) returns (bytes32)`: compute the Keccak-256 hash of the input
 
* `sha256(bytes memory) returns (bytes32)`: compute the SHA-256 hash of the input
 
* `ripemd160(bytes memory) returns (bytes20)`: compute the RIPEMD-160 hash of the input
 
* `ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)`: recover address associated with the public key from elliptic curve signature, return zero on error
 
* `addmod(uint x, uint y, uint k) returns (uint)`: compute `(x + y) % k` where the addition is performed with arbitrary precision and does not wrap around at `2**256`. Assert that `k != 0` starting from version 0.5.0.
 
* `mulmod(uint x, uint y, uint k) returns (uint)`: compute `(x * y) % k` where the multiplication is performed with arbitrary precision and does not wrap around at `2**256`. Assert that `k != 0` starting from version 0.5.0.
 
## Type Information[](#type-information "Link to this heading")
* `type(C).name` (`string`): the name of the contract
 
* `type(C).creationCode` (`bytes memory`): creation bytecode of the given contract, see [Type Information](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#meta-type).
 
* `type(C).runtimeCode` (`bytes memory`): runtime bytecode of the given contract, see [Type Information](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#meta-type).
 
* `type(I).interfaceId` (`bytes4`): value containing the EIP-165 interface identifier of the given interface, see [Type Information](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#meta-type).
 
* `type(T).min` (`T`): the minimum value representable by the integer type `T`, see [Type Information](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#meta-type).
 
* `type(T).max` (`T`): the maximum value representable by the integer type `T`, see [Type Information](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#meta-type).
 
## Function Visibility Specifiers[](#function-visibility-specifiers "Link to this heading")
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=ZnVuY3Rpb24gbXlGdW5jdGlvbigpIDx2aXNpYmlsaXR5IHNwZWNpZmllcj4gcmV0dXJucyAoYm9vbCkgewogICAgcmV0dXJuIHRydWU7Cn0=)
function myFunction() <visibility specifier\> returns (bool) {
 return true;
}
* `public`: visible externally and internally (creates a [getter function](https://docs.soliditylang.org/en/v0.8.30/contracts.html#getter-functions) for storage/state variables)
 
* `private`: only visible in the current contract
 
* `external`: only visible externally (only for functions) - i.e. can only be message-called (via `this.func`)
 
* `internal`: only visible internally
 
## Modifiers[](#modifiers "Link to this heading")
* `pure` for functions: Disallows modification or access of state.
 
* `view` for functions: Disallows modification of state.
 
* `payable` for functions: Allows them to receive Ether together with a call.
 
* `constant` for state variables: Disallows assignment (except initialization), does not occupy storage slot.
 
* `immutable` for state variables: Allows assignment at construction time and is constant when deployed. Is stored in code.
 
* `anonymous` for events: Does not store event signature as topic.
 
* `indexed` for event parameters: Stores the parameter as topic.
 
* `virtual` for functions and modifiers: Allows the function’s or modifier’s behavior to be changed in derived contracts.
 
* `override`: States that this function, modifier or public state variable changes the behavior of a function or modifier in a base contract.

# [Common Patterns — Solidity 0.4.26 documentation](https://docs.soliditylang.org/en/v0.4.26/common-patterns.html) 
 _https://docs.soliditylang.org/en/v0.4.26/common-patterns.html_

[Solidity](https://docs.soliditylang.org/en/v0.4.26/index.html)
## Withdrawal from Contracts[¶](#withdrawal-from-contracts "Permalink to this headline")
The recommended method of sending funds after an effect is using the withdrawal pattern. Although the most intuitive method of sending Ether, as a result of an effect, is a direct `send` call, this is not recommended as it introduces a potential security risk. You may read more about this on the [Security Considerations](https://docs.soliditylang.org/en/v0.4.26/security-considerations.html#security-considerations) page.
This is an example of the withdrawal pattern in practice in a contract where the goal is to send the most money to the contract in order to become the “richest”, inspired by [King of the Ether](https://www.kingoftheether.com/).
In the following contract, if you are usurped as the richest, you will receive the funds of the person who has gone on to become the new richest.
pragma solidity ^0.4.11;
contract WithdrawalContract {
 address public richest;
 uint public mostSent;
 mapping (address \=> uint) pendingWithdrawals;
 function WithdrawalContract() public payable {
 richest \= msg.sender;
 mostSent \= msg.value;
 }
 function becomeRichest() public payable returns (bool) {
 if (msg.value \> mostSent) {
 pendingWithdrawals\[richest\] += msg.value;
 richest \= msg.sender;
 mostSent \= msg.value;
 return true;
 } else {
 return false;
 }
 }
 function withdraw() public {
 uint amount \= pendingWithdrawals\[msg.sender\];
 // Remember to zero the pending refund before
 // sending to prevent re-entrancy attacks
 pendingWithdrawals\[msg.sender\] \= 0;
 msg.sender.transfer(amount);
 }
}
This is as opposed to the more intuitive sending pattern:
pragma solidity ^0.4.11;
contract SendContract {
 address public richest;
 uint public mostSent;
 function SendContract() public payable {
 richest \= msg.sender;
 mostSent \= msg.value;
 }
 function becomeRichest() public payable returns (bool) {
 if (msg.value \> mostSent) {
 // This line can cause problems (explained below).
 richest.transfer(msg.value);
 richest \= msg.sender;
 mostSent \= msg.value;
 return true;
 } else {
 return false;
 }
 }
}
Notice that, in this example, an attacker could trap the contract into an unusable state by causing `richest` to be the address of a contract that has a fallback function which fails (e.g. by using `revert()` or by just consuming more than the 2300 gas stipend). That way, whenever `transfer` is called to deliver funds to the “poisoned” contract, it will fail and thus also `becomeRichest` will fail, with the contract being stuck forever.
In contrast, if you use the “withdraw” pattern from the first example, the attacker can only cause his or her own withdraw to fail and not the rest of the contract’s workings.
## Restricting Access[¶](#restricting-access "Permalink to this headline")
Restricting access is a common pattern for contracts. Note that you can never restrict any human or computer from reading the content of your transactions or your contract’s state. You can make it a bit harder by using encryption, but if your contract is supposed to read the data, so will everyone else.
You can restrict read access to your contract’s state by **other contracts**. That is actually the default unless you declare make your state variables `public`.
Furthermore, you can restrict who can make modifications to your contract’s state or call your contract’s functions and this is what this section is about.
The use of **function modifiers** makes these restrictions highly readable.
pragma solidity ^0.4.22;
contract AccessRestriction {
 // These will be assigned at the construction
 // phase, where \`msg.sender\` is the account
 // creating this contract.
 address public owner \= msg.sender;
 uint public creationTime \= now;
 // Modifiers can be used to change
 // the body of a function.
 // If this modifier is used, it will
 // prepend a check that only passes
 // if the function is called from
 // a certain address.
 modifier onlyBy(address \_account)
 {
 require(
 msg.sender \== \_account,
 "Sender not authorized."
 );
 // Do not forget the "\_;"! It will
 // be replaced by the actual function
 // body when the modifier is used.
 \_;
 }
 /// Make \`\_newOwner\` the new owner of this
 /// contract.
 function changeOwner(address \_newOwner)
 public
 onlyBy(owner)
 {
 owner \= \_newOwner;
 }
 modifier onlyAfter(uint \_time) {
 require(
 now \>= \_time,
 "Function called too early."
 );
 \_;
 }
 /// Erase ownership information.
 /// May only be called 6 weeks after
 /// the contract has been created.
 function disown()
 public
 onlyBy(owner)
 onlyAfter(creationTime + 6 weeks)
 {
 delete owner;
 }
 // This modifier requires a certain
 // fee being associated with a function call.
 // If the caller sent too much, he or she is
 // refunded, but only after the function body.
 // This was dangerous before Solidity version 0.4.0,
 // where it was possible to skip the part after \`\_;\`.
 modifier costs(uint \_amount) {
 require(
 msg.value \>= \_amount,
 "Not enough Ether provided."
 );
 \_;
 if (msg.value \> \_amount)
 msg.sender.send(msg.value \- \_amount);
 }
 function forceOwnerChange(address \_newOwner)
 public
 payable
 costs(200 ether)
 {
 owner \= \_newOwner;
 // just some example condition
 if (uint(owner) & 0 \== 1)
 // This did not refund for Solidity
 // before version 0.4.0.
 return;
 // refund overpaid fees
 }
}
A more specialised way in which access to function calls can be restricted will be discussed in the next example.
## State Machine[¶](#state-machine "Permalink to this headline")
Contracts often act as a state machine, which means that they have certain **stages** in which they behave differently or in which different functions can be called. A function call often ends a stage and transitions the contract into the next stage (especially if the contract models **interaction**). It is also common that some stages are automatically reached at a certain point in **time**.
An example for this is a blind auction contract which starts in the stage “accepting blinded bids”, then transitions to “revealing bids” which is ended by “determine auction outcome”.
Function modifiers can be used in this situation to model the states and guard against incorrect usage of the contract.
### Example[¶](#example "Permalink to this headline")
In the following example, the modifier `atStage` ensures that the function can only be called at a certain stage.
Automatic timed transitions are handled by the modifier `timeTransitions`, which should be used for all functions.
Note
**Modifier Order Matters**. If atStage is combined with timedTransitions, make sure that you mention it after the latter, so that the new stage is taken into account.
Finally, the modifier `transitionNext` can be used to automatically go to the next stage when the function finishes.
Note
**Modifier May be Skipped**. This only applies to Solidity before version 0.4.0: Since modifiers are applied by simply replacing code and not by using a function call, the code in the transitionNext modifier can be skipped if the function itself uses return. If you want to do that, make sure to call nextStage manually from those functions. Starting with version 0.4.0, modifier code will run even if the function explicitly returns.
pragma solidity ^0.4.22;
contract StateMachine {
 enum Stages {
 AcceptingBlindedBids,
 RevealBids,
 AnotherStage,
 AreWeDoneYet,
 Finished
 }
 // This is the current stage.
 Stages public stage \= Stages.AcceptingBlindedBids;
 uint public creationTime \= now;
 modifier atStage(Stages \_stage) {
 require(
 stage \== \_stage,
 "Function cannot be called at this time."
 );
 \_;
 }
 function nextStage() internal {
 stage \= Stages(uint(stage) + 1);
 }
 // Perform timed transitions. Be sure to mention
 // this modifier first, otherwise the guards
 // will not take the new stage into account.
 modifier timedTransitions() {
 if (stage \== Stages.AcceptingBlindedBids &&
 now \>= creationTime + 10 days)
 nextStage();
 if (stage \== Stages.RevealBids &&
 now \>= creationTime + 12 days)
 nextStage();
 // The other stages transition by transaction
 \_;
 }
 // Order of the modifiers matters here!
 function bid()
 public
 payable
 timedTransitions
 atStage(Stages.AcceptingBlindedBids)
 {
 // We will not implement that here
 }
 function reveal()
 public
 timedTransitions
 atStage(Stages.RevealBids)
 {
 }
 // This modifier goes to the next stage
 // after the function is done.
 modifier transitionNext()
 {
 \_;
 nextStage();
 }
 function g()
 public
 timedTransitions
 atStage(Stages.AnotherStage)
 transitionNext
 {
 }
 function h()
 public
 timedTransitions
 atStage(Stages.AreWeDoneYet)
 transitionNext
 {
 }
 function i()
 public
 timedTransitions
 atStage(Stages.Finished)
 {
 }
}

# [Sık Kullanılan Modeller — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/common-patterns.html) 
 _https://docs.soliditylang.org/tr/latest/common-patterns.html_

## Sözleşmelerden Para Çekme[](#sozlesmelerden-para-cekme "Permalink to this heading")
Bir etkiden sonra önerilen fon gönderme yöntemi, para çekme modelini kullanmaktır. Bir etki sonucunda, anlaşılması en kolay Ether gönderme yöntemi doğrudan `transfer` çağrısı olsa da, potansiyel güvenlik riski oluşturduğundan bu önerilmez. Bu konuda daha fazla bilgiye [Güvenlikle İlgili Değerlendirmeler](https://docs.soliditylang.org/tr/latest/security-considerations.html#security-considerations) sayfasından ulaşabilirsiniz.
King of the Ether <https://www.kingoftheether.com/>’de olduğu gibi, amacın “en zengin” olmak için sözleşmeye en fazla parayı göndermek olduğu bir sözleşmede para çekme modelinin nasıl kullanıldığına dair uygulamalı bir örnek aşağıda verilmiştir.
Aşağıdaki sözleşmede, artık en zengin olan değilseniz o anda en zengin olan kişinin fonlarını alırsınız.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IFdpdGhkcmF3YWxDb250cmFjdCB7CiAgICBhZGRyZXNzIHB1YmxpYyByaWNoZXN0OwogICAgdWludCBwdWJsaWMgbW9zdFNlbnQ7CgogICAgbWFwcGluZyAoYWRkcmVzcyA9PiB1aW50KSBwZW5kaW5nV2l0aGRyYXdhbHM7CgogICAgLy8vIEfDtm5kZXJpbGVuIEV0aGVyIG1pa3RhcsSxIMWfdSBhbmtpIGVuIHnDvGtzZWsKICAgIC8vLyBtaWt0YXJkYW4gecO8a3NlayBkZcSfaWxkaS4KICAgIGVycm9yIE5vdEVub3VnaEV0aGVyKCk7CgogICAgY29uc3RydWN0b3IoKSBwYXlhYmxlIHsKICAgICAgICByaWNoZXN0ID0gbXNnLnNlbmRlcjsKICAgICAgICBtb3N0U2VudCA9IG1zZy52YWx1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBiZWNvbWVSaWNoZXN0KCkgcHVibGljIHBheWFibGUgewogICAgICAgIGlmIChtc2cudmFsdWUgPD0gbW9zdFNlbnQpIHJldmVydCBOb3RFbm91Z2hFdGhlcigpOwogICAgICAgIHBlbmRpbmdXaXRoZHJhd2Fsc1tyaWNoZXN0XSArPSBtc2cudmFsdWU7CiAgICAgICAgcmljaGVzdCA9IG1zZy5zZW5kZXI7CiAgICAgICAgbW9zdFNlbnQgPSBtc2cudmFsdWU7CiAgICB9CgogICAgZnVuY3Rpb24gd2l0aGRyYXcoKSBwdWJsaWMgewogICAgICAgIHVpbnQgYW1vdW50ID0gcGVuZGluZ1dpdGhkcmF3YWxzW21zZy5zZW5kZXJdOwogICAgICAgIC8vIFRla3JhciBnaXJtZShyZS1lbnRyYW5jeSksIHNhbGTEsXLEsWxhcsSxbsSxIMO2bmxlbWVrIGnDp2luIGfDtm5kZXJpbQogICAgICAgIC8vIMO2bmNlc2luZGUgZ2VyaSDDtmRlbWV5aSBzxLFmxLFybGFtYXnEsSB1bnV0bWF5xLFuCiAgICAgICAgcGVuZGluZ1dpdGhkcmF3YWxzW21zZy5zZW5kZXJdID0gMDsKICAgICAgICBwYXlhYmxlKG1zZy5zZW5kZXIpLnRyYW5zZmVyKGFtb3VudCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract WithdrawalContract {
 address public richest;
 uint public mostSent;
 mapping (address \=> uint) pendingWithdrawals;
 /// Gönderilen Ether miktarı şu anki en yüksek
 /// miktardan yüksek değildi.
 error NotEnoughEther();
 constructor() payable {
 richest \= msg.sender;
 mostSent \= msg.value;
 }
 function becomeRichest() public payable {
 if (msg.value <= mostSent) revert NotEnoughEther();
 pendingWithdrawals\[richest\] += msg.value;
 richest \= msg.sender;
 mostSent \= msg.value;
 }
 function withdraw() public {
 uint amount \= pendingWithdrawals\[msg.sender\];
 // Tekrar girme(re-entrancy), saldırılarını önlemek için gönderim
 // öncesinde geri ödemeyi sıfırlamayı unutmayın
 pendingWithdrawals\[msg.sender\] \= 0;
 payable(msg.sender).transfer(amount);
 }
}
Akla daha yatkın olan gönderme modeli aşağıdaki gibidir ama güvenlik açığı içerir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IFNlbmRDb250cmFjdCB7CiAgICBhZGRyZXNzIHBheWFibGUgcHVibGljIHJpY2hlc3Q7CiAgICB1aW50IHB1YmxpYyBtb3N0U2VudDsKCiAgICAvLy8gR8O2bmRlcmlsZW4gRXRoZXIgbWlrdGFyxLEgxZ91IGFua2kgZW4gecO8a3NlawogICAgLy8vIG1pa3RhcmRhbiB5w7xrc2VrIGRlxJ9pbGRpLgogICAgZXJyb3IgTm90RW5vdWdoRXRoZXIoKTsKCiAgICBjb25zdHJ1Y3RvcigpIHBheWFibGUgewogICAgICAgIHJpY2hlc3QgPSBwYXlhYmxlKG1zZy5zZW5kZXIpOwogICAgICAgIG1vc3RTZW50ID0gbXNnLnZhbHVlOwogICAgfQoKICAgIGZ1bmN0aW9uIGJlY29tZVJpY2hlc3QoKSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgaWYgKG1zZy52YWx1ZSA8PSBtb3N0U2VudCkgcmV2ZXJ0IE5vdEVub3VnaEV0aGVyKCk7CiAgICAgICAgLy8gQnUgc2F0xLFyIHNvcnVubGFyYSBuZWRlbiBvbGFiaWxpciAoYcWfYcSfxLFkYSBhw6fEsWtsYW5txLHFn3TEsXIpLgogICAgICAgIHJpY2hlc3QudHJhbnNmZXIobXNnLnZhbHVlKTsKICAgICAgICByaWNoZXN0ID0gcGF5YWJsZShtc2cuc2VuZGVyKTsKICAgICAgICBtb3N0U2VudCA9IG1zZy52YWx1ZTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract SendContract {
 address payable public richest;
 uint public mostSent;
 /// Gönderilen Ether miktarı şu anki en yüksek
 /// miktardan yüksek değildi.
 error NotEnoughEther();
 constructor() payable {
 richest \= payable(msg.sender);
 mostSent \= msg.value;
 }
 function becomeRichest() public payable {
 if (msg.value <= mostSent) revert NotEnoughEther();
 // Bu satır sorunlara neden olabilir (aşağıda açıklanmıştır).
 richest.transfer(msg.value);
 richest \= payable(msg.sender);
 mostSent \= msg.value;
 }
}
Bu örnekte, bir saldırgan, `richest`’ın başarısız olan bir receive veya callback fonksiyonuna sahip bir sözleşmenin adresi olmasına sebep olarak (örneğin, `revert()` kullanarak veya yalnızca, onlara aktarılan 2300 gas ücretinden daha fazlasını tüketerek) sözleşmeyi kullanılamayacak bir duruma düşürebilir. Bu şekilde, fonları “zehirlenmiş” sözleşmeye iletmek için `transfer` her çağrıldığında başarısız olur, dolayısıyla `becomeRichest` fonksiyonu da başarısız olur ve sözleşme sonsuza kadar kilitli / takılı kalır.
Bunun aksine, ilk örnekten “çekme” modelini kullanırsanız saldırgan sözleşmenin kalanındaki işleyişin değil, yalnızca kendi çekim işleminin başarısız olmasına sebep olabilir.
## Erişimi Kısıtlamak[](#erisimi-kisitlamak "Permalink to this heading")
Erişimi kısıtlamak sözleşmeler için yaygın bir modeldir. Herhangi bir insanı veya bilgisayarı, işlemlerinizin içeriğini veya sözleşmenizin durumunu okumak konusunda kesinlikle kısıtlayamayacağınızı unutmayın. Şifreleme kullanarak bunu bir miktar zorlaştırabilirsiniz ancak sözleşmenizin veri okumasına izin verilmişse diğer herkes de okuyacaktır.
Sözleşme durum degişkenlerinin okuma erişimini **diğer sözleşmeler** ile kısıtlayabilirsiniz. Bu aslında, durum değişkenlerinizi `public` olarak bildirmediğiniz sürece varsayılandır.
Ayrıca, sözleşmenizin durumunda değişiklik yapabilecek kişileri kısıtlayabilir veya sözleşmenizin fonksiyonlarını çağırabilirsiniz; bu bölümün konusu da budur.
**Fonksiyon modifier’larının** kullanımı bu kısıtlamaları oldukça okunur hale getirir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IEFjY2Vzc1Jlc3RyaWN0aW9uIHsKICAgIC8vIEJ1bmxhciwgYG1zZy5zZW5kZXJgJ8SxbiBidSBzw7Z6bGXFn21leWkKICAgIC8vIG9sdcWfdHVyYW4gaGVzYXAgb2xkdcSfdSB5YXDEsW0gYcWfYW1hc8SxbmRhCiAgICAvLyBhdGFuYWNha3TEsXIuCiAgICBhZGRyZXNzIHB1YmxpYyBvd25lciA9IG1zZy5zZW5kZXI7CiAgICB1aW50IHB1YmxpYyBjcmVhdGlvblRpbWUgPSBibG9jay50aW1lc3RhbXA7CgogICAgLy8gQWx0dGEsIGJ1IHPDtnpsZcWfbWVuaW4gb2x1xZ90dXJhYmlsZWNlxJ9pCiAgICAvLyBoYXRhbGFyxLFuIGJpciBsaXN0ZXNpLCDDtnplbCB5b3J1bWxhcmRhCiAgICAvLyB5YXrEsWzEsSBiaXIgYcOnxLFrbGFtYXlsYSBiaXJsaWt0ZQogICAgLy8gdmVyaWxtacWfdGlyLgoKICAgIC8vLyBHw7ZuZGVyaWNpIGJ1IGnFn2xlbSBpw6dpbiB5ZXRraWxpCiAgICAvLy8gZGXEn2lsZGlyLgogICAgZXJyb3IgVW5hdXRob3JpemVkKCk7CgogICAgLy8vIEZvbmtzaXlvbiDDp29rIGVya2VuIMOnYcSfcsSxbGTEsS4KICAgIGVycm9yIFRvb0Vhcmx5KCk7CgogICAgLy8vIEZvbmtzaXlvbiDDp2HEn3LEsXPEsXlsYSB5ZXRlcmluY2UgRXRoZXIgZ8O2bmRlcmlsbWVkaS4KICAgIGVycm9yIE5vdEVub3VnaEV0aGVyKCk7CgogICAgLy8gTW9kaWZpZXInbGFyIGJpciBmb25rc2l5b251biBnw7Z2ZGVzaW5pCiAgICAvLyBkZcSfacWfdGlybWVrIGnDp2luIGt1bGxhbsSxbGFiaWxpci4KICAgIC8vIEJ1IG1vZGlmaWVyIGt1bGxhbsSxbMSxcnNhIGJhxZ9hLAogICAgLy8geWFsbsSxemNhIGZvbmtzaXlvbiBiZWxpcmxpIGJpcgogICAgLy8gYWRyZXN0ZW4gw6dhxJ9yxLFsZMSxxJ/EsW5kYSBnZcOnZW4gYmlyCiAgICAvLyBrb250cm9sIGVrbGV5ZWNla3Rpci4KICAgIG1vZGlmaWVyIG9ubHlCeShhZGRyZXNzIGFjY291bnQpCiAgICB7CiAgICAgICAgaWYgKG1zZy5zZW5kZXIgIT0gYWNjb3VudCkKICAgICAgICAgICAgcmV2ZXJ0IFVuYXV0aG9yaXplZCgpOwogICAgICAgIC8vICJfOyIgacWfYXJldGluaSB1bnV0bWF5xLFuISBNb2RpZmllcgogICAgICAgIC8vIGt1bGxhbsSxbGTEscSfxLFuZGEgYnUsIGdlcsOnZWsgZm9ua3NpeW9uCiAgICAgICAgLy8gZ8O2dmRlc2kgaWxlIGRlxJ9pxZ90aXJpbGVjZWt0aXIuCiAgICAgICAgXzsKICAgIH0KCiAgICAvLy8gYG5ld093bmVyYCfEsSBidSBzw7Z6bGXFn21lbmluIHllbmkKICAgIC8vLyBzYWhpYmkgeWFwxLFuLgogICAgZnVuY3Rpb24gY2hhbmdlT3duZXIoYWRkcmVzcyBuZXdPd25lcikKICAgICAgICBwdWJsaWMKICAgICAgICBvbmx5Qnkob3duZXIpCiAgICB7CiAgICAgICAgb3duZXIgPSBuZXdPd25lcjsKICAgIH0KCiAgICBtb2RpZmllciBvbmx5QWZ0ZXIodWludCB0aW1lKSB7CiAgICAgICAgaWYgKGJsb2NrLnRpbWVzdGFtcCA8IHRpbWUpCiAgICAgICAgICAgIHJldmVydCBUb29FYXJseSgpOwogICAgICAgIF87CiAgICB9CgogICAgLy8vIFNhaGlwbGlrIGJpbGdpbGVyaW5pIHNpbGluLgogICAgLy8vIFlhbG7EsXpjYSBzw7Z6bGXFn21lIG9sdcWfdHVydWxkdWt0YW4KICAgIC8vLyA2IGhhZnRhIHNvbnJhIMOnYcSfcsSxbGFiaWxpci4KICAgIGZ1bmN0aW9uIGRpc293bigpCiAgICAgICAgcHVibGljCiAgICAgICAgb25seUJ5KG93bmVyKQogICAgICAgIG9ubHlBZnRlcihjcmVhdGlvblRpbWUgKyA2IHdlZWtzKQogICAgewogICAgICAgIGRlbGV0ZSBvd25lcjsKICAgIH0KCiAgICAvLyBCdSBtb2RpZmllciwgYmlyIGZvbmtzaXlvbiDDp2HEn3LEsXPEsW7EsW4gYmVsaXJsaQogICAgLy8gYmlyIMO8Y3JldGxlIGlsacWfa2lsZW5kaXJpbG1lc2luaSBnZXJla3RpcmlyLgogICAgLy8gw4dhxJ/EsXJhbiBracWfaSDDp29rIGZhemxhIGfDtm5kZXJtacWfc2UgeWFsbsSxemNhCiAgICAvLyBmb25rc2l5b24gZ8O2dmRlc2luZGVuIHNvbnJhc8SxIGlhZGUgZWRpbGlyLgogICAgLy8gQnUsIGBfO2Agc29ucmFzxLFuZGFraSBrxLFzbcSxIGF0bGFtYW7EsW4gbcO8bWvDvG4KICAgIC8vIG9sZHXEn3UgU29saWRpdHkgc8O8csO8bcO8IDAuNC4wIMO2bmNlc2luZGUgdGVobGlrZWxpeWRpLgogICAgbW9kaWZpZXIgY29zdHModWludCBhbW91bnQpIHsKICAgICAgICBpZiAobXNnLnZhbHVlIDwgYW1vdW50KQogICAgICAgICAgICByZXZlcnQgTm90RW5vdWdoRXRoZXIoKTsKCiAgICAgICAgXzsKICAgICAgICBpZiAobXNnLnZhbHVlID4gYW1vdW50KQogICAgICAgICAgICBwYXlhYmxlKG1zZy5zZW5kZXIpLnRyYW5zZmVyKG1zZy52YWx1ZSAtIGFtb3VudCk7CiAgICB9CgogICAgZnVuY3Rpb24gZm9yY2VPd25lckNoYW5nZShhZGRyZXNzIG5ld093bmVyKQogICAgICAgIHB1YmxpYwogICAgICAgIHBheWFibGUKICAgICAgICBjb3N0cygyMDAgZXRoZXIpCiAgICB7CiAgICAgICAgb3duZXIgPSBuZXdPd25lcjsKICAgICAgICAvLyB5YWxuxLF6Y2Egw7ZybmVrIGJpciBrb8WfdWwKICAgICAgICBpZiAodWludDE2MChvd25lcikgJiAwID09IDEpCiAgICAgICAgICAgIC8vIFPDvHLDvG0gMC40LjAgw7ZuY2VzaW5kZSBidSwgU29saWRpdHkKICAgICAgICAgICAgLy8gaWFkZSB5YXBtxLF5b3JkdS4KICAgICAgICAgICAgcmV0dXJuOwogICAgICAgIC8vIGZhemxhIMO2ZGVuZW4gw7xjcmV0bGVyaSBpYWRlIGV0CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract AccessRestriction {
 // Bunlar, \`msg.sender\`'ın bu sözleşmeyi
 // oluşturan hesap olduğu yapım aşamasında
 // atanacaktır.
 address public owner \= msg.sender;
 uint public creationTime \= block.timestamp;
 // Altta, bu sözleşmenin oluşturabileceği
 // hataların bir listesi, özel yorumlarda
 // yazılı bir açıklamayla birlikte
 // verilmiştir.
 /// Gönderici bu işlem için yetkili
 /// değildir.
 error Unauthorized();
 /// Fonksiyon çok erken çağrıldı.
 error TooEarly();
 /// Fonksiyon çağrısıyla yeterince Ether gönderilmedi.
 error NotEnoughEther();
 // Modifier'lar bir fonksiyonun gövdesini
 // değiştirmek için kullanılabilir.
 // Bu modifier kullanılırsa başa,
 // yalnızca fonksiyon belirli bir
 // adresten çağrıldığında geçen bir
 // kontrol ekleyecektir.
 modifier onlyBy(address account)
 {
 if (msg.sender != account)
 revert Unauthorized();
 // "\_;" işaretini unutmayın! Modifier
 // kullanıldığında bu, gerçek fonksiyon
 // gövdesi ile değiştirilecektir.
 \_;
 }
 /// \`newOwner\`'ı bu sözleşmenin yeni
 /// sahibi yapın.
 function changeOwner(address newOwner)
 public
 onlyBy(owner)
 {
 owner \= newOwner;
 }
 modifier onlyAfter(uint time) {
 if (block.timestamp < time)
 revert TooEarly();
 \_;
 }
 /// Sahiplik bilgilerini silin.
 /// Yalnızca sözleşme oluşturulduktan
 /// 6 hafta sonra çağrılabilir.
 function disown()
 public
 onlyBy(owner)
 onlyAfter(creationTime + 6 weeks)
 {
 delete owner;
 }
 // Bu modifier, bir fonksiyon çağrısının belirli
 // bir ücretle ilişkilendirilmesini gerektirir.
 // Çağıran kişi çok fazla göndermişse yalnızca
 // fonksiyon gövdesinden sonrası iade edilir.
 // Bu, \`\_;\` sonrasındaki kısmı atlamanın mümkün
 // olduğu Solidity sürümü 0.4.0 öncesinde tehlikeliydi.
 modifier costs(uint amount) {
 if (msg.value < amount)
 revert NotEnoughEther();
 \_;
 if (msg.value \> amount)
 payable(msg.sender).transfer(msg.value \- amount);
 }
 function forceOwnerChange(address newOwner)
 public
 payable
 costs(200 ether)
 {
 owner \= newOwner;
 // yalnızca örnek bir koşul
 if (uint160(owner) & 0 \== 1)
 // Sürüm 0.4.0 öncesinde bu, Solidity
 // iade yapmıyordu.
 return;
 // fazla ödenen ücretleri iade et
 }
}
Fonksiyon çağrılarına erişimin kısıtlanabileceği daha özel bir yol, bir sonraki örnekte incelenecektir.
## Durum Makinesi[](#durum-makinesi "Permalink to this heading")
Sözleşmeler, sıklıkla, bir durum makinesi işlevi görür; bu, içinde farklı davrandıkları veya farklı fonksiyonların çağrılabildiği belirli **aşamalara** sahip oldukları anlamına gelir.Bir fonksiyon çağrısı genellikle bir aşamayı sonlandırır ve sözleşmeyi bir sonraki aşamaya geçirir (özellikle sözleşme, **etkileşimi** modellediğinde). Bazı aşamalara belirli bir **anda** otomatik olarak ulaşılması da yaygındır.
Bunun bir örneği, “kör teklifleri kabul etme” aşamasından başlayan, “teklifleri açıklama” aşamasına geçen ve “ihale sonucunu belirleme” ile sonlanan kör ihale sözleşmesidir.
Bu durumda, durumları modellemek ve sözleşmenin yanlış kullanımına karşı korunmak için fonksiyon modifier’ları kullanılabilir.
### Örnek[](#ornek "Permalink to this heading")
Aşağıdaki örnekte, `atStage` modifier’ı fonksiyonun yalnızca belirli bir aşamada çağrılmasını sağlar.
Otomatik zaman ayarlı geçişler, tüm fonksiyonlar tarafından kullanılması gereken `timedTransitions` modifier’ı ele alınır.
Not
**Modifier Sırası Önemlidir**. atStage, timedTransitions ile birleştirilirse yeni aşamanın dikkate alınması için atStage’i timedTransitions’tan sonra belirttiğinizden emin olun.
Son olarak, fonksiyon sonlandığında otomatik olarak bir sonraki aşamaya gitmek için `transitionNext` modifier’ı kullanılabilir.
Not
**Modifier Atlanabilir**. Bu, yalnızca 0.4.0 öncesi Solidity sürümlerinde geçerlidir: Modifier’lar, fonksiyon çağrısı kullanarak değil, yalnızca kodu değiştirerek uygulandığından fonksiyonun kendisi return kullanırsa transitionNext modifier’ındaki kod atlanabilir. Bunu yapmak isterseniz nextStage’i o fonksiyonlardan manuel olarak çağırdığınızdan emin olun. 0.4.0 sürümünden itibaren modifier kodu, fonksiyon açıkça retun etse dahi çalışacaktır.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IFN0YXRlTWFjaGluZSB7CiAgICBlbnVtIFN0YWdlcyB7CiAgICAgICAgQWNjZXB0aW5nQmxpbmRlZEJpZHMsCiAgICAgICAgUmV2ZWFsQmlkcywKICAgICAgICBBbm90aGVyU3RhZ2UsCiAgICAgICAgQXJlV2VEb25lWWV0LAogICAgICAgIEZpbmlzaGVkCiAgICB9CiAgICAvLy8gQnUgbm9rdGFkYSBmb25rc2l5b24gw6dhxJ9yxLFsYW1hei4KICAgIGVycm9yIEZ1bmN0aW9uSW52YWxpZEF0VGhpc1N0YWdlKCk7CgogICAgLy8gTWV2Y3V0IGHFn2FtYSBidWR1ci4KICAgIFN0YWdlcyBwdWJsaWMgc3RhZ2UgPSBTdGFnZXMuQWNjZXB0aW5nQmxpbmRlZEJpZHM7CgogICAgdWludCBwdWJsaWMgY3JlYXRpb25UaW1lID0gYmxvY2sudGltZXN0YW1wOwoKICAgIG1vZGlmaWVyIGF0U3RhZ2UoU3RhZ2VzIHN0YWdlXykgewogICAgICAgIGlmIChzdGFnZSAhPSBzdGFnZV8pCiAgICAgICAgICAgIHJldmVydCBGdW5jdGlvbkludmFsaWRBdFRoaXNTdGFnZSgpOwogICAgICAgIF87CiAgICB9CgogICAgZnVuY3Rpb24gbmV4dFN0YWdlKCkgaW50ZXJuYWwgewogICAgICAgIHN0YWdlID0gU3RhZ2VzKHVpbnQoc3RhZ2UpICsgMSk7CiAgICB9CgogICAgLy8gWmFtYW4gYXlhcmzEsSBnZcOnacWfbGVyIGdlcsOnZWtsZcWfdGlyaW4uIMOWbmNlIGJ1CiAgICAvLyBtb2RpZmllcifEsSBiZWxpcnR0acSfaW5pemRlbiBlbWluIG9sdW4gYWtzaSBoYWxkZQogICAgLy8ga29ydW1hbGFyIHllbmkgYcWfYW1hecSxIGRpa2thdGUgYWxtYXouCiAgICBtb2RpZmllciB0aW1lZFRyYW5zaXRpb25zKCkgewogICAgICAgIGlmIChzdGFnZSA9PSBTdGFnZXMuQWNjZXB0aW5nQmxpbmRlZEJpZHMgJiYKICAgICAgICAgICAgICAgICAgICBibG9jay50aW1lc3RhbXAgPj0gY3JlYXRpb25UaW1lICsgMTAgZGF5cykKICAgICAgICAgICAgbmV4dFN0YWdlKCk7CiAgICAgICAgaWYgKHN0YWdlID09IFN0YWdlcy5SZXZlYWxCaWRzICYmCiAgICAgICAgICAgICAgICBibG9jay50aW1lc3RhbXAgPj0gY3JlYXRpb25UaW1lICsgMTIgZGF5cykKICAgICAgICAgICAgbmV4dFN0YWdlKCk7CiAgICAgICAgLy8gRGnEn2VyIGHFn2FtYWxhciBpxZ9sZW1lIGfDtnJlIGdlw6dpxZ8geWFwYXIKICAgICAgICBfOwogICAgfQoKICAgIC8vIEJ1cmFkYSBtb2RpZmllcidsYXLEsW4gc8SxcmFzxLEgw7ZuZW1saWRpciEKICAgIGZ1bmN0aW9uIGJpZCgpCiAgICAgICAgcHVibGljCiAgICAgICAgcGF5YWJsZQogICAgICAgIHRpbWVkVHJhbnNpdGlvbnMKICAgICAgICBhdFN0YWdlKFN0YWdlcy5BY2NlcHRpbmdCbGluZGVkQmlkcykKICAgIHsKICAgICAgICAvLyBPbnUgYnVyYWRhIHV5Z3VsYW1heWFjYcSfxLF6CiAgICB9CgogICAgZnVuY3Rpb24gcmV2ZWFsKCkKICAgICAgICBwdWJsaWMKICAgICAgICB0aW1lZFRyYW5zaXRpb25zCiAgICAgICAgYXRTdGFnZShTdGFnZXMuUmV2ZWFsQmlkcykKICAgIHsKICAgIH0KCiAgICAvLyBCdSBtb2RpZmllciwgZm9ua3NpeW9udW4gdGFtYW1sYW5tYXPEsW7EsW4KICAgIC8vIGFyZMSxbmRhbiBzb25yYWtpIGHFn2FtYXlhIGdlw6dlci4KICAgIG1vZGlmaWVyIHRyYW5zaXRpb25OZXh0KCkKICAgIHsKICAgICAgICBfOwogICAgICAgIG5leHRTdGFnZSgpOwogICAgfQoKICAgIGZ1bmN0aW9uIGcoKQogICAgICAgIHB1YmxpYwogICAgICAgIHRpbWVkVHJhbnNpdGlvbnMKICAgICAgICBhdFN0YWdlKFN0YWdlcy5Bbm90aGVyU3RhZ2UpCiAgICAgICAgdHJhbnNpdGlvbk5leHQKICAgIHsKICAgIH0KCiAgICBmdW5jdGlvbiBoKCkKICAgICAgICBwdWJsaWMKICAgICAgICB0aW1lZFRyYW5zaXRpb25zCiAgICAgICAgYXRTdGFnZShTdGFnZXMuQXJlV2VEb25lWWV0KQogICAgICAgIHRyYW5zaXRpb25OZXh0CiAgICB7CiAgICB9CgogICAgZnVuY3Rpb24gaSgpCiAgICAgICAgcHVibGljCiAgICAgICAgdGltZWRUcmFuc2l0aW9ucwogICAgICAgIGF0U3RhZ2UoU3RhZ2VzLkZpbmlzaGVkKQogICAgewogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract StateMachine {
 enum Stages {
 AcceptingBlindedBids,
 RevealBids,
 AnotherStage,
 AreWeDoneYet,
 Finished
 }
 /// Bu noktada fonksiyon çağrılamaz.
 error FunctionInvalidAtThisStage();
 // Mevcut aşama budur.
 Stages public stage \= Stages.AcceptingBlindedBids;
 uint public creationTime \= block.timestamp;
 modifier atStage(Stages stage\_) {
 if (stage != stage\_)
 revert FunctionInvalidAtThisStage();
 \_;
 }
 function nextStage() internal {
 stage \= Stages(uint(stage) + 1);
 }
 // Zaman ayarlı geçişler gerçekleştirin. Önce bu
 // modifier'ı belirttiğinizden emin olun aksi halde
 // korumalar yeni aşamayı dikkate almaz.
 modifier timedTransitions() {
 if (stage \== Stages.AcceptingBlindedBids &&
 block.timestamp \>= creationTime + 10 days)
 nextStage();
 if (stage \== Stages.RevealBids &&
 block.timestamp \>= creationTime + 12 days)
 nextStage();
 // Diğer aşamalar işleme göre geçiş yapar
 \_;
 }
 // Burada modifier'ların sırası önemlidir!
 function bid()
 public
 payable
 timedTransitions
 atStage(Stages.AcceptingBlindedBids)
 {
 // Onu burada uygulamayacağız
 }
 function reveal()
 public
 timedTransitions
 atStage(Stages.RevealBids)
 {
 }
 // Bu modifier, fonksiyonun tamamlanmasının
 // ardından sonraki aşamaya geçer.
 modifier transitionNext()
 {
 \_;
 nextStage();
 }
 function g()
 public
 timedTransitions
 atStage(Stages.AnotherStage)
 transitionNext
 {
 }
 function h()
 public
 timedTransitions
 atStage(Stages.AreWeDoneYet)
 transitionNext
 {
 }
 function i()
 public
 timedTransitions
 atStage(Stages.Finished)
 {
 }
}

# [Types — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/types.html) 
 _https://docs.soliditylang.org/en/latest/types.html_

Solidity is a statically typed language, which means that the type of each variable (state and local) needs to be specified. Solidity provides several elementary types which can be combined to form complex types.
In addition, types can interact with each other in expressions containing operators. For a quick reference of the various operators, see [Order of Precedence of Operators](#order).
The concept of “undefined” or “null” values does not exist in Solidity, but newly declared variables always have a [default value](https://docs.soliditylang.org/en/latest/control-structures.html#default-value) dependent on its type. To handle any unexpected values, you should use the [revert function](https://docs.soliditylang.org/en/latest/control-structures.html#assert-and-require) to revert the whole transaction, or return a tuple with a second `bool` value denoting success.
## Value Types[](#value-types "Link to this heading")
The following are called value types because their variables will always be passed by value, i.e. they are always copied when they are used as function arguments or in assignments.
Unlike [reference types](#reference-types), value type declarations do not specify a data location since they are small enough to be stored on the stack. The only exception is [state variables](https://docs.soliditylang.org/en/latest/structure-of-a-contract.html#structure-state-variables). Those are by default located in storage, but can also be marked as [transient](https://docs.soliditylang.org/en/latest/contracts.html#transient-storage), [constant or immutable](https://docs.soliditylang.org/en/latest/contracts.html#constants).
### Booleans[](#booleans "Link to this heading")
`bool`: The possible values are constants `true` and `false`.
Operators:
* `!` (logical negation)
 
* `&&` (logical conjunction, “and”)
 
* `||` (logical disjunction, “or”)
 
* `==` (equality)
 
* `!=` (inequality)
 
The operators `||` and `&&` apply the common short-circuiting rules. This means that in the expression `f(x) || g(y)`, if `f(x)` evaluates to `true`, `g(y)` will not be evaluated even if it may have side-effects.
### Integers[](#integers "Link to this heading")
`int` / `uint`: Signed and unsigned integers of various sizes. Keywords `uint8` to `uint256` in steps of `8` (unsigned of 8 up to 256 bits) and `int8` to `int256`. `uint` and `int` are aliases for `uint256` and `int256`, respectively.
Operators:
* Comparisons: `<=`, `<`, `==`, `!=`, `>=`, `>` (evaluate to `bool`)
 
* Bit operators: `&`, `|`, `^` (bitwise exclusive or), `~` (bitwise negation)
 
* Shift operators: `<<` (left shift), `>>` (right shift)
 
* Arithmetic operators: `+`, `-`, unary `-` (only for signed integers), `*`, `/`, `%` (modulo), `**` (exponentiation)
 
For an integer type `X`, you can use `type(X).min` and `type(X).max` to access the minimum and maximum value representable by the type.
Warning
Integers in Solidity are restricted to a certain range. For example, with `uint32`, this is `0` up to `2**32 - 1`. There are two modes in which arithmetic is performed on these types: The “wrapping” or “unchecked” mode and the “checked” mode. By default, arithmetic is always “checked”, meaning that if an operation’s result falls outside the value range of the type, the call is reverted through a [failing assertion](https://docs.soliditylang.org/en/latest/control-structures.html#assert-and-require). You can switch to “unchecked” mode using `unchecked { ... }`. More details can be found in the section about [unchecked](https://docs.soliditylang.org/en/latest/control-structures.html#unchecked).
#### Comparisons[](#comparisons "Link to this heading")
The value of a comparison is the one obtained by comparing the integer value.
#### Bit operations[](#bit-operations "Link to this heading")
Bit operations are performed on the two’s complement representation of the number. This means that, for example `~int256(0) == int256(-1)`.
#### Shifts[](#shifts "Link to this heading")
The result of a shift operation has the type of the left operand, truncating the result to match the type. The right operand must be of unsigned type, trying to shift by a signed type will produce a compilation error.
Shifts can be “simulated” using multiplication by powers of two in the following way. Note that the truncation to the type of the left operand is always performed at the end, but not mentioned explicitly.
* `x << y` is equivalent to the mathematical expression `x * 2**y`.
 
* `x >> y` is equivalent to the mathematical expression `x / 2**y`, rounded towards negative infinity.
 
Warning
Before version `0.5.0` a right shift `x >> y` for negative `x` was equivalent to the mathematical expression `x / 2**y` rounded towards zero, i.e., right shifts used rounding up (towards zero) instead of rounding down (towards negative infinity).
Note
Overflow checks are never performed for shift operations as they are done for arithmetic operations. Instead, the result is always truncated.
#### Addition, Subtraction and Multiplication[](#addition-subtraction-and-multiplication "Link to this heading")
Addition, subtraction and multiplication have the usual semantics, with two different modes in regard to over- and underflow:
By default, all arithmetic is checked for under- or overflow, but this can be disabled using the [unchecked block](https://docs.soliditylang.org/en/latest/control-structures.html#unchecked), resulting in wrapping arithmetic. More details can be found in that section.
The expression `-x` is equivalent to `(T(0) - x)` where `T` is the type of `x`. It can only be applied to signed types. The value of `-x` can be positive if `x` is negative. There is another caveat also resulting from two’s complement representation:
If you have `int x = type(int).min;`, then `-x` does not fit the positive range. This means that `unchecked { assert(-x == x); }` works, and the expression `-x` when used in checked mode will result in a failing assertion.
#### Division[](#division "Link to this heading")
Since the type of the result of an operation is always the type of one of the operands, division on integers always results in an integer. In Solidity, division rounds towards zero. This means that `int256(-5) / int256(2) == int256(-2)`.
Note that in contrast, division on [literals](#rational-literals) results in fractional values of arbitrary precision.
Note
Division by zero causes a [Panic error](https://docs.soliditylang.org/en/latest/control-structures.html#assert-and-require). This check can **not** be disabled through `unchecked { ... }`.
Note
The expression `type(int).min / (-1)` is the only case where division causes an overflow. In checked arithmetic mode, this will cause a failing assertion, while in wrapping mode, the value will be `type(int).min`.
#### Modulo[](#modulo "Link to this heading")
The modulo operation `a % n` yields the remainder `r` after the division of the operand `a` by the operand `n`, where `q = int(a / n)` and `r = a - (n * q)`. This means that modulo results in the same sign as its left operand (or zero) and `a % n == -(-a % n)` holds for negative `a`:
* `int256(5) % int256(2) == int256(1)`
 
* `int256(5) % int256(-2) == int256(1)`
 
* `int256(-5) % int256(2) == int256(-1)`
 
* `int256(-5) % int256(-2) == int256(-1)`
 
Note
Modulo with zero causes a [Panic error](https://docs.soliditylang.org/en/latest/control-structures.html#assert-and-require). This check can **not** be disabled through `unchecked { ... }`.
#### Exponentiation[](#exponentiation "Link to this heading")
Exponentiation is only available for unsigned types in the exponent. The resulting type of an exponentiation is always equal to the type of the base. Please take care that it is large enough to hold the result and prepare for potential assertion failures or wrapping behavior.
Note
In checked mode, exponentiation only uses the comparatively cheap `exp` opcode for small bases. For the cases of `x**3`, the expression `x*x*x` might be cheaper. In any case, gas cost tests and the use of the optimizer are advisable.
Note
Note that `0**0` is defined by the EVM as `1`.
### Fixed Point Numbers[](#fixed-point-numbers "Link to this heading")
Warning
Fixed point numbers are not fully supported by Solidity yet. They can be declared, but cannot be assigned to or from.
`fixed` / `ufixed`: Signed and unsigned fixed point number of various sizes. Keywords `ufixedMxN` and `fixedMxN`, where `M` represents the number of bits taken by the type and `N` represents how many decimal points are available. `M` must be divisible by 8 and goes from 8 to 256 bits. `N` must be between 0 and 80, inclusive. `ufixed` and `fixed` are aliases for `ufixed128x18` and `fixed128x18`, respectively.
Operators:
* Comparisons: `<=`, `<`, `==`, `!=`, `>=`, `>` (evaluate to `bool`)
 
* Arithmetic operators: `+`, `-`, unary `-`, `*`, `/`, `%` (modulo)
 
Note
The main difference between floating point (`float` and `double` in many languages, more precisely IEEE 754 numbers) and fixed point numbers is that the number of bits used for the integer and the fractional part (the part after the decimal dot) is flexible in the former, while it is strictly defined in the latter. Generally, in floating point almost the entire space is used to represent the number, while only a small number of bits define where the decimal point is.
### Address[](#address "Link to this heading")
The address type comes in two largely identical flavors:
* `address`: Holds a 20 byte value (size of an Ethereum address).
 
* `address payable`: Same as `address`, but with the additional members `transfer` and `send`.
 
The idea behind this distinction is that `address payable` is an address you can send Ether to, while you are not supposed to send Ether to a plain `address`, for example because it might be a smart contract that was not built to accept Ether.
Type conversions:
Implicit conversions from `address payable` to `address` are allowed, whereas conversions from `address` to `address payable` must be explicit via `payable(<address>)`.
Explicit conversions to and from `address` are allowed for `uint160`, integer literals, `bytes20` and contract types.
Only expressions of type `address` and contract type can be converted to the type `address payable` via the explicit conversion `payable(...)`. For contract-type, this conversion is only allowed if the contract can receive Ether, i.e., the contract either has a [receive](https://docs.soliditylang.org/en/latest/contracts.html#receive-ether-function) or a payable fallback function. Note that `payable(0)` is valid and is an exception to this rule.
Note
If you need a variable of type `address` and plan to send Ether to it, then declare its type as `address payable` to make this requirement visible. Also, try to make this distinction or conversion as early as possible.
The distinction between `address` and `address payable` was introduced in version 0.5.0. Also starting from that version, contracts are not implicitly convertible to the `address` type, but can still be explicitly converted to `address` or to `address payable`, if they have a receive or payable fallback function.
Operators:
* `<=`, `<`, `==`, `!=`, `>=` and `>`
 
Warning
If you convert a type that uses a larger byte size to an `address`, for example `bytes32`, then the `address` is truncated. To reduce conversion ambiguity, starting with version 0.4.24, the compiler will force you to make the truncation explicit in the conversion. Take for example the 32-byte value `0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC`.
You can use `address(uint160(bytes20(b)))`, which results in `0x111122223333444455556666777788889999aAaa`, or you can use `address(uint160(uint256(b)))`, which results in `0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc`.
Note
Mixed-case hexadecimal numbers conforming to [EIP-55](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md) are automatically treated as literals of the `address` type. See [Address Literals](#address-literals).
#### Members of Addresses[](#members-of-addresses "Link to this heading")
For a quick reference of all members of address, see [Members of Address Types](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#address-related).
* `balance` and `transfer`
 
It is possible to query the balance of an address using the property `balance` and to send Ether (in units of wei) to a payable address using the `transfer` function:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=YWRkcmVzcyBwYXlhYmxlIHggPSBwYXlhYmxlKDB4MTIzKTsKYWRkcmVzcyBteUFkZHJlc3MgPSBhZGRyZXNzKHRoaXMpOwppZiAoeC5iYWxhbmNlIDwgMTAgJiYgbXlBZGRyZXNzLmJhbGFuY2UgPj0gMTApIHgudHJhbnNmZXIoMTApOw==)
address payable x \= payable(0x123);
address myAddress \= address(this);
if (x.balance < 10 && myAddress.balance \>= 10) x.transfer(10);
The `transfer` function fails if the balance of the current contract is not large enough or if the Ether transfer is rejected by the receiving account. The `transfer` function reverts on failure.
Note
If `x` is a contract address, its code (more specifically: its [Receive Ether Function](https://docs.soliditylang.org/en/latest/contracts.html#receive-ether-function), if present, or otherwise its [Fallback Function](https://docs.soliditylang.org/en/latest/contracts.html#fallback-function), if present) will be executed together with the `transfer` call (this is a feature of the EVM and cannot be prevented). If that execution runs out of gas or fails in any way, the Ether transfer will be reverted and the current contract will stop with an exception.
* `send`
 
`send` is the low-level counterpart of `transfer`. If the execution fails, the current contract will not stop with an exception, but `send` will return `false`.
Warning
There are some dangers in using `send`: The transfer fails if the call stack depth is at 1024 (this can always be forced by the caller) and it also fails if the recipient runs out of gas. So in order to make safe Ether transfers, always check the return value of `send`, use `transfer` or even better: use a pattern where the recipient withdraws the Ether.
* `call`, `delegatecall` and `staticcall`
 
In order to interface with contracts that do not adhere to the ABI, or to get more direct control over the encoding, the functions `call`, `delegatecall` and `staticcall` are provided. They all take a single `bytes memory` parameter and return the success condition (as a `bool`) and the returned data (`bytes memory`). The functions `abi.encode`, `abi.encodePacked`, `abi.encodeWithSelector` and `abi.encodeWithSignature` can be used to encode structured data.
Example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ynl0ZXMgbWVtb3J5IHBheWxvYWQgPSBhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgicmVnaXN0ZXIoc3RyaW5nKSIsICJNeU5hbWUiKTsKKGJvb2wgc3VjY2VzcywgYnl0ZXMgbWVtb3J5IHJldHVybkRhdGEpID0gYWRkcmVzcyhuYW1lUmVnKS5jYWxsKHBheWxvYWQpOwpyZXF1aXJlKHN1Y2Nlc3MpOw==)
bytes memory payload \= abi.encodeWithSignature("register(string)", "MyName");
(bool success, bytes memory returnData) \= address(nameReg).call(payload);
require(success);
Warning
All these functions are low-level functions and should be used with care. Specifically, any unknown contract might be malicious and if you call it, you hand over control to that contract which could in turn call back into your contract, so be prepared for changes to your state variables when the call returns. The regular way to interact with other contracts is to call a function on a contract object (`x.f()`).
Note
Previous versions of Solidity allowed these functions to receive arbitrary arguments and would also handle a first argument of type `bytes4` differently. These edge cases were removed in version 0.5.0.
It is possible to adjust the supplied gas with the `gas` modifier:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse2dhczogMTAwMDAwMH0oYWJpLmVuY29kZVdpdGhTaWduYXR1cmUoInJlZ2lzdGVyKHN0cmluZykiLCAiTXlOYW1lIikpOw==)
address(nameReg).call{gas: 1000000}(abi.encodeWithSignature("register(string)", "MyName"));
Similarly, the supplied Ether value can be controlled too:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse3ZhbHVlOiAxIGV0aGVyfShhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgicmVnaXN0ZXIoc3RyaW5nKSIsICJNeU5hbWUiKSk7)
address(nameReg).call{value: 1 ether}(abi.encodeWithSignature("register(string)", "MyName"));
Lastly, these modifiers can be combined. Their order does not matter:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse2dhczogMTAwMDAwMCwgdmFsdWU6IDEgZXRoZXJ9KGFiaS5lbmNvZGVXaXRoU2lnbmF0dXJlKCJyZWdpc3RlcihzdHJpbmcpIiwgIk15TmFtZSIpKTs=)
address(nameReg).call{gas: 1000000, value: 1 ether}(abi.encodeWithSignature("register(string)", "MyName"));
In a similar way, the function `delegatecall` can be used: the difference is that only the code of the given address is used, all other aspects (storage, balance, …) are taken from the current contract. The purpose of `delegatecall` is to use library code which is stored in another contract. The user has to ensure that the layout of storage in both contracts is suitable for delegatecall to be used.
Note
Prior to homestead, only a limited variant called `callcode` was available that did not provide access to the original `msg.sender` and `msg.value` values. This function was removed in version 0.5.0.
Since byzantium `staticcall` can be used as well. This is basically the same as `call`, but will revert if the called function modifies the state in any way.
All three functions `call`, `delegatecall` and `staticcall` are very low-level functions and should only be used as a _last resort_ as they break the type-safety of Solidity.
The `gas` option is available on all three methods, while the `value` option is only available on `call`.
Note
It is best to avoid relying on hardcoded gas values in your smart contract code, regardless of whether state is read from or written to, as this can have many pitfalls. Also, access to gas might change in the future.
* `code` and `codehash`
 
You can query the deployed code for any smart contract. Use `.code` to get the EVM bytecode as a `bytes memory`, which might be empty. Use `.codehash` to get the Keccak-256 hash of that code (as a `bytes32`). Note that `addr.codehash` is cheaper than using `keccak256(addr.code)`.
Warning
The output of `addr.codehash` may be `0` if the account associated with `addr` is empty or non-existent (i.e., it has no code, zero balance, and zero nonce as defined by [EIP-161](https://eips.ethereum.org/EIPS/eip-161)). If the account has no code but a non-zero balance or nonce, then `addr.codehash` will output the Keccak-256 hash of empty data (i.e., `keccak256("")` which is equal to `c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`), as defined by [EIP-1052](https://eips.ethereum.org/EIPS/eip-1052).
Note
All contracts can be converted to `address` type, so it is possible to query the balance of the current contract using `address(this).balance`.
### Contract Types[](#contract-types "Link to this heading")
Every [contract](https://docs.soliditylang.org/en/latest/contracts.html#contracts) defines its own type. You can implicitly convert contracts to contracts they inherit from. Contracts can be explicitly converted to and from the `address` type.
Explicit conversion to and from the `address payable` type is only possible if the contract type has a receive or payable fallback function. The conversion is still performed using `address(x)`. If the contract type does not have a receive or payable fallback function, the conversion to `address payable` can be done using `payable(address(x))`. You can find more information in the section about the [address type](#address).
Note
Before version 0.5.0, contracts directly derived from the address type and there was no distinction between `address` and `address payable`.
If you declare a local variable of contract type (`MyContract c`), you can call functions on that contract. Take care to assign it from somewhere that is the same contract type.
You can also instantiate contracts (which means they are newly created). You can find more details in the [‘Contracts via new’](https://docs.soliditylang.org/en/latest/control-structures.html#creating-contracts) section.
The data representation of a contract is identical to that of the `address` type and this type is also used in the [ABI](https://docs.soliditylang.org/en/latest/abi-spec.html#abi).
Contracts do not support any operators.
The members of contract types are the external functions of the contract including any state variables marked as `public`.
For a contract `C` you can use `type(C)` to access [type information](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#meta-type) about the contract.
### Fixed-size byte arrays[](#fixed-size-byte-arrays "Link to this heading")
The value types `bytes1`, `bytes2`, `bytes3`, …, `bytes32` hold a sequence of bytes from one to up to 32.
Operators:
* Comparisons: `<=`, `<`, `==`, `!=`, `>=`, `>` (evaluate to `bool`)
 
* Bit operators: `&`, `|`, `^` (bitwise exclusive or), `~` (bitwise negation)
 
* Shift operators: `<<` (left shift), `>>` (right shift)
 
* Index access: If `x` is of type `bytesI`, then `x[k]` for `0 <= k < I` returns the `k` th byte (read-only).
 
The shifting operator works with unsigned integer type as right operand (but returns the type of the left operand), which denotes the number of bits to shift by. Shifting by a signed type will produce a compilation error.
Members:
* `.length` yields the fixed length of the byte array (read-only).
 
Note
The type `bytes1[]` is an array of bytes, but due to padding rules, it wastes 31 bytes of space for each element (except in storage). It is better to use the `bytes` type instead.
Note
Prior to version 0.8.0, `byte` used to be an alias for `bytes1`.
### Address Literals[](#address-literals "Link to this heading")
Hexadecimal literals that pass the address checksum test, for example `0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF` are of `address` type. Hexadecimal literals that are between 39 and 41 digits long and do not pass the checksum test produce an error. You can prepend (for integer types) or append (for bytesNN types) zeros to remove the error.
Note
The mixed-case address checksum format is defined in [EIP-55](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md).
### Rational and Integer Literals[](#rational-and-integer-literals "Link to this heading")
Integer literals are formed from a sequence of digits in the range 0-9. They are interpreted as decimals. For example, `69` means sixty nine. Octal literals do not exist in Solidity and leading zeros are invalid.
Decimal fractional literals are formed by a `.` with at least one number after the decimal point. Examples include `.1` and `1.3` (but not `1.`).
Scientific notation in the form of `2e10` is also supported, where the mantissa can be fractional but the exponent has to be an integer. The literal `MeE` is equivalent to `M * 10**E`. Examples include `2e10`, `-2e10`, `2e-10`, `2.5e1`.
Underscores can be used to separate the digits of a numeric literal to aid readability. For example, decimal `123_000`, hexadecimal `0x2eff_abde`, scientific decimal notation `1_2e345_678` are all valid. Underscores are only allowed between two digits and only one consecutive underscore is allowed. There is no additional semantic meaning added to a number literal containing underscores, the underscores are ignored.
Number literal expressions retain arbitrary precision until they are converted to a non-literal type (i.e. by using them together with anything other than a number literal expression (like boolean literals) or by explicit conversion). This means that computations do not overflow and divisions do not truncate in number literal expressions.
For example, `(2**800 + 1) - 2**800` results in the constant `1` (of type `uint8`) although intermediate results would not even fit the machine word size. Furthermore, `.5 * 8` results in the integer `4` (although non-integers were used in between).
Warning
While most operators produce a literal expression when applied to literals, there are certain operators that do not follow this pattern:
* Ternary operator (`... ? ... : ...`),
 
* Array subscript (`<array>[<index>]`).
 
You might expect expressions like `255 + (true ? 1 : 0)` or `255 + [1, 2, 3][0]` to be equivalent to using the literal 256 directly, but in fact they are computed within the type `uint8` and can overflow.
Any operator that can be applied to integers can also be applied to number literal expressions as long as the operands are integers. If any of the two is fractional, bit operations are disallowed and exponentiation is disallowed if the exponent is fractional (because that might result in a non-rational number).
Shifts and exponentiation with literal numbers as left (or base) operand and integer types as the right (exponent) operand are always performed in the `uint256` (for non-negative literals) or `int256` (for a negative literals) type, regardless of the type of the right (exponent) operand.
Warning
Division on integer literals used to truncate in Solidity prior to version 0.4.0, but it now converts into a rational number, i.e. `5 / 2` is not equal to `2`, but to `2.5`.
Note
Solidity has a number literal type for each rational number. Integer literals and rational number literals belong to number literal types. Moreover, all number literal expressions (i.e. the expressions that contain only number literals and operators) belong to number literal types. So the number literal expressions `1 + 2` and `2 + 1` both belong to the same number literal type for the rational number three.
Note
Number literal expressions are converted into a non-literal type as soon as they are used with non-literal expressions. Disregarding types, the value of the expression assigned to `b` below evaluates to an integer. Because `a` is of type `uint128`, the expression `2.5 + a` has to have a proper type, though. Since there is no common type for the type of `2.5` and `uint128`, the Solidity compiler does not accept this code.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=dWludDEyOCBhID0gMTsKdWludDEyOCBiID0gMi41ICsgYSArIDAuNTs=)
uint128 a \= 1;
uint128 b \= 2.5 + a + 0.5;
### String Literals and Types[](#string-literals-and-types "Link to this heading")
String literals are written with either double or single-quotes (`"foo"` or `'bar'`), and they can also be split into multiple consecutive parts (`"foo" "bar"` is equivalent to `"foobar"`) which can be helpful when dealing with long strings. They do not imply trailing zeroes as in C; `"foo"` represents three bytes, not four. As with integer literals, their type can vary, but they are implicitly convertible to `bytes1`, …, `bytes32`, if they fit, to `bytes` and to `string`.
For example, with `bytes32 samevar = "stringliteral"` the string literal is interpreted in its raw byte form when assigned to a `bytes32` type.
String literals can only contain printable ASCII characters, which means the characters between and including 0x20 .. 0x7E.
Additionally, string literals also support the following escape characters:
* `\<newline>` (escapes an actual newline)
 
* `\\` (backslash)
 
* `\'` (single quote)
 
* `\"` (double quote)
 
* `\n` (newline)
 
* `\r` (carriage return)
 
* `\t` (tab)
 
* `\xNN` (hex escape, see below)
 
* `\uNNNN` (unicode escape, see below)
 
`\xNN` takes a hex value and inserts the appropriate byte, while `\uNNNN` takes a Unicode codepoint and inserts an UTF-8 sequence.
Note
Until version 0.8.0 there were three additional escape sequences: `\b`, `\f` and `\v`. They are commonly available in other languages but rarely needed in practice. If you do need them, they can still be inserted via hexadecimal escapes, i.e. `\x08`, `\x0c` and `\x0b`, respectively, just as any other ASCII character.
The string in the following example has a length of ten bytes. It starts with a newline byte, followed by a double quote, a single quote a backslash character and then (without separator) the character sequence `abcdef`.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=IlxuXCJcJ1xcYWJjXApkZWYi)
Any Unicode line terminator which is not a newline (i.e. LF, VF, FF, CR, NEL, LS, PS) is considered to terminate the string literal. Newline only terminates the string literal if it is not preceded by a `\`.
### Unicode Literals[](#unicode-literals "Link to this heading")
While regular string literals can only contain ASCII, Unicode literals – prefixed with the keyword `unicode` – can contain any valid UTF-8 sequence. They also support the very same escape sequences as regular string literals.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=c3RyaW5nIG1lbW9yeSBhID0gdW5pY29kZSJIZWxsbyDwn5iDIjs=)
string memory a \= unicode"Hello 😃";
### Hexadecimal Literals[](#hexadecimal-literals "Link to this heading")
Hexadecimal literals are prefixed with the keyword `hex` and are enclosed in double or single-quotes (`hex"001122FF"`, `hex'0011_22_FF'`). Their content must be hexadecimal digits which can optionally use a single underscore as separator between byte boundaries. The value of the literal will be the binary representation of the hexadecimal sequence.
Multiple hexadecimal literals separated by whitespace are concatenated into a single literal: `hex"00112233" hex"44556677"` is equivalent to `hex"0011223344556677"`
Hexadecimal literals in some ways behave like [string literals](#string-literals) but are not implicitly convertible to the `string` type.
### Enums[](#enums "Link to this heading")
Enums are one way to create a user-defined type in Solidity. They are explicitly convertible to and from all integer types but implicit conversion is not allowed. The explicit conversion from integer checks at runtime that the value lies inside the range of the enum and causes a [Panic error](https://docs.soliditylang.org/en/latest/control-structures.html#assert-and-require) otherwise. Enums require at least one member, and its default value when declared is the first member. Enums cannot have more than 256 members.
The data representation is the same as for enums in C: The options are represented by subsequent unsigned integer values starting from `0`.
Using `type(NameOfEnum).min` and `type(NameOfEnum).max` you can get the smallest and respectively largest value of the given enum.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguODsKCmNvbnRyYWN0IHRlc3QgewogICAgZW51bSBBY3Rpb25DaG9pY2VzIHsgR29MZWZ0LCBHb1JpZ2h0LCBHb1N0cmFpZ2h0LCBTaXRTdGlsbCB9CiAgICBBY3Rpb25DaG9pY2VzIGNob2ljZTsKICAgIEFjdGlvbkNob2ljZXMgY29uc3RhbnQgZGVmYXVsdENob2ljZSA9IEFjdGlvbkNob2ljZXMuR29TdHJhaWdodDsKCiAgICBmdW5jdGlvbiBzZXRHb1N0cmFpZ2h0KCkgcHVibGljIHsKICAgICAgICBjaG9pY2UgPSBBY3Rpb25DaG9pY2VzLkdvU3RyYWlnaHQ7CiAgICB9CgogICAgLy8gU2luY2UgZW51bSB0eXBlcyBhcmUgbm90IHBhcnQgb2YgdGhlIEFCSSwgdGhlIHNpZ25hdHVyZSBvZiAiZ2V0Q2hvaWNlIgogICAgLy8gd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGNoYW5nZWQgdG8gImdldENob2ljZSgpIHJldHVybnMgKHVpbnQ4KSIKICAgIC8vIGZvciBhbGwgbWF0dGVycyBleHRlcm5hbCB0byBTb2xpZGl0eS4KICAgIGZ1bmN0aW9uIGdldENob2ljZSgpIHB1YmxpYyB2aWV3IHJldHVybnMgKEFjdGlvbkNob2ljZXMpIHsKICAgICAgICByZXR1cm4gY2hvaWNlOwogICAgfQoKICAgIGZ1bmN0aW9uIGdldERlZmF1bHRDaG9pY2UoKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIHVpbnQoZGVmYXVsdENob2ljZSk7CiAgICB9CgogICAgZnVuY3Rpb24gZ2V0TGFyZ2VzdFZhbHVlKCkgcHVibGljIHB1cmUgcmV0dXJucyAoQWN0aW9uQ2hvaWNlcykgewogICAgICAgIHJldHVybiB0eXBlKEFjdGlvbkNob2ljZXMpLm1heDsKICAgIH0KCiAgICBmdW5jdGlvbiBnZXRTbWFsbGVzdFZhbHVlKCkgcHVibGljIHB1cmUgcmV0dXJucyAoQWN0aW9uQ2hvaWNlcykgewogICAgICAgIHJldHVybiB0eXBlKEFjdGlvbkNob2ljZXMpLm1pbjsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.8;
contract test {
 enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }
 ActionChoices choice;
 ActionChoices constant defaultChoice \= ActionChoices.GoStraight;
 function setGoStraight() public {
 choice \= ActionChoices.GoStraight;
 }
 // Since enum types are not part of the ABI, the signature of "getChoice"
 // will automatically be changed to "getChoice() returns (uint8)"
 // for all matters external to Solidity.
 function getChoice() public view returns (ActionChoices) {
 return choice;
 }
 function getDefaultChoice() public pure returns (uint) {
 return uint(defaultChoice);
 }
 function getLargestValue() public pure returns (ActionChoices) {
 return type(ActionChoices).max;
 }
 function getSmallestValue() public pure returns (ActionChoices) {
 return type(ActionChoices).min;
 }
}
Note
Enums can also be declared on the file level, outside of contract or library definitions.
### User-defined Value Types[](#user-defined-value-types "Link to this heading")
A user-defined value type allows creating a zero cost abstraction over an elementary value type. This is similar to an alias, but with stricter type requirements.
A user-defined value type is defined using `type C is V`, where `C` is the name of the newly introduced type and `V` has to be a built-in value type (the “underlying type”). The function `C.wrap` is used to convert from the underlying type to the custom type. Similarly, the function `C.unwrap` is used to convert from the custom type to the underlying type.
The type `C` does not have any operators or attached member functions. In particular, even the operator `==` is not defined. Explicit and implicit conversions to and from other types are disallowed.
The data-representation of values of such types are inherited from the underlying type and the underlying type is also used in the ABI.
The following example illustrates a custom type `UFixed256x18` representing a decimal fixed point type with 18 decimals and a minimal library to do arithmetic operations on the type.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguODsKCi8vIFJlcHJlc2VudCBhIDE4IGRlY2ltYWwsIDI1NiBiaXQgd2lkZSBmaXhlZCBwb2ludCB0eXBlIHVzaW5nIGEgdXNlci1kZWZpbmVkIHZhbHVlIHR5cGUuCnR5cGUgVUZpeGVkMjU2eDE4IGlzIHVpbnQyNTY7CgovLy8gQSBtaW5pbWFsIGxpYnJhcnkgdG8gZG8gZml4ZWQgcG9pbnQgb3BlcmF0aW9ucyBvbiBVRml4ZWQyNTZ4MTguCmxpYnJhcnkgRml4ZWRNYXRoIHsKICAgIHVpbnQgY29uc3RhbnQgbXVsdGlwbGllciA9IDEwKioxODsKCiAgICAvLy8gQWRkcyB0d28gVUZpeGVkMjU2eDE4IG51bWJlcnMuIFJldmVydHMgb24gb3ZlcmZsb3csIHJlbHlpbmcgb24gY2hlY2tlZAogICAgLy8vIGFyaXRobWV0aWMgb24gdWludDI1Ni4KICAgIGZ1bmN0aW9uIGFkZChVRml4ZWQyNTZ4MTggYSwgVUZpeGVkMjU2eDE4IGIpIGludGVybmFsIHB1cmUgcmV0dXJucyAoVUZpeGVkMjU2eDE4KSB7CiAgICAgICAgcmV0dXJuIFVGaXhlZDI1NngxOC53cmFwKFVGaXhlZDI1NngxOC51bndyYXAoYSkgKyBVRml4ZWQyNTZ4MTgudW53cmFwKGIpKTsKICAgIH0KICAgIC8vLyBNdWx0aXBsaWVzIFVGaXhlZDI1NngxOCBhbmQgdWludDI1Ni4gUmV2ZXJ0cyBvbiBvdmVyZmxvdywgcmVseWluZyBvbiBjaGVja2VkCiAgICAvLy8gYXJpdGhtZXRpYyBvbiB1aW50MjU2LgogICAgZnVuY3Rpb24gbXVsKFVGaXhlZDI1NngxOCBhLCB1aW50MjU2IGIpIGludGVybmFsIHB1cmUgcmV0dXJucyAoVUZpeGVkMjU2eDE4KSB7CiAgICAgICAgcmV0dXJuIFVGaXhlZDI1NngxOC53cmFwKFVGaXhlZDI1NngxOC51bndyYXAoYSkgKiBiKTsKICAgIH0KICAgIC8vLyBUYWtlIHRoZSBmbG9vciBvZiBhIFVGaXhlZDI1NngxOCBudW1iZXIuCiAgICAvLy8gQHJldHVybiB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHRoYXQgZG9lcyBub3QgZXhjZWVkIGBhYC4KICAgIGZ1bmN0aW9uIGZsb29yKFVGaXhlZDI1NngxOCBhKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnQyNTYpIHsKICAgICAgICByZXR1cm4gVUZpeGVkMjU2eDE4LnVud3JhcChhKSAvIG11bHRpcGxpZXI7CiAgICB9CiAgICAvLy8gVHVybnMgYSB1aW50MjU2IGludG8gYSBVRml4ZWQyNTZ4MTggb2YgdGhlIHNhbWUgdmFsdWUuCiAgICAvLy8gUmV2ZXJ0cyBpZiB0aGUgaW50ZWdlciBpcyB0b28gbGFyZ2UuCiAgICBmdW5jdGlvbiB0b1VGaXhlZDI1NngxOCh1aW50MjU2IGEpIGludGVybmFsIHB1cmUgcmV0dXJucyAoVUZpeGVkMjU2eDE4KSB7CiAgICAgICAgcmV0dXJuIFVGaXhlZDI1NngxOC53cmFwKGEgKiBtdWx0aXBsaWVyKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.8;
// Represent a 18 decimal, 256 bit wide fixed point type using a user-defined value type.
type UFixed256x18 is uint256;
/// A minimal library to do fixed point operations on UFixed256x18.
library FixedMath {
 uint constant multiplier \= 10\*\*18;
 /// Adds two UFixed256x18 numbers. Reverts on overflow, relying on checked
 /// arithmetic on uint256.
 function add(UFixed256x18 a, UFixed256x18 b) internal pure returns (UFixed256x18) {
 return UFixed256x18.wrap(UFixed256x18.unwrap(a) + UFixed256x18.unwrap(b));
 }
 /// Multiplies UFixed256x18 and uint256. Reverts on overflow, relying on checked
 /// arithmetic on uint256.
 function mul(UFixed256x18 a, uint256 b) internal pure returns (UFixed256x18) {
 return UFixed256x18.wrap(UFixed256x18.unwrap(a) \* b);
 }
 /// Take the floor of a UFixed256x18 number.
 /// @return the largest integer that does not exceed \`a\`.
 function floor(UFixed256x18 a) internal pure returns (uint256) {
 return UFixed256x18.unwrap(a) / multiplier;
 }
 /// Turns a uint256 into a UFixed256x18 of the same value.
 /// Reverts if the integer is too large.
 function toUFixed256x18(uint256 a) internal pure returns (UFixed256x18) {
 return UFixed256x18.wrap(a \* multiplier);
 }
}
Notice how `UFixed256x18.wrap` and `FixedMath.toUFixed256x18` have the same signature but perform two very different operations: The `UFixed256x18.wrap` function returns a `UFixed256x18` that has the same data representation as the input, whereas `toUFixed256x18` returns a `UFixed256x18` that has the same numerical value.
### Function Types[](#function-types "Link to this heading")
Function types are the types of functions. Variables of a function type can be assigned from functions and function parameters of function type can be used to pass functions to and return functions from function calls. Function types come in two flavours - _internal_ and _external_ functions:
Internal functions can only be called inside the current contract (more specifically, inside the current code unit, which also includes internal library functions and inherited functions) because they cannot be executed outside of the context of the current contract. Calling an internal function is realized by jumping to its entry label, just like when calling a function of the current contract internally.
External functions consist of an address and a function signature and they can be passed via and returned from external function calls.
Note that public functions of the current contract can be used both as an internal and as an external function. To use `f` as an internal function, just use `f`, if you want to use its external form, use `this.f`.
If a function type variable is not initialised, calling it results in a [Panic error](https://docs.soliditylang.org/en/latest/control-structures.html#assert-and-require). The same happens if you call a function after using `delete` on it.
Note
Lambda or inline functions are planned but not yet supported.
#### Declaration syntax[](#declaration-syntax "Link to this heading")
Function types are notated as follows:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=ZnVuY3Rpb24gKDxwYXJhbWV0ZXIgdHlwZXM+KSB7aW50ZXJuYWx8ZXh0ZXJuYWx9IFtwdXJlfHZpZXd8cGF5YWJsZV0gW3JldHVybnMgKDxyZXR1cm4gdHlwZXM+KV0=)
function (<parameter types\>) {internal|external} \[pure|view|payable\] \[returns (<return types\>)\]
In contrast to the parameter types, the return types cannot be empty - if the function type should not return anything, the whole `returns (<return types>)` part has to be omitted.
By default, function types are internal, so the `internal` keyword can be omitted. Note that this only applies to function types. Visibility has to be specified explicitly for functions defined in contracts, they do not have a default.
#### Conversions[](#conversions "Link to this heading")
A function type `A` is implicitly convertible to a function type `B` if and only if their parameter types are identical, their return types are identical, their internal/external property is identical and the state mutability of `A` is more restrictive than the state mutability of `B`. In particular:
* `pure` functions can be converted to `view` and `non-payable` functions
 
* `view` functions can be converted to `non-payable` functions
 
* `payable` functions can be converted to `non-payable` functions
 
No other conversions between function types are possible.
The rule about `payable` and `non-payable` might be a little confusing, but in essence, if a function is `payable`, this means that it also accepts a payment of zero Ether, so it also is `non-payable`. On the other hand, a `non-payable` function will reject Ether sent to it, so `non-payable` functions cannot be converted to `payable` functions. To clarify, rejecting ether is more restrictive than not rejecting ether. This means you can override a payable function with a non-payable but not the other way around.
Additionally, When you define a `non-payable` function pointer, the compiler does not enforce that the pointed function will actually reject ether. Instead, it enforces that the function pointer is never used to send ether. Which makes it possible to assign a `payable` function pointer to a `non-payable` function pointer ensuring both types behave the same way, i.e, both cannot be used to send ether.
If external function types are used outside of the context of Solidity, they are treated as the `function` type, which encodes the address followed by the function identifier together in a single `bytes24` type.
A function of an internal type can be assigned to a variable of an internal function type regardless of where it is defined. This includes private, internal and public functions of both contracts and libraries as well as free functions. External function types, on the other hand, are only compatible with public and external contract functions.
Note
External functions with `calldata` parameters are incompatible with external function types with `calldata` parameters. They are compatible with the corresponding types with `memory` parameters instead. For example, there is no function that can be pointed at by a value of type `function (string calldata) external` while `function (string memory) external` can point at both `function f(string memory) external {}` and `function g(string calldata) external {}`. This is because for both locations the arguments are passed to the function in the same way. The caller cannot pass its calldata directly to an external function and always ABI-encodes the arguments into memory. Marking the parameters as `calldata` only affects the implementation of the external function and is meaningless in a function pointer on the caller’s side.
Warning
Comparison of internal function pointers can have unexpected results in the legacy pipeline with the optimizer enabled, as it can collapse identical functions into one, which will then lead to said function pointers comparing as equal instead of not. Such comparisons are not advised, and will lead to the compiler issuing a warning, until the next breaking release (0.9.0), when the warning will be upgraded to an error, thereby making such comparisons disallowed.
Libraries are excluded because they require a `delegatecall` and use [a different ABI convention for their selectors](https://docs.soliditylang.org/en/latest/contracts.html#library-selectors). Functions declared in interfaces do not have definitions so pointing at them does not make sense either.
#### Members[](#members "Link to this heading")
External (or public) functions have the following members:
* `.address` returns the address of the contract of the function.
 
* `.selector` returns the [ABI function selector](https://docs.soliditylang.org/en/latest/abi-spec.html#abi-function-selector)
 
Note
External (or public) functions used to have the additional members `.gas(uint)` and `.value(uint)`. These were deprecated in Solidity 0.6.2 and removed in Solidity 0.7.0. Instead use `{gas: ...}` and `{value: ...}` to specify the amount of gas or the amount of wei sent to a function, respectively. See [External Function Calls](https://docs.soliditylang.org/en/latest/control-structures.html#external-function-calls) for more information.
#### Value stability across contract updates[](#value-stability-across-contract-updates "Link to this heading")
An important aspect to consider when using values of function types is whether the value will remain valid if the underlying code changes.
The state of the blockchain is not completely immutable and there are multiple ways to place different code under the same address:
* Directly deploying different code using [salted contract creation](https://docs.soliditylang.org/en/latest/control-structures.html#salted-contract-creations).
 
* Delegating to a different contract via [DELEGATECALL](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#delegatecall) (upgradeable code behind a proxy contract is a common example of this).
 
* Account abstraction as defined by [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702).
 
External function types can be considered as stable as contract’s ABI, which makes them very portable. Their ABI representation always consists of a contract address and a function selector and it is perfectly safe to store them long-term or pass them between contracts. While it is possible for the referenced function to change or disappear, a direct external call would be affected the same way, so there is no additional risk in such use.
In case of internal functions, however, the value is an identifier that is strongly tied to contract’s bytecode. The actual representation of the identifier is an implementation detail and may change between compiler versions or even [between different backends](https://docs.soliditylang.org/en/latest/ir-breaking-changes.html#internal-function-pointers-in-ir). Values assigned under a given representation are deterministic (i.e. guaranteed to remain the same as long as the source code is the same) but are easily affected by changes such as adding, removing or reordering of functions. The compiler is also free to remove internal functions that are never used, which may affect other identifiers. Some representations, e.g. one where identifiers are simply jump targets, may be affected by virtually any change, even one completely unrelated to internal functions.
To counter this, the language limits the use of internal function types outside of the context in which they are valid. This is why internal function types cannot be used as parameters of external functions (or in any other way that is exposed in contract’s ABI). However, there are still situations where it is up to the user to decide whether their use is safe or not. For example long-term storage of such values in state variables is discouraged, but may be safe if the contract code is never going to be updated. It is also always possible to side-step any safeguards by using inline assembly. Such use always needs careful consideration.
Note
The removal of unused internal functions only takes into account explicit references to such functions by name. Implicit references, such as assigning a new value to a function type variable in inline assembly may still lead to the removal of the function if it is not also referenced explicitly elsewhere in the source.
#### Examples[](#examples "Link to this heading")
Example that shows how to use the members:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjQgPDAuOS4wOwoKY29udHJhY3QgRXhhbXBsZSB7CiAgICBmdW5jdGlvbiBmKCkgcHVibGljIHBheWFibGUgcmV0dXJucyAoYnl0ZXM0KSB7CiAgICAgICAgYXNzZXJ0KHRoaXMuZi5hZGRyZXNzID09IGFkZHJlc3ModGhpcykpOwogICAgICAgIHJldHVybiB0aGlzLmYuc2VsZWN0b3I7CiAgICB9CgogICAgZnVuY3Rpb24gZygpIHB1YmxpYyB7CiAgICAgICAgdGhpcy5me2dhczogMTAsIHZhbHVlOiA4MDB9KCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.4 <0.9.0;
contract Example {
 function f() public payable returns (bytes4) {
 assert(this.f.address \== address(this));
 return this.f.selector;
 }
 function g() public {
 this.f{gas: 10, value: 800}();
 }
}
Example that shows how to use internal function types:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmxpYnJhcnkgQXJyYXlVdGlscyB7CiAgICAvLyBpbnRlcm5hbCBmdW5jdGlvbnMgY2FuIGJlIHVzZWQgaW4gaW50ZXJuYWwgbGlicmFyeSBmdW5jdGlvbnMgYmVjYXVzZQogICAgLy8gdGhleSB3aWxsIGJlIHBhcnQgb2YgdGhlIHNhbWUgY29kZSBjb250ZXh0CiAgICBmdW5jdGlvbiBtYXAodWludFtdIG1lbW9yeSBzZWxmLCBmdW5jdGlvbiAodWludCkgcHVyZSByZXR1cm5zICh1aW50KSBmKQogICAgICAgIGludGVybmFsCiAgICAgICAgcHVyZQogICAgICAgIHJldHVybnMgKHVpbnRbXSBtZW1vcnkgcikKICAgIHsKICAgICAgICByID0gbmV3IHVpbnRbXShzZWxmLmxlbmd0aCk7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykgewogICAgICAgICAgICByW2ldID0gZihzZWxmW2ldKTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gcmVkdWNlKAogICAgICAgIHVpbnRbXSBtZW1vcnkgc2VsZiwKICAgICAgICBmdW5jdGlvbiAodWludCwgdWludCkgcHVyZSByZXR1cm5zICh1aW50KSBmCiAgICApCiAgICAgICAgaW50ZXJuYWwKICAgICAgICBwdXJlCiAgICAgICAgcmV0dXJucyAodWludCByKQogICAgewogICAgICAgIHIgPSBzZWxmWzBdOwogICAgICAgIGZvciAodWludCBpID0gMTsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgciA9IGYociwgc2VsZltpXSk7CiAgICAgICAgfQogICAgfQoKICAgIGZ1bmN0aW9uIHJhbmdlKHVpbnQgbGVuZ3RoKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnRbXSBtZW1vcnkgcikgewogICAgICAgIHIgPSBuZXcgdWludFtdKGxlbmd0aCk7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgci5sZW5ndGg7IGkrKykgewogICAgICAgICAgICByW2ldID0gaTsKICAgICAgICB9CiAgICB9Cn0KCgpjb250cmFjdCBQeXJhbWlkIHsKICAgIHVzaW5nIEFycmF5VXRpbHMgZm9yICo7CgogICAgZnVuY3Rpb24gcHlyYW1pZCh1aW50IGwpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4gQXJyYXlVdGlscy5yYW5nZShsKS5tYXAoc3F1YXJlKS5yZWR1Y2Uoc3VtKTsKICAgIH0KCiAgICBmdW5jdGlvbiBzcXVhcmUodWludCB4KSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4geCAqIHg7CiAgICB9CgogICAgZnVuY3Rpb24gc3VtKHVpbnQgeCwgdWludCB5KSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4geCArIHk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
library ArrayUtils {
 // internal functions can be used in internal library functions because
 // they will be part of the same code context
 function map(uint\[\] memory self, function (uint) pure returns (uint) f)
 internal
 pure
 returns (uint\[\] memory r)
 {
 r \= new uint\[\](self.length);
 for (uint i \= 0; i < self.length; i++) {
 r\[i\] \= f(self\[i\]);
 }
 }
 function reduce(
 uint\[\] memory self,
 function (uint, uint) pure returns (uint) f
 )
 internal
 pure
 returns (uint r)
 {
 r \= self\[0\];
 for (uint i \= 1; i < self.length; i++) {
 r \= f(r, self\[i\]);
 }
 }
 function range(uint length) internal pure returns (uint\[\] memory r) {
 r \= new uint\[\](length);
 for (uint i \= 0; i < r.length; i++) {
 r\[i\] \= i;
 }
 }
}
contract Pyramid {
 using ArrayUtils for \*;
 function pyramid(uint l) public pure returns (uint) {
 return ArrayUtils.range(l).map(square).reduce(sum);
 }
 function square(uint x) internal pure returns (uint) {
 return x \* x;
 }
 function sum(uint x, uint y) internal pure returns (uint) {
 return x + y;
 }
}
Another example that uses external function types:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCgpjb250cmFjdCBPcmFjbGUgewogICAgc3RydWN0IFJlcXVlc3QgewogICAgICAgIGJ5dGVzIGRhdGE7CiAgICAgICAgZnVuY3Rpb24odWludCkgZXh0ZXJuYWwgY2FsbGJhY2s7CiAgICB9CgogICAgUmVxdWVzdFtdIHByaXZhdGUgcmVxdWVzdHM7CiAgICBldmVudCBOZXdSZXF1ZXN0KHVpbnQpOwoKICAgIGZ1bmN0aW9uIHF1ZXJ5KGJ5dGVzIG1lbW9yeSBkYXRhLCBmdW5jdGlvbih1aW50KSBleHRlcm5hbCBjYWxsYmFjaykgcHVibGljIHsKICAgICAgICByZXF1ZXN0cy5wdXNoKFJlcXVlc3QoZGF0YSwgY2FsbGJhY2spKTsKICAgICAgICBlbWl0IE5ld1JlcXVlc3QocmVxdWVzdHMubGVuZ3RoIC0gMSk7CiAgICB9CgogICAgZnVuY3Rpb24gcmVwbHkodWludCByZXF1ZXN0SUQsIHVpbnQgcmVzcG9uc2UpIHB1YmxpYyB7CiAgICAgICAgLy8gSGVyZSBnb2VzIHRoZSBjaGVjayB0aGF0IHRoZSByZXBseSBjb21lcyBmcm9tIGEgdHJ1c3RlZCBzb3VyY2UKICAgICAgICByZXF1ZXN0c1tyZXF1ZXN0SURdLmNhbGxiYWNrKHJlc3BvbnNlKTsKICAgIH0KfQoKCmNvbnRyYWN0IE9yYWNsZVVzZXIgewogICAgT3JhY2xlIGNvbnN0YW50IHByaXZhdGUgT1JBQ0xFX0NPTlNUID0gT3JhY2xlKGFkZHJlc3MoMHgwMDAwMDAwMDIxOWFiNTQwMzU2Y0JCODM5Q2JlMDUzMDNkNzcwNUZhKSk7IC8vIGtub3duIGNvbnRyYWN0CiAgICB1aW50IHByaXZhdGUgZXhjaGFuZ2VSYXRlOwoKICAgIGZ1bmN0aW9uIGJ1eVNvbWV0aGluZygpIHB1YmxpYyB7CiAgICAgICAgT1JBQ0xFX0NPTlNULnF1ZXJ5KCJVU0QiLCB0aGlzLm9yYWNsZVJlc3BvbnNlKTsKICAgIH0KCiAgICBmdW5jdGlvbiBvcmFjbGVSZXNwb25zZSh1aW50IHJlc3BvbnNlKSBwdWJsaWMgewogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgIG1zZy5zZW5kZXIgPT0gYWRkcmVzcyhPUkFDTEVfQ09OU1QpLAogICAgICAgICAgICAiT25seSBvcmFjbGUgY2FuIGNhbGwgdGhpcy4iCiAgICAgICAgKTsKICAgICAgICBleGNoYW5nZVJhdGUgPSByZXNwb25zZTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.22 <0.9.0;
contract Oracle {
 struct Request {
 bytes data;
 function(uint) external callback;
 }
 Request\[\] private requests;
 event NewRequest(uint);
 function query(bytes memory data, function(uint) external callback) public {
 requests.push(Request(data, callback));
 emit NewRequest(requests.length \- 1);
 }
 function reply(uint requestID, uint response) public {
 // Here goes the check that the reply comes from a trusted source
 requests\[requestID\].callback(response);
 }
}
contract OracleUser {
 Oracle constant private ORACLE\_CONST \= Oracle(address(0x00000000219ab540356cBB839Cbe05303d7705Fa)); // known contract
 uint private exchangeRate;
 function buySomething() public {
 ORACLE\_CONST.query("USD", this.oracleResponse);
 }
 function oracleResponse(uint response) public {
 require(
 msg.sender \== address(ORACLE\_CONST),
 "Only oracle can call this."
 );
 exchangeRate \= response;
 }
}
## Reference Types[](#reference-types "Link to this heading")
Values of reference type can be modified through multiple different names. Contrast this with value types where you get an independent copy whenever a variable of value type is used. Because of that, reference types have to be handled more carefully than value types. Currently, reference types comprise structs, arrays and mappings. If you use a reference type, you always have to explicitly provide the data area where the type is stored: `memory` (whose lifetime is limited to an external function call), `storage` (the location where the state variables are stored, where the lifetime is limited to the lifetime of a contract) or `calldata` (special data location that contains the function arguments).
An assignment or type conversion that changes the data location will always incur an automatic copy operation, while assignments inside the same data location only copy in some cases for storage types.
### Data location[](#data-location "Link to this heading")
Every reference type has an additional annotation, the “data location”, about where it is stored. There are three data locations: `memory`, `storage` and `calldata`. Calldata is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.
Note
`transient` is not yet supported as a data location for reference types.
Note
If you can, try to use `calldata` as data location because it will avoid copies and also makes sure that the data cannot be modified. Arrays and structs with `calldata` data location can also be returned from functions, but it is not possible to allocate such types.
Note
Arrays and structs with `calldata` location declared in a function body or as its return parameters must be assigned before being used or returned. There are certain cases in which non-trivial control flow is used and the compiler can’t properly detect the initialization. A common workaround in such cases is to assign the affected variable to itself before the correct initialization takes place.
Note
Prior to version 0.6.9 data location for reference-type arguments was limited to `calldata` in external functions, `memory` in public functions and either `memory` or `storage` in internal and private ones. Now `memory` and `calldata` are allowed in all functions regardless of their visibility.
Note
Constructor parameters cannot use `calldata` as their data location.
Note
Prior to version 0.5.0 the data location could be omitted, and would default to different locations depending on the kind of variable, function type, etc., but all complex types must now give an explicit data location.
#### Data location and assignment behavior[](#data-location-and-assignment-behavior "Link to this heading")
Data locations are not only relevant for persistency of data, but also for the semantics of assignments:
* Assignments between `storage` and `memory` (or from `calldata`) always create an independent copy.
 
* Assignments from `memory` to `memory` only create references. This means that changes to one memory variable are also visible in all other memory variables that refer to the same data.
 
* Assignments from `storage` to a **local** storage variable also only assign a reference.
 
* All other assignments to `storage` always copy. Examples for this case are assignments to state variables or to members of local variables of storage struct type, even if the local variable itself is just a reference.
 
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICAvLyBUaGUgZGF0YSBsb2NhdGlvbiBvZiB4IGlzIHN0b3JhZ2UuCiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHBsYWNlIHdoZXJlIHRoZQogICAgLy8gZGF0YSBsb2NhdGlvbiBjYW4gYmUgb21pdHRlZC4KICAgIHVpbnRbXSB4OwoKICAgIC8vIFRoZSBkYXRhIGxvY2F0aW9uIG9mIG1lbW9yeUFycmF5IGlzIG1lbW9yeS4KICAgIGZ1bmN0aW9uIGYodWludFtdIG1lbW9yeSBtZW1vcnlBcnJheSkgcHVibGljIHsKICAgICAgICB4ID0gbWVtb3J5QXJyYXk7IC8vIHdvcmtzLCBjb3BpZXMgdGhlIHdob2xlIGFycmF5IHRvIHN0b3JhZ2UKICAgICAgICB1aW50W10gc3RvcmFnZSB5ID0geDsgLy8gd29ya3MsIGFzc2lnbnMgYSBwb2ludGVyLCBkYXRhIGxvY2F0aW9uIG9mIHkgaXMgc3RvcmFnZQogICAgICAgIHlbN107IC8vIGZpbmUsIHJldHVybnMgdGhlIDh0aCBlbGVtZW50CiAgICAgICAgeS5wb3AoKTsgLy8gZmluZSwgbW9kaWZpZXMgeCB0aHJvdWdoIHkKICAgICAgICBkZWxldGUgeDsgLy8gZmluZSwgY2xlYXJzIHRoZSBhcnJheSwgYWxzbyBtb2RpZmllcyB5CiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBkb2VzIG5vdCB3b3JrOyBpdCB3b3VsZCBuZWVkIHRvIGNyZWF0ZSBhIG5ldyB0ZW1wb3JhcnkgLwogICAgICAgIC8vIHVubmFtZWQgYXJyYXkgaW4gc3RvcmFnZSwgYnV0IHN0b3JhZ2UgaXMgInN0YXRpY2FsbHkiIGFsbG9jYXRlZDoKICAgICAgICAvLyB5ID0gbWVtb3J5QXJyYXk7CiAgICAgICAgLy8gU2ltaWxhcmx5LCAiZGVsZXRlIHkiIGlzIG5vdCB2YWxpZCwgYXMgYXNzaWdubWVudHMgdG8gbG9jYWwgdmFyaWFibGVzCiAgICAgICAgLy8gcmVmZXJlbmNpbmcgc3RvcmFnZSBvYmplY3RzIGNhbiBvbmx5IGJlIG1hZGUgZnJvbSBleGlzdGluZyBzdG9yYWdlIG9iamVjdHMuCiAgICAgICAgLy8gSXQgd291bGQgInJlc2V0IiB0aGUgcG9pbnRlciwgYnV0IHRoZXJlIGlzIG5vIHNlbnNpYmxlIGxvY2F0aW9uIGl0IGNvdWxkIHBvaW50IHRvLgogICAgICAgIC8vIEZvciBtb3JlIGRldGFpbHMgc2VlIHRoZSBkb2N1bWVudGF0aW9uIG9mIHRoZSAiZGVsZXRlIiBvcGVyYXRvci4KICAgICAgICAvLyBkZWxldGUgeTsKICAgICAgICBnKHgpOyAvLyBjYWxscyBnLCBoYW5kaW5nIG92ZXIgYSByZWZlcmVuY2UgdG8geAogICAgICAgIGgoeCk7IC8vIGNhbGxzIGggYW5kIGNyZWF0ZXMgYW4gaW5kZXBlbmRlbnQsIHRlbXBvcmFyeSBjb3B5IGluIG1lbW9yeQogICAgfQoKICAgIGZ1bmN0aW9uIGcodWludFtdIHN0b3JhZ2UpIGludGVybmFsIHB1cmUge30KICAgIGZ1bmN0aW9uIGgodWludFtdIG1lbW9yeSkgcHVibGljIHB1cmUge30KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
contract C {
 // The data location of x is storage.
 // This is the only place where the
 // data location can be omitted.
 uint\[\] x;
 // The data location of memoryArray is memory.
 function f(uint\[\] memory memoryArray) public {
 x \= memoryArray; // works, copies the whole array to storage
 uint\[\] storage y \= x; // works, assigns a pointer, data location of y is storage
 y\[7\]; // fine, returns the 8th element
 y.pop(); // fine, modifies x through y
 delete x; // fine, clears the array, also modifies y
 // The following does not work; it would need to create a new temporary /
 // unnamed array in storage, but storage is "statically" allocated:
 // y = memoryArray;
 // Similarly, "delete y" is not valid, as assignments to local variables
 // referencing storage objects can only be made from existing storage objects.
 // It would "reset" the pointer, but there is no sensible location it could point to.
 // For more details see the documentation of the "delete" operator.
 // delete y;
 g(x); // calls g, handing over a reference to x
 h(x); // calls h and creates an independent, temporary copy in memory
 }
 function g(uint\[\] storage) internal pure {}
 function h(uint\[\] memory) public pure {}
}
### Arrays[](#arrays "Link to this heading")
Arrays can have a compile-time fixed size, or they can have a dynamic size.
The type of an array of fixed size `k` and element type `T` is written as `T[k]`, and an array of dynamic size as `T[]`.
For example, an array of 5 dynamic arrays of `uint` is written as `uint[][5]`. The notation is reversed compared to some other languages. In Solidity, `X[3]` is always an array containing three elements of type `X`, even if `X` is itself an array. This is not the case in other languages such as C.
Indices are zero-based, and access is in the opposite direction of the declaration.
For example, if you have a variable `uint[][5] memory x`, you access the seventh `uint` in the third dynamic array using `x[2][6]`, and to access the third dynamic array, use `x[2]`. Again, if you have an array `T[5] a` for a type `T` that can also be an array, then `a[2]` always has type `T`.
Array elements can be of any type, including mapping or struct. The general restrictions for types apply, in that mappings can only be stored in the `storage` data location and publicly-visible functions need parameters that are [ABI types](https://docs.soliditylang.org/en/latest/abi-spec.html#abi).
It is possible to mark state variable arrays `public` and have Solidity create a [getter](https://docs.soliditylang.org/en/latest/contracts.html#visibility-and-getters). The numeric index becomes a required parameter for the getter.
Accessing an array past its end causes a failing assertion. Methods `.push()` and `.push(value)` can be used to append a new element at the end of a dynamically-sized array, where `.push()` appends a zero-initialized element and returns a reference to it.
Note
Dynamically-sized arrays can only be resized in storage. In memory, such arrays can be of arbitrary size but the size cannot be changed once an array is allocated.
#### `bytes` and `string` as Arrays[](#bytes-and-string-as-arrays "Link to this heading")
Variables of type `bytes` and `string` are special arrays. The `bytes` type is similar to `bytes1[]`, but it is packed tightly in calldata and memory. `string` is equal to `bytes` but does not allow length or index access.
Solidity does not have string manipulation functions, but there are third-party string libraries. You can also compare two strings by their keccak256-hash using `keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))` and concatenate two strings using `string.concat(s1, s2)`.
You should use `bytes` over `bytes1[]` because it is cheaper, since using `bytes1[]` in `memory` adds 31 padding bytes between the elements. Note that in `storage`, the padding is absent due to tight packing, see [bytes and string](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#bytes-and-string). As a general rule, use `bytes` for arbitrary-length raw byte data and `string` for arbitrary-length string (UTF-8) data. If you can limit the length to a certain number of bytes, always use one of the value types `bytes1` to `bytes32` because they are much cheaper.
Note
If you want to access the byte-representation of a string `s`, use `bytes(s).length` / `bytes(s)[7] = 'x';`. Keep in mind that you are accessing the low-level bytes of the UTF-8 representation, and not the individual characters.
#### The functions `bytes.concat` and `string.concat`[](#the-functions-bytes-concat-and-string-concat "Link to this heading")
You can concatenate an arbitrary number of `string` values using `string.concat`. The function returns a single `string memory` array that contains the contents of the arguments without padding. If you want to use parameters of other types that are not implicitly convertible to `string`, you need to convert them to `string` first.
Analogously, the `bytes.concat` function can concatenate an arbitrary number of `bytes` or `bytes1 ... bytes32` values. The function returns a single `bytes memory` array that contains the contents of the arguments without padding. If you want to use string parameters or other types that are not implicitly convertible to `bytes`, you need to convert them to `bytes` or `bytes1`/…/`bytes32` first.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTI7Cgpjb250cmFjdCBDIHsKICAgIHN0cmluZyBzID0gIlN0b3JhZ2UiOwogICAgZnVuY3Rpb24gZihieXRlcyBjYWxsZGF0YSBiYywgc3RyaW5nIG1lbW9yeSBzbSwgYnl0ZXMxNiBiKSBwdWJsaWMgdmlldyB7CiAgICAgICAgc3RyaW5nIG1lbW9yeSBjb25jYXRTdHJpbmcgPSBzdHJpbmcuY29uY2F0KHMsIHN0cmluZyhiYyksICJMaXRlcmFsIiwgc20pOwogICAgICAgIGFzc2VydCgoYnl0ZXMocykubGVuZ3RoICsgYmMubGVuZ3RoICsgNyArIGJ5dGVzKHNtKS5sZW5ndGgpID09IGJ5dGVzKGNvbmNhdFN0cmluZykubGVuZ3RoKTsKCiAgICAgICAgYnl0ZXMgbWVtb3J5IGNvbmNhdEJ5dGVzID0gYnl0ZXMuY29uY2F0KGJ5dGVzKHMpLCBiYywgYmNbOjJdLCAiTGl0ZXJhbCIsIGJ5dGVzKHNtKSwgYik7CiAgICAgICAgYXNzZXJ0KChieXRlcyhzKS5sZW5ndGggKyBiYy5sZW5ndGggKyAyICsgNyArIGJ5dGVzKHNtKS5sZW5ndGggKyBiLmxlbmd0aCkgPT0gY29uY2F0Qnl0ZXMubGVuZ3RoKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.12;
contract C {
 string s \= "Storage";
 function f(bytes calldata bc, string memory sm, bytes16 b) public view {
 string memory concatString \= string.concat(s, string(bc), "Literal", sm);
 assert((bytes(s).length + bc.length + 7 + bytes(sm).length) \== bytes(concatString).length);
 bytes memory concatBytes \= bytes.concat(bytes(s), bc, bc\[:2\], "Literal", bytes(sm), b);
 assert((bytes(s).length + bc.length + 2 + 7 + bytes(sm).length + b.length) \== concatBytes.length);
 }
}
If you call `string.concat` or `bytes.concat` without arguments they return an empty array.
#### Allocating Memory Arrays[](#allocating-memory-arrays "Link to this heading")
Memory arrays with dynamic length can be created using the `new` operator. As opposed to storage arrays, it is **not** possible to resize memory arrays (e.g. the `.push` member functions are not available). You either have to calculate the required size in advance or create a new memory array and copy every element.
As all variables in Solidity, the elements of newly allocated arrays are always initialized with the [default value](https://docs.soliditylang.org/en/latest/control-structures.html#default-value).
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50IGxlbikgcHVibGljIHB1cmUgewogICAgICAgIHVpbnRbXSBtZW1vcnkgYSA9IG5ldyB1aW50W10oNyk7CiAgICAgICAgYnl0ZXMgbWVtb3J5IGIgPSBuZXcgYnl0ZXMobGVuKTsKICAgICAgICBhc3NlcnQoYS5sZW5ndGggPT0gNyk7CiAgICAgICAgYXNzZXJ0KGIubGVuZ3RoID09IGxlbik7CiAgICAgICAgYVs2XSA9IDg7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 function f(uint len) public pure {
 uint\[\] memory a \= new uint\[\](7);
 bytes memory b \= new bytes(len);
 assert(a.length \== 7);
 assert(b.length \== len);
 a\[6\] \= 8;
 }
}
#### Array Literals[](#array-literals "Link to this heading")
An array literal is a comma-separated list of one or more expressions, enclosed in square brackets (`[...]`). For example `[1, a, f(3)]`. The type of the array literal is determined as follows:
It is always a statically-sized memory array whose length is the number of expressions.
The base type of the array is the type of the first expression on the list such that all other expressions can be implicitly converted to it. It is a type error if this is not possible.
It is not enough that there is a type all the elements can be converted to. One of the elements has to be of that type.
In the example below, the type of `[1, 2, 3]` is `uint8[3] memory`, because the type of each of these constants is `uint8`. If you want the result to be a `uint[3] memory` type, you need to convert the first element to `uint`.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHsKICAgICAgICBnKFt1aW50KDEpLCAyLCAzXSk7CiAgICB9CiAgICBmdW5jdGlvbiBnKHVpbnRbM10gbWVtb3J5KSBwdWJsaWMgcHVyZSB7CiAgICAgICAgLy8gLi4uCiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 function f() public pure {
 g(\[uint(1), 2, 3\]);
 }
 function g(uint\[3\] memory) public pure {
 // ...
 }
}
The array literal `[1, -1]` is invalid because the type of the first expression is `uint8` while the type of the second is `int8` and they cannot be implicitly converted to each other. To make it work, you can use `[int8(1), -1]`, for example.
Since fixed-size memory arrays of different type cannot be converted into each other (even if the base types can), you always have to specify a common base type explicitly if you want to use two-dimensional array literals:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQyNFsyXVs0XSBtZW1vcnkpIHsKICAgICAgICB1aW50MjRbMl1bNF0gbWVtb3J5IHggPSBbW3VpbnQyNCgweDEpLCAxXSwgWzB4ZmZmZmZmLCAyXSwgW3VpbnQyNCgweGZmKSwgM10sIFt1aW50MjQoMHhmZmZmKSwgNF1dOwogICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgZG9lcyBub3Qgd29yaywgYmVjYXVzZSBzb21lIG9mIHRoZSBpbm5lciBhcnJheXMgYXJlIG5vdCBvZiB0aGUgcmlnaHQgdHlwZS4KICAgICAgICAvLyB1aW50WzJdWzRdIG1lbW9yeSB4ID0gW1sweDEsIDFdLCBbMHhmZmZmZmYsIDJdLCBbMHhmZiwgM10sIFsweGZmZmYsIDRdXTsKICAgICAgICByZXR1cm4geDsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 function f() public pure returns (uint24\[2\]\[4\] memory) {
 uint24\[2\]\[4\] memory x \= \[\[uint24(0x1), 1\], \[0xffffff, 2\], \[uint24(0xff), 3\], \[uint24(0xffff), 4\]\];
 // The following does not work, because some of the inner arrays are not of the right type.
 // uint\[2\]\[4\] memory x = \[\[0x1, 1\], \[0xffffff, 2\], \[0xff, 3\], \[0xffff, 4\]\];
 return x;
 }
}
Fixed size memory arrays cannot be assigned to dynamically-sized memory arrays, i.e. the following is not possible:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKLy8gVGhpcyB3aWxsIG5vdCBjb21waWxlLgpjb250cmFjdCBDIHsKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIC8vIFRoZSBuZXh0IGxpbmUgY3JlYXRlcyBhIHR5cGUgZXJyb3IgYmVjYXVzZSB1aW50WzNdIG1lbW9yeQogICAgICAgIC8vIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gdWludFtdIG1lbW9yeS4KICAgICAgICB1aW50W10gbWVtb3J5IHggPSBbdWludCgxKSwgMywgNF07CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
// This will not compile.
contract C {
 function f() public {
 // The next line creates a type error because uint\[3\] memory
 // cannot be converted to uint\[\] memory.
 uint\[\] memory x \= \[uint(1), 3, 4\];
 }
}
It is planned to remove this restriction in the future, but it creates some complications because of how arrays are passed in the ABI.
If you want to initialize dynamically-sized arrays, you have to assign the individual elements:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHsKICAgICAgICB1aW50W10gbWVtb3J5IHggPSBuZXcgdWludFtdKDMpOwogICAgICAgIHhbMF0gPSAxOwogICAgICAgIHhbMV0gPSAzOwogICAgICAgIHhbMl0gPSA0OwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 function f() public pure {
 uint\[\] memory x \= new uint\[\](3);
 x\[0\] \= 1;
 x\[1\] \= 3;
 x\[2\] \= 4;
 }
}
#### Array Members[](#array-members "Link to this heading")
**length**:
Arrays have a `length` member that contains their number of elements. The length of memory arrays is fixed (but dynamic, i.e. it can depend on runtime parameters) once they are created.
**push()**:
Dynamic storage arrays and `bytes` (not `string`) have a member function called `push()` that you can use to append a zero-initialised element at the end of the array. It returns a reference to the element, so that it can be used like `x.push().t = 2` or `x.push() = b`.
**push(x)**:
Dynamic storage arrays and `bytes` (not `string`) have a member function called `push(x)` that you can use to append a given element at the end of the array. The function returns nothing.
**pop()**:
Dynamic storage arrays and `bytes` (not `string`) have a member function called `pop()` that you can use to remove an element from the end of the array. This also implicitly calls [delete](#delete) on the removed element. The function returns nothing.
Note
Increasing the length of a storage array by calling `push()` has constant gas costs because storage is zero-initialised, while decreasing the length by calling `pop()` has a cost that depends on the “size” of the element being removed. If that element is an array, it can be very costly, because it includes explicitly clearing the removed elements similar to calling [delete](#delete) on them.
Note
To use arrays of arrays in external (instead of public) functions, you need to activate ABI coder v2.
Note
In EVM versions before Byzantium, it was not possible to access dynamic arrays returned from function calls. If you call functions that return dynamic arrays, make sure to use an EVM that is set to Byzantium mode.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQXJyYXlDb250cmFjdCB7CiAgICB1aW50WzIqKjIwXSBhTG90T2ZJbnRlZ2VyczsKICAgIC8vIE5vdGUgdGhhdCB0aGUgZm9sbG93aW5nIGlzIG5vdCBhIHBhaXIgb2YgZHluYW1pYyBhcnJheXMgYnV0IGEKICAgIC8vIGR5bmFtaWMgYXJyYXkgb2YgcGFpcnMgKGkuZS4gb2YgZml4ZWQgc2l6ZSBhcnJheXMgb2YgbGVuZ3RoIHR3bykuCiAgICAvLyBJbiBTb2xpZGl0eSwgVFtrXSBhbmQgVFtdIGFyZSBhbHdheXMgYXJyYXlzIHdpdGggZWxlbWVudHMgb2YgdHlwZSBULAogICAgLy8gZXZlbiBpZiBUIGl0c2VsZiBpcyBhbiBhcnJheS4KICAgIC8vIEJlY2F1c2Ugb2YgdGhhdCwgYm9vbFsyXVtdIGlzIGEgZHluYW1pYyBhcnJheSBvZiBlbGVtZW50cwogICAgLy8gdGhhdCBhcmUgYm9vbFsyXS4gVGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBvdGhlciBsYW5ndWFnZXMsIGxpa2UgQy4KICAgIC8vIERhdGEgbG9jYXRpb24gZm9yIGFsbCBzdGF0ZSB2YXJpYWJsZXMgaXMgc3RvcmFnZS4KICAgIGJvb2xbMl1bXSBwYWlyc09mRmxhZ3M7CgogICAgLy8gbmV3UGFpcnMgaXMgc3RvcmVkIGluIG1lbW9yeQogICAgZnVuY3Rpb24gc2V0QWxsRmxhZ1BhaXJzKGJvb2xbMl1bXSBtZW1vcnkgbmV3UGFpcnMpIHB1YmxpYyB7CiAgICAgICAgLy8gYXNzaWdubWVudCB0byBhIHN0b3JhZ2UgYXJyYXkgcGVyZm9ybXMgYSBjb3B5IG9mIGBgbmV3UGFpcnNgYCBhbmQKICAgICAgICAvLyByZXBsYWNlcyB0aGUgY29tcGxldGUgYXJyYXkgYGBwYWlyc09mRmxhZ3NgYC4KICAgICAgICBwYWlyc09mRmxhZ3MgPSBuZXdQYWlyczsKICAgIH0KCiAgICBzdHJ1Y3QgU3RydWN0VHlwZSB7CiAgICAgICAgdWludFtdIGNvbnRlbnRzOwogICAgICAgIHVpbnQgbW9yZUluZm87CiAgICB9CiAgICBTdHJ1Y3RUeXBlIHM7CgogICAgZnVuY3Rpb24gZih1aW50W10gbWVtb3J5IGMpIHB1YmxpYyB7CiAgICAgICAgLy8gc3RvcmVzIGEgcmVmZXJlbmNlIHRvIGBgc2BgIGluIGBgZ2BgCiAgICAgICAgU3RydWN0VHlwZSBzdG9yYWdlIGcgPSBzOwogICAgICAgIC8vIGFsc28gY2hhbmdlcyBgYHMubW9yZUluZm9gYC4KICAgICAgICBnLm1vcmVJbmZvID0gMjsKICAgICAgICAvLyBhc3NpZ25zIGEgY29weSBiZWNhdXNlIGBgZy5jb250ZW50c2BgCiAgICAgICAgLy8gaXMgbm90IGEgbG9jYWwgdmFyaWFibGUsIGJ1dCBhIG1lbWJlciBvZgogICAgICAgIC8vIGEgbG9jYWwgdmFyaWFibGUuCiAgICAgICAgZy5jb250ZW50cyA9IGM7CiAgICB9CgogICAgZnVuY3Rpb24gc2V0RmxhZ1BhaXIodWludCBpbmRleCwgYm9vbCBmbGFnQSwgYm9vbCBmbGFnQikgcHVibGljIHsKICAgICAgICAvLyBhY2Nlc3MgdG8gYSBub24tZXhpc3RpbmcgaW5kZXggd2lsbCB0aHJvdyBhbiBleGNlcHRpb24KICAgICAgICBwYWlyc09mRmxhZ3NbaW5kZXhdWzBdID0gZmxhZ0E7CiAgICAgICAgcGFpcnNPZkZsYWdzW2luZGV4XVsxXSA9IGZsYWdCOwogICAgfQoKICAgIGZ1bmN0aW9uIGNoYW5nZUZsYWdBcnJheVNpemUodWludCBuZXdTaXplKSBwdWJsaWMgewogICAgICAgIC8vIHVzaW5nIHB1c2ggYW5kIHBvcCBpcyB0aGUgb25seSB3YXkgdG8gY2hhbmdlIHRoZQogICAgICAgIC8vIGxlbmd0aCBvZiBhbiBhcnJheQogICAgICAgIGlmIChuZXdTaXplIDwgcGFpcnNPZkZsYWdzLmxlbmd0aCkgewogICAgICAgICAgICB3aGlsZSAocGFpcnNPZkZsYWdzLmxlbmd0aCA+IG5ld1NpemUpCiAgICAgICAgICAgICAgICBwYWlyc09mRmxhZ3MucG9wKCk7CiAgICAgICAgfSBlbHNlIGlmIChuZXdTaXplID4gcGFpcnNPZkZsYWdzLmxlbmd0aCkgewogICAgICAgICAgICB3aGlsZSAocGFpcnNPZkZsYWdzLmxlbmd0aCA8IG5ld1NpemUpCiAgICAgICAgICAgICAgICBwYWlyc09mRmxhZ3MucHVzaCgpOwogICAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiBjbGVhcigpIHB1YmxpYyB7CiAgICAgICAgLy8gdGhlc2UgY2xlYXIgdGhlIGFycmF5cyBjb21wbGV0ZWx5CiAgICAgICAgZGVsZXRlIHBhaXJzT2ZGbGFnczsKICAgICAgICBkZWxldGUgYUxvdE9mSW50ZWdlcnM7CiAgICAgICAgLy8gaWRlbnRpY2FsIGVmZmVjdCBoZXJlCiAgICAgICAgcGFpcnNPZkZsYWdzID0gbmV3IGJvb2xbMl1bXSgwKTsKICAgIH0KCiAgICBieXRlcyBieXRlRGF0YTsKCiAgICBmdW5jdGlvbiBieXRlQXJyYXlzKGJ5dGVzIG1lbW9yeSBkYXRhKSBwdWJsaWMgewogICAgICAgIC8vIGJ5dGUgYXJyYXlzICgiYnl0ZXMiKSBhcmUgZGlmZmVyZW50IGFzIHRoZXkgYXJlIHN0b3JlZCB3aXRob3V0IHBhZGRpbmcsCiAgICAgICAgLy8gYnV0IGNhbiBiZSB0cmVhdGVkIGlkZW50aWNhbCB0byAidWludDhbXSIKICAgICAgICBieXRlRGF0YSA9IGRhdGE7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgNzsgaSsrKQogICAgICAgICAgICBieXRlRGF0YS5wdXNoKCk7CiAgICAgICAgYnl0ZURhdGFbM10gPSAweDA4OwogICAgICAgIGRlbGV0ZSBieXRlRGF0YVsyXTsKICAgIH0KCiAgICBmdW5jdGlvbiBhZGRGbGFnKGJvb2xbMl0gbWVtb3J5IGZsYWcpIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcGFpcnNPZkZsYWdzLnB1c2goZmxhZyk7CiAgICAgICAgcmV0dXJuIHBhaXJzT2ZGbGFncy5sZW5ndGg7CiAgICB9CgogICAgZnVuY3Rpb24gY3JlYXRlTWVtb3J5QXJyYXkodWludCBzaXplKSBwdWJsaWMgcHVyZSByZXR1cm5zIChieXRlcyBtZW1vcnkpIHsKICAgICAgICAvLyBEeW5hbWljIG1lbW9yeSBhcnJheXMgYXJlIGNyZWF0ZWQgdXNpbmcgYG5ld2A6CiAgICAgICAgdWludFsyXVtdIG1lbW9yeSBhcnJheU9mUGFpcnMgPSBuZXcgdWludFsyXVtdKHNpemUpOwoKICAgICAgICAvLyBJbmxpbmUgYXJyYXlzIGFyZSBhbHdheXMgc3RhdGljYWxseS1zaXplZCBhbmQgaWYgeW91IG9ubHkKICAgICAgICAvLyB1c2UgbGl0ZXJhbHMsIHlvdSBoYXZlIHRvIHByb3ZpZGUgYXQgbGVhc3Qgb25lIHR5cGUuCiAgICAgICAgYXJyYXlPZlBhaXJzWzBdID0gW3VpbnQoMSksIDJdOwoKICAgICAgICAvLyBDcmVhdGUgYSBkeW5hbWljIGJ5dGUgYXJyYXk6CiAgICAgICAgYnl0ZXMgbWVtb3J5IGIgPSBuZXcgYnl0ZXMoMjAwKTsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKQogICAgICAgICAgICBiW2ldID0gYnl0ZXMxKHVpbnQ4KGkpKTsKICAgICAgICByZXR1cm4gYjsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract ArrayContract {
 uint\[2\*\*20\] aLotOfIntegers;
 // Note that the following is not a pair of dynamic arrays but a
 // dynamic array of pairs (i.e. of fixed size arrays of length two).
 // In Solidity, T\[k\] and T\[\] are always arrays with elements of type T,
 // even if T itself is an array.
 // Because of that, bool\[2\]\[\] is a dynamic array of elements
 // that are bool\[2\]. This is different from other languages, like C.
 // Data location for all state variables is storage.
 bool\[2\]\[\] pairsOfFlags;
 // newPairs is stored in memory
 function setAllFlagPairs(bool\[2\]\[\] memory newPairs) public {
 // assignment to a storage array performs a copy of \`\`newPairs\`\` and
 // replaces the complete array \`\`pairsOfFlags\`\`.
 pairsOfFlags \= newPairs;
 }
 struct StructType {
 uint\[\] contents;
 uint moreInfo;
 }
 StructType s;
 function f(uint\[\] memory c) public {
 // stores a reference to \`\`s\`\` in \`\`g\`\`
 StructType storage g \= s;
 // also changes \`\`s.moreInfo\`\`.
 g.moreInfo \= 2;
 // assigns a copy because \`\`g.contents\`\`
 // is not a local variable, but a member of
 // a local variable.
 g.contents \= c;
 }
 function setFlagPair(uint index, bool flagA, bool flagB) public {
 // access to a non-existing index will throw an exception
 pairsOfFlags\[index\]\[0\] \= flagA;
 pairsOfFlags\[index\]\[1\] \= flagB;
 }
 function changeFlagArraySize(uint newSize) public {
 // using push and pop is the only way to change the
 // length of an array
 if (newSize < pairsOfFlags.length) {
 while (pairsOfFlags.length \> newSize)
 pairsOfFlags.pop();
 } else if (newSize \> pairsOfFlags.length) {
 while (pairsOfFlags.length < newSize)
 pairsOfFlags.push();
 }
 }
 function clear() public {
 // these clear the arrays completely
 delete pairsOfFlags;
 delete aLotOfIntegers;
 // identical effect here
 pairsOfFlags \= new bool\[2\]\[\](0);
 }
 bytes byteData;
 function byteArrays(bytes memory data) public {
 // byte arrays ("bytes") are different as they are stored without padding,
 // but can be treated identical to "uint8\[\]"
 byteData \= data;
 for (uint i \= 0; i < 7; i++)
 byteData.push();
 byteData\[3\] \= 0x08;
 delete byteData\[2\];
 }
 function addFlag(bool\[2\] memory flag) public returns (uint) {
 pairsOfFlags.push(flag);
 return pairsOfFlags.length;
 }
 function createMemoryArray(uint size) public pure returns (bytes memory) {
 // Dynamic memory arrays are created using \`new\`:
 uint\[2\]\[\] memory arrayOfPairs \= new uint\[2\]\[\](size);
 // Inline arrays are always statically-sized and if you only
 // use literals, you have to provide at least one type.
 arrayOfPairs\[0\] \= \[uint(1), 2\];
 // Create a dynamic byte array:
 bytes memory b \= new bytes(200);
 for (uint i \= 0; i < b.length; i++)
 b\[i\] \= bytes1(uint8(i));
 return b;
 }
}
#### Dangling References to Storage Array Elements[](#dangling-references-to-storage-array-elements "Link to this heading")
When working with storage arrays, you need to take care to avoid dangling references. A dangling reference is a reference that points to something that no longer exists or has been moved without updating the reference. A dangling reference can for example occur, if you store a reference to an array element in a local variable and then `.pop()` from the containing array:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50W11bXSBzOwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIC8vIFN0b3JlcyBhIHBvaW50ZXIgdG8gdGhlIGxhc3QgYXJyYXkgZWxlbWVudCBvZiBzLgogICAgICAgIHVpbnRbXSBzdG9yYWdlIHB0ciA9IHNbcy5sZW5ndGggLSAxXTsKICAgICAgICAvLyBSZW1vdmVzIHRoZSBsYXN0IGFycmF5IGVsZW1lbnQgb2Ygcy4KICAgICAgICBzLnBvcCgpOwogICAgICAgIC8vIFdyaXRlcyB0byB0aGUgYXJyYXkgZWxlbWVudCB0aGF0IGlzIG5vIGxvbmdlciB3aXRoaW4gdGhlIGFycmF5LgogICAgICAgIHB0ci5wdXNoKDB4NDIpOwogICAgICAgIC8vIEFkZGluZyBhIG5ldyBlbGVtZW50IHRvIGBgc2BgIG5vdyB3aWxsIG5vdCBhZGQgYW4gZW1wdHkgYXJyYXksIGJ1dAogICAgICAgIC8vIHdpbGwgcmVzdWx0IGluIGFuIGFycmF5IG9mIGxlbmd0aCAxIHdpdGggYGAweDQyYGAgYXMgZWxlbWVudC4KICAgICAgICBzLnB1c2goKTsKICAgICAgICBhc3NlcnQoc1tzLmxlbmd0aCAtIDFdWzBdID09IDB4NDIpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0 <0.9.0;
contract C {
 uint\[\]\[\] s;
 function f() public {
 // Stores a pointer to the last array element of s.
 uint\[\] storage ptr \= s\[s.length \- 1\];
 // Removes the last array element of s.
 s.pop();
 // Writes to the array element that is no longer within the array.
 ptr.push(0x42);
 // Adding a new element to \`\`s\`\` now will not add an empty array, but
 // will result in an array of length 1 with \`\`0x42\`\` as element.
 s.push();
 assert(s\[s.length \- 1\]\[0\] \== 0x42);
 }
}
The write in `ptr.push(0x42)` will **not** revert, despite the fact that `ptr` no longer refers to a valid element of `s`. Since the compiler assumes that unused storage is always zeroed, a subsequent `s.push()` will not explicitly write zeroes to storage, so the last element of `s` after that `push()` will have length `1` and contain `0x42` as its first element.
Note that Solidity does not allow to declare references to value types in storage. These kinds of explicit dangling references are restricted to nested reference types. However, dangling references can also occur temporarily when using complex expressions in tuple assignments:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50W10gczsKICAgIHVpbnRbXSB0OwogICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgLy8gUHVzaCBzb21lIGluaXRpYWwgdmFsdWVzIHRvIHRoZSBzdG9yYWdlIGFycmF5cy4KICAgICAgICBzLnB1c2goMHgwNyk7CiAgICAgICAgdC5wdXNoKDB4MDMpOwogICAgfQoKICAgIGZ1bmN0aW9uIGcoKSBpbnRlcm5hbCByZXR1cm5zICh1aW50W10gc3RvcmFnZSkgewogICAgICAgIHMucG9wKCk7CiAgICAgICAgcmV0dXJuIHQ7CiAgICB9CgogICAgZnVuY3Rpb24gZigpIHB1YmxpYyByZXR1cm5zICh1aW50W10gbWVtb3J5KSB7CiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyB3aWxsIGZpcnN0IGV2YWx1YXRlIGBgcy5wdXNoKClgYCB0byBhIHJlZmVyZW5jZSB0byBhIG5ldyBlbGVtZW50CiAgICAgICAgLy8gYXQgaW5kZXggMS4gQWZ0ZXJ3YXJkcywgdGhlIGNhbGwgdG8gYGBnYGAgcG9wcyB0aGlzIG5ldyBlbGVtZW50LCByZXN1bHRpbmcgaW4KICAgICAgICAvLyB0aGUgbGVmdC1tb3N0IHR1cGxlIGVsZW1lbnQgdG8gYmVjb21lIGEgZGFuZ2xpbmcgcmVmZXJlbmNlLiBUaGUgYXNzaWdubWVudCBzdGlsbAogICAgICAgIC8vIHRha2VzIHBsYWNlIGFuZCB3aWxsIHdyaXRlIG91dHNpZGUgdGhlIGRhdGEgYXJlYSBvZiBgYHNgYC4KICAgICAgICAocy5wdXNoKCksIGcoKVswXSkgPSAoMHg0MiwgMHgxNyk7CiAgICAgICAgLy8gQSBzdWJzZXF1ZW50IHB1c2ggdG8gYGBzYGAgd2lsbCByZXZlYWwgdGhlIHZhbHVlIHdyaXR0ZW4gYnkgdGhlIHByZXZpb3VzCiAgICAgICAgLy8gc3RhdGVtZW50LCBpLmUuIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGBzYGAgYXQgdGhlIGVuZCBvZiB0aGlzIGZ1bmN0aW9uIHdpbGwgaGF2ZQogICAgICAgIC8vIHRoZSB2YWx1ZSBgYDB4NDJgYC4KICAgICAgICBzLnB1c2goKTsKICAgICAgICByZXR1cm4gczsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0 <0.9.0;
contract C {
 uint\[\] s;
 uint\[\] t;
 constructor() {
 // Push some initial values to the storage arrays.
 s.push(0x07);
 t.push(0x03);
 }
 function g() internal returns (uint\[\] storage) {
 s.pop();
 return t;
 }
 function f() public returns (uint\[\] memory) {
 // The following will first evaluate \`\`s.push()\`\` to a reference to a new element
 // at index 1. Afterwards, the call to \`\`g\`\` pops this new element, resulting in
 // the left-most tuple element to become a dangling reference. The assignment still
 // takes place and will write outside the data area of \`\`s\`\`.
 (s.push(), g()\[0\]) \= (0x42, 0x17);
 // A subsequent push to \`\`s\`\` will reveal the value written by the previous
 // statement, i.e. the last element of \`\`s\`\` at the end of this function will have
 // the value \`\`0x42\`\`.
 s.push();
 return s;
 }
}
It is always safer to only assign to storage once per statement and to avoid complex expressions on the left-hand-side of an assignment.
You need to take particular care when dealing with references to elements of `bytes` arrays, since a `.push()` on a bytes array may switch [from short to long layout in storage](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#bytes-and-string).
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjAgPDAuOS4wOwoKLy8gVGhpcyB3aWxsIHJlcG9ydCBhIHdhcm5pbmcKY29udHJhY3QgQyB7CiAgICBieXRlcyB4ID0gIjAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OSI7CgogICAgZnVuY3Rpb24gdGVzdCgpIGV4dGVybmFsIHJldHVybnModWludCkgewogICAgICAgICh4LnB1c2goKSwgeC5wdXNoKCkpID0gKDB4MDEsIDB4MDIpOwogICAgICAgIHJldHVybiB4Lmxlbmd0aDsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0 <0.9.0;
// This will report a warning
contract C {
 bytes x \= "012345678901234567890123456789";
 function test() external returns(uint) {
 (x.push(), x.push()) \= (0x01, 0x02);
 return x.length;
 }
}
Here, when the first `x.push()` is evaluated, `x` is still stored in short layout, thereby `x.push()` returns a reference to an element in the first storage slot of `x`. However, the second `x.push()` switches the bytes array to large layout. Now the element that `x.push()` referred to is in the data area of the array while the reference still points at its original location, which is now a part of the length field and the assignment will effectively garble the length of `x`. To be safe, only enlarge bytes arrays by at most one element during a single assignment and do not simultaneously index-access the array in the same statement.
While the above describes the behavior of dangling storage references in the current version of the compiler, any code with dangling references should be considered to have _undefined behavior_. In particular, this means that any future version of the compiler may change the behavior of code that involves dangling references.
Be sure to avoid dangling references in your code!
### Array Slices[](#array-slices "Link to this heading")
Array slices are a view on a contiguous portion of an array. They are written as `x[start:end]`, where `start` and `end` are expressions resulting in a uint256 type (or implicitly convertible to it). The first element of the slice is `x[start]` and the last element is `x[end - 1]`.
If `start` is greater than `end` or if `end` is greater than the length of the array, an exception is thrown.
Both `start` and `end` are optional: `start` defaults to `0` and `end` defaults to the length of the array.
Array slices do not have any members. They are implicitly convertible to arrays of their underlying type and support index access. Index access is not absolute in the underlying array, but relative to the start of the slice.
Array slices do not have a type name which means no variable can have an array slices as type, they only exist in intermediate expressions.
Note
As of now, array slices are only implemented for calldata arrays.
Array slices are useful to ABI-decode secondary data passed in function parameters:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjUgPDAuOS4wOwpjb250cmFjdCBQcm94eSB7CiAgICAvLy8gQGRldiBBZGRyZXNzIG9mIHRoZSBjbGllbnQgY29udHJhY3QgbWFuYWdlZCBieSBwcm94eSBpLmUuLCB0aGlzIGNvbnRyYWN0CiAgICBhZGRyZXNzIGNsaWVudDsKCiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzIGNsaWVudF8pIHsKICAgICAgICBjbGllbnQgPSBjbGllbnRfOwogICAgfQoKICAgIC8vLyBGb3J3YXJkIGNhbGwgdG8gInNldE93bmVyKGFkZHJlc3MpIiB0aGF0IGlzIGltcGxlbWVudGVkIGJ5IGNsaWVudAogICAgLy8vIGFmdGVyIGRvaW5nIGJhc2ljIHZhbGlkYXRpb24gb24gdGhlIGFkZHJlc3MgYXJndW1lbnQuCiAgICBmdW5jdGlvbiBmb3J3YXJkKGJ5dGVzIGNhbGxkYXRhIHBheWxvYWQpIGV4dGVybmFsIHsKICAgICAgICBieXRlczQgc2lnID0gYnl0ZXM0KHBheWxvYWRbOjRdKTsKICAgICAgICAvLyBEdWUgdG8gdHJ1bmNhdGluZyBiZWhhdmlvciwgYnl0ZXM0KHBheWxvYWQpIHBlcmZvcm1zIGlkZW50aWNhbGx5LgogICAgICAgIC8vIGJ5dGVzNCBzaWcgPSBieXRlczQocGF5bG9hZCk7CiAgICAgICAgaWYgKHNpZyA9PSBieXRlczQoa2VjY2FrMjU2KCJzZXRPd25lcihhZGRyZXNzKSIpKSkgewogICAgICAgICAgICBhZGRyZXNzIG93bmVyID0gYWJpLmRlY29kZShwYXlsb2FkWzQ6XSwgKGFkZHJlc3MpKTsKICAgICAgICAgICAgcmVxdWlyZShvd25lciAhPSBhZGRyZXNzKDApLCAiQWRkcmVzcyBvZiBvd25lciBjYW5ub3QgYmUgemVyby4iKTsKICAgICAgICB9CiAgICAgICAgKGJvb2wgc3RhdHVzLCkgPSBjbGllbnQuZGVsZWdhdGVjYWxsKHBheWxvYWQpOwogICAgICAgIHJlcXVpcmUoc3RhdHVzLCAiRm9yd2FyZGVkIGNhbGwgZmFpbGVkLiIpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.5 <0.9.0;
contract Proxy {
 /// @dev Address of the client contract managed by proxy i.e., this contract
 address client;
 constructor(address client\_) {
 client \= client\_;
 }
 /// Forward call to "setOwner(address)" that is implemented by client
 /// after doing basic validation on the address argument.
 function forward(bytes calldata payload) external {
 bytes4 sig \= bytes4(payload\[:4\]);
 // Due to truncating behavior, bytes4(payload) performs identically.
 // bytes4 sig = bytes4(payload);
 if (sig \== bytes4(keccak256("setOwner(address)"))) {
 address owner \= abi.decode(payload\[4:\], (address));
 require(owner != address(0), "Address of owner cannot be zero.");
 }
 (bool status,) \= client.delegatecall(payload);
 require(status, "Forwarded call failed.");
 }
}
### Structs[](#structs "Link to this heading")
Solidity provides a way to define new types in the form of structs, which is shown in the following example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKLy8gRGVmaW5lcyBhIG5ldyB0eXBlIHdpdGggdHdvIGZpZWxkcy4KLy8gRGVjbGFyaW5nIGEgc3RydWN0IG91dHNpZGUgb2YgYSBjb250cmFjdCBhbGxvd3MKLy8gaXQgdG8gYmUgc2hhcmVkIGJ5IG11bHRpcGxlIGNvbnRyYWN0cy4KLy8gSGVyZSwgdGhpcyBpcyBub3QgcmVhbGx5IG5lZWRlZC4Kc3RydWN0IEZ1bmRlciB7CiAgICBhZGRyZXNzIGFkZHI7CiAgICB1aW50IGFtb3VudDsKfQoKY29udHJhY3QgQ3Jvd2RGdW5kaW5nIHsKICAgIC8vIFN0cnVjdHMgY2FuIGFsc28gYmUgZGVmaW5lZCBpbnNpZGUgY29udHJhY3RzLCB3aGljaCBtYWtlcyB0aGVtCiAgICAvLyB2aXNpYmxlIG9ubHkgdGhlcmUgYW5kIGluIGRlcml2ZWQgY29udHJhY3RzLgogICAgc3RydWN0IENhbXBhaWduIHsKICAgICAgICBhZGRyZXNzIHBheWFibGUgYmVuZWZpY2lhcnk7CiAgICAgICAgdWludCBmdW5kaW5nR29hbDsKICAgICAgICB1aW50IG51bUZ1bmRlcnM7CiAgICAgICAgdWludCBhbW91bnQ7CiAgICAgICAgbWFwcGluZyh1aW50ID0+IEZ1bmRlcikgZnVuZGVyczsKICAgIH0KCiAgICB1aW50IG51bUNhbXBhaWduczsKICAgIG1hcHBpbmcodWludCA9PiBDYW1wYWlnbikgY2FtcGFpZ25zOwoKICAgIGZ1bmN0aW9uIG5ld0NhbXBhaWduKGFkZHJlc3MgcGF5YWJsZSBiZW5lZmljaWFyeSwgdWludCBnb2FsKSBwdWJsaWMgcmV0dXJucyAodWludCBjYW1wYWlnbklEKSB7CiAgICAgICAgY2FtcGFpZ25JRCA9IG51bUNhbXBhaWducysrOyAvLyBjYW1wYWlnbklEIGlzIHJldHVybiB2YXJpYWJsZQogICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgImNhbXBhaWduc1tjYW1wYWlnbklEXSA9IENhbXBhaWduKGJlbmVmaWNpYXJ5LCBnb2FsLCAwLCAwKSIKICAgICAgICAvLyBiZWNhdXNlIHRoZSByaWdodCBoYW5kIHNpZGUgY3JlYXRlcyBhIG1lbW9yeS1zdHJ1Y3QgIkNhbXBhaWduIiB0aGF0IGNvbnRhaW5zIGEgbWFwcGluZy4KICAgICAgICBDYW1wYWlnbiBzdG9yYWdlIGMgPSBjYW1wYWlnbnNbY2FtcGFpZ25JRF07CiAgICAgICAgYy5iZW5lZmljaWFyeSA9IGJlbmVmaWNpYXJ5OwogICAgICAgIGMuZnVuZGluZ0dvYWwgPSBnb2FsOwogICAgfQoKICAgIGZ1bmN0aW9uIGNvbnRyaWJ1dGUodWludCBjYW1wYWlnbklEKSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgQ2FtcGFpZ24gc3RvcmFnZSBjID0gY2FtcGFpZ25zW2NhbXBhaWduSURdOwogICAgICAgIC8vIENyZWF0ZXMgYSBuZXcgdGVtcG9yYXJ5IG1lbW9yeSBzdHJ1Y3QsIGluaXRpYWxpc2VkIHdpdGggdGhlIGdpdmVuIHZhbHVlcwogICAgICAgIC8vIGFuZCBjb3BpZXMgaXQgb3ZlciB0byBzdG9yYWdlLgogICAgICAgIC8vIE5vdGUgdGhhdCB5b3UgY2FuIGFsc28gdXNlIEZ1bmRlcihtc2cuc2VuZGVyLCBtc2cudmFsdWUpIHRvIGluaXRpYWxpc2UuCiAgICAgICAgYy5mdW5kZXJzW2MubnVtRnVuZGVycysrXSA9IEZ1bmRlcih7YWRkcjogbXNnLnNlbmRlciwgYW1vdW50OiBtc2cudmFsdWV9KTsKICAgICAgICBjLmFtb3VudCArPSBtc2cudmFsdWU7CiAgICB9CgogICAgZnVuY3Rpb24gY2hlY2tHb2FsUmVhY2hlZCh1aW50IGNhbXBhaWduSUQpIHB1YmxpYyByZXR1cm5zIChib29sIHJlYWNoZWQpIHsKICAgICAgICBDYW1wYWlnbiBzdG9yYWdlIGMgPSBjYW1wYWlnbnNbY2FtcGFpZ25JRF07CiAgICAgICAgaWYgKGMuYW1vdW50IDwgYy5mdW5kaW5nR29hbCkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIHVpbnQgYW1vdW50ID0gYy5hbW91bnQ7CiAgICAgICAgYy5hbW91bnQgPSAwOwogICAgICAgIGMuYmVuZWZpY2lhcnkudHJhbnNmZXIoYW1vdW50KTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
// Defines a new type with two fields.
// Declaring a struct outside of a contract allows
// it to be shared by multiple contracts.
// Here, this is not really needed.
struct Funder {
 address addr;
 uint amount;
}
contract CrowdFunding {
 // Structs can also be defined inside contracts, which makes them
 // visible only there and in derived contracts.
 struct Campaign {
 address payable beneficiary;
 uint fundingGoal;
 uint numFunders;
 uint amount;
 mapping(uint \=> Funder) funders;
 }
 uint numCampaigns;
 mapping(uint \=> Campaign) campaigns;
 function newCampaign(address payable beneficiary, uint goal) public returns (uint campaignID) {
 campaignID \= numCampaigns++; // campaignID is return variable
 // We cannot use "campaigns\[campaignID\] = Campaign(beneficiary, goal, 0, 0)"
 // because the right hand side creates a memory-struct "Campaign" that contains a mapping.
 Campaign storage c \= campaigns\[campaignID\];
 c.beneficiary \= beneficiary;
 c.fundingGoal \= goal;
 }
 function contribute(uint campaignID) public payable {
 Campaign storage c \= campaigns\[campaignID\];
 // Creates a new temporary memory struct, initialised with the given values
 // and copies it over to storage.
 // Note that you can also use Funder(msg.sender, msg.value) to initialise.
 c.funders\[c.numFunders++\] \= Funder({addr: msg.sender, amount: msg.value});
 c.amount += msg.value;
 }
 function checkGoalReached(uint campaignID) public returns (bool reached) {
 Campaign storage c \= campaigns\[campaignID\];
 if (c.amount < c.fundingGoal)
 return false;
 uint amount \= c.amount;
 c.amount \= 0;
 c.beneficiary.transfer(amount);
 return true;
 }
}
The contract does not provide the full functionality of a crowdfunding contract, but it contains the basic concepts necessary to understand structs. Struct types can be used inside mappings and arrays and they can themselves contain mappings and arrays.
It is not possible for a struct to contain a member of its own type, although the struct itself can be the value type of a mapping member or it can contain a dynamically-sized array of its type. This restriction is necessary, as the size of the struct has to be finite.
Note how in all the functions, a struct type is assigned to a local variable with data location `storage`. This does not copy the struct but only stores a reference so that assignments to members of the local variable actually write to the state.
Of course, you can also directly access the members of the struct without assigning it to a local variable, as in `campaigns[campaignID].amount = 0`.
Note
Until Solidity 0.7.0, memory-structs containing members of storage-only types (e.g. mappings) were allowed and assignments like `campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0)` in the example above would work and just silently skip those members.
## Mapping Types[](#mapping-types "Link to this heading")
Mapping types use the syntax `mapping(KeyType KeyName? => ValueType ValueName?)` and variables of mapping type are declared using the syntax `mapping(KeyType KeyName? => ValueType ValueName?) VariableName`. The `KeyType` can be any built-in value type, `bytes`, `string`, or any contract or enum type. Other user-defined or complex types, such as mappings, structs or array types are not allowed. `ValueType` can be any type, including mappings, arrays and structs. `KeyName` and `ValueName` are optional (so `mapping(KeyType => ValueType)` works as well) and can be any valid identifier that is not a type.
You can think of mappings as [hash tables](https://en.wikipedia.org/wiki/Hash_table), which are virtually initialised such that every possible key exists and is mapped to a value whose byte-representation is all zeros, a type’s [default value](https://docs.soliditylang.org/en/latest/control-structures.html#default-value). The similarity ends there, the key data is not stored in a mapping, only its `keccak256` hash is used to look up the value.
Because of this, mappings do not have a length or a concept of a key or value being set, and therefore cannot be erased without extra information regarding the assigned keys (see [Clearing Mappings](https://docs.soliditylang.org/en/latest/security-considerations.html#clearing-mappings)).
Mappings can only have a data location of `storage` and thus are allowed for state variables, as storage reference types in functions, or as parameters for library functions. They cannot be used as parameters or return parameters of contract functions that are publicly visible. These restrictions are also true for arrays and structs that contain mappings.
You can mark state variables of mapping type as `public` and Solidity creates a [getter](https://docs.soliditylang.org/en/latest/contracts.html#visibility-and-getters) for you. The `KeyType` becomes a parameter with name `KeyName` (if specified) for the getter. If `ValueType` is a value type or a struct, the getter returns `ValueType` with name `ValueName` (if specified). If `ValueType` is an array or a mapping, the getter has one parameter for each `KeyType`, recursively.
In the example below, the `MappingExample` contract defines a public `balances` mapping, with the key type an `address`, and a value type a `uint`, mapping an Ethereum address to an unsigned integer value. As `uint` is a value type, the getter returns a value that matches the type, which you can see in the `MappingUser` contract that returns the value at the specified address.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgTWFwcGluZ0V4YW1wbGUgewogICAgbWFwcGluZyhhZGRyZXNzID0+IHVpbnQpIHB1YmxpYyBiYWxhbmNlczsKCiAgICBmdW5jdGlvbiB1cGRhdGUodWludCBuZXdCYWxhbmNlKSBwdWJsaWMgewogICAgICAgIGJhbGFuY2VzW21zZy5zZW5kZXJdID0gbmV3QmFsYW5jZTsKICAgIH0KfQoKY29udHJhY3QgTWFwcGluZ1VzZXIgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgTWFwcGluZ0V4YW1wbGUgbSA9IG5ldyBNYXBwaW5nRXhhbXBsZSgpOwogICAgICAgIG0udXBkYXRlKDEwMCk7CiAgICAgICAgcmV0dXJuIG0uYmFsYW5jZXMoYWRkcmVzcyh0aGlzKSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract MappingExample {
 mapping(address \=> uint) public balances;
 function update(uint newBalance) public {
 balances\[msg.sender\] \= newBalance;
 }
}
contract MappingUser {
 function f() public returns (uint) {
 MappingExample m \= new MappingExample();
 m.update(100);
 return m.balances(address(this));
 }
}
The example below is a simplified version of an [ERC20 token](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol). `_allowances` is an example of a mapping type inside another mapping type.
In the example below, the optional `KeyName` and `ValueName` are provided for the mapping. It does not affect any contract functionality or bytecode, it only sets the `name` field for the inputs and outputs in the ABI for the mapping’s getter.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTg7Cgpjb250cmFjdCBNYXBwaW5nRXhhbXBsZVdpdGhOYW1lcyB7CiAgICBtYXBwaW5nKGFkZHJlc3MgdXNlciA9PiB1aW50IGJhbGFuY2UpIHB1YmxpYyBiYWxhbmNlczsKCiAgICBmdW5jdGlvbiB1cGRhdGUodWludCBuZXdCYWxhbmNlKSBwdWJsaWMgewogICAgICAgIGJhbGFuY2VzW21zZy5zZW5kZXJdID0gbmV3QmFsYW5jZTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.18;
contract MappingExampleWithNames {
 mapping(address user \=> uint balance) public balances;
 function update(uint newBalance) public {
 balances\[msg.sender\] \= newBalance;
 }
}
The example below uses `_allowances` to record the amount someone else is allowed to withdraw from your account.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCmNvbnRyYWN0IE1hcHBpbmdFeGFtcGxlIHsKCiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gdWludDI1NikgcHJpdmF0ZSBfYmFsYW5jZXM7CiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gbWFwcGluZyhhZGRyZXNzID0+IHVpbnQyNTYpKSBwcml2YXRlIF9hbGxvd2FuY2VzOwoKICAgIGV2ZW50IFRyYW5zZmVyKGFkZHJlc3MgaW5kZXhlZCBmcm9tLCBhZGRyZXNzIGluZGV4ZWQgdG8sIHVpbnQyNTYgdmFsdWUpOwogICAgZXZlbnQgQXBwcm92YWwoYWRkcmVzcyBpbmRleGVkIG93bmVyLCBhZGRyZXNzIGluZGV4ZWQgc3BlbmRlciwgdWludDI1NiB2YWx1ZSk7CgogICAgZnVuY3Rpb24gYWxsb3dhbmNlKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3Mgc3BlbmRlcikgcHVibGljIHZpZXcgcmV0dXJucyAodWludDI1NikgewogICAgICAgIHJldHVybiBfYWxsb3dhbmNlc1tvd25lcl1bc3BlbmRlcl07CiAgICB9CgogICAgZnVuY3Rpb24gdHJhbnNmZXJGcm9tKGFkZHJlc3Mgc2VuZGVyLCBhZGRyZXNzIHJlY2lwaWVudCwgdWludDI1NiBhbW91bnQpIHB1YmxpYyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmVxdWlyZShfYWxsb3dhbmNlc1tzZW5kZXJdW21zZy5zZW5kZXJdID49IGFtb3VudCwgIkVSQzIwOiBBbGxvd2FuY2Ugbm90IGhpZ2ggZW5vdWdoLiIpOwogICAgICAgIF9hbGxvd2FuY2VzW3NlbmRlcl1bbXNnLnNlbmRlcl0gLT0gYW1vdW50OwogICAgICAgIF90cmFuc2ZlcihzZW5kZXIsIHJlY2lwaWVudCwgYW1vdW50KTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBhcHByb3ZlKGFkZHJlc3Mgc3BlbmRlciwgdWludDI1NiBhbW91bnQpIHB1YmxpYyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmVxdWlyZShzcGVuZGVyICE9IGFkZHJlc3MoMCksICJFUkMyMDogYXBwcm92ZSB0byB0aGUgemVybyBhZGRyZXNzIik7CgogICAgICAgIF9hbGxvd2FuY2VzW21zZy5zZW5kZXJdW3NwZW5kZXJdID0gYW1vdW50OwogICAgICAgIGVtaXQgQXBwcm92YWwobXNnLnNlbmRlciwgc3BlbmRlciwgYW1vdW50KTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBfdHJhbnNmZXIoYWRkcmVzcyBzZW5kZXIsIGFkZHJlc3MgcmVjaXBpZW50LCB1aW50MjU2IGFtb3VudCkgaW50ZXJuYWwgewogICAgICAgIHJlcXVpcmUoc2VuZGVyICE9IGFkZHJlc3MoMCksICJFUkMyMDogdHJhbnNmZXIgZnJvbSB0aGUgemVybyBhZGRyZXNzIik7CiAgICAgICAgcmVxdWlyZShyZWNpcGllbnQgIT0gYWRkcmVzcygwKSwgIkVSQzIwOiB0cmFuc2ZlciB0byB0aGUgemVybyBhZGRyZXNzIik7CiAgICAgICAgcmVxdWlyZShfYmFsYW5jZXNbc2VuZGVyXSA+PSBhbW91bnQsICJFUkMyMDogTm90IGVub3VnaCBmdW5kcy4iKTsKCiAgICAgICAgX2JhbGFuY2VzW3NlbmRlcl0gLT0gYW1vdW50OwogICAgICAgIF9iYWxhbmNlc1tyZWNpcGllbnRdICs9IGFtb3VudDsKICAgICAgICBlbWl0IFRyYW5zZmVyKHNlbmRlciwgcmVjaXBpZW50LCBhbW91bnQpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.22 <0.9.0;
contract MappingExample {
 mapping(address \=> uint256) private \_balances;
 mapping(address \=> mapping(address \=> uint256)) private \_allowances;
 event Transfer(address indexed from, address indexed to, uint256 value);
 event Approval(address indexed owner, address indexed spender, uint256 value);
 function allowance(address owner, address spender) public view returns (uint256) {
 return \_allowances\[owner\]\[spender\];
 }
 function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
 require(\_allowances\[sender\]\[msg.sender\] \>= amount, "ERC20: Allowance not high enough.");
 \_allowances\[sender\]\[msg.sender\] \-= amount;
 \_transfer(sender, recipient, amount);
 return true;
 }
 function approve(address spender, uint256 amount) public returns (bool) {
 require(spender != address(0), "ERC20: approve to the zero address");
 \_allowances\[msg.sender\]\[spender\] \= amount;
 emit Approval(msg.sender, spender, amount);
 return true;
 }
 function \_transfer(address sender, address recipient, uint256 amount) internal {
 require(sender != address(0), "ERC20: transfer from the zero address");
 require(recipient != address(0), "ERC20: transfer to the zero address");
 require(\_balances\[sender\] \>= amount, "ERC20: Not enough funds.");
 \_balances\[sender\] \-= amount;
 \_balances\[recipient\] += amount;
 emit Transfer(sender, recipient, amount);
 }
}
### Iterable Mappings[](#iterable-mappings "Link to this heading")
You cannot iterate over mappings, i.e. you cannot enumerate their keys. It is possible, though, to implement a data structure on top of them and iterate over that. For example, the code below implements an `IterableMapping` library that the `User` contract then adds data to, and the `sum` function iterates over to sum all the values.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguODsKCnN0cnVjdCBJbmRleFZhbHVlIHsgdWludCBrZXlJbmRleDsgdWludCB2YWx1ZTsgfQpzdHJ1Y3QgS2V5RmxhZyB7IHVpbnQga2V5OyBib29sIGRlbGV0ZWQ7IH0KCnN0cnVjdCBpdG1hcCB7CiAgICBtYXBwaW5nKHVpbnQgPT4gSW5kZXhWYWx1ZSkgZGF0YTsKICAgIEtleUZsYWdbXSBrZXlzOwogICAgdWludCBzaXplOwp9Cgp0eXBlIEl0ZXJhdG9yIGlzIHVpbnQ7CgpsaWJyYXJ5IEl0ZXJhYmxlTWFwcGluZyB7CiAgICBmdW5jdGlvbiBpbnNlcnQoaXRtYXAgc3RvcmFnZSBzZWxmLCB1aW50IGtleSwgdWludCB2YWx1ZSkgaW50ZXJuYWwgcmV0dXJucyAoYm9vbCByZXBsYWNlZCkgewogICAgICAgIHVpbnQga2V5SW5kZXggPSBzZWxmLmRhdGFba2V5XS5rZXlJbmRleDsKICAgICAgICBzZWxmLmRhdGFba2V5XS52YWx1ZSA9IHZhbHVlOwogICAgICAgIGlmIChrZXlJbmRleCA+IDApCiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIGVsc2UgewogICAgICAgICAgICBrZXlJbmRleCA9IHNlbGYua2V5cy5sZW5ndGg7CiAgICAgICAgICAgIHNlbGYua2V5cy5wdXNoKCk7CiAgICAgICAgICAgIHNlbGYuZGF0YVtrZXldLmtleUluZGV4ID0ga2V5SW5kZXggKyAxOwogICAgICAgICAgICBzZWxmLmtleXNba2V5SW5kZXhdLmtleSA9IGtleTsKICAgICAgICAgICAgc2VsZi5zaXplKys7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gcmVtb3ZlKGl0bWFwIHN0b3JhZ2Ugc2VsZiwgdWludCBrZXkpIGludGVybmFsIHJldHVybnMgKGJvb2wgc3VjY2VzcykgewogICAgICAgIHVpbnQga2V5SW5kZXggPSBzZWxmLmRhdGFba2V5XS5rZXlJbmRleDsKICAgICAgICBpZiAoa2V5SW5kZXggPT0gMCkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIGRlbGV0ZSBzZWxmLmRhdGFba2V5XTsKICAgICAgICBzZWxmLmtleXNba2V5SW5kZXggLSAxXS5kZWxldGVkID0gdHJ1ZTsKICAgICAgICBzZWxmLnNpemUgLS07CiAgICB9CgogICAgZnVuY3Rpb24gY29udGFpbnMoaXRtYXAgc3RvcmFnZSBzZWxmLCB1aW50IGtleSkgaW50ZXJuYWwgdmlldyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmV0dXJuIHNlbGYuZGF0YVtrZXldLmtleUluZGV4ID4gMDsKICAgIH0KCiAgICBmdW5jdGlvbiBpdGVyYXRlU3RhcnQoaXRtYXAgc3RvcmFnZSBzZWxmKSBpbnRlcm5hbCB2aWV3IHJldHVybnMgKEl0ZXJhdG9yKSB7CiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yU2tpcERlbGV0ZWQoc2VsZiwgMCk7CiAgICB9CgogICAgZnVuY3Rpb24gaXRlcmF0ZVZhbGlkKGl0bWFwIHN0b3JhZ2Ugc2VsZiwgSXRlcmF0b3IgaXRlcmF0b3IpIGludGVybmFsIHZpZXcgcmV0dXJucyAoYm9vbCkgewogICAgICAgIHJldHVybiBJdGVyYXRvci51bndyYXAoaXRlcmF0b3IpIDwgc2VsZi5rZXlzLmxlbmd0aDsKICAgIH0KCiAgICBmdW5jdGlvbiBpdGVyYXRlTmV4dChpdG1hcCBzdG9yYWdlIHNlbGYsIEl0ZXJhdG9yIGl0ZXJhdG9yKSBpbnRlcm5hbCB2aWV3IHJldHVybnMgKEl0ZXJhdG9yKSB7CiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yU2tpcERlbGV0ZWQoc2VsZiwgSXRlcmF0b3IudW53cmFwKGl0ZXJhdG9yKSArIDEpOwogICAgfQoKICAgIGZ1bmN0aW9uIGl0ZXJhdGVHZXQoaXRtYXAgc3RvcmFnZSBzZWxmLCBJdGVyYXRvciBpdGVyYXRvcikgaW50ZXJuYWwgdmlldyByZXR1cm5zICh1aW50IGtleSwgdWludCB2YWx1ZSkgewogICAgICAgIHVpbnQga2V5SW5kZXggPSBJdGVyYXRvci51bndyYXAoaXRlcmF0b3IpOwogICAgICAgIGtleSA9IHNlbGYua2V5c1trZXlJbmRleF0ua2V5OwogICAgICAgIHZhbHVlID0gc2VsZi5kYXRhW2tleV0udmFsdWU7CiAgICB9CgogICAgZnVuY3Rpb24gaXRlcmF0b3JTa2lwRGVsZXRlZChpdG1hcCBzdG9yYWdlIHNlbGYsIHVpbnQga2V5SW5kZXgpIHByaXZhdGUgdmlldyByZXR1cm5zIChJdGVyYXRvcikgewogICAgICAgIHdoaWxlIChrZXlJbmRleCA8IHNlbGYua2V5cy5sZW5ndGggJiYgc2VsZi5rZXlzW2tleUluZGV4XS5kZWxldGVkKQogICAgICAgICAgICBrZXlJbmRleCsrOwogICAgICAgIHJldHVybiBJdGVyYXRvci53cmFwKGtleUluZGV4KTsKICAgIH0KfQoKLy8gSG93IHRvIHVzZSBpdApjb250cmFjdCBVc2VyIHsKICAgIC8vIEp1c3QgYSBzdHJ1Y3QgaG9sZGluZyBvdXIgZGF0YS4KICAgIGl0bWFwIGRhdGE7CiAgICAvLyBBcHBseSBsaWJyYXJ5IGZ1bmN0aW9ucyB0byB0aGUgZGF0YSB0eXBlLgogICAgdXNpbmcgSXRlcmFibGVNYXBwaW5nIGZvciBpdG1hcDsKCiAgICAvLyBJbnNlcnQgc29tZXRoaW5nCiAgICBmdW5jdGlvbiBpbnNlcnQodWludCBrLCB1aW50IHYpIHB1YmxpYyByZXR1cm5zICh1aW50IHNpemUpIHsKICAgICAgICAvLyBUaGlzIGNhbGxzIEl0ZXJhYmxlTWFwcGluZy5pbnNlcnQoZGF0YSwgaywgdikKICAgICAgICBkYXRhLmluc2VydChrLCB2KTsKICAgICAgICAvLyBXZSBjYW4gc3RpbGwgYWNjZXNzIG1lbWJlcnMgb2YgdGhlIHN0cnVjdCwKICAgICAgICAvLyBidXQgd2Ugc2hvdWxkIHRha2UgY2FyZSBub3QgdG8gbWVzcyB3aXRoIHRoZW0uCiAgICAgICAgcmV0dXJuIGRhdGEuc2l6ZTsKICAgIH0KCiAgICAvLyBDb21wdXRlcyB0aGUgc3VtIG9mIGFsbCBzdG9yZWQgZGF0YS4KICAgIGZ1bmN0aW9uIHN1bSgpIHB1YmxpYyB2aWV3IHJldHVybnMgKHVpbnQgcykgewogICAgICAgIGZvciAoCiAgICAgICAgICAgIEl0ZXJhdG9yIGkgPSBkYXRhLml0ZXJhdGVTdGFydCgpOwogICAgICAgICAgICBkYXRhLml0ZXJhdGVWYWxpZChpKTsKICAgICAgICAgICAgaSA9IGRhdGEuaXRlcmF0ZU5leHQoaSkKICAgICAgICApIHsKICAgICAgICAgICAgKCwgdWludCB2YWx1ZSkgPSBkYXRhLml0ZXJhdGVHZXQoaSk7CiAgICAgICAgICAgIHMgKz0gdmFsdWU7CiAgICAgICAgfQogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.8;
struct IndexValue { uint keyIndex; uint value; }
struct KeyFlag { uint key; bool deleted; }
struct itmap {
 mapping(uint \=> IndexValue) data;
 KeyFlag\[\] keys;
 uint size;
}
type Iterator is uint;
library IterableMapping {
 function insert(itmap storage self, uint key, uint value) internal returns (bool replaced) {
 uint keyIndex \= self.data\[key\].keyIndex;
 self.data\[key\].value \= value;
 if (keyIndex \> 0)
 return true;
 else {
 keyIndex \= self.keys.length;
 self.keys.push();
 self.data\[key\].keyIndex \= keyIndex + 1;
 self.keys\[keyIndex\].key \= key;
 self.size++;
 return false;
 }
 }
 function remove(itmap storage self, uint key) internal returns (bool success) {
 uint keyIndex \= self.data\[key\].keyIndex;
 if (keyIndex \== 0)
 return false;
 delete self.data\[key\];
 self.keys\[keyIndex \- 1\].deleted \= true;
 self.size \--;
 }
 function contains(itmap storage self, uint key) internal view returns (bool) {
 return self.data\[key\].keyIndex \> 0;
 }
 function iterateStart(itmap storage self) internal view returns (Iterator) {
 return iteratorSkipDeleted(self, 0);
 }
 function iterateValid(itmap storage self, Iterator iterator) internal view returns (bool) {
 return Iterator.unwrap(iterator) < self.keys.length;
 }
 function iterateNext(itmap storage self, Iterator iterator) internal view returns (Iterator) {
 return iteratorSkipDeleted(self, Iterator.unwrap(iterator) + 1);
 }
 function iterateGet(itmap storage self, Iterator iterator) internal view returns (uint key, uint value) {
 uint keyIndex \= Iterator.unwrap(iterator);
 key \= self.keys\[keyIndex\].key;
 value \= self.data\[key\].value;
 }
 function iteratorSkipDeleted(itmap storage self, uint keyIndex) private view returns (Iterator) {
 while (keyIndex < self.keys.length && self.keys\[keyIndex\].deleted)
 keyIndex++;
 return Iterator.wrap(keyIndex);
 }
}
// How to use it
contract User {
 // Just a struct holding our data.
 itmap data;
 // Apply library functions to the data type.
 using IterableMapping for itmap;
 // Insert something
 function insert(uint k, uint v) public returns (uint size) {
 // This calls IterableMapping.insert(data, k, v)
 data.insert(k, v);
 // We can still access members of the struct,
 // but we should take care not to mess with them.
 return data.size;
 }
 // Computes the sum of all stored data.
 function sum() public view returns (uint s) {
 for (
 Iterator i \= data.iterateStart();
 data.iterateValid(i);
 i \= data.iterateNext(i)
 ) {
 (, uint value) \= data.iterateGet(i);
 s += value;
 }
 }
}
## Operators[](#operators "Link to this heading")
Arithmetic and bit operators can be applied even if the two operands do not have the same type. For example, you can compute `y = x + z`, where `x` is a `uint8` and `z` has the type `uint32`. In these cases, the following mechanism will be used to determine the type in which the operation is computed (this is important in case of overflow) and the type of the operator’s result:
1. If the type of the right operand can be implicitly converted to the type of the left operand, use the type of the left operand,
 
2. if the type of the left operand can be implicitly converted to the type of the right operand, use the type of the right operand,
 
3. otherwise, the operation is not allowed.
 
In case one of the operands is a [literal number](#rational-literals) it is first converted to its “mobile type”, which is the smallest type that can hold the value (unsigned types of the same bit-width are considered “smaller” than the signed types). If both are literal numbers, the operation is computed with effectively unlimited precision in that the expression is evaluated to whatever precision is necessary so that none is lost when the result is used with a non-literal type.
The operator’s result type is the same as the type the operation is performed in, except for comparison operators where the result is always `bool`.
The operators `**` (exponentiation), `<<` and `>>` use the type of the left operand for the operation and the result.
### Ternary Operator[](#ternary-operator "Link to this heading")
The ternary operator is used in expressions of the form `<expression> ? <trueExpression> : <falseExpression>`. It evaluates one of the latter two given expressions depending upon the result of the evaluation of the main `<expression>`. If `<expression>` evaluates to `true`, then `<trueExpression>` will be evaluated, otherwise `<falseExpression>` is evaluated.
The result of the ternary operator does not have a rational number type, even if all of its operands are rational number literals. The result type is determined from the types of the two operands in the same way as above, converting to their mobile type first if required.
As a consequence, `255 + (true ? 1 : 0)` will revert due to arithmetic overflow. The reason is that `(true ? 1 : 0)` is of `uint8` type, which forces the addition to be performed in `uint8` as well, and 256 exceeds the range allowed for this type.
Another consequence is that an expression like `1.5 + 1.5` is valid but `1.5 + (true ? 1.5 : 2.5)` is not. This is because the former is a rational expression evaluated in unlimited precision and only its final value matters. The latter involves a conversion of a fractional rational number to an integer, which is currently disallowed.
### Compound and Increment/Decrement Operators[](#compound-and-increment-decrement-operators "Link to this heading")
If `a` is an LValue (i.e. a variable or something that can be assigned to), the following operators are available as shorthands:
`a += e` is equivalent to `a = a + e`. The operators `-=`, `*=`, `/=`, `%=`, `|=`, `&=`, `^=`, `<<=` and `>>=` are defined accordingly. `a++` and `a--` are equivalent to `a += 1` / `a -= 1` but the expression itself still has the previous value of `a`. In contrast, `--a` and `++a` have the same effect on `a` but return the value after the change.
### delete[](#delete "Link to this heading")
`delete a` assigns the initial value for the type to `a`. I.e. for integers it is equivalent to `a = 0`, but it can also be used on arrays, where it assigns a dynamic array of length zero or a static array of the same length with all elements set to their initial value. `delete a[x]` deletes the item at index `x` of the array and leaves all other elements and the length of the array untouched. This especially means that it leaves a gap in the array. If you plan to remove items, a [mapping](#mapping-types) is probably a better choice.
For structs, it assigns a struct with all members reset. In other words, the value of `a` after `delete a` is the same as if `a` would be declared without assignment, with the following caveat:
`delete` has no effect on mappings (as the keys of mappings may be arbitrary and are generally unknown). So if you delete a struct, it will reset all members that are not mappings and also recurse into the members unless they are mappings. However, individual keys and what they map to can be deleted: If `a` is a mapping, then `delete a[x]` will delete the value stored at `x`.
It is important to note that `delete a` really behaves like an assignment to `a`, i.e. it stores a new object in `a`. This distinction is visible when `a` is reference variable: It will only reset `a` itself, not the value it referred to previously.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgRGVsZXRlRXhhbXBsZSB7CiAgICB1aW50IGRhdGE7CiAgICB1aW50W10gZGF0YUFycmF5OwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIHVpbnQgeCA9IGRhdGE7CiAgICAgICAgZGVsZXRlIHg7IC8vIHNldHMgeCB0byAwLCBkb2VzIG5vdCBhZmZlY3QgZGF0YQogICAgICAgIGRlbGV0ZSBkYXRhOyAvLyBzZXRzIGRhdGEgdG8gMCwgZG9lcyBub3QgYWZmZWN0IHgKICAgICAgICB1aW50W10gc3RvcmFnZSB5ID0gZGF0YUFycmF5OwogICAgICAgIGRlbGV0ZSBkYXRhQXJyYXk7IC8vIHRoaXMgc2V0cyBkYXRhQXJyYXkubGVuZ3RoIHRvIHplcm8sIGJ1dCBhcyB1aW50W10gaXMgYSBjb21wbGV4IG9iamVjdCwgYWxzbwogICAgICAgIC8vIHkgaXMgYWZmZWN0ZWQgd2hpY2ggaXMgYW4gYWxpYXMgdG8gdGhlIHN0b3JhZ2Ugb2JqZWN0CiAgICAgICAgLy8gT24gdGhlIG90aGVyIGhhbmQ6ICJkZWxldGUgeSIgaXMgbm90IHZhbGlkLCBhcyBhc3NpZ25tZW50cyB0byBsb2NhbCB2YXJpYWJsZXMKICAgICAgICAvLyByZWZlcmVuY2luZyBzdG9yYWdlIG9iamVjdHMgY2FuIG9ubHkgYmUgbWFkZSBmcm9tIGV4aXN0aW5nIHN0b3JhZ2Ugb2JqZWN0cy4KICAgICAgICBhc3NlcnQoeS5sZW5ndGggPT0gMCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract DeleteExample {
 uint data;
 uint\[\] dataArray;
 function f() public {
 uint x \= data;
 delete x; // sets x to 0, does not affect data
 delete data; // sets data to 0, does not affect x
 uint\[\] storage y \= dataArray;
 delete dataArray; // this sets dataArray.length to zero, but as uint\[\] is a complex object, also
 // y is affected which is an alias to the storage object
 // On the other hand: "delete y" is not valid, as assignments to local variables
 // referencing storage objects can only be made from existing storage objects.
 assert(y.length \== 0);
 }
}
### Order of Precedence of Operators[](#order-of-precedence-of-operators "Link to this heading")
The following is the order of precedence for operators, listed in order of evaluation.
Precedence
Description
Operator
_1_
Postfix increment and decrement
`++`, `--`
New expression
`new <typename>`
Array subscripting
`<array>[<index>]`
Member access
`<object>.<member>`
Function-like call
`<func>(<args...>)`
Parentheses
`(<statement>)`
_2_
Prefix increment and decrement
`++`, `--`
Unary minus
`-`
Unary operations
`delete`
Logical NOT
`!`
Bitwise NOT
`~`
_3_
Exponentiation
`**`
_4_
Multiplication, division and modulo
`*`, `/`, `%`
_5_
Addition and subtraction
`+`, `-`
_6_
Bitwise shift operators
`<<`, `>>`
_7_
Bitwise AND
`&`
_8_
Bitwise XOR
`^`
_9_
Bitwise OR
`|`
_10_
Inequality operators
`<`, `>`, `<=`, `>=`
_11_
Equality operators
`==`, `!=`
_12_
Logical AND
`&&`
_13_
Logical OR
`||`
_14_
Ternary operator
`<conditional> ? <if-true> : <if-false>`
Assignment operators
`=`, `|=`, `^=`, `&=`, `<<=`, `>>=`, `+=`, `-=`, `*=`, `/=`, `%=`
_15_
Comma operator
`,`
## Conversions between Elementary Types[](#conversions-between-elementary-types "Link to this heading")
### Implicit Conversions[](#implicit-conversions "Link to this heading")
An implicit type conversion is automatically applied by the compiler in some cases during assignments, when passing arguments to functions and when applying operators. In general, an implicit conversion between value-types is possible if it makes sense semantically and no information is lost.
For example, `uint8` is convertible to `uint16` and `int128` to `int256`, but `int8` is not convertible to `uint256`, because `uint256` cannot hold values such as `-1`.
If an operator is applied to different types, the compiler tries to implicitly convert one of the operands to the type of the other (the same is true for assignments). This means that operations are always performed in the type of one of the operands.
For more details about which implicit conversions are possible, please consult the sections about the types themselves.
In the example below, `y` and `z`, the operands of the addition, do not have the same type, but `uint8` can be implicitly converted to `uint16` and not vice-versa. Because of that, `y` is converted to the type of `z` before the addition is performed in the `uint16` type. The resulting type of the expression `y + z` is `uint16`. Because it is assigned to a variable of type `uint32` another implicit conversion is performed after the addition.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=dWludDggeTsKdWludDE2IHo7CnVpbnQzMiB4ID0geSArIHo7)
uint8 y;
uint16 z;
uint32 x \= y + z;
### Explicit Conversions[](#explicit-conversions "Link to this heading")
If the compiler does not allow implicit conversion but you are confident a conversion will work, an explicit type conversion is sometimes possible. This may result in unexpected behavior and allows you to bypass some security features of the compiler, so be sure to test that the result is what you want and expect!
Take the following example that converts a negative `int` to a `uint`:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=aW50ICB5ID0gLTM7CnVpbnQgeCA9IHVpbnQoeSk7)
int y \= \-3;
uint x \= uint(y);
At the end of this code snippet, `x` will have the value `0xfffff..fd` (64 hex characters), which is -3 in the two’s complement representation of 256 bits.
If an integer is explicitly converted to a smaller type, higher-order bits are cut off:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=dWludDMyIGEgPSAweDEyMzQ1Njc4Owp1aW50MTYgYiA9IHVpbnQxNihhKTsgLy8gYiB3aWxsIGJlIDB4NTY3OCBub3c=)
uint32 a \= 0x12345678;
uint16 b \= uint16(a); // b will be 0x5678 now
If an integer is explicitly converted to a larger type, it is padded on the left (i.e., at the higher order end). The result of the conversion will compare equal to the original integer:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=dWludDE2IGEgPSAweDEyMzQ7CnVpbnQzMiBiID0gdWludDMyKGEpOyAvLyBiIHdpbGwgYmUgMHgwMDAwMTIzNCBub3cKYXNzZXJ0KGEgPT0gYik7)
uint16 a \= 0x1234;
uint32 b \= uint32(a); // b will be 0x00001234 now
assert(a \== b);
Fixed-size bytes types behave differently during conversions. They can be thought of as sequences of individual bytes and converting to a smaller type will cut off the sequence:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ynl0ZXMyIGEgPSAweDEyMzQ7CmJ5dGVzMSBiID0gYnl0ZXMxKGEpOyAvLyBiIHdpbGwgYmUgMHgxMg==)
bytes2 a \= 0x1234;
bytes1 b \= bytes1(a); // b will be 0x12
If a fixed-size bytes type is explicitly converted to a larger type, it is padded on the right. Accessing the byte at a fixed index will result in the same value before and after the conversion (if the index is still in range):
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ynl0ZXMyIGEgPSAweDEyMzQ7CmJ5dGVzNCBiID0gYnl0ZXM0KGEpOyAvLyBiIHdpbGwgYmUgMHgxMjM0MDAwMAphc3NlcnQoYVswXSA9PSBiWzBdKTsKYXNzZXJ0KGFbMV0gPT0gYlsxXSk7)
bytes2 a \= 0x1234;
bytes4 b \= bytes4(a); // b will be 0x12340000
assert(a\[0\] \== b\[0\]);
assert(a\[1\] \== b\[1\]);
Since integers and fixed-size byte arrays behave differently when truncating or padding, explicit conversions between integers and fixed-size byte arrays are only allowed, if both have the same size. If you want to convert between integers and fixed-size byte arrays of different size, you have to use intermediate conversions that make the desired truncation and padding rules explicit:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ynl0ZXMyIGEgPSAweDEyMzQ7CnVpbnQzMiBiID0gdWludDE2KGEpOyAvLyBiIHdpbGwgYmUgMHgwMDAwMTIzNAp1aW50MzIgYyA9IHVpbnQzMihieXRlczQoYSkpOyAvLyBjIHdpbGwgYmUgMHgxMjM0MDAwMAp1aW50OCBkID0gdWludDgodWludDE2KGEpKTsgLy8gZCB3aWxsIGJlIDB4MzQKdWludDggZSA9IHVpbnQ4KGJ5dGVzMShhKSk7IC8vIGUgd2lsbCBiZSAweDEy)
bytes2 a \= 0x1234;
uint32 b \= uint16(a); // b will be 0x00001234
uint32 c \= uint32(bytes4(a)); // c will be 0x12340000
uint8 d \= uint8(uint16(a)); // d will be 0x34
uint8 e \= uint8(bytes1(a)); // e will be 0x12
`bytes` arrays and `bytes` calldata slices can be converted explicitly to fixed bytes types (`bytes1`/…/`bytes32`). In case the array is longer than the target fixed bytes type, truncation at the end will happen. If the array is shorter than the target type, it will be padded with zeros at the end.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNTsKCmNvbnRyYWN0IEMgewogICAgYnl0ZXMgcyA9ICJhYmNkZWZnaCI7CiAgICBmdW5jdGlvbiBmKGJ5dGVzIGNhbGxkYXRhIGMsIGJ5dGVzIG1lbW9yeSBtKSBwdWJsaWMgdmlldyByZXR1cm5zIChieXRlczE2LCBieXRlczMpIHsKICAgICAgICByZXF1aXJlKGMubGVuZ3RoID09IDE2LCAiIik7CiAgICAgICAgYnl0ZXMxNiBiID0gYnl0ZXMxNihtKTsgIC8vIGlmIGxlbmd0aCBvZiBtIGlzIGdyZWF0ZXIgdGhhbiAxNiwgdHJ1bmNhdGlvbiB3aWxsIGhhcHBlbgogICAgICAgIGIgPSBieXRlczE2KHMpOyAgLy8gcGFkZGVkIG9uIHRoZSByaWdodCwgc28gcmVzdWx0IGlzICJhYmNkZWZnaFwwXDBcMFwwXDBcMFwwXDAiCiAgICAgICAgYnl0ZXMzIGIxID0gYnl0ZXMzKHMpOyAvLyB0cnVuY2F0ZWQsIGIxIGVxdWFscyB0byAiYWJjIgogICAgICAgIGIgPSBieXRlczE2KGNbOjhdKTsgIC8vIGFsc28gcGFkZGVkIHdpdGggemVyb3MKICAgICAgICByZXR1cm4gKGIsIGIxKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.5;
contract C {
 bytes s \= "abcdefgh";
 function f(bytes calldata c, bytes memory m) public view returns (bytes16, bytes3) {
 require(c.length \== 16, "");
 bytes16 b \= bytes16(m); // if length of m is greater than 16, truncation will happen
 b \= bytes16(s); // padded on the right, so result is "abcdefgh\\0\\0\\0\\0\\0\\0\\0\\0"
 bytes3 b1 \= bytes3(s); // truncated, b1 equals to "abc"
 b \= bytes16(c\[:8\]); // also padded with zeros
 return (b, b1);
 }
}
## Conversions between Literals and Elementary Types[](#conversions-between-literals-and-elementary-types "Link to this heading")
### Integer Types[](#integer-types "Link to this heading")
Decimal and hexadecimal number literals can be implicitly converted to any integer type that is large enough to represent it without truncation:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=dWludDggYSA9IDEyOyAvLyBmaW5lCnVpbnQzMiBiID0gMTIzNDsgLy8gZmluZQp1aW50MTYgYyA9IDB4MTIzNDU2OyAvLyBmYWlscywgc2luY2UgaXQgd291bGQgaGF2ZSB0byB0cnVuY2F0ZSB0byAweDM0NTY=)
uint8 a \= 12; // fine
uint32 b \= 1234; // fine
uint16 c \= 0x123456; // fails, since it would have to truncate to 0x3456
Note
Prior to version 0.8.0, any decimal or hexadecimal number literals could be explicitly converted to an integer type. From 0.8.0, such explicit conversions are as strict as implicit conversions, i.e., they are only allowed if the literal fits in the resulting range.
### Fixed-Size Byte Arrays[](#index-34 "Link to this heading")
Decimal number literals cannot be implicitly converted to fixed-size byte arrays. Hexadecimal number literals can be, but only if the number of hex digits exactly fits the size of the bytes type. As an exception both decimal and hexadecimal literals which have a value of zero can be converted to any fixed-size bytes type:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ynl0ZXMyIGEgPSA1NDMyMTsgLy8gbm90IGFsbG93ZWQKYnl0ZXMyIGIgPSAweDEyOyAvLyBub3QgYWxsb3dlZApieXRlczIgYyA9IDB4MTIzOyAvLyBub3QgYWxsb3dlZApieXRlczIgZCA9IDB4MTIzNDsgLy8gZmluZQpieXRlczIgZSA9IDB4MDAxMjsgLy8gZmluZQpieXRlczQgZiA9IDA7IC8vIGZpbmUKYnl0ZXM0IGcgPSAweDA7IC8vIGZpbmU=)
bytes2 a \= 54321; // not allowed
bytes2 b \= 0x12; // not allowed
bytes2 c \= 0x123; // not allowed
bytes2 d \= 0x1234; // fine
bytes2 e \= 0x0012; // fine
bytes4 f \= 0; // fine
bytes4 g \= 0x0; // fine
String literals and hex string literals can be implicitly converted to fixed-size byte arrays, if their number of characters is less than or equal to the size of the bytes type:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ynl0ZXMyIGEgPSBoZXgiMTIzNCI7IC8vIGZpbmUKYnl0ZXMyIGIgPSAieHkiOyAvLyBmaW5lCmJ5dGVzMiBjID0gaGV4IjEyIjsgLy8gZmluZQpieXRlczIgZSA9ICJ4IjsgLy8gZmluZQpieXRlczIgZiA9ICJ4eXoiOyAvLyBub3QgYWxsb3dlZA==)
bytes2 a \= hex"1234"; // fine
bytes2 b \= "xy"; // fine
bytes2 c \= hex"12"; // fine
bytes2 e \= "x"; // fine
bytes2 f \= "xyz"; // not allowed
### Addresses[](#addresses "Link to this heading")
As described in [Address Literals](#address-literals), hex literals of the correct size that pass the checksum test are of `address` type. No other literals can be implicitly converted to the `address` type.
Explicit conversions to `address` are allowed only from `bytes20` and `uint160`.
An `address a` can be converted explicitly to `address payable` via `payable(a)`.
Note
Prior to version 0.8.0, it was possible to explicitly convert from any integer type (of any size, signed or unsigned) to `address` or `address payable`. Starting with 0.8.0 only conversion from `uint160` is allowed.

# [Contracts — Solidity 0.4.26 documentation](https://docs.soliditylang.org/en/v0.4.26/contracts.html) 
 _https://docs.soliditylang.org/en/v0.4.26/contracts.html_

[Solidity](https://docs.soliditylang.org/en/v0.4.26/index.html)
Contracts in Solidity are similar to classes in object-oriented languages. They contain persistent data in state variables and functions that can modify these variables. Calling a function on a different contract (instance) will perform an EVM function call and thus switch the context such that state variables are inaccessible.
## Creating Contracts[¶](#creating-contracts "Permalink to this headline")
Contracts can be created “from outside” via Ethereum transactions or from within Solidity contracts.
IDEs, such as [Remix](https://remix.ethereum.org/), make the creation process seamless using UI elements.
Creating contracts programatically on Ethereum is best done via using the JavaScript API [web3.js](https://github.com/ethereum/web3.js). As of today it has a method called [web3.eth.Contract](https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract) to facilitate contract creation.
When a contract is created, its constructor (a function declared with the `constructor` keyword) is executed once. A constructor is optional. Only one constructor is allowed, and this means overloading is not supported.
Internally, constructor arguments are passed [ABI encoded](https://docs.soliditylang.org/en/v0.4.26/abi-spec.html#abi) after the code of the contract itself, but you do not have to care about this if you use `web3.js`.
If a contract wants to create another contract, the source code (and the binary) of the created contract has to be known to the creator. This means that cyclic creation dependencies are impossible.
pragma solidity ^0.4.22;
contract OwnedToken {
 // TokenCreator is a contract type that is defined below.
 // It is fine to reference it as long as it is not used
 // to create a new contract.
 TokenCreator creator;
 address owner;
 bytes32 name;
 // This is the constructor which registers the
 // creator and the assigned name.
 constructor(bytes32 \_name) public {
 // State variables are accessed via their name
 // and not via e.g. this.owner. This also applies
 // to functions and especially in the constructors,
 // you can only call them like that ("internally"),
 // because the contract itself does not exist yet.
 owner \= msg.sender;
 // We do an explicit type conversion from \`address\`
 // to \`TokenCreator\` and assume that the type of
 // the calling contract is TokenCreator, there is
 // no real way to check that.
 creator \= TokenCreator(msg.sender);
 name \= \_name;
 }
 function changeName(bytes32 newName) public {
 // Only the creator can alter the name --
 // the comparison is possible since contracts
 // are implicitly convertible to addresses.
 if (msg.sender \== address(creator))
 name \= newName;
 }
 function transfer(address newOwner) public {
 // Only the current owner can transfer the token.
 if (msg.sender != owner) return;
 // We also want to ask the creator if the transfer
 // is fine. Note that this calls a function of the
 // contract defined below. If the call fails (e.g.
 // due to out-of-gas), the execution here stops
 // immediately.
 if (creator.isTokenTransferOK(owner, newOwner))
 owner \= newOwner;
 }
}
contract TokenCreator {
 function createToken(bytes32 name)
 public
 returns (OwnedToken tokenAddress)
 {
 // Create a new Token contract and return its address.
 // From the JavaScript side, the return type is simply
 // \`address\`, as this is the closest type available in
 // the ABI.
 return new OwnedToken(name);
 }
 function changeName(OwnedToken tokenAddress, bytes32 name) public {
 // Again, the external type of \`tokenAddress\` is
 // simply \`address\`.
 tokenAddress.changeName(name);
 }
 function isTokenTransferOK(address currentOwner, address newOwner)
 public
 view
 returns (bool ok)
 {
 // Check some arbitrary condition.
 address tokenAddress \= msg.sender;
 return (keccak256(newOwner) & 0xff) \== (bytes20(tokenAddress) & 0xff);
 }
}
## Visibility and Getters[¶](#visibility-and-getters "Permalink to this headline")
Since Solidity knows two kinds of function calls (internal ones that do not create an actual EVM call (also called a “message call”) and external ones that do), there are four types of visibilities for functions and state variables.
Functions can be specified as being `external`, `public`, `internal` or `private`, where the default is `public`. For state variables, `external` is not possible and the default is `internal`.
`external`:
External functions are part of the contract interface, which means they can be called from other contracts and via transactions. An external function `f` cannot be called internally (i.e. `f()` does not work, but `this.f()` works). External functions are sometimes more efficient when they receive large arrays of data.
`public`:
Public functions are part of the contract interface and can be either called internally or via messages. For public state variables, an automatic getter function (see below) is generated.
`internal`:
Those functions and state variables can only be accessed internally (i.e. from within the current contract or contracts deriving from it), without using `this`.
`private`:
Private functions and state variables are only visible for the contract they are defined in and not in derived contracts.
Note
Everything that is inside a contract is visible to all external observers. Making something `private` only prevents other contracts from accessing and modifying the information, but it will still be visible to the whole world outside of the blockchain.
The visibility specifier is given after the type for state variables and between parameter list and return parameter list for functions.
pragma solidity ^0.4.16;
contract C {
 function f(uint a) private pure returns (uint b) { return a + 1; }
 function setData(uint a) internal { data \= a; }
 uint public data;
}
In the following example, `D`, can call `c.getData()` to retrieve the value of `data` in state storage, but is not able to call `f`. Contract `E` is derived from `C` and, thus, can call `compute`.
// This will not compile
pragma solidity ^0.4.0;
contract C {
 uint private data;
 function f(uint a) private returns(uint b) { return a + 1; }
 function setData(uint a) public { data \= a; }
 function getData() public returns(uint) { return data; }
 function compute(uint a, uint b) internal returns (uint) { return a+b; }
}
contract D {
 function readData() public {
 C c \= new C();
 uint local \= c.f(7); // error: member \`f\` is not visible
 c.setData(3);
 local \= c.getData();
 local \= c.compute(3, 5); // error: member \`compute\` is not visible
 }
}
contract E is C {
 function g() public {
 C c \= new C();
 uint val \= compute(3, 5); // access to internal member (from derived to parent contract)
 }
}
### Getter Functions[¶](#getter-functions "Permalink to this headline")
The compiler automatically creates getter functions for all **public** state variables. For the contract given below, the compiler will generate a function called `data` that does not take any arguments and returns a `uint`, the value of the state variable `data`. The initialization of state variables can be done at declaration.
pragma solidity ^0.4.0;
contract C {
 uint public data \= 42;
}
contract Caller {
 C c \= new C();
 function f() public {
 uint local \= c.data();
 }
}
The getter functions have external visibility. If the symbol is accessed internally (i.e. without `this.`), it is evaluated as a state variable. If it is accessed externally (i.e. with `this.`), it is evaluated as a function.
pragma solidity ^0.4.0;
contract C {
 uint public data;
 function x() public {
 data \= 3; // internal access
 uint val \= this.data(); // external access
 }
}
The next example is a bit more complex:
pragma solidity ^0.4.0;
contract Complex {
 struct Data {
 uint a;
 bytes3 b;
 mapping (uint \=> uint) map;
 }
 mapping (uint \=> mapping(bool \=> Data\[\])) public data;
}
It will generate a function of the following form:
function data(uint arg1, bool arg2, uint arg3) public returns (uint a, bytes3 b) {
 a \= data\[arg1\]\[arg2\]\[arg3\].a;
 b \= data\[arg1\]\[arg2\]\[arg3\].b;
}
Note that the mapping in the struct is omitted because there is no good way to provide the key for the mapping.
## Function Modifiers[¶](#function-modifiers "Permalink to this headline")
Modifiers can be used to easily change the behaviour of functions. For example, they can automatically check a condition prior to executing the function. Modifiers are inheritable properties of contracts and may be overridden by derived contracts.
pragma solidity ^0.4.22;
contract owned {
 function owned() public { owner \= msg.sender; }
 address owner;
 // This contract only defines a modifier but does not use
 // it: it will be used in derived contracts.
 // The function body is inserted where the special symbol
 // \`\_;\` in the definition of a modifier appears.
 // This means that if the owner calls this function, the
 // function is executed and otherwise, an exception is
 // thrown.
 modifier onlyOwner {
 require(
 msg.sender \== owner,
 "Only owner can call this function."
 );
 \_;
 }
}
contract mortal is owned {
 // This contract inherits the \`onlyOwner\` modifier from
 // \`owned\` and applies it to the \`close\` function, which
 // causes that calls to \`close\` only have an effect if
 // they are made by the stored owner.
 function close() public onlyOwner {
 selfdestruct(owner);
 }
}
contract priced {
 // Modifiers can receive arguments:
 modifier costs(uint price) {
 if (msg.value \>= price) {
 \_;
 }
 }
}
contract Register is priced, owned {
 mapping (address \=> bool) registeredAddresses;
 uint price;
 function Register(uint initialPrice) public { price \= initialPrice; }
 // It is important to also provide the
 // \`payable\` keyword here, otherwise the function will
 // automatically reject all Ether sent to it.
 function register() public payable costs(price) {
 registeredAddresses\[msg.sender\] \= true;
 }
 function changePrice(uint \_price) public onlyOwner {
 price \= \_price;
 }
}
contract Mutex {
 bool locked;
 modifier noReentrancy() {
 require(
 !locked,
 "Reentrant call."
 );
 locked \= true;
 \_;
 locked \= false;
 }
 /// This function is protected by a mutex, which means that
 /// reentrant calls from within \`msg.sender.call\` cannot call \`f\` again.
 /// The \`return 7\` statement assigns 7 to the return value but still
 /// executes the statement \`locked = false\` in the modifier.
 function f() public noReentrancy returns (uint) {
 require(msg.sender.call());
 return 7;
 }
}
Multiple modifiers are applied to a function by specifying them in a whitespace-separated list and are evaluated in the order presented.
Warning
In an earlier version of Solidity, `return` statements in functions having modifiers behaved differently.
Explicit returns from a modifier or function body only leave the current modifier or function body. Return variables are assigned and control flow continues after the “\_” in the preceding modifier.
Arbitrary expressions are allowed for modifier arguments and in this context, all symbols visible from the function are visible in the modifier. Symbols introduced in the modifier are not visible in the function (as they might change by overriding).
## Constant State Variables[¶](#constant-state-variables "Permalink to this headline")
State variables can be declared as `constant`. In this case, they have to be assigned from an expression which is a constant at compile time. Any expression that accesses storage, blockchain data (e.g. `now`, `this.balance` or `block.number`) or execution data (`msg.value` or `gasleft()`) or make calls to external contracts are disallowed. Expressions that might have a side-effect on memory allocation are allowed, but those that might have a side-effect on other memory objects are not. The built-in functions `keccak256`, `sha256`, `ripemd160`, `ecrecover`, `addmod` and `mulmod` are allowed (even though they do call external contracts).
The reason behind allowing side-effects on the memory allocator is that it should be possible to construct complex objects like e.g. lookup-tables. This feature is not yet fully usable.
The compiler does not reserve a storage slot for these variables, and every occurrence is replaced by the respective constant expression (which might be computed to a single value by the optimizer).
Not all types for constants are implemented at this time. The only supported types are value types and strings.
pragma solidity ^0.4.0;
contract C {
 uint constant x \= 32\*\*22 + 8;
 string constant text \= "abc";
 bytes32 constant myHash \= keccak256("abc");
}
## Functions[¶](#functions "Permalink to this headline")
### View Functions[¶](#view-functions "Permalink to this headline")
Functions can be declared `view` in which case they promise not to modify the state.
The following statements are considered modifying the state:
1. Writing to state variables.
2. [Emitting events](#events).
3. [Creating other contracts](https://docs.soliditylang.org/en/v0.4.26/control-structures.html#creating-contracts).
4. Using `selfdestruct`.
5. Sending Ether via calls.
6. Calling any function not marked `view` or `pure`.
7. Using low-level calls.
8. Using inline assembly that contains certain opcodes.
pragma solidity ^0.4.16;
contract C {
 function f(uint a, uint b) public view returns (uint) {
 return a \* (b + 42) + now;
 }
}
Note
`constant` on functions is an alias to `view`, but this is deprecated and will be dropped in version 0.5.0.
Note
Getter methods are marked `view`.
Note
If invalid explicit type conversions are used, state modifications are possible even though a `view` function was called. You can switch the compiler to use `STATICCALL` when calling such functions and thus prevent modifications to the state on the level of the EVM by adding `pragma experimental "v0.5.0";`
Warning
The compiler does not enforce yet that a `view` method is not modifying state. It raises a warning though.
### Pure Functions[¶](#pure-functions "Permalink to this headline")
Functions can be declared `pure` in which case they promise not to read from or modify the state.
In addition to the list of state modifying statements explained above, the following are considered reading from the state:
1. Reading from state variables.
2. Accessing `this.balance` or `<address>.balance`.
3. Accessing any of the members of `block`, `tx`, `msg` (with the exception of `msg.sig` and `msg.data`).
4. Calling any function not marked `pure`.
5. Using inline assembly that contains certain opcodes.
pragma solidity ^0.4.16;
contract C {
 function f(uint a, uint b) public pure returns (uint) {
 return a \* (b + 42);
 }
}
Note
If invalid explicit type conversions are used, state modifications are possible even though a `pure` function was called. You can switch the compiler to use `STATICCALL` when calling such functions and thus prevent modifications to the state on the level of the EVM by adding `pragma experimental "v0.5.0";`
Warning
It is not possible to prevent functions from reading the state at the level of the EVM, it is only possible to prevent them from writing to the state (i.e. only `view` can be enforced at the EVM level, `pure` can not).
Warning
Before version 0.4.17 the compiler didn’t enforce that `pure` is not reading the state.
### Fallback Function[¶](#fallback-function "Permalink to this headline")
A contract can have exactly one unnamed function. This function cannot have arguments and cannot return anything. It is executed on a call to the contract if none of the other functions match the given function identifier (or if no data was supplied at all).
Furthermore, this function is executed whenever the contract receives plain Ether (without data). Additionally, in order to receive Ether, the fallback function must be marked `payable`. If no such function exists, the contract cannot receive Ether through regular transactions.
In the worst case, the fallback function can only rely on 2300 gas being available (for example when send or transfer is used), leaving not much room to perform other operations except basic logging. The following operations will consume more gas than the 2300 gas stipend:
* Writing to storage
* Creating a contract
* Calling an external function which consumes a large amount of gas
* Sending Ether
Like any function, the fallback function can execute complex operations as long as there is enough gas passed on to it.
Note
Even though the fallback function cannot have arguments, one can still use `msg.data` to retrieve any payload supplied with the call.
Warning
Contracts that receive Ether directly (without a function call, i.e. using `send` or `transfer`) but do not define a fallback function throw an exception, sending back the Ether (this was different before Solidity v0.4.0). So if you want your contract to receive Ether, you have to implement a fallback function.
Warning
A contract without a payable fallback function can receive Ether as a recipient of a coinbase transaction (aka miner block reward) or as a destination of a `selfdestruct`.
A contract cannot react to such Ether transfers and thus also cannot reject them. This is a design choice of the EVM and Solidity cannot work around it.
It also means that `this.balance` can be higher than the sum of some manual accounting implemented in a contract (i.e. having a counter updated in the fallback function).
pragma solidity ^0.4.0;
contract Test {
 // This function is called for all messages sent to
 // this contract (there is no other function).
 // Sending Ether to this contract will cause an exception,
 // because the fallback function does not have the \`payable\`
 // modifier.
 function() public { x \= 1; }
 uint x;
}
// This contract keeps all Ether sent to it with no way
// to get it back.
contract Sink {
 function() public payable { }
}
contract Caller {
 function callTest(Test test) public {
 test.call(0xabcdef01); // hash does not exist
 // results in test.x becoming == 1.
 // The following will not compile, but even
 // if someone sends ether to that contract,
 // the transaction will fail and reject the
 // Ether.
 //test.send(2 ether);
 }
}
### Function Overloading[¶](#function-overloading "Permalink to this headline")
A Contract can have multiple functions of the same name but with different arguments. This also applies to inherited functions. The following example shows overloading of the `f` function in the scope of contract `A`.
pragma solidity ^0.4.16;
contract A {
 function f(uint \_in) public pure returns (uint out) {
 out \= 1;
 }
 function f(uint \_in, bytes32 \_key) public pure returns (uint out) {
 out \= 2;
 }
}
Overloaded functions are also present in the external interface. It is an error if two externally visible functions differ by their Solidity types but not by their external types.
// This will not compile
pragma solidity ^0.4.16;
contract A {
 function f(B \_in) public pure returns (B out) {
 out \= \_in;
 }
 function f(address \_in) public pure returns (address out) {
 out \= \_in;
 }
}
contract B {
}
Both `f` function overloads above end up accepting the address type for the ABI although they are considered different inside Solidity.
#### Overload resolution and Argument matching[¶](#overload-resolution-and-argument-matching "Permalink to this headline")
Overloaded functions are selected by matching the function declarations in the current scope to the arguments supplied in the function call. Functions are selected as overload candidates if all arguments can be implicitly converted to the expected types. If there is not exactly one candidate, resolution fails.
Note
Return parameters are not taken into account for overload resolution.
pragma solidity ^0.4.16;
contract A {
 function f(uint8 \_in) public pure returns (uint8 out) {
 out \= \_in;
 }
 function f(uint256 \_in) public pure returns (uint256 out) {
 out \= \_in;
 }
}
Calling `f(50)` would create a type error since `50` can be implicitly converted both to `uint8` and `uint256` types. On another hand `f(256)` would resolve to `f(uint256)` overload as `256` cannot be implicitly converted to `uint8`.
## Events[¶](#events "Permalink to this headline")
Events allow the convenient usage of the EVM logging facilities, which in turn can be used to “call” JavaScript callbacks in the user interface of a dapp, which listen for these events.
Events are inheritable members of contracts. When they are called, they cause the arguments to be stored in the transaction’s log - a special data structure in the blockchain. These logs are associated with the address of the contract and will be incorporated into the blockchain and stay there as long as a block is accessible (forever as of Frontier and Homestead, but this might change with Serenity). Log and event data is not accessible from within contracts (not even from the contract that created them).
SPV proofs for logs are possible, so if an external entity supplies a contract with such a proof, it can check that the log actually exists inside the blockchain. But be aware that block headers have to be supplied because the contract can only see the last 256 block hashes.
Up to three parameters can receive the attribute `indexed` which will cause the respective arguments to be searched for: It is possible to filter for specific values of indexed arguments in the user interface.
If arrays (including `string` and `bytes`) are used as indexed arguments, the Keccak-256 hash of it is stored as topic instead.
The hash of the signature of the event is one of the topics except if you declared the event with `anonymous` specifier. This means that it is not possible to filter for specific anonymous events by name.
All non-indexed arguments will be stored in the data part of the log.
Note
Indexed arguments will not be stored themselves. You can only search for the values, but it is impossible to retrieve the values themselves.
pragma solidity ^0.4.0;
contract ClientReceipt {
 event Deposit(
 address indexed \_from,
 bytes32 indexed \_id,
 uint \_value
 );
 function deposit(bytes32 \_id) public payable {
 // Events are emitted using \`emit\`, followed by
 // the name of the event and the arguments
 // (if any) in parentheses. Any such invocation
 // (even deeply nested) can be detected from
 // the JavaScript API by filtering for \`Deposit\`.
 emit Deposit(msg.sender, \_id, msg.value);
 }
}
The use in the JavaScript API would be as follows:
var abi \= /\* abi as generated by the compiler \*/;
var ClientReceipt \= web3.eth.contract(abi);
var clientReceipt \= ClientReceipt.at("0x1234...ab67" /\* address \*/);
var event \= clientReceipt.Deposit();
// watch for changes
event.watch(function(error, result){
 // result will contain various information
 // including the argumets given to the \`Deposit\`
 // call.
 if (!error)
 console.log(result);
});
// Or pass a callback to start watching immediately
var event \= clientReceipt.Deposit(function(error, result) {
 if (!error)
 console.log(result);
});
### Low-Level Interface to Logs[¶](#low-level-interface-to-logs "Permalink to this headline")
It is also possible to access the low-level interface to the logging mechanism via the functions `log0`, `log1`, `log2`, `log3` and `log4`. `logi` takes `i + 1` parameter of type `bytes32`, where the first argument will be used for the data part of the log and the others as topics. The event call above can be performed in the same way as
pragma solidity ^0.4.10;
contract C {
 function f() public payable {
 bytes32 \_id \= 0x420042;
 log3(
 bytes32(msg.value),
 bytes32(0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20),
 bytes32(msg.sender),
 \_id
 );
 }
}
where the long hexadecimal number is equal to `keccak256("Deposit(address,bytes32,uint256)")`, the signature of the event.
## Inheritance[¶](#inheritance "Permalink to this headline")
Solidity supports multiple inheritance by copying code including polymorphism.
All function calls are virtual, which means that the most derived function is called, except when the contract name is explicitly given.
When a contract inherits from multiple contracts, only a single contract is created on the blockchain, and the code from all the base contracts is copied into the created contract.
The general inheritance system is very similar to [Python’s](https://docs.python.org/3/tutorial/classes.html#inheritance), especially concerning multiple inheritance.
Details are given in the following example.
pragma solidity ^0.4.22;
contract owned {
 constructor() { owner \= msg.sender; }
 address owner;
}
// Use \`is\` to derive from another contract. Derived
// contracts can access all non-private members including
// internal functions and state variables. These cannot be
// accessed externally via \`this\`, though.
contract mortal is owned {
 function kill() {
 if (msg.sender \== owner) selfdestruct(owner);
 }
}
// These abstract contracts are only provided to make the
// interface known to the compiler. Note the function
// without body. If a contract does not implement all
// functions it can only be used as an interface.
contract Config {
 function lookup(uint id) public returns (address adr);
}
contract NameReg {
 function register(bytes32 name) public;
 function unregister() public;
 }
// Multiple inheritance is possible. Note that \`owned\` is
// also a base class of \`mortal\`, yet there is only a single
// instance of \`owned\` (as for virtual inheritance in C++).
contract named is owned, mortal {
 constructor(bytes32 name) {
 Config config \= Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
 NameReg(config.lookup(1)).register(name);
 }
 // Functions can be overridden by another function with the same name and
 // the same number/types of inputs. If the overriding function has different
 // types of output parameters, that causes an error.
 // Both local and message-based function calls take these overrides
 // into account.
 function kill() public {
 if (msg.sender \== owner) {
 Config config \= Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
 NameReg(config.lookup(1)).unregister();
 // It is still possible to call a specific
 // overridden function.
 mortal.kill();
 }
 }
}
// If a constructor takes an argument, it needs to be
// provided in the header (or modifier-invocation-style at
// the constructor of the derived contract (see below)).
contract PriceFeed is owned, mortal, named("GoldFeed") {
 function updateInfo(uint newInfo) public {
 if (msg.sender \== owner) info \= newInfo;
 }
 function get() public view returns(uint r) { return info; }
 uint info;
}
Note that above, we call `mortal.kill()` to “forward” the destruction request. The way this is done is problematic, as seen in the following example:
pragma solidity ^0.4.22;
contract owned {
 constructor() public { owner \= msg.sender; }
 address owner;
}
contract mortal is owned {
 function kill() public {
 if (msg.sender \== owner) selfdestruct(owner);
 }
}
contract Base1 is mortal {
 function kill() public { /\* do cleanup 1 \*/ mortal.kill(); }
}
contract Base2 is mortal {
 function kill() public { /\* do cleanup 2 \*/ mortal.kill(); }
}
contract Final is Base1, Base2 {
}
A call to `Final.kill()` will call `Base2.kill` as the most derived override, but this function will bypass `Base1.kill`, basically because it does not even know about `Base1`. The way around this is to use `super`:
pragma solidity ^0.4.22;
contract owned {
 constructor() public { owner \= msg.sender; }
 address owner;
}
contract mortal is owned {
 function kill() public {
 if (msg.sender \== owner) selfdestruct(owner);
 }
}
contract Base1 is mortal {
 function kill() public { /\* do cleanup 1 \*/ super.kill(); }
}
contract Base2 is mortal {
 function kill() public { /\* do cleanup 2 \*/ super.kill(); }
}
contract Final is Base1, Base2 {
}
If `Base2` calls a function of `super`, it does not simply call this function on one of its base contracts. Rather, it calls this function on the next base contract in the final inheritance graph, so it will call `Base1.kill()` (note that the final inheritance sequence is – starting with the most derived contract: Final, Base2, Base1, mortal, owned). The actual function that is called when using super is not known in the context of the class where it is used, although its type is known. This is similar for ordinary virtual method lookup.
### Constructors[¶](#constructors "Permalink to this headline")
A constructor is an optional function declared with the `constructor` keyword which is executed upon contract creation. Constructor functions can be either `public` or `internal`. If there is no constructor, the contract will assume the default constructor: `contructor() public {}`.
pragma solidity ^0.4.22;
contract A {
 uint public a;
 constructor(uint \_a) internal {
 a \= \_a;
 }
}
contract B is A(1) {
 constructor() public {}
}
A constructor set as `internal` causes the contract to be marked as [abstract](#abstract-contract).
Note
Prior to version 0.4.22, constructors were defined as functions with the same name as the contract. This syntax is now deprecated.
pragma solidity ^0.4.11;
contract A {
 uint public a;
 function A(uint \_a) internal {
 a \= \_a;
 }
}
contract B is A(1) {
 function B() public {}
}
### Arguments for Base Constructors[¶](#arguments-for-base-constructors "Permalink to this headline")
The constructors of all the base contracts will be called following the linearization rules explained below. If the base constructors have arguments, derived contracts need to specify all of them. This can be done in two ways:
pragma solidity ^0.4.22;
contract Base {
 uint x;
 constructor(uint \_x) public { x \= \_x; }
}
contract Derived1 is Base(7) {
 constructor(uint \_y) public {}
}
contract Derived2 is Base {
 constructor(uint \_y) Base(\_y \* \_y) public {}
}
One way is directly in the inheritance list (`is Base(7)`). The other is in the way a modifier would be invoked as part of the header of the derived constructor (`Base(_y * _y)`). The first way to do it is more convenient if the constructor argument is a constant and defines the behaviour of the contract or describes it. The second way has to be used if the constructor arguments of the base depend on those of the derived contract. Arguments have to be given either in the inheritance list or in modifier-style in the derived constuctor. Specifying arguments in both places is an error.
If a derived contract doesn’t specify the arguments to all of its base contracts’ constructors, it will be abstract.
### Multiple Inheritance and Linearization[¶](#multiple-inheritance-and-linearization "Permalink to this headline")
Languages that allow multiple inheritance have to deal with several problems. One is the [Diamond Problem](https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem). Solidity is similar to Python in that it uses “[C3 Linearization](https://en.wikipedia.org/wiki/C3_linearization)” to force a specific order in the DAG of base classes. This results in the desirable property of monotonicity but disallows some inheritance graphs. Especially, the order in which the base classes are given in the `is` directive is important: You have to list the direct base contracts in the order from “most base-like” to “most derived”. Note that this order is different from the one used in Python. In the following code, Solidity will give the error “Linearization of inheritance graph impossible”.
// This will not compile
pragma solidity ^0.4.0;
contract X {}
contract A is X {}
contract C is A, X {}
The reason for this is that `C` requests `X` to override `A` (by specifying `A, X` in this order), but `A` itself requests to override `X`, which is a contradiction that cannot be resolved.
### Inheriting Different Kinds of Members of the Same Name[¶](#inheriting-different-kinds-of-members-of-the-same-name "Permalink to this headline")
When the inheritance results in a contract with a function and a modifier of the same name, it is considered as an error. This error is produced also by an event and a modifier of the same name, and a function and an event of the same name. As an exception, a state variable getter can override a public function.
## Abstract Contracts[¶](#abstract-contracts "Permalink to this headline")
Contracts are marked as abstract when at least one of their functions lacks an implementation as in the following example (note that the function declaration header is terminated by `;`):
pragma solidity ^0.4.0;
contract Feline {
 function utterance() public returns (bytes32);
}
Such contracts cannot be compiled (even if they contain implemented functions alongside non-implemented functions), but they can be used as base contracts:
pragma solidity ^0.4.0;
contract Feline {
 function utterance() public returns (bytes32);
}
contract Cat is Feline {
 function utterance() public returns (bytes32) { return "miaow"; }
}
If a contract inherits from an abstract contract and does not implement all non-implemented functions by overriding, it will itself be abstract.
Note that a function without implementation is different from a [Function Type](https://docs.soliditylang.org/en/v0.4.26/types.html#function-types) even though their syntax looks very similar.
Example of function without implementation (a function declaration):
function foo(address) external returns (address);
Example of a Function Type (a variable declaration, where the variable is of type `function`):
function(address) external returns (address) foo;
Abstract contracts decouple the definition of a contract from its implementation providing better extensibility and self-documentation and facilitating patterns like the [Template method](https://en.wikipedia.org/wiki/Template_method_pattern) and removing code duplication. Abstract contracts are useful in the same way that defining methods in an interface is useful. It is a way for the designer of the abstract contract to say “any child of mine must implement this method”.
## Interfaces[¶](#interfaces "Permalink to this headline")
Interfaces are similar to abstract contracts, but they cannot have any functions implemented. There are further restrictions:
1. Cannot inherit other contracts or interfaces.
2. Cannot define constructor.
3. Cannot define variables.
4. Cannot define structs.
5. Cannot define enums.
Some of these restrictions might be lifted in the future.
Interfaces are basically limited to what the Contract ABI can represent, and the conversion between the ABI and an Interface should be possible without any information loss.
Interfaces are denoted by their own keyword:
pragma solidity ^0.4.11;
interface Token {
 function transfer(address recipient, uint amount) public;
}
Contracts can inherit interfaces as they would inherit other contracts.
## Libraries[¶](#libraries "Permalink to this headline")
Libraries are similar to contracts, but their purpose is that they are deployed only once at a specific address and their code is reused using the `DELEGATECALL` (`CALLCODE` until Homestead) feature of the EVM. This means that if library functions are called, their code is executed in the context of the calling contract, i.e. `this` points to the calling contract, and especially the storage from the calling contract can be accessed. As a library is an isolated piece of source code, it can only access state variables of the calling contract if they are explicitly supplied (it would have no way to name them, otherwise). Library functions can only be called directly (i.e. without the use of `DELEGATECALL`) if they do not modify the state (i.e. if they are `view` or `pure` functions), because libraries are assumed to be stateless. In particular, it is not possible to destroy a library unless Solidity’s type system is circumvented.
Libraries can be seen as implicit base contracts of the contracts that use them. They will not be explicitly visible in the inheritance hierarchy, but calls to library functions look just like calls to functions of explicit base contracts (`L.f()` if `L` is the name of the library). Furthermore, `internal` functions of libraries are visible in all contracts, just as if the library were a base contract. Of course, calls to internal functions use the internal calling convention, which means that all internal types can be passed and memory types will be passed by reference and not copied. To realize this in the EVM, code of internal library functions and all functions called from therein will at compile time be pulled into the calling contract, and a regular `JUMP` call will be used instead of a `DELEGATECALL`.
The following example illustrates how to use libraries (but be sure to check out [using for](#using-for) for a more advanced example to implement a set).
pragma solidity ^0.4.22;
library Set {
 // We define a new struct datatype that will be used to
 // hold its data in the calling contract.
 struct Data { mapping(uint \=> bool) flags; }
 // Note that the first parameter is of type "storage
 // reference" and thus only its storage address and not
 // its contents is passed as part of the call. This is a
 // special feature of library functions. It is idiomatic
 // to call the first parameter \`self\`, if the function can
 // be seen as a method of that object.
 function insert(Data storage self, uint value)
 public
 returns (bool)
 {
 if (self.flags\[value\])
 return false; // already there
 self.flags\[value\] \= true;
 return true;
 }
 function remove(Data storage self, uint value)
 public
 returns (bool)
 {
 if (!self.flags\[value\])
 return false; // not there
 self.flags\[value\] \= false;
 return true;
 }
 function contains(Data storage self, uint value)
 public
 view
 returns (bool)
 {
 return self.flags\[value\];
 }
}
contract C {
 Set.Data knownValues;
 function register(uint value) public {
 // The library functions can be called without a
 // specific instance of the library, since the
 // "instance" will be the current contract.
 require(Set.insert(knownValues, value));
 }
 // In this contract, we can also directly access knownValues.flags, if we want.
}
Of course, you do not have to follow this way to use libraries: they can also be used without defining struct data types. Functions also work without any storage reference parameters, and they can have multiple storage reference parameters and in any position.
The calls to `Set.contains`, `Set.insert` and `Set.remove` are all compiled as calls (`DELEGATECALL`) to an external contract/library. If you use libraries, take care that an actual external function call is performed. `msg.sender`, `msg.value` and `this` will retain their values in this call, though (prior to Homestead, because of the use of `CALLCODE`, `msg.sender` and `msg.value` changed, though).
The following example shows how to use memory types and internal functions in libraries in order to implement custom types without the overhead of external function calls:
pragma solidity ^0.4.16;
library BigInt {
 struct bigint {
 uint\[\] limbs;
 }
 function fromUint(uint x) internal pure returns (bigint r) {
 r.limbs \= new uint\[\](1);
 r.limbs\[0\] \= x;
 }
 function add(bigint \_a, bigint \_b) internal pure returns (bigint r) {
 r.limbs \= new uint\[\](max(\_a.limbs.length, \_b.limbs.length));
 uint carry \= 0;
 for (uint i \= 0; i < r.limbs.length; ++i) {
 uint a \= limb(\_a, i);
 uint b \= limb(\_b, i);
 r.limbs\[i\] \= a + b + carry;
 if (a + b < a || (a + b \== uint(\-1) && carry \> 0))
 carry \= 1;
 else
 carry \= 0;
 }
 if (carry \> 0) {
 // too bad, we have to add a limb
 uint\[\] memory newLimbs \= new uint\[\](r.limbs.length + 1);
 for (i \= 0; i < r.limbs.length; ++i)
 newLimbs\[i\] \= r.limbs\[i\];
 newLimbs\[i\] \= carry;
 r.limbs \= newLimbs;
 }
 }
 function limb(bigint \_a, uint \_limb) internal pure returns (uint) {
 return \_limb < \_a.limbs.length ? \_a.limbs\[\_limb\] : 0;
 }
 function max(uint a, uint b) private pure returns (uint) {
 return a \> b ? a : b;
 }
}
contract C {
 using BigInt for BigInt.bigint;
 function f() public pure {
 var x \= BigInt.fromUint(7);
 var y \= BigInt.fromUint(uint(\-1));
 var z \= x.add(y);
 }
}
As the compiler cannot know where the library will be deployed at, these addresses have to be filled into the final bytecode by a linker (see [Using the Commandline Compiler](https://docs.soliditylang.org/en/v0.4.26/using-the-compiler.html#commandline-compiler) for how to use the commandline compiler for linking). If the addresses are not given as arguments to the compiler, the compiled hex code will contain placeholders of the form `__Set______` (where `Set` is the name of the library). The address can be filled manually by replacing all those 40 symbols by the hex encoding of the address of the library contract.
Restrictions for libraries in comparison to contracts:
* No state variables
* Cannot inherit nor be inherited
* Cannot receive Ether
(These might be lifted at a later point.)
### Call Protection For Libraries[¶](#call-protection-for-libraries "Permalink to this headline")
As mentioned in the introduction, if a library’s code is executed using a `CALL` instead of a `DELEGATECALL` or `CALLCODE`, it will revert unless a `view` or `pure` function is called.
The EVM does not provide a direct way for a contract to detect whether it was called using `CALL` or not, but a contract can use the `ADDRESS` opcode to find out “where” it is currently running. The generated code compares this address to the address used at construction time to determine the mode of calling.
More specifically, the runtime code of a library always starts with a push instruction, which is a zero of 20 bytes at compilation time. When the deploy code runs, this constant is replaced in memory by the current address and this modified code is stored in the contract. At runtime, this causes the deploy time address to be the first constant to be pushed onto the stack and the dispatcher code compares the current address against this constant for any non-view and non-pure function.
## Using For[¶](#using-for "Permalink to this headline")
The directive `using A for B;` can be used to attach library functions (from the library `A`) to any type (`B`). These functions will receive the object they are called on as their first parameter (like the `self` variable in Python).
The effect of `using A for *;` is that the functions from the library `A` are attached to any type.
In both situations, all functions, even those where the type of the first parameter does not match the type of the object, are attached. The type is checked at the point the function is called and function overload resolution is performed.
The `using A for B;` directive is active for the current scope, which is limited to a contract for now but will be lifted to the global scope later, so that by including a module, its data types including library functions are available without having to add further code.
Let us rewrite the set example from the [Libraries](#libraries) in this way:
pragma solidity ^0.4.16;
// This is the same code as before, just without comments
library Set {
 struct Data { mapping(uint \=> bool) flags; }
 function insert(Data storage self, uint value)
 public
 returns (bool)
 {
 if (self.flags\[value\])
 return false; // already there
 self.flags\[value\] \= true;
 return true;
 }
 function remove(Data storage self, uint value)
 public
 returns (bool)
 {
 if (!self.flags\[value\])
 return false; // not there
 self.flags\[value\] \= false;
 return true;
 }
 function contains(Data storage self, uint value)
 public
 view
 returns (bool)
 {
 return self.flags\[value\];
 }
}
contract C {
 using Set for Set.Data; // this is the crucial change
 Set.Data knownValues;
 function register(uint value) public {
 // Here, all variables of type Set.Data have
 // corresponding member functions.
 // The following function call is identical to
 // \`Set.insert(knownValues, value)\`
 require(knownValues.insert(value));
 }
}
It is also possible to extend elementary types in that way:
pragma solidity ^0.4.16;
library Search {
 function indexOf(uint\[\] storage self, uint value)
 public
 view
 returns (uint)
 {
 for (uint i \= 0; i < self.length; i++)
 if (self\[i\] \== value) return i;
 return uint(\-1);
 }
}
contract C {
 using Search for uint\[\];
 uint\[\] data;
 function append(uint value) public {
 data.push(value);
 }
 function replace(uint \_old, uint \_new) public {
 // This performs the library function call
 uint index \= data.indexOf(\_old);
 if (index \== uint(\-1))
 data.push(\_new);
 else
 data\[index\] \= \_new;
 }
}
Note that all library calls are actual EVM function calls. This means that if you pass memory or value types, a copy will be performed, even of the `self` variable. The only situation where no copy will be performed is when storage reference variables are used.

# [Introduction to Smart Contracts — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html) 
 _https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html_

## A Simple Smart Contract[](#a-simple-smart-contract "Link to this heading")
Let us begin with a basic example that sets the value of a variable and exposes it for other contracts to access. It is fine if you do not understand everything right now, we will go into more details later.
### Storage Example[](#storage-example "Link to this heading")
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZVN0b3JhZ2UgewogICAgdWludCBzdG9yZWREYXRhOwoKICAgIGZ1bmN0aW9uIHNldCh1aW50IHgpIHB1YmxpYyB7CiAgICAgICAgc3RvcmVkRGF0YSA9IHg7CiAgICB9CgogICAgZnVuY3Rpb24gZ2V0KCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBzdG9yZWREYXRhOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract SimpleStorage {
 uint storedData;
 function set(uint x) public {
 storedData \= x;
 }
 function get() public view returns (uint) {
 return storedData;
 }
}
The first line tells you that the source code is licensed under the GPL version 3.0. Machine-readable license specifiers are important in a setting where publishing the source code is the default.
The next line specifies that the source code is written for Solidity version 0.4.16, or a newer version of the language up to, but not including version 0.9.0. This is to ensure that the contract is not compilable with a new (breaking) compiler version, where it could behave differently. [Pragmas](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#pragma) are common instructions for compilers about how to treat the source code (e.g. [pragma once](https://en.wikipedia.org/wiki/Pragma_once)).
A contract in the sense of Solidity is a collection of code (its _functions_) and data (its _state_) that resides at a specific address on the Ethereum blockchain. The line `uint storedData;` declares a state variable called `storedData` of type `uint` (_u_nsigned _int_eger of _256_ bits). You can think of it as a single slot in a database that you can query and alter by calling functions of the code that manages the database. In this example, the contract defines the functions `set` and `get` that can be used to modify or retrieve the value of the variable.
To access a member (like a state variable) of the current contract, you do not typically add the `this.` prefix, you just access it directly via its name. Unlike in some other languages, omitting it is not just a matter of style, it results in a completely different way to access the member, but more on this later.
This contract does not do much yet apart from (due to the infrastructure built by Ethereum) allowing anyone to store a single number that is accessible by anyone in the world without a (feasible) way to prevent you from publishing this number. Anyone could call `set` again with a different value and overwrite your number, but the number is still stored in the history of the blockchain. Later, you will see how you can impose access restrictions so that only you can alter the number.
Warning
Be careful with using Unicode text, as similar looking (or even identical) characters can have different code points and as such are encoded as a different byte array.
Note
All identifiers (contract names, function names and variable names) are restricted to the ASCII character set. It is possible to store UTF-8 encoded data in string variables.
### Subcurrency Example[](#subcurrency-example "Link to this heading")
The following contract implements the simplest form of a cryptocurrency. The contract allows only its creator to create new coins (different issuance schemes are possible). Anyone can send coins to each other without a need for registering with a username and password, all you need is an Ethereum keypair.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjY7CgovLyBUaGlzIHdpbGwgb25seSBjb21waWxlIHZpYSBJUgpjb250cmFjdCBDb2luIHsKICAgIC8vIFRoZSBrZXl3b3JkICJwdWJsaWMiIG1ha2VzIHZhcmlhYmxlcwogICAgLy8gYWNjZXNzaWJsZSBmcm9tIG90aGVyIGNvbnRyYWN0cwogICAgYWRkcmVzcyBwdWJsaWMgbWludGVyOwogICAgbWFwcGluZyhhZGRyZXNzID0+IHVpbnQpIHB1YmxpYyBiYWxhbmNlczsKCiAgICAvLyBFdmVudHMgYWxsb3cgY2xpZW50cyB0byByZWFjdCB0byBzcGVjaWZpYwogICAgLy8gY29udHJhY3QgY2hhbmdlcyB5b3UgZGVjbGFyZQogICAgZXZlbnQgU2VudChhZGRyZXNzIGZyb20sIGFkZHJlc3MgdG8sIHVpbnQgYW1vdW50KTsKCiAgICAvLyBDb25zdHJ1Y3RvciBjb2RlIGlzIG9ubHkgcnVuIHdoZW4gdGhlIGNvbnRyYWN0CiAgICAvLyBpcyBjcmVhdGVkCiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgICBtaW50ZXIgPSBtc2cuc2VuZGVyOwogICAgfQoKICAgIC8vIFNlbmRzIGFuIGFtb3VudCBvZiBuZXdseSBjcmVhdGVkIGNvaW5zIHRvIGFuIGFkZHJlc3MKICAgIC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSB0aGUgY29udHJhY3QgY3JlYXRvcgogICAgZnVuY3Rpb24gbWludChhZGRyZXNzIHJlY2VpdmVyLCB1aW50IGFtb3VudCkgcHVibGljIHsKICAgICAgICByZXF1aXJlKG1zZy5zZW5kZXIgPT0gbWludGVyKTsKICAgICAgICBiYWxhbmNlc1tyZWNlaXZlcl0gKz0gYW1vdW50OwogICAgfQoKICAgIC8vIEVycm9ycyBhbGxvdyB5b3UgdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dAogICAgLy8gd2h5IGFuIG9wZXJhdGlvbiBmYWlsZWQuIFRoZXkgYXJlIHJldHVybmVkCiAgICAvLyB0byB0aGUgY2FsbGVyIG9mIHRoZSBmdW5jdGlvbi4KICAgIGVycm9yIEluc3VmZmljaWVudEJhbGFuY2UodWludCByZXF1ZXN0ZWQsIHVpbnQgYXZhaWxhYmxlKTsKCiAgICAvLyBTZW5kcyBhbiBhbW91bnQgb2YgZXhpc3RpbmcgY29pbnMKICAgIC8vIGZyb20gYW55IGNhbGxlciB0byBhbiBhZGRyZXNzCiAgICBmdW5jdGlvbiBzZW5kKGFkZHJlc3MgcmVjZWl2ZXIsIHVpbnQgYW1vdW50KSBwdWJsaWMgewogICAgICAgIHJlcXVpcmUoYW1vdW50IDw9IGJhbGFuY2VzW21zZy5zZW5kZXJdLCBJbnN1ZmZpY2llbnRCYWxhbmNlKGFtb3VudCwgYmFsYW5jZXNbbXNnLnNlbmRlcl0pKTsKICAgICAgICBiYWxhbmNlc1ttc2cuc2VuZGVyXSAtPSBhbW91bnQ7CiAgICAgICAgYmFsYW5jZXNbcmVjZWl2ZXJdICs9IGFtb3VudDsKICAgICAgICBlbWl0IFNlbnQobXNnLnNlbmRlciwgcmVjZWl2ZXIsIGFtb3VudCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.26;
// This will only compile via IR
contract Coin {
 // The keyword "public" makes variables
 // accessible from other contracts
 address public minter;
 mapping(address \=> uint) public balances;
 // Events allow clients to react to specific
 // contract changes you declare
 event Sent(address from, address to, uint amount);
 // Constructor code is only run when the contract
 // is created
 constructor() {
 minter \= msg.sender;
 }
 // Sends an amount of newly created coins to an address
 // Can only be called by the contract creator
 function mint(address receiver, uint amount) public {
 require(msg.sender \== minter);
 balances\[receiver\] += amount;
 }
 // Errors allow you to provide information about
 // why an operation failed. They are returned
 // to the caller of the function.
 error InsufficientBalance(uint requested, uint available);
 // Sends an amount of existing coins
 // from any caller to an address
 function send(address receiver, uint amount) public {
 require(amount <= balances\[msg.sender\], InsufficientBalance(amount, balances\[msg.sender\]));
 balances\[msg.sender\] \-= amount;
 balances\[receiver\] += amount;
 emit Sent(msg.sender, receiver, amount);
 }
}
This contract introduces some new concepts, let us go through them one by one.
The line `address public minter;` declares a state variable of type [address](https://docs.soliditylang.org/en/v0.8.30/types.html#address). The `address` type is a 160-bit value that does not allow any arithmetic operations. It is suitable for storing addresses of contracts, or a hash of the public half of a keypair belonging to [external accounts](#accounts).
The keyword `public` automatically generates a function that allows you to access the current value of the state variable from outside of the contract. Without this keyword, other contracts have no way to access the variable. The code of the function generated by the compiler is equivalent to the following (ignore `external` and `view` for now):
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=ZnVuY3Rpb24gbWludGVyKCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChhZGRyZXNzKSB7IHJldHVybiBtaW50ZXI7IH0=)
function minter() external view returns (address) { return minter; }
You could add a function like the above yourself, but you would have a function and state variable with the same name. You do not need to do this, the compiler figures it out for you.
The next line, `mapping(address => uint) public balances;` also creates a public state variable, but it is a more complex datatype. The [mapping](https://docs.soliditylang.org/en/v0.8.30/types.html#mapping-types) type maps addresses to [unsigned integers](https://docs.soliditylang.org/en/v0.8.30/types.html#integers).
Mappings can be seen as [hash tables](https://en.wikipedia.org/wiki/Hash_table) which are virtually initialized such that every possible key exists from the start and is mapped to a value whose byte-representation is all zeros. However, it is neither possible to obtain a list of all keys of a mapping, nor a list of all values. Record what you added to the mapping, or use it in a context where this is not needed. Or even better, keep a list, or use a more suitable data type.
The [getter function](https://docs.soliditylang.org/en/v0.8.30/contracts.html#getter-functions) created by the `public` keyword is more complex in the case of a mapping. It looks like the following:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=ZnVuY3Rpb24gYmFsYW5jZXMoYWRkcmVzcyBhY2NvdW50KSBleHRlcm5hbCB2aWV3IHJldHVybnMgKHVpbnQpIHsKICAgIHJldHVybiBiYWxhbmNlc1thY2NvdW50XTsKfQ==)
function balances(address account) external view returns (uint) {
 return balances\[account\];
}
You can use this function to query the balance of a single account.
The line `event Sent(address from, address to, uint amount);` declares an [“event”](https://docs.soliditylang.org/en/v0.8.30/contracts.html#events), which is emitted in the last line of the function `send`. Ethereum clients such as web applications can listen for these events emitted on the blockchain without much cost. As soon as it is emitted, the listener receives the arguments `from`, `to` and `amount`, which makes it possible to track transactions.
To listen for this event, you could use the following JavaScript code, which uses [web3.js](https://github.com/web3/web3.js/) to create the `Coin` contract object, and any user interface calls the automatically generated `balances` function from above:
Coin.Sent().watch({}, '', function(error, result) {
 if (!error) {
 console.log("Coin transfer: " + result.args.amount +
 " coins were sent from " + result.args.from +
 " to " + result.args.to + ".");
 console.log("Balances now:\\n" +
 "Sender: " + Coin.balances.call(result.args.from) +
 "Receiver: " + Coin.balances.call(result.args.to));
 }
})
The [constructor](https://docs.soliditylang.org/en/v0.8.30/contracts.html#constructor) is a special function that is executed during the creation of the contract and cannot be called afterwards. In this case, it permanently stores the address of the person creating the contract. The `msg` variable (together with `tx` and `block`) is a [special global variable](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#special-variables-functions) that contains properties which allow access to the blockchain. `msg.sender` is always the address where the current (external) function call came from.
The functions that make up the contract, and that users and contracts can call are `mint` and `send`.
The `mint` function sends an amount of newly created coins to another address. The [require](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#assert-and-require) function call defines conditions that reverts all changes if not met. In this example, `require(msg.sender == minter);` ensures that only the creator of the contract can call `mint`. In general, the creator can mint as many tokens as they like, but at some point, this will lead to a phenomenon called “overflow”. Note that because of the default [Checked arithmetic](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#unchecked), the transaction would revert if the expression `balances[receiver] += amount;` overflows, i.e., when `balances[receiver] + amount` in arbitrary precision arithmetic is larger than the maximum value of `uint` (`2**256 - 1`). This is also true for the statement `balances[receiver] += amount;` in the function `send`.
[Errors](https://docs.soliditylang.org/en/v0.8.30/contracts.html#errors) allow you to provide more information to the caller about why a condition or operation failed. Errors are used together with the [revert statement](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#revert-statement). The `revert` statement unconditionally aborts and reverts all changes, much like the [require function](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#assert-and-require-statements). Both approaches allow you to provide the name of an error and additional data which will be supplied to the caller (and eventually to the front-end application or block explorer) so that a failure can more easily be debugged or reacted upon.
The `send` function can be used by anyone (who already has some of these coins) to send coins to anyone else. If the sender does not have enough coins to send, the `if` condition evaluates to true. As a result, the `revert` will cause the operation to fail while providing the sender with error details using the `InsufficientBalance` error.
Note
If you use this contract to send coins to an address, you will not see anything when you look at that address on a blockchain explorer, because the record that you sent coins and the changed balances are only stored in the data storage of this particular coin contract. By using events, you can create a “blockchain explorer” that tracks transactions and balances of your new coin, but you have to inspect the coin contract address and not the addresses of the coin owners.
## Blockchain Basics[](#blockchain-basics "Link to this heading")
Blockchains as a concept are not too hard to understand for programmers. The reason is that most of the complications (mining, [hashing](https://en.wikipedia.org/wiki/Cryptographic_hash_function), [elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic_curve_cryptography), [peer-to-peer networks](https://en.wikipedia.org/wiki/Peer-to-peer), etc.) are just there to provide a certain set of features and promises for the platform. Once you accept these features as given, you do not have to worry about the underlying technology - or do you have to know how Amazon’s AWS works internally in order to use it?
### Transactions[](#transactions "Link to this heading")
A blockchain is a globally shared, transactional database. This means that everyone can read entries in the database just by participating in the network. If you want to change something in the database, you have to create a so-called transaction which has to be accepted by all others. The word transaction implies that the change you want to make (assume you want to change two values at the same time) is either not done at all or completely applied. Furthermore, while your transaction is being applied to the database, no other transaction can alter it.
As an example, imagine a table that lists the balances of all accounts in an electronic currency. If a transfer from one account to another is requested, the transactional nature of the database ensures that if the amount is subtracted from one account, it is always added to the other account. If due to whatever reason, adding the amount to the target account is not possible, the source account is also not modified.
Furthermore, a transaction is always cryptographically signed by the sender (creator). This makes it straightforward to guard access to specific modifications of the database. In the example of the electronic currency, a simple check ensures that only the person holding the keys to the account can transfer some compensation, e.g. Ether, from it.
### Blocks[](#blocks "Link to this heading")
One major obstacle to overcome is what (in Bitcoin terms) is called a “double-spend attack”: What happens if two transactions exist in the network that both want to empty an account? Only one of the transactions can be valid, typically the one that is accepted first. The problem is that “first” is not an objective term in a peer-to-peer network.
The abstract answer to this is that you do not have to care. A globally accepted order of the transactions will be selected for you, solving the conflict. The transactions will be bundled into what is called a “block” and then they will be executed and distributed among all participating nodes. If two transactions contradict each other, the one that ends up being second will be rejected and not become part of the block.
These blocks form a linear sequence in time, and that is where the word “blockchain” derives from. Blocks are added to the chain at regular intervals, although these intervals may be subject to change in the future. For the most up-to-date information, it is recommended to monitor the network, for example, on [Etherscan](https://etherscan.io/chart/blocktime).
As part of the “order selection mechanism”, which is called [attestation](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/attestations/), it may happen that blocks are reverted from time to time, but only at the “tip” of the chain. The more blocks are added on top of a particular block, the less likely this block will be reverted. So it might be that your transactions are reverted and even removed from the blockchain, but the longer you wait, the less likely it will be.
Note
Transactions are not guaranteed to be included in the next block or any specific future block, since it is not up to the submitter of a transaction, but up to the miners to determine in which block the transaction is included.
If you want to schedule future calls of your contract, you can use a smart contract automation tool or an oracle service.
## The Ethereum Virtual Machine[](#index-6 "Link to this heading")
### Overview[](#overview "Link to this heading")
The Ethereum Virtual Machine or EVM is the runtime environment for smart contracts in Ethereum. It is not only sandboxed but actually completely isolated, which means that code running inside the EVM has no access to network, filesystem or other processes. Smart contracts even have limited access to other smart contracts.
### Accounts[](#accounts "Link to this heading")
There are two kinds of accounts in Ethereum which share the same address space: **External accounts** that are controlled by public-private key pairs (i.e. humans) and **contract accounts** which are controlled by the code stored together with the account.
The address of an external account is determined from the public key while the address of a contract is determined at the time the contract is created (it is derived from the creator address and the number of transactions sent from that address, the so-called “nonce”).
Regardless of whether or not the account stores code, the two types are treated equally by the EVM.
Every account has a persistent key-value store mapping 256-bit words to 256-bit words called **storage**.
Furthermore, every account has a **balance** in Ether (in “Wei” to be exact, `1 ether` is `10**18 wei`) which can be modified by sending transactions that include Ether.
### Transactions[](#index-8 "Link to this heading")
A transaction is a message that is sent from one account to another account (which might be the same or empty, see below). It can include binary data (which is called “payload”) and Ether.
If the target account contains code, that code is executed and the payload is provided as input data.
If the target account is not set (the transaction does not have a recipient or the recipient is set to `null`), the transaction creates a **new contract**. As already mentioned, the address of that contract is not the zero address but an address derived from the sender and its number of transactions sent (the “nonce”). The payload of such a contract creation transaction is taken to be EVM bytecode and executed. The output data of this execution is permanently stored as the code of the contract. This means that in order to create a contract, you do not send the actual code of the contract, but in fact code that returns that code when executed.
Note
While a contract is being created, its code is still empty. Because of that, you should not call back into the contract under construction until its constructor has finished executing.
### Gas[](#gas "Link to this heading")
Upon creation, each transaction is charged with a certain amount of **gas** that has to be paid for by the originator of the transaction (`tx.origin`). While the EVM executes the transaction, the gas is gradually depleted according to specific rules. If the gas is used up at any point (i.e. it would be negative), an out-of-gas exception is triggered, which ends execution and reverts all modifications made to the state in the current call frame.
This mechanism incentivizes economical use of EVM execution time and also compensates EVM executors (i.e. miners / stakers) for their work. Since each block has a maximum amount of gas, it also limits the amount of work needed to validate a block.
The **gas price** is a value set by the originator of the transaction, who has to pay `gas_price * gas` up front to the EVM executor. If some gas is left after execution, it is refunded to the transaction originator. In case of an exception that reverts changes, already used up gas is not refunded.
Since EVM executors can choose to include a transaction or not, transaction senders cannot abuse the system by setting a low gas price.
### Storage, Transient Storage, Memory and the Stack[](#storage-transient-storage-memory-and-the-stack "Link to this heading")
The Ethereum Virtual Machine has different areas where it can store data with the most prominent being storage, transient storage, memory and the stack.
Each account has a data area called **storage**, which is persistent between function calls and transactions. Storage is a key-value store that maps 256-bit words to 256-bit words. It is not possible to enumerate storage from within a contract, it is comparatively costly to read, and even more to initialise and modify storage. Because of this cost, you should minimize what you store in persistent storage to what the contract needs to run. Store data like derived calculations, caching, and aggregates outside of the contract. A contract can neither read nor write to any storage apart from its own.
Similar to storage, there is another data area called **transient storage**, where the main difference is that it is reset at the end of each transaction. The values stored in this data location persist only across function calls originating from the first call of the transaction. When the transaction ends, the transient storage is reset and the values stored there become unavailable to calls in subsequent transactions. Despite this, the cost of reading and writing to transient storage is significantly lower than for storage.
The third data area is called **memory**, of which a contract obtains a freshly cleared instance for each message call. Memory is linear and can be addressed at byte level, but reads are limited to a width of 256 bits, while writes can be either 8 bits or 256 bits wide. Memory is expanded by a word (256-bit), when accessing (either reading or writing) a previously untouched memory word (i.e. any offset within a word). At the time of expansion, the cost in gas must be paid. Memory is more costly the larger it grows (it scales quadratically).
The EVM is not a register machine but a stack machine, so all computations are performed on a data area called the **stack**. It has a maximum size of 1024 elements and contains words of 256 bits. Access to the stack is limited to the top end in the following way: It is possible to copy one of the topmost 16 elements to the top of the stack or swap the topmost element with one of the 16 elements below it. All other operations take the topmost two (or one, or more, depending on the operation) elements from the stack and push the result onto the stack. Of course it is possible to move stack elements to storage or memory in order to get deeper access to the stack, but it is not possible to just access arbitrary elements deeper in the stack without first removing the top of the stack.
### Calldata, Returndata and Code[](#calldata-returndata-and-code "Link to this heading")
There are also other data areas which are not as apparent as those discussed previously. However, they are routinely used during the execution of smart contract transactions.
The calldata region is the data sent to a transaction as part of a smart contract transaction. For example, when creating a contract, calldata would be the constructor code of the new contract. The parameters of external functions are always initially stored in calldata in an ABI-encoded form and only then decoded into the location specified in their declaration. If declared as `memory`, the compiler will eagerly decode them into memory at the beginning of the function, while marking them as `calldata` means that this will be done lazily, only when accessed. Value types and `storage` pointers are decoded directly onto the stack.
The returndata is the way a smart contract can return a value after a call. In general, external Solidity functions use the `return` keyword to ABI-encode values into the returndata area.
The code is the region where the EVM instructions of a smart contract are stored. Code is the bytes read, interpreted, and executed by the EVM during smart contract execution. Instruction data stored in the code is persistent as part of a contract account state field. Immutable and constant variables are stored in the code region. All references to immutables are replaced with the values assigned to them. A similar process is performed for constants which have their expressions inlined in the places where they are referenced in the smart contract code.
### Instruction Set[](#instruction-set "Link to this heading")
The instruction set of the EVM is kept minimal in order to avoid incorrect or inconsistent implementations which could cause consensus problems. All instructions operate on the basic data type, 256-bit words or on slices of memory (or other byte arrays). The usual arithmetic, bit, logical and comparison operations are present. Conditional and unconditional jumps are possible. Furthermore, contracts can access relevant properties of the current block like its number and timestamp.
For a complete list, please see the [list of opcodes](https://docs.soliditylang.org/en/v0.8.30/yul.html#opcodes) as part of the inline assembly documentation.
### Message Calls[](#message-calls "Link to this heading")
Contracts can call other contracts or send Ether to non-contract accounts by the means of message calls. Message calls are similar to transactions, in that they have a source, a target, data payload, Ether, gas and return data. In fact, every transaction consists of a top-level message call which in turn can create further message calls.
A contract can decide how much of its remaining **gas** should be sent with the inner message call and how much it wants to retain. If an out-of-gas exception happens in the inner call (or any other exception), this will be signaled by an error value put onto the stack. In this case, only the gas sent together with the call is used up. In Solidity, the calling contract causes a manual exception by default in such situations, so that exceptions “bubble up” the call stack.
As already said, the called contract (which can be the same as the caller) will receive a freshly cleared instance of memory and has access to the call payload - which will be provided in a separate area called the **calldata**. After it has finished execution, it can return data which will be stored at a location in the caller’s memory preallocated by the caller. All such calls are fully synchronous.
Calls are **limited** to a depth of 1024, which means that for more complex operations, loops should be preferred over recursive calls. Furthermore, only 63/64th of the gas can be forwarded in a message call, which causes a depth limit of a little less than 1000 in practice.
### Delegatecall and Libraries[](#delegatecall-and-libraries "Link to this heading")
There exists a special variant of a message call, named **delegatecall** which is identical to a message call apart from the fact that the code at the target address is executed in the context (i.e. at the address) of the calling contract and `msg.sender` and `msg.value` do not change their values.
This means that a contract can dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract, only the code is taken from the called address.
This makes it possible to implement the “library” feature in Solidity: Reusable library code that can be applied to a contract’s storage, e.g. in order to implement a complex data structure.
### Logs[](#logs "Link to this heading")
It is possible to store data in a specially indexed data structure that maps all the way up to the block level. This feature called **logs** is used by Solidity in order to implement [events](https://docs.soliditylang.org/en/v0.8.30/contracts.html#events). Contracts cannot access log data after it has been created, but they can be efficiently accessed from outside the blockchain. Since some part of the log data is stored in [bloom filters](https://en.wikipedia.org/wiki/Bloom_filter), it is possible to search for this data in an efficient and cryptographically secure way, so network peers that do not download the whole blockchain (so-called “light clients”) can still find these logs.
### Create[](#create "Link to this heading")
Contracts can even create other contracts using a special opcode (i.e. they do not simply call the zero address as a transaction would). The only difference between these **create calls** and normal message calls is that the payload data is executed and the result stored as code and the caller / creator receives the address of the new contract on the stack.
### Deactivate and Self-destruct[](#deactivate-and-self-destruct "Link to this heading")
The only way to remove code from the blockchain is when a contract at that address performs the `selfdestruct` operation. The remaining Ether stored at that address is sent to a designated target and then the storage and code is removed from the state. Removing the contract in theory sounds like a good idea, but it is potentially dangerous, as if someone sends Ether to removed contracts, the Ether is forever lost.
Warning
From `EVM >= Cancun` onwards, `selfdestruct` will **only** send all Ether in the account to the given recipient and not destroy the contract. However, when `selfdestruct` is called in the same transaction that creates the contract calling it, the behaviour of `selfdestruct` before Cancun hardfork (i.e., `EVM <= Shanghai`) is preserved and will destroy the current contract, deleting any data, including storage keys, code and the account itself. See [EIP-6780](https://eips.ethereum.org/EIPS/eip-6780) for more details.
The new behaviour is the result of a network-wide change that affects all contracts present on the Ethereum mainnet and testnets. It is important to note that this change is dependent on the EVM version of the chain on which the contract is deployed. The `--evm-version` setting used when compiling the contract has no bearing on it.
Also, note that the `selfdestruct` opcode has been deprecated in Solidity version 0.8.18, as recommended by [EIP-6049](https://eips.ethereum.org/EIPS/eip-6049). The deprecation is still in effect and the compiler will still emit warnings on its use. Any use in newly deployed contracts is strongly discouraged even if the new behavior is taken into account. Future changes to the EVM might further reduce the functionality of the opcode.
Warning
Even if a contract is removed by `selfdestruct`, it is still part of the history of the blockchain and probably retained by most Ethereum nodes. So using `selfdestruct` is not the same as deleting data from a hard disk.
Note
Even if a contract’s code does not contain a call to `selfdestruct`, it can still perform that operation using `delegatecall` or `callcode`.
If you want to deactivate your contracts, you should instead **disable** them by changing some internal state which causes all functions to revert. This makes it impossible to use the contract, as it returns Ether immediately.
### Precompiled Contracts[](#precompiled-contracts "Link to this heading")
There is a small set of contract addresses that are special: The address range between `1` and (including) `0x0a` contains “precompiled contracts” that can be called as any other contract but their behavior (and their gas consumption) is not defined by EVM code stored at that address (they do not contain code) but instead is implemented in the EVM execution environment itself.
Different EVM-compatible chains might use a different set of precompiled contracts. It might also be possible that new precompiled contracts are added to the Ethereum main chain in the future, but you can reasonably expect them to always be in the range between `1` and `0xffff` (inclusive).

# [Optimize Edici — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/internals/optimizer.html) 
 _https://docs.soliditylang.org/tr/latest/internals/optimizer.html_

Solidity derleyicisi iki farklı optimize edici modül kullanır: İşlem kodu düzeyinde çalışan “eski” iyileştirici ve Yul IR kodunda çalışan “yeni” iyileştirici.
İşlem kodu tabanlı optimize edici, işlem kodlarına bir dizi [basitleştirme kuralı](https://github.com/ethereum/solidity/blob/develop/libevmasm/RuleList.h) uygular. Ayrıca eşit kod kümelerini birleştirir ve kullanılmayan kodu kaldırır.
Yul tabanlı optimize edici, fonksiyon çağrıları arasında çalışabildiği için çok daha güçlüdür. Örneğin, Yul’da arbitrary jumps yapmak mümkün değildir, bu nedenle her bir fonksiyonun yan etkilerini hesaplamak mümkündür. İlkinin depolamayı değiştirmediği ve ikincisinin depolamayı değiştirdiği iki fonksiyon çağrısını düşünün. Argümanları ve dönüş değerleri birbirine bağlı değilse, fonksiyon çağrılarını yeniden sıralayabiliriz. Benzer şekilde, bir fonksiyon yan etkiden arındırılmışsa ve sonucu sıfırla çarpılırsa, fonksiyon çağrısını tamamen kaldırabilirsiniz.
Şu anda, “–optimize” parametresi, oluşturulan bayt kodu için işlem kodu tabanlı iyileştiriciyi ve dahili olarak Yul kodu için oluşturulan Yul iyileştiriciyi, örneğin ABI kodlayıcı v2’yi etkinleştirir. Bir Solidity kaynağına özel olarak optimize edilmiş bir Yul IR üretmek için `solc --ir-optimized --optimize` kullanılabilir. Benzer şekilde, bağımsız bir Yul modu için `solc --strict-assembly --optimize` kullanılabilir.
Aşağıda hem optimize edici modüller hem de optimizasyon adımları hakkında daha fazla ayrıntı bulabilirsiniz.
## Solidity Kodunu Optimize Etmenin Faydaları[](#solidity-kodunu-optimize-etmenin-faydalari "Permalink to this heading")
Genel olarak optimize ediciler, karmaşık ifadeleri sadeleştirmeye çalışır, bu da hem kod boyutunu hem de çalıştırma(execution) maliyetini azaltır, yani sözleşmenin devreye alınmasını ve sözleşmeye yapılan harici çağrılar için gereken gas miktarını azaltabilir. Ayrıca, fonksiyonları uzmanlaştırır veya sıralar. Özellikle satır içi fonksiyonları oluşturma, çok daha büyük kodlara neden olabilecek bir işlemdir, ancak daha fazla sadeleştirme fırsatlarına yol açtığı için sıklıkla yapılır.
## Optimize Edilmiş ve Optimize Edilmemiş Kod Arasındaki Farklar[](#optimize-edilmis-ve-optimize-edilmemis-kod-arasindaki-farklar "Permalink to this heading")
Genel olarak ikisi arasındaki en görünür fark, sabit ifadelerin derleme zamanındaki farklılıklardır. ASM çıktısı söz konusu olduğunda, eşdeğer veya yinelenen kod bloklarındaki gas miktarında azalma da fark edilebilir (`--asm` ve `--asm --optimize` işaretlerinin çıktısını karşılaştırın). Bununla birlikte, Yul/intermediate-representation söz konusu olduğunda, önemli farklılıklar olabilir, örneğin, fonksiyonlar satır içine alınabilir, birleştirilebilir veya fazlalıkları ortadan kaldırmak için yeniden yazılabilir, vb. (çıktıyı `--ir` ve `--optimize --ir-optimized` işaretleri ile birlikte karşılaştırabilirsiniz ).
## Optimize Edici Parametre Çalıştırmaları[](#optimize-edici-parametre-calistirmalari "Permalink to this heading")
Çalıştırma sayısı (”–optimize-runs”), dağıtılan kodun her bir işlem kodunun sözleşmenin ömrü boyunca yaklaşık olarak ne sıklıkta yürütüleceğini belirtir. Bu, kod boyutu (dağıtım maliyeti) ve kod yürütme maliyeti (dağıtımdan sonraki maliyet) arasında bir değiş tokuş parametresi olduğu anlamına gelir. “1” “runs” parametresi kısa ama pahalı olan bir kod üretecektir. Buna karşılık, daha büyük bir “runs” parametresi daha uzun ancak daha fazla gaz verimli kod üretecektir. Parametrenin maksimum değeri `2**32-1` dir.
Not
Yaygın bir yanlış anlama ise bu parametrenin optimize edicinin yineleme sayısını belirtmesidir. Ancak bu doğru değildir: Optimize edici her zaman kodu iyileştirebildiği kadar çalışır.
## Opcode Tabanlı Optimize Edici Modülü[](#opcode-tabanli-optimize-edici-modulu "Permalink to this heading")
Opcode tabanlı optimize edici modül, assembly kodu üzerinde çalışır. Komut dizisini “JUMPs” ve “JUMPDESTs”de temel bloklara böler. Bu blokların içinde, optimize edici talimatları analiz eder ve yığında, bellekte veya depolamada yapılan her değişikliği, bir talimattan ve diğer ifadelere işaret eden bir argüman listesinden oluşan bir ifade olarak kaydeder.
Ek olarak, işlem kodu tabanlı optimize edici, diğer görevlerin yanı sıra (her girişte) her zaman eşit olan ifadeleri bulan ve bunları bir ifade sınıfında birleştiren “CommonSubexpressionEliminator” adlı bir bileşen kullanır. İlk önce her yeni ifadeyi önceden bilinen ifadeler listesinde bulmaya çalışır. Böyle bir eşleşme bulunamazsa, ifadeyi `constant + constant = sum_of_constants` veya `X * 1 = X` gibi kurallara göre sadeleştirir. Bu recursive(öz yinelemeli) bir süreç olduğundan, ikinci faktör her zaman bir olarak değerlendirdiğini bildiğimiz daha karmaşık bir ifadeyse, ikinci kuralı da uygulayabiliriz.
Belirli optimize edici adımları, depolama ve bellek konumlarını sembolik olarak izler. Örneğin bu bilgi, derleme sırasında değerlendirilebilecek Keccak-256 hashlerini hesaplamak için kullanılır. Bu sıralamayı düşünebilirsiniz:
PUSH 32
PUSH 0
CALLDATALOAD
PUSH 100
DUP2
MSTORE
KECCAK256
veya eşdeğeri Yul
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.15&code=bGV0IHggOj0gY2FsbGRhdGFsb2FkKDApCm1zdG9yZSh4LCAxMDApCmxldCB2YWx1ZSA6PSBrZWNjYWsyNTYoeCwgMzIp)
let x := calldataload(0)
mstore(x, 100)
let value := keccak256(x, 32)
Bu durumda, optimize edici `calldataload(0)` bellek konumundaki değeri izler ve ardından Keccak-256 hash değerinin derleme zamanında değerlendirilebileceğini anlar. Bu, yalnızca `mstore` ve `keccak256` arasındaki belleği değiştiren başka bir komut yoksa çalışır. Yani belleğe (veya depolamaya) bilgi yazan bir talimat varsa, o zaman mevcut bilginin bellek (veya depolama) bilgisini silmemiz gerekir. Ancak, talimatın belirli bir yere yazmadığını kolayca görebildiğimizde, bu silme işleminin bir istisnası vardır.
Örneğin,
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.15&code=bGV0IHggOj0gY2FsbGRhdGFsb2FkKDApCm1zdG9yZSh4LCAxMDApCi8vIE1ldmN1dCBiaWxnaSBoYWbEsXphIGtvbnVtdSB4IC0+IDEwMApsZXQgeSA6PSBhZGQoeCwgMzIpCi8vIHknbmluIFt4LCB4ICsgMzIpJ3llIGJpbGdpIHlhem1hbWFzxLEgbmVkZW5peWxlIHggLT4gMTAwIG9sZHXEn3UgYmlsZ2lzaSBzaWxpbm1legptc3RvcmUoeSwgMjAwKQovLyBCdSBLZWNjYWstMjU2IGFydMSxayBkZcSfZXJsZW5kaXJpbGViaWxpcgpsZXQgdmFsdWUgOj0ga2VjY2FrMjU2KHgsIDMyKQ==)
let x := calldataload(0)
mstore(x, 100)
// Mevcut bilgi hafıza konumu x -> 100
let y := add(x, 32)
// y'nin \[x, x + 32)'ye bilgi yazmaması nedeniyle x -> 100 olduğu bilgisi silinmez
mstore(y, 200)
// Bu Keccak-256 artık değerlendirilebilir
let value := keccak256(x, 32)
Bu nedenle, depolama ve bellek konumlarında, örneğin `l` konumunda yapılan değişiklikler, `l``ye eşit olabilecek depolama veya bellek konumları hakkındaki bilgileri silmelidir. Daha spesifik olarak, depolama için, optimize edicinin ``l``ye eşit olabilecek tüm sembolik konum bilgilerini silmesi gerekir ve bellek için optimize edicinin en az 32 bayt uzakta olmayabilecek tüm sembolik konum bilgilerini silmesi gerekir. . Eğer ``m` arbitarry lokasyonu gösteriyorsa, o zaman bu silme kararı `sub(l, m)` değeri hesaplanarak yapılır. Depolama için, bu değer sıfırdan farklı bir hazır bilgi olarak değerlendirilirse, o zaman `m` ile ilgili bilgi tutulacaktır. Bellek için, değer `32` ile `2**256 - 32` arasında bir değer olarak değerlendirilirse, `m` ile ilgili bilgi korunur. Diğer tüm durumlarda, `m` hakkındaki bilgiler silinecektir.
Bu işlemden sonra, sonunda yığında(stack) hangi ifadelerin olması gerektiğini biliyoruz ve bellek ve depolamada yapılan değişikliklerin bir listesine sahibiz. Bu bilgi, temel bloklarla birlikte saklanır ve bunları birbirine bağlamak için kullanılır. Ayrıca yığın, depolama ve bellek yapılandırması hakkındaki bilgiler sonraki bloğa/bloklara iletilir.
Tüm `JUMP` ve `JUMPI` komutlarının hedeflerini biliyorsak, programın tam bir kontrol akış grafiğini oluşturabiliriz. Bilmediğimiz tek bir hedef varsa (bu prensipte olduğu gibi olabilir, jump targets girdilerden hesaplanabilir), bilinmeyen `JUMP` değerinin hedefi olabileceğinden bir bloğun girdi durumu hakkındaki tüm bilgileri silmemiz gerekir. İşlem kodu tabanlı optimize edici modül, koşulu bir sabite göre değerlendirilen bir `JUMPI` bulursa, bunu koşulsuz bir jump\`a dönüştürür.
Son adım olarak, her bloktaki kod yeniden oluşturulur. Optimize edici, bloğun sonunda bulunan yığındaki ifadelerden bir bağımlılık grafiği oluşturur ve bu grafiğin parçası olmayan her işlemi bırakır. Değişiklikleri orijinal kodda yapıldıkları sırayla belleğe(memory) ve depolamaya(storage) uygulayan kod üretir (gerekli olmadığı tespit edilen değişiklikleri bırakarak). Son olarak yığında olması gereken tüm değerleri doğru yerde üretir.
Bu adımlar her temel bloğa uygulanır ve yeni oluşturulan kod daha küçükse yedek olarak kullanılır. Temel bir blok bir `JUMPI`’de bölünürse ve analiz sırasında koşul bir sabit olarak değerlendirilirse, `JUMPI` sabitin değerine göre değiştirilir. Aşağıda bulunan kodda olduğu gibi
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=dWludCB4ID0gNzsKZGF0YVs3XSA9IDk7CmlmIChkYXRhW3hdICE9IHggKyAyKSAvLyBidSBrb8WfdWwgYXNsYSBkb8SfcnUgZGXEn2lsZGlyCiAgcmV0dXJuIDI7CmVsc2UKICByZXR1cm4gMTs=)
uint x \= 7;
data\[7\] \= 9;
if (data\[x\] != x + 2) // bu koşul asla doğru değildir
 return 2;
else
 return 1;
bunu sadeleştirir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=ZGF0YVs3XSA9IDk7CnJldHVybiAxOw==)
### Basit Inlining[](#basit-inlining "Permalink to this heading")
Solidity 0.8.2 sürümünden bu yana, “jump” ile biten “simple” talimatları içeren bloklara yapılan belirli atlamaları bu talimatların bir kopyası ile değiştiren başka bir optimizer adımı bulunmaktadır. Bu, basit, küçük Solidity veya Yul fonksiyonlarının inlining’ine karşılık gelir. Özellikle, `PUSHTAG(tag) JUMP` dizisi, `JUMP` bir fonksiyona atlama olarak işaretlendiğinde ve `tag` arkasında bir fonksiyondan “dışarı” atlama olarak işaretlenen başka bir `JUMP` ile biten temel bir blok (“CommonSubexpressionEliminator” için yukarıda açıklandığı gibi) olduğunda değiştirilebilir.
Özellikle, dahili bir Solidity fonksiyonuna yapılan bir çağrı için oluşturulan aşağıdaki prototip assembly örneğini göz önünde bulundurun:
 tag\_return
 tag\_f
 jump // içeri
tag\_return:
 ...opcodes after call to f...
tag\_f:
 ...body of function f...
 jump // dışarı
Fonksiyonun gövdesi sürekli bir temel blok olduğu sürece, “Inliner” `tag_f jump` yerine `tag_f` adresindeki blokla değiştirebilir ve sonuç olarak:
 tag\_return
 ...body of function f...
 jump
tag\_return:
 ...opcodes after call to f...
tag\_f:
 ...body of function f...
 jump // out
Şimdi ideal olarak, yukarıda açıklanan diğer optimize edici adımlar, return etiketi push’unun kalan jump’a doğru hareket ettirilmesiyle sonuçlanacaktır:
 ...body of function f...
 tag\_return
 jump
tag\_return:
 ...opcodes after call to f...
tag\_f:
 ...body of function f...
 jump // out
Bu durumda “PeepholeOptimizer” return jump’ı kaldıracaktır. İdeal olarak, tüm bunlar `tag_f`’ye yapılan tüm referanslar için yapılabilir, kullanılmadan bırakılabilir, s.t. kaldırılabilir, sonuç verir:
...body of function f...
...opcodes after call to f...
Böylece `f` fonksiyonuna yapılan çağrı satır içine alınır ve `f` fonksiyonunun orijinal tanımı kaldırılabilir.
Bir buluşsal yöntem, bir sözleşmenin ömrü boyunca inlining yapmanın inlining yapmamaktan daha ucuz olduğunu gösterdiğinde, bu durumdaki inlining denenir. Bu sezgisel yöntem, fonksiyon gövdesinin boyutuna, etiketine yapılan diğer referansların sayısına (fonksiyona yapılan çağrıların sayısına yaklaşık olarak) ve sözleşmenin beklenen yürütme sayısına (global optimizer parametresi “runs”) bağlıdır.
## Yul Tabanlı Optimize Edici Modülü[](#yul-tabanli-optimize-edici-modulu "Permalink to this heading")
Yul tabanlı optimize edici, tümü AST’yi anlamsal olarak eşdeğer bir şekilde dönüştüren birkaç aşamadan ve bileşenden oluşur. Amaç, ya daha kısa ya da en azından marjinal olarak daha uzun olan ancak daha fazla optimizasyon adımına izin verecek bir kodla sonuçlandırmaktır.
Uyarı
Optimize edici yoğun bir geliştirme aşamasında olduğundan, buradaki bilgiler güncel olmayabilir. Belirli bir fonksiyonelliğe güveniyorsanız, lütfen doğrudan ekiple iletişime geçin.
Optimize edici şu anda tamamen greedy(metinsel olarak mümkün olduğunca fazla eşleşen) bir strateji izliyor ve herhangi bir geri izleme yapmıyor.
Yul tabanlı optimizer modülünün tüm bileşenleri aşağıda açıklanmıştır. Aşağıdaki dönüşüm adımları ana bileşenlerdir:
* SSA Transform
 
* Common Subexpression Eliminator
 
* Expression Simplifier
 
* Redundant Assign Eliminator
 
* Full Inliner
 
### Optimize Edici Adımları[](#optimize-edici-adimlari "Permalink to this heading")
Bu, Yul tabanlı optimize edicinin alfabetik olarak sıralanmış tüm adımlarının bir listesidir. Her bir adım ve bunların sıralaması hakkında daha fazla bilgiyi aşağıda bulabilirsiniz.
* [BlockFlattener](#block-flattener).
 
* [CircularReferencesPruner](#circular-reference-pruner).
 
* [CommonSubexpressionEliminator](#common-subexpression-eliminator).
 
* [ConditionalSimplifier](#conditional-simplifier).
 
* [ConditionalUnsimplifier](#conditional-unsimplifier).
 
* [ControlFlowSimplifier](#control-flow-simplifier).
 
* [DeadCodeEliminator](#dead-code-eliminator).
 
* [EqualStoreEliminator](#equal-store-eliminator).
 
* [EquivalentFunctionCombiner](#equivalent-function-combiner).
 
* [ExpressionJoiner](#expression-joiner).
 
* [İfade Basitleştirici (Expression Simplifier)](#expression-simplifier).
 
* [ExpressionSplitter](#expression-splitter).
 
* [ForLoopConditionIntoBody](#for-loop-condition-into-body).
 
* [ForLoopConditionOutOfBody](#for-loop-condition-out-of-body).
 
* [ForLoopInitRewriter](#for-loop-init-rewriter).
 
* [ExpressionInliner](#expression-inliner).
 
* [FullInliner](#full-inliner).
 
* [FunctionGrouper](#function-grouper).
 
* [FunctionHoister](#function-hoister).
 
* [FunctionSpecializer](#function-specializer).
 
* [LiteralRematerialiser](#literal-rematerialiser).
 
* [LoadResolver](#load-resolver).
 
* [LoopInvariantCodeMotion](#loop-invariant-code-motion).
 
* [RedundantAssignEliminator](#redundant-assign-eliminator).
 
* [ReasoningBasedSimplifier](#reasoning-based-simplifier).
 
* [Rematerialiser](#rematerialiser).
 
* [SSAReverser](#ssa-reverser).
 
* [SSATransform](#ssa-transform).
 
* [StructuralSimplifier](#structural-simplifier).
 
* [UnusedFunctionParameterPruner](#unused-function-parameter-pruner).
 
* [UnusedPruner](#unused-pruner).
 
* [VarDeclInitializer](#var-decl-initializer).
 
### Optimizasyonları Seçme[](#optimizasyonlari-secme "Permalink to this heading")
Varsayılan olarak optimizer, oluşturulan assembly’ye önceden tanımlanmış optimizasyon adımları dizisini uygular. Bu diziyi geçersiz kılabilir ve `--yul-optimizations` seçeneğini kullanarak kendi dizinizi sağlayabilirsiniz:
solc \--optimize \--ir-optimized \--yul-optimizations 'dhfoD\[xarrscLMcCTU\]uljmul'
`[...]` içinde yer alan dizi, Yul kodu değişmeden kalana kadar veya maksimum tur sayısına (şu anda 12) ulaşılana kadar bir döngü içinde birden çok kez uygulanacaktır.
Mevcut kısaltmalar [Yul optimize edici dokümanları](https://docs.soliditylang.org/tr/latest/yul.html#optimization-step-sequence) içinde listelenmiştir.
### Ön İşleme (Preprocessing)[](#on-isleme-preprocessing "Permalink to this heading")
Ön işleme bileşenleri, programı üzerinde çalışılması daha kolay olan belirli normal bir forma sokmak için gerekli dönüşümleri gerçekleştirir. Bu normal formu optimizasyon sürecinin geri kalan bölümü boyunca muhafaza eder.
#### Disambiguator[](#disambiguator "Permalink to this heading")
Anlam ayrıştırıcı bir AST alır ve tüm tanımlayıcıların girdi AST’sinde benzersiz adlara sahip olduğu yeni bir kopya döndürür. Bu, diğer tüm optimize edici aşamalar için bir ön koşuldur. Avantajlarından biri, tanımlayıcının aranmanın kapsamları dikkate almasına gerek kalmamasıdır, bu da diğer adımlar için gereken analizi basitleştirir.
Sonraki tüm aşamalar, tüm isimlerin benzersiz kalması özelliğine sahiptir. Bu, herhangi bir yeni tanımlayıcı eklenmesi gerektiğinde yeni bir benzersiz isim üretileceği anlamına gelir.
#### FunctionHoister[](#functionhoister "Permalink to this heading")
Fonksiyon hoister, tüm fonksiyon tanımlarını en üstte bulunan bloğun sonuna taşır. Belirsizliği giderme aşamasından sonra gerçekleştirildiği sürece bu anlamsal olarak eşdeğer bir dönüşümdür. Bunun nedeni, bir tanımın daha yüksek seviyeli bir bloğa taşınmasının görünürlüğünü azaltamaması ve farklı bir fonksiyonda tanımlanan değişkenlere başvurmanın imkansız olmasıdır.
Bu aşamanın faydası, fonksiyon tanımlarının daha kolay aranabilmesi ve fonksiyonların, AST’yi tamamen geçmek zorunda kalmadan izole bir şekilde optimize edilebilmesidir.
#### FunctionGrouper[](#functiongrouper "Permalink to this heading")
Fonksiyon grouper, Disambiguator ve FunctionHoister sonra uygulanmalıdır. Etkisi, işlev tanımları olmayan en üstteki tüm öğelerin, kök bloğun ilk ifadesi olan tek bir bloğa taşınmasıdır.
Bu adımdan sonra, bir program aşağıdaki normal forma sahiptir:
Burada `I` herhangi bir fonksiyon tanımı içermeyen (rekürsif olarak bile) (potansiyel olarak boş) bir bloktur ve `F` hiçbir fonksiyonun bir fonksiyon tanımı içermediği bir fonksiyon tanımları listesidir.
Bu aşamanın faydası, fonksiyon listesinin nerede başladığını her zaman bilmemize olanak sağlamasıdır.
#### ForLoopConditionIntoBody[](#forloopconditionintobody "Permalink to this heading")
Bu dönüşüm, bir for döngüsünün döngü yineleme koşulunu döngü gövdesine taşır. Bu dönüşüme ihtiyacımız var çünkü [ExpressionSplitter](#expression-splitter) yineleme koşulu ifadelerine (aşağıdaki örnekte `C`) uygulanmayacaktır.
for { Init... } C { Post... } {
 Body...
}
dönüştürülür
for { Init... } 1 { Post... } {
 if iszero(C) { break }
 Body...
}
Bu dönüşüm aynı zamanda `LoopInvariantCodeMotion` ile eşleştirildiğinde de faydalı olabilir, çünkü döngüde değişmez koşullardaki invariant’lar daha sonra döngünün dışına alınabilir.
#### ForLoopInitRewriter[](#forloopinitrewriter "Permalink to this heading")
Bu dönüşüm, bir for-döngüsünün başlatma kısmını döngüden önceki kısmına taşır:
for { Init... } C { Post... } {
 Body...
}
dönüştürülür
Init...
for {} C { Post... } {
 Body...
}
Bu, döngü başlatma(genesis) bloğunun karmaşık kapsam belirleme kurallarını göz ardı edebileceğimiz için optimizasyon sürecinin geri kalanını kolaylaştırır.
#### VarDeclInitializer[](#vardeclinitializer "Permalink to this heading")
Bu adım, değişken tanımlamalarını yeniden yazarak hepsinin başlatılmasını sağlar. `let x, y` gibi tanımlamalar birden fazla tanımlama (multiple declaration) ifadesine bölünür.
Şimdilik yalnızca sıfır literali ile başlatmayı destekliyor.
### Pseudo-SSA Dönüşümü[](#pseudo-ssa-donusumu "Permalink to this heading")
Bu bileşenlerin amacı programı daha uzun bir forma sokmaktır, böylece diğer bileşenler onunla daha kolay çalışabilir. Final gösterimi statik-tek-atama (SSA) formuna benzer olacaktır, tek farkı kontrol akışının farklı kollarından(branch) gelen değerleri birleştiren açık “phi” fonksiyonlarını kullanmamasıdır çünkü böyle bir özellik Yul dilinde mevcut değildir. Bunun yerine, kontrol akışı birleştiğinde, kollardan(branch) birinde bir değişken yeniden atanırsa, mevcut değerini tutmak için yeni bir SSA değişkeni bildirilir, böylece aşağıdaki ifadelerin hala yalnızca SSA değişkenlerine başvurması gerekir.
Örnek bir dönüşüm aşağıda verilmiştir:
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.15&code=ewogICAgbGV0IGEgOj0gY2FsbGRhdGFsb2FkKDApCiAgICBsZXQgYiA6PSBjYWxsZGF0YWxvYWQoMHgyMCkKICAgIGlmIGd0KGEsIDApIHsKICAgICAgICBiIDo9IG11bChiLCAweDIwKQogICAgfQogICAgYSA6PSBhZGQoYSwgMSkKICAgIHNzdG9yZShhLCBhZGQoYiwgMHgyMCkpCn0=)
{
 let a := calldataload(0)
 let b := calldataload(0x20)
 if gt(a, 0) {
 b := mul(b, 0x20)
 }
 a := add(a, 1)
 sstore(a, add(b, 0x20))
}
Aşağıdaki tüm dönüşüm adımları uygulandığında, program aşağıdaki gibi görünecektir:
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.15&code=ewogICAgbGV0IF8xIDo9IDAKICAgIGxldCBhXzkgOj0gY2FsbGRhdGFsb2FkKF8xKQogICAgbGV0IGEgOj0gYV85CiAgICBsZXQgXzIgOj0gMHgyMAogICAgbGV0IGJfMTAgOj0gY2FsbGRhdGFsb2FkKF8yKQogICAgbGV0IGIgOj0gYl8xMAogICAgbGV0IF8zIDo9IDAKICAgIGxldCBfNCA6PSBndChhXzksIF8zKQogICAgaWYgXzQKICAgIHsKICAgICAgICBsZXQgXzUgOj0gMHgyMAogICAgICAgIGxldCBiXzExIDo9IG11bChiXzEwLCBfNSkKICAgICAgICBiIDo9IGJfMTEKICAgIH0KICAgIGxldCBiXzEyIDo9IGIKICAgIGxldCBfNiA6PSAxCiAgICBsZXQgYV8xMyA6PSBhZGQoYV85LCBfNikKICAgIGxldCBfNyA6PSAweDIwCiAgICBsZXQgXzggOj0gYWRkKGJfMTIsIF83KQogICAgc3N0b3JlKGFfMTMsIF84KQp9)
{
 let \_1 := 0
 let a\_9 := calldataload(\_1)
 let a := a\_9
 let \_2 := 0x20
 let b\_10 := calldataload(\_2)
 let b := b\_10
 let \_3 := 0
 let \_4 := gt(a\_9, \_3)
 if \_4
 {
 let \_5 := 0x20
 let b\_11 := mul(b\_10, \_5)
 b := b\_11
 }
 let b\_12 := b
 let \_6 := 1
 let a\_13 := add(a\_9, \_6)
 let \_7 := 0x20
 let \_8 := add(b\_12, \_7)
 sstore(a\_13, \_8)
}
Bu kod parçasında yeniden atanan tek değişkenin `b` olduğuna dikkat edin. Bu yeniden atama işleminden kaçınılamaz çünkü `b` kontrol akışına bağlı olarak farklı değerlere sahiptir. Diğer tüm değişkenler tanımlandıktan sonra değerlerini asla değiştirmezler. Bu özelliğin avantajı, bu değerler yeni bağlamda hala geçerli olduğu sürece, değişkenlerin serbestçe hareket ettirilebilmesi ve bunlara yapılan referansların ilk değerleriyle (ve tersiyle) değiştirilebilmesidir.
Elbette, buradaki kod optimize edilmekten oldukça uzaktır. Aksine, çok daha uzundur. Buradaki beklentimiz, bu kodla çalışmanın daha kolay olacağı ve ayrıca, bu değişiklikleri geri alan ve sonunda kodu tekrar daha kompakt hale getiren optimize edici adımların var olmasıdır.
#### ExpressionSplitter[](#expressionsplitter "Permalink to this heading")
Expression splitter(İfade Ayırıcı), `add(mload(0x123), mul(mload(0x456), 0x20))` gibi ifadeleri, ilgili ifadenin alt ifadelerine atanan benzersiz değişkenleri bildiren bir diziye dönüştürür, böylece her fonksiyon çağrısında argüman olarak yalnızca değişkenler bulunur.
Yukarıdakiler şu şekle dönüştürülebilir:
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.15&code=ewogICAgbGV0IF8xIDo9IDB4MjAKICAgIGxldCBfMiA6PSAweDQ1NgogICAgbGV0IF8zIDo9IG1sb2FkKF8yKQogICAgbGV0IF80IDo9IG11bChfMywgXzEpCiAgICBsZXQgXzUgOj0gMHgxMjMKICAgIGxldCBfNiA6PSBtbG9hZChfNSkKICAgIGxldCB6IDo9IGFkZChfNiwgXzQpCn0=)
{
 let \_1 := 0x20
 let \_2 := 0x456
 let \_3 := mload(\_2)
 let \_4 := mul(\_3, \_1)
 let \_5 := 0x123
 let \_6 := mload(\_5)
 let z := add(\_6, \_4)
}
Bu dönüşümün işlem kodlarının veya fonksiyon çağrılarının sırasını değiştirmediğini unutmayın.
Bu özellik döngü yineleme koşuluna(loop iteration-condition) uygulanmaz, çünkü döngü kontrol akışı her durumda iç ifadelerin(inner expressions) bu şekilde “outlining” yapılmasına izin vermez. Yineleme koşulunu döngü gövdesine taşımak için [ForLoopConditionIntoBody](#for-loop-condition-into-body) uygulayarak bu sınırlamayı ortadan kaldırabiliriz.
Final programı öyle bir formda olmalıdır ki fonksiyon çağrıları (döngü koşulları hariç) ifadelerin içinde içiçe görünmemeli ve tüm fonksiyon çağrısı argümanları değişken olmalıdır.
Bu formun faydaları, işlem kodları dizisini yeniden sıralamanın çok daha kolay olması ve ayrıca fonksiyon çağrısı inlining’i yapmanın daha kolay hale getirmesidir. Ayrıca, ifadelerin tek tek parçalarını değiştirmek veya “expression tree”’yi yeniden düzenlemek daha kolaydır. Dezavantajı ise bu tür kodların insanlar tarafından okunmasının çok daha zor olmasıdır.
#### SSATransform[](#ssatransform "Permalink to this heading")
Bu aşama, mevcut değişkenlere tekrarlanan atamaları mümkün olduğunca yeni değişkenlerin tanımlamalarıyla değiştirmeye çalışır. Yeniden atamalar hala mevcuttur, ancak yeniden atanan değişkenlere yapılan tüm referanslar yeni bildirilen değişkenlerle değiştirilir.
Örnek:
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.15&code=ewogICAgbGV0IGEgOj0gMQogICAgbXN0b3JlKGEsIDIpCiAgICBhIDo9IDMKfQ==)
{
 let a := 1
 mstore(a, 2)
 a := 3
}
dönüştürülür
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.15&code=ewogICAgbGV0IGFfMSA6PSAxCiAgICBsZXQgYSA6PSBhXzEKICAgIG1zdG9yZShhXzEsIDIpCiAgICBsZXQgYV8zIDo9IDMKICAgIGEgOj0gYV8zCn0=)
{
 let a\_1 := 1
 let a := a\_1
 mstore(a\_1, 2)
 let a\_3 := 3
 a := a\_3
}
Tam Semantik:
Kodda herhangi bir yere atanan bir `a` değişkeni için (değerle tanımlanan ve asla yeniden atanmayan değişkenler değiştirilmemektedir) aşağıdaki dönüşümleri gerçekleştirin:
* `let a := v` yerine `let a_i := v let a := a_i` yazın
 
* `a := v` yerine `let a_i := v a := a_i` yazın; buradaki `i`, `a_i` henüz kullanılmamış türde bir sayıdır.
 
Ayrıca, `a` için kullanılan `i` geçerli değerini her zaman saklamalı ve `a` değişkenine yapılan her referansı `a_i` ile değiştirmelisiniz. Bir `a` değişkeni için geçerli olan bir değer eşlemesi, atandığı her bloğun sonunda ve for döngü gövdesi veya post bloğu içinde atanmışsa for döngüsü init(başlangıç) bloğunun sonunda temizlenir. Bir değişkenin değeri yukarıdaki kurala göre temizlenirse ve değişken blok dışında bildirilirse, kontrol akışının birleştiği yerde yeni bir SSA değişkeni oluşturulur, buna döngü sonrası/gövde bloğunun başlangıcı ve If/Switch/ForLoop/Block ifadesinden hemen sonra gelen konum dahildir.
Bu aşamadan sonra, gereksiz ara atamaları kaldırmak için Redundant Assign Eliminator kullanılması önerilir.
Bu aşama, Expression Splitter (İfade Ayırıcı) ve Common Subexpression Eliminator (Ortak Alt İfade Giderici) hemen öncesinde çalıştırılırsa en iyi sonuçları verir, çünkü o zaman aşırı miktarda değişken üretmez. Öte yandan, Common Subexpression Eliminator (Ortak Alt İfade Giderici) SSA dönüşümünden sonra çalıştırılırsa daha verimli olabilir.
#### RedundantAssignEliminator[](#redundantassigneliminator "Permalink to this heading")
SSA dönüşümü her zaman `a := a_i` şeklinde bir atama üretir, ancak bunlar aşağıdaki örnekte olduğu gibi birçok durumda gereksiz olabilir:
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.15&code=ewogICAgbGV0IGEgOj0gMQogICAgYSA6PSBtbG9hZChhKQogICAgYSA6PSBzbG9hZChhKQogICAgc3N0b3JlKGEsIDEpCn0=)
{
 let a := 1
 a := mload(a)
 a := sload(a)
 sstore(a, 1)
}
SSA dönüşümü bu parçacığı aşağıdaki parçacığa dönüştürür:
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.15&code=ewogICAgbGV0IGFfMSA6PSAxCiAgICBsZXQgYSA6PSBhXzEKICAgIGxldCBhXzIgOj0gbWxvYWQoYV8xKQogICAgYSA6PSBhXzIKICAgIGxldCBhXzMgOj0gc2xvYWQoYV8yKQogICAgYSA6PSBhXzMKICAgIHNzdG9yZShhXzMsIDEpCn0=)
{
 let a\_1 := 1
 let a := a\_1
 let a\_2 := mload(a\_1)
 a := a\_2
 let a\_3 := sload(a\_2)
 a := a\_3
 sstore(a\_3, 1)
}
Redundant Assign Eliminator, `a` değerinin kullanılmaması nedeniyle `a` değerine yapılan üç atamayı da kaldırır ve böylece bu parçacığı strict SSA formuna dönüştürür:
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.15&code=ewogICAgbGV0IGFfMSA6PSAxCiAgICBsZXQgYV8yIDo9IG1sb2FkKGFfMSkKICAgIGxldCBhXzMgOj0gc2xvYWQoYV8yKQogICAgc3N0b3JlKGFfMywgMSkKfQ==)
{
 let a\_1 := 1
 let a\_2 := mload(a\_1)
 let a\_3 := sload(a\_2)
 sstore(a\_3, 1)
}
Elbette, bir atamanın gereksiz olup olmadığını belirlemenin karmaşık kısımları, kontrol akışının birleştirilmesiyle bağlantılıdır.
Bileşen ayrıntılı olarak aşağıdaki gibi çalışır:
AST iki kez taranır: bilgi toplama adımında ve asıl kaldırma adımında. Bilgi toplama sırasında, atama ifadelerinden “unused”, “undecided” ve “used” olmak üzere üç duruma yönelik bir eşleştirme tutarız, bu da atanan değerin daha sonra değişkene yapılan bir referans tarafından kullanılıp kullanılmayacağını gösterir.
Bir atama işlemi gerçekleştirildiğinde, “undecided” durumdaki eşleştirmeye eklenir (aşağıdaki for döngüleriyle ilgili açıklamaya bakın) ardından aynı değişkene yapılan ve hala “kararsız” durumda olan diğer tüm atamalar “undecided” olarak değiştirilir. Bir değişkene referans verildiği zaman, o değişkene yapılan ve hala “unused” durumda olan tüm atamaların durumu “undecided” olarak değiştirilir.
Kontrol akışının bölündüğü noktalarda, eşleştirmenin bir kopyası her bir kola(branch) aktarılır. Kontrol akışının birleştiği noktalarda, iki koldan gelen iki eşleme aşağıdaki şekilde birleştirilir: Ve ayrıca Yalnızca bir eşlemede bulunan veya aynı duruma sahip olan ifadeler değiştirilmeden kullanılır. Çakışan İfade değerleri de aşağıdaki şekilde çözümlenir:
* “unused”, “undecided” -> “undecided”
 
* “unused”, “used” -> “used”
 
* “undecided, “used” -> “used”
 
For-döngüleri açısından koşul, gövde ve son bölüm, koşulda birleşen kontrol akışı dikkate alınarak iki kez kontrol edilir. Başka bir ifadeyle, temel olarak üç kontrol akış yolu oluşturulur: Döngünün sıfır çalıştırılması, tek çalıştırılması ve ardından iki kez çalıştırılması ve sonunda birleştirilmesi.
Üçüncü bir çalıştırma ya da daha fazlasını simüle etmek gereksizdir, bu da şekilde olduğu biçimde anlaşılabilir:
Yinelemenin başlangıcındaki bir atama durumu, deterministik olarak yinelemenin sonunda o atamanın bir durumuyla sonuçlanacaktır. Bu durum eşleme fonksiyonu `f` olarak adlandırılsın. Yukarıda açıklandığı gibi `unused`, `undecided` ve `used` üç farklı durum kombinasyonu, `unused = 0`, `undecided = 1` ve `used = 2` olan `max` operasyondur.
Doğru yol döngüden
max(s, f(s), f(f(s)), f(f(f(s))), ...)
sonra hesaplamak olacaktır. `f` sadece üç farklı değer aralığına sahip olduğundan, iterasyon en fazla üç iterasyondan sonra bir döngüye ulaşmalıdır ve bu nedenle `f(f(f(s)))` `s`, `f(s)` veya `f(f(s))` değerlerinden birine eşit olmalıdır ve böylece
max(s, f(s), f(f(s))) = max(s, f(s), f(f(s)), f(f(f(s))), ...).
Özetle, döngüyü en fazla iki kez çalıştırmak yeterlidir çünkü sadece üç farklı durum vardır.
“Varsayılan” duruma sahip switch ifadeleri için switch’i atlayan bir kontrol akışı parçası yoktur.
Bir değişken kapsam dışına çıktığında, değişken bir fonksiyonun geri dönüş parametresi olmadığı sürece, hala “undecided” durumundaki tüm ifadeler “unused” olarak değiştirilir - bu durumda durum “used” olarak değişir.
İkinci çaprazlamada, “unused” durumunda olan tüm atamalar kaldırılır.
Bu adım genellikle SSA dönüşümünden hemen sonra çalıştırılarak pseudo-SSA’nın oluşturulması tamamlanır.
### Araçlar[](#araclar "Permalink to this heading")
#### Taşınabilirlik(Movability)[](#tasinabilirlik-movability "Permalink to this heading")
Taşınabilirlik(Movability) bir ifadenin özelliğidir. Kabaca, ifadenin yan etkisiz olduğu ve değerlendirmesinin yalnızca değişkenlerin değerlerine ve ortamın çağrı sabit durumuna bağlı olduğu anlamına gelir. Çoğu ifade taşınabilirdir. Aşağıdaki parçalar bir ifadeyi taşınamaz yapar:
* fonksiyon çağrıları (eğer fonksiyondaki tüm ifadeler taşınabilirse gelecekte gevşetilebilir)
 
* yan etkileri olan (olabilen) işlem kodları (`call` veya `selfdestruct` gibi)
 
* bellek, depolama veya harici durum bilgilerini okuyan veya yazan işlem kodları
 
* geçerli PC’ye, bellek boyutuna veya geri dönen veri boyutuna bağlı olan işlem kodları
 
#### DataflowAnalyzer[](#dataflowanalyzer "Permalink to this heading")
Dataflow Analyzer kendi başına bir optimizer adımı değildir ancak diğer bileşenler tarafından bir araç olarak kullanılır. AST’de gezinirken, bu değer hareketli bir ifade olduğu sürece her değişkenin mevcut değerini izler. O anda her bir diğer değişkene atanmış olan ifadenin parçası olan değişkenleri kaydeder. Bir `a` değişkenine yapılan her atamada, `a` değişkeninin saklanan mevcut değeri güncellenir ve `a` değişkeni `b` için saklanan ifadenin bir parçası olduğunda `b` değişkeninin saklanan tüm değerleri silinir.
Kontrol akışı birleşimlerinde, değişkenler hakkındaki bilgiler, kontrol akışı yollarından herhangi birinde atanmışlarsa veya atanacaklarsa temizlenir. Örneğin, bir for döngüsüne girildiğinde, gövde veya son blok sırasında atanacak tüm değişkenler temizlenir.
### İfade-Ölçekli Basitleştirmeler (Expression-Scale Simplifications)[](#ifade-olcekli-basitlestirmeler-expression-scale-simplifications "Permalink to this heading")
Bu sadeleştirme geçişleri ifadeleri değiştirir ve onları eşdeğer ve muhtemelen daha basit ifadelerle değiştirir.
#### CommonSubexpressionEliminator[](#commonsubexpressioneliminator "Permalink to this heading")
Bu adım Dataflow Analyzer’ı kullanır ve bir değişkenin mevcut değeriyle sözdizimsel olarak eşleşen alt ifadeleri o değişkene bir referans yoluyla değiştirir. Bu bir eşdeğerlik dönüşümüdür çünkü bu tür alt ifadelerin taşınabilir olması gerekir.
Kendileri tanımlayıcı olan tüm alt ifadeler, değer bir tanımlayıcıysa mevcut değerleriyle değiştirilir.
Yukarıdaki iki kuralın kombinasyonu, yerel değer numaralandırmasının hesaplanmasına izin verir; bu da iki değişken aynı değere sahipse, bunlardan birinin her zaman kullanılmayacağı anlamına gelir. Unused Pruner veya Redundant Assign Eliminator daha sonra bu tür değişkenleri tamamen ortadan kaldırabilecektir.
Bu adım özellikle ifade ayırıcı çalıştırıldığında etkilidir. Kod pseudo-SSA formundaysa, değişkenlerin değerleri daha uzun bir süre için mevcuttur ve bu nedenle ifadelerin değiştirilebilir olma şansı daha yüksektir.
İfade basitleştirici daha iyi değiştirmeler gerçekleştirebilecektir eğer ortak alt ifade giderici kendisinden hemen önce çalıştırılmışsa.
#### İfade Basitleştirici (Expression Simplifier)[](#ifade-basitlestirici-expression-simplifier "Permalink to this heading")
İfade Basitleştirici, Dataflow Analyzer’ı kullanarak kodu basitleştirmek için `X + 0 -> X` gibi ifadeler üzerinde bir denklik dönüşümleri listesi kullanmaktadır.
Her alt ifadede `X + 0` gibi kalıpları eşleştirmeye çalışır. Eşleştirme prosedürü sırasında, kod pseudo-SSA formunda olsa bile daha derin iç içe geçmiş kalıpları eşleştirebilmek için değişkenleri o anda atanmış ifadelerine göre çözümler.
`X - X -> 0` gibi bazı kalıplar yalnızca `X` ifadesi taşınabilir olduğu sürece uygulanabilir, çünkü aksi takdirde potansiyel yan etkilerini ortadan kaldırır. Değişken referansları, mevcut değerleri olmasa bile her zaman taşınabilir olduğundan, İfade Basitleştirici bölünmüş veya pseudo-SSA formunda yine daha etkilidir.
#### LiteralRematerialiser[](#literalrematerialiser "Permalink to this heading")
Belgelenmek üzere…
#### LoadResolver[](#loadresolver "Permalink to this heading")
Eğer biliniyorsa, `sload(x)` ve `mload(x)` tipindeki ifadeleri o anda bellekte depolanan değerle değiştiren optimizasyon aşamasıdır.
Kod SSA formundaysa en iyi şekilde çalışır.
Prerequisite: Disambiguator, ForLoopInitRewriter.
#### ReasoningBasedSimplifier[](#reasoningbasedsimplifier "Permalink to this heading")
Bu optimizer, `if` koşullarının sabit olup olmadığını kontrol etmek için SMT çözücülerini kullanır.
* Eğer `constraints AND condition` UNSAT ise, koşul hiçbir zaman doğru değildir ve tüm gövde kaldırılabilir.
 
* Eğer `constraints AND NOT condition` UNSAT ise, koşul her zaman doğrudur ve `1` ile değiştirilebilir.
 
Yukarıdaki basitleştirmeler yalnızca koşulun hareketli olması durumunda uygulanabilir.
Yalnızca EVM diyalektinde etkilidir, ancak diğer diyalektlerde kullanımı güvenlidir.
Prerequisite: Disambiguator, SSATransform.
### İfade Ölçeğindeki Basitleştirmeler (Statement-Scale Simplifications)[](#ifade-olcegindeki-basitlestirmeler-statement-scale-simplifications "Permalink to this heading")
#### CircularReferencesPruner[](#circularreferencespruner "Permalink to this heading")
Bu aşama, birbirini çağıran ancak dışarıdan veya en dış bağlamdan referans verilmeyen fonksiyonları kaldırır.
#### ConditionalSimplifier[](#conditionalsimplifier "Permalink to this heading")
Koşullu Basitleştirici(ConditionalSimplifier), değer kontrol akışından itibaren belirlenebiliyorsa koşul değişikliklerine atamalar ekler.
SSA formunu yok eder.
Şu anda, bu araç çok sınırlıdır, çünkü henüz boolean değişken türleri için desteğimiz yoktur. Koşullar yalnızca ifadelerin sıfırdan farklı olup olmadığını kontrol ettiğinden, belirli bir değer atayamayız.
Mevcut özellikler:
* switch cases: insert “<condition> := <caseLabel>”
 
* kontrol akışını sonlandıran if ifadesinden sonra “<condition> := 0” ekleyin
 
Future features:
* allow replacements by “1”
 
* take termination of user-defined functions into account
 
En iyi SSA formu ile ve ölü kod kaldırma işlemi daha önce çalıştırılmışsa çalışır.
Ön koşul: Anlam Ayrıştırıcı.
#### ConditionalUnsimplifier[](#conditionalunsimplifier "Permalink to this heading")
Koşullu Basitleştirici’nin(ConditionalSimplifier) tersi.
#### ControlFlowSimplifier[](#controlflowsimplifier "Permalink to this heading")
Çeşitli kontrol akışı yapılarını basitleştirir:
* if’i boş gövde ile pop(koşul) ile değiştirin
 
* boş varsayılan anahtar durumunu kaldırın
 
* varsayılan durum yoksa boş anahtar durumunu kaldırın
 
* switch’i no cases ile pop(expression) ile değiştirin
 
* tek durumlu anahtarı if’e dönüştürün
 
* switch’i pop(expression) ve body ile yalnızca varsayılan durumla değiştirin
 
* switch’i eşleşen case gövdesine sahip const expr ile değiştirin
 
* `for` yerine kontrol akışını sonlandıran ve diğer break/continue olmadan `if` yazın
 
* bir fonksiyonun sonundaki `leave` ifadesini kaldırın.
 
Bu işlemlerin hiçbiri veri akışına bağlı değildir. StructuralSimplifier, veri akışına bağlı olan benzer görevleri yerine getirir.
ControlFlowSimplifier, çaprazlama sırasında `break` ve `continue` deyimlerinin varlığını veya yokluğunu kaydeder.
Ön koşul: Disambiguator, FunctionHoister, ForLoopInitRewriter. Önemli: EVM işlem kodlarını tanıtır ve bu nedenle şimdilik yalnızca EVM kodu üzerinde kullanılabilir.
#### DeadCodeEliminator[](#deadcodeeliminator "Permalink to this heading")
Bu optimizasyon aşaması ulaşılamayan kodu kaldırır.
Ulaşılamayan kod, bir blok içinde öncesinde leave, return, invalid, break, continue, selfdestruct veya revert bulunan kodlardır.
Fonksiyon tanımları, daha önceki kodlar tarafından çağrılabilecekleri için korunur ve bu nedenle ulaşılabilir olarak kabul edilir.
Bir for döngüsünün init(başlangıç) bloğunda bildirilen değişkenlerin kapsamı döngü gövdesine genişletildiğinden, ForLoopInitRewriter’ın bu adımdan önce çalışmasını gerektirir.
Önkoşul: ForLoopInitRewriter, Function Hoister, Function Grouper
#### EqualStoreEliminator[](#equalstoreeliminator "Permalink to this heading")
Bu adım, `mstore(k, v)` ve `sstore(k, v)` çağrılarını, daha önce `mstore(k, v)` / `sstore(k, v)` çağrısı yapılmışsa, arada başka bir depo yoksa ve `k` ve `v` değerleri değişmemişse kaldırır.
Bu basit adım, SSA dönüşümü ve Common Subexpression Eliminator’den sonra çalıştırılırsa etkili olur, çünkü SSA değişkenlerin değişmeyeceğinden emin olur ve Common Subexpression Eliminator, değerin aynı olduğu biliniyorsa tam olarak aynı değişkeni yeniden kullanır.
Önkoşullar: Disambiguator, ForLoopInitRewriter
#### UnusedPruner[](#unusedpruner "Permalink to this heading")
Bu adım, hiçbir zaman başvurulmayan tüm fonksiyonların tanımlarını kaldırır.
Ayrıca, hiçbir zaman başvurulmayan değişkenlerin tanımlarını da kaldırır. Tanımlama taşınabilir olmayan bir değer atarsa, ifade korunur ancak değeri atılır.
Tüm taşınabilir ifade ifadeleri (atanmamış ifadeler) kaldırılır.
#### StructuralSimplifier[](#structuralsimplifier "Permalink to this heading")
Bu, yapısal düzeyde çeşitli basitleştirmeler gerçekleştiren genel bir adımdır:
* if ifadesini boş gövde ile `pop(koşul)` ile değiştirin
 
* if ifadesini gövdesine göre doğru koşulla değiştirin
 
* if deyimini yanlış koşulla kaldırın
 
* tek durumlu anahtarı if’e dönüştürün
 
* switch’i sadece varsayılan durumla `pop(expression)` ve gövde ile değiştirin
 
* case gövdesini eşleştirerek switch’i gerçek ifade ile değiştirin
 
* yanlış koşullu for döngüsünü başlatma kısmı ile değiştirin
 
Bu bileşen Dataflow Analyzer’ı kullanır.
#### BlockFlattener[](#blockflattener "Permalink to this heading")
Bu aşama, iç bloktaki ifadeyi dış bloktaki uygun yere yerleştirerek iç içe geçmiş blokları ortadan kaldırır. FunctionGrouper’a bağlıdır ve FunctionGrouper tarafından üretilen formu korumak için en dıştaki bloğu düzleştirmez.
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.15&code=ewogICAgewogICAgICAgIGxldCB4IDo9IDIKICAgICAgICB7CiAgICAgICAgICAgIGxldCB5IDo9IDMKICAgICAgICAgICAgbXN0b3JlKHgsIHkpCiAgICAgICAgfQogICAgfQp9)
{
 {
 let x := 2
 {
 let y := 3
 mstore(x, y)
 }
 }
}
dönüştürülür
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.15&code=ewogICAgewogICAgICAgIGxldCB4IDo9IDIKICAgICAgICBsZXQgeSA6PSAzCiAgICAgICAgbXN0b3JlKHgsIHkpCiAgICB9Cn0=)
{
 {
 let x := 2
 let y := 3
 mstore(x, y)
 }
}
Kodda belirsizlikler giderildiği sürece bu bir soruna yol açmaz çünkü değişkenlerin kapsamları yalnızca büyüyebilir.
#### LoopInvariantCodeMotion[](#loopinvariantcodemotion "Permalink to this heading")
Bu optimizasyon, taşınabilir SSA değişken tanımlamalarını döngünün dışına taşır.
Yalnızca bir döngünün gövdesindeki veya son bloğundaki en üst düzeydeki ifadeler dikkate alınır, yani koşullu branşların(branch) içindeki değişken tanımlamaları döngünün dışına taşınmaz.
Gereksinimler:
* Disambiguator, ForLoopInitRewriter ve FunctionHoister önceden çalıştırılmalıdır.
 
* İfade ayırıcı ve SSA dönüşümü daha iyi sonuç elde etmek için önceden çalıştırılmalıdır.
 
### Fonksiyon Düzeyinde Optimizasyonlar[](#fonksiyon-duzeyinde-optimizasyonlar "Permalink to this heading")
#### FunctionSpecializer[](#functionspecializer "Permalink to this heading")
Bu adım, fonksiyonu gerçek argümanlarıyla özelleştirir.
Bir fonksiyon, örneğin `fonksiyon f(a, b) { sstore (a, b) }`, literal argümanlarla çağrılırsa, örneğin `f(x, 5)`, burada `x` bir tanımlayıcıdır, sadece bir argüman alan yeni bir `f_1` fonksiyonu oluşturularak özelleştirilebilir, yani,
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.15&code=ZnVuY3Rpb24gZl8xKGFfMSkgewogICAgbGV0IGJfMSA6PSA1CiAgICBzc3RvcmUoYV8xLCBiXzEpCn0=)
function f\_1(a\_1) {
 let b\_1 := 5
 sstore(a\_1, b\_1)
}
Diğer optimizasyon adımları fonksiyonda daha fazla basitleştirme yapabilecektir. Optimizasyon adımı esas olarak inline edilmeyecek fonksiyonlar için kullanışlıdır.
Önkoşullar: Disambiguator, FunctionHoister
LiteralRematerialiser, doğruluk için gerekli olmasa da bir ön koşul olarak önerilir.
#### UnusedFunctionParameterPruner[](#unusedfunctionparameterpruner "Permalink to this heading")
Bu adım, bir fonksiyondaki kullanılmayan parametreleri kaldırır.
Eğer bir parametre kullanılmıyorsa, `fonksiyon f(a,b,c) -> x, y { x := div(a,b) }` içindeki `c` ve `y` gibi, parametreyi kaldırırız ve aşağıdaki gibi yeni bir “bağlama” fonksiyonu oluştururuz:
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.15&code=ZnVuY3Rpb24gZihhLGIpIC0+IHggeyB4IDo9IGRpdihhLGIpIH0KZnVuY3Rpb24gZjIoYSxiLGMpIC0+IHgsIHkgeyB4IDo9IGYoYSxiKSB9)
function f(a,b) \-> x { x := div(a,b) }
function f2(a,b,c) \-> x, y { x := f(a,b) }
ve `f` öğesine yapılan tüm referansları `f2` ile değiştirmelisiniz. Tüm `f2` referanslarının `f` ile değiştirildiğinden emin olmak için inliner daha sonra çalıştırılmalıdır.
Önkoşullar: Disambiguator, FunctionHoister, LiteralRematerialiser.
LiteralRematerialiser adımı doğruluk için gerekli değildir. Aşağıdaki gibi durumlarla başa çıkmaya yardımcı olur: `fonksiyon f(x) -> y { revert(y, y} }` burada `y` değişmezi `0` değeri ile değiştirilecek ve fonksiyonu yeniden yazmamıza izin verecektir.
#### EquivalentFunctionCombiner[](#equivalentfunctioncombiner "Permalink to this heading")
İki fonksiyon sözdizimsel(syntactically) olarak eşdeğerse, değişkenlerin yeniden adlandırılmasına izin verirken herhangi bir yeniden sıralamaya izin vermiyorsa, fonksiyonlardan birine yapılan herhangi bir referans diğeriyle değiştirilir.
Fonksiyonun asıl kaldırılma işlemi Unused Pruner tarafından gerçekleştirilir.
### Fonksiyon Inlining (Function Inlining)[](#fonksiyon-inlining-function-inlining "Permalink to this heading")
#### ExpressionInliner[](#expressioninliner "Permalink to this heading")
Optimize edicinin bu bileşeni, fonksiyonel ifadeler içinde inline edilebilen fonksiyonları, yani tek bir değer döndüren fonksiyonları inline ederek kısıtlı fonksiyon inliningi gerçekleştirir:
* tek bir değer döndüren.
 
* `r := <fonksiyonel ifade>` gibi bir gövdeye sahip olan.
 
* ne kendilerine ne de sağ taraftaki `r` ye referans verirler.
 
Ayrıca, tüm parametreler için aşağıdakilerin tümünün doğru olması gerekir:
* Bağımsız değişken taşınabilir.
 
* Parametreye ya fonksiyon gövdesinde iki kereden az referans verilir ya da argüman oldukça ucuzdur (“cost” en fazla 1, 0xff’ye kadar bir sabit gibi).
 
Örnek: Inline edilecek fonksiyon `function f(...) -> r { r := E }` biçimindedir; burada `E`, `r` ye referans vermeyen bir ifadedir ve fonksiyon çağrısındaki tüm argümanlar taşınabilir ifadelerdir.
Bu inlining işleminin sonucu her zaman tek bir ifadedir.
Bu bileşen yalnızca benzersiz adlara sahip kaynaklarda kullanılabilir.
#### FullInliner[](#fullinliner "Permalink to this heading")
Full Inliner, belirli fonksiyonların belirli çağrılarını fonksiyonun gövdesi ile değiştirir. Bu çoğu durumda çok yararlı değildir, çünkü kod boyutunu artırır ayrıca bir faydası da yoktur. Genellikle kod çok pahalıdır ve daha verimli bir kod yerine daha kısa bir kodu tercih ederiz. Yine de aynı durumlarda, bir fonksiyonun inlining işleminin sonraki optimizer adımları üzerinde olumlu etkileri olabilir. Örneğin, fonksiyon argümanlarından birinin sabit olması durumunda durum böyledir.
Inlining sırasında, fonksiyon çağrısının inline edilip edilmeyeceğini söylemek için bir heuristic kullanılır. Mevcut heuristic, çağrılan fonksiyon küçük olmadığı sürece “büyük” fonksiyonları inline etmez. Sadece bir kez kullanılan fonksiyonların yanı sıra orta büyüklükteki fonksiyonlar da inline edilirken, sabit argümanlara sahip fonksiyon çağrıları biraz daha büyük fonksiyonlara izin verir.
Gelecekte, bir fonksiyonu hemen inline etmek yerine sadece uzmanlaştıran bir geri izleme bileşeni ekleyebiliriz, bu da belirli bir parametrenin her zaman bir sabitle değiştirildiği fonksiyonun bir kopyasının oluşturulacağı anlamına gelir. Bundan sonra, optimize ediciyi bu özelleştirilmiş fonksiyon üzerinde çalıştırabiliriz. Eğer büyük kazançlar elde edilirse, özelleştirilmiş fonksiyon korunur, aksi takdirde orijinal fonksiyon kullanılır.
### Temizlik (Cleanup)[](#temizlik-cleanup "Permalink to this heading")
Temizleme, optimizer çalışmasının sonunda gerçekleştirilir. Bölünmüş ifadeleri tekrar derin iç içe geçmiş ifadelerle birleştirmeye çalışır ve ayrıca değişkenleri mümkün olduğunca ortadan kaldırarak yığın(stack) makineleri için “derlenebilirliği” iyileştirir.
#### ExpressionJoiner[](#expressionjoiner "Permalink to this heading")
Bu işlem, ifade ayırıcının(expression splitter) tersidir. Tam olarak bir referansı olan bir dizi değişken tanımlamasını karmaşık bir ifadeye dönüştürür. Bu aşama, fonksiyon çağrılarının ve işlem kodu yürütmelerinin sırasını tamamen korur. İşlem kodlarının değişebilirliğine ilişkin herhangi bir bilgi kullanmaz; bir değişkenin değerini kullanım yerine taşımak herhangi bir işlev çağrısının veya işlem kodu yürütmesinin sırasını değiştirecekse, dönüşüm gerçekleştirilmez.
Bileşenin, bir değişken atamasının atanmış değerini veya birden fazla kez başvurulan bir değişkeni taşımayacağını unutmayın.
`let x := add(0, 2) let y := mul(x, mload(2))` kod parçacığı dönüştürülmez, çünkü `add` ve `mload` işlem kodlarına yapılan çağrıların sırasının değiştirilmesine neden olur - ancak `add` taşınabilir olduğu için bu bir fark yaratmaz.
İşlem kodlarını bu şekilde yeniden sıralarken, değişken referansları ve literaller göz ardı edilir. Bu nedenle, `let x := add(0, 2) let y := mul(x, 3)` kod parçacığı, `add` işlem kodu `3` literalinin değerlendirilmesinden sonra çalıştırılacak olsa bile, `let y := mul(add(0, 2), 3)` olarak dönüştürülür.
#### SSAReverser[](#ssareverser "Permalink to this heading")
Bu, Common Subexpression Eliminator ve Unused Pruner ile birleştirildiğinde SSA dönüşümünün etkilerini tersine çevirmeye yardımcı olan küçük bir adımdır.
Ürettiğimiz SSA formu EVM ve WebAssembly’de kod üretimi için zararlıdır çünkü çok sayıda yerel değişken üretir. Yeni değişken bildirimleri yerine mevcut değişkenleri atamalarla yeniden kullanmak daha iyi sonuç verecektir.
SSA dönüşümleri şu şekilde
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.15&code=bGV0IGEgOj0gY2FsbGRhdGFsb2FkKDApCm1zdG9yZShhLCAxKQ==)
let a := calldataload(0)
mstore(a, 1)
yeniden yazılır
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.15&code=bGV0IGFfMSA6PSBjYWxsZGF0YWxvYWQoMCkKbGV0IGEgOj0gYV8xCm1zdG9yZShhXzEsIDEpCmxldCBhXzIgOj0gY2FsbGRhdGFsb2FkKDB4MjApCmEgOj0gYV8y)
let a\_1 := calldataload(0)
let a := a\_1
mstore(a\_1, 1)
let a\_2 := calldataload(0x20)
a := a\_2
Sorun, `a` değişkenine her başvurulduğunda `a` yerine `a_1` değişkeninin kullanılmasıdır. SSA dönüşümü bu formdaki ifadeleri sadece tanımlama ve atamayı değiştirerek değiştirir. Yukarıdaki kod parçacığı şu şekle dönüşür
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.15&code=bGV0IGEgOj0gY2FsbGRhdGFsb2FkKDApCmxldCBhXzEgOj0gYQptc3RvcmUoYV8xLCAxKQphIDo9IGNhbGxkYXRhbG9hZCgweDIwKQpsZXQgYV8yIDo9IGE=)
let a := calldataload(0)
let a\_1 := a
mstore(a\_1, 1)
a := calldataload(0x20)
let a\_2 := a
Bu çok basit bir denklik dönüşümüdür, ancak şimdi Common Subexpression Eliminator’ü çalıştırdığımızda, `a_1` değişkeninin tüm kullanımlarını `a` ile değiştirecektir (`a` yeniden atanana kadar). Unused Pruner daha sonra `a_1` değişkenini tamamen ortadan kaldıracak ve böylece SSA dönüşümünü tamamen tersine çevirecektir.
#### StackCompressor[](#stackcompressor "Permalink to this heading")
Ethereum Sanal Makinesi için kod oluşturmayı zorlaştıran bir sorun, ifade yığınına ulaşmak için 16 slotluk katı bir sınır olmasıdır. Bu da aşağı yukarı 16 yerel değişken sınırı anlamına gelmektedir. Yığın sıkıştırıcı Yul kodunu alır ve EVM bayt koduna derler. Yığın farkı çok büyük olduğunda, bunun hangi fonksiyonda gerçekleştiğini kaydeder.
Böyle bir soruna neden olan her bir fonksiyon için, değerlerinin maliyetine göre sıralanan belirli değişkenleri agresif bir şekilde ortadan kaldırmak için özel bir taleple Rematerialiser çağrılır.
Başarısızlık durumunda, bu prosedür birden çok kez tekrarlanır.
#### Rematerialiser[](#rematerialiser "Permalink to this heading")
Rematerialisation aşaması, değişken referanslarını değişkene en son atanan ifade ile değiştirmeye çalışır. Bu elbette yalnızca bu ifadenin değerlendirilmesi nispeten daha ucuzsa faydalıdır. Ayrıca, yalnızca ifadenin değeri atama noktası ile kullanım noktası arasında değişmediyse anlamsal olarak denktir. Bu aşamanın ana faydası, bir değişkenin tamamen ortadan kaldırılmasına yol açarsa yığın yuvalarından tasarruf edebilmesidir (aşağıya bakın), ancak ifade çok ucuzsa EVM’de bir DUP işlem kodundan da tasarruf edebilir.
Rematerialiser, her zaman hareketli olan değişkenlerin mevcut değerlerini izlemek için Dataflow Analyzer’ı kullanır. Değer çok ucuzsa veya değişkenin ortadan kaldırılması açıkça istenmişse, değişken referansı geçerli değeriyle değiştirilir.
#### ForLoopConditionOutOfBody[](#forloopconditionoutofbody "Permalink to this heading")
ForLoopConditionIntoBody dönüşümünü tersine çevirir.
Herhangi bir taşınabilir `c` için,
for { ... } 1 { ... } {
if iszero(c) { break }
...
}
dönüşür
for { ... } c { ... } {
...
}
ve döner
for { ... } 1 { ... } {
if c { break }
...
}
dönüşür
for { ... } iszero(c) { ... } {
...
}
LiteralRematerialiser bu adımdan önce çalıştırılmalıdır.
### WebAssembly’a özgü[](#webassembly-a-ozgu "Permalink to this heading")
#### Ana Fonksiyon(MainFunction)[](#ana-fonksiyon-mainfunction "Permalink to this heading")
En üstteki bloğu, girdisi veya çıktısı olmayan belirli bir ada (“main”) sahip bir fonksiyon olarak değiştirir.
Fonksiyon Gruplayıcısına bağlıdır.

# [Dizin — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/genindex.html) 
 _https://docs.soliditylang.org/tr/latest/genindex.html_

[Solidity](https://docs.soliditylang.org/tr/latest/index.html)
[**Semboller**](#Semboller) | [**A**](#A) | [**B**](#B) | [**C**](#C) | [**D**](#D) | [**E**](#E) | [**F**](#F) | [**G**](#G) | [**H**](#H) | [**I**](#I) | [**J**](#J) | [**K**](#K) | [**L**](#L) | [**M**](#M) | [**N**](#N) | [**O**](#O) | [**P**](#P) | [**R**](#R) | [**S**](#S) | [**T**](#T) | [**U**](#U) | [**V**](#V) | [**W**](#W) | [**Y**](#Y)
## Semboller
* [**\--allow-paths**](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-8), [\[1\]](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#index-1)
* [**\--base-path**](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-7), [\[1\]](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#index-1), [\[2\]](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#index-3)
* [**\--include-path**](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-7), [\[1\]](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#index-1)
* [**\--libraries**](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#index-2)
* [**\--link**](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#index-2)
* [**\--standard-json**](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#index-5), [\[1\]](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#index-3)
* [<stdin>](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-3)
## A
* [abi](https://docs.soliditylang.org/tr/latest/abi-spec.html#index-0), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-2), [\[2\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-3)
* [**abstract contract**](https://docs.soliditylang.org/tr/latest/contracts.html#index-23), [\[1\]](https://docs.soliditylang.org/tr/latest/contracts.html#index-21)
* access
 * [restricting](https://docs.soliditylang.org/tr/latest/common-patterns.html#index-1)
* [**account**](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-7)
* [addmod](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-7)
* [address](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-7), [\[1\]](https://docs.soliditylang.org/tr/latest/types.html#index-5), [\[2\]](https://docs.soliditylang.org/tr/latest/types.html#index-8)
* [**allowed paths**](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-8), [\[1\]](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#index-1)
* [analyse](https://docs.soliditylang.org/tr/latest/analysing-compilation-output.html#index-0)
* [anonymous](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-3)
* [application binary interface](https://docs.soliditylang.org/tr/latest/abi-spec.html#index-0)
* [**array**](https://docs.soliditylang.org/tr/latest/types.html#index-16), [\[1\]](https://docs.soliditylang.org/tr/latest/contracts.html#index-8), [\[2\]](https://docs.soliditylang.org/tr/latest/types.html#index-15)
 * [**allocating**](https://docs.soliditylang.org/tr/latest/types.html#index-19)
 * [**dangling storage references**](https://docs.soliditylang.org/tr/latest/types.html#index-22)
 * [**length**](https://docs.soliditylang.org/tr/latest/types.html#index-21)
 * [**literals**](https://docs.soliditylang.org/tr/latest/types.html#index-20)
 * [**pop**](https://docs.soliditylang.org/tr/latest/types.html#index-21)
 * [**push**](https://docs.soliditylang.org/tr/latest/types.html#index-21)
 * [**slice**](https://docs.soliditylang.org/tr/latest/types.html#index-23)
* [array of strings](https://docs.soliditylang.org/tr/latest/contracts.html#index-8)
* [**asm**](https://docs.soliditylang.org/tr/latest/assembly.html#index-0), [**\[1\]**](https://docs.soliditylang.org/tr/latest/yul.html#index-0), [\[2\]](https://docs.soliditylang.org/tr/latest/analysing-compilation-output.html#index-0)
* [**assembly**](https://docs.soliditylang.org/tr/latest/assembly.html#index-0), [**\[1\]**](https://docs.soliditylang.org/tr/latest/yul.html#index-0)
* [assembly-flags (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.assemblyFlags)
* [assembly-statement (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.assemblyStatement)
* [**assert**](https://docs.soliditylang.org/tr/latest/control-structures.html#index-8), [\[1\]](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[2\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-6)
* [**assignment**](https://docs.soliditylang.org/tr/latest/control-structures.html#index-4), [\[1\]](https://docs.soliditylang.org/tr/latest/types.html#index-28)
 * [**destructuring**](https://docs.soliditylang.org/tr/latest/control-structures.html#index-5)
* auction
 * [blind](https://docs.soliditylang.org/tr/latest/solidity-by-example.html#index-1)
 * [open](https://docs.soliditylang.org/tr/latest/solidity-by-example.html#index-1)
## B
* [balance](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-7), [\[2\]](https://docs.soliditylang.org/tr/latest/types.html#index-5), [\[3\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-8)
* [ballot](https://docs.soliditylang.org/tr/latest/solidity-by-example.html#index-0)
* base
 * [**constructor**](https://docs.soliditylang.org/tr/latest/contracts.html#index-21)
* [**base class**](https://docs.soliditylang.org/tr/latest/contracts.html#index-17)
* [**base path**](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-7), [\[1\]](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#index-1)
* [blind auction](https://docs.soliditylang.org/tr/latest/solidity-by-example.html#index-1)
* [**block**](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-5), [\[1\]](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[2\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-2)
 * [number](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-2)
 * [timestamp](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-2)
* [block (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.block)
* [**bool**](https://docs.soliditylang.org/tr/latest/types.html#index-2)
* [boolean-literal (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.booleanLiteral)
* [break](https://docs.soliditylang.org/tr/latest/control-structures.html#index-1)
* [break-statement (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.breakStatement)
* [Bugs](https://docs.soliditylang.org/tr/latest/bugs.html#index-0)
* [byte array](https://docs.soliditylang.org/tr/latest/types.html#index-7)
* [**bytes**](https://docs.soliditylang.org/tr/latest/types.html#index-17), [\[1\]](https://docs.soliditylang.org/tr/latest/types.html#index-11)
* [bytes members](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-4)
* [**bytes-concat**](https://docs.soliditylang.org/tr/latest/types.html#index-18)
* [bytes32](https://docs.soliditylang.org/tr/latest/types.html#index-7)
## C
* [**C3 linearization**](https://docs.soliditylang.org/tr/latest/contracts.html#index-22)
* [call](https://docs.soliditylang.org/tr/latest/types.html#index-5), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-8)
* [call-argument-list (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.callArgumentList)
* [callcode](https://docs.soliditylang.org/tr/latest/contracts.html#index-25), [\[1\]](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-13), [\[2\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-8)
* [**cast**](https://docs.soliditylang.org/tr/latest/types.html#index-31)
* [catch-clause (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.catchClause)
* [checked](https://docs.soliditylang.org/tr/latest/control-structures.html#index-7)
* [cleanup](https://docs.soliditylang.org/tr/latest/ir-breaking-changes.html#index-3)
* [codehash](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-8)
* [coding style](https://docs.soliditylang.org/tr/latest/style-guide.html#index-0)
* [coin](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-3)
* [coinbase](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-2)
* [**commandline compiler**](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#index-0)
* [**comment**](https://docs.soliditylang.org/tr/latest/layout-of-source-files.html#index-5)
* [common subexpression elimination](https://docs.soliditylang.org/tr/latest/internals/optimizer.html#index-0)
* [compile target](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#index-4)
* compiler
 * [commandline](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#index-0)
* [**compound operators**](https://docs.soliditylang.org/tr/latest/types.html#index-28)
* [**constant**](https://docs.soliditylang.org/tr/latest/contracts.html#index-6), [\[1\]](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-3)
* [constant propagation](https://docs.soliditylang.org/tr/latest/internals/optimizer.html#index-0)
* [constant-variable-declaration (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.constantVariableDeclaration)
* [**constructor**](https://docs.soliditylang.org/tr/latest/contracts.html#index-20), [\[1\]](https://docs.soliditylang.org/tr/latest/contracts.html#index-1)
 * [arguments](https://docs.soliditylang.org/tr/latest/contracts.html#index-2)
* [constructor-definition (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.constructorDefinition)
* [continue](https://docs.soliditylang.org/tr/latest/control-structures.html#index-1)
* [continue-statement (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.continueStatement)
* [**contract**](https://docs.soliditylang.org/tr/latest/contracts.html#index-0), [\[1\]](https://docs.soliditylang.org/tr/latest/structure-of-a-contract.html#index-0)
 * [**abstract**](https://docs.soliditylang.org/tr/latest/contracts.html#index-23), [\[1\]](https://docs.soliditylang.org/tr/latest/contracts.html#index-21)
 * [**base**](https://docs.soliditylang.org/tr/latest/contracts.html#index-17)
 * [**creation**](https://docs.soliditylang.org/tr/latest/contracts.html#index-1)
 * [**interface**](https://docs.soliditylang.org/tr/latest/contracts.html#index-24)
 * [modular](https://docs.soliditylang.org/tr/latest/solidity-by-example.html#index-3)
 * [**precompiled**](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-17)
* [contract creation](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-15)
* [**contract type**](https://docs.soliditylang.org/tr/latest/types.html#index-6)
* [contract verification](https://docs.soliditylang.org/tr/latest/metadata.html#index-0)
* [contract-body-element (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.contractBodyElement)
* [contract-definition (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.contractDefinition)
* contracts
 * [creating](https://docs.soliditylang.org/tr/latest/control-structures.html#index-3)
* [creationCode](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-10)
* [cryptography](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-7)
* [custom type](https://docs.soliditylang.org/tr/latest/types.html#index-13)
## D
* [data](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-2)
* [data-location (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.dataLocation)
* [days](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-1)
* [deactivate](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-16)
* [decimal-number (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer.DecimalNumber)
* [declarations](https://docs.soliditylang.org/tr/latest/control-structures.html#index-6)
* [default value](https://docs.soliditylang.org/tr/latest/control-structures.html#index-6)
* [delegatecall](https://docs.soliditylang.org/tr/latest/contracts.html#index-25), [\[1\]](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-13), [\[2\]](https://docs.soliditylang.org/tr/latest/types.html#index-5), [\[3\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-8)
* [**delete**](https://docs.soliditylang.org/tr/latest/types.html#index-29)
* [deneysel](https://docs.soliditylang.org/tr/latest/layout-of-source-files.html#index-2)
* [**deriving**](https://docs.soliditylang.org/tr/latest/contracts.html#index-17)
* [difficulty](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-2)
* [**direct import**](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-5)
* [dirty bits](https://docs.soliditylang.org/tr/latest/ir-breaking-changes.html#index-3)
* [do-while-statement (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.doWhileStatement)
* [do/while](https://docs.soliditylang.org/tr/latest/control-structures.html#index-1)
* [double-quoted-printable (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer.DoubleQuotedPrintable)
* [dynamic array](https://docs.soliditylang.org/tr/latest/contracts.html#index-8)
## E
* [ecrecover](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-7)
* [elementary-type-name (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.elementaryTypeName)
* [else](https://docs.soliditylang.org/tr/latest/control-structures.html#index-1)
* [emit-statement (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.emitStatement)
* [empty-string-literal (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer.EmptyStringLiteral)
* [encode](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-2)
* [encoding](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-3)
* [enum](https://docs.soliditylang.org/tr/latest/structure-of-a-contract.html#index-0), [\[1\]](https://docs.soliditylang.org/tr/latest/types.html#index-12)
* [enum-definition (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.enumDefinition)
* [**error**](https://docs.soliditylang.org/tr/latest/contracts.html#index-16), [\[1\]](https://docs.soliditylang.org/tr/latest/abi-spec.html#index-2)
* [error-definition (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.errorDefinition)
* [error-parameter (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.errorParameter)
* [**errors**](https://docs.soliditylang.org/tr/latest/control-structures.html#index-8)
* [escape-sequence (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer.EscapeSequence)
* [escrow](https://docs.soliditylang.org/tr/latest/solidity-by-example.html#index-2)
* [ether](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-0)
* [**ethereum virtual machine**](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-6)
* evaluation order
 * [**expression**](https://docs.soliditylang.org/tr/latest/ir-breaking-changes.html#index-0)
 * [**function arguments**](https://docs.soliditylang.org/tr/latest/ir-breaking-changes.html#index-1)
* [**event**](https://docs.soliditylang.org/tr/latest/contracts.html#index-14), [\[1\]](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-2), [\[2\]](https://docs.soliditylang.org/tr/latest/structure-of-a-contract.html#index-0)
 * [**anonymous**](https://docs.soliditylang.org/tr/latest/contracts.html#index-14)
 * [**indexed**](https://docs.soliditylang.org/tr/latest/contracts.html#index-14)
 * [**topic**](https://docs.soliditylang.org/tr/latest/contracts.html#index-14)
* [event-definition (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.eventDefinition)
* [event-parameter (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.eventParameter)
* [**evm**](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-6)
* [**EVM version**](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#index-4)
* [**evmasm**](https://docs.soliditylang.org/tr/latest/assembly.html#index-0), [**\[1\]**](https://docs.soliditylang.org/tr/latest/yul.html#index-0)
* [**exception**](https://docs.soliditylang.org/tr/latest/control-structures.html#index-8)
* [expression (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.expression)
* [expression-statement (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.expressionStatement)
* [external](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-2), [\[1\]](https://docs.soliditylang.org/tr/latest/contracts.html#index-3)
## F
* [**fallback function**](https://docs.soliditylang.org/tr/latest/contracts.html#index-12)
* [fallback-function-definition (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.fallbackFunctionDefinition)
* [**false**](https://docs.soliditylang.org/tr/latest/types.html#index-2)
* [file://](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-10)
* [filesystem path](https://docs.soliditylang.org/tr/latest/layout-of-source-files.html#index-4)
* [finney](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-0)
* [**fixed**](https://docs.soliditylang.org/tr/latest/types.html#index-4)
* [**fixed point number**](https://docs.soliditylang.org/tr/latest/types.html#index-4)
* [fixed-bytes (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer.FixedBytes)
* [for](https://docs.soliditylang.org/tr/latest/control-structures.html#index-1)
* [for-statement (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.forStatement)
* [function](https://docs.soliditylang.org/tr/latest/structure-of-a-contract.html#index-0)
 * [**call**](https://docs.soliditylang.org/tr/latest/control-structures.html#index-2), [\[1\]](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-12)
 * [external](https://docs.soliditylang.org/tr/latest/control-structures.html#index-2)
 * [fallback](https://docs.soliditylang.org/tr/latest/contracts.html#index-12)
 * [**getter**](https://docs.soliditylang.org/tr/latest/contracts.html#index-4)
 * [internal](https://docs.soliditylang.org/tr/latest/control-structures.html#index-2)
 * [**modifier**](https://docs.soliditylang.org/tr/latest/contracts.html#index-5), [\[1\]](https://docs.soliditylang.org/tr/latest/common-patterns.html#index-2), [\[2\]](https://docs.soliditylang.org/tr/latest/common-patterns.html#index-4), [\[3\]](https://docs.soliditylang.org/tr/latest/structure-of-a-contract.html#index-0)
 * [pure](https://docs.soliditylang.org/tr/latest/contracts.html#index-10)
 * [receive ! receive](https://docs.soliditylang.org/tr/latest/contracts.html#index-11)
 * [view](https://docs.soliditylang.org/tr/latest/contracts.html#index-9)
* [function parameter](https://docs.soliditylang.org/tr/latest/control-structures.html#index-0)
* [function pointers](https://docs.soliditylang.org/tr/latest/ir-breaking-changes.html#index-2)
* [**function type**](https://docs.soliditylang.org/tr/latest/types.html#index-14)
* [function-definition (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.functionDefinition)
* [function-type-name (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.functionTypeName)
* [**functions**](https://docs.soliditylang.org/tr/latest/contracts.html#index-7)
## G
* [**gas**](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-9), [\[1\]](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[2\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-2)
* [**gas price**](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-9), [\[1\]](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[2\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-2)
* getter
 * [**function**](https://docs.soliditylang.org/tr/latest/contracts.html#index-4)
* [goto](https://docs.soliditylang.org/tr/latest/control-structures.html#index-1)
* [gwei](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-0)
## H
* [hex-number (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer.HexNumber)
* [hex-string (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer.HexString)
* [hex-string-literal (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.hexStringLiteral)
* [**Host Filesystem Loader**](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-1)
* [hours](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-1)
## I
* [**içe aktarma**](https://docs.soliditylang.org/tr/latest/layout-of-source-files.html#index-3)
* [identifier (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer.Identifier), [\[1\]](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.identifier)
* [identifier-path (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.identifierPath)
* [if](https://docs.soliditylang.org/tr/latest/control-structures.html#index-1)
* [if-statement (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.ifStatement)
* import
 * [direct](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-5)
 * [**path**](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-4), [\[1\]](https://docs.soliditylang.org/tr/latest/layout-of-source-files.html#index-4)
 * [**relative**](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-6)
 * [**remapping**](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-9)
* [**import callback**](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/layout-of-source-files.html#index-4)
* [import-directive (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.importDirective)
* [**include paths**](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-7), [\[1\]](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#index-1)
* [indexed](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-3)
* [**inheritance**](https://docs.soliditylang.org/tr/latest/contracts.html#index-17)
 * [**multiple**](https://docs.soliditylang.org/tr/latest/contracts.html#index-22)
* [inheritance list](https://docs.soliditylang.org/tr/latest/contracts.html#index-21)
* [inheritance-specifier (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.inheritanceSpecifier)
* inline
 * [**arrays**](https://docs.soliditylang.org/tr/latest/types.html#index-20)
* [inline-array-expression (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.inlineArrayExpression)
* [**installing**](https://docs.soliditylang.org/tr/latest/installing-solidity.html#index-0)
* [**instruction**](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-11)
* [**int**](https://docs.soliditylang.org/tr/latest/types.html#index-3)
* [**integer**](https://docs.soliditylang.org/tr/latest/types.html#index-3)
* [**interface contract**](https://docs.soliditylang.org/tr/latest/contracts.html#index-24)
* [interface-definition (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.interfaceDefinition)
* [internal](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-2), [\[1\]](https://docs.soliditylang.org/tr/latest/contracts.html#index-3)
* [**iterable mappings**](https://docs.soliditylang.org/tr/latest/types.html#index-26)
* [iulia](https://docs.soliditylang.org/tr/latest/yul.html#index-0)
## J
* [julia](https://docs.soliditylang.org/tr/latest/yul.html#index-0)
## K
* [kaynak birim](https://docs.soliditylang.org/tr/latest/layout-of-source-files.html#index-3)
* [kaynak dosya](https://docs.soliditylang.org/tr/latest/layout-of-source-files.html#index-3)
* [keccak256](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-7)
## L
* [length](https://docs.soliditylang.org/tr/latest/types.html#index-21)
* [**library**](https://docs.soliditylang.org/tr/latest/contracts.html#index-25), [\[1\]](https://docs.soliditylang.org/tr/latest/contracts.html#index-28), [\[2\]](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-13)
* [library-definition (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.libraryDefinition)
* [**license**](https://docs.soliditylang.org/tr/latest/layout-of-source-files.html#index-0)
* [**linearization**](https://docs.soliditylang.org/tr/latest/contracts.html#index-22)
* [**linker**](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#index-2)
* [literal](https://docs.soliditylang.org/tr/latest/types.html#index-10), [\[1\]](https://docs.soliditylang.org/tr/latest/types.html#index-11), [\[2\]](https://docs.soliditylang.org/tr/latest/types.html#index-9)
 * [address](https://docs.soliditylang.org/tr/latest/types.html#index-8)
 * [rational](https://docs.soliditylang.org/tr/latest/types.html#index-9)
 * [string](https://docs.soliditylang.org/tr/latest/types.html#index-10)
* [literal (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.literal)
* [location](https://docs.soliditylang.org/tr/latest/types.html#index-15)
* [log](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-14)
* [lvalue](https://docs.soliditylang.org/tr/latest/types.html#index-28)
## M
* [**mapping**](https://docs.soliditylang.org/tr/latest/types.html#index-25), [\[1\]](https://docs.soliditylang.org/tr/latest/internals/layout_in_storage.html#index-0), [\[2\]](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-1)
* [mapping-key-type (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.mappingKeyType)
* [mapping-type (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.mappingType)
* [**memory**](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-10), [\[1\]](https://docs.soliditylang.org/tr/latest/types.html#index-15)
* [**message call**](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-12)
* [metadata](https://docs.soliditylang.org/tr/latest/metadata.html#index-0)
* [minutes](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-1)
* [modifier-definition (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.modifierDefinition)
* [modifier-invocation (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.modifierInvocation)
* [modifiers](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-3)
* [modular contract](https://docs.soliditylang.org/tr/latest/solidity-by-example.html#index-3)
* [modül](https://docs.soliditylang.org/tr/latest/layout-of-source-files.html#index-3)
* [msg](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-2)
* [mulmod](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-7)
## N
* [natspec](https://docs.soliditylang.org/tr/latest/layout-of-source-files.html#index-5)
* [**new**](https://docs.soliditylang.org/tr/latest/control-structures.html#index-3), [\[1\]](https://docs.soliditylang.org/tr/latest/types.html#index-19)
* [non-empty-string-literal (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer.NonEmptyStringLiteral)
* [number](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-2)
* [number-literal (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.numberLiteral)
* [number-unit (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer.NumberUnit)
## O
* [open auction](https://docs.soliditylang.org/tr/latest/solidity-by-example.html#index-1)
* [**operator**](https://docs.soliditylang.org/tr/latest/types.html#index-27)
 * [**precedence**](https://docs.soliditylang.org/tr/latest/types.html#index-30), [\[1\]](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-0)
* [optimiser](https://docs.soliditylang.org/tr/latest/internals/optimizer.html#index-0)
* [optimizer](https://docs.soliditylang.org/tr/latest/internals/optimizer.html#index-0)
* [origin](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-2)
* [**overload**](https://docs.soliditylang.org/tr/latest/contracts.html#index-13)
* [override-specifier (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.overrideSpecifier)
* overriding
 * [**function**](https://docs.soliditylang.org/tr/latest/contracts.html#index-18)
 * [**modifier**](https://docs.soliditylang.org/tr/latest/contracts.html#index-19)
## P
* [packed](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-3)
* [**parameter**](https://docs.soliditylang.org/tr/latest/control-structures.html#index-0)
 * [function](https://docs.soliditylang.org/tr/latest/control-structures.html#index-0)
 * [input](https://docs.soliditylang.org/tr/latest/control-structures.html#index-0)
 * [output](https://docs.soliditylang.org/tr/latest/control-structures.html#index-0)
* [parameter-list (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.parameterList)
* [path (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.path)
* [payable](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-3)
* [pop](https://docs.soliditylang.org/tr/latest/types.html#index-21)
* [**pragma**](https://docs.soliditylang.org/tr/latest/layout-of-source-files.html#index-1), [**\[1\]**](https://docs.soliditylang.org/tr/latest/layout-of-source-files.html#index-2)
* [pragma-token (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer.PragmaToken)
* [**precompiled contracts**](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-17)
* [**precompiles**](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-17)
* [private](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-2), [\[1\]](https://docs.soliditylang.org/tr/latest/contracts.html#index-3)
* [public](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-2), [\[1\]](https://docs.soliditylang.org/tr/latest/contracts.html#index-3)
* [purchase](https://docs.soliditylang.org/tr/latest/solidity-by-example.html#index-2)
* [pure](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-3)
* [**pure function**](https://docs.soliditylang.org/tr/latest/contracts.html#index-10)
* [push](https://docs.soliditylang.org/tr/latest/types.html#index-21)
## R
* [**receive ether function**](https://docs.soliditylang.org/tr/latest/contracts.html#index-11)
* [receive-function-definition (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.receiveFunctionDefinition)
* [**reference type**](https://docs.soliditylang.org/tr/latest/types.html#index-15)
* [**relative import**](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-6)
* remapping
 * [**context**](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-9)
 * [**import**](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-9)
 * [**prefix**](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-9)
 * [**target**](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-9), [\[1\]](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-8)
* [Remix IDE](https://docs.soliditylang.org/tr/latest/layout-of-source-files.html#index-4), [\[1\]](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-10)
* [remote purchase](https://docs.soliditylang.org/tr/latest/solidity-by-example.html#index-2)
* [**require**](https://docs.soliditylang.org/tr/latest/control-structures.html#index-8), [\[1\]](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[2\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-6)
* [return](https://docs.soliditylang.org/tr/latest/control-structures.html#index-0), [\[1\]](https://docs.soliditylang.org/tr/latest/control-structures.html#index-1)
* [return array](https://docs.soliditylang.org/tr/latest/contracts.html#index-8)
* [return string](https://docs.soliditylang.org/tr/latest/contracts.html#index-8)
* [return struct](https://docs.soliditylang.org/tr/latest/contracts.html#index-8)
* [return variable](https://docs.soliditylang.org/tr/latest/control-structures.html#index-0)
* [return-statement (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.returnStatement)
* [**revert**](https://docs.soliditylang.org/tr/latest/control-structures.html#index-8), [\[1\]](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[2\]](https://docs.soliditylang.org/tr/latest/contracts.html#index-16), [\[3\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-6)
* [revert-statement (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.revertStatement)
* [ripemd160](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-7)
* [runtimeCode](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-10)
## S
* [**safe math**](https://docs.soliditylang.org/tr/latest/control-structures.html#index-7)
* [safemath](https://docs.soliditylang.org/tr/latest/control-structures.html#index-7)
* [**scoping**](https://docs.soliditylang.org/tr/latest/control-structures.html#index-6)
* [seconds](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-1)
* selector
 * [**of a function**](https://docs.soliditylang.org/tr/latest/abi-spec.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/assembly.html#index-1)
 * [**of a library function**](https://docs.soliditylang.org/tr/latest/contracts.html#index-27)
 * [**of an error**](https://docs.soliditylang.org/tr/latest/contracts.html#index-16), [\[1\]](https://docs.soliditylang.org/tr/latest/abi-spec.html#index-2)
 * [**of an event**](https://docs.soliditylang.org/tr/latest/contracts.html#index-15)
* [self-destruct](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-16)
* [selfdestruct](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-16), [\[2\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-9)
* [send](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/types.html#index-5), [\[2\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-8)
* [sender](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-2)
* [set](https://docs.soliditylang.org/tr/latest/contracts.html#index-26)
* [sha256](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-7)
* [signed-integer-type (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer.SignedIntegerType)
* [single-quoted-printable (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer.SingleQuotedPrintable)
* [**solc**](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#index-0)
* [SolidityLexer (Antlr4 lexer grammar)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer)
* [SolidityParser (Antlr4 parser grammar)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser)
* [source mappings](https://docs.soliditylang.org/tr/latest/internals/source_mappings.html#index-0)
* [**source unit name**](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-0), [\[1\]](https://docs.soliditylang.org/tr/latest/layout-of-source-files.html#index-4)
* [source-unit (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.sourceUnit)
* [spdx](https://docs.soliditylang.org/tr/latest/layout-of-source-files.html#index-0)
* [**stack**](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-10)
* [standard input](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-3)
* [**standard JSON**](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#index-5), [\[1\]](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-2)
* [state machine](https://docs.soliditylang.org/tr/latest/common-patterns.html#index-3)
* [state variable](https://docs.soliditylang.org/tr/latest/internals/layout_in_storage.html#index-0), [\[1\]](https://docs.soliditylang.org/tr/latest/structure-of-a-contract.html#index-0)
* [state-mutability (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.stateMutability)
* [state-variable-declaration (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.stateVariableDeclaration)
* [statement (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.statement)
* [staticcall](https://docs.soliditylang.org/tr/latest/types.html#index-5), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-8)
* [stdin](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-3)
* [**storage**](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-10), [\[1\]](https://docs.soliditylang.org/tr/latest/internals/layout_in_storage.html#index-0), [\[2\]](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-7), [\[3\]](https://docs.soliditylang.org/tr/latest/types.html#index-15)
* [**string**](https://docs.soliditylang.org/tr/latest/types.html#index-17), [\[1\]](https://docs.soliditylang.org/tr/latest/contracts.html#index-8), [\[2\]](https://docs.soliditylang.org/tr/latest/types.html#index-10)
* [string members](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-5)
* [**string-concat**](https://docs.soliditylang.org/tr/latest/types.html#index-18)
* [string-literal (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.stringLiteral)
* [**struct**](https://docs.soliditylang.org/tr/latest/types.html#index-24), [\[1\]](https://docs.soliditylang.org/tr/latest/contracts.html#index-8), [\[2\]](https://docs.soliditylang.org/tr/latest/structure-of-a-contract.html#index-0), [\[3\]](https://docs.soliditylang.org/tr/latest/types.html#index-15)
* [struct-definition (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.structDefinition)
* [struct-member (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.structMember)
* [style](https://docs.soliditylang.org/tr/latest/style-guide.html#index-0)
* [**subcurrency**](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-0)
* [super](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1)
* [switch](https://docs.soliditylang.org/tr/latest/control-structures.html#index-1)
* [symbol-aliases (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.symbolAliases)
* [szabo](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-0)
## T
* [this](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-9)
* [**throw**](https://docs.soliditylang.org/tr/latest/control-structures.html#index-8)
* [time](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-1)
* [timestamp](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-2)
* [**transaction**](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-8), [\[1\]](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#index-4)
* [transfer](https://docs.soliditylang.org/tr/latest/types.html#index-5), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-8)
* [**true**](https://docs.soliditylang.org/tr/latest/types.html#index-2)
* [try-statement (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.tryStatement)
* [tuple-expression (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.tupleExpression)
* [type](https://docs.soliditylang.org/tr/latest/types.html#index-0), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-10)
 * [**contract**](https://docs.soliditylang.org/tr/latest/types.html#index-6)
 * [**conversion**](https://docs.soliditylang.org/tr/latest/types.html#index-31)
 * [**function**](https://docs.soliditylang.org/tr/latest/types.html#index-14)
 * [**reference**](https://docs.soliditylang.org/tr/latest/types.html#index-15)
 * [**struct**](https://docs.soliditylang.org/tr/latest/types.html#index-24)
 * [**value**](https://docs.soliditylang.org/tr/latest/types.html#index-1)
* [type-name (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.typeName)
## U
* [**ufixed**](https://docs.soliditylang.org/tr/latest/types.html#index-4)
* [**uint**](https://docs.soliditylang.org/tr/latest/types.html#index-3)
* [unchecked](https://docs.soliditylang.org/tr/latest/control-structures.html#index-7)
* [unchecked-block (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.uncheckedBlock)
* [unicode-string-literal (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer.UnicodeStringLiteral), [\[1\]](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.unicodeStringLiteral)
* [unsigned-integer-type (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer.UnsignedIntegerType)
* [**user defined value type**](https://docs.soliditylang.org/tr/latest/types.html#index-13)
* [user-defined-value-type-definition (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.userDefinedValueTypeDefinition)
* [**using for**](https://docs.soliditylang.org/tr/latest/contracts.html#index-28), [\[1\]](https://docs.soliditylang.org/tr/latest/contracts.html#index-26)
* [using-directive (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.usingDirective)
## V
* [value](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-1), [\[1\]](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-2)
* [**value type**](https://docs.soliditylang.org/tr/latest/types.html#index-1)
* variable
 * [return](https://docs.soliditylang.org/tr/latest/control-structures.html#index-0)
* [variable-declaration (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.variableDeclaration)
* [variable-declaration-statement (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.variableDeclarationStatement)
* [variable-declaration-tuple (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.variableDeclarationTuple)
* [variably sized array](https://docs.soliditylang.org/tr/latest/contracts.html#index-8)
* [**VFS**](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-0)
* [view](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-3)
* [**view function**](https://docs.soliditylang.org/tr/latest/contracts.html#index-9)
* [**virtual filesystem**](https://docs.soliditylang.org/tr/latest/path-resolution.html#index-0), [\[1\]](https://docs.soliditylang.org/tr/latest/layout-of-source-files.html#index-4)
* [**visibility**](https://docs.soliditylang.org/tr/latest/contracts.html#index-3), [\[1\]](https://docs.soliditylang.org/tr/latest/cheatsheet.html#index-2)
 * [(Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.visibility)
* [voting](https://docs.soliditylang.org/tr/latest/solidity-by-example.html#index-0)
## W
* [weeks](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-1)
* [wei](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-0)
* [while](https://docs.soliditylang.org/tr/latest/control-structures.html#index-1)
* [while-statement (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.whileStatement)
* [withdrawal](https://docs.soliditylang.org/tr/latest/common-patterns.html#index-0)
## Y
* [years](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#index-1)
* [**yul**](https://docs.soliditylang.org/tr/latest/yul.html#index-0)
* [yul-assignment (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.yulAssignment)
* [yul-block (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.yulBlock)
* [yul-boolean (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.yulBoolean)
* [yul-decimal-number (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer.YulDecimalNumber)
* [yul-evm-builtin (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer.YulEVMBuiltin)
* [yul-expression (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.yulExpression)
* [yul-for-statement (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.yulForStatement)
* [yul-function-call (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.yulFunctionCall)
* [yul-function-definition (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.yulFunctionDefinition)
* [yul-hex-number (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer.YulHexNumber)
* [yul-identifier (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer.YulIdentifier)
* [yul-if-statement (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.yulIfStatement)
* [yul-literal (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.yulLiteral)
* [yul-path (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.yulPath)
* [yul-statement (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.yulStatement)
* [yul-string-literal (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityLexer.YulStringLiteral)
* [yul-switch-statement (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.yulSwitchStatement)
* [yul-variable-declaration (Antlr4 production rule)](https://docs.soliditylang.org/tr/latest/grammar.html#a4.SolidityParser.yulVariableDeclaration)

# [Değişkenlerin Temizlenmesi — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/internals/variable_cleanup.html) 
 _https://docs.soliditylang.org/tr/latest/internals/variable_cleanup.html_

[Solidity](https://docs.soliditylang.org/tr/latest/index.html)
Bir değer 256 bitten daha kısa olduğunda, bazı durumlarda kalan bitlerin temizlenmesi gerekir. Solidity derleyicisi, kalan bitlerdeki potansiyel çöplerden olumsuz etkilenebilecek herhangi bir işlemden önce bu tür kalan bitleri temizlemek üzere tasarlanmıştır. Örnek vermek gerekirse, belleğe bir değer yazmadan öncede kalan bitlerin temizlenmesi gerekir çünkü bellek içeriği hash değerlerinin hesaplanması için kullanılabilir veya bir mesaj çağrısının verisi olarak gönderilebilir. Benzer şekilde, bir değeri depolamadan öncede aynı durum geçerlidir çünkü aksi takdirde bozuk değer gözlemlenebilir.
Satır içi(inline) assembly yoluyla erişimin böyle bir işlem olarak kabul edilmediğini unutmayın: Eğer 256 bitten kısa Solidity değişkenlerine erişmek için satır içi (inline) assembly kullanırsanız, derleyici değerin düzgün bir şekilde temizlendiğini garanti etmez.
Dahası, hemen ardından gelen işlem tarafından etkilenmiyorsa bitleri temizlemeyiz. Örneğin, sıfır olmayan herhangi bir değer `JUMPI` komutu tarafından `true` olarak kabul edildiğinden, boolean değerlerini `JUMPI` için koşul olarak kullanılmadan önce temizlemiyoruz.
Yukarıdaki tasarım prensibine ek olarak, Solidity derleyicisi girdi verilerini yığına(stack) yüklendiğinde temizler.
Farklı türlerin geçersiz değerleri temizlemek için farklı kuralları vardır:
Tür
Geçerli Değerler
Geçersiz Değerlerin Anlamları
n üyeli bir enum
0’dan n - 1’e kadar
istisna
bool
0 ya da 1
1
işaretli tam sayılar
işareti uzatılmış kelime
sessizce doğru formata getirir; gelecekte istisnala r atılacaktır
işaretsiz tam sayılar
daha yüksek bit değerleri sıfırlandı
sessizce doğru formata getirir; gelecekte istisnala r atılacaktır

# [undefined](undefined) 
 _undefined_

undefined

# [Units and Globally Available Variables — Solidity 0.4.26 documentation](https://docs.soliditylang.org/en/v0.4.26/units-and-global-variables.html) 
 _https://docs.soliditylang.org/en/v0.4.26/units-and-global-variables.html_

[Solidity](https://docs.soliditylang.org/en/v0.4.26/index.html)
## Ether Units[¶](#ether-units "Permalink to this headline")
A literal number can take a suffix of `wei`, `finney`, `szabo` or `ether` to convert between the subdenominations of Ether, where Ether currency numbers without a postfix are assumed to be Wei, e.g. `2 ether == 2000 finney` evaluates to `true`.
## Time Units[¶](#time-units "Permalink to this headline")
Suffixes like `seconds`, `minutes`, `hours`, `days`, `weeks` and `years` after literal numbers can be used to convert between units of time where seconds are the base unit and units are considered naively in the following way:
> * `1 == 1 seconds`
> * `1 minutes == 60 seconds`
> * `1 hours == 60 minutes`
> * `1 days == 24 hours`
> * `1 weeks == 7 days`
> * `1 years == 365 days`
Take care if you perform calendar calculations using these units, because not every year equals 365 days and not even every day has 24 hours because of [leap seconds](https://en.wikipedia.org/wiki/Leap_second). Due to the fact that leap seconds cannot be predicted, an exact calendar library has to be updated by an external oracle.
Note
The suffix `years` has been deprecated due to the reasons above.
These suffixes cannot be applied to variables. If you want to interpret some input variable in e.g. days, you can do it in the following way:
function f(uint start, uint daysAfter) public {
 if (now \>= start + daysAfter \* 1 days) {
 // ...
 }
}
## Special Variables and Functions[¶](#special-variables-and-functions "Permalink to this headline")
There are special variables and functions which always exist in the global namespace and are mainly used to provide information about the blockchain or are general-use utility functions.
### Block and Transaction Properties[¶](#block-and-transaction-properties "Permalink to this headline")
* `block.blockhash(uint blockNumber) returns (bytes32)`: hash of the given block - only works for 256 most recent, excluding current, blocks - deprecated in version 0.4.22 and replaced by `blockhash(uint blockNumber)`.
* `block.coinbase` (`address`): current block miner’s address
* `block.difficulty` (`uint`): current block difficulty
* `block.gaslimit` (`uint`): current block gaslimit
* `block.number` (`uint`): current block number
* `block.timestamp` (`uint`): current block timestamp as seconds since unix epoch
* `gasleft() returns (uint256)`: remaining gas
* `msg.data` (`bytes`): complete calldata
* `msg.gas` (`uint`): remaining gas - deprecated in version 0.4.21 and to be replaced by `gasleft()`
* `msg.sender` (`address`): sender of the message (current call)
* `msg.sig` (`bytes4`): first four bytes of the calldata (i.e. function identifier)
* `msg.value` (`uint`): number of wei sent with the message
* `now` (`uint`): current block timestamp (alias for `block.timestamp`)
* `tx.gasprice` (`uint`): gas price of the transaction
* `tx.origin` (`address`): sender of the transaction (full call chain)
Note
The values of all members of `msg`, including `msg.sender` and `msg.value` can change for every **external** function call. This includes calls to library functions.
Note
Do not rely on `block.timestamp`, `now` and `blockhash` as a source of randomness, unless you know what you are doing.
Both the timestamp and the block hash can be influenced by miners to some degree. Bad actors in the mining community can for example run a casino payout function on a chosen hash and just retry a different hash if they did not receive any money.
The current block timestamp must be strictly larger than the timestamp of the last block, but the only guarantee is that it will be somewhere between the timestamps of two consecutive blocks in the canonical chain.
Note
The block hashes are not available for all blocks for scalability reasons. You can only access the hashes of the most recent 256 blocks, all other values will be zero.
### ABI Encoding Functions[¶](#abi-encoding-functions "Permalink to this headline")
* `abi.encode(...) returns (bytes)`: ABI-encodes the given arguments
* `abi.encodePacked(...) returns (bytes)`: Performes packed encoding of the given arguments
* `abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)`: ABI-encodes the given arguments
 
 starting from the second and prepends the given four-byte selector
 
* `abi.encodeWithSignature(string signature, ...) returns (bytes)`: Equivalent to `` abi.encodeWithSelector(bytes4(keccak256(signature), ...)` ``
Note
These encoding functions can be used to craft data for function calls without actually calling a function. Furthermore, `keccak256(abi.encodePacked(a, b))` is a more explicit way to compute `keccak256(a, b)`, which will be deprecated in future versions.
See the documentation about the [ABI](https://docs.soliditylang.org/en/v0.4.26/abi-spec.html#abi) and the [tightly packed encoding](https://docs.soliditylang.org/en/v0.4.26/abi-spec.html#abi-packed-mode) for details about the encoding.
### Error Handling[¶](#error-handling "Permalink to this headline")
`assert(bool condition)`:
invalidates the transaction if the condition is not met - to be used for internal errors.
`require(bool condition)`:
reverts if the condition is not met - to be used for errors in inputs or external components.
`require(bool condition, string message)`:
reverts if the condition is not met - to be used for errors in inputs or external components. Also provides an error message.
`revert()`:
abort execution and revert state changes
`revert(string reason)`:
abort execution and revert state changes, providing an explanatory string
### Mathematical and Cryptographic Functions[¶](#mathematical-and-cryptographic-functions "Permalink to this headline")
`addmod(uint x, uint y, uint k) returns (uint)`:
compute `(x + y) % k` where the addition is performed with arbitrary precision and does not wrap around at `2**256`. Assert that `k != 0` starting from version 0.5.0.
`mulmod(uint x, uint y, uint k) returns (uint)`:
compute `(x * y) % k` where the multiplication is performed with arbitrary precision and does not wrap around at `2**256`. Assert that `k != 0` starting from version 0.5.0.
`keccak256(...) returns (bytes32)`:
compute the Ethereum-SHA-3 (Keccak-256) hash of the [(tightly packed) arguments](https://docs.soliditylang.org/en/v0.4.26/abi-spec.html#abi-packed-mode)
`sha256(...) returns (bytes32)`:
compute the SHA-256 hash of the [(tightly packed) arguments](https://docs.soliditylang.org/en/v0.4.26/abi-spec.html#abi-packed-mode)
`sha3(...) returns (bytes32)`:
alias to `keccak256`
`ripemd160(...) returns (bytes20)`:
compute RIPEMD-160 hash of the [(tightly packed) arguments](https://docs.soliditylang.org/en/v0.4.26/abi-spec.html#abi-packed-mode)
`ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)`:
recover the address associated with the public key from elliptic curve signature or return zero on error ([example usage](https://ethereum.stackexchange.com/q/1777/222))
In the above, “tightly packed” means that the arguments are concatenated without padding. This means that the following are all identical:
keccak256("ab", "c")
keccak256("abc")
keccak256(0x616263)
keccak256(6382179)
keccak256(97, 98, 99)
If padding is needed, explicit type conversions can be used: `keccak256("\x00\x12")` is the same as `keccak256(uint16(0x12))`.
Note that constants will be packed using the minimum number of bytes required to store them. This means that, for example, `keccak256(0) == keccak256(uint8(0))` and `keccak256(0x12345678) == keccak256(uint32(0x12345678))`.
It might be that you run into Out-of-Gas for `sha256`, `ripemd160` or `ecrecover` on a _private blockchain_. The reason for this is that those are implemented as so-called precompiled contracts and these contracts only really exist after they received the first message (although their contract code is hardcoded). Messages to non-existing contracts are more expensive and thus the execution runs into an Out-of-Gas error. A workaround for this problem is to first send e.g. 1 Wei to each of the contracts before you use them in your actual contracts. This is not an issue on the official or test net.

# [Installing the Solidity Compiler — Solidity 0.4.26 documentation](https://docs.soliditylang.org/en/v0.4.26/installing-solidity.html) 
 _https://docs.soliditylang.org/en/v0.4.26/installing-solidity.html_

## Versioning[¶](#versioning "Permalink to this headline")
Solidity versions follow [semantic versioning](https://semver.org/) and in addition to releases, **nightly development builds** are also made available. The nightly builds are not guaranteed to be working and despite best efforts they might contain undocumented and/or broken changes. We recommend using the latest release. Package installers below will use the latest release.
## Remix[¶](#remix "Permalink to this headline")
_We recommend Remix for small contracts and for quickly learning Solidity._
[Access Remix online](https://remix.ethereum.org/), you don’t need to install anything. If you want to use it without connection to the Internet, go to [https://github.com/ethereum/browser-solidity/tree/gh-pages](https://github.com/ethereum/browser-solidity/tree/gh-pages) and download the .ZIP file as explained on that page.
Further options on this page detail installing commandline Solidity compiler software on your computer. Choose a commandline compiler if you are working on a larger contract or if you require more compilation options.
## npm / Node.js[¶](#npm-node-js "Permalink to this headline")
Use npm for a convenient and portable way to install solcjs, a Solidity compiler. The solcjs program has fewer features than all options further down this page. Our [Using the Commandline Compiler](https://docs.soliditylang.org/en/v0.4.26/using-the-compiler.html#commandline-compiler) documentation assumes you are using the full-featured compiler, solc. So if you install solcjs from npm then you will stop reading the documentation here and then continue to [solc-js](https://github.com/ethereum/solc-js).
Note: The solc-js project is derived from the C++ solc by using Emscripten. solc-js can be used in JavaScript projects directly (such as Remix). Please refer to the solc-js repository for instructions.
Note
The commandline is named solcjs.
The comandline options of solcjs are not compatible with solc and tools (such as geth) expecting the behaviour of solc will not work with solcjs.
## Docker[¶](#docker "Permalink to this headline")
We provide up to date docker builds for the compiler. The `stable` repository contains released versions while the `nightly` repository contains potentially unstable changes in the develop branch.
docker run ethereum/solc:stable solc \--version
Currently, the docker image only contains the compiler executable, so you have to do some additional work to link in the source and output directories.
## Binary Packages[¶](#binary-packages "Permalink to this headline")
Binary packages of Solidity are available at [solidity/releases](https://github.com/ethereum/solidity/releases).
We also have PPAs for Ubuntu. For the latest stable version.
sudo add\-apt\-repository ppa:ethereum/ethereum
sudo apt\-get update
sudo apt\-get install solc
If you want to use the cutting edge developer version:
sudo add\-apt\-repository ppa:ethereum/ethereum
sudo add\-apt\-repository ppa:ethereum/ethereum\-dev
sudo apt\-get update
sudo apt\-get install solc
We are also releasing a [snap package](https://snapcraft.io/), which is installable in all the [supported Linux distros](https://snapcraft.io/docs/core/install). To install the latest stable version of solc:
Or if you want to help testing the unstable solc with the most recent changes from the development branch:
sudo snap install solc \--edge
Arch Linux also has packages, albeit limited to the latest development version:
Homebrew is missing pre-built bottles at the time of writing, following a Jenkins to TravisCI migration, but Homebrew should still work just fine as a means to build-from-source. We will re-add the pre-built bottles soon.
brew update
brew upgrade
brew tap ethereum/ethereum
brew install solidity
If you need a specific version of Solidity you can install a Homebrew formula directly from Github.
View [solidity.rb commits on Github](https://github.com/ethereum/homebrew-ethereum/commits/master/solidity.rb).
Follow the history links until you have a raw file link of a specific commit of `solidity.rb`.
Install it using `brew`:
brew unlink solidity
＃ Install 0.4.8
brew install https://raw.githubusercontent.com/ethereum/homebrew-ethereum/77cce03da9f289e5a3ffe579840d3c5dc0a62717/solidity.rb
Gentoo Linux also provides a solidity package that can be installed using `emerge`:
## Building from Source[¶](#building-from-source "Permalink to this headline")
### Clone the Repository[¶](#clone-the-repository "Permalink to this headline")
To clone the source code, execute the following command:
git clone \--recursive https://github.com/ethereum/solidity.git
cd solidity
If you want to help developing Solidity, you should fork Solidity and add your personal fork as a second remote:
cd solidity
git remote add personal git@github.com:\[username\]/solidity.git
Solidity has git submodules. Ensure they are properly loaded:
git submodule update \--init \--recursive
### Prerequisites - macOS[¶](#prerequisites-macos "Permalink to this headline")
For macOS, ensure that you have the latest version of [Xcode installed](https://developer.apple.com/xcode/download/). This contains the [Clang C++ compiler](https://en.wikipedia.org/wiki/Clang), the [Xcode IDE](https://en.wikipedia.org/wiki/Xcode) and other Apple development tools which are required for building C++ applications on OS X. If you are installing Xcode for the first time, or have just installed a new version then you will need to agree to the license before you can do command-line builds:
sudo xcodebuild \-license accept
Our OS X builds require you to [install the Homebrew](http://brew.sh/) package manager for installing external dependencies. Here’s how to [uninstall Homebrew](https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/FAQ.md#how-do-i-uninstall-homebrew), if you ever want to start again from scratch.
### Prerequisites - Windows[¶](#prerequisites-windows "Permalink to this headline")
You will need to install the following dependencies for Windows builds of Solidity:
If you’ve already had one IDE and only need compiler and libraries, you could install Visual Studio 2017 Build Tools.
Visual Studio 2017 provides both IDE and necessary compiler and libraries. So if you have not got an IDE and prefer to develop solidity, Visual Studio 2017 may be an choice for you to get everything setup easily.
Here is the list of components that should be installed in Visual Studio 2017 Build Tools or Visual Studio 2017:
* Visual Studio C++ core features
* VC++ 2017 v141 toolset (x86,x64)
* Windows Universal CRT SDK
* Windows 8.1 SDK
* C++/CLI support
### External Dependencies[¶](#external-dependencies "Permalink to this headline")
We now have a “one button” script which installs all required external dependencies on macOS, Windows and on numerous Linux distros. This used to be a multi-step manual process, but is now a one-liner:
./scripts/install\_deps.sh
Or, on Windows:
### Command-Line Build[¶](#command-line-build "Permalink to this headline")
**Be sure to install External Dependencies (see above) before build.**
Solidity project uses CMake to configure the build. Building Solidity is quite similar on Linux, macOS and other Unices:
mkdir build
cd build
cmake .. && make
or even easier:
＃note: this will install binaries solc and soltest at usr/local/bin
./scripts/build.sh
And even for Windows:
mkdir build
cd build
cmake \-G "Visual Studio 15 2017 Win64" ..
This latter set of instructions should result in the creation of **solidity.sln** in that build directory. Double-clicking on that file should result in Visual Studio firing up. We suggest building **RelWithDebugInfo** configuration, but all others work.
Alternatively, you can build for Windows on the command-line, like so:
cmake \--build . \--config RelWithDebInfo
## CMake options[¶](#cmake-options "Permalink to this headline")
If you are interested what CMake options are available run `cmake .. -LH`.
## The version string in detail[¶](#the-version-string-in-detail "Permalink to this headline")
The Solidity version string contains four parts:
* the version number
* pre-release tag, usually set to `develop.YYYY.MM.DD` or `nightly.YYYY.MM.DD`
* commit in the format of `commit.GITHASH`
* platform has arbitrary number of items, containing details about the platform and compiler
If there are local modifications, the commit will be postfixed with `.mod`.
These parts are combined as required by Semver, where the Solidity pre-release tag equals to the Semver pre-release and the Solidity commit and platform combined make up the Semver build metadata.
A release example: `0.4.8+commit.60cc1668.Emscripten.clang`.
A pre-release example: `0.4.9-nightly.2017.1.17+commit.6ecb4aa3.Emscripten.clang`
## Important information about versioning[¶](#important-information-about-versioning "Permalink to this headline")
After a release is made, the patch version level is bumped, because we assume that only patch level changes follow. When changes are merged, the version should be bumped according to semver and the severity of the change. Finally, a release is always made with the version of the current nightly build, but without the `prerelease` specifier.
Example:
0. the 0.4.0 release is made
1. nightly build has a version of 0.4.1 from now on
2. non-breaking changes are introduced - no change in version
3. a breaking change is introduced - version is bumped to 0.5.0
4. the 0.5.0 release is made
This behaviour works well with the [version pragma](https://docs.soliditylang.org/en/v0.4.26/layout-of-source-files.html#version-pragma).

# [Source Mappings — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/internals/source_mappings.html) 
 _https://docs.soliditylang.org/en/latest/internals/source_mappings.html_

As part of the AST output, the compiler provides the range of the source code that is represented by the respective node in the AST. This can be used for various purposes ranging from static analysis tools that report errors based on the AST and debugging tools that highlight local variables and their uses.
Furthermore, the compiler can also generate a mapping from the bytecode to the range in the source code that generated the instruction. This is again important for static analysis tools that operate on bytecode level and for displaying the current position in the source code inside a debugger or for breakpoint handling. This mapping also contains other information, like the jump type and the modifier depth (see below).
Both kinds of source mappings use integer identifiers to refer to source files. The identifier of a source file is stored in `output['sources'][sourceName]['id']` where `output` is the output of the standard-json compiler interface parsed as JSON. For some utility routines, the compiler generates “internal” source files that are not part of the original input but are referenced from the source mappings. These source files together with their identifiers can be obtained via `output['contracts'][sourceName][contractName]['evm']['bytecode']['generatedSources']`.
Note
In the case of instructions that are not associated with any particular source file, the source mapping assigns an integer identifier of `-1`. This may happen for bytecode sections stemming from compiler-generated inline assembly statements.
The source mappings inside the AST use the following notation:
`s:l:f`
Where `s` is the byte-offset to the start of the range in the source file, `l` is the length of the source range in bytes and `f` is the source index mentioned above.
The encoding in the source mapping for the bytecode is more complicated: It is a list of `s:l:f:j:m` separated by `;`. Each of these elements corresponds to an instruction, i.e. you cannot use the byte offset but have to use the instruction offset (push instructions are longer than a single byte). The fields `s`, `l` and `f` are as above. `j` can be either `i`, `o` or `-` signifying whether a jump instruction goes into a function, returns from a function or is a regular jump as part of e.g. a loop. The last field, `m`, is an integer that denotes the “modifier depth”. This depth is increased whenever the placeholder statement (`_`) is entered in a modifier and decreased when it is left again. This allows debuggers to track tricky cases like the same modifier being used twice or multiple placeholder statements being used in a single modifier.
In order to compress these source mappings especially for bytecode, the following rules are used:
* If a field is empty, the value of the preceding element is used.
 
* If a `:` is missing, all following fields are considered empty.
 
This means the following source mappings represent the same information:
`1:2:1;1:9:1;2:1:2;2:1:2;2:1:2`
`1:2:1;:9;2:1:2;;`
Important to note is that when the [verbatim](https://docs.soliditylang.org/en/latest/yul.html#yul-verbatim) builtin is used, the source mappings will be invalid: The builtin is considered a single instruction instead of potentially multiple.

# [Guide de style — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/style-guide.html) 
 _https://docs.soliditylang.org/fr/latest/style-guide.html_

## Introduction[](#introduction "Lien permanent vers cette rubrique")
Ce guide est destiné à fournir des conventions de codage pour l’écriture du code Solidity. Ce guide doit être considéré comme un document évolutif qui changera au fur et à mesure que des conventions utiles seront trouvées et que les anciennes conventions seront rendues obsolètes.
De nombreux projets mettront en place leurs propres guides de style. En cas de conflits, les guides de style spécifiques au projet sont prioritaires.
La structure et un grand nombre de recommandations de ce guide de style ont été tirées du guide de style de python [pep8 style guide](https://www.python.org/dev/peps/pep-0008/).
Le but de ce guide n’est _pas_ d’être la bonne ou la meilleure façon d’écrire du code Solidity. Le but de ce guide est la _consistance_. Une citation de python [pep8](https://www.python.org/dev/peps/pep-0008/#a-foolish-consistency-is-the-hobgoblin-of-little-minds) résume bien ce concept.
Note
Un guide de style est une question de cohérence. La cohérence avec ce guide de style est importante. La cohérence au sein d’un module ou d’une fonction est la plus importante.
Mais le plus important : **savoir quand être incohérent** - parfois le guide de style ne s’applique tout simplement pas. En cas de doute, utilisez votre meilleur jugement. Regardez d’autres exemples et décidez de ce qui vous semble le mieux. Et n’hésitez pas à demander !
## Présentation du code[](#presentation-du-code "Lien permanent vers cette rubrique")
### Indentation[](#indentation "Lien permanent vers cette rubrique")
Utilisez 4 espaces par niveau d’indentation.
### Tabs ou Espaces[](#tabs-ou-espaces "Lien permanent vers cette rubrique")
Les espaces sont la méthode d’indentation préférée.
Il faut éviter de mélanger les tabulations et les espaces.
### Lignes vierges[](#lignes-vierges "Lien permanent vers cette rubrique")
Entourer les déclarations de haut niveau dans le code source de solidity de deux lignes vides.
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQSB7CiAgICAvLyAuLi4KfQoKCmNvbnRyYWN0IEIgewogICAgLy8gLi4uCn0KCgpjb250cmFjdCBDIHsKICAgIC8vIC4uLgp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract A {
 // ...
}
contract B {
 // ...
}
contract C {
 // ...
}
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQSB7CiAgICAvLyAuLi4KfQpjb250cmFjdCBCIHsKICAgIC8vIC4uLgp9Cgpjb250cmFjdCBDIHsKICAgIC8vIC4uLgp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract A {
 // ...
}
contract B {
 // ...
}
contract C {
 // ...
}
Dans un contrat, les déclarations de fonctions sont entourées d’une seule ligne vierge.
Les lignes vides peuvent être omises entre des groupes de déclarations d’une seule ligne (comme les fonctions de base d’un contrat abstrait).
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgQSB7CiAgICBmdW5jdGlvbiBzcGFtKCkgcHVibGljIHZpcnR1YWwgcHVyZTsKICAgIGZ1bmN0aW9uIGhhbSgpIHB1YmxpYyB2aXJ0dWFsIHB1cmU7Cn0KCgpjb250cmFjdCBCIGlzIEEgewogICAgZnVuY3Rpb24gc3BhbSgpIHB1YmxpYyBwdXJlIG92ZXJyaWRlIHsKICAgICAgICAvLyAuLi4KICAgIH0KCiAgICBmdW5jdGlvbiBoYW0oKSBwdWJsaWMgcHVyZSBvdmVycmlkZSB7CiAgICAgICAgLy8gLi4uCiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
abstract contract A {
 function spam() public virtual pure;
 function ham() public virtual pure;
}
contract B is A {
 function spam() public pure override {
 // ...
 }
 function ham() public pure override {
 // ...
 }
}
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgQSB7CiAgICBmdW5jdGlvbiBzcGFtKCkgdmlydHVhbCBwdXJlIHB1YmxpYzsKICAgIGZ1bmN0aW9uIGhhbSgpIHB1YmxpYyB2aXJ0dWFsIHB1cmU7Cn0KCgpjb250cmFjdCBCIGlzIEEgewogICAgZnVuY3Rpb24gc3BhbSgpIHB1YmxpYyBwdXJlIG92ZXJyaWRlIHsKICAgICAgICAvLyAuLi4KICAgIH0KICAgIGZ1bmN0aW9uIGhhbSgpIHB1YmxpYyBwdXJlIG92ZXJyaWRlIHsKICAgICAgICAvLyAuLi4KICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
abstract contract A {
 function spam() virtual pure public;
 function ham() public virtual pure;
}
contract B is A {
 function spam() public pure override {
 // ...
 }
 function ham() public pure override {
 // ...
 }
}
### Longueur maximale de la ligne[](#longueur-maximale-de-la-ligne "Lien permanent vers cette rubrique")
Garder les lignes sous la recommandation [PEP 8](https://www.python.org/dev/peps/pep-0008/#maximum-line-length) à un maximum de 79 (ou 99) caractères aide les lecteurs à analyser facilement le code.
Les lignes enveloppées doivent se conformer aux directives suivantes.
1. Le premier argument ne doit pas être attaché à la parenthèse ouvrante.
 
2. Une, et une seule, indentation doit être utilisée.
 
3. Chaque argument doit être placé sur sa propre ligne.
 
4. L’élément de terminaison, `);`, doit être placé seul sur la dernière ligne.
 
Appels de fonction
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=dGhpc0Z1bmN0aW9uQ2FsbElzUmVhbGx5TG9uZygKICAgIGxvbmdBcmd1bWVudDEsCiAgICBsb25nQXJndW1lbnQyLAogICAgbG9uZ0FyZ3VtZW50MwopOw==)
thisFunctionCallIsReallyLong(
 longArgument1,
 longArgument2,
 longArgument3
);
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=dGhpc0Z1bmN0aW9uQ2FsbElzUmVhbGx5TG9uZyhsb25nQXJndW1lbnQxLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb25nQXJndW1lbnQyLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb25nQXJndW1lbnQzCik7Cgp0aGlzRnVuY3Rpb25DYWxsSXNSZWFsbHlMb25nKGxvbmdBcmd1bWVudDEsCiAgICBsb25nQXJndW1lbnQyLAogICAgbG9uZ0FyZ3VtZW50MwopOwoKdGhpc0Z1bmN0aW9uQ2FsbElzUmVhbGx5TG9uZygKICAgIGxvbmdBcmd1bWVudDEsIGxvbmdBcmd1bWVudDIsCiAgICBsb25nQXJndW1lbnQzCik7Cgp0aGlzRnVuY3Rpb25DYWxsSXNSZWFsbHlMb25nKApsb25nQXJndW1lbnQxLApsb25nQXJndW1lbnQyLApsb25nQXJndW1lbnQzCik7Cgp0aGlzRnVuY3Rpb25DYWxsSXNSZWFsbHlMb25nKAogICAgbG9uZ0FyZ3VtZW50MSwKICAgIGxvbmdBcmd1bWVudDIsCiAgICBsb25nQXJndW1lbnQzKTs=)
thisFunctionCallIsReallyLong(longArgument1,
 longArgument2,
 longArgument3
);
thisFunctionCallIsReallyLong(longArgument1,
 longArgument2,
 longArgument3
);
thisFunctionCallIsReallyLong(
 longArgument1, longArgument2,
 longArgument3
);
thisFunctionCallIsReallyLong(
longArgument1,
longArgument2,
longArgument3
);
thisFunctionCallIsReallyLong(
 longArgument1,
 longArgument2,
 longArgument3);
Déclarations d’affectation
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=dGhpc0lzQUxvbmdOZXN0ZWRNYXBwaW5nW2JlaW5nXVtzZXRdW3RvX3NvbWVfdmFsdWVdID0gc29tZUZ1bmN0aW9uKAogICAgYXJndW1lbnQxLAogICAgYXJndW1lbnQyLAogICAgYXJndW1lbnQzLAogICAgYXJndW1lbnQ0Cik7)
thisIsALongNestedMapping\[being\]\[set\]\[to\_some\_value\] \= someFunction(
 argument1,
 argument2,
 argument3,
 argument4
);
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=dGhpc0lzQUxvbmdOZXN0ZWRNYXBwaW5nW2JlaW5nXVtzZXRdW3RvX3NvbWVfdmFsdWVdID0gc29tZUZ1bmN0aW9uKGFyZ3VtZW50MSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50MiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50MywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50NCk7)
thisIsALongNestedMapping\[being\]\[set\]\[to\_some\_value\] \= someFunction(argument1,
 argument2,
 argument3,
 argument4);
Définitions d’événements et émetteurs d’événements
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZXZlbnQgTG9uZ0FuZExvdHNPZkFyZ3MoCiAgICBhZGRyZXNzIHNlbmRlciwKICAgIGFkZHJlc3MgcmVjaXBpZW50LAogICAgdWludDI1NiBwdWJsaWNLZXksCiAgICB1aW50MjU2IGFtb3VudCwKICAgIGJ5dGVzMzJbXSBvcHRpb25zCik7CgpMb25nQW5kTG90c09mQXJncygKICAgIHNlbmRlciwKICAgIHJlY2lwaWVudCwKICAgIHB1YmxpY0tleSwKICAgIGFtb3VudCwKICAgIG9wdGlvbnMKKTs=)
event LongAndLotsOfArgs(
 address sender,
 address recipient,
 uint256 publicKey,
 uint256 amount,
 bytes32\[\] options
);
LongAndLotsOfArgs(
 sender,
 recipient,
 publicKey,
 amount,
 options
);
Non « 
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZXZlbnQgTG9uZ0FuZExvdHNPZkFyZ3MoYWRkcmVzcyBzZW5kZXIsCiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgcmVjaXBpZW50LAogICAgICAgICAgICAgICAgICAgICAgICB1aW50MjU2IHB1YmxpY0tleSwKICAgICAgICAgICAgICAgICAgICAgICAgdWludDI1NiBhbW91bnQsCiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzMzJbXSBvcHRpb25zKTsKCkxvbmdBbmRMb3RzT2ZBcmdzKHNlbmRlciwKICAgICAgICAgICAgICAgICAgcmVjaXBpZW50LAogICAgICAgICAgICAgICAgICBwdWJsaWNLZXksCiAgICAgICAgICAgICAgICAgIGFtb3VudCwKICAgICAgICAgICAgICAgICAgb3B0aW9ucyk7)
event LongAndLotsOfArgs(address sender,
 address recipient,
 uint256 publicKey,
 uint256 amount,
 bytes32\[\] options);
LongAndLotsOfArgs(sender,
 recipient,
 publicKey,
 amount,
 options);
### Codage du fichier source[](#codage-du-fichier-source "Lien permanent vers cette rubrique")
L’encodage UTF-8 ou ASCII est préféré.
### Importations[](#importations "Lien permanent vers cette rubrique")
Les déclarations d’importation doivent toujours être placées en haut du fichier.
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKaW1wb3J0ICIuL093bmVkLnNvbCI7Cgpjb250cmFjdCBBIHsKICAgIC8vIC4uLgp9Cgpjb250cmFjdCBCIGlzIE93bmVkIHsKICAgIC8vIC4uLgp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
import "./Owned.sol";
contract A {
 // ...
}
contract B is Owned {
 // ...
}
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQSB7CiAgICAvLyAuLi4KfQoKCmltcG9ydCAiLi9Pd25lZC5zb2wiOwoKCmNvbnRyYWN0IEIgaXMgT3duZWQgewogICAgLy8gLi4uCn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract A {
 // ...
}
import "./Owned.sol";
contract B is Owned {
 // ...
}
### Ordre des fonctions[](#ordre-des-fonctions "Lien permanent vers cette rubrique")
L’ordre aide les lecteurs à identifier les fonctions qu’ils peuvent appeler et à trouver plus facilement les définitions des constructeurs et des fonctions de repli.
Les fonctions doivent être regroupées en fonction de leur visibilité et ordonnées :
* constructor
 
* receive function (si elle existe)
 
* fallback function (si elle existe)
 
* external
 
* public
 
* internal
 
* private
 
Dans un regroupement, placez les fonctions `view` et `pure` en dernier.
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwpjb250cmFjdCBBIHsKICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgIC8vIC4uLgogICAgfQoKICAgIHJlY2VpdmUoKSBleHRlcm5hbCBwYXlhYmxlIHsKICAgICAgICAvLyAuLi4KICAgIH0KCiAgICBmYWxsYmFjaygpIGV4dGVybmFsIHsKICAgICAgICAvLyAuLi4KICAgIH0KCiAgICAvLyBGb25jdGlvbnMgZXh0ZXJuZXMKICAgIC8vIC4uLgoKICAgIC8vIEZvbmN0aW9ucyBleHRlcm5lcyBxdWkgc29udCB2aWV3CiAgICAvLyAuLi4KCiAgICAvLyBGb25jdGlvbnMgZXh0ZXJuZXMgcXVpIHNvbnQgcHVyZQogICAgLy8gLi4uCgogICAgLy8gRm9uY3Rpb25zIHB1YmxpcXVlcwogICAgLy8gLi4uCgogICAgLy8gRm9uY3Rpb25zIGludGVybmVzCiAgICAvLyAuLi4KCiAgICAvLyBGb25jdGlvbnMgcHJpdsOpZXMKICAgIC8vIC4uLgp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract A {
 constructor() {
 // ...
 }
 receive() external payable {
 // ...
 }
 fallback() external {
 // ...
 }
 // Fonctions externes
 // ...
 // Fonctions externes qui sont view
 // ...
 // Fonctions externes qui sont pure
 // ...
 // Fonctions publiques
 // ...
 // Fonctions internes
 // ...
 // Fonctions privées
 // ...
}
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwpjb250cmFjdCBBIHsKCiAgICAvLyBFeHRlcm5hbCBmdW5jdGlvbnMKICAgIC8vIC4uLgoKICAgIGZhbGxiYWNrKCkgZXh0ZXJuYWwgewogICAgICAgIC8vIC4uLgogICAgfQogICAgcmVjZWl2ZSgpIGV4dGVybmFsIHBheWFibGUgewogICAgICAgIC8vIC4uLgogICAgfQoKICAgIC8vIEZvbmN0aW9ucyBwcml2w6llcwogICAgLy8gLi4uCgogICAgLy8gRm9uY3Rpb25zIHB1YmxpcXVlcwogICAgLy8gLi4uCgogICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgLy8gLi4uCiAgICB9CgogICAgLy8gRm9uY3Rpb25zIGludGVybmVzCiAgICAvLyAuLi4KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract A {
 // External functions
 // ...
 fallback() external {
 // ...
 }
 receive() external payable {
 // ...
 }
 // Fonctions privées
 // ...
 // Fonctions publiques
 // ...
 constructor() {
 // ...
 }
 // Fonctions internes
 // ...
}
### Espaces blancs dans les expressions[](#espaces-blancs-dans-les-expressions "Lien permanent vers cette rubrique")
Évitez les espaces blancs superflus dans les situations suivantes :
Immédiatement à l’intérieur des parenthèses, des crochets ou des accolades, à l’exception des déclarations de fonctions sur une seule ligne.
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=c3BhbShoYW1bMV0sIENvaW4oe25hbWU6ICJoYW0ifSkpOw==)
spam(ham\[1\], Coin({name: "ham"}));
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=c3BhbSggaGFtWyAxIF0sIENvaW4oIHsgbmFtZTogImhhbSIgfSApICk7)
spam( ham\[ 1 \], Coin( { name: "ham" } ) );
Exception :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZnVuY3Rpb24gc2luZ2xlTGluZSgpIHB1YmxpYyB7IHNwYW0oKTsgfQ==)
function singleLine() public { spam(); }
Immédiatement avant une virgule, un point-virgule :
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZnVuY3Rpb24gc3BhbSh1aW50IGksIENvaW4gY29pbikgcHVibGljOw==)
function spam(uint i, Coin coin) public;
Non;
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZnVuY3Rpb24gc3BhbSh1aW50IGkgLCBDb2luIGNvaW4pIHB1YmxpYyA7)
function spam(uint i , Coin coin) public ;
More than one space around an assignment or other operator to align with another:
Yes:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=eCA9IDE7CnkgPSAyOwpsb25nX3ZhcmlhYmxlID0gMzs=)
x \= 1;
y \= 2;
long\_variable \= 3;
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=eCAgICAgICAgICAgICA9IDE7CnkgICAgICAgICAgICAgPSAyOwpsb25nX3ZhcmlhYmxlID0gMzs=)
x \= 1;
y \= 2;
long\_variable \= 3;
Ne pas inclure d’espace dans les fonctions de réception et de repli :
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=cmVjZWl2ZSgpIGV4dGVybmFsIHBheWFibGUgewogICAgLi4uCn0KCmZhbGxiYWNrKCkgZXh0ZXJuYWwgewogICAgLi4uCn0=)
receive() external payable {
 ...
}
fallback() external {
 ...
}
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=cmVjZWl2ZSAoKSBleHRlcm5hbCBwYXlhYmxlIHsKICAgIC4uLgp9CgpmYWxsYmFjayAoKSBleHRlcm5hbCB7CiAgICAuLi4KfQ==)
receive () external payable {
 ...
}
fallback () external {
 ...
}
### Structures de contrôle[](#structures-de-controle "Lien permanent vers cette rubrique")
Les accolades désignant le corps d’un contrat, d’une bibliothèque, de fonctions et de structs doivent :
* s’ouvrir sur la même ligne que la déclaration
 
* se fermer sur leur propre ligne au même niveau d’indentation que le début de la déclaration.
 
* L’accolade d’ouverture doit être précédée d’un espace.
 
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQ29pbiB7CiAgICBzdHJ1Y3QgQmFuayB7CiAgICAgICAgYWRkcmVzcyBvd25lcjsKICAgICAgICB1aW50IGJhbGFuY2U7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract Coin {
 struct Bank {
 address owner;
 uint balance;
 }
}
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQ29pbgp7CiAgICBzdHJ1Y3QgQmFuayB7CiAgICAgICAgYWRkcmVzcyBvd25lcjsKICAgICAgICB1aW50IGJhbGFuY2U7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract Coin
{
 struct Bank {
 address owner;
 uint balance;
 }
}
Les mêmes recommandations s’appliquent aux structures de contrôle `if`, `else`, `while`, et `for`.
En outre, les structures de contrôle suivantes doivent être séparées par un espace unique `if`, `while` et `for` et le bloc entre parenthèses représentant le conditionnel, ainsi qu’un espace entre le bloc parenthétique conditionnel et l’accolade ouvrante.
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=aWYgKC4uLikgewogICAgLi4uCn0KCmZvciAoLi4uKSB7CiAgICAuLi4KfQ==)
if (...) {
 ...
}
for (...) {
 ...
}
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=aWYgKC4uLikKewogICAgLi4uCn0KCndoaWxlKC4uLil7Cn0KCmZvciAoLi4uKSB7CiAgICAuLi47fQ==)
if (...)
{
 ...
}
while(...){
}
for (...) {
 ...;}
Pour les structures de contrôle dont le corps contient une seule déclaration, l’omission des accolades est acceptable _si_ la déclaration est contenue sur une seule ligne.
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=aWYgKHggPCAxMCkKICAgIHggKz0gMTs=)
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=aWYgKHggPCAxMCkKICAgIHNvbWVBcnJheS5wdXNoKENvaW4oewogICAgICAgIG5hbWU6ICdzcGFtJywKICAgICAgICB2YWx1ZTogNDIKICAgIH0pKTs=)
if (x < 10)
 someArray.push(Coin({
 name: 'spam',
 value: 42
 }));
Pour les blocs `if` qui ont une clause `else` ou `else if`, la clause `else` doit être placée sur la même ligne que l’accolade fermant le bloc `if`. Il s’agit d’une exception par rapport aux règles des autres structures de type bloc.
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=aWYgKHggPCAzKSB7CiAgICB4ICs9IDE7Cn0gZWxzZSBpZiAoeCA+IDcpIHsKICAgIHggLT0gMTsKfSBlbHNlIHsKICAgIHggPSA1Owp9CgoKaWYgKHggPCAzKQogICAgeCArPSAxOwplbHNlCiAgICB4IC09IDE7)
if (x < 3) {
 x += 1;
} else if (x \> 7) {
 x \-= 1;
} else {
 x \= 5;
}
if (x < 3)
 x += 1;
else
 x \-= 1;
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=aWYgKHggPCAzKSB7CiAgICB4ICs9IDE7Cn0KZWxzZSB7CiAgICB4IC09IDE7Cn0=)
if (x < 3) {
 x += 1;
}
else {
 x \-= 1;
}
### Déclaration de fonction[](#declaration-de-fonction "Lien permanent vers cette rubrique")
Pour les déclarations de fonction courtes, il est recommandé de garder l’accolade d’ouverture du corps de la fonction sur la même ligne que la déclaration de la fonction.
L’accolade fermante doit être au même niveau d’indentation que la déclaration de fonction. de la fonction.
L’accolade ouvrante doit être précédée d’un seul espace.
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZnVuY3Rpb24gaW5jcmVtZW50KHVpbnQgeCkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgcmV0dXJuIHggKyAxOwp9CgpmdW5jdGlvbiBpbmNyZW1lbnQodWludCB4KSBwdWJsaWMgcHVyZSBvbmx5T3duZXIgcmV0dXJucyAodWludCkgewogICAgcmV0dXJuIHggKyAxOwp9)
function increment(uint x) public pure returns (uint) {
 return x + 1;
}
function increment(uint x) public pure onlyOwner returns (uint) {
 return x + 1;
}
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZnVuY3Rpb24gaW5jcmVtZW50KHVpbnQgeCkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkKewogICAgcmV0dXJuIHggKyAxOwp9CgpmdW5jdGlvbiBpbmNyZW1lbnQodWludCB4KSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50KXsKICAgIHJldHVybiB4ICsgMTsKfQoKZnVuY3Rpb24gaW5jcmVtZW50KHVpbnQgeCkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgcmV0dXJuIHggKyAxOwogICAgfQoKZnVuY3Rpb24gaW5jcmVtZW50KHVpbnQgeCkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgcmV0dXJuIHggKyAxO30=)
function increment(uint x) public pure returns (uint)
{
 return x + 1;
}
function increment(uint x) public pure returns (uint){
 return x + 1;
}
function increment(uint x) public pure returns (uint) {
 return x + 1;
 }
function increment(uint x) public pure returns (uint) {
 return x + 1;}
L’ordre des modificateurs pour une fonction doit être :
1. Visibilité
 
2. Mutabilité
 
3. Virtuel
 
4. Remplacer
 
5. Modificateurs personnalisés
 
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZnVuY3Rpb24gYmFsYW5jZSh1aW50IGZyb20pIHB1YmxpYyB2aWV3IG92ZXJyaWRlIHJldHVybnMgKHVpbnQpICB7CiAgICByZXR1cm4gYmFsYW5jZU9mW2Zyb21dOwp9CgpmdW5jdGlvbiBzaHV0ZG93bigpIHB1YmxpYyBvbmx5T3duZXIgewogICAgc2VsZmRlc3RydWN0KG93bmVyKTsKfQ==)
function balance(uint from) public view override returns (uint) {
 return balanceOf\[from\];
}
function shutdown() public onlyOwner {
 selfdestruct(owner);
}
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZnVuY3Rpb24gYmFsYW5jZSh1aW50IGZyb20pIHB1YmxpYyBvdmVycmlkZSB2aWV3IHJldHVybnMgKHVpbnQpICB7CiAgICByZXR1cm4gYmFsYW5jZU9mW2Zyb21dOwp9CgpmdW5jdGlvbiBzaHV0ZG93bigpIG9ubHlPd25lciBwdWJsaWMgewogICAgc2VsZmRlc3RydWN0KG93bmVyKTsKfQ==)
function balance(uint from) public override view returns (uint) {
 return balanceOf\[from\];
}
function shutdown() onlyOwner public {
 selfdestruct(owner);
}
Pour les longues déclarations de fonctions, il est recommandé de déposer chaque argument sur sa propre ligne au même niveau d’indentation que le corps de la fonction. La parenthèse fermante et la parenthèse ouvrante doivent être placées sur leur propre ligne au même niveau d’indentation que la déclaration de fonction.
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZnVuY3Rpb24gdGhpc0Z1bmN0aW9uSGFzTG90c09mQXJndW1lbnRzKAogICAgYWRkcmVzcyBhLAogICAgYWRkcmVzcyBiLAogICAgYWRkcmVzcyBjLAogICAgYWRkcmVzcyBkLAogICAgYWRkcmVzcyBlLAogICAgYWRkcmVzcyBmCikKICAgIHB1YmxpYwp7CiAgICBkb1NvbWV0aGluZygpOwp9)
function thisFunctionHasLotsOfArguments(
 address a,
 address b,
 address c,
 address d,
 address e,
 address f
)
 public
{
 doSomething();
}
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZnVuY3Rpb24gdGhpc0Z1bmN0aW9uSGFzTG90c09mQXJndW1lbnRzKGFkZHJlc3MgYSwgYWRkcmVzcyBiLCBhZGRyZXNzIGMsCiAgICBhZGRyZXNzIGQsIGFkZHJlc3MgZSwgYWRkcmVzcyBmKSBwdWJsaWMgewogICAgZG9Tb21ldGhpbmcoKTsKfQoKZnVuY3Rpb24gdGhpc0Z1bmN0aW9uSGFzTG90c09mQXJndW1lbnRzKGFkZHJlc3MgYSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgYiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgYywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgZCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgZikgcHVibGljIHsKICAgIGRvU29tZXRoaW5nKCk7Cn0KCmZ1bmN0aW9uIHRoaXNGdW5jdGlvbkhhc0xvdHNPZkFyZ3VtZW50cygKICAgIGFkZHJlc3MgYSwKICAgIGFkZHJlc3MgYiwKICAgIGFkZHJlc3MgYywKICAgIGFkZHJlc3MgZCwKICAgIGFkZHJlc3MgZSwKICAgIGFkZHJlc3MgZikgcHVibGljIHsKICAgIGRvU29tZXRoaW5nKCk7Cn0=)
function thisFunctionHasLotsOfArguments(address a, address b, address c,
 address d, address e, address f) public {
 doSomething();
}
function thisFunctionHasLotsOfArguments(address a,
 address b,
 address c,
 address d,
 address e,
 address f) public {
 doSomething();
}
function thisFunctionHasLotsOfArguments(
 address a,
 address b,
 address c,
 address d,
 address e,
 address f) public {
 doSomething();
}
Si une longue déclaration de fonction comporte des modificateurs, chaque modificateur doit être déposé sur sa propre ligne.
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZnVuY3Rpb24gdGhpc0Z1bmN0aW9uTmFtZUlzUmVhbGx5TG9uZyhhZGRyZXNzIHgsIGFkZHJlc3MgeSwgYWRkcmVzcyB6KQogICAgcHVibGljCiAgICBvbmx5T3duZXIKICAgIHByaWNlZAogICAgcmV0dXJucyAoYWRkcmVzcykKewogICAgZG9Tb21ldGhpbmcoKTsKfQoKZnVuY3Rpb24gdGhpc0Z1bmN0aW9uTmFtZUlzUmVhbGx5TG9uZygKICAgIGFkZHJlc3MgeCwKICAgIGFkZHJlc3MgeSwKICAgIGFkZHJlc3MgegopCiAgICBwdWJsaWMKICAgIG9ubHlPd25lcgogICAgcHJpY2VkCiAgICByZXR1cm5zIChhZGRyZXNzKQp7CiAgICBkb1NvbWV0aGluZygpOwp9)
function thisFunctionNameIsReallyLong(address x, address y, address z)
 public
 onlyOwner
 priced
 returns (address)
{
 doSomething();
}
function thisFunctionNameIsReallyLong(
 address x,
 address y,
 address z
)
 public
 onlyOwner
 priced
 returns (address)
{
 doSomething();
}
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZnVuY3Rpb24gdGhpc0Z1bmN0aW9uTmFtZUlzUmVhbGx5TG9uZyhhZGRyZXNzIHgsIGFkZHJlc3MgeSwgYWRkcmVzcyB6KQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1YmxpYwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ubHlPd25lcgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlZAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnMgKGFkZHJlc3MpIHsKICAgIGRvU29tZXRoaW5nKCk7Cn0KCmZ1bmN0aW9uIHRoaXNGdW5jdGlvbk5hbWVJc1JlYWxseUxvbmcoYWRkcmVzcyB4LCBhZGRyZXNzIHksIGFkZHJlc3MgeikKICAgIHB1YmxpYyBvbmx5T3duZXIgcHJpY2VkIHJldHVybnMgKGFkZHJlc3MpCnsKICAgIGRvU29tZXRoaW5nKCk7Cn0KCmZ1bmN0aW9uIHRoaXNGdW5jdGlvbk5hbWVJc1JlYWxseUxvbmcoYWRkcmVzcyB4LCBhZGRyZXNzIHksIGFkZHJlc3MgeikKICAgIHB1YmxpYwogICAgb25seU93bmVyCiAgICBwcmljZWQKICAgIHJldHVybnMgKGFkZHJlc3MpIHsKICAgIGRvU29tZXRoaW5nKCk7Cn0=)
function thisFunctionNameIsReallyLong(address x, address y, address z)
 public
 onlyOwner
 priced
 returns (address) {
 doSomething();
}
function thisFunctionNameIsReallyLong(address x, address y, address z)
 public onlyOwner priced returns (address)
{
 doSomething();
}
function thisFunctionNameIsReallyLong(address x, address y, address z)
 public
 onlyOwner
 priced
 returns (address) {
 doSomething();
}
Les paramètres de sortie et les instructions de retour multilignes doivent suivre le même style que celui recommandé pour l’habillage des longues lignes dans la section Longueur de ligne maximale.
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZnVuY3Rpb24gdGhpc0Z1bmN0aW9uTmFtZUlzUmVhbGx5TG9uZygKICAgIGFkZHJlc3MgYSwKICAgIGFkZHJlc3MgYiwKICAgIGFkZHJlc3MgYwopCiAgICBwdWJsaWMKICAgIHJldHVybnMgKAogICAgICAgIGFkZHJlc3Mgc29tZUFkZHJlc3NOYW1lLAogICAgICAgIHVpbnQyNTYgTG9uZ0FyZ3VtZW50LAogICAgICAgIHVpbnQyNTYgQXJndW1lbnQKICAgICkKewogICAgZG9Tb21ldGhpbmcoKQoKICAgIHJldHVybiAoCiAgICAgICAgdmVyeUxvbmdSZXR1cm5BcmcxLAogICAgICAgIHZlcnlMb25nUmV0dXJuQXJnMiwKICAgICAgICB2ZXJ5TG9uZ1JldHVybkFyZzMKICAgICk7Cn0=)
function thisFunctionNameIsReallyLong(
 address a,
 address b,
 address c
)
 public
 returns (
 address someAddressName,
 uint256 LongArgument,
 uint256 Argument
 )
{
 doSomething()
 return (
 veryLongReturnArg1,
 veryLongReturnArg2,
 veryLongReturnArg3
 );
}
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZnVuY3Rpb24gdGhpc0Z1bmN0aW9uTmFtZUlzUmVhbGx5TG9uZygKICAgIGFkZHJlc3MgYSwKICAgIGFkZHJlc3MgYiwKICAgIGFkZHJlc3MgYwopCiAgICBwdWJsaWMKICAgIHJldHVybnMgKGFkZHJlc3Mgc29tZUFkZHJlc3NOYW1lLAogICAgICAgICAgICAgdWludDI1NiBMb25nQXJndW1lbnQsCiAgICAgICAgICAgICB1aW50MjU2IEFyZ3VtZW50KQp7CiAgICBkb1NvbWV0aGluZygpCgogICAgcmV0dXJuICh2ZXJ5TG9uZ1JldHVybkFyZzEsCiAgICAgICAgICAgIHZlcnlMb25nUmV0dXJuQXJnMSwKICAgICAgICAgICAgdmVyeUxvbmdSZXR1cm5BcmcxKTsKfQ==)
function thisFunctionNameIsReallyLong(
 address a,
 address b,
 address c
)
 public
 returns (address someAddressName,
 uint256 LongArgument,
 uint256 Argument)
{
 doSomething()
 return (veryLongReturnArg1,
 veryLongReturnArg1,
 veryLongReturnArg1);
}
Pour les fonctions constructrices sur les contrats hérités dont les bases nécessitent des arguments, il est recommandé de déposer les constructeurs de base sur de nouvelles lignes de la même manière que les modificateurs si la déclaration de la fonction est longue ou difficile à lire.
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwovLyBDb250cmF0cyBkZSBiYXNlIGp1c3RlIHBvdXIgcXVlIGNlbGEgY29tcGlsZQpjb250cmFjdCBCIHsKICAgIGNvbnN0cnVjdG9yKHVpbnQpIHsKICAgIH0KfQpjb250cmFjdCBDIHsKICAgIGNvbnN0cnVjdG9yKHVpbnQsIHVpbnQpIHsKICAgIH0KfQpjb250cmFjdCBEIHsKICAgIGNvbnN0cnVjdG9yKHVpbnQpIHsKICAgIH0KfQoKY29udHJhY3QgQSBpcyBCLCBDLCBEIHsKICAgIHVpbnQgeDsKCiAgICBjb25zdHJ1Y3Rvcih1aW50IHBhcmFtMSwgdWludCBwYXJhbTIsIHVpbnQgcGFyYW0zLCB1aW50IHBhcmFtNCwgdWludCBwYXJhbTUpCiAgICAgICAgQihwYXJhbTEpCiAgICAgICAgQyhwYXJhbTIsIHBhcmFtMykKICAgICAgICBEKHBhcmFtNCkKICAgIHsKICAgICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCBwYXJhbTUKICAgICAgICB4ID0gcGFyYW01OwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
// Contrats de base juste pour que cela compile
contract B {
 constructor(uint) {
 }
}
contract C {
 constructor(uint, uint) {
 }
}
contract D {
 constructor(uint) {
 }
}
contract A is B, C, D {
 uint x;
 constructor(uint param1, uint param2, uint param3, uint param4, uint param5)
 B(param1)
 C(param2, param3)
 D(param4)
 {
 // do something with param5
 x \= param5;
 }
}
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKLy8gQ29udHJhdHMgZGUgYmFzZSBqdXN0ZSBwb3VyIHF1ZSBjZWxhIGNvbXBpbGUKY29udHJhY3QgQiB7CiAgICBjb25zdHJ1Y3Rvcih1aW50KSB7CiAgICB9Cn0KCgpjb250cmFjdCBDIHsKICAgIGNvbnN0cnVjdG9yKHVpbnQsIHVpbnQpIHsKICAgIH0KfQoKCmNvbnRyYWN0IEQgewogICAgY29uc3RydWN0b3IodWludCkgewogICAgfQp9CgoKY29udHJhY3QgQSBpcyBCLCBDLCBEIHsKICAgIHVpbnQgeDsKCiAgICBjb25zdHJ1Y3Rvcih1aW50IHBhcmFtMSwgdWludCBwYXJhbTIsIHVpbnQgcGFyYW0zLCB1aW50IHBhcmFtNCwgdWludCBwYXJhbTUpCiAgICBCKHBhcmFtMSkKICAgIEMocGFyYW0yLCBwYXJhbTMpCiAgICBEKHBhcmFtNCkgewogICAgICAgIHggPSBwYXJhbTU7CiAgICB9Cn0KCgpjb250cmFjdCBYIGlzIEIsIEMsIEQgewogICAgdWludCB4OwoKICAgIGNvbnN0cnVjdG9yKHVpbnQgcGFyYW0xLCB1aW50IHBhcmFtMiwgdWludCBwYXJhbTMsIHVpbnQgcGFyYW00LCB1aW50IHBhcmFtNSkKICAgICAgICBCKHBhcmFtMSkKICAgICAgICBDKHBhcmFtMiwgcGFyYW0zKQogICAgICAgIEQocGFyYW00KSB7CiAgICAgICAgICAgIHggPSBwYXJhbTU7CiAgICAgICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
// Contrats de base juste pour que cela compile
contract B {
 constructor(uint) {
 }
}
contract C {
 constructor(uint, uint) {
 }
}
contract D {
 constructor(uint) {
 }
}
contract A is B, C, D {
 uint x;
 constructor(uint param1, uint param2, uint param3, uint param4, uint param5)
 B(param1)
 C(param2, param3)
 D(param4) {
 x \= param5;
 }
}
contract X is B, C, D {
 uint x;
 constructor(uint param1, uint param2, uint param3, uint param4, uint param5)
 B(param1)
 C(param2, param3)
 D(param4) {
 x \= param5;
 }
}
Lorsque vous déclarez des fonctions courtes avec une seule déclaration, il est permis de le faire sur une seule ligne.
C’est autorisé :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZnVuY3Rpb24gc2hvcnRGdW5jdGlvbigpIHB1YmxpYyB7IGRvU29tZXRoaW5nKCk7IH0=)
function shortFunction() public { doSomething(); }
Ces directives pour les déclarations de fonctions sont destinées à améliorer la lisibilité. Les auteurs doivent faire preuve de discernement car ce guide ne prétend pas couvrir toutes les permutations possibles pour les déclarations de fonctions.
### Mappages[](#mappages "Lien permanent vers cette rubrique")
Dans les déclarations de variables, ne séparez pas le mot-clé `mapping` de son type par un espace. Ne séparez pas un mot-clé `mapping` imbriqué de son type par un espace.
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=bWFwcGluZyh1aW50ID0+IHVpbnQpIG1hcDsKbWFwcGluZyhhZGRyZXNzID0+IGJvb2wpIHJlZ2lzdGVyZWRBZGRyZXNzZXM7Cm1hcHBpbmcodWludCA9PiBtYXBwaW5nKGJvb2wgPT4gRGF0YVtdKSkgcHVibGljIGRhdGE7Cm1hcHBpbmcodWludCA9PiBtYXBwaW5nKHVpbnQgPT4gcykpIGRhdGE7)
mapping(uint \=> uint) map;
mapping(address \=> bool) registeredAddresses;
mapping(uint \=> mapping(bool \=> Data\[\])) public data;
mapping(uint \=> mapping(uint \=> s)) data;
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=bWFwcGluZyAodWludCA9PiB1aW50KSBtYXA7Cm1hcHBpbmcoIGFkZHJlc3MgPT4gYm9vbCApIHJlZ2lzdGVyZWRBZGRyZXNzZXM7Cm1hcHBpbmcgKHVpbnQgPT4gbWFwcGluZyAoYm9vbCA9PiBEYXRhW10pKSBwdWJsaWMgZGF0YTsKbWFwcGluZyh1aW50ID0+IG1hcHBpbmcgKHVpbnQgPT4gcykpIGRhdGE7)
mapping (uint \=> uint) map;
mapping( address \=> bool ) registeredAddresses;
mapping (uint \=> mapping (bool \=> Data\[\])) public data;
mapping(uint \=> mapping (uint \=> s)) data;
### Déclarations de variables[](#declarations-de-variables "Lien permanent vers cette rubrique")
Les déclarations de variables de tableau ne doivent pas comporter d’espace entre le type et les parenthèses.
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=dWludFtdIHg7)
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=dWludCBbXSB4Ow==)
### Autres recommandations[](#autres-recommandations "Lien permanent vers cette rubrique")
* Les chaînes de caractères devraient être citées avec des guillemets doubles au lieu de guillemets simples.
 
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=c3RyID0gImZvbyI7CnN0ciA9ICJIYW1sZXQgZGl0IDogJ8OKdHJlIG91IG5lIHBhcyDDqnRyZS4uLiciOw==)
str \= "foo";
str \= "Hamlet dit : 'Être ou ne pas être...'";
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=c3RyID0gJ2Jhcic7CnN0ciA9ICciU295ZXogdm91cy1tw6ptZSA7IHRvdXMgbGVzIGF1dHJlcyBzb250IGTDqWrDoCBwcmlzLiIgLU9zY2FyIFdpbGRlJzs=)
str \= 'bar';
str \= '"Soyez vous-même ; tous les autres sont déjà pris." -Oscar Wilde';
* Entourer les opérateurs d’un espace unique de chaque côté.
 
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=eCA9IDM7CnggPSAxMDAgLyAxMDsKeCArPSAzICsgNDsKeCB8PSB5ICYmIHo7)
x \= 3;
x \= 100 / 10;
x += 3 + 4;
x |\= y && z;
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=eD0zOwp4ID0gMTAwLzEwOwp4ICs9IDMrNDsKeCB8PSB5JiZ6Ow==)
x\=3;
x \= 100/10;
x += 3+4;
x |\= y&&z;
* Les opérateurs ayant une priorité plus élevée que les autres peuvent exclure les espaces afin d’indiquer la préséance. Ceci a pour but de permettre d’améliorer la lisibilité d’une déclaration complexe. Vous devez toujours utiliser la même quantité d’espaces blancs de part et d’autre d’un opérateur :
 
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=eCA9IDIqKjMgKyA1Owp4ID0gMip5ICsgMyp6Owp4ID0gKGErYikgKiAoYS1iKTs=)
x \= 2\*\*3 + 5;
x \= 2\*y + 3\*z;
x \= (a+b) \* (a\-b);
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=eCA9IDIqKiAzICsgNTsKeCA9IHkrejsKeCArPTE7)
x \= 2\*\* 3 + 5;
x \= y+z;
x +=1;
## Ordre de mise en page[](#ordre-de-mise-en-page "Lien permanent vers cette rubrique")
Disposez les éléments du contrat dans l’ordre suivant :
1. Déclarations de pragmatisme
 
2. Instructions d’importation
 
3. Interfaces
 
4. Bibliothèques
 
5. Contrats
 
À l’intérieur de chaque contrat, bibliothèque ou interface, utilisez l’ordre suivant :
1. Les déclarations de type
 
2. Variables d’état
 
3. Événements
 
4. Fonctions
 
Note
Il peut être plus clair de déclarer les types à proximité de leur utilisation dans les événements ou les variables d’état.
## Conventions d’appellation[](#conventions-d-appellation "Lien permanent vers cette rubrique")
Les conventions de dénomination sont puissantes lorsqu’elles sont adoptées et utilisées à grande échelle. L’utilisation de différentes conventions peut véhiculer des informations _méta_ significatives qui, autrement, ne seraient pas immédiatement disponibles.
Les recommandations de nommage données ici sont destinées à améliorer la lisibilité, et ne sont donc pas des règles, mais plutôt des lignes directrices pour essayer d’aider à transmettre le plus d’informations à travers les noms des choses.
Enfin, la cohérence au sein d’une base de code devrait toujours prévaloir sur les conventions décrites dans ce document.
### Styles de dénomination[](#styles-de-denomination "Lien permanent vers cette rubrique")
Pour éviter toute confusion, les noms suivants seront utilisés pour faire référence à différents styles d’appellation.
* `b` (lettre minuscule simple)
 
* `B` (lettre majuscule simple)
 
* `lettresminuscules`
 
* `minuscule_avec_underscores`
 
* `MAJUSCULE`
 
* `MAJUSCULE_AVEC_UNDERSCORES`
 
* `MotsEnMajuscule` (ou MotsEnMaj)
 
* `casMixe` (diffère des CapitalizedWords par le caractère minuscule initial !)
 
* `Mots_Capitalisés_Avec_Underscores`
 
Note
Lorsque vous utilisez des sigles dans CapWords, mettez toutes les lettres des sigles en majuscules. Ainsi, HTTPServerError est préférable à HttpServerError. Lors de l’utilisation d’initiales en mixedCase, mettez toutes les lettres des initiales en majuscules, mais gardez la première en minuscule si elle est le début du nom. Ainsi, xmlHTTPRequest est préférable à XMLHTTPRequest.
### Noms à éviter[](#noms-a-eviter "Lien permanent vers cette rubrique")
* `l` - Lettre minuscule el
 
* `O` - Lettre majuscule oh
 
* `I` - Lettre majuscule eye
 
N’utilisez jamais l’un de ces noms pour des noms de variables à une seule lettre. Elles sont souvent impossibles à distinguer des chiffres un et zéro.
### Noms de contrats et de bibliothèques[](#noms-de-contrats-et-de-bibliotheques "Lien permanent vers cette rubrique")
* Les contrats et les bibliothèques doivent être nommés en utilisant le style CapWords. Exemples : `SimpleToken`, `SmartBank`, `CertificateHashRepository`, `Player`, `Congress`, `Owned`.
 
* Les noms des contrats et des bibliothèques doivent également correspondre à leurs noms de fichiers.
 
* Si un fichier de contrat comprend plusieurs contrats et/ou bibliothèques, alors le nom du fichier doit correspondre au _contrat principal_. Cela n’est cependant pas recommandé si cela peut être évité.
 
Comme le montre l’exemple ci-dessous, si le nom du contrat est `Congress` et celui de la bibliothèque `Owned`, les noms de fichiers associés doivent être `Congress.sol` et `Owned.sol`.
Oui :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKLy8gT3duZWQuc29sCmNvbnRyYWN0IE93bmVkIHsKICAgIGFkZHJlc3MgcHVibGljIG93bmVyOwoKICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgIG93bmVyID0gbXNnLnNlbmRlcjsKICAgIH0KCiAgICBtb2RpZmllciBvbmx5T3duZXIgewogICAgICAgIHJlcXVpcmUobXNnLnNlbmRlciA9PSBvd25lcik7CiAgICAgICAgXzsKICAgIH0KCiAgICBmdW5jdGlvbiB0cmFuc2Zlck93bmVyc2hpcChhZGRyZXNzIG5ld093bmVyKSBwdWJsaWMgb25seU93bmVyIHsKICAgICAgICBvd25lciA9IG5ld093bmVyOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
// Owned.sol
contract Owned {
 address public owner;
 constructor() {
 owner \= msg.sender;
 }
 modifier onlyOwner {
 require(msg.sender \== owner);
 \_;
 }
 function transferOwnership(address newOwner) public onlyOwner {
 owner \= newOwner;
 }
}
et dans `Congress.sol` :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKaW1wb3J0ICIuL093bmVkLnNvbCI7CgoKY29udHJhY3QgQ29uZ3Jlc3MgaXMgT3duZWQsIFRva2VuUmVjaXBpZW50IHsKICAgIC8vLi4uCn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
import "./Owned.sol";
contract Congress is Owned, TokenRecipient {
 //...
}
Non :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKLy8gb3duZWQuc29sCmNvbnRyYWN0IG93bmVkIHsKICAgIGFkZHJlc3MgcHVibGljIG93bmVyOwoKICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgIG93bmVyID0gbXNnLnNlbmRlcjsKICAgIH0KCiAgICBtb2RpZmllciBvbmx5T3duZXIgewogICAgICAgIHJlcXVpcmUobXNnLnNlbmRlciA9PSBvd25lcik7CiAgICAgICAgXzsKICAgIH0KCiAgICBmdW5jdGlvbiB0cmFuc2Zlck93bmVyc2hpcChhZGRyZXNzIG5ld093bmVyKSBwdWJsaWMgb25seU93bmVyIHsKICAgICAgICBvd25lciA9IG5ld093bmVyOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
// owned.sol
contract owned {
 address public owner;
 constructor() {
 owner \= msg.sender;
 }
 modifier onlyOwner {
 require(msg.sender \== owner);
 \_;
 }
 function transferOwnership(address newOwner) public onlyOwner {
 owner \= newOwner;
 }
}
et dans `Congress.sol`:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjcuMDsKCgppbXBvcnQgIi4vb3duZWQuc29sIjsKCgpjb250cmFjdCBDb25ncmVzcyBpcyBvd25lZCwgdG9rZW5SZWNpcGllbnQgewogICAgLy8uLi4KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.7.0;
import "./owned.sol";
contract Congress is owned, tokenRecipient {
 //...
}
### Noms de structures[](#noms-de-structures "Lien permanent vers cette rubrique")
Les structures doivent être nommées en utilisant le style CapWords. Exemples :`MonCoin`, `Position`, `PositionXY`.
### Noms d’événements[](#noms-d-evenements "Lien permanent vers cette rubrique")
Les événements doivent être nommés en utilisant le style CapWords. Exemples : `Dépôt`, `Transfert`, `Approbation`, `AvantTransfert`, `AprèsTransfert`.
### Noms des fonctions[](#noms-des-fonctions "Lien permanent vers cette rubrique")
Les fonctions doivent utiliser la casse mixte. Exemples : `getBalance`, `transfer`, `verifyOwner`, `addMember`, `changeOwner`.
### Noms des arguments de la fonction[](#noms-des-arguments-de-la-fonction "Lien permanent vers cette rubrique")
Les arguments des fonctions doivent utiliser des majuscules et des minuscules. Exemples : `initialSupply`, `account`, `recipientAddress`, `senderAddress`, `newOwner`.
Lorsque vous écrivez des fonctions de bibliothèque qui opèrent sur un struct personnalisé, le struct doit être le premier argument et doit toujours être nommée `self`.
### Noms des variables locales et des variables d’état[](#noms-des-variables-locales-et-des-variables-d-etat "Lien permanent vers cette rubrique")
Utilisez la casse mixte. Exemples : `totalSupply`, `remainingSupply`, `balancesOf`, `creatorAddress`, `isPreSale`, `tokenExchangeRate`.
### Constantes[](#constantes "Lien permanent vers cette rubrique")
Les constantes doivent être nommées avec des lettres majuscules et des caractères de soulignement pour séparer les mots. Exemples : `MAX_BLOCKS`, `TOKEN_NAME`, `TOKEN_TICKER`, `CONTRACT_VERSION`.
### Noms des modificateurs[](#noms-des-modificateurs "Lien permanent vers cette rubrique")
Utilisez la casse mixte. Exemples : `onlyBy`, `onlyAfter`, `onlyDuringThePreSale`.
### Enums[](#enums "Lien permanent vers cette rubrique")
Les Enums, dans le style des déclarations de type simples, doivent être nommés en utilisant le style CapWords. Exemples : `TokenGroup`, `Frame`, `HashStyle`, `CharacterLocation`.
### Éviter les collisions de noms[](#eviter-les-collisions-de-noms "Lien permanent vers cette rubrique")
* `single_trailing_underscore_`
 
Cette convention est suggérée lorsque le nom souhaité entre en collision avec celui d’un nom intégré ou autrement réservé.
## NatSpec[](#natspec "Lien permanent vers cette rubrique")
Les contrats Solidity peuvent également contenir des commentaires NatSpec. Ils sont écrits avec une triple barre oblique (`///`) ou un double astérisque (`/** ... */`). Ils doivent être utilisés directement au-dessus des déclarations de fonctions ou des instructions.
Par exemple, le contrat de [un smart contract simple](https://docs.soliditylang.org/fr/latest/introduction-to-smart-contracts.html#simple-smart-contract) avec les commentaires ajoutés, ressemble à celui ci-dessous :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCi8vLyBAYXV0aG9yIEwnw6lxdWlwZSBTb2xpZGl0eQovLy8gQHRpdGxlIFVuIGV4ZW1wbGUgc2ltcGxlIGRlIHN0b2NrYWdlCmNvbnRyYWN0IFNpbXBsZVN0b3JhZ2UgewogICAgdWludCBzdG9yZWREYXRhOwoKICAgIC8vLyBTdG9ja2UgYHhgLgogICAgLy8vIEBwYXJhbSB4IGxhIG5vdXZlbGxlIHZhbGV1ciDDoCBzdG9ja2VyCiAgICAvLy8gQGRldiBzdG9ja2UgbGUgbm9tYnJlIGRhbnMgbGEgdmFyaWFibGUgZCfDqXRhdCBgc3RvcmVkRGF0YWAuCiAgICBmdW5jdGlvbiBzZXQodWludCB4KSBwdWJsaWMgewogICAgICAgIHN0b3JlZERhdGEgPSB4OwogICAgfQoKICAgIC8vLyBSZXRvdXJuZXIgbGEgdmFsZXVyIHN0b2Nrw6llLgogICAgLy8vIEBkZXYgcsOpY3Vww6hyZSBsYSB2YWxldXIgZGUgbGEgdmFyaWFibGUgZCfDqXRhdCBgc3RvcmVkRGF0YWAuCiAgICAvLy8gQHJldG91cm5lIGxhIHZhbGV1ciBzdG9ja8OpZQogICAgZnVuY3Rpb24gZ2V0KCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBzdG9yZWREYXRhOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
/// @author L'équipe Solidity
/// @title Un exemple simple de stockage
contract SimpleStorage {
 uint storedData;
 /// Stocke \`x\`.
 /// @param x la nouvelle valeur à stocker
 /// @dev stocke le nombre dans la variable d'état \`storedData\`.
 function set(uint x) public {
 storedData \= x;
 }
 /// Retourner la valeur stockée.
 /// @dev récupère la valeur de la variable d'état \`storedData\`.
 /// @retourne la valeur stockée
 function get() public view returns (uint) {
 return storedData;
 }
}
Il est recommandé que les contrats Solidity soient entièrement annotés en utilisant [NatSpec](https://docs.soliditylang.org/fr/latest/natspec-format.html#natspec) pour toutes les interfaces publiques (tout ce qui se trouve dans l’ABI).
Veuillez consulter la section sur [NatSpec](https://docs.soliditylang.org/fr/latest/natspec-format.html#natspec) pour une explication détaillée.

# [Modèles communs — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/common-patterns.html) 
 _https://docs.soliditylang.org/fr/latest/common-patterns.html_

## Retrait des contrats[](#retrait-des-contrats "Lien permanent vers cette rubrique")
La méthode recommandée pour envoyer des fonds après un effet est d’utiliser le modèle de retrait. Bien que la méthode la plus intuitive la méthode la plus intuitive pour envoyer de l’Ether, suite à un effet, est un appel direct de « transfert », ce n’est pas recommandé car il introduit un car elle introduit un risque potentiel de sécurité. Vous pouvez lire plus d’informations à ce sujet sur la page [Considérations de sécurité](https://docs.soliditylang.org/fr/latest/security-considerations.html#security-considerations).
Voici un exemple du schéma de retrait en pratique dans un contrat où l’objectif est d’envoyer le plus d’argent vers le contrat afin de devenir le plus « riche », inspiré de [King of the Ether](https://www.kingoftheether.com/).
Dans le contrat suivant, si vous n’êtes plus le plus riche, vous recevez les fonds de la personne qui est maintenant la plus riche.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IFdpdGhkcmF3YWxDb250cmFjdCB7CiAgICBhZGRyZXNzIHB1YmxpYyByaWNoZXN0OwogICAgdWludCBwdWJsaWMgbW9zdFNlbnQ7CgogICAgbWFwcGluZyAoYWRkcmVzcyA9PiB1aW50KSBwZW5kaW5nV2l0aGRyYXdhbHM7CgogICAgLy8vIExhIHF1YW50aXTDqSBkJ0V0aGVyIGVudm95w6kgbifDqXRhaXQgcGFzIHN1cMOpcmlldXIgYXUKICAgIC8vLyBtb250YW50IGxlIHBsdXMgw6lsZXbDqSBhY3R1ZWxsZW1lbnQuCiAgICBlcnJvciBOb3RFbm91Z2hFdGhlcigpOwoKICAgIGNvbnN0cnVjdG9yKCkgcGF5YWJsZSB7CiAgICAgICAgcmljaGVzdCA9IG1zZy5zZW5kZXI7CiAgICAgICAgbW9zdFNlbnQgPSBtc2cudmFsdWU7CiAgICB9CgogICAgZnVuY3Rpb24gYmVjb21lUmljaGVzdCgpIHB1YmxpYyBwYXlhYmxlIHsKICAgICAgICBpZiAobXNnLnZhbHVlIDw9IG1vc3RTZW50KSByZXZlcnQgTm90RW5vdWdoRXRoZXIoKTsKICAgICAgICBwZW5kaW5nV2l0aGRyYXdhbHNbcmljaGVzdF0gKz0gbXNnLnZhbHVlOwogICAgICAgIHJpY2hlc3QgPSBtc2cuc2VuZGVyOwogICAgICAgIG1vc3RTZW50ID0gbXNnLnZhbHVlOwogICAgfQoKICAgIGZ1bmN0aW9uIHdpdGhkcmF3KCkgcHVibGljIHsKICAgICAgICB1aW50IGFtb3VudCA9IHBlbmRpbmdXaXRoZHJhd2Fsc1ttc2cuc2VuZGVyXTsKICAgICAgICAvLyBOJ291YmxpZXogcGFzIGRlIG1ldHRyZSDDoCB6w6lybyBsZSByZW1ib3Vyc2VtZW50IGVuIGF0dGVudGUgYXZhbnQKICAgICAgICAvLyBsJ2Vudm9pIHBvdXIgw6l2aXRlciBsZXMgYXR0YXF1ZXMgZGUgcsOpLWVudHJhbmNlCiAgICAgICAgcGVuZGluZ1dpdGhkcmF3YWxzW21zZy5zZW5kZXJdID0gMDsKICAgICAgICBwYXlhYmxlKG1zZy5zZW5kZXIpLnRyYW5zZmVyKGFtb3VudCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract WithdrawalContract {
 address public richest;
 uint public mostSent;
 mapping (address \=> uint) pendingWithdrawals;
 /// La quantité d'Ether envoyé n'était pas supérieur au
 /// montant le plus élevé actuellement.
 error NotEnoughEther();
 constructor() payable {
 richest \= msg.sender;
 mostSent \= msg.value;
 }
 function becomeRichest() public payable {
 if (msg.value <= mostSent) revert NotEnoughEther();
 pendingWithdrawals\[richest\] += msg.value;
 richest \= msg.sender;
 mostSent \= msg.value;
 }
 function withdraw() public {
 uint amount \= pendingWithdrawals\[msg.sender\];
 // N'oubliez pas de mettre à zéro le remboursement en attente avant
 // l'envoi pour éviter les attaques de ré-entrance
 pendingWithdrawals\[msg.sender\] \= 0;
 payable(msg.sender).transfer(amount);
 }
}
Cela s’oppose au modèle d’envoi plus intuitif :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IFNlbmRDb250cmFjdCB7CiAgICBhZGRyZXNzIHBheWFibGUgcHVibGljIHJpY2hlc3Q7CiAgICB1aW50IHB1YmxpYyBtb3N0U2VudDsKCiAgICAvLy8gTGEgcXVhbnRpdMOpIGQnRXRoZXIgZW52b3nDqWUgbifDqXRhaXQgcGFzIHBsdXMgw6lsZXbDqWUgcXVlCiAgICAvLy8gbGUgbW9udGFudCBsZSBwbHVzIMOpbGV2w6kgYWN0dWVsbGVtZW50LgogICAgZXJyb3IgTm90RW5vdWdoRXRoZXIoKTsKCiAgICBjb25zdHJ1Y3RvcigpIHBheWFibGUgewogICAgICAgIHJpY2hlc3QgPSBwYXlhYmxlKG1zZy5zZW5kZXIpOwogICAgICAgIG1vc3RTZW50ID0gbXNnLnZhbHVlOwogICAgfQoKICAgIGZ1bmN0aW9uIGJlY29tZVJpY2hlc3QoKSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgaWYgKG1zZy52YWx1ZSA8PSBtb3N0U2VudCkgcmV2ZXJ0IE5vdEVub3VnaEV0aGVyKCk7CiAgICAgICAgLy8gQ2V0dGUgbGlnbmUgcGV1dCBjYXVzZXIgZGVzIHByb2Jsw6htZXMgKGV4cGxpcXXDqXMgY2ktZGVzc291cykuCiAgICAgICAgcmljaGVzdC50cmFuc2Zlcihtc2cudmFsdWUpOwogICAgICAgIHJpY2hlc3QgPSBwYXlhYmxlKG1zZy5zZW5kZXIpOwogICAgICAgIG1vc3RTZW50ID0gbXNnLnZhbHVlOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract SendContract {
 address payable public richest;
 uint public mostSent;
 /// La quantité d'Ether envoyée n'était pas plus élevée que
 /// le montant le plus élevé actuellement.
 error NotEnoughEther();
 constructor() payable {
 richest \= payable(msg.sender);
 mostSent \= msg.value;
 }
 function becomeRichest() public payable {
 if (msg.value <= mostSent) revert NotEnoughEther();
 // Cette ligne peut causer des problèmes (expliqués ci-dessous).
 richest.transfer(msg.value);
 richest \= payable(msg.sender);
 mostSent \= msg.value;
 }
}
Remarquez que, dans cet exemple, un attaquant pourrait piéger le contrat dans un état inutilisable en faisant en sorte que `richest` soit l’adresse d’un contrat qui possède une fonction de réception ou de repli qui échoue (par exemple en utilisant `revert()` ou simplement en consommant plus que l’allocation de 2300 gaz qui leur a été transférée). De cette façon, chaque fois que `transfer` est appelé pour livrer des fonds au contrat « empoisonné », il échouera et donc aussi `becomeRichest` échouera aussi, et le contrat sera bloqué pour toujours.
En revanche, si vous utilisez le motif « withdraw » du premier exemple, l’attaquant ne peut faire échouer que son propre retrait, et pas le reste le reste du fonctionnement du contrat.
## Restriction de l’accès[](#restriction-de-l-acces "Lien permanent vers cette rubrique")
La restriction de l’accès est un modèle courant pour les contrats. Notez que vous ne pouvez jamais empêcher un humain ou un ordinateur de lire le contenu de vos transactions ou l’état de votre contrat. Vous pouvez rendre les choses un peu plus difficiles en utilisant le cryptage, mais si votre contrat est supposé lire les données, tout le monde le fera aussi.
Vous pouvez restreindre l’accès en lecture à l’état de votre contrat par **d’autres contrats**. C’est en fait le cas par défaut sauf si vous déclarez vos variables d’état `public`.
De plus, vous pouvez restreindre les personnes qui peuvent apporter des modifications l’état de votre contrat ou appeler les fonctions de votre contrat. fonctions de votre contrat et c’est ce dont il est question dans cette section.
L’utilisation de **modificateurs de fonction** permet de rendre ces restrictions très lisibles.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IEFjY2Vzc1Jlc3RyaWN0aW9uIHsKICAgIC8vIElscyBzZXJvbnQgYXR0cmlidcOpcyBsb3JzIGRlIGxhIGNvbnN0cnVjdGlvbgogICAgLy8gcGhhc2UgZGUgY29uc3RydWN0aW9uLCBvw7kgYG1zZy5zZW5kZXJgIGVzdCBsZSBjb21wdGUKICAgIC8vIHF1aSBjcsOpZSBjZSBjb250cmF0LgogICAgYWRkcmVzcyBwdWJsaWMgb3duZXIgPSBtc2cuc2VuZGVyOwogICAgdWludCBwdWJsaWMgY3JlYXRpb25UaW1lID0gYmxvY2sudGltZXN0YW1wOwoKICAgIC8vIFN1aXQgbWFpbnRlbmFudCB1bmUgbGlzdGUgZCdlcnJldXJzIHF1ZQogICAgLy8gY2UgY29udHJhdCBwZXV0IGfDqW7DqXJlciBhaW5zaSBxdWUKICAgIC8vIGF2ZWMgdW5lIGV4cGxpY2F0aW9uIHRleHR1ZWxsZSBkYW5zIGRlcwogICAgLy8gY29tbWVudGFpcmVzIHNww6ljaWF1eC4KCiAgICAvLy8gTCdleHDDqWRpdGV1ciBuJ2VzdCBwYXMgYXV0b3Jpc8OpIHBvdXIgY2V0dGUKICAgIC8vLyBvcMOpcmF0aW9uLgogICAgZXJyb3IgVW5hdXRob3JpemVkKCk7CgogICAgLy8vIExhIGZvbmN0aW9uIGVzdCBhcHBlbMOpZSB0cm9wIHTDtHQuCiAgICBlcnJvciBUb29FYXJseSgpOwoKICAgIC8vLyBQYXMgYXNzZXogZCdFdGhlciBlbnZvecOpIGF2ZWMgbCdhcHBlbCBkZSBmb25jdGlvbi4KICAgIGVycm9yIE5vdEVub3VnaEV0aGVyKCk7CgogICAgLy8gTGVzIG1vZGlmaWNhdGV1cnMgcGV1dmVudCDDqnRyZSB1dGlsaXPDqXMgcG91ciBjaGFuZ2VyCiAgICAvLyBsZSBjb3JwcyBkJ3VuZSBmb25jdGlvbi4KICAgIC8vIFNpIGNlIG1vZGlmaWNhdGV1ciBlc3QgdXRpbGlzw6ksIGlsCiAgICAvLyBham91dGVyYSB1bmUgdsOpcmlmaWNhdGlvbiBxdWkgbmUgc2UgcGFzc2UKICAgIC8vIHF1ZSBzaSBsYSBmb25jdGlvbiBlc3QgYXBwZWzDqWUgZGVwdWlzCiAgICAvLyB1bmUgY2VydGFpbmUgYWRyZXNzZS4KICAgIG1vZGlmaWVyIG9ubHlCeShhZGRyZXNzIF9hY2NvdW50KQogICAgewogICAgICAgIGlmIChtc2cuc2VuZGVyICE9IF9hY2NvdW50KQogICAgICAgICAgICByZXZlcnQgVW5hdXRob3JpemVkKCk7CiAgICAgICAgLy8gTidvdWJsaWV6IHBhcyBsZSAiXzsiISBJbCBzZXJhCiAgICAgICAgLy8gcmVtcGxhY8OpIHBhciBsZSBjb3JwcyBkZSBsYSBmb25jdGlvbgogICAgICAgIC8vIHLDqWVsbGUgbG9yc3F1ZSBsZSBtb2RpZmljYXRldXIgZXN0IHV0aWxpc8OpLgogICAgICAgIF87CiAgICB9CgogICAgLy8vIEZhaXJlIGRlIGBfbmV3T3duZXJgIGxlIG5vdXZlYXUgcHJvcHJpw6l0YWlyZSBkZSBjZQogICAgLy8vIGNvbnRyYXQuCiAgICBmdW5jdGlvbiBjaGFuZ2VPd25lcihhZGRyZXNzIF9uZXdPd25lcikKICAgICAgICBwdWJsaWMKICAgICAgICBvbmx5Qnkob3duZXIpCiAgICB7CiAgICAgICAgb3duZXIgPSBfbmV3T3duZXI7CiAgICB9CgogICAgbW9kaWZpZXIgb25seUFmdGVyKHVpbnQgX3RpbWUpIHsKICAgICAgICBpZiAoYmxvY2sudGltZXN0YW1wIDwgX3RpbWUpCiAgICAgICAgICAgIHJldmVydCBUb29FYXJseSgpOwogICAgICAgIF87CiAgICB9CgogICAgLy8vIEVmZmFjZXIgbGVzIGluZm9ybWF0aW9ucyBzdXIgbGEgcHJvcHJpw6l0w6kuCiAgICAvLy8gTmUgcGV1dCDDqnRyZSBhcHBlbMOpIHF1ZSA2IHNlbWFpbmVzIGFwcsOocwogICAgLy8vIHF1ZSBsZSBjb250cmF0IGFpdCDDqXTDqSBjcsOpw6kuCiAgICBmdW5jdGlvbiBkaXNvd24oKQogICAgICAgIHB1YmxpYwogICAgICAgIG9ubHlCeShvd25lcikKICAgICAgICBvbmx5QWZ0ZXIoY3JlYXRpb25UaW1lICsgNiB3ZWVrcykKICAgIHsKICAgICAgICBkZWxldGUgb3duZXI7CiAgICB9CgogICAgLy8gQ2UgbW9kaWZpY2F0ZXVyIGV4aWdlIHF1J3VuIGNlcnRhaW4KICAgIC8vIGZyYWlzIMOpdGFudCBhc3NvY2nDqSDDoCB1biBhcHBlbCBkZSBmb25jdGlvbi4KICAgIC8vIFNpIGwnYXBwZWxhbnQgYSBlbnZvecOpIHRyb3AgZGUgZnJhaXMsIGlsIG91IGVsbGUgZXN0CiAgICAvLyByZW1ib3Vyc8OpLCBtYWlzIHNldWxlbWVudCBhcHLDqHMgbGUgY29ycHMgZGUgbGEgZm9uY3Rpb24uCiAgICAvLyBDZWNpIMOpdGFpdCBkYW5nZXJldXggYXZhbnQgbGEgdmVyc2lvbiAwLjQuMCBkZSBTb2xpZGl0eSwKICAgIC8vIG/DuSBpbCDDqXRhaXQgcG9zc2libGUgZGUgc2F1dGVyIGxhIHBhcnRpZSBhcHLDqHMgYF87YC4KICAgIG1vZGlmaWVyIGNvc3RzKHVpbnQgX2Ftb3VudCkgewogICAgICAgIGlmIChtc2cudmFsdWUgPCBfYW1vdW50KQogICAgICAgICAgICByZXZlcnQgTm90RW5vdWdoRXRoZXIoKTsKCiAgICAgICAgXzsKICAgICAgICBpZiAobXNnLnZhbHVlID4gX2Ftb3VudCkKICAgICAgICAgICAgcGF5YWJsZShtc2cuc2VuZGVyKS50cmFuc2Zlcihtc2cudmFsdWUgLSBfYW1vdW50KTsKICAgIH0KCiAgICBmdW5jdGlvbiBmb3JjZU93bmVyQ2hhbmdlKGFkZHJlc3MgX25ld093bmVyKQogICAgICAgIHB1YmxpYwogICAgICAgIHBheWFibGUKICAgICAgICBjb3N0cygyMDAgZXRoZXIpCiAgICB7CiAgICAgICAgb3duZXIgPSBfbmV3T3duZXI7CiAgICAgICAgLy8ganVzdGUgcXVlbHF1ZXMgZXhlbXBsZXMgZGUgY29uZGl0aW9ucwogICAgICAgIGlmICh1aW50MTYwKG93bmVyKSAmIDAgPT0gMSkKICAgICAgICAgICAgLy8gQ2VsYSBuJ2EgcGFzIHJlbWJvdXJzw6kgcG91ciBTb2xpZGl0eQogICAgICAgICAgICAvLyBhdmFudCBsYSB2ZXJzaW9uIDAuNC4wLgogICAgICAgICAgICByZXR1cm47CiAgICAgICAgLy8gcmVtYm91cnNlciBsZXMgZnJhaXMgcGF5w6lzIGVuIHRyb3AKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract AccessRestriction {
 // Ils seront attribués lors de la construction
 // phase de construction, où \`msg.sender\` est le compte
 // qui crée ce contrat.
 address public owner \= msg.sender;
 uint public creationTime \= block.timestamp;
 // Suit maintenant une liste d'erreurs que
 // ce contrat peut générer ainsi que
 // avec une explication textuelle dans des
 // commentaires spéciaux.
 /// L'expéditeur n'est pas autorisé pour cette
 /// opération.
 error Unauthorized();
 /// La fonction est appelée trop tôt.
 error TooEarly();
 /// Pas assez d'Ether envoyé avec l'appel de fonction.
 error NotEnoughEther();
 // Les modificateurs peuvent être utilisés pour changer
 // le corps d'une fonction.
 // Si ce modificateur est utilisé, il
 // ajoutera une vérification qui ne se passe
 // que si la fonction est appelée depuis
 // une certaine adresse.
 modifier onlyBy(address \_account)
 {
 if (msg.sender != \_account)
 revert Unauthorized();
 // N'oubliez pas le "\_;"! Il sera
 // remplacé par le corps de la fonction
 // réelle lorsque le modificateur est utilisé.
 \_;
 }
 /// Faire de \`\_newOwner\` le nouveau propriétaire de ce
 /// contrat.
 function changeOwner(address \_newOwner)
 public
 onlyBy(owner)
 {
 owner \= \_newOwner;
 }
 modifier onlyAfter(uint \_time) {
 if (block.timestamp < \_time)
 revert TooEarly();
 \_;
 }
 /// Effacer les informations sur la propriété.
 /// Ne peut être appelé que 6 semaines après
 /// que le contrat ait été créé.
 function disown()
 public
 onlyBy(owner)
 onlyAfter(creationTime + 6 weeks)
 {
 delete owner;
 }
 // Ce modificateur exige qu'un certain
 // frais étant associé à un appel de fonction.
 // Si l'appelant a envoyé trop de frais, il ou elle est
 // remboursé, mais seulement après le corps de la fonction.
 // Ceci était dangereux avant la version 0.4.0 de Solidity,
 // où il était possible de sauter la partie après \`\_;\`.
 modifier costs(uint \_amount) {
 if (msg.value < \_amount)
 revert NotEnoughEther();
 \_;
 if (msg.value \> \_amount)
 payable(msg.sender).transfer(msg.value \- \_amount);
 }
 function forceOwnerChange(address \_newOwner)
 public
 payable
 costs(200 ether)
 {
 owner \= \_newOwner;
 // juste quelques exemples de conditions
 if (uint160(owner) & 0 \== 1)
 // Cela n'a pas remboursé pour Solidity
 // avant la version 0.4.0.
 return;
 // rembourser les frais payés en trop
 }
}
Une manière plus spécialisée de restreindre l’accès aux appels peut être restreint, sera abordée dans l’exemple suivant.
## Machine à états[](#machine-a-etats "Lien permanent vers cette rubrique")
Les contrats se comportent souvent comme une machine à états, ce qui signifie qu’ils ont certaines **étapes** dans lesquelles ils se comportent différemment ou dans lesquelles différentes fonctions peuvent être appelées. Un appel de fonction termine souvent une étape et fait passer le contrat à l’étape suivante (surtout si le contrat modélise une **interaction**). Il est également courant que certaines étapes soient automatiquement à un certain moment dans le **temps**.
Par exemple, un contrat d’enchères à l’aveugle qui commence à l’étape « accepter des offres à l’aveugle », puis qui passe ensuite à l’étape « révéler les offres » et qui se termine par « déterminer le résultat de l’enchère ».
Les modificateurs de fonction peuvent être utilisés dans cette situation pour modéliser les états et se prémunir contre l’utilisation incorrecte du contrat.
### Exemple[](#exemple "Lien permanent vers cette rubrique")
Dans l’exemple suivant, le modificateur `atStage` assure que la fonction ne peut être appelée qu’à un certain stade.
Les transitions automatiques temporisées sont gérées par le modificateur `timedTransitions`, devrait être utilisé pour toutes les fonctions.
Note
**L’ordre des modificateurs est important**. Si atStage est combiné avec timedTransitions, assurez-vous que vous le mentionnez après cette dernière, afin que la nouvelle étape soit prise en compte.
Enfin, le modificateur `transitionNext` peut être utilisé pour passer automatiquement à l’étape suivante lorsque la fonction se termine.
Note
**Le Modificateur Peut Être Ignoré**. Ceci s’applique uniquement à Solidity avant la version 0.4.0 : Puisque les modificateurs sont appliqués en remplaçant simplement code et non en utilisant un appel de fonction, le code dans le modificateur transitionNext peut être ignoré si la fonction elle-même utilise return. Si vous voulez faire cela, assurez-vous d’appeler nextStage manuellement à partir de ces fonctions. À partir de la version 0.4.0, le code du modificateur sera exécuté même si la fonction retourne explicitement.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IFN0YXRlTWFjaGluZSB7CiAgICBlbnVtIFN0YWdlcyB7CiAgICAgICAgQWNjZXB0aW5nQmxpbmRlZEJpZHMsCiAgICAgICAgUmV2ZWFsQmlkcywKICAgICAgICBBbm90aGVyU3RhZ2UsCiAgICAgICAgQXJlV2VEb25lWWV0LAogICAgICAgIEZpbmlzaGVkCiAgICB9CiAgICAvLy8gTGEgZm9uY3Rpb24gbmUgcGV1dCBwYXMgw6p0cmUgYXBwZWzDqWUgcG91ciBsZSBtb21lbnQuCiAgICBlcnJvciBGdW5jdGlvbkludmFsaWRBdFRoaXNTdGFnZSgpOwoKICAgIC8vIElsIHMnYWdpdCBkZSBsJ8OpdGFwZSBhY3R1ZWxsZS4KICAgIFN0YWdlcyBwdWJsaWMgc3RhZ2UgPSBTdGFnZXMuQWNjZXB0aW5nQmxpbmRlZEJpZHM7CgogICAgdWludCBwdWJsaWMgY3JlYXRpb25UaW1lID0gYmxvY2sudGltZXN0YW1wOwoKICAgIG1vZGlmaWVyIGF0U3RhZ2UoU3RhZ2VzIF9zdGFnZSkgewogICAgICAgIGlmIChzdGFnZSAhPSBfc3RhZ2UpCiAgICAgICAgICAgIHJldmVydCBGdW5jdGlvbkludmFsaWRBdFRoaXNTdGFnZSgpOwogICAgICAgIF87CiAgICB9CgogICAgZnVuY3Rpb24gbmV4dFN0YWdlKCkgaW50ZXJuYWwgewogICAgICAgIHN0YWdlID0gU3RhZ2VzKHVpbnQoc3RhZ2UpICsgMSk7CiAgICB9CgogICAgLy8gRWZmZWN0dWV6IGRlcyB0cmFuc2l0aW9ucyBjaHJvbm9tw6l0csOpZXMuIFZlaWxsZXogw6AgbWVudGlvbm5lcgogICAgLy8gY2UgbW9kaWZpY2F0ZXVyIGVuIHByZW1pZXIsIHNpbm9uIGxlcyBnYXJkZXMKICAgIC8vIG5lIHRpZW5kcm9udCBwYXMgY29tcHRlIGRlIGxhIG5vdXZlbGxlIMOpdGFwZS4KICAgIG1vZGlmaWVyIHRpbWVkVHJhbnNpdGlvbnMoKSB7CiAgICAgICAgaWYgKHN0YWdlID09IFN0YWdlcy5BY2NlcHRpbmdCbGluZGVkQmlkcyAmJgogICAgICAgICAgICAgICAgICAgIGJsb2NrLnRpbWVzdGFtcCA+PSBjcmVhdGlvblRpbWUgKyAxMCBkYXlzKQogICAgICAgICAgICBuZXh0U3RhZ2UoKTsKICAgICAgICBpZiAoc3RhZ2UgPT0gU3RhZ2VzLlJldmVhbEJpZHMgJiYKICAgICAgICAgICAgICAgIGJsb2NrLnRpbWVzdGFtcCA+PSBjcmVhdGlvblRpbWUgKyAxMiBkYXlzKQogICAgICAgICAgICBuZXh0U3RhZ2UoKTsKICAgICAgICAvLyBMZXMgYXV0cmVzIMOpdGFwZXMgc2UgZMOpcm91bGVudCBwYXIgdHJhbnNhY3Rpb24KICAgICAgICBfOwogICAgfQoKICAgIC8vIEwnb3JkcmUgZGVzIG1vZGlmaWNhdGV1cnMgZXN0IGltcG9ydGFudCBpY2kgIQogICAgZnVuY3Rpb24gYmlkKCkKICAgICAgICBwdWJsaWMKICAgICAgICBwYXlhYmxlCiAgICAgICAgdGltZWRUcmFuc2l0aW9ucwogICAgICAgIGF0U3RhZ2UoU3RhZ2VzLkFjY2VwdGluZ0JsaW5kZWRCaWRzKQogICAgewogICAgICAgIC8vIE5vdXMgbidpbXBsw6ltZW50ZXJvbnMgcGFzIGNlbGEgaWNpCiAgICB9CgogICAgZnVuY3Rpb24gcmV2ZWFsKCkKICAgICAgICBwdWJsaWMKICAgICAgICB0aW1lZFRyYW5zaXRpb25zCiAgICAgICAgYXRTdGFnZShTdGFnZXMuUmV2ZWFsQmlkcykKICAgIHsKICAgIH0KCiAgICAvLyBDZSBtb2RpZmljYXRldXIgcGFzc2Ugw6AgbCfDqXRhcGUgc3VpdmFudGUKICAgIC8vIGFwcsOocyBxdWUgbGEgZm9uY3Rpb24gc29pdCB0ZXJtaW7DqWUuCiAgICBtb2RpZmllciB0cmFuc2l0aW9uTmV4dCgpCiAgICB7CiAgICAgICAgXzsKICAgICAgICBuZXh0U3RhZ2UoKTsKICAgIH0KCiAgICBmdW5jdGlvbiBnKCkKICAgICAgICBwdWJsaWMKICAgICAgICB0aW1lZFRyYW5zaXRpb25zCiAgICAgICAgYXRTdGFnZShTdGFnZXMuQW5vdGhlclN0YWdlKQogICAgICAgIHRyYW5zaXRpb25OZXh0CiAgICB7CiAgICB9CgogICAgZnVuY3Rpb24gaCgpCiAgICAgICAgcHVibGljCiAgICAgICAgdGltZWRUcmFuc2l0aW9ucwogICAgICAgIGF0U3RhZ2UoU3RhZ2VzLkFyZVdlRG9uZVlldCkKICAgICAgICB0cmFuc2l0aW9uTmV4dAogICAgewogICAgfQoKICAgIGZ1bmN0aW9uIGkoKQogICAgICAgIHB1YmxpYwogICAgICAgIHRpbWVkVHJhbnNpdGlvbnMKICAgICAgICBhdFN0YWdlKFN0YWdlcy5GaW5pc2hlZCkKICAgIHsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract StateMachine {
 enum Stages {
 AcceptingBlindedBids,
 RevealBids,
 AnotherStage,
 AreWeDoneYet,
 Finished
 }
 /// La fonction ne peut pas être appelée pour le moment.
 error FunctionInvalidAtThisStage();
 // Il s'agit de l'étape actuelle.
 Stages public stage \= Stages.AcceptingBlindedBids;
 uint public creationTime \= block.timestamp;
 modifier atStage(Stages \_stage) {
 if (stage != \_stage)
 revert FunctionInvalidAtThisStage();
 \_;
 }
 function nextStage() internal {
 stage \= Stages(uint(stage) + 1);
 }
 // Effectuez des transitions chronométrées. Veillez à mentionner
 // ce modificateur en premier, sinon les gardes
 // ne tiendront pas compte de la nouvelle étape.
 modifier timedTransitions() {
 if (stage \== Stages.AcceptingBlindedBids &&
 block.timestamp \>= creationTime + 10 days)
 nextStage();
 if (stage \== Stages.RevealBids &&
 block.timestamp \>= creationTime + 12 days)
 nextStage();
 // Les autres étapes se déroulent par transaction
 \_;
 }
 // L'ordre des modificateurs est important ici !
 function bid()
 public
 payable
 timedTransitions
 atStage(Stages.AcceptingBlindedBids)
 {
 // Nous n'implémenterons pas cela ici
 }
 function reveal()
 public
 timedTransitions
 atStage(Stages.RevealBids)
 {
 }
 // Ce modificateur passe à l'étape suivante
 // après que la fonction soit terminée.
 modifier transitionNext()
 {
 \_;
 nextStage();
 }
 function g()
 public
 timedTransitions
 atStage(Stages.AnotherStage)
 transitionNext
 {
 }
 function h()
 public
 timedTransitions
 atStage(Stages.AreWeDoneYet)
 transitionNext
 {
 }
 function i()
 public
 timedTransitions
 atStage(Stages.Finished)
 {
 }
}

# [资源 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/resources.html) 
 _https://docs.soliditylang.org/zh-cn/latest/resources.html_

## 资源[](#id1 "此标题的永久链接")
## 一般资源[](#id2 "此标题的永久链接")
* [Ethereum.org开发者门户网站](https://ethereum.org/en/developers/)
 
* [Ethereum StackExchange](https://ethereum.stackexchange.com/)
 
* [Solidity门户网站](https://soliditylang.org/)
 
* [Solidity变更日志](https://github.com/ethereum/solidity/blob/develop/Changelog.md)
 
* [GitHub上的Solidity源代码](https://github.com/ethereum/solidity/)
 
* [Solidity语言用户聊天室](https://matrix.to/#/#ethereum_solidity:gitter.im)
 
* [Solidity编译器开发人员聊天室](https://matrix.to/#/#ethereum_solidity-dev:gitter.im)
 
* [很棒的Solidity](https://github.com/bkrem/awesome-solidity)
 
* [通过实例学Solidity](https://solidity-by-example.org/)
 
* [Solidity文档社区翻译](https://github.com/solidity-docs)
 
## 集成（以太坊）开发环境[](#id9 "此标题的永久链接")
> * [Brownie](https://eth-brownie.readthedocs.io/en/stable/)
> 
> 面向以太坊虚拟机的基于Python的智能合约开发和测试框架。
> 
> * [Dapp](https://dapp.tools/)
> 
> 用于从命令行构建，测试和部署智能合约的工具。
> 
> * [Foundry](https://github.com/foundry-rs/foundry)
> 
> 用Rust编写的用于Ethereum应用开发的快速，可移植和模块化的工具包。
> 
> * [Hardhat](https://hardhat.org/)
> 
> 以太坊开发环境具有本地以太坊网络，调试功能和插件生态系统。
> 
> * [Remix](https://remix.ethereum.org/)
> 
> 基于浏览器的IDE，具有集成的编译器和Solidity运行环境，没有服务器端组件。
> 
> * [Truffle](https://trufflesuite.com/truffle/)
> 
> 以太坊开发框架。
> 
## 编辑器集成[](#id10 "此标题的永久链接")
* Emacs
 
 > * [Emacs Solidity](https://github.com/ethereum/emacs-solidity/)
 > 
 > Emacs编辑器的插件，提供语法高亮和编译错误报告。
 > 
 
* IntelliJ
 
 > * [IntelliJ IDEA 插件](https://plugins.jetbrains.com/plugin/9475-solidity/)
 > 
 > IntelliJ IDEA（和所有其他JetBrains IDEs）的Solidity插件
 > 
 
* Sublime Text
 
 > * [SublimeText的软件包 - Solidity语言语法](https://packagecontrol.io/packages/Ethereum/)
 > 
 > 用于 SublimeText 编辑器的 Solidity 语法高亮。
 > 
 
* Vim
 
 > * [Thesis 的 Vim Solidity](https://github.com/thesis/vim-solidity/)
 > 
 > Vim 中 Solidity 的语法高亮。
 > 
 > * [TovarishFin 的 Vim Solidity](https://github.com/TovarishFin/vim-solidity)
 > 
 > Solidity 的 Vim 语法文件。
 > 
 > * [Vim Syntastic](https://github.com/vim-syntastic/syntastic)
 > 
 > 为Vim编辑器提供编译检查的插件。
 > 
 
* Visual Studio Code (VS Code)
 
 > * [以太坊 Remix 的 Visual Studio 代码扩展包](https://github.com/ethereum/remix-vscode)
 > 
 > VS Code 的以太坊 Remix 扩展包
 > 
 > * [Juan Blanco 的 Solidity Visual Studio 代码扩展包](https://juan.blanco.ws/solidity-contracts-in-visual-studio-code/)
 > 
 > Microsoft Visual Studio Code 的 Solidity 插件，包括语法高亮和 Solidity 编译器。
 > 
 > * [Nomic Foundation 的 Solidity Visual Studio 代码扩展包](https://marketplace.visualstudio.com/items?itemName=NomicFoundation.hardhat-solidity)
 > 
 > 由Hardhat团队提供的Solidity和Hardhat支持，包括：语法高亮，跳转到定义，重命名，快速修复和内联solc警告和错误。
 > 
 > * [Solidity 可视化审计扩展](https://marketplace.visualstudio.com/items?itemName=tintinweb.solidity-visual-auditor)
 > 
 > 在Visual Studio Code中增加了以安全为中心的语法和语义突出显示。
 > 
 > * [用于 VS Code 的 Truffle](https://marketplace.visualstudio.com/items?itemName=trufflesuite-csi.truffle-vscode)
 > 
 > 在Ethereum和EVM兼容的区块链上构建，调试和部署智能合约。
 > 
 
* [ABI到Solidity接口转换器](https://gist.github.com/chriseth/8f533d133fa0c15b0d6eaf3ec502c82b)
 
 一个用于从智能合约的ABI生成合约接口的脚本。
 
* [abi-to-sol](https://github.com/gnidan/abi-to-sol)
 
 从一个给定的ABI JSON生成Solidity接口源的工具。
 
* [Doxity](https://github.com/DigixGlobal/doxity)
 
 Solidity的文档生成器。
 
* [Ethlint](https://github.com/duaraghav8/Ethlint)
 
 识别和修复Solidity中的风格和安全问题的语法检查器。
 
* [evmdis](https://github.com/Arachnid/evmdis)
 
 EVM反汇编程序，对字节码进行静态分析，提供比原始EVM操作更高的抽象水平。
 
* [EVM Lab](https://github.com/ethereum/evmlab/)
 
 丰富的工具包，与EVM互动。包括一个虚拟机、以太链API，以及一个带有燃料成本显示的跟踪查看器。
 
* [hevm](https://github.com/dapphub/dapptools/tree/master/src/hevm#readme)
 
 EVM调试器和符号执行引擎。
 
* [leafleth](https://github.com/clemlak/leafleth)
 
 Solidity智能合约的文档生成器。
 
* [Scaffold-ETH](https://github.com/scaffold-eth/scaffold-eth)
 
 专注于产品快速迭代的可分叉的以太坊开发堆栈。
 
* [sol2uml](https://www.npmjs.com/package/sol2uml)
 
 Solidity合约的统一建模语言（UML）类图生成器。
 
* [solc-select](https://github.com/crytic/solc-select)
 
 一个在 Solidity 编译器版本之间快速切换的脚本。
 
* [优化Solidity语言格式插件](https://github.com/prettier-solidity/prettier-plugin-solidity)
 
 Solidity格式美化插件。
 
* [Solidity REPL](https://github.com/raineorshine/solidity-repl)
 
 使用命令行solidity控制台立即尝试solidity。
 
* [solgraph](https://github.com/raineorshine/solgraph)
 
 可视化Solidity控制流并突出潜在的安全漏洞。
 
* [Solhint](https://github.com/protofire/solhint)
 
 Solidity语法检查器，为智能合约的验证提供安全，风格指南和最佳实践规则。
 
* [Sourcify](https://sourcify.dev/)
 
 去中心化的自动合约验证服务和合约元数据的公共存储库。
 
* [Sūrya](https://github.com/ConsenSys/surya/)
 
 智能合约系统的实用工具，提供一些可视化输出和关于合约结构的信息。还支持查询函数调用图。
 
* [Universal Mutator](https://github.com/agroce/universalmutator)
 
 一个用于突变生成的工具，具有可配置的规则并支持Solidity和Vyper。
 
## 第三方Solidity解析器和语法[](#id14 "此标题的永久链接")
* [用于JavaScript的Solidity解析器](https://github.com/solidity-parser/parser)
 
 一个建立在强大的ANTLR4语法之上的JS Solidity解析器。

# [Introduction to Smart Contracts — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html) 
 _https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html_

## A Simple Smart Contract[](#a-simple-smart-contract "Link to this heading")
Let us begin with a basic example that sets the value of a variable and exposes it for other contracts to access. It is fine if you do not understand everything right now, we will go into more details later.
### Storage Example[](#storage-example "Link to this heading")
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZVN0b3JhZ2UgewogICAgdWludCBzdG9yZWREYXRhOwoKICAgIGZ1bmN0aW9uIHNldCh1aW50IHgpIHB1YmxpYyB7CiAgICAgICAgc3RvcmVkRGF0YSA9IHg7CiAgICB9CgogICAgZnVuY3Rpb24gZ2V0KCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBzdG9yZWREYXRhOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract SimpleStorage {
 uint storedData;
 function set(uint x) public {
 storedData \= x;
 }
 function get() public view returns (uint) {
 return storedData;
 }
}
The first line tells you that the source code is licensed under the GPL version 3.0. Machine-readable license specifiers are important in a setting where publishing the source code is the default.
The next line specifies that the source code is written for Solidity version 0.4.16, or a newer version of the language up to, but not including version 0.9.0. This is to ensure that the contract is not compilable with a new (breaking) compiler version, where it could behave differently. [Pragmas](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#pragma) are common instructions for compilers about how to treat the source code (e.g. [pragma once](https://en.wikipedia.org/wiki/Pragma_once)).
A contract in the sense of Solidity is a collection of code (its _functions_) and data (its _state_) that resides at a specific address on the Ethereum blockchain. The line `uint storedData;` declares a state variable called `storedData` of type `uint` (_u_nsigned _int_eger of _256_ bits). You can think of it as a single slot in a database that you can query and alter by calling functions of the code that manages the database. In this example, the contract defines the functions `set` and `get` that can be used to modify or retrieve the value of the variable.
To access a member (like a state variable) of the current contract, you do not typically add the `this.` prefix, you just access it directly via its name. Unlike in some other languages, omitting it is not just a matter of style, it results in a completely different way to access the member, but more on this later.
This contract does not do much yet apart from (due to the infrastructure built by Ethereum) allowing anyone to store a single number that is accessible by anyone in the world without a (feasible) way to prevent you from publishing this number. Anyone could call `set` again with a different value and overwrite your number, but the number is still stored in the history of the blockchain. Later, you will see how you can impose access restrictions so that only you can alter the number.
Warning
Be careful with using Unicode text, as similar looking (or even identical) characters can have different code points and as such are encoded as a different byte array.
Note
All identifiers (contract names, function names and variable names) are restricted to the ASCII character set. It is possible to store UTF-8 encoded data in string variables.
### Subcurrency Example[](#subcurrency-example "Link to this heading")
The following contract implements the simplest form of a cryptocurrency. The contract allows only its creator to create new coins (different issuance schemes are possible). Anyone can send coins to each other without a need for registering with a username and password, all you need is an Ethereum keypair.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjY7CgovLyBUaGlzIHdpbGwgb25seSBjb21waWxlIHZpYSBJUgpjb250cmFjdCBDb2luIHsKICAgIC8vIFRoZSBrZXl3b3JkICJwdWJsaWMiIG1ha2VzIHZhcmlhYmxlcwogICAgLy8gYWNjZXNzaWJsZSBmcm9tIG90aGVyIGNvbnRyYWN0cwogICAgYWRkcmVzcyBwdWJsaWMgbWludGVyOwogICAgbWFwcGluZyhhZGRyZXNzID0+IHVpbnQpIHB1YmxpYyBiYWxhbmNlczsKCiAgICAvLyBFdmVudHMgYWxsb3cgY2xpZW50cyB0byByZWFjdCB0byBzcGVjaWZpYwogICAgLy8gY29udHJhY3QgY2hhbmdlcyB5b3UgZGVjbGFyZQogICAgZXZlbnQgU2VudChhZGRyZXNzIGZyb20sIGFkZHJlc3MgdG8sIHVpbnQgYW1vdW50KTsKCiAgICAvLyBDb25zdHJ1Y3RvciBjb2RlIGlzIG9ubHkgcnVuIHdoZW4gdGhlIGNvbnRyYWN0CiAgICAvLyBpcyBjcmVhdGVkCiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgICBtaW50ZXIgPSBtc2cuc2VuZGVyOwogICAgfQoKICAgIC8vIFNlbmRzIGFuIGFtb3VudCBvZiBuZXdseSBjcmVhdGVkIGNvaW5zIHRvIGFuIGFkZHJlc3MKICAgIC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSB0aGUgY29udHJhY3QgY3JlYXRvcgogICAgZnVuY3Rpb24gbWludChhZGRyZXNzIHJlY2VpdmVyLCB1aW50IGFtb3VudCkgcHVibGljIHsKICAgICAgICByZXF1aXJlKG1zZy5zZW5kZXIgPT0gbWludGVyKTsKICAgICAgICBiYWxhbmNlc1tyZWNlaXZlcl0gKz0gYW1vdW50OwogICAgfQoKICAgIC8vIEVycm9ycyBhbGxvdyB5b3UgdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dAogICAgLy8gd2h5IGFuIG9wZXJhdGlvbiBmYWlsZWQuIFRoZXkgYXJlIHJldHVybmVkCiAgICAvLyB0byB0aGUgY2FsbGVyIG9mIHRoZSBmdW5jdGlvbi4KICAgIGVycm9yIEluc3VmZmljaWVudEJhbGFuY2UodWludCByZXF1ZXN0ZWQsIHVpbnQgYXZhaWxhYmxlKTsKCiAgICAvLyBTZW5kcyBhbiBhbW91bnQgb2YgZXhpc3RpbmcgY29pbnMKICAgIC8vIGZyb20gYW55IGNhbGxlciB0byBhbiBhZGRyZXNzCiAgICBmdW5jdGlvbiBzZW5kKGFkZHJlc3MgcmVjZWl2ZXIsIHVpbnQgYW1vdW50KSBwdWJsaWMgewogICAgICAgIHJlcXVpcmUoYW1vdW50IDw9IGJhbGFuY2VzW21zZy5zZW5kZXJdLCBJbnN1ZmZpY2llbnRCYWxhbmNlKGFtb3VudCwgYmFsYW5jZXNbbXNnLnNlbmRlcl0pKTsKICAgICAgICBiYWxhbmNlc1ttc2cuc2VuZGVyXSAtPSBhbW91bnQ7CiAgICAgICAgYmFsYW5jZXNbcmVjZWl2ZXJdICs9IGFtb3VudDsKICAgICAgICBlbWl0IFNlbnQobXNnLnNlbmRlciwgcmVjZWl2ZXIsIGFtb3VudCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.26;
// This will only compile via IR
contract Coin {
 // The keyword "public" makes variables
 // accessible from other contracts
 address public minter;
 mapping(address \=> uint) public balances;
 // Events allow clients to react to specific
 // contract changes you declare
 event Sent(address from, address to, uint amount);
 // Constructor code is only run when the contract
 // is created
 constructor() {
 minter \= msg.sender;
 }
 // Sends an amount of newly created coins to an address
 // Can only be called by the contract creator
 function mint(address receiver, uint amount) public {
 require(msg.sender \== minter);
 balances\[receiver\] += amount;
 }
 // Errors allow you to provide information about
 // why an operation failed. They are returned
 // to the caller of the function.
 error InsufficientBalance(uint requested, uint available);
 // Sends an amount of existing coins
 // from any caller to an address
 function send(address receiver, uint amount) public {
 require(amount <= balances\[msg.sender\], InsufficientBalance(amount, balances\[msg.sender\]));
 balances\[msg.sender\] \-= amount;
 balances\[receiver\] += amount;
 emit Sent(msg.sender, receiver, amount);
 }
}
This contract introduces some new concepts, let us go through them one by one.
The line `address public minter;` declares a state variable of type [address](https://docs.soliditylang.org/en/latest/types.html#address). The `address` type is a 160-bit value that does not allow any arithmetic operations. It is suitable for storing addresses of contracts, or a hash of the public half of a keypair belonging to [external accounts](#accounts).
The keyword `public` automatically generates a function that allows you to access the current value of the state variable from outside of the contract. Without this keyword, other contracts have no way to access the variable. The code of the function generated by the compiler is equivalent to the following (ignore `external` and `view` for now):
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=ZnVuY3Rpb24gbWludGVyKCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChhZGRyZXNzKSB7IHJldHVybiBtaW50ZXI7IH0=)
function minter() external view returns (address) { return minter; }
You could add a function like the above yourself, but you would have a function and state variable with the same name. You do not need to do this, the compiler figures it out for you.
The next line, `mapping(address => uint) public balances;` also creates a public state variable, but it is a more complex datatype. The [mapping](https://docs.soliditylang.org/en/latest/types.html#mapping-types) type maps addresses to [unsigned integers](https://docs.soliditylang.org/en/latest/types.html#integers).
Mappings can be seen as [hash tables](https://en.wikipedia.org/wiki/Hash_table) which are virtually initialized such that every possible key exists from the start and is mapped to a value whose byte-representation is all zeros. However, it is neither possible to obtain a list of all keys of a mapping, nor a list of all values. Record what you added to the mapping, or use it in a context where this is not needed. Or even better, keep a list, or use a more suitable data type.
The [getter function](https://docs.soliditylang.org/en/latest/contracts.html#getter-functions) created by the `public` keyword is more complex in the case of a mapping. It looks like the following:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=ZnVuY3Rpb24gYmFsYW5jZXMoYWRkcmVzcyBhY2NvdW50KSBleHRlcm5hbCB2aWV3IHJldHVybnMgKHVpbnQpIHsKICAgIHJldHVybiBiYWxhbmNlc1thY2NvdW50XTsKfQ==)
function balances(address account) external view returns (uint) {
 return balances\[account\];
}
You can use this function to query the balance of a single account.
The line `event Sent(address from, address to, uint amount);` declares an [“event”](https://docs.soliditylang.org/en/latest/contracts.html#events), which is emitted in the last line of the function `send`. Ethereum clients such as web applications can listen for these events emitted on the blockchain without much cost. As soon as it is emitted, the listener receives the arguments `from`, `to` and `amount`, which makes it possible to track transactions.
To listen for this event, you could use the following JavaScript code, which uses [web3.js](https://github.com/web3/web3.js/) to create the `Coin` contract object, and any user interface calls the automatically generated `balances` function from above:
Coin.Sent().watch({}, '', function(error, result) {
 if (!error) {
 console.log("Coin transfer: " + result.args.amount +
 " coins were sent from " + result.args.from +
 " to " + result.args.to + ".");
 console.log("Balances now:\\n" +
 "Sender: " + Coin.balances.call(result.args.from) +
 "Receiver: " + Coin.balances.call(result.args.to));
 }
})
The [constructor](https://docs.soliditylang.org/en/latest/contracts.html#constructor) is a special function that is executed during the creation of the contract and cannot be called afterwards. In this case, it permanently stores the address of the person creating the contract. The `msg` variable (together with `tx` and `block`) is a [special global variable](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#special-variables-functions) that contains properties which allow access to the blockchain. `msg.sender` is always the address where the current (external) function call came from.
The functions that make up the contract, and that users and contracts can call are `mint` and `send`.
The `mint` function sends an amount of newly created coins to another address. The [require](https://docs.soliditylang.org/en/latest/control-structures.html#assert-and-require) function call defines conditions that reverts all changes if not met. In this example, `require(msg.sender == minter);` ensures that only the creator of the contract can call `mint`. In general, the creator can mint as many tokens as they like, but at some point, this will lead to a phenomenon called “overflow”. Note that because of the default [Checked arithmetic](https://docs.soliditylang.org/en/latest/control-structures.html#unchecked), the transaction would revert if the expression `balances[receiver] += amount;` overflows, i.e., when `balances[receiver] + amount` in arbitrary precision arithmetic is larger than the maximum value of `uint` (`2**256 - 1`). This is also true for the statement `balances[receiver] += amount;` in the function `send`.
[Errors](https://docs.soliditylang.org/en/latest/contracts.html#errors) allow you to provide more information to the caller about why a condition or operation failed. Errors are used together with the [revert statement](https://docs.soliditylang.org/en/latest/control-structures.html#revert-statement). The `revert` statement unconditionally aborts and reverts all changes, much like the [require function](https://docs.soliditylang.org/en/latest/control-structures.html#assert-and-require-statements). Both approaches allow you to provide the name of an error and additional data which will be supplied to the caller (and eventually to the front-end application or block explorer) so that a failure can more easily be debugged or reacted upon.
The `send` function can be used by anyone (who already has some of these coins) to send coins to anyone else. If the sender does not have enough coins to send, the `if` condition evaluates to true. As a result, the `revert` will cause the operation to fail while providing the sender with error details using the `InsufficientBalance` error.
Note
If you use this contract to send coins to an address, you will not see anything when you look at that address on a blockchain explorer, because the record that you sent coins and the changed balances are only stored in the data storage of this particular coin contract. By using events, you can create a “blockchain explorer” that tracks transactions and balances of your new coin, but you have to inspect the coin contract address and not the addresses of the coin owners.
## Blockchain Basics[](#blockchain-basics "Link to this heading")
Blockchains as a concept are not too hard to understand for programmers. The reason is that most of the complications (mining, [hashing](https://en.wikipedia.org/wiki/Cryptographic_hash_function), [elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic_curve_cryptography), [peer-to-peer networks](https://en.wikipedia.org/wiki/Peer-to-peer), etc.) are just there to provide a certain set of features and promises for the platform. Once you accept these features as given, you do not have to worry about the underlying technology - or do you have to know how Amazon’s AWS works internally in order to use it?
### Transactions[](#transactions "Link to this heading")
A blockchain is a globally shared, transactional database. This means that everyone can read entries in the database just by participating in the network. If you want to change something in the database, you have to create a so-called transaction which has to be accepted by all others. The word transaction implies that the change you want to make (assume you want to change two values at the same time) is either not done at all or completely applied. Furthermore, while your transaction is being applied to the database, no other transaction can alter it.
As an example, imagine a table that lists the balances of all accounts in an electronic currency. If a transfer from one account to another is requested, the transactional nature of the database ensures that if the amount is subtracted from one account, it is always added to the other account. If due to whatever reason, adding the amount to the target account is not possible, the source account is also not modified.
Furthermore, a transaction is always cryptographically signed by the sender (creator). This makes it straightforward to guard access to specific modifications of the database. In the example of the electronic currency, a simple check ensures that only the person holding the keys to the account can transfer some compensation, e.g. Ether, from it.
### Blocks[](#blocks "Link to this heading")
One major obstacle to overcome is what (in Bitcoin terms) is called a “double-spend attack”: What happens if two transactions exist in the network that both want to empty an account? Only one of the transactions can be valid, typically the one that is accepted first. The problem is that “first” is not an objective term in a peer-to-peer network.
The abstract answer to this is that you do not have to care. A globally accepted order of the transactions will be selected for you, solving the conflict. The transactions will be bundled into what is called a “block” and then they will be executed and distributed among all participating nodes. If two transactions contradict each other, the one that ends up being second will be rejected and not become part of the block.
These blocks form a linear sequence in time, and that is where the word “blockchain” derives from. Blocks are added to the chain at regular intervals, although these intervals may be subject to change in the future. For the most up-to-date information, it is recommended to monitor the network, for example, on [Etherscan](https://etherscan.io/chart/blocktime).
As part of the “order selection mechanism”, which is called [attestation](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/attestations/), it may happen that blocks are reverted from time to time, but only at the “tip” of the chain. The more blocks are added on top of a particular block, the less likely this block will be reverted. So it might be that your transactions are reverted and even removed from the blockchain, but the longer you wait, the less likely it will be.
Note
Transactions are not guaranteed to be included in the next block or any specific future block, since it is not up to the submitter of a transaction, but up to the miners to determine in which block the transaction is included.
If you want to schedule future calls of your contract, you can use a smart contract automation tool or an oracle service.
## The Ethereum Virtual Machine[](#index-6 "Link to this heading")
### Overview[](#overview "Link to this heading")
The Ethereum Virtual Machine or EVM is the runtime environment for smart contracts in Ethereum. It is not only sandboxed but actually completely isolated, which means that code running inside the EVM has no access to network, filesystem or other processes. Smart contracts even have limited access to other smart contracts.
### Accounts[](#accounts "Link to this heading")
There are two kinds of accounts in Ethereum which share the same address space: **External accounts** that are controlled by public-private key pairs (i.e. humans) and **contract accounts** which are controlled by the code stored together with the account.
The address of an external account is determined from the public key while the address of a contract is determined at the time the contract is created (it is derived from the creator address and the number of transactions sent from that address, the so-called “nonce”).
Regardless of whether or not the account stores code, the two types are treated equally by the EVM.
Every account has a persistent key-value store mapping 256-bit words to 256-bit words called **storage**.
Furthermore, every account has a **balance** in Ether (in “Wei” to be exact, `1 ether` is `10**18 wei`) which can be modified by sending transactions that include Ether.
### Transactions[](#index-8 "Link to this heading")
A transaction is a message that is sent from one account to another account (which might be the same or empty, see below). It can include binary data (which is called “payload”) and Ether.
If the target account contains code, that code is executed and the payload is provided as input data.
If the target account is not set (the transaction does not have a recipient or the recipient is set to `null`), the transaction creates a **new contract**. As already mentioned, the address of that contract is not the zero address but an address derived from the sender and its number of transactions sent (the “nonce”). The payload of such a contract creation transaction is taken to be EVM bytecode and executed. The output data of this execution is permanently stored as the code of the contract. This means that in order to create a contract, you do not send the actual code of the contract, but in fact code that returns that code when executed.
Note
While a contract is being created, its code is still empty. Because of that, you should not call back into the contract under construction until its constructor has finished executing.
### Gas[](#gas "Link to this heading")
Upon creation, each transaction is charged with a certain amount of **gas** that has to be paid for by the originator of the transaction (`tx.origin`). While the EVM executes the transaction, the gas is gradually depleted according to specific rules. If the gas is used up at any point (i.e. it would be negative), an out-of-gas exception is triggered, which ends execution and reverts all modifications made to the state in the current call frame.
This mechanism incentivizes economical use of EVM execution time and also compensates EVM executors (i.e. miners / stakers) for their work. Since each block has a maximum amount of gas, it also limits the amount of work needed to validate a block.
The **gas price** is a value set by the originator of the transaction, who has to pay `gas_price * gas` up front to the EVM executor. If some gas is left after execution, it is refunded to the transaction originator. In case of an exception that reverts changes, already used up gas is not refunded.
Since EVM executors can choose to include a transaction or not, transaction senders cannot abuse the system by setting a low gas price.
### Storage, Transient Storage, Memory and the Stack[](#storage-transient-storage-memory-and-the-stack "Link to this heading")
The Ethereum Virtual Machine has different areas where it can store data with the most prominent being storage, transient storage, memory and the stack.
Each account has a data area called **storage**, which is persistent between function calls and transactions. Storage is a key-value store that maps 256-bit words to 256-bit words. It is not possible to enumerate storage from within a contract, it is comparatively costly to read, and even more to initialise and modify storage. Because of this cost, you should minimize what you store in persistent storage to what the contract needs to run. Store data like derived calculations, caching, and aggregates outside of the contract. A contract can neither read nor write to any storage apart from its own.
Similar to storage, there is another data area called **transient storage**, where the main difference is that it is reset at the end of each transaction. The values stored in this data location persist only across function calls originating from the first call of the transaction. When the transaction ends, the transient storage is reset and the values stored there become unavailable to calls in subsequent transactions. Despite this, the cost of reading and writing to transient storage is significantly lower than for storage.
The third data area is called **memory**, of which a contract obtains a freshly cleared instance for each message call. Memory is linear and can be addressed at byte level, but reads are limited to a width of 256 bits, while writes can be either 8 bits or 256 bits wide. Memory is expanded by a word (256-bit), when accessing (either reading or writing) a previously untouched memory word (i.e. any offset within a word). At the time of expansion, the cost in gas must be paid. Memory is more costly the larger it grows (it scales quadratically).
The EVM is not a register machine but a stack machine, so all computations are performed on a data area called the **stack**. It has a maximum size of 1024 elements and contains words of 256 bits. Access to the stack is limited to the top end in the following way: It is possible to copy one of the topmost 16 elements to the top of the stack or swap the topmost element with one of the 16 elements below it. All other operations take the topmost two (or one, or more, depending on the operation) elements from the stack and push the result onto the stack. Of course it is possible to move stack elements to storage or memory in order to get deeper access to the stack, but it is not possible to just access arbitrary elements deeper in the stack without first removing the top of the stack.
### Calldata, Returndata and Code[](#calldata-returndata-and-code "Link to this heading")
There are also other data areas which are not as apparent as those discussed previously. However, they are routinely used during the execution of smart contract transactions.
The calldata region is the data sent to a transaction as part of a smart contract transaction. For example, when creating a contract, calldata would be the constructor code of the new contract. The parameters of external functions are always initially stored in calldata in an ABI-encoded form and only then decoded into the location specified in their declaration. If declared as `memory`, the compiler will eagerly decode them into memory at the beginning of the function, while marking them as `calldata` means that this will be done lazily, only when accessed. Value types and `storage` pointers are decoded directly onto the stack.
The returndata is the way a smart contract can return a value after a call. In general, external Solidity functions use the `return` keyword to ABI-encode values into the returndata area.
The code is the region where the EVM instructions of a smart contract are stored. Code is the bytes read, interpreted, and executed by the EVM during smart contract execution. Instruction data stored in the code is persistent as part of a contract account state field. Immutable and constant variables are stored in the code region. All references to immutables are replaced with the values assigned to them. A similar process is performed for constants which have their expressions inlined in the places where they are referenced in the smart contract code.
### Instruction Set[](#instruction-set "Link to this heading")
The instruction set of the EVM is kept minimal in order to avoid incorrect or inconsistent implementations which could cause consensus problems. All instructions operate on the basic data type, 256-bit words or on slices of memory (or other byte arrays). The usual arithmetic, bit, logical and comparison operations are present. Conditional and unconditional jumps are possible. Furthermore, contracts can access relevant properties of the current block like its number and timestamp.
For a complete list, please see the [list of opcodes](https://docs.soliditylang.org/en/latest/yul.html#opcodes) as part of the inline assembly documentation.
### Message Calls[](#message-calls "Link to this heading")
Contracts can call other contracts or send Ether to non-contract accounts by the means of message calls. Message calls are similar to transactions, in that they have a source, a target, data payload, Ether, gas and return data. In fact, every transaction consists of a top-level message call which in turn can create further message calls.
A contract can decide how much of its remaining **gas** should be sent with the inner message call and how much it wants to retain. If an out-of-gas exception happens in the inner call (or any other exception), this will be signaled by an error value put onto the stack. In this case, only the gas sent together with the call is used up. In Solidity, the calling contract causes a manual exception by default in such situations, so that exceptions “bubble up” the call stack.
As already said, the called contract (which can be the same as the caller) will receive a freshly cleared instance of memory and has access to the call payload - which will be provided in a separate area called the **calldata**. After it has finished execution, it can return data which will be stored at a location in the caller’s memory preallocated by the caller. All such calls are fully synchronous.
Calls are **limited** to a depth of 1024, which means that for more complex operations, loops should be preferred over recursive calls. Furthermore, only 63/64th of the gas can be forwarded in a message call, which causes a depth limit of a little less than 1000 in practice.
### Delegatecall and Libraries[](#delegatecall-and-libraries "Link to this heading")
There exists a special variant of a message call, named **delegatecall** which is identical to a message call apart from the fact that the code at the target address is executed in the context (i.e. at the address) of the calling contract and `msg.sender` and `msg.value` do not change their values.
This means that a contract can dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract, only the code is taken from the called address.
This makes it possible to implement the “library” feature in Solidity: Reusable library code that can be applied to a contract’s storage, e.g. in order to implement a complex data structure.
### Logs[](#logs "Link to this heading")
It is possible to store data in a specially indexed data structure that maps all the way up to the block level. This feature called **logs** is used by Solidity in order to implement [events](https://docs.soliditylang.org/en/latest/contracts.html#events). Contracts cannot access log data after it has been created, but they can be efficiently accessed from outside the blockchain. Since some part of the log data is stored in [bloom filters](https://en.wikipedia.org/wiki/Bloom_filter), it is possible to search for this data in an efficient and cryptographically secure way, so network peers that do not download the whole blockchain (so-called “light clients”) can still find these logs.
### Create[](#create "Link to this heading")
Contracts can even create other contracts using a special opcode (i.e. they do not simply call the zero address as a transaction would). The only difference between these **create calls** and normal message calls is that the payload data is executed and the result stored as code and the caller / creator receives the address of the new contract on the stack.
### Deactivate and Self-destruct[](#deactivate-and-self-destruct "Link to this heading")
The only way to remove code from the blockchain is when a contract at that address performs the `selfdestruct` operation. The remaining Ether stored at that address is sent to a designated target and then the storage and code is removed from the state. Removing the contract in theory sounds like a good idea, but it is potentially dangerous, as if someone sends Ether to removed contracts, the Ether is forever lost.
Warning
From `EVM >= Cancun` onwards, `selfdestruct` will **only** send all Ether in the account to the given recipient and not destroy the contract. However, when `selfdestruct` is called in the same transaction that creates the contract calling it, the behaviour of `selfdestruct` before Cancun hardfork (i.e., `EVM <= Shanghai`) is preserved and will destroy the current contract, deleting any data, including storage keys, code and the account itself. See [EIP-6780](https://eips.ethereum.org/EIPS/eip-6780) for more details.
The new behaviour is the result of a network-wide change that affects all contracts present on the Ethereum mainnet and testnets. It is important to note that this change is dependent on the EVM version of the chain on which the contract is deployed. The `--evm-version` setting used when compiling the contract has no bearing on it.
Also, note that the `selfdestruct` opcode has been deprecated in Solidity version 0.8.18, as recommended by [EIP-6049](https://eips.ethereum.org/EIPS/eip-6049). The deprecation is still in effect and the compiler will still emit warnings on its use. Any use in newly deployed contracts is strongly discouraged even if the new behavior is taken into account. Future changes to the EVM might further reduce the functionality of the opcode.
Warning
Even if a contract is removed by `selfdestruct`, it is still part of the history of the blockchain and probably retained by most Ethereum nodes. So using `selfdestruct` is not the same as deleting data from a hard disk.
Note
Even if a contract’s code does not contain a call to `selfdestruct`, it can still perform that operation using `delegatecall` or `callcode`.
If you want to deactivate your contracts, you should instead **disable** them by changing some internal state which causes all functions to revert. This makes it impossible to use the contract, as it returns Ether immediately.
### Precompiled Contracts[](#precompiled-contracts "Link to this heading")
There is a small set of contract addresses that are special: The address range between `1` and (including) `0x0a` contains “precompiled contracts” that can be called as any other contract but their behavior (and their gas consumption) is not defined by EVM code stored at that address (they do not contain code) but instead is implemented in the EVM execution environment itself.
Different EVM-compatible chains might use a different set of precompiled contracts. It might also be possible that new precompiled contracts are added to the Ethereum main chain in the future, but you can reasonably expect them to always be in the range between `1` and `0xffff` (inclusive).

