# [Cleaning Up Variables — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/internals/variable_cleanup.html) 
 _https://docs.soliditylang.org/en/latest/internals/variable_cleanup.html_

Ultimately, all values in the EVM are stored in 256 bit words. Thus, in some cases, when the type of a value has less than 256 bits, it is necessary to clean the remaining bits. The Solidity compiler is designed to do such cleaning before any operations that might be adversely affected by the potential garbage in the remaining bits. For example, before writing a value to memory, the remaining bits need to be cleared because the memory contents can be used for computing hashes or sent as the data of a message call. Similarly, before storing a value in the storage, the remaining bits need to be cleaned because otherwise the garbled value can be observed.
Note that access via inline assembly is not considered such an operation: If you use inline assembly to access Solidity variables shorter than 256 bits, the compiler does not guarantee that the value is properly cleaned up.
Moreover, we do not clean the bits if the immediately following operation is not affected. For instance, since any non-zero value is considered `true` by `JUMPI` instruction, we do not clean the boolean values before they are used as the condition for `JUMPI`.
In addition to the design principle above, the Solidity compiler cleans input data when it is loaded onto the stack.
The following table describes the cleaning rules applied to different types, where `higher bits` refers to the remaining bits in case the type has less than 256 bits.
Type
Valid Values
Cleanup of Invalid Values
enum of n members
0 until n - 1
throws exception
bool
0 or 1
results in 1
signed integers
higher bits set to the sign bit
currently silently signextends to a valid value, i.e. all higher bits are set to the sign bit; may throw an exception in the future
unsigned integers
higher bits zeroed
currently silently masks to a valid value, i.e. all higher bits are set to zero; may throw an exception in the future
Note that valid and invalid values are dependent on their type size. Consider `uint8`, the unsigned 8-bit type, which has the following valid values:
0000...0000 0000 0000
0000...0000 0000 0001
0000...0000 0000 0010
....
0000...0000 1111 1111
Any invalid value will have the higher bits set to zero:
0101...1101 0010 1010 invalid value
0000...0000 0010 1010 cleaned value
For `int8`, the signed 8-bit type, the valid values are:
Negative
1111...1111 1111 1111
1111...1111 1111 1110
....
1111...1111 1000 0000
Positive
0000...0000 0000 0000
0000...0000 0000 0001
0000...0000 0000 0010
....
0000...0000 1111 1111
The compiler will `signextend` the sign bit, which is 1 for negative and 0 for positive values, overwriting the higher bits:
Negative
0010...1010 1111 1111 invalid value
1111...1111 1111 1111 cleaned value
Positive
1101...0101 0000 0100 invalid value
0000...0000 0000 0100 cleaned value

# [Solidity v0.8.0 Breaking Changes — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/080-breaking-changes.html) 
 _https://docs.soliditylang.org/en/v0.8.30/080-breaking-changes.html_

This section highlights the main breaking changes introduced in Solidity version 0.8.0. For the full list check [the release changelog](https://github.com/ethereum/solidity/releases/tag/v0.8.0).
## Silent Changes of the Semantics[](#silent-changes-of-the-semantics "Link to this heading")
This section lists changes where existing code changes its behavior without the compiler notifying you about it.
* Arithmetic operations revert on underflow and overflow. You can use `unchecked { ... }` to use the previous wrapping behavior.
 
 Checks for overflow are very common, so we made them the default to increase readability of code, even if it comes at a slight increase of gas costs.
 
* ABI coder v2 is activated by default.
 
 You can choose to use the old behavior using `pragma abicoder v1;`. The pragma `pragma experimental ABIEncoderV2;` is still valid, but it is deprecated and has no effect. If you want to be explicit, please use `pragma abicoder v2;` instead.
 
 Note that ABI coder v2 supports more types than v1 and performs more sanity checks on the inputs. ABI coder v2 makes some function calls more expensive and it can also make contract calls revert that did not revert with ABI coder v1 when they contain data that does not conform to the parameter types.
 
* Exponentiation is right associative, i.e., the expression `a**b**c` is parsed as `a**(b**c)`. Before 0.8.0, it was parsed as `(a**b)**c`.
 
 This is the common way to parse the exponentiation operator.
 
* Failing assertions and other internal checks like division by zero or arithmetic overflow do not use the invalid opcode but instead the revert opcode. More specifically, they will use error data equal to a function call to `Panic(uint256)` with an error code specific to the circumstances.
 
 This will save gas on errors while it still allows static analysis tools to distinguish these situations from a revert on invalid input, like a failing `require`.
 
* If a byte array in storage is accessed whose length is encoded incorrectly, a panic is caused. A contract cannot get into this situation unless inline assembly is used to modify the raw representation of storage byte arrays.
 
* If constants are used in array length expressions, previous versions of Solidity would use arbitrary precision in all branches of the evaluation tree. Now, if constant variables are used as intermediate expressions, their values will be properly rounded in the same way as when they are used in run-time expressions.
 
* The type `byte` has been removed. It was an alias of `bytes1`.
 
## New Restrictions[](#new-restrictions "Link to this heading")
This section lists changes that might cause existing contracts to not compile anymore.
* There are new restrictions related to explicit conversions of literals. The previous behavior in the following cases was likely ambiguous:
 
 1. Explicit conversions from negative literals and literals larger than `type(uint160).max` to `address` are disallowed.
 
 2. Explicit conversions between literals and an integer type `T` are only allowed if the literal lies between `type(T).min` and `type(T).max`. In particular, replace usages of `uint(-1)` with `type(uint).max`.
 
 3. Explicit conversions between literals and enums are only allowed if the literal can represent a value in the enum.
 
 4. Explicit conversions between literals and `address` type (e.g. `address(literal)`) have the type `address` instead of `address payable`. One can get a payable address type by using an explicit conversion, i.e., `payable(literal)`.
 
* [Address literals](https://docs.soliditylang.org/en/v0.8.30/types.html#address-literals) have the type `address` instead of `address payable`. They can be converted to `address payable` by using an explicit conversion, e.g. `payable(0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF)`.
 
* There are new restrictions on explicit type conversions. The conversion is only allowed when there is at most one change in sign, width or type-category (`int`, `address`, `bytesNN`, etc.). To perform multiple changes, use multiple conversions.
 
 Let us use the notation `T(S)` to denote the explicit conversion `T(x)`, where, `T` and `S` are types, and `x` is any arbitrary variable of type `S`. An example of such a disallowed conversion would be `uint16(int8)` since it changes both width (8 bits to 16 bits) and sign (signed integer to unsigned integer). In order to do the conversion, one has to go through an intermediate type. In the previous example, this would be `uint16(uint8(int8))` or `uint16(int16(int8))`. Note that the two ways to convert will produce different results e.g., for `-1`. The following are some examples of conversions that are disallowed by this rule.
 
 * `address(uint)` and `uint(address)`: converting both type-category and width. Replace this by `address(uint160(uint))` and `uint(uint160(address))` respectively.
 
 * `payable(uint160)`, `payable(bytes20)` and `payable(integer-literal)`: converting both type-category and state-mutability. Replace this by `payable(address(uint160))`, `payable(address(bytes20))` and `payable(address(integer-literal))` respectively. Note that `payable(0)` is valid and is an exception to the rule.
 
 * `int80(bytes10)` and `bytes10(int80)`: converting both type-category and sign. Replace this by `int80(uint80(bytes10))` and `bytes10(uint80(int80)` respectively.
 
 * `Contract(uint)`: converting both type-category and width. Replace this by `Contract(address(uint160(uint)))`.
 
 
 These conversions were disallowed to avoid ambiguity. For example, in the expression `uint16 x = uint16(int8(-1))`, the value of `x` would depend on whether the sign or the width conversion was applied first.
 
* Function call options can only be given once, i.e. `c.f{gas: 10000}{value: 1}()` is invalid and has to be changed to `c.f{gas: 10000, value: 1}()`.
 
* The global functions `log0`, `log1`, `log2`, `log3` and `log4` have been removed.
 
 These are low-level functions that were largely unused. Their behavior can be accessed from inline assembly.
 
* `enum` definitions cannot contain more than 256 members.
 
 This will make it safe to assume that the underlying type in the ABI is always `uint8`.
 
* Declarations with the name `this`, `super` and `_` are disallowed, with the exception of public functions and events. The exception is to make it possible to declare interfaces of contracts implemented in languages other than Solidity that do permit such function names.
 
* Remove support for the `\b`, `\f`, and `\v` escape sequences in code. They can still be inserted via hexadecimal escapes, e.g. `\x08`, `\x0c`, and `\x0b`, respectively.
 
* The global variables `tx.origin` and `msg.sender` have the type `address` instead of `address payable`. One can convert them into `address payable` by using an explicit conversion, i.e., `payable(tx.origin)` or `payable(msg.sender)`.
 
 This change was done since the compiler cannot determine whether or not these addresses are payable or not, so it now requires an explicit conversion to make this requirement visible.
 
* Explicit conversion into `address` type always returns a non-payable `address` type. In particular, the following explicit conversions have the type `address` instead of `address payable`:
 
 * `address(u)` where `u` is a variable of type `uint160`. One can convert `u` into the type `address payable` by using two explicit conversions, i.e., `payable(address(u))`.
 
 * `address(b)` where `b` is a variable of type `bytes20`. One can convert `b` into the type `address payable` by using two explicit conversions, i.e., `payable(address(b))`.
 
 * `address(c)` where `c` is a contract. Previously, the return type of this conversion depended on whether the contract can receive Ether (either by having a receive function or a payable fallback function). The conversion `payable(c)` has the type `address payable` and is only allowed when the contract `c` can receive Ether. In general, one can always convert `c` into the type `address payable` by using the following explicit conversion: `payable(address(c))`. Note that `address(this)` falls under the same category as `address(c)` and the same rules apply for it.
 
* The `chainid` builtin in inline assembly is now considered `view` instead of `pure`.
 
* Unary negation cannot be used on unsigned integers anymore, only on signed integers.
 
## Interface Changes[](#interface-changes "Link to this heading")
* The output of `--combined-json` has changed: JSON fields `abi`, `devdoc`, `userdoc` and `storage-layout` are sub-objects now. Before 0.8.0 they used to be serialised as strings.
 
* The “legacy AST” has been removed (`--ast-json` on the commandline interface and `legacyAST` for standard JSON). Use the “compact AST” (`--ast-compact-json` resp. `AST`) as replacement.
 
* The old error reporter (`--old-reporter`) has been removed.
 
## How to update your code[](#how-to-update-your-code "Link to this heading")
* If you rely on wrapping arithmetic, surround each operation with `unchecked { ... }`.
 
* Optional: If you use SafeMath or a similar library, change `x.add(y)` to `x + y`, `x.mul(y)` to `x * y` etc.
 
* Add `pragma abicoder v1;` if you want to stay with the old ABI coder.
 
* Optionally remove `pragma experimental ABIEncoderV2` or `pragma abicoder v2` since it is redundant.
 
* Change `byte` to `bytes1`.
 
* Add intermediate explicit type conversions if required.
 
* Combine `c.f{gas: 10000}{value: 1}()` to `c.f{gas: 10000, value: 1}()`.
 
* Change `msg.sender.transfer(x)` to `payable(msg.sender).transfer(x)` or use a stored variable of `address payable` type.
 
* Change `x**y**z` to `(x**y)**z`.
 
* Use inline assembly as a replacement for `log0`, …, `log4`.
 
* Negate unsigned integers by subtracting them from the maximum value of the type and adding 1 (e.g. `type(uint256).max - x + 1`, while ensuring that `x` is not zero)

# [Security Considerations — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/security-considerations.html) 
 _https://docs.soliditylang.org/en/v0.8.30/security-considerations.html_

While it is usually quite easy to build software that works as expected, it is much harder to check that nobody can use it in a way that was **not** anticipated.
In Solidity, this is even more important because you can use smart contracts to handle tokens or, possibly, even more valuable things. Furthermore, every execution of a smart contract happens in public and, in addition to that, the source code is often available.
Of course, you always have to consider how much is at stake: You can compare a smart contract with a web service that is open to the public (and thus, also to malicious actors) and perhaps even open-source. If you only store your grocery list on that web service, you might not have to take too much care, but if you manage your bank account using that web service, you should be more careful.
This section will list some pitfalls and general security recommendations but can, of course, never be complete. Also, keep in mind that even if your smart contract code is bug-free, the compiler or the platform itself might have a bug. A list of some publicly known security-relevant bugs of the compiler can be found in the [list of known bugs](https://docs.soliditylang.org/en/v0.8.30/bugs.html#known-bugs), which is also machine-readable. Note that there is a [Bug Bounty Program](https://ethereum.org/en/bug-bounty/) that covers the code generator of the Solidity compiler.
As always, with open-source documentation, please help us extend this section (especially, some examples would not hurt)!
NOTE: In addition to the list below, you can find more security recommendations and best practices [in Guy Lando’s knowledge list](https://github.com/guylando/KnowledgeLists/blob/master/EthereumSmartContracts.md) and [the Consensys GitHub repo](https://consensys.github.io/smart-contract-best-practices/).
## Pitfalls[](#pitfalls "Link to this heading")
### Private Information and Randomness[](#private-information-and-randomness "Link to this heading")
Everything you use in a smart contract is publicly visible, even local variables and state variables marked `private`.
Using random numbers in smart contracts is quite tricky if you do not want block builders to be able to cheat.
### Reentrancy[](#reentrancy "Link to this heading")
Any interaction from a contract (A) with another contract (B) and any transfer of Ether hands over control to that contract (B). This makes it possible for B to call back into A before this interaction is completed. To give an example, the following code contains a bug (it is just a snippet and not a complete contract):
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKLy8gVEhJUyBDT05UUkFDVCBDT05UQUlOUyBBIEJVRyAtIERPIE5PVCBVU0UKY29udHJhY3QgRnVuZCB7CiAgICAvLy8gQGRldiBNYXBwaW5nIG9mIGV0aGVyIHNoYXJlcyBvZiB0aGUgY29udHJhY3QuCiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gdWludCkgc2hhcmVzOwogICAgLy8vIFdpdGhkcmF3IHlvdXIgc2hhcmUuCiAgICBmdW5jdGlvbiB3aXRoZHJhdygpIHB1YmxpYyB7CiAgICAgICAgaWYgKHBheWFibGUobXNnLnNlbmRlcikuc2VuZChzaGFyZXNbbXNnLnNlbmRlcl0pKQogICAgICAgICAgICBzaGFyZXNbbXNnLnNlbmRlcl0gPSAwOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
// THIS CONTRACT CONTAINS A BUG - DO NOT USE
contract Fund {
 /// @dev Mapping of ether shares of the contract.
 mapping(address \=> uint) shares;
 /// Withdraw your share.
 function withdraw() public {
 if (payable(msg.sender).send(shares\[msg.sender\]))
 shares\[msg.sender\] \= 0;
 }
}
The problem is not too serious here because of the limited gas as part of `send`, but it still exposes a weakness: Ether transfer can always include code execution, so the recipient could be a contract that calls back into `withdraw`. This would let it get multiple refunds and, basically, retrieve all the Ether in the contract. In particular, the following contract will allow an attacker to refund multiple times as it uses `call` which forwards all remaining gas by default:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKLy8gVEhJUyBDT05UUkFDVCBDT05UQUlOUyBBIEJVRyAtIERPIE5PVCBVU0UKY29udHJhY3QgRnVuZCB7CiAgICAvLy8gQGRldiBNYXBwaW5nIG9mIGV0aGVyIHNoYXJlcyBvZiB0aGUgY29udHJhY3QuCiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gdWludCkgc2hhcmVzOwogICAgLy8vIFdpdGhkcmF3IHlvdXIgc2hhcmUuCiAgICBmdW5jdGlvbiB3aXRoZHJhdygpIHB1YmxpYyB7CiAgICAgICAgKGJvb2wgc3VjY2VzcywpID0gbXNnLnNlbmRlci5jYWxse3ZhbHVlOiBzaGFyZXNbbXNnLnNlbmRlcl19KCIiKTsKICAgICAgICBpZiAoc3VjY2VzcykKICAgICAgICAgICAgc2hhcmVzW21zZy5zZW5kZXJdID0gMDsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.2 <0.9.0;
// THIS CONTRACT CONTAINS A BUG - DO NOT USE
contract Fund {
 /// @dev Mapping of ether shares of the contract.
 mapping(address \=> uint) shares;
 /// Withdraw your share.
 function withdraw() public {
 (bool success,) \= msg.sender.call{value: shares\[msg.sender\]}("");
 if (success)
 shares\[msg.sender\] \= 0;
 }
}
To avoid reentrancy, you can use the Checks-Effects-Interactions pattern as demonstrated below:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgRnVuZCB7CiAgICAvLy8gQGRldiBNYXBwaW5nIG9mIGV0aGVyIHNoYXJlcyBvZiB0aGUgY29udHJhY3QuCiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gdWludCkgc2hhcmVzOwogICAgLy8vIFdpdGhkcmF3IHlvdXIgc2hhcmUuCiAgICBmdW5jdGlvbiB3aXRoZHJhdygpIHB1YmxpYyB7CiAgICAgICAgdWludCBzaGFyZSA9IHNoYXJlc1ttc2cuc2VuZGVyXTsKICAgICAgICBzaGFyZXNbbXNnLnNlbmRlcl0gPSAwOwogICAgICAgIHBheWFibGUobXNnLnNlbmRlcikudHJhbnNmZXIoc2hhcmUpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract Fund {
 /// @dev Mapping of ether shares of the contract.
 mapping(address \=> uint) shares;
 /// Withdraw your share.
 function withdraw() public {
 uint share \= shares\[msg.sender\];
 shares\[msg.sender\] \= 0;
 payable(msg.sender).transfer(share);
 }
}
The Checks-Effects-Interactions pattern ensures that all code paths through a contract complete all required checks of the supplied parameters before modifying the contract’s state (Checks); only then it makes any changes to the state (Effects); it may make calls to functions in other contracts _after_ all planned state changes have been written to storage (Interactions). This is a common foolproof way to prevent _reentrancy attacks_, where an externally called malicious contract can double-spend an allowance, double-withdraw a balance, among other things, by using logic that calls back into the original contract before it has finalized its transaction.
Note that reentrancy is not only an effect of Ether transfer but of any function call on another contract. Furthermore, you also have to take multi-contract situations into account. A called contract could modify the state of another contract you depend on.
### Gas Limit and Loops[](#gas-limit-and-loops "Link to this heading")
Loops that do not have a fixed number of iterations, for example, loops that depend on storage values, have to be used carefully: Due to the block gas limit, transactions can only consume a certain amount of gas. Either explicitly or just due to normal operation, the number of iterations in a loop can grow beyond the block gas limit which can cause the complete contract to be stalled at a certain point. This may not apply to `view` functions that are only executed to read data from the blockchain. Still, such functions may be called by other contracts as part of on-chain operations and stall those. Please be explicit about such cases in the documentation of your contracts.
### Sending and Receiving Ether[](#sending-and-receiving-ether "Link to this heading")
* Neither contracts nor “external accounts” are currently able to prevent someone from sending them Ether. Contracts can react on and reject a regular transfer, but there are ways to move Ether without creating a message call. One way is to simply “mine to” the contract address and the second way is using `selfdestruct(x)`.
 
* If a contract receives Ether (without a function being called), either the [receive Ether](https://docs.soliditylang.org/en/v0.8.30/contracts.html#receive-ether-function) or the [fallback](https://docs.soliditylang.org/en/v0.8.30/contracts.html#fallback-function) function is executed. If it does not have a `receive` nor a `fallback` function, the Ether will be rejected (by throwing an exception). During the execution of one of these functions, the contract can only rely on the “gas stipend” it is passed (2300 gas) being available to it at that time. This stipend is not enough to modify storage (do not take this for granted though, the stipend might change with future hard forks). To be sure that your contract can receive Ether in that way, check the gas requirements of the receive and fallback functions (for example in the “details” section in Remix).
 
* There is a way to forward more gas to the receiving contract using `addr.call{value: x}("")`. This is essentially the same as `addr.transfer(x)`, only that it forwards all remaining gas and opens up the ability for the recipient to perform more expensive actions (and it returns a failure code instead of automatically propagating the error). This might include calling back into the sending contract or other state changes you might not have thought of. So it allows for great flexibility for honest users but also for malicious actors.
 
* Use the most precise units to represent the Wei amount as possible, as you lose any that is rounded due to a lack of precision.
 
* If you want to send Ether using `address.transfer`, there are certain details to be aware of:
 
 1. If the recipient is a contract, it causes its receive or fallback function to be executed which can, in turn, call back the sending contract.
 
 2. Sending Ether can fail due to the call depth going above 1024. Since the caller is in total control of the call depth, they can force the transfer to fail; take this possibility into account or use `send` and make sure to always check its return value. Better yet, write your contract using a pattern where the recipient can withdraw Ether instead.
 
 3. Sending Ether can also fail because the execution of the recipient contract requires more than the allotted amount of gas (explicitly by using [require](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#assert-and-require), [assert](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#assert-and-require), [revert](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#assert-and-require) or because the operation is too expensive) - it “runs out of gas” (OOG). If you use `transfer` or `send` with a return value check, this might provide a means for the recipient to block progress in the sending contract. Again, the best practice here is to use a [“withdraw” pattern instead of a “send” pattern](https://docs.soliditylang.org/en/v0.8.30/common-patterns.html#withdrawal-pattern).
 
### Call Stack Depth[](#call-stack-depth "Link to this heading")
External function calls can fail at any time because they exceed the maximum call stack size limit of 1024. In such situations, Solidity throws an exception. Malicious actors might be able to force the call stack to a high value before they interact with your contract. Note that, since [Tangerine Whistle](https://eips.ethereum.org/EIPS/eip-608) hardfork, the [63/64 rule](https://eips.ethereum.org/EIPS/eip-150) makes call stack depth attack impractical. Also note that the call stack and the expression stack are unrelated, even though both have a size limit of 1024 stack slots.
Note that `.send()` does **not** throw an exception if the call stack is depleted but rather returns `false` in that case. The low-level functions `.call()`, `.delegatecall()` and `.staticcall()` behave in the same way.
### Authorized Proxies[](#authorized-proxies "Link to this heading")
If your contract can act as a proxy, i.e. if it can call arbitrary contracts with user-supplied data, then the user can essentially assume the identity of the proxy contract. Even if you have other protective measures in place, it is best to build your contract system such that the proxy does not have any permissions (not even for itself). If needed, you can accomplish that using a second proxy:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMDsKY29udHJhY3QgUHJveHlXaXRoTW9yZUZ1bmN0aW9uYWxpdHkgewogICAgUGVybWlzc2lvbmxlc3NQcm94eSBwcm94eTsKCiAgICBmdW5jdGlvbiBjYWxsT3RoZXIoYWRkcmVzcyBhZGRyLCBieXRlcyBtZW1vcnkgcGF5bG9hZCkgcHVibGljCiAgICAgICAgICAgIHJldHVybnMgKGJvb2wsIGJ5dGVzIG1lbW9yeSkgewogICAgICAgIHJldHVybiBwcm94eS5jYWxsT3RoZXIoYWRkciwgcGF5bG9hZCk7CiAgICB9CiAgICAvLyBPdGhlciBmdW5jdGlvbnMgYW5kIG90aGVyIGZ1bmN0aW9uYWxpdHkKfQoKLy8gVGhpcyBpcyB0aGUgZnVsbCBjb250cmFjdCwgaXQgaGFzIG5vIG90aGVyIGZ1bmN0aW9uYWxpdHkgYW5kCi8vIHJlcXVpcmVzIG5vIHByaXZpbGVnZXMgdG8gd29yay4KY29udHJhY3QgUGVybWlzc2lvbmxlc3NQcm94eSB7CiAgICBmdW5jdGlvbiBjYWxsT3RoZXIoYWRkcmVzcyBhZGRyLCBieXRlcyBtZW1vcnkgcGF5bG9hZCkgcHVibGljCiAgICAgICAgICAgIHJldHVybnMgKGJvb2wsIGJ5dGVzIG1lbW9yeSkgewogICAgICAgIHJldHVybiBhZGRyLmNhbGwocGF5bG9hZCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;
contract ProxyWithMoreFunctionality {
 PermissionlessProxy proxy;
 function callOther(address addr, bytes memory payload) public
 returns (bool, bytes memory) {
 return proxy.callOther(addr, payload);
 }
 // Other functions and other functionality
}
// This is the full contract, it has no other functionality and
// requires no privileges to work.
contract PermissionlessProxy {
 function callOther(address addr, bytes memory payload) public
 returns (bool, bytes memory) {
 return addr.call(payload);
 }
}
### tx.origin[](#tx-origin "Link to this heading")
Never use `tx.origin` for authorization. Let’s say you have a wallet contract like this:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwovLyBUSElTIENPTlRSQUNUIENPTlRBSU5TIEEgQlVHIC0gRE8gTk9UIFVTRQpjb250cmFjdCBUeFVzZXJXYWxsZXQgewogICAgYWRkcmVzcyBvd25lcjsKCiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgICBvd25lciA9IG1zZy5zZW5kZXI7CiAgICB9CgogICAgZnVuY3Rpb24gdHJhbnNmZXJUbyhhZGRyZXNzIHBheWFibGUgZGVzdCwgdWludCBhbW91bnQpIHB1YmxpYyB7CiAgICAgICAgLy8gVEhFIEJVRyBJUyBSSUdIVCBIRVJFLCB5b3UgbXVzdCB1c2UgbXNnLnNlbmRlciBpbnN0ZWFkIG9mIHR4Lm9yaWdpbgogICAgICAgIHJlcXVpcmUodHgub3JpZ2luID09IG93bmVyKTsKICAgICAgICBkZXN0LnRyYW5zZmVyKGFtb3VudCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
// THIS CONTRACT CONTAINS A BUG - DO NOT USE
contract TxUserWallet {
 address owner;
 constructor() {
 owner \= msg.sender;
 }
 function transferTo(address payable dest, uint amount) public {
 // THE BUG IS RIGHT HERE, you must use msg.sender instead of tx.origin
 require(tx.origin \== owner);
 dest.transfer(amount);
 }
}
Now someone tricks you into sending Ether to the address of this attack wallet:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwppbnRlcmZhY2UgVHhVc2VyV2FsbGV0IHsKICAgIGZ1bmN0aW9uIHRyYW5zZmVyVG8oYWRkcmVzcyBwYXlhYmxlIGRlc3QsIHVpbnQgYW1vdW50KSBleHRlcm5hbDsKfQoKY29udHJhY3QgVHhBdHRhY2tXYWxsZXQgewogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwoKICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgIG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsKICAgIH0KCiAgICByZWNlaXZlKCkgZXh0ZXJuYWwgcGF5YWJsZSB7CiAgICAgICAgVHhVc2VyV2FsbGV0KG1zZy5zZW5kZXIpLnRyYW5zZmVyVG8ob3duZXIsIG1zZy5zZW5kZXIuYmFsYW5jZSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
interface TxUserWallet {
 function transferTo(address payable dest, uint amount) external;
}
contract TxAttackWallet {
 address payable owner;
 constructor() {
 owner \= payable(msg.sender);
 }
 receive() external payable {
 TxUserWallet(msg.sender).transferTo(owner, msg.sender.balance);
 }
}
If your wallet had checked `msg.sender` for authorization, it would get the address of the attack wallet, instead of the owner’s address. But by checking `tx.origin`, it gets the original address that kicked off the transaction, which is still the owner’s address. The attack wallet instantly drains all your funds.
### Two’s Complement / Underflows / Overflows[](#two-s-complement-underflows-overflows "Link to this heading")
As in many programming languages, Solidity’s integer types are not actually integers. They resemble integers when the values are small, but cannot represent arbitrarily large numbers.
The following code causes an overflow because the result of the addition is too large to be stored in the type `uint8`:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=dWludDggeCA9IDI1NTsKdWludDggeSA9IDE7CnJldHVybiB4ICsgeTs=)
uint8 x \= 255;
uint8 y \= 1;
return x + y;
Solidity has two modes in which it deals with these overflows: Checked and Unchecked or “wrapping” mode.
The default checked mode will detect overflows and cause a failing assertion. You can disable this check using `unchecked { ... }`, causing the overflow to be silently ignored. The above code would return `0` if wrapped in `unchecked { ... }`.
Even in checked mode, do not assume you are protected from overflow bugs. In this mode, overflows will always revert. If it is not possible to avoid the overflow, this can lead to a smart contract being stuck in a certain state.
In general, read about the limits of two’s complement representation, which even has some more special edge cases for signed numbers.
Try to use `require` to limit the size of inputs to a reasonable range and use the [SMT checker](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#smt-checker) to find potential overflows.
### Clearing Mappings[](#clearing-mappings "Link to this heading")
The Solidity type `mapping` (see [Mapping Types](https://docs.soliditylang.org/en/v0.8.30/types.html#mapping-types)) is a storage-only key-value data structure that does not keep track of the keys that were assigned a non-zero value. Because of that, cleaning a mapping without extra information about the written keys is not possible. If a `mapping` is used as the base type of a dynamic storage array, deleting or popping the array will have no effect over the `mapping` elements. The same happens, for example, if a `mapping` is used as the type of a member field of a `struct` that is the base type of a dynamic storage array. The `mapping` is also ignored in assignments of structs or arrays containing a `mapping`.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgTWFwIHsKICAgIG1hcHBpbmcodWludCA9PiB1aW50KVtdIGFycmF5OwoKICAgIGZ1bmN0aW9uIGFsbG9jYXRlKHVpbnQgbmV3TWFwcykgcHVibGljIHsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCBuZXdNYXBzOyBpKyspCiAgICAgICAgICAgIGFycmF5LnB1c2goKTsKICAgIH0KCiAgICBmdW5jdGlvbiB3cml0ZU1hcCh1aW50IG1hcCwgdWludCBrZXksIHVpbnQgdmFsdWUpIHB1YmxpYyB7CiAgICAgICAgYXJyYXlbbWFwXVtrZXldID0gdmFsdWU7CiAgICB9CgogICAgZnVuY3Rpb24gcmVhZE1hcCh1aW50IG1hcCwgdWludCBrZXkpIHB1YmxpYyB2aWV3IHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4gYXJyYXlbbWFwXVtrZXldOwogICAgfQoKICAgIGZ1bmN0aW9uIGVyYXNlTWFwcygpIHB1YmxpYyB7CiAgICAgICAgZGVsZXRlIGFycmF5OwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract Map {
 mapping(uint \=> uint)\[\] array;
 function allocate(uint newMaps) public {
 for (uint i \= 0; i < newMaps; i++)
 array.push();
 }
 function writeMap(uint map, uint key, uint value) public {
 array\[map\]\[key\] \= value;
 }
 function readMap(uint map, uint key) public view returns (uint) {
 return array\[map\]\[key\];
 }
 function eraseMaps() public {
 delete array;
 }
}
Consider the example above and the following sequence of calls: `allocate(10)`, `writeMap(4, 128, 256)`. At this point, calling `readMap(4, 128)` returns 256. If we call `eraseMaps`, the length of the state variable `array` is zeroed, but since its `mapping` elements cannot be zeroed, their information stays alive in the contract’s storage. After deleting `array`, calling `allocate(5)` allows us to access `array[4]` again, and calling `readMap(4, 128)` returns 256 even without another call to `writeMap`.
If your `mapping` information must be deleted, consider using a library similar to [iterable mapping](https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol), allowing you to traverse the keys and delete their values in the appropriate `mapping`.
### Internal Function Pointers in Upgradeable Contracts[](#internal-function-pointers-in-upgradeable-contracts "Link to this heading")
Updating the code of your contract may [invalidate the values of variables of internal function types](https://docs.soliditylang.org/en/v0.8.30/types.html#function-type-value-stability-across-contract-updates). Consider such values ephemeral and avoid storing them in state variables. If you do, you must ensure that they never persist across code updates and are never used by other contracts having access to the same storage space as a result of a delegatecall or account abstraction.
### Minor Details[](#minor-details "Link to this heading")
* Types that do not occupy the full 32 bytes might contain “dirty higher order bits”. This is especially important if you access `msg.data` - it poses a malleability risk: You can craft transactions that call a function `f(uint8 x)` with a raw byte argument of `0xff000001` and with `0x00000001`. Both are fed to the contract and both will look like the number `1` as far as `x` is concerned, but `msg.data` will be different, so if you use `keccak256(msg.data)` for anything, you will get different results.
 
## Recommendations[](#recommendations "Link to this heading")
### Take Warnings Seriously[](#take-warnings-seriously "Link to this heading")
If the compiler warns you about something, you should change it. Even if you do not think that this particular warning has security implications, there might be another issue buried beneath it. Any compiler warning we issue can be silenced by slight changes to the code.
Always use the latest version of the compiler to be notified about all recently introduced warnings.
Messages of type `info`, issued by the compiler, are not dangerous and simply represent extra suggestions and optional information that the compiler thinks might be useful to the user.
### Restrict the Amount of Ether[](#restrict-the-amount-of-ether "Link to this heading")
Restrict the amount of Ether (or other tokens) that can be stored in a smart contract. If your source code, the compiler or the platform has a bug, these funds may be lost. If you want to limit your loss, limit the amount of Ether.
### Keep it Small and Modular[](#keep-it-small-and-modular "Link to this heading")
Keep your contracts small and easily understandable. Single out unrelated functionality in other contracts or into libraries. General recommendations about the source code quality of course apply: Limit the amount of local variables, the length of functions and so on. Document your functions so that others can see what your intention was and whether it is different than what the code does.
### Use the Checks-Effects-Interactions Pattern[](#use-the-checks-effects-interactions-pattern "Link to this heading")
Most functions will first perform some checks and they should be done first (who called the function, are the arguments in range, did they send enough Ether, does the person have tokens, etc.).
As the second step, if all checks passed, effects to the state variables of the current contract should be made. Interaction with other contracts should be the very last step in any function.
Early contracts delayed some effects and waited for external function calls to return in a non-error state. This is often a serious mistake because of the reentrancy problem explained above.
Note that, also, calls to known contracts might in turn cause calls to unknown contracts, so it is probably better to just always apply this pattern.
### Include a Fail-Safe Mode[](#include-a-fail-safe-mode "Link to this heading")
While making your system fully decentralized will remove any intermediary, it might be a good idea, especially for new code, to include some kind of fail-safe mechanism:
You can add a function in your smart contract that performs some self-checks like “Has any Ether leaked?”, “Is the sum of the tokens equal to the balance of the contract?” or similar things. Keep in mind that you cannot use too much gas for that, so help through off-chain computations might be needed there.
If the self-check fails, the contract automatically switches into some kind of “failsafe” mode, which, for example, disables most of the features, hands over control to a fixed and trusted third party or just converts the contract into a simple “give me back my Ether” contract.
### Ask for Peer Review[](#ask-for-peer-review "Link to this heading")
The more people examine a piece of code, the more issues are found. Asking people to review your code also helps as a cross-check to find out whether your code is easy to understand - a very important criterion for good smart contracts.

# [Solidity v0.5.0 Breaking Changes — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/050-breaking-changes.html) 
 _https://docs.soliditylang.org/en/latest/050-breaking-changes.html_

This section highlights the main breaking changes introduced in Solidity version 0.5.0, along with the reasoning behind the changes and how to update affected code. For the full list check [the release changelog](https://github.com/ethereum/solidity/releases/tag/v0.5.0).
Note
Contracts compiled with Solidity v0.5.0 can still interface with contracts and even libraries compiled with older versions without recompiling or redeploying them. Changing the interfaces to include data locations and visibility and mutability specifiers suffices. See the [Interoperability With Older Contracts](#interoperability) section below.
## Semantic Only Changes[](#semantic-only-changes "Link to this heading")
This section lists the changes that are semantic-only, thus potentially hiding new and different behavior in existing code.
* Signed right shift now uses proper arithmetic shift, i.e. rounding towards negative infinity, instead of rounding towards zero. Signed and unsigned shift will have dedicated opcodes in Constantinople, and are emulated by Solidity for the moment.
 
* The `continue` statement in a `do...while` loop now jumps to the condition, which is the common behavior in such cases. It used to jump to the loop body. Thus, if the condition is false, the loop terminates.
 
* The functions `.call()`, `.delegatecall()` and `.staticcall()` do not pad anymore when given a single `bytes` parameter.
 
* Pure and view functions are now called using the opcode `STATICCALL` instead of `CALL` if the EVM version is Byzantium or later. This disallows state changes on the EVM level.
 
* The ABI encoder now properly pads byte arrays and strings from calldata (`msg.data` and external function parameters) when used in external function calls and in `abi.encode`. For unpadded encoding, use `abi.encodePacked`.
 
* The ABI decoder reverts in the beginning of functions and in `abi.decode()` if passed calldata is too short or points out of bounds. Note that dirty higher order bits are still simply ignored.
 
* Forward all available gas with external function calls starting from Tangerine Whistle.
 
## Semantic and Syntactic Changes[](#semantic-and-syntactic-changes "Link to this heading")
This section highlights changes that affect syntax and semantics.
* The functions `.call()`, `.delegatecall()`, `staticcall()`, `keccak256()`, `sha256()` and `ripemd160()` now accept only a single `bytes` argument. Moreover, the argument is not padded. This was changed to make more explicit and clear how the arguments are concatenated. Change every `.call()` (and family) to a `.call("")` and every `.call(signature, a, b, c)` to use `.call(abi.encodeWithSignature(signature, a, b, c))` (the last one only works for value types). Change every `keccak256(a, b, c)` to `keccak256(abi.encodePacked(a, b, c))`. Even though it is not a breaking change, it is suggested that developers change `x.call(bytes4(keccak256("f(uint256)")), a, b)` to `x.call(abi.encodeWithSignature("f(uint256)", a, b))`.
 
* Functions `.call()`, `.delegatecall()` and `.staticcall()` now return `(bool, bytes memory)` to provide access to the return data. Change `bool success = otherContract.call("f")` to `(bool success, bytes memory data) = otherContract.call("f")`.
 
* Solidity now implements C99-style scoping rules for function local variables, that is, variables can only be used after they have been declared and only in the same or nested scopes. Variables declared in the initialization block of a `for` loop are valid at any point inside the loop.
 
## Explicitness Requirements[](#explicitness-requirements "Link to this heading")
This section lists changes where the code now needs to be more explicit. For most of the topics the compiler will provide suggestions.
* Explicit function visibility is now mandatory. Add `public` to every function and constructor, and `external` to every fallback or interface function that does not specify its visibility already.
 
* Explicit data location for all variables of struct, array or mapping types is now mandatory. This is also applied to function parameters and return variables. For example, change `uint[] x = z` to `uint[] storage x = z`, and `function f(uint[][] x)` to `function f(uint[][] memory x)` where `memory` is the data location and might be replaced by `storage` or `calldata` accordingly. Note that `external` functions require parameters with a data location of `calldata`.
 
* Contract types do not include `address` members anymore in order to separate the namespaces. Therefore, it is now necessary to explicitly convert values of contract type to addresses before using an `address` member. Example: if `c` is a contract, change `c.transfer(...)` to `address(c).transfer(...)`, and `c.balance` to `address(c).balance`.
 
* Explicit conversions between unrelated contract types are now disallowed. You can only convert from a contract type to one of its base or ancestor types. If you are sure that a contract is compatible with the contract type you want to convert to, although it does not inherit from it, you can work around this by converting to `address` first. Example: if `A` and `B` are contract types, `B` does not inherit from `A` and `b` is a contract of type `B`, you can still convert `b` to type `A` using `A(address(b))`. Note that you still need to watch out for matching payable fallback functions, as explained below.
 
* The `address` type was split into `address` and `address payable`, where only `address payable` provides the `transfer` function. An `address payable` can be directly converted to an `address`, but the other way around is not allowed. Converting `address` to `address payable` is possible via conversion through `uint160`. If `c` is a contract, `address(c)` results in `address payable` only if `c` has a payable fallback function. If you use the [withdraw pattern](https://docs.soliditylang.org/en/latest/common-patterns.html#withdrawal-pattern), you most likely do not have to change your code because `transfer` is only used on `msg.sender` instead of stored addresses and `msg.sender` is an `address payable`.
 
* Conversions between `bytesX` and `uintY` of different size are now disallowed due to `bytesX` padding on the right and `uintY` padding on the left which may cause unexpected conversion results. The size must now be adjusted within the type before the conversion. For example, you can convert a `bytes4` (4 bytes) to a `uint64` (8 bytes) by first converting the `bytes4` variable to `bytes8` and then to `uint64`. You get the opposite padding when converting through `uint32`. Before v0.5.0 any conversion between `bytesX` and `uintY` would go through `uint8X`. For example `uint8(bytes3(0x291807))` would be converted to `uint8(uint24(bytes3(0x291807)))` (the result is `0x07`).
 
* Using `msg.value` in non-payable functions (or introducing it via a modifier) is disallowed as a security feature. Turn the function into `payable` or create a new internal function for the program logic that uses `msg.value`.
 
* For clarity reasons, the command-line interface now requires `-` if the standard input is used as source.
 
## Deprecated Elements[](#deprecated-elements "Link to this heading")
This section lists changes that deprecate prior features or syntax. Note that many of these changes were already enabled in the experimental mode `v0.5.0`.
### Command-line and JSON Interfaces[](#command-line-and-json-interfaces "Link to this heading")
* The command-line option `--formal` (used to generate Why3 output for further formal verification) was deprecated and is now removed. A new formal verification module, the SMTChecker, is enabled via `pragma experimental SMTChecker;`.
 
* The command-line option `--julia` was renamed to `--yul` due to the renaming of the intermediate language `Julia` to `Yul`.
 
* The `--clone-bin` and `--combined-json clone-bin` command-line options were removed.
 
* Remappings with empty prefix are disallowed.
 
* The JSON AST fields `constant` and `payable` were removed. The information is now present in the `stateMutability` field.
 
* The JSON AST field `isConstructor` of the `FunctionDefinition` node was replaced by a field called `kind` which can have the value `"constructor"`, `"fallback"` or `"function"`.
 
* In unlinked binary hex files, library address placeholders are now the first 36 hex characters of the keccak256 hash of the fully qualified library name, surrounded by `$...$`. Previously, just the fully qualified library name was used. This reduces the chances of collisions, especially when long paths are used. Binary files now also contain a list of mappings from these placeholders to the fully qualified names.
 
### Constructors[](#constructors "Link to this heading")
* Constructors must now be defined using the `constructor` keyword.
 
* Calling base constructors without parentheses is now disallowed.
 
* Specifying base constructor arguments multiple times in the same inheritance hierarchy is now disallowed.
 
* Calling a constructor with arguments but with wrong argument count is now disallowed. If you only want to specify an inheritance relation without giving arguments, do not provide parentheses at all.
 
### Functions[](#functions "Link to this heading")
* Function `callcode` is now disallowed (in favor of `delegatecall`). It is still possible to use it via inline assembly.
 
* `suicide` is now disallowed (in favor of `selfdestruct`).
 
* `sha3` is now disallowed (in favor of `keccak256`).
 
* `throw` is now disallowed (in favor of `revert`, `require` and `assert`).
 
### Conversions[](#conversions "Link to this heading")
* Explicit and implicit conversions from decimal literals to `bytesXX` types is now disallowed.
 
* Explicit and implicit conversions from hex literals to `bytesXX` types of different size is now disallowed.
 
### Literals and Suffixes[](#literals-and-suffixes "Link to this heading")
* The unit denomination `years` is now disallowed due to complications and confusions about leap years.
 
* Trailing dots that are not followed by a number are now disallowed.
 
* Combining hex numbers with unit denominations (e.g. `0x1e wei`) is now disallowed.
 
* The prefix `0X` for hex numbers is disallowed, only `0x` is possible.
 
### Variables[](#variables "Link to this heading")
* Declaring empty structs is now disallowed for clarity.
 
* The `var` keyword is now disallowed to favor explicitness.
 
* Assignments between tuples with different number of components is now disallowed.
 
* Values for constants that are not compile-time constants are disallowed.
 
* Multi-variable declarations with mismatching number of values are now disallowed.
 
* Uninitialized storage variables are now disallowed.
 
* Empty tuple components are now disallowed.
 
* Detecting cyclic dependencies in variables and structs is limited in recursion to 256.
 
* Fixed-size arrays with a length of zero are now disallowed.
 
### Syntax[](#syntax "Link to this heading")
* Using `constant` as function state mutability modifier is now disallowed.
 
* Boolean expressions cannot use arithmetic operations.
 
* The unary `+` operator is now disallowed.
 
* Literals cannot anymore be used with `abi.encodePacked` without prior conversion to an explicit type.
 
* Empty return statements for functions with one or more return values are now disallowed.
 
* The “loose assembly” syntax is now disallowed entirely, that is, jump labels, jumps and non-functional instructions cannot be used anymore. Use the new `while`, `switch` and `if` constructs instead.
 
* Functions without implementation cannot use modifiers anymore.
 
* Function types with named return values are now disallowed.
 
* Single statement variable declarations inside if/while/for bodies that are not blocks are now disallowed.
 
* New keywords: `calldata` and `constructor`.
 
* New reserved keywords: `alias`, `apply`, `auto`, `copyof`, `define`, `immutable`, `implements`, `macro`, `mutable`, `override`, `partial`, `promise`, `reference`, `sealed`, `sizeof`, `supports`, `typedef` and `unchecked`.
 
## Interoperability With Older Contracts[](#interoperability-with-older-contracts "Link to this heading")
It is still possible to interface with contracts written for Solidity versions prior to v0.5.0 (or the other way around) by defining interfaces for them. Consider you have the following pre-0.5.0 contract already deployed:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjQuMjU7Ci8vIFRoaXMgd2lsbCByZXBvcnQgYSB3YXJuaW5nIHVudGlsIHZlcnNpb24gMC40LjI1IG9mIHRoZSBjb21waWxlcgovLyBUaGlzIHdpbGwgbm90IGNvbXBpbGUgYWZ0ZXIgMC41LjAKY29udHJhY3QgT2xkQ29udHJhY3QgewogICAgZnVuY3Rpb24gc29tZU9sZEZ1bmN0aW9uKHVpbnQ4IGEpIHsKICAgICAgICAvLy4uLgogICAgfQogICAgZnVuY3Rpb24gYW5vdGhlck9sZEZ1bmN0aW9uKCkgY29uc3RhbnQgcmV0dXJucyAoYm9vbCkgewogICAgICAgIC8vLi4uCiAgICB9CiAgICAvLyAuLi4KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.4.25;
// This will report a warning until version 0.4.25 of the compiler
// This will not compile after 0.5.0
contract OldContract {
 function someOldFunction(uint8 a) {
 //...
 }
 function anotherOldFunction() constant returns (bool) {
 //...
 }
 // ...
}
This will no longer compile with Solidity v0.5.0. However, you can define a compatible interface for it:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwppbnRlcmZhY2UgT2xkQ29udHJhY3QgewogICAgZnVuY3Rpb24gc29tZU9sZEZ1bmN0aW9uKHVpbnQ4IGEpIGV4dGVybmFsOwogICAgZnVuY3Rpb24gYW5vdGhlck9sZEZ1bmN0aW9uKCkgZXh0ZXJuYWwgcmV0dXJucyAoYm9vbCk7Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
interface OldContract {
 function someOldFunction(uint8 a) external;
 function anotherOldFunction() external returns (bool);
}
Note that we did not declare `anotherOldFunction` to be `view`, despite it being declared `constant` in the original contract. This is due to the fact that starting with Solidity v0.5.0 `staticcall` is used to call `view` functions. Prior to v0.5.0 the `constant` keyword was not enforced, so calling a function declared `constant` with `staticcall` may still revert, since the `constant` function may still attempt to modify storage. Consequently, when defining an interface for older contracts, you should only use `view` in place of `constant` in case you are absolutely sure that the function will work with `staticcall`.
Given the interface defined above, you can now easily use the already deployed pre-0.5.0 contract:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKaW50ZXJmYWNlIE9sZENvbnRyYWN0IHsKICAgIGZ1bmN0aW9uIHNvbWVPbGRGdW5jdGlvbih1aW50OCBhKSBleHRlcm5hbDsKICAgIGZ1bmN0aW9uIGFub3RoZXJPbGRGdW5jdGlvbigpIGV4dGVybmFsIHJldHVybnMgKGJvb2wpOwp9Cgpjb250cmFjdCBOZXdDb250cmFjdCB7CiAgICBmdW5jdGlvbiBkb1NvbWV0aGluZyhPbGRDb250cmFjdCBhKSBwdWJsaWMgcmV0dXJucyAoYm9vbCkgewogICAgICAgIGEuc29tZU9sZEZ1bmN0aW9uKDB4NDIpOwogICAgICAgIHJldHVybiBhLmFub3RoZXJPbGRGdW5jdGlvbigpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
interface OldContract {
 function someOldFunction(uint8 a) external;
 function anotherOldFunction() external returns (bool);
}
contract NewContract {
 function doSomething(OldContract a) public returns (bool) {
 a.someOldFunction(0x42);
 return a.anotherOldFunction();
 }
}
Similarly, pre-0.5.0 libraries can be used by defining the functions of the library without implementation and supplying the address of the pre-0.5.0 library during linking (see [Using the Commandline Compiler](https://docs.soliditylang.org/en/latest/using-the-compiler.html#commandline-compiler) for how to use the commandline compiler for linking):
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gVGhpcyB3aWxsIG5vdCBjb21waWxlIGFmdGVyIDAuNi4wCi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBHUEwtMy4wCnByYWdtYSBzb2xpZGl0eSBeMC41LjA7CgpsaWJyYXJ5IE9sZExpYnJhcnkgewogICAgZnVuY3Rpb24gc29tZUZ1bmN0aW9uKHVpbnQ4IGEpIHB1YmxpYyByZXR1cm5zKGJvb2wpOwp9Cgpjb250cmFjdCBOZXdDb250cmFjdCB7CiAgICBmdW5jdGlvbiBmKHVpbnQ4IGEpIHB1YmxpYyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmV0dXJuIE9sZExpYnJhcnkuc29tZUZ1bmN0aW9uKGEpOwogICAgfQp9)
// This will not compile after 0.6.0
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.5.0;
library OldLibrary {
 function someFunction(uint8 a) public returns(bool);
}
contract NewContract {
 function f(uint8 a) public returns (bool) {
 return OldLibrary.someFunction(a);
 }
}
## Example[](#example "Link to this heading")
The following example shows a contract and its updated version for Solidity v0.5.0 with some of the changes listed in this section.
Old version:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjQuMjU7Ci8vIFRoaXMgd2lsbCBub3QgY29tcGlsZSBhZnRlciAwLjUuMAoKY29udHJhY3QgT3RoZXJDb250cmFjdCB7CiAgICB1aW50IHg7CiAgICBmdW5jdGlvbiBmKHVpbnQgeSkgZXh0ZXJuYWwgewogICAgICAgIHggPSB5OwogICAgfQogICAgZnVuY3Rpb24oKSBwYXlhYmxlIGV4dGVybmFsIHt9Cn0KCmNvbnRyYWN0IE9sZCB7CiAgICBPdGhlckNvbnRyYWN0IG90aGVyOwogICAgdWludCBteU51bWJlcjsKCiAgICAvLyBGdW5jdGlvbiBtdXRhYmlsaXR5IG5vdCBwcm92aWRlZCwgbm90IGFuIGVycm9yLgogICAgZnVuY3Rpb24gc29tZUludGVnZXIoKSBpbnRlcm5hbCByZXR1cm5zICh1aW50KSB7IHJldHVybiAyOyB9CgogICAgLy8gRnVuY3Rpb24gdmlzaWJpbGl0eSBub3QgcHJvdmlkZWQsIG5vdCBhbiBlcnJvci4KICAgIC8vIEZ1bmN0aW9uIG11dGFiaWxpdHkgbm90IHByb3ZpZGVkLCBub3QgYW4gZXJyb3IuCiAgICBmdW5jdGlvbiBmKHVpbnQgeCkgcmV0dXJucyAoYnl0ZXMpIHsKICAgICAgICAvLyBWYXIgaXMgZmluZSBpbiB0aGlzIHZlcnNpb24uCiAgICAgICAgdmFyIHogPSBzb21lSW50ZWdlcigpOwogICAgICAgIHggKz0gejsKICAgICAgICAvLyBUaHJvdyBpcyBmaW5lIGluIHRoaXMgdmVyc2lvbi4KICAgICAgICBpZiAoeCA+IDEwMCkKICAgICAgICAgICAgdGhyb3c7CiAgICAgICAgYnl0ZXMgbWVtb3J5IGIgPSBuZXcgYnl0ZXMoeCk7CiAgICAgICAgeSA9IC0zID4+IDE7CiAgICAgICAgLy8geSA9PSAtMSAod3JvbmcsIHNob3VsZCBiZSAtMikKICAgICAgICBkbyB7CiAgICAgICAgICAgIHggKz0gMTsKICAgICAgICAgICAgaWYgKHggPiAxMCkgY29udGludWU7CiAgICAgICAgICAgIC8vICdDb250aW51ZScgY2F1c2VzIGFuIGluZmluaXRlIGxvb3AuCiAgICAgICAgfSB3aGlsZSAoeCA8IDExKTsKICAgICAgICAvLyBDYWxsIHJldHVybnMgb25seSBhIEJvb2wuCiAgICAgICAgYm9vbCBzdWNjZXNzID0gYWRkcmVzcyhvdGhlcikuY2FsbCgiZiIpOwogICAgICAgIGlmICghc3VjY2VzcykKICAgICAgICAgICAgcmV2ZXJ0KCk7CiAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIC8vIExvY2FsIHZhcmlhYmxlcyBjb3VsZCBiZSBkZWNsYXJlZCBhZnRlciB0aGVpciB1c2UuCiAgICAgICAgICAgIGludCB5OwogICAgICAgIH0KICAgICAgICByZXR1cm4gYjsKICAgIH0KCiAgICAvLyBObyBuZWVkIGZvciBhbiBleHBsaWNpdCBkYXRhIGxvY2F0aW9uIGZvciAnYXJyJwogICAgZnVuY3Rpb24gZyh1aW50W10gYXJyLCBieXRlczggeCwgT3RoZXJDb250cmFjdCBvdGhlckNvbnRyYWN0KSBwdWJsaWMgewogICAgICAgIG90aGVyQ29udHJhY3QudHJhbnNmZXIoMSBldGhlcik7CgogICAgICAgIC8vIFNpbmNlIHVpbnQzMiAoNCBieXRlcykgaXMgc21hbGxlciB0aGFuIGJ5dGVzOCAoOCBieXRlcyksCiAgICAgICAgLy8gdGhlIGZpcnN0IDQgYnl0ZXMgb2YgeCB3aWxsIGJlIGxvc3QuIFRoaXMgbWlnaHQgbGVhZCB0bwogICAgICAgIC8vIHVuZXhwZWN0ZWQgYmVoYXZpb3Igc2luY2UgYnl0ZXNYIGFyZSByaWdodCBwYWRkZWQuCiAgICAgICAgdWludDMyIHkgPSB1aW50MzIoeCk7CiAgICAgICAgbXlOdW1iZXIgKz0geSArIG1zZy52YWx1ZTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.4.25;
// This will not compile after 0.5.0
contract OtherContract {
 uint x;
 function f(uint y) external {
 x \= y;
 }
 function() payable external {}
}
contract Old {
 OtherContract other;
 uint myNumber;
 // Function mutability not provided, not an error.
 function someInteger() internal returns (uint) { return 2; }
 // Function visibility not provided, not an error.
 // Function mutability not provided, not an error.
 function f(uint x) returns (bytes) {
 // Var is fine in this version.
 var z \= someInteger();
 x += z;
 // Throw is fine in this version.
 if (x \> 100)
 throw;
 bytes memory b \= new bytes(x);
 y \= \-3 \>> 1;
 // y == -1 (wrong, should be -2)
 do {
 x += 1;
 if (x \> 10) continue;
 // 'Continue' causes an infinite loop.
 } while (x < 11);
 // Call returns only a Bool.
 bool success \= address(other).call("f");
 if (!success)
 revert();
 else {
 // Local variables could be declared after their use.
 int y;
 }
 return b;
 }
 // No need for an explicit data location for 'arr'
 function g(uint\[\] arr, bytes8 x, OtherContract otherContract) public {
 otherContract.transfer(1 ether);
 // Since uint32 (4 bytes) is smaller than bytes8 (8 bytes),
 // the first 4 bytes of x will be lost. This might lead to
 // unexpected behavior since bytesX are right padded.
 uint32 y \= uint32(x);
 myNumber += y + msg.value;
 }
}
New version:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjUuMDsKLy8gVGhpcyB3aWxsIG5vdCBjb21waWxlIGFmdGVyIDAuNi4wCgpjb250cmFjdCBPdGhlckNvbnRyYWN0IHsKICAgIHVpbnQgeDsKICAgIGZ1bmN0aW9uIGYodWludCB5KSBleHRlcm5hbCB7CiAgICAgICAgeCA9IHk7CiAgICB9CiAgICBmdW5jdGlvbigpIHBheWFibGUgZXh0ZXJuYWwge30KfQoKY29udHJhY3QgTmV3IHsKICAgIE90aGVyQ29udHJhY3Qgb3RoZXI7CiAgICB1aW50IG15TnVtYmVyOwoKICAgIC8vIEZ1bmN0aW9uIG11dGFiaWxpdHkgbXVzdCBiZSBzcGVjaWZpZWQuCiAgICBmdW5jdGlvbiBzb21lSW50ZWdlcigpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludCkgeyByZXR1cm4gMjsgfQoKICAgIC8vIEZ1bmN0aW9uIHZpc2liaWxpdHkgbXVzdCBiZSBzcGVjaWZpZWQuCiAgICAvLyBGdW5jdGlvbiBtdXRhYmlsaXR5IG11c3QgYmUgc3BlY2lmaWVkLgogICAgZnVuY3Rpb24gZih1aW50IHgpIHB1YmxpYyByZXR1cm5zIChieXRlcyBtZW1vcnkpIHsKICAgICAgICAvLyBUaGUgdHlwZSBtdXN0IG5vdyBiZSBleHBsaWNpdGx5IGdpdmVuLgogICAgICAgIHVpbnQgeiA9IHNvbWVJbnRlZ2VyKCk7CiAgICAgICAgeCArPSB6OwogICAgICAgIC8vIFRocm93IGlzIG5vdyBkaXNhbGxvd2VkLgogICAgICAgIHJlcXVpcmUoeCA8PSAxMDApOwogICAgICAgIGludCB5ID0gLTMgPj4gMTsKICAgICAgICByZXF1aXJlKHkgPT0gLTIpOwogICAgICAgIGRvIHsKICAgICAgICAgICAgeCArPSAxOwogICAgICAgICAgICBpZiAoeCA+IDEwKSBjb250aW51ZTsKICAgICAgICAgICAgLy8gJ0NvbnRpbnVlJyBqdW1wcyB0byB0aGUgY29uZGl0aW9uIGJlbG93LgogICAgICAgIH0gd2hpbGUgKHggPCAxMSk7CgogICAgICAgIC8vIENhbGwgcmV0dXJucyAoYm9vbCwgYnl0ZXMpLgogICAgICAgIC8vIERhdGEgbG9jYXRpb24gbXVzdCBiZSBzcGVjaWZpZWQuCiAgICAgICAgKGJvb2wgc3VjY2VzcywgYnl0ZXMgbWVtb3J5IGRhdGEpID0gYWRkcmVzcyhvdGhlcikuY2FsbCgiZiIpOwogICAgICAgIGlmICghc3VjY2VzcykKICAgICAgICAgICAgcmV2ZXJ0KCk7CiAgICAgICAgcmV0dXJuIGRhdGE7CiAgICB9CgogICAgdXNpbmcgQWRkcmVzc01ha2VQYXlhYmxlIGZvciBhZGRyZXNzOwogICAgLy8gRGF0YSBsb2NhdGlvbiBmb3IgJ2FycicgbXVzdCBiZSBzcGVjaWZpZWQKICAgIGZ1bmN0aW9uIGcodWludFtdIG1lbW9yeSAvKiBhcnIgKi8sIGJ5dGVzOCB4LCBPdGhlckNvbnRyYWN0IG90aGVyQ29udHJhY3QsIGFkZHJlc3MgdW5rbm93bkNvbnRyYWN0KSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgLy8gJ290aGVyQ29udHJhY3QudHJhbnNmZXInIGlzIG5vdCBwcm92aWRlZC4KICAgICAgICAvLyBTaW5jZSB0aGUgY29kZSBvZiAnT3RoZXJDb250cmFjdCcgaXMga25vd24gYW5kIGhhcyB0aGUgZmFsbGJhY2sKICAgICAgICAvLyBmdW5jdGlvbiwgYWRkcmVzcyhvdGhlckNvbnRyYWN0KSBoYXMgdHlwZSAnYWRkcmVzcyBwYXlhYmxlJy4KICAgICAgICBhZGRyZXNzKG90aGVyQ29udHJhY3QpLnRyYW5zZmVyKDEgZXRoZXIpOwoKICAgICAgICAvLyAndW5rbm93bkNvbnRyYWN0LnRyYW5zZmVyJyBpcyBub3QgcHJvdmlkZWQuCiAgICAgICAgLy8gJ2FkZHJlc3ModW5rbm93bkNvbnRyYWN0KS50cmFuc2ZlcicgaXMgbm90IHByb3ZpZGVkCiAgICAgICAgLy8gc2luY2UgJ2FkZHJlc3ModW5rbm93bkNvbnRyYWN0KScgaXMgbm90ICdhZGRyZXNzIHBheWFibGUnLgogICAgICAgIC8vIElmIHRoZSBmdW5jdGlvbiB0YWtlcyBhbiAnYWRkcmVzcycgd2hpY2ggeW91IHdhbnQgdG8gc2VuZAogICAgICAgIC8vIGZ1bmRzIHRvLCB5b3UgY2FuIGNvbnZlcnQgaXQgdG8gJ2FkZHJlc3MgcGF5YWJsZScgdmlhICd1aW50MTYwJy4KICAgICAgICAvLyBOb3RlOiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZCBhbmQgdGhlIGV4cGxpY2l0IHR5cGUKICAgICAgICAvLyAnYWRkcmVzcyBwYXlhYmxlJyBzaG91bGQgYmUgdXNlZCB3aGVuZXZlciBwb3NzaWJsZS4KICAgICAgICAvLyBUbyBpbmNyZWFzZSBjbGFyaXR5LCB3ZSBzdWdnZXN0IHRoZSB1c2Ugb2YgYSBsaWJyYXJ5IGZvcgogICAgICAgIC8vIHRoZSBjb252ZXJzaW9uIChwcm92aWRlZCBhZnRlciB0aGUgY29udHJhY3QgaW4gdGhpcyBleGFtcGxlKS4KICAgICAgICBhZGRyZXNzIHBheWFibGUgYWRkciA9IHVua25vd25Db250cmFjdC5tYWtlUGF5YWJsZSgpOwogICAgICAgIHJlcXVpcmUoYWRkci5zZW5kKDEgZXRoZXIpKTsKCiAgICAgICAgLy8gU2luY2UgdWludDMyICg0IGJ5dGVzKSBpcyBzbWFsbGVyIHRoYW4gYnl0ZXM4ICg4IGJ5dGVzKSwKICAgICAgICAvLyB0aGUgY29udmVyc2lvbiBpcyBub3QgYWxsb3dlZC4KICAgICAgICAvLyBXZSBuZWVkIHRvIGNvbnZlcnQgdG8gYSBjb21tb24gc2l6ZSBmaXJzdDoKICAgICAgICBieXRlczQgeDQgPSBieXRlczQoeCk7IC8vIFBhZGRpbmcgaGFwcGVucyBvbiB0aGUgcmlnaHQKICAgICAgICB1aW50MzIgeSA9IHVpbnQzMih4NCk7IC8vIENvbnZlcnNpb24gaXMgY29uc2lzdGVudAogICAgICAgIC8vICdtc2cudmFsdWUnIGNhbm5vdCBiZSB1c2VkIGluIGEgJ25vbi1wYXlhYmxlJyBmdW5jdGlvbi4KICAgICAgICAvLyBXZSBuZWVkIHRvIG1ha2UgdGhlIGZ1bmN0aW9uIHBheWFibGUKICAgICAgICBteU51bWJlciArPSB5ICsgbXNnLnZhbHVlOwogICAgfQp9CgovLyBXZSBjYW4gZGVmaW5lIGEgbGlicmFyeSBmb3IgZXhwbGljaXRseSBjb252ZXJ0aW5nIGBgYWRkcmVzc2BgCi8vIHRvIGBgYWRkcmVzcyBwYXlhYmxlYGAgYXMgYSB3b3JrYXJvdW5kLgpsaWJyYXJ5IEFkZHJlc3NNYWtlUGF5YWJsZSB7CiAgICBmdW5jdGlvbiBtYWtlUGF5YWJsZShhZGRyZXNzIHgpIGludGVybmFsIHB1cmUgcmV0dXJucyAoYWRkcmVzcyBwYXlhYmxlKSB7CiAgICAgICAgcmV0dXJuIGFkZHJlc3ModWludDE2MCh4KSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.5.0;
// This will not compile after 0.6.0
contract OtherContract {
 uint x;
 function f(uint y) external {
 x \= y;
 }
 function() payable external {}
}
contract New {
 OtherContract other;
 uint myNumber;
 // Function mutability must be specified.
 function someInteger() internal pure returns (uint) { return 2; }
 // Function visibility must be specified.
 // Function mutability must be specified.
 function f(uint x) public returns (bytes memory) {
 // The type must now be explicitly given.
 uint z \= someInteger();
 x += z;
 // Throw is now disallowed.
 require(x <= 100);
 int y \= \-3 \>> 1;
 require(y \== \-2);
 do {
 x += 1;
 if (x \> 10) continue;
 // 'Continue' jumps to the condition below.
 } while (x < 11);
 // Call returns (bool, bytes).
 // Data location must be specified.
 (bool success, bytes memory data) \= address(other).call("f");
 if (!success)
 revert();
 return data;
 }
 using AddressMakePayable for address;
 // Data location for 'arr' must be specified
 function g(uint\[\] memory /\* arr \*/, bytes8 x, OtherContract otherContract, address unknownContract) public payable {
 // 'otherContract.transfer' is not provided.
 // Since the code of 'OtherContract' is known and has the fallback
 // function, address(otherContract) has type 'address payable'.
 address(otherContract).transfer(1 ether);
 // 'unknownContract.transfer' is not provided.
 // 'address(unknownContract).transfer' is not provided
 // since 'address(unknownContract)' is not 'address payable'.
 // If the function takes an 'address' which you want to send
 // funds to, you can convert it to 'address payable' via 'uint160'.
 // Note: This is not recommended and the explicit type
 // 'address payable' should be used whenever possible.
 // To increase clarity, we suggest the use of a library for
 // the conversion (provided after the contract in this example).
 address payable addr \= unknownContract.makePayable();
 require(addr.send(1 ether));
 // Since uint32 (4 bytes) is smaller than bytes8 (8 bytes),
 // the conversion is not allowed.
 // We need to convert to a common size first:
 bytes4 x4 \= bytes4(x); // Padding happens on the right
 uint32 y \= uint32(x4); // Conversion is consistent
 // 'msg.value' cannot be used in a 'non-payable' function.
 // We need to make the function payable
 myNumber += y + msg.value;
 }
}
// We can define a library for explicitly converting \`\`address\`\`
// to \`\`address payable\`\` as a workaround.
library AddressMakePayable {
 function makePayable(address x) internal pure returns (address payable) {
 return address(uint160(x));
 }
}

# [Analysing the Compiler Output — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/analysing-compilation-output.html) 
 _https://docs.soliditylang.org/en/v0.8.30/analysing-compilation-output.html_

It is often useful to look at the assembly code generated by the compiler. The generated binary, i.e., the output of `solc --bin contract.sol`, is generally difficult to read. It is recommended to use the flag `--asm` to analyse the assembly output. Even for large contracts, looking at a visual diff of the assembly before and after a change is often very enlightening.
Consider the following contract (named, say `contract.sol`):
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwpjb250cmFjdCBDIHsKICAgIGZ1bmN0aW9uIG9uZSgpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4gMTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
contract C {
 function one() public pure returns (uint) {
 return 1;
 }
}
The following would be the output of `solc --asm contract.sol`
\======= contract.sol:C =======
EVM assembly:
 /\* "contract.sol":0:86 contract C {... \*/
 mstore(0x40, 0x80)
 callvalue
 dup1
 iszero
 tag\_1
 jumpi
 0x00
 dup1
 revert
tag\_1:
 pop
 dataSize(sub\_0)
 dup1
 dataOffset(sub\_0)
 0x00
 codecopy
 0x00
 return
stop
sub\_0: assembly {
 /\* "contract.sol":0:86 contract C {... \*/
 mstore(0x40, 0x80)
 callvalue
 dup1
 iszero
 tag\_1
 jumpi
 0x00
 dup1
 revert
 tag\_1:
 pop
 jumpi(tag\_2, lt(calldatasize, 0x04))
 shr(0xe0, calldataload(0x00))
 dup1
 0x901717d1
 eq
 tag\_3
 jumpi
 tag\_2:
 0x00
 dup1
 revert
 /\* "contract.sol":17:84 function one() public pure returns (uint) {... \*/
 tag\_3:
 tag\_4
 tag\_5
 jump // in
 tag\_4:
 mload(0x40)
 tag\_6
 swap2
 swap1
 tag\_7
 jump // in
 tag\_6:
 mload(0x40)
 dup1
 swap2
 sub
 swap1
 return
 tag\_5:
 /\* "contract.sol":53:57 uint \*/
 0x00
 /\* "contract.sol":76:77 1 \*/
 0x01
 /\* "contract.sol":69:77 return 1 \*/
 swap1
 pop
 /\* "contract.sol":17:84 function one() public pure returns (uint) {... \*/
 swap1
 jump // out
 /\* "#utility.yul":7:125 \*/
 tag\_10:
 /\* "#utility.yul":94:118 \*/
 tag\_12
 /\* "#utility.yul":112:117 \*/
 dup2
 /\* "#utility.yul":94:118 \*/
 tag\_13
 jump // in
 tag\_12:
 /\* "#utility.yul":89:92 \*/
 dup3
 /\* "#utility.yul":82:119 \*/
 mstore
 /\* "#utility.yul":72:125 \*/
 pop
 pop
 jump // out
 /\* "#utility.yul":131:353 \*/
 tag\_7:
 0x00
 /\* "#utility.yul":262:264 \*/
 0x20
 /\* "#utility.yul":251:260 \*/
 dup3
 /\* "#utility.yul":247:265 \*/
 add
 /\* "#utility.yul":239:265 \*/
 swap1
 pop
 /\* "#utility.yul":275:346 \*/
 tag\_15
 /\* "#utility.yul":343:344 \*/
 0x00
 /\* "#utility.yul":332:341 \*/
 dup4
 /\* "#utility.yul":328:345 \*/
 add
 /\* "#utility.yul":319:325 \*/
 dup5
 /\* "#utility.yul":275:346 \*/
 tag\_10
 jump // in
 tag\_15:
 /\* "#utility.yul":229:353 \*/
 swap3
 swap2
 pop
 pop
 jump // out
 /\* "#utility.yul":359:436 \*/
 tag\_13:
 0x00
 /\* "#utility.yul":425:430 \*/
 dup2
 /\* "#utility.yul":414:430 \*/
 swap1
 pop
 /\* "#utility.yul":404:436 \*/
 swap2
 swap1
 pop
 jump // out
 auxdata: 0xa2646970667358221220a5874f19737ddd4c5d77ace1619e5160c67b3d4bedac75fce908fed32d98899864736f6c637827302e382e342d646576656c6f702e323032312e332e33302b636f6d6d69742e65613065363933380058
}
Alternatively, the above output can also be obtained from [Remix](https://remix.ethereum.org/), under the option “Compilation Details” after compiling a contract.
Notice that the `asm` output starts with the creation / constructor code. The deploy code is provided as part of the sub object (in the above example, it is part of the sub-object `sub_0`). The `auxdata` field corresponds to the contract [metadata](https://docs.soliditylang.org/en/v0.8.30/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode). The comments in the assembly output point to the source location. Note that ＃utility.yul is an internally generated file of utility functions that can be obtained using the flags `--combined-json generated-sources,generated-sources-runtime`.
Similarly, the optimized assembly can be obtained with the command: `solc --optimize --asm contract.sol`. Often times, it is interesting to see if two different sources in Solidity result in the same optimized code. For example, to see if the expressions `(a * b) / c`, `a * b / c` generates the same bytecode. This can be easily done by taking a `diff` of the corresponding assembly output, after potentially stripping comments that reference the source locations.
Note
The `--asm` output is not designed to be machine readable. Therefore, there may be breaking changes on the output between minor versions of solc.

# [Kaynaklar — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/resources.html) 
 _https://docs.soliditylang.org/tr/latest/resources.html_

[Solidity](https://docs.soliditylang.org/tr/latest/index.html)
## Genel Kaynaklar[](#genel-kaynaklar "Permalink to this heading")
* [Ethereum.org Geliştirici Portalı](https://ethereum.org/en/developers/)
 
* [Ethereum StackExchange](https://ethereum.stackexchange.com/)
 
* [Solidity Portal](https://soliditylang.org/)
 
* [Solidity Değişiklik Günlüğü](https://github.com/ethereum/solidity/blob/develop/Changelog.md)
 
* [Solidity Kaynak Kodu GitHub’da](https://github.com/ethereum/solidity/)
 
* [Solidity Language Users Chat](https://matrix.to/#/#ethereum_solidity:gitter.im)
 
* [Solidity Compiler Developers Chat](https://matrix.to/#/#ethereum_solidity-dev:gitter.im)
 
* [Awesome Solidity](https://github.com/bkrem/awesome-solidity)
 
* [Solidity by Example](https://solidity-by-example.org/)
 
* [Solidity Dokümantasyon Topluluğu Çevirileri](https://github.com/solidity-docs)
 
## Entegre (Ethereum) Geliştirme Ortamları[](#entegre-ethereum-gelistirme-ortamlari "Permalink to this heading")
> * [Brownie](https://eth-brownie.readthedocs.io/en/stable/) Ethereum Sanal Makinesini hedefleyen akıllı sözleşmeler için Python tabanlı geliştirme ve test çerçevesi.
> 
> * [Dapp](https://dapp.tools/) Komut satırından akıllı sözleşmeler oluşturmak, test etmek ve dağıtmak için bir araç.
> 
> * [Embark](https://framework.embarklabs.io/) Merkezi olmayan uygulamalar oluşturmak ve dağıtmak için geliştirici platformu.
> 
> * [Foundry](https://github.com/gakonst/foundry) Rust ile yazılmış Ethereum uygulama geliştirme için hızlı, taşınabilir ve modüler araç seti.
> 
> * [Hardhat](https://hardhat.org/) Yerel Ethereum ağı, hata ayıklama özellikleri ve eklenti ekosistemi ile Ethereum geliştirme ortamı.
> 
> * [Remix](https://remix.ethereum.org/) Sunucu tarafı bileşenleri olmayan entegre derleyici ve Solidity çalışma zamanı ortamına sahip tarayıcı tabanlı IDE.
> 
> * [Truffle](https://www.trufflesuite.com/truffle) Ethereum geliştirme çerçevesi.
> 
## Editör Entegrasyonları[](#editor-entegrasyonlari "Permalink to this heading")
* Atom
 
 > * [Etheratom](https://github.com/0mkara/etheratom)
 > 
 > Sözdizimi vurgulama, derleme ve çalışma zamanı ortamı (Backend node ve VM uyumlu) içeren Atom editörü için eklenti.
 > 
 > * [Atom Solidity Linter](https://atom.io/packages/linter-solidity)
 > 
 > Solidity linting sağlayan Atom editörü için eklenti.
 > 
 > * [Atom Solium Linter](https://atom.io/packages/linter-solium)
 > 
 > Solium’u (şimdi Ethlint) temel olarak kullanan Atom için yapılandırılabilir Solidity linter.
 > 
 
* Emacs
 
 > * [Emacs Solidity](https://github.com/ethereum/emacs-solidity/)
 > 
 > Emacs editörü için sözdizimi vurgulama ve derleme hatası raporlama sağlayan eklenti.
 > 
 
* IntelliJ
 
 > * [IntelliJ IDEA eklentisi](https://plugins.jetbrains.com/plugin/9475-intellij-solidity)
 > 
 > IntelliJ IDEA (ve diğer tüm JetBrains IDE’leri) için Solidity eklentisi
 > 
 
* Sublime
 
 > * [SublimeText için paket - Solidity dil sözdizimi](https://packagecontrol.io/packages/Ethereum/)
 > 
 > SublimeText editörü için Solidity sözdizimi vurgulama.
 > 
 
* Vim
 
 > * [Vim Solidity](https://github.com/tomlion/vim-solidity/)
 > 
 > Vim düzenleyicisi için sözdizimi vurgulama sağlayan eklenti.
 > 
 > * [Vim Syntastic](https://github.com/vim-syntastic/syntastic)
 > 
 > Derleme denetimi sağlayan Vim düzenleyicisi için eklenti.
 > 
 
* Visual Studio Code
 
 > * [Visual Studio Kod uzantısı](https://juan.blanco.ws/solidity-contracts-in-visual-studio-code/)
 > 
 > Microsoft Visual Studio Code için sözdizimi vurgulama ve Solidity derleyicisi içeren Solidity eklentisi.
 > 
 > * [Solidity Görsel Denetçi uzantısı](https://marketplace.visualstudio.com/items?itemName=tintinweb.solidity-visual-auditor)
 > 
 > Visual Studio Code’a güvenlik merkezli sözdizimi ve anlamsal vurgulama ekler.
 > 
 
## Solidity Araçları[](#solidity-araclari "Permalink to this heading")
* [ABI - Solidity arayüz dönüştürücüsü](https://gist.github.com/chriseth/8f533d133fa0c15b0d6eaf3ec502c82b)
 
 Akıllı bir sözleşmenin ABI’sinden sözleşme arayüzleri oluşturmak için bir betik.
 
* [abi-to-sol](https://github.com/gnidan/abi-to-sol)
 
 Belirli bir ABI JSON’dan Solidity arayüz kaynağı oluşturmak için araç.
 
* [Doxity](https://github.com/DigixGlobal/doxity)
 
 Solidity için Dokümantasyon Oluşturucu.
 
* [Ethlint](https://github.com/duaraghav8/Ethlint)
 
 Solidity’deki stil ve güvenlik sorunlarını tanımlamak ve düzeltmek için Linter.
 
* [evmdis](https://github.com/Arachnid/evmdis)
 
 Ham EVM işlemlerinden daha yüksek bir soyutlama düzeyi sağlamak için bytecode üzerinde statik analiz gerçekleştiren EVM Disassembler.
 
* [EVM Lab](https://github.com/ethereum/evmlab/)
 
 EVM ile etkileşim için zengin araç paketi. Bir VM, Etherchain API ve gaz maliyeti göstergeli bir izleme görüntüleyici içerir.
 
* [hevm](https://github.com/dapphub/dapptools/tree/master/src/hevm#readme)
 
 EVM hata ayıklayıcı ve sembolik yürütme motoru.
 
* [leafleth](https://github.com/clemlak/leafleth)
 
 Solidity akıllı sözleşmeleri için bir dokümantasyon oluşturucu.
 
* [PIET](https://piet.slock.it/)
 
 Basit bir grafik arayüz aracılığıyla Solidity akıllı sözleşmelerini geliştirmek, denetlemek ve kullanmak için bir araç.
 
* [Scaffold-ETH](https://github.com/scaffold-eth/scaffold-eth)
 
 Hızlı ürün yinelemelerine odaklanan forklanabilir Ethereum geliştirme yığını.
 
* [sol2uml](https://www.npmjs.com/package/sol2uml)
 
 Solidity sözleşmeleri için Birleşik Modelleme Dili (UML) sınıf diyagramı oluşturucu.
 
* [solc-select](https://github.com/crytic/solc-select)
 
 Solidity derleyici sürümleri arasında hızlıca geçiş yapmak için bir betik.
 
* [Solidity prettier eklentisi](https://github.com/prettier-solidity/prettier-plugin-solidity)
 
 Solidity için prettier.
 
* [Solidity REPL](https://github.com/raineorshine/solidity-repl)
 
 Solidity’yi bir komut satırı Solidity konsolu ile anında deneyin.
 
* [solgraph](https://github.com/raineorshine/solgraph)
 
 Solidity kontrol akışını görselleştirin ve potansiyel güvenlik açıklarını vurgulayın.
 
* [Solhint](https://github.com/protofire/solhint)
 
 Akıllı sözleşme doğrulaması için güvenlik, stil kılavuzu ve en iyi uygulama kuralları sağlayan Solidity linter.
 
* [Sourcify](https://sourcify.dev/)
 
 Merkezi olmayan otomatik sözleşme doğrulama hizmeti ve sözleşme meta verilerinin halka açık deposu.
 
* [Sūrya](https://github.com/ConsenSys/surya/)
 
 Akıllı sözleşme sistemleri için bir dizi görsel çıktı ve sözleşmelerin yapısı hakkında bilgi sunan yardımcı araç. Ayrıca fonksiyon çağrı grafiğini sorgulamayı da destekler.
 
* [Universal Mutator](https://github.com/agroce/universalmutator)
 
 Yapılandırılabilir kurallar ve Solidity ve Vyper desteği ile mutasyon üretimi için bir araç.
 
## Üçüncü Parti Solidity Ayrıştırıcıları ve Gramerleri[](#ucuncu-parti-solidity-ayristiricilari-ve-gramerleri "Permalink to this heading")
* [Solidity Parser for JavaScript](https://github.com/solidity-parser/parser)
 
 Sağlam bir ANTLR4 gramerinin üzerine inşa edilmiş JS için bir Solidity ayrıştırıcısı.

# [Ara — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/search.html) 
 _https://docs.soliditylang.org/tr/latest/search.html_

* [](https://docs.soliditylang.org/tr/latest/index.html)
* Ara
* * *

# [Derleyicinin Kullanımı — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/using-the-compiler.html) 
 _https://docs.soliditylang.org/tr/latest/using-the-compiler.html_

## Komut Satırı Derleyicisinin Kullanımı[](#komut-satiri-derleyicisinin-kullanimi "Permalink to this heading")
Not
Bu bölüm, komut satırı modunda kullanılsa bile [solcjs](https://docs.soliditylang.org/tr/latest/installing-solidity.html#solcjs) için geçerli değildir.
### Temel Kullanım[](#temel-kullanim "Permalink to this heading")
Solidity deposunun(repository) derleme kaynaklarından biri de Solidity komut satırı derleyicisi olan `solc` dur. `solc --help` komutunu kullanmak size tüm seçeneklerin açıklamalarını verir. Derleyici, soyut bir sözdizimi ağacı (parse tree) üzerinde basit binary ve assembly’den gaz kullanımı tahminlerine kadar çeşitli çıktılar üretebilir. Sadece tek bir dosyayı derlemek istiyorsanız, `solc --bin sourceFile.sol` şeklinde çalıştırdığınızda binary dosyayı yazdıracaktır. Eğer `solc``un daha gelişmiş çıktı çeşitlerinden bazılarını elde etmek istiyorsanız, ``solc -o outputDirectory --bin --ast-compact-json --asm sourceFile.sol` kullanarak her öğeyi ayrı dosyalara çıktı olarak vermesini söylemek muhtemelen daha iyi bir seçenek olacaktır.
### Optimize Edici Seçenekleri[](#optimize-edici-secenekleri "Permalink to this heading")
Sözleşmenizi deploy etmeden önce, `solc --optimize --bin sourceFile.sol` kullanarak derleme yaparken optimize ediciyi etkinleştirmelisiniz. Standart olarak optimize edici, sözleşmenin ömrü boyunca 200 kez çağrıldığını varsayarak sözleşmeyi optimize edecektir (daha spesifik olarak, her bir işlem kodunun yaklaşık 200 kez çalıştırıldığını varsayar). İlk sözleşme dağıtımının daha ucuz olmasını ve daha sonraki fonksiyon yürütmelerinin(executions) daha pahalı olmasını istiyorsanız, `--optimize-runs=1` olarak ayarlayın. Çok sayıda işlem bekliyorsanız ve daha yüksek dağıtım maliyeti ve çıktı boyutunu önemsemiyorsanız, `--optimize-runs` değerini yüksek bir sayıya ayarlayın. Bu parametrenin aşağıdaki değerler üzerinde etkileri vardır (bu durum gelecekte değişebilir):
* fonksiyon gönderim prosedüründeki binary aramasının boyutu
 
* büyük sayılar veya dizeler gibi sabitlerin saklanma şekli
 
### Base Path ve Import Remapping[](#base-path-ve-import-remapping "Permalink to this heading")
Komut satırı derleyicisi içe aktarılan dosyaları dosya sisteminden otomatik olarak okuyacaktır, ancak aşağıdaki şekilde `prefix=path` kullanarak [path redirects](https://docs.soliditylang.org/tr/latest/path-resolution.html#import-remapping) sağlamanız da mümkündür:
solc github.com/ethereum/dapp-bin/\=/usr/local/lib/dapp-bin/ file.sol
This essentially instructs the compiler to search for anything starting with `github.com/ethereum/dapp-bin/` under `/usr/local/lib/dapp-bin`.
İçe aktarmaları aramak için dosya sistemine erişirken, :ref:\` ./ veya ../ <direct-imports>\` ile başlamayan dizinler, `--base-path` ve `--include-path` seçenekleri kullanılarak belirtilen dizinlere (veya temel yol belirtilmemişse geçerli çalışma dizinine) bağlı olarak değerlendirilir. Ayrıca, dizinin bu seçenekler aracılığıyla eklenen kısmı sözleşme metadatasında görünmeyecektir.
Güvenlik nedeniyle derleyicinin [hangi dizinlere erişebileceği konusunda kısıtlamaları vardır](https://docs.soliditylang.org/tr/latest/path-resolution.html#allowed-paths). Komut satırında belirtilen kaynak dosyaların dizinlerine ve yeniden eşlemelerin hedef yollarına dosya okuyucu tarafından erişilmesine otomatik olarak izin verilir, ancak diğer her şey varsayılan olarak reddedilir. İlave yollara (ve bunların alt dizinlerine) `--allow-paths /sample/path,/another/sample/path` anahtarıyla izin verilebilir. `--base-path` ile belirtilen yol içindeki her şeye her zaman izin verilir.
Yukarıda anlatılanlar, derleyicinin içe aktarma yollarını nasıl ele aldığının basitleştirilmiş halidir. Örneklerle birlikte ayrıntılı bir açıklama ve uç noktaların tartışılması için lütfen [path resolution](https://docs.soliditylang.org/tr/latest/path-resolution.html#path-resolution) bölümüne bakın.
### Kütüphane Bağlantıları (Library Linking)[](#kutuphane-baglantilari-library-linking "Permalink to this heading")
Sözleşmeleriniz [libraries](https://docs.soliditylang.org/tr/latest/contracts.html#libraries) kullanıyorsa, bytecode’un `__$53aea86b7d70b31448b230b20ae141a537$__` şeklinde alt dizeler içerdiğini fark edeceksiniz. Bunlar gerçek kütüphane adresleri için yer tutuculardır. Yer tutucu, tam nitelikli kütüphane adının keccak256 hash’inin hex encoding’inin 34 karakterlik bir önekidir. Bayt kodu dosyası, yer tutucuların hangi kütüphaneleri temsil ettiğini belirlemeye yardımcı olmak için sonunda `// <placeholder> -> <fq library name>` şeklinde satırlar da içerecektir. Tam nitelikli kütüphane adının, kaynak dosyasının yolu ve `:` ile ayrılmış kütüphane adı olduğunu unutmayın. Bir bağlayıcı olarak `solc` kullanabilirsiniz, yani bu noktalarda sizin için kütüphane adreslerini ekleyecektir:
Her kütüphane için bir adres sağlamak üzere komutunuza `--libraries "file.sol:Math=0x123456789012345678901234567890 file.sol:Heap=0xabCD567890123456789012345678901234567890"` ekleyin (ayırıcı olarak virgül veya boşluk kullanın) veya dizeyi bir dosyada saklayın (satır başına bir kütüphane) ve `--libraries fileName` kullanarak `solc` çalıştırın.
Not
Solidity 0.8.1’den itibaren `=` kütüphane ve adres arasında ayırıcı olarak kabul etmektedir ve `:` ayırıcı olarak kullanımdan kaldırılmıştır. Gelecekte kaldırılacaktır. Şu anda `-libraries "file.sol:Math:0x1234567890123456789012345678901234567890 file.sol:Heap:0xabCD567890123456789012345678901234567890"` da çalışacaktır.
Eğer `solc` `--standard-json` seçeneği ile çağrılırsa, standart girişte bir JSON girdisi (aşağıda açıklandığı gibi) bekleyecek ve standart çıkışta bir JSON çıktısı döndürecektir. Bu, daha karmaşık ve özellikle otomatikleştirilmiş kullanımlar için önerilen arayüzdür. İşlem her zaman “başarılı” durumda sonlanacak ve hataları JSON çıktısı aracılığıyla bildirecektir. `--base-path` seçeneği de standart-json modunda işlenir.
Eğer `solc` `--link` seçeneği ile çağrılırsa, tüm girdi dosyaları yukarıda verilen `__$53aea86b7d70b31448b230b20ae141a537$__`\-formatında bağlanmamış binaryler (hex-encoded) olarak yorumlanır ve yerinde bağlanır (eğer girdi stdin\`den okunuyorsa, stdout\`a yazılır). Bu durumda `--libraries` dışındaki tüm seçenekler göz ardı edilir (`-o` dahil).
Uyarı
Sözleşme meta verilerini güncellemediğinden, oluşturulan bayt kodu üzerinde kütüphaneleri manuel olarak bağlamak önerilmez. Metadata derleme sırasında belirtilen kütüphanelerin bir listesini içerdiğinden ve bayt kodu bir metadata hash’i içerdiğinden, bağlama işleminin ne zaman yapıldığına bağlı olarak farklı binary dosyaları elde edersiniz.
Derleyiciye standart-JSON arayüzünü kullanıyorsanız `solc` seçeneğinin `--libraries` seçeneğini veya `libraries` anahtarını kullanarak bir sözleşme derlendiğinde derleyiciden kütüphaneleri bağlamasını istemelisiniz.
Not
Kütüphane yer tutucusu eskiden kütüphanenin hash’i yerine kütüphanenin kendisinin tam nitelikli adı olurdu. Bu biçim hala `solc --link` tarafından desteklenmektedir ancak derleyici artık bu biçimin çıktısını vermeyecektir. Bu değişiklik, tam nitelikli kütüphane adının yalnızca ilk 36 karakteri kullanılabildiğinden, kütüphaneler arasında bir çakışma olasılığını azaltmak için yapılmıştır.
## EVM Sürümünün Hedefe Ayarlanması[](#evm-surumunun-hedefe-ayarlanmasi "Permalink to this heading")
Sözleşme kodunuzu derlerken, belirli özelliklerden veya davranışlardan kaçınmak için derlenecek Ethereum sanal makine sürümünü belirtebilirsiniz.
Uyarı
Hatalı EVM sürümü için derleme yapmak yanlış, garip ve başarısız davranışlara neden olabilir. Lütfen, özellikle özel bir zincir çalıştırıyorsanız, uyumlu EVM sürümlerini kullandığınızdan emin olun.
Komut satırında, EVM sürümünü aşağıdaki gibi seçebilirsiniz:
solc \--evm-version <VERSION> contract.sol
ref:standart JSON arayüzü <compiler-api>\`de, \`”settings”\`\` alanında `"evmVersion"` anahtarını kullanın:
{
 "sources": {/\* ... \*/},
 "settings": {
 "optimizer": {/\* ... \*/},
 "evmVersion": "<VERSION>"
 }
}
### Hedef Seçenekleri[](#hedef-secenekleri "Permalink to this heading")
Aşağıda hedef EVM sürümlerinin bir listesi ve her sürümde derleyiciyle ilgili yapılan değişiklikler yer almaktadır. Her sürüm arasında geriye dönük uyumluluk garanti edilmez.
* `homestead`
 
 * (en eski sürüm)
 
 
* `tangerineWhistle`
 
 * Gaz tahmini ve optimize edici ile ilgili diğer hesaplara erişim için gaz maliyeti arttı.
 
 * Harici aramalar için varsayılan olarak gönderilen tüm gaz. Daha önce belirli bir miktarın tutulması gerekiyordu.
 
 
* `spuriousDragon`
 
 * Gaz tahmini ve optimize edici ile ilgili `exp` işlem kodu için gaz maliyeti arttı.
 
 
* `byzantium`
 
 * Assembly’de `returndatacopy`, `returndatasize` ve `staticcall` işlem kodları mevcuttur.
 
 * `staticcall` işlem kodu, kütüphane dışı görünüm veya pure fonksiyonları çağırırken kullanılır, bu da fonksiyonların EVM seviyesinde durumu değiştirmesini engeller, yani geçersiz tip dönüşümleri kullandığınızda bile geçerlidir.
 
 * Fonksiyon çağrılarından dönen dinamik verilere erişmek mümkündür.
 
 * `revert` işlem kodu tanıtıldı, bu da `revert()` işleminin gaz israfına yol açmayacağı anlamına geliyor.
 
 
* `constantinople`
 
 * Assembly’de `create2`, `extcodehash`, `shl`, `shr` ve `sar` işlem kodları mevcuttur.
 
 * Shifting operatörleri shifting opcodes kullanır ve bu nedenle daha az gaza ihtiyaç duyar.
 
 
* `petersburg`
 
 * Derleyici istanbul’da olduğu gibi aynı şekilde davranır.
 
 
* `istanbul`
 
 * Assembly’de `chainid` ve `selfbalance` opcode’ları mevcuttur.
 
 
* `berlin`
 
 * `SLOAD`, `*CALL`, `BALANCE`, `EXT*` ve `SELFDESTRUCT` için gaz maliyetleri arttı. Bu maliyetler derleyici bu tür operasyonlarda soğuk gaz maliyetlerini varsayar. Bu, gaz tahmini için geçerlidir ve optimize edicidir.
 
 
* `london` (**default**)
 
 * Bloğun taban ücretine ([EIP-3198](https://eips.ethereum.org/EIPS/eip-3198) ve [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559)) global `block.basefee` veya inline assembly\`de `basefee()` aracılığıyla erişilebilir.
 
 
## Derleyici JSON Girdisi ve Çıktısı Tanımı[](#derleyici-json-girdisi-ve-ciktisi-tanimi "Permalink to this heading")
Özellikle daha karmaşık ve otomatik kurulumlar için Solidity derleyicisi ile arayüz oluşturmanın önerilen yolu JSON-girdi-çıktı arayüzüdür. Aynı arayüz derleyicinin tüm dağıtımları tarafından sağlanır.
Alanlar genellikle değişikliğe tabidir, bazıları isteğe bağlıdır (belirtildiği gibi), ancak yalnızca geriye dönük uyumlu değişiklikler yapmaya çalışıyoruz.
Derleyici API’si JSON formatında bir girdi bekler ve derleme sonucunu JSON formatında bir çıktı olarak verir. Standart hata çıktısı kullanılmaz ve hatalar olsa bile işlem her zaman “başarılı” durumda sonlandırılır. Hatalar her zaman JSON çıktısının bir parçası olarak rapor edilir.
Aşağıdaki alt bölümlerde format bir örnek üzerinden açıklanmaktadır. Yorumlara elbette izin verilmez ve burada yalnızca açıklama amacıyla kullanılır.
### Girdi Açıklaması[](#girdi-aciklamasi "Permalink to this heading")
{
 // Gerekli: Kaynak kod dili. Şu anda "Solidity" ve "Yul" desteklenmektedir.
 "language": "Solidity",
 // Gerekli
 "sources":
 {
 // Buradaki anahtarlar kaynak dosyaların "global" isimleridir,
 // içe aktarmalar yeniden eşlemeler yoluyla diğer dosyaları kullanabilir (aşağıya bakın).
 "myFile.sol":
 {
 // Opsiyonel: kaynak dosyanın keccak256 hash'i
 // URL'ler aracılığıyla içe aktarılmışsa alınan içeriği doğrulamak için kullanılır.
 "keccak256": "0x123...",
 // Gerekli ("content" kullanılmadığı sürece, aşağıya bakın): Kaynak dosyaya giden URL(ler).
 // URL(ler) bu sırayla içe aktarılmalı ve sonuç keccak256 hash'iyle
 // (varsa) kontrol edilmelidir. Hash eşleşmezse veya URL(ler)den hiçbiri başarıyla
 // sonuçlanmazsa, bir hata oluşmalıdır.
 // Komut satırı arayüzü kullanılarak yalnızca dosya sistemi yolları desteklenir.
 // JavaScript arayüzü ile URL, kullanıcı tarafından sağlanan okuma geri çağrısına aktarılır,
 // böylece geri çağrı tarafından desteklenen herhangi bir URL kullanılabilir.
 "urls":
 \[
 "bzzr://56ab...",
 "ipfs://Qma...",
 "/tmp/path/to/file.sol"
 // Dosyalar kullanılıyorsa, dizinleri komut satırına şu yolla eklenmelidir
 // \`--allow-paths <path>\`.
 \]
 },
 "destructible":
 {
 // Opsiyonel: kaynak dosyanın keccak256 hash'i
 "keccak256": "0x234...",
 // Gerekli ("urls" kullanılmadığı sürece): kaynak dosyanın gerçek içeriği
 "content": "contract destructible is owned { function shutdown() { if (msg.sender == owner) selfdestruct(owner); } }"
 }
 },
 // Opsiyonel
 "settings":
 {
 // Opsiyonel: Belirtilen aşamadan sonra derlemeyi durdurun. Şu anda burada sadece "parsing" geçerlidir
 "stopAfter": "parsing",
 // Opsiyonel: Yeniden eşlemelerin sıralanmış listesi
 "remappings": \[ ":g=/dir" \],
 // Opsiyonel: Optimize edici ayarları
 "optimizer": {
 // Varsayılan olarak devre dışıdır.
 // NOT: enabled=false hala bazı optimizasyonları açık bırakır. Aşağıdaki yorumlara bakın.
 // UYARI: 0.8.6 sürümünden önce 'enabled' anahtarını atlamak, false olarak ayarlamakla eşdeğer
 // değildi ve aslında tüm optimizasyonları devre dışı bırakıyordu.
 "enabled": true,
 // Kodu kaç kez çalıştırmayı planladığınıza göre optimize edin.
 // Düşük değerler ilk dağıtım maliyeti için daha fazla optimizasyon sağlarken, yüksek
 // değerler yüksek frekanslı kullanım için daha fazla optimizasyon sağlayacaktır.
 "runs": 200,
 // Optimize edici bileşenleri ayrıntılı olarak açın veya kapatın.
 // Yukarıdaki "enabled" anahtarı, burada değiştirilebilecek iki
 // varsayılan değer sağlar. Eğer "details" verilmişse, "enabled" atlanabilir.
 "details": {
 // Ayrıntı verilmediğinde peephole optimizer her zaman açıktır,
 // kapatmak için ayrıntıları kullanın.
 "peephole": true,
 // Ayrıntı verilmediğinde inliner her zaman açıktır,,
 // kapatmak için ayrıntıları kullanın.
 "inliner": true,
 // Kullanılmayan jumpdest kaldırıcı, ayrıntı verilmediğinde her zaman açıktır,
 // kapatmak için ayrıntıları kullanın.
 "jumpdestRemover": true,
 // Bazen değişmeli işlemlerde değişmezleri yeniden sıralar.
 "orderLiterals": false,
 // Yinelenen kod bloklarını kaldırır
 "deduplicate": false,
 // Ortak alt ifade eliminasyonu, bu en karmaşık adımdır ancak
 // aynı zamanda en büyük kazancı sağlayabilir.
 "cse": false,
 // Koddaki değişmez sayıların ve dizelerin gösterimini optimize edin.
 "constantOptimizer": false,
 // Yeni Yul optimize edici. Çoğunlukla ABI coder v2 ve inline assembly kodu
 // üzerinde çalışır.
 // Global optimizer ayarı ile birlikte etkinleştirilir ve
 // buradan devre dışı bırakılabilir.
 // Solidity 0.6.0'dan önce bu anahtar aracılığıyla etkinleştirilmesi gerekiyordu.
 "yul": false,
 // Yul optimize edici için ayarlama seçenekleri.
 "yulDetails": {
 // Değişkenler için yığın yuvalarının tahsisini iyileştirin, yığın yuvalarını erken boşaltabilir.
 // Yul optimize edici etkinleştirilirse varsayılan olarak etkinleştirilir.
 "stackAllocation": true,
 // Uygulanacak optimizasyon adımlarını seçin.
 // İsteğe bağlıdır, atlanırsa optimize edici varsayılan sırayı kullanır.
 "optimizerSteps": "dhfoDgvulfnTUtnIf..."
 }
 }
 },
 // Derlenecek EVM sürümü.
 // Tip denetimini ve kod üretimini etkiler. Yerleşim yeri olabilir,
 // tangerineWhistle, spuriousDragon, byzantium, constantinople, petersburg, istanbul or berlin
 "evmVersion": "byzantium",
 // Opsiyonel: Derleme işlem hattını Yul ara temsilinden geçecek şekilde değiştirin.
 // Bu varsayılan olarak yanlıştır.
 "viaIR": true,
 // Opsiyonel: Hata ayıklama ayarları
 "debug": {
 // Revert (ve require) sebep string' lerine nasıl işlem yapılır. Ayarlar
 // "default", "strip", "debug" ve "verboseDebug" şeklindedir.
 // "default" derleyici tarafından oluşturulan revert stringlerini enjekte etmez ve kullanıcı tarafından sağlananları tutar.
 // "strip" tüm revert stringlerini (mümkünse, yani değişmezler kullanılıyorsa) yan etkilerini koruyarak kaldırır
 // "debug" derleyici tarafından oluşturulan dahili geri dönüşler için stringler enjekte eder, şimdilik ABI kodlayıcıları V1 ve V2 için uygulanmaktadır.
 // "verboseDebug" kullanıcı tarafından sağlanan revert stringlerine daha fazla bilgi ekler (henüz uygulanmadı)
 "revertStrings": "default",
 // Opsiyonel: Üretilen EVM assembly ve Yul kodundaki yorumlara ne kadar ekstra
 // hata ayıklama bilgisi ekleneceği. Mevcut bileşenler şunlardır:
 // - \`location\`: Orijinal Solidity dosyasındaki ilgili öğenin konumunu belirten
 // \`@src <index>:<start>:<end>\` biçimindeki ek açıklamalar, burada:
 // - \`<index>\`, \`@use-src\` ek açıklamasıyla eşleşen dosya dizinidir,
 // - \`<start>\` o konumdaki ilk baytın indeksidir,
 // - \`<end>\` bu konumdan sonraki ilk baytın indeksidir.
 // - \`snippet\`: \`@src\` ile belirtilen konumdan tek satırlık bir kod parçacığı.
 // Parçacık alıntılanır ve ilgili \`@src\` ek açıklamasını takip eder.
 // - \`\*\`: Her şeyi talep etmek için kullanılabilecek joker karakter değeri.
 "debugInfo": \["location", "snippet"\]
 },
 // Metadata ayarları (isteğe bağlı)
 "metadata": {
 // URL'leri değil, yalnızca gerçek içeriği kullan (varsayılan olarak false)
 "useLiteralContent": true,
 // Bayt koduna eklenen metadata hash'i için verilen hash yöntemini kullanın.
 // Metadata hash'i "none" seçeneği ile bayt kodundan kaldırılabilir.
 // Diğer seçenekler "ipfs" ve "bzzr1 "dir.
 // Seçenek atlanırsa, varsayılan olarak "ipfs" kullanılır.
 "bytecodeHash": "ipfs"
 },
 // Kütüphanelerin adresleri. Tüm kütüphaneler burada verilmezse,
 // çıktı verileri farklı olan bağlantısız nesnelerle sonuçlanabilir.
 "libraries": {
 // En üst düzey anahtar, kütüphanenin kullanıldığı kaynak dosyanın adıdır.
 // Yeniden eşlemeler kullanılıyorsa, bu kaynak dosya yeniden eşlemeler
 // uygulandıktan sonraki genel yolla eşleşmelidir.
 // Bu anahtar boş bir string ise, bu global bir seviyeyi ifade eder.
 "myFile.sol": {
 "MyLib": "0x123123..."
 }
 },
 // Dosya ve sözleşme adlarına göre istenen çıktıları
 // seçmek için aşağıdakiler kullanılabilir.
 // Bu alan atlanırsa, derleyici yükler ve tür denetimi yapar,
 // ancak hatalar dışında herhangi bir çıktı üretmez.
 // Birinci seviye anahtar dosya adı, ikinci seviye anahtar ise sözleşme adıdır.
 // Boş bir sözleşme adı, bir sözleşmeye bağlı olmayan ancak AST gibi
 // tüm kaynak dosyaya bağlı olan çıktılar için kullanılır.
 // Sözleşme adı olarak bir yıldız, dosyadaki tüm sözleşmeleri ifade eder.
 // Benzer şekilde, dosya adı olarak bir yıldız tüm dosyalarla eşleşir.
 // Derleyicinin üretebileceği tüm çıktıları seçmek için
 // "outputSelection: { "\*": { "\*": \[ "\*" \], "": \[ "\*" \] } }"
 // ancak bunun derleme sürecini gereksiz yere yavaşlatabileceğini unutmayın.
 //
 // Mevcut çıktı türleri aşağıdaki gibidir:
 //
 // Dosya seviyesi (sözleşme adı olarak boş dize gerekir):
 // ast - Tüm kaynak dosyaların AST'si
 //
 // Sözleşme seviyesi (sözleşme adına veya "\*" işaretine ihtiyaç duyar):
 // abi - ABI
 // devdoc - Geliştirici dokümantasyonu (natspec)
 // userdoc - Kullanıcı dokümantasyonu (natspec)
 // metadata - Metadata
 // ir - Optimizasyondan önce kodun Yul ara temsili
 // irOptimized - Optimizasyon sonrası ara temsil
 // storageLayout - Sözleşmenin durum değişkenlerinin yuvaları, ofsetleri ve türleri.
 // evm.assembly - Yeni assembly formatı
 // evm.legacyAssembly - JSON'daki eski tarz assembly formatı
 // evm.bytecode.functionDebugData - Fonksiyon düzeyinde hata ayıklama bilgileri
 // evm.bytecode.object - Bytecode objesi
 // evm.bytecode.opcodes - Opcodes listesi
 // evm.bytecode.sourceMap - Kaynak eşlemesi (hata ayıklama için yararlı)
 // evm.bytecode.linkReferences - Bağlantı referansları (bağlantısı olmayan nesne ise)
 // evm.bytecode.generatedSources - Derleyici tarafından oluşturulan kaynaklar
 // evm.deployedBytecode\* - Deployed bytecode (evm.bytecode'un sahip olduğu tüm seçeneklere sahiptir)
 // evm.deployedBytecode.immutableReferences - AST kimliklerinden değişmezlere referans veren bayt kodu aralıklarına eşleme
 // evm.methodIdentifiers - Fonksiyon hash'lerinin listesi
 // evm.gasEstimates - Fonksiyon gazı tahminleri
 // ewasm.wast - WebAssembly S-expressions biçiminde Ewasm
 // ewasm.wasm - WebAssembly binary formatında Ewasm
 //
 // Bir \`evm\`, \`evm.bytecode\`, \`ewasm\`, vb. kullanmanın bu çıktının her
 // hedef parçasını seçeceğini unutmayın. Ayrıca, \`\*\` her şeyi istemek için joker karakter olarak kullanılabilir.
 //
 "outputSelection": {
 "\*": {
 "\*": \[
 "metadata", "evm.bytecode" // Her bir sözleşmenin metadata ve bytecode çıktılarını etkinleştirin.
 , "evm.bytecode.sourceMap" // Her bir sözleşmenin kaynak eşleme çıktısını etkinleştirin.
 \],
 "": \[
 "ast" // Her bir dosyanın AST çıktısını etkinleştirin.
 \]
 },
 // Def dosyasında tanımlanan MyContract'ın abi ve opcodes çıktısını etkinleştirin.
 "def": {
 "MyContract": \[ "abi", "evm.bytecode.opcodes" \]
 }
 },
 // ModelChecker nesnesi deneyseldir ve değişikliklere tabidir.
 "modelChecker":
 {
 // Hangi sözleşmelerin konuşlandırılmış sözleşme olarak analiz edilmesi gerektiğini seçin.
 "contracts":
 {
 "source1.sol": \["contract1"\],
 "source2.sol": \["contract2", "contract3"\]
 },
 // Bölme ve modulo işlemlerinin nasıl şifreleneceğini seçin.
 // \`false\` kullanıldığında, bunlar slack değişkenlerle çarpılarak
 // değiştirilir. Bu varsayılandır.
 // CHC motorunu kullanıyorsanız ve Horn çözücü olarak Spacer kullanmıyorsanız
 // (örneğin Eldarica kullanıyorsanız) burada \`true\` kullanılması önerilir.
 // Bu seçeneğin daha ayrıntılı bir açıklaması için Biçimsel Doğrulama bölümüne bakın.
 "divModNoSlacks": false,
 // Hangi model denetleyici motorunun kullanılacağını seçin: all (varsayılan), bmc, chc, none.
 "engine": "chc",
 // Kullanıcıya hangi tür değişmezlerin rapor edileceğini seçin: contract, reentrancy.
 "invariants": \["contract", "reentrancy"\],
 // Kanıtlanmamış tüm hedeflerin çıktısının alınıp alınmayacağını seçin. Varsayılan değer \`false\`dir.
 "showUnproved": true,
 // Varsa, hangi çözücülerin kullanılması gerektiğini seçin.
 // Çözücülerin açıklaması için Biçimsel Doğrulama bölümüne bakın.
 "solvers": \["cvc4", "smtlib2", "z3"\],
 // Hangi hedeflerin kontrol edilmesi gerektiğini seçin: constantCondition,
 // underflow, overflow, divByZero, balance, assert, popEmptyArray, outOfBounds.
 // Seçenek belirtilmezse, Solidity >=0.8.7 için underflow/overflow
 // hariç tüm hedefler varsayılan olarak kontrol edilir.
 // Hedeflerin açıklaması için Biçimsel Doğrulama bölümüne bakın.
 "targets": \["underflow", "overflow", "assert"\],
 // Her SMT sorgusu için milisaniye cinsinden zaman aşımı.
 // Bu seçenek verilmezse, SMTChecker varsayılan olarak
 // deterministik bir kaynak sınırı kullanacaktır.
 // Verilen zaman aşımının 0 olması, herhangi bir sorgu için kaynak/zaman kısıtlaması olmadığı anlamına gelir.
 "timeout": 20000
 }
 }
}
### Çıktı Açıklaması[](#cikti-aciklamasi "Permalink to this heading")
{
 // Opsiyonel: herhangi bir hata/uyarı/bilgi ile karşılaşılmadıysa mevcut değildir
 "errors": \[
 {
 // Opsiyonel: Kaynak dosya içindeki konum.
 "sourceLocation": {
 "file": "sourceFile.sol",
 "start": 0,
 "end": 100
 },
 // Opsiyonel: Diğer yerler (örn. çelişkili beyanların olduğu yerler)
 "secondarySourceLocations": \[
 {
 "file": "sourceFile.sol",
 "start": 64,
 "end": 92,
 "message": "Other declaration is here:"
 }
 \],
 // Zorunlu: Hata türü, örneğin "TypeError", "InternalCompilerError", "Exception", vb.
 // Türlerin tam listesi için aşağıya bakınız.
 "type": "TypeError",
 // Zorunlu: Hatanın kaynaklandığı bileşen, örneğin "general", "ewasm", vb.
 "component": "general",
 // Zorunlu (" error", "warning" veya "info", ancak bunun gelecekte genişletilebileceğini lütfen unutmayın)
 "severity": "error",
 // İsteğe bağlı: hatanın nedeni için benzersiz kod
 "errorCode": "3141",
 // Zorunlu
 "message": "Invalid keyword",
 // Opsiyonel: kaynak konumu ile biçimlendirilmiş mesaj
 "formattedMessage": "sourceFile.sol:100: Invalid keyword"
 }
 \],
 // Bu, dosya düzeyinde çıktıları içerir.
 // OutputSelection ayarları ile sınırlandırılabilir/filtrelenebilir.
 "sources": {
 "sourceFile.sol": {
 // Kaynak tanımlayıcısı (kaynak eşlemelerinde kullanılır)
 "id": 1,
 // AST objesi
 "ast": {}
 }
 },
 // Bu, sözleşme düzeyindeki çıktıları içerir.
 // OutputSelection ayarları ile sınırlandırılabilir/filtrelenebilir.
 "contracts": {
 "sourceFile.sol": {
 // Kullanılan dilde sözleşme adı yoksa, bu alan boş bir dizeye eşit olmalıdır.
 "ContractName": {
 // Ethereum Sözleşmesi ABI'si. Boşsa, boş bir dizi olarak gösterilir.
 // bkz. https://docs.soliditylang.org/en/develop/abi-spec.html
 "abi": \[\],
 // Metadata Çıktısı belgelerine bakın (serileştirilmiş JSON stringi)
 "metadata": "{/\* ... \*/}",
 // Kullanıcı dokümantasyonu (natspec)
 "userdoc": {},
 // Geliştirici dokümantasyonu (natspec)
 "devdoc": {},
 // Ara temsil (string)
 "ir": "",
 // Depolama Düzeni belgelerine bakın.
 "storageLayout": {"storage": \[/\* ... \*/\], "types": {/\* ... \*/} },
 // EVM'ye ilişkin çıktılar
 "evm": {
 // Assembly (string)
 "assembly": "",
 // Eski tarz assembly (object)
 "legacyAssembly": {},
 // Bytecode ve ilgili ayrıntılar.
 "bytecode": {
 // Fonksiyonlar düzeyinde veri hata ayıklama.
 "functionDebugData": {
 // Şimdi derleyicinin dahili ve kullanıcı tanımlı fonksiyonlarını içeren bir fonksiyon kümesini takip edin.
 // Kümenin eksiksiz olması gerekmez.
 "@mint\_13": { // Fonksiyonun dahili adı
 "entryPoint": 128, // Fonksiyonun başladığı byte offset bytecode (isteğe bağlı)
 "id": 13, // Fonksiyon tanımının AST ID'si veya derleyiciye dahili fonksiyonlar için null (isteğe bağlı)
 "parameterSlots": 2, // Fonksiyon parametreleri için EVM yığın yuvası sayısı (isteğe bağlı)
 "returnSlots": 1 // Dönüş değerleri için EVM yığın yuvası sayısı (isteğe bağlı)
 }
 },
 // Hex string olarak bytecode.
 "object": "00fe",
 // Opcodes listesi (string)
 "opcodes": "",
 // Bir string olarak kaynak eşlemesi. Kaynak eşleme tanımına bakın.
 "sourceMap": "",
 // Derleyici tarafından oluşturulan kaynakların dizisi. Şu anda yalnızca
 // tek bir Yul dosyası içerir.
 "generatedSources": \[{
 // Yul AST
 "ast": {/\* ... \*/},
 // Metin halindeki kaynak dosya (yorum içerebilir)
 "contents":"{ function abi\_decode(start, end) -> data { data := calldataload(start) } }",
 // Kaynak dosya ID'si, kaynak referansları için kullanılır, Solidity kaynak dosyalarıyla aynı "ad alanı"
 "id": 2,
 "language": "Yul",
 "name": "#utility.yul"
 }\],
 // Verilirse, bu bağlantısız bir nesnedir.
 "linkReferences": {
 "libraryFile.sol": {
 // Baytların bayt kodu içindeki ofsetleri.
 // Bağlantı, burada bulunan 20 baytın yerini alır.
 "Library1": \[
 { "start": 0, "length": 20 },
 { "start": 200, "length": 20 }
 \]
 }
 }
 },
 "deployedBytecode": {
 /\* ..., \*/ // Yukarıdaki ile aynı düzen.
 "immutableReferences": {
 // AST ID 3 ile değişmeze iki referans vardır, her ikisi de 32 bayt uzunluğundadır. Bir tanesi
 // bytecode offset 42'de, diğeri bytecode offset 80'de.
 "3": \[{ "start": 42, "length": 32 }, { "start": 80, "length": 32 }\]
 }
 },
 // Fonksiyon hash'lerinin listesi
 "methodIdentifiers": {
 "delegate(address)": "5c19a95c"
 },
 // Fonksiyon gaz tahminleri
 "gasEstimates": {
 "creation": {
 "codeDepositCost": "420000",
 "executionCost": "infinite",
 "totalCost": "infinite"
 },
 "external": {
 "delegate(address)": "25000"
 },
 "internal": {
 "heavyLifting()": "infinite"
 }
 }
 },
 // Ewasm ile ilgili çıktılar
 "ewasm": {
 // S-expressions biçimi
 "wast": "",
 // Binary formatı (hex string)
 "wasm": ""
 }
 }
 }
 }
}
#### Hata Türleri[](#hata-turleri "Permalink to this heading")
1. `JSONError`: JSON girdisi gerekli biçime uymuyor, örneğin girdi bir JSON nesnesi değil, dil desteklenmiyor vb.
 
2. `IOError`: Çözümlenemeyen URL veya sağlanan kaynaklardaki hash uyuşmazlığı gibi IO ve içe aktarma işleme hataları.
 
3. `ParserError`: Kaynak kodu dil kurallarına uygun değil.
 
4. `DocstringParsingError`: Yorum bloğundaki NatSpec etiketleri ayrıştırılamıyor.
 
5. `SyntaxError`: Sözdizimsel hata, örneğin `continue` bir `for` döngüsünün dışında kullanılmıştır.
 
6. `DeclarationError`: Geçersiz, çözümlenemeyen veya çakışan tanımlayıcı adları. ör. `Identifier not found`
 
7. `TypeError`: Geçersiz tür dönüşümleri, geçersiz atamalar vb. gibi tür sistemi içindeki hatalar.
 
8. `UnimplementedFeatureError`: Özellik derleyici tarafından desteklenmiyor, ancak gelecek sürümlerde desteklenmesi bekleniyor.
 
9. `InternalCompilerError`: Derleyicide tetiklenen dahili hata - bu bir sorun olarak raporlanmalıdır.
 
10. `Exception`: Derleme sırasında bilinmeyen hata - bu bir sorun olarak raporlanmalıdır.
 
11. `CompilerError`: Derleyici yığınının geçersiz kullanımı - bu bir sorun olarak raporlanmalıdır.
 
12. `FatalError`: Ölümcül hata doğru şekilde işlenmedi - bu bir sorun olarak raporlanmalıdır.
 
13. `Warning`: Derlemeyi durdurmayan, ancak mümkünse ele alınması gereken bir uyarı.
 
14. `Info`: Derleyicinin kullanıcının yararlı bulabileceğini düşündüğü, ancak tehlikeli olmayan ve mutlaka ele alınması gerekmeyen bilgiler.
 
## Derleyici Araçları[](#derleyici-araclari "Permalink to this heading")
### solidity-upgrade[](#solidity-upgrade "Permalink to this heading")
`solidity-upgrade` sözleşmelerinizi dil değişikliklerine yarı otomatik olarak yükseltmenize yardımcı olabilir. Her son sürüm için gerekli tüm değişiklikleri uygulamasa ve uygulayamasa da, aksi takdirde çok sayıda tekrarlayan manuel ayarlama gerektirecek olanları hala desteklemektedir.
Not
‘’solidity-upgrade’’ işin büyük bir kısmını gerçekleştirir, ancak sözleşmelerinizin büyük olasılıkla daha fazla manuel ayarlamaya ihtiyacı olacaktır. Dosyalarınız için bir sürüm kontrol sistemi kullanmanızı öneririz. Bu, yapılan değişikliklerin gözden geçirilmesine ve sonunda geri alınmasına yardımcı olur.
Uyarı
`solidity-upgrade` tam veya hatasız olarak kabul edilmez, bu nedenle lütfen dikkatli kullanın.
#### Nasıl Çalışır?[](#nasil-calisir "Permalink to this heading")
Solidity kaynak dosya(lar)ını `solidity-upgrade [files]`’a aktarabilirsiniz. Bunlar, geçerli kaynak dosyanın dizini dışındaki dosyalara referans veren `import` ifadesini kullanıyorsa, `--allow-paths [directory]` seçeneğini geçerek dosyaların okunmasına ve içe aktarılmasına izin verilen dizinleri belirtmeniz gerekir. Eksik dosyaları `--ignore-missing` seçeneğini geçerek yok sayabilirsiniz.
`solidity-upgrade`, `libsolidity` tabanlıdır ve kaynak dosyalarınızı ayrıştırabilir, derleyebilir ve analiz edebilir ve içlerinde uygulanabilir kaynak yükseltmeleri bulabilir.
Kaynak yükseltmeleri, kaynak kodunuzda yapılan küçük metinsel değişiklikler olarak kabul edilir. Bunlar, verilen kaynak dosyaların bellek içi gösterimine uygulanır. İlgili kaynak dosyası varsayılan olarak güncellenir, ancak herhangi bir dosyaya yazmadan tüm yükseltme işlemini simüle etmek için `--dry-run` geçebilirsiniz.
Yükseltme işleminin iki aşaması vardır. İlk aşamada kaynak dosyalar ayrıştırılır ve kaynak kodu bu seviyede yükseltmek mümkün olmadığından, hatalar toplanır ve `--verbose` geçilerek günlüğe kaydedilebilir. Bu noktada kaynak yükseltmesi mevcut değildir.
İkinci aşamada, tüm kaynaklar derlenir ve tüm etkinleştirilmiş yükseltme analizi modülleri derleme ile birlikte çalıştırılır. Varsayılan olarak, mevcut tüm modüller etkinleştirilir. Daha fazla ayrıntı için lütfen [available modules](#upgrade-modules) belgesini okuyun.
Bu, kaynak yükseltmeleri ile düzeltilebilecek derleme hatalarına neden olabilir. Hiçbir hata oluşmazsa, hiçbir kaynak yükseltmesi bildirilmez ve işiniz biter. Hatalar oluşursa ve bazı yükseltme modülleri bir kaynak yükseltmesi bildirirse, ilk bildirilen uygulanır ve verilen tüm kaynak dosyaları için derleme yeniden tetiklenir. Kaynak yükseltmeleri rapor edildiği sürece önceki adım tekrarlanır. Eğer hala hatalar oluşuyorsa, `--verbose` komutunu geçerek bunları günlüğe kaydedebilirsiniz. Herhangi bir hata oluşmazsa, sözleşmeleriniz günceldir ve derleyicinin en son sürümüyle derlenebilir.
#### Kullanılabilir Yükseltme Modülleri[](#kullanilabilir-yukseltme-modulleri "Permalink to this heading")
Modül
Versiyon
Açıklama
`constructor`
0.5.0
Constructor’’lar artık `constructor` anahtar sözcüğü kullanılarak tanımlanmalıdır.
`visibility`
0.5.0
Public fonksiyon görünürlüğü artık zorunlu, varsayılan değer `public`.
`abstract`
0.6.0
Bir sözleşme tüm fonksiyonlarını uygulamıyorsa `abstract` anahtar sözcüğü kullanılmalıdır.
`virtual`
0.6.0
Bir arayüz dışında uygulaması olmayan fonksiyonlar `virtual` olarak işaretlenmelidir.
`override`
0.6.0
Bir fonksiyon veya modifier geçersiz kılınırken, yeni `override` anahtar sözcüğü kullanılmalıdır
`dotsyntax`
0.7.0
Aşağıdaki sözdizimi kullanımdan kaldırılmıştır: `f.gas(...)()`, `f.value(...)()` ve `(new C).value(...)()`. Bu çağrıların yerine `f{gas: ..., value: ...}()` ve `(new C){value: ...}()`.
`now`
0.7.0
`now` anahtar sözcüğü kullanımdan kalktı. Bunun yerine block.timestamp\` kullanın.
`constructor-visibility`
0.7.0
Constructor’ların görünürlüğünü kaldırır.
Daha fazla ayrıntı için lütfen [0.5.0 release notes](https://docs.soliditylang.org/tr/latest/050-breaking-changes.html), [0.6.0 release notes](https://docs.soliditylang.org/tr/latest/060-breaking-changes.html), [0.7.0 release notes](https://docs.soliditylang.org/tr/latest/070-breaking-changes.html) ve [0.8.0 release notes](https://docs.soliditylang.org/tr/latest/080-breaking-changes.html) bölümlerini okuyun.
#### Özet bilgi(Synopsis)[](#ozet-bilgi-synopsis "Permalink to this heading")
Usage: solidity-upgrade \[options\] contract.sol
Allowed options:
 --help Show help message and exit.
 --version Show version and exit.
 --allow-paths path(s)
 Allow a given path for imports. A list of paths can be
 supplied by separating them with a comma.
 --ignore-missing Ignore missing files.
 --modules module(s) Only activate a specific upgrade module. A list of
 modules can be supplied by separating them with a comma.
 --dry-run Apply changes in-memory only and don't write to input
 file.
 --verbose Print logs, errors and changes. Shortens output of
 upgrade patches.
 --unsafe Accept \*unsafe\* changes.
#### Hata Raporları / Özellik Talepleri[](#hata-raporlari-ozellik-talepleri "Permalink to this heading")
Bir hata bulduysanız veya bir özellik isteğiniz varsa, lütfen [Github’da](https://github.com/ethereum/solidity/issues/new/choose) bir sorun gönderin.
#### Örnek[](#ornek "Permalink to this heading")
`Source.sol` içinde aşağıdaki sözleşmeye sahip olduğunuzu varsayın:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=cHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuNi40OwovLyBUaGlzIHdpbGwgbm90IGNvbXBpbGUgYWZ0ZXIgMC43LjAKLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKY29udHJhY3QgQyB7CiAgICAvLyBCRU7EsETDnFpFTFQ6IGNvbnN0cnVjdG9yIGfDtnLDvG7DvHJsw7zEn8O8bsO8IGthbGTEsXLEsW4gdmUgc8O2emxlxZ9tZXlpIGFic3RyYWN0IGhhbGUgZ2V0aXJpbgogICAgY29uc3RydWN0b3IoKSBpbnRlcm5hbCB7fQp9Cgpjb250cmFjdCBEIHsKICAgIHVpbnQgdGltZTsKCiAgICBmdW5jdGlvbiBmKCkgcHVibGljIHBheWFibGUgewogICAgICAgIC8vIEJFTsSwRMOcWkVMVDogbm93J3UgYmxvY2sudGltZXN0YW1wIG9sYXJhayBkZcSfacWfdGlyaW4KICAgICAgICB0aW1lID0gbm93OwogICAgfQp9Cgpjb250cmFjdCBFIHsKICAgIEQgZDsKCiAgICAvLyBCRU7EsETDnFpFTFQ6IGNvbnN0cnVjdG9yIGfDtnLDvG7DvHJsw7zEn8O8bsO8IGthbGTEsXIKICAgIGNvbnN0cnVjdG9yKCkgcHVibGljIHt9CgogICAgZnVuY3Rpb24gZygpIHB1YmxpYyB7CiAgICAgICAgLy8gQkVOxLBEw5xaRUxUOiAudmFsdWUoNSkgPT4ge3ZhbHVlOiA1fSBvbGFyYWsgZGXEn2nFn3RpcmluCiAgICAgICAgZC5mLnZhbHVlKDUpKCk7CiAgICB9Cn0=)
pragma solidity \>=0.6.0 <0.6.4;
// This will not compile after 0.7.0
// SPDX-License-Identifier: GPL-3.0
contract C {
 // BENİDÜZELT: constructor görünürlüğünü kaldırın ve sözleşmeyi abstract hale getirin
 constructor() internal {}
}
contract D {
 uint time;
 function f() public payable {
 // BENİDÜZELT: now'u block.timestamp olarak değiştirin
 time \= now;
 }
}
contract E {
 D d;
 // BENİDÜZELT: constructor görünürlüğünü kaldır
 constructor() public {}
 function g() public {
 // BENİDÜZELT: .value(5) => {value: 5} olarak değiştirin
 d.f.value(5)();
 }
}
##### Gerekli Değişiklikler[](#gerekli-degisiklikler "Permalink to this heading")
Yukarıdaki sözleşme 0.7.0’dan itibaren derlenmeyecektir. Sözleşmeyi mevcut Solidity sürümüyle güncel hale getirmek için aşağıdaki yükseltme modüllerinin çalıştırılması gerekir: `constructor-visibility`, `now` ve `dotsyntax`. Daha fazla ayrıntı için lütfen [available modules](#upgrade-modules) belgelendirmesini okuyun.
##### Yükseltmenin Çalıştırılması[](#yukseltmenin-calistirilmasi "Permalink to this heading")
Yükseltme modüllerinin `--modules` argümanı kullanılarak açıkça belirtilmesi önerilir.
solidity-upgrade \--modules constructor-visibility,now,dotsyntax Source.sol
Yukarıdaki komut aşağıda gösterildiği gibi tüm değişiklikleri uygular. Lütfen bunları dikkatlice inceleyin (pragmaların manuel olarak güncellenmesi gerekecektir).
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwphYnN0cmFjdCBjb250cmFjdCBDIHsKICAgIC8vIEJFTsSwRMOcWkVMVDogY29uc3RydWN0b3IgZ8O2csO8bsO8cmzDvMSfw7xuw7wga2FsZMSxcsSxbiB2ZSBzw7Z6bGXFn21leWkgYWJzdHJhY3QgaGFsZSBnZXRpcmluCiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0KCmNvbnRyYWN0IEQgewogICAgdWludCB0aW1lOwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgLy8gQkVOxLBEw5xaRUxUOiBub3cndSBibG9jay50aW1lc3RhbXAgb2xhcmFrIGRlxJ9pxZ90aXJpbgogICAgICAgIHRpbWUgPSBibG9jay50aW1lc3RhbXA7CiAgICB9Cn0KCmNvbnRyYWN0IEUgewogICAgRCBkOwoKICAgIC8vIEJFTsSwRMOcWkVMVDogY29uc3RydWN0b3IgZ8O2csO8bsO8cmzDvMSfw7xuw7wga2FsZMSxcgogICAgY29uc3RydWN0b3IoKSB7fQoKICAgIGZ1bmN0aW9uIGcoKSBwdWJsaWMgewogICAgICAgIC8vIEZJWE1FOiBjaGFuZ2UgLnZhbHVlKDUpID0+ICB7dmFsdWU6IDV9CiAgICAgICAgZC5me3ZhbHVlOiA1fSgpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
abstract contract C {
 // BENİDÜZELT: constructor görünürlüğünü kaldırın ve sözleşmeyi abstract hale getirin
 constructor() {}
}
contract D {
 uint time;
 function f() public payable {
 // BENİDÜZELT: now'u block.timestamp olarak değiştirin
 time \= block.timestamp;
 }
}
contract E {
 D d;
 // BENİDÜZELT: constructor görünürlüğünü kaldır
 constructor() {}
 function g() public {
 // FIXME: change .value(5) => {value: 5}
 d.f{value: 5}();
 }
}

# [Search — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/search.html) 
 _https://docs.soliditylang.org/en/latest/search.html_

* [](https://docs.soliditylang.org/en/latest/index.html)
* Search
* * *

# [Solidity Marka Kılavuzu — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/brand-guide.html) 
 _https://docs.soliditylang.org/tr/latest/brand-guide.html_

Bu marka rehberi, Solidity’nin marka politikası ve logo kullanım yönergeleri hakkında bilgi içerir.
## Solidity Markası[](#solidity-markasi "Permalink to this heading")
Solidity programlama dili, çekirdek bir ekip tarafından yönetilen açık kaynaklı bir topluluk projesidir. Çekirdek ekip [Ethereum Foundation](https://ethereum.foundation/) tarafından desteklenmektedir.
Bu belge, Solidity marka adı ve logosunun en iyi şekilde nasıl kullanılacağı hakkında bilgi vermeyi amaçlamaktadır.
Marka adını veya logoyu kullanmadan önce bu belgeyi dikkatlice okumanızı öneririz. İşbirliğiniz çok takdir edilmektedir!
## Solidity Marka Adı[](#solidity-marka-adi "Permalink to this heading")
“Solidity” yalnızca Solidity programlama diline atıfta bulunmak için kullanılmalıdır.
Lütfen “Solidity” i aşağıdaki şekillerde kullanmayın:
* Başka herhangi bir programlama diline atıfta bulunmak için.
 
* Yanıltıcı olacak veya ilgisiz modüllerin, araçların, belgelerin veya diğer kaynakların Solidity programlama diliyle ilişkilendirildiğini ima edecek şekilde.
 
* Solidity programlama dilinin açık kaynaklı ve ücretsiz olup olmadığı konusunda topluluğun kafasını karıştıracak şekilde.
 
## Solidity Logo Lisansı[](#solidity-logo-lisansi "Permalink to this heading")
Solidity logosu [Creative Commons Attribution 4.0 International License](https://creativecommons.org/licenses/by/4.0/) altında dağıtılmakta ve lisanslanmaktadır.
Bu, en serbest Creative Commons lisansıdır ve herhangi bir amaç için yeniden kullanıma ve değişikliklere izin verir.
Bunları yapmakta özgürsünüz:
* **Paylaş** - Materyali herhangi bir ortamda veya formatta kopyalayın ve yeniden dağıtın.
 
* **Uyarlamak** - Ticari olarak bile olsa herhangi bir amaçla materyali yeniden karıştırmak, dönüştürmek ve üzerine inşa etmek.
 
Aşağıdaki şartlar altında:
* **Atıf** - Uygun şekilde atıfta bulunmalı, lisansa bir bağlantı vermeli ve değişiklik yapılıp yapılmadığını belirtmelisiniz. Bunu makul herhangi bir şekilde yapabilirsiniz, ancak Solidity çekirdek ekibinin sizi veya kullanımınızı onayladığını gösteren herhangi bir şekilde yapamazsınız.
 
Solidity logosunu kullanırken lütfen Solidity logo yönergelerine uyun.
## Solidity Logo Kılavuzu[](#solidity-logo-kilavuzu "Permalink to this heading")
_(İndirmek için logoya sağ tıklayın.)_
Lütfen şunları yapmayınız:
* Logonun oranını değiştirmek (uzatmayın veya kesmeyin).
 
* Kesinlikle gerekli olmadığı sürece logonun renklerini değiştirmek.
 
## Credits[](#credits "Permalink to this heading")
Bu belge kısmen [Python Yazılım Vakfı Ticari Marka Kullanım Politikası](https://www.python.org/psf/trademarks/) ve [Rust Media Guide](https://www.rust-lang.org/policies/media-guide)’dan türetilmiştir.

# [Miscellaneous — Solidity 0.4.26 documentation](https://docs.soliditylang.org/en/v0.4.26/miscellaneous.html) 
 _https://docs.soliditylang.org/en/v0.4.26/miscellaneous.html_

[Solidity](https://docs.soliditylang.org/en/v0.4.26/index.html)
## Layout of State Variables in Storage[¶](#layout-of-state-variables-in-storage "Permalink to this headline")
Statically-sized variables (everything except mapping and dynamically-sized array types) are laid out contiguously in storage starting from position `0`. Multiple items that need less than 32 bytes are packed into a single storage slot if possible, according to the following rules:
* The first item in a storage slot is stored lower-order aligned.
* Elementary types use only that many bytes that are necessary to store them.
* If an elementary type does not fit the remaining part of a storage slot, it is moved to the next storage slot.
* Structs and array data always start a new slot and occupy whole slots (but items inside a struct or array are packed tightly according to these rules).
Warning
When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.
It is only beneficial to use reduced-size arguments if you are dealing with storage values because the compiler will pack multiple elements into one storage slot, and thus, combine multiple reads or writes into a single operation. When dealing with function arguments or memory values, there is no inherent benefit because the compiler does not pack these values.
Finally, in order to allow the EVM to optimize for this, ensure that you try to order your storage variables and `struct` members such that they can be packed tightly. For example, declaring your storage variables in the order of `uint128, uint128, uint256` instead of `uint128, uint256, uint128`, as the former will only take up two slots of storage whereas the latter will take up three.
The elements of structs and arrays are stored after each other, just as if they were given explicitly.
Due to their unpredictable size, mapping and dynamically-sized array types use a Keccak-256 hash computation to find the starting position of the value or the array data. These starting positions are always full stack slots.
The mapping or the dynamic array itself occupies an (unfilled) slot in storage at some position `p` according to the above rule (or by recursively applying this rule for mappings to mappings or arrays of arrays). For a dynamic array, this slot stores the number of elements in the array (byte arrays and strings are an exception here, see below). For a mapping, the slot is unused (but it is needed so that two equal mappings after each other will use a different hash distribution). Array data is located at `keccak256(p)` and the value corresponding to a mapping key `k` is located at `keccak256(k . p)` where `.` is concatenation. If the value is again a non-elementary type, the positions are found by adding an offset of `keccak256(k . p)`.
`bytes` and `string` store their data in the same slot where also the length is stored if they are short. In particular: If the data is at most `31` bytes long, it is stored in the higher-order bytes (left aligned) and the lowest-order byte stores `length * 2`. If it is longer, the main slot stores `length * 2 + 1` and the data is stored as usual in `keccak256(slot)`.
So for the following contract snippet:
pragma solidity ^0.4.0;
contract C {
 struct s { uint a; uint b; }
 uint x;
 mapping(uint \=> mapping(uint \=> s)) data;
}
The position of `data[4][9].b` is at `keccak256(uint256(9) . keccak256(uint256(4) . uint256(1))) + 1`.
## Layout in Memory[¶](#layout-in-memory "Permalink to this headline")
Solidity reserves four 32 byte slots:
* `0x00` - `0x3f`: scratch space for hashing methods
* `0x40` - `0x5f`: currently allocated memory size (aka. free memory pointer)
* `0x60` - `0x7f`: zero slot
Scratch space can be used between statements (ie. within inline assembly). The zero slot is used as initial value for dynamic memory arrays and should never be written to (the free memory pointer points to `0x80` initially).
Solidity always places new objects at the free memory pointer and memory is never freed (this might change in the future).
Warning
There are some operations in Solidity that need a temporary memory area larger than 64 bytes and therefore will not fit into the scratch space. They will be placed where the free memory points to, but given their short lifecycle, the pointer is not updated. The memory may or may not be zeroed out. Because of this, one shouldn’t expect the free memory to be zeroed out.
## Layout of Call Data[¶](#layout-of-call-data "Permalink to this headline")
When a Solidity contract is deployed and when it is called from an account, the input data is assumed to be in the format in [the ABI specification](https://docs.soliditylang.org/en/v0.4.26/abi-spec.html#abi). The ABI specification requires arguments to be padded to multiples of 32 bytes. The internal function calls use a different convention.
## Internals - Cleaning Up Variables[¶](#internals-cleaning-up-variables "Permalink to this headline")
When a value is shorter than 256-bit, in some cases the remaining bits must be cleaned. The Solidity compiler is designed to clean such remaining bits before any operations that might be adversely affected by the potential garbage in the remaining bits. For example, before writing a value to the memory, the remaining bits need to be cleared because the memory contents can be used for computing hashes or sent as the data of a message call. Similarly, before storing a value in the storage, the remaining bits need to be cleaned because otherwise the garbled value can be observed.
On the other hand, we do not clean the bits if the immediately following operation is not affected. For instance, since any non-zero value is considered `true` by `JUMPI` instruction, we do not clean the boolean values before they are used as the condition for `JUMPI`.
In addition to the design principle above, the Solidity compiler cleans input data when it is loaded onto the stack.
Different types have different rules for cleaning up invalid values:
 
Type
Valid Values
Invalid Values Mean
enum of n members
0 until n - 1
exception
bool
0 or 1
1
signed integers
sign-extended word
currently silently wraps; in the future exceptions will be thrown
unsigned integers
higher bits zeroed
currently silently wraps; in the future exceptions will be thrown
## Internals - The Optimizer[¶](#internals-the-optimizer "Permalink to this headline")
The Solidity optimizer operates on assembly, so it can be and also is used by other languages. It splits the sequence of instructions into basic blocks at `JUMPs` and `JUMPDESTs`. Inside these blocks, the instructions are analysed and every modification to the stack, to memory or storage is recorded as an expression which consists of an instruction and a list of arguments which are essentially pointers to other expressions. The main idea is now to find expressions that are always equal (on every input) and combine them into an expression class. The optimizer first tries to find each new expression in a list of already known expressions. If this does not work, the expression is simplified according to rules like `constant + constant = sum_of_constants` or `X * 1 = X`. Since this is done recursively, we can also apply the latter rule if the second factor is a more complex expression where we know that it will always evaluate to one. Modifications to storage and memory locations have to erase knowledge about storage and memory locations which are not known to be different: If we first write to location x and then to location y and both are input variables, the second could overwrite the first, so we actually do not know what is stored at x after we wrote to y. On the other hand, if a simplification of the expression x - y evaluates to a non-zero constant, we know that we can keep our knowledge about what is stored at x.
At the end of this process, we know which expressions have to be on the stack in the end and have a list of modifications to memory and storage. This information is stored together with the basic blocks and is used to link them. Furthermore, knowledge about the stack, storage and memory configuration is forwarded to the next block(s). If we know the targets of all `JUMP` and `JUMPI` instructions, we can build a complete control flow graph of the program. If there is only one target we do not know (this can happen as in principle, jump targets can be computed from inputs), we have to erase all knowledge about the input state of a block as it can be the target of the unknown `JUMP`. If a `JUMPI` is found whose condition evaluates to a constant, it is transformed to an unconditional jump.
As the last step, the code in each block is completely re-generated. A dependency graph is created from the expressions on the stack at the end of the block and every operation that is not part of this graph is essentially dropped. Now code is generated that applies the modifications to memory and storage in the order they were made in the original code (dropping modifications which were found not to be needed) and finally, generates all values that are required to be on the stack in the correct place.
These steps are applied to each basic block and the newly generated code is used as replacement if it is smaller. If a basic block is split at a `JUMPI` and during the analysis, the condition evaluates to a constant, the `JUMPI` is replaced depending on the value of the constant, and thus code like
var x \= 7;
data\[7\] \= 9;
if (data\[x\] != x + 2)
 return 2;
else
 return 1;
is simplified to code which can also be compiled from
even though the instructions contained a jump in the beginning.
## Source Mappings[¶](#source-mappings "Permalink to this headline")
As part of the AST output, the compiler provides the range of the source code that is represented by the respective node in the AST. This can be used for various purposes ranging from static analysis tools that report errors based on the AST and debugging tools that highlight local variables and their uses.
Furthermore, the compiler can also generate a mapping from the bytecode to the range in the source code that generated the instruction. This is again important for static analysis tools that operate on bytecode level and for displaying the current position in the source code inside a debugger or for breakpoint handling.
Both kinds of source mappings use integer indentifiers to refer to source files. These are regular array indices into a list of source files usually called `"sourceList"`, which is part of the combined-json and the output of the json / npm compiler.
Note
In the case of instructions that are not associated with any particular source file, the source mapping assigns an integer identifier of `-1`. This may happen for bytecode sections stemming from compiler-generated inline assembly statements.
The source mappings inside the AST use the following notation:
`s:l:f`
Where `s` is the byte-offset to the start of the range in the source file, `l` is the length of the source range in bytes and `f` is the source index mentioned above.
The encoding in the source mapping for the bytecode is more complicated: It is a list of `s:l:f:j` separated by `;`. Each of these elements corresponds to an instruction, i.e. you cannot use the byte offset but have to use the instruction offset (push instructions are longer than a single byte). The fields `s`, `l` and `f` are as above and `j` can be either `i`, `o` or `-` signifying whether a jump instruction goes into a function, returns from a function or is a regular jump as part of e.g. a loop.
In order to compress these source mappings especially for bytecode, the following rules are used:
> * If a field is empty, the value of the preceding element is used.
> * If a `:` is missing, all following fields are considered empty.
This means the following source mappings represent the same information:
`1:2:1;1:9:1;2:1:2;2:1:2;2:1:2`
`1:2:1;:9;2:1:2;;`
## Tips and Tricks[¶](#tips-and-tricks "Permalink to this headline")
* Use `delete` on arrays to delete all its elements.
* Use shorter types for struct elements and sort them such that short types are grouped together. This can lower the gas costs as multiple `SSTORE` operations might be combined into a single (`SSTORE` costs 5000 or 20000 gas, so this is what you want to optimise). Use the gas price estimator (with optimiser enabled) to check!
* Make your state variables public - the compiler will create [getters](https://docs.soliditylang.org/en/v0.4.26/contracts.html#visibility-and-getters) for you automatically.
* If you end up checking conditions on input or state a lot at the beginning of your functions, try using [Function Modifiers](https://docs.soliditylang.org/en/v0.4.26/contracts.html#modifiers).
* If your contract has a function called `send` but you want to use the built-in send-function, use `address(contractVariable).send(amount)`.
* Initialize storage structs with a single assignment: `x = MyStruct({a: 1, b: 2});`
Note
If the storage struct has tightly packed properties, initialize it with separate assignments: `x.a = 1; x.b = 2;`. In this way it will be easier for the optimizer to update storage in one go, thus making assignment cheaper.
## Cheatsheet[¶](#cheatsheet "Permalink to this headline")
### Order of Precedence of Operators[¶](#order-of-precedence-of-operators "Permalink to this headline")
The following is the order of precedence for operators, listed in order of evaluation.
 
Precedence
Description
Operator
_1_
Postfix increment and decrement
`++`, `--`
New expression
`new <typename>`
Array subscripting
`<array>[<index>]`
Member access
`<object>.<member>`
Function-like call
`<func>(<args...>)`
Parentheses
`(<statement>)`
_2_
Prefix increment and decrement
`++`, `--`
Unary plus and minus
`+`, `-`
Unary operations
`delete`
Logical NOT
`!`
Bitwise NOT
`~`
_3_
Exponentiation
`**`
_4_
Multiplication, division and modulo
`*`, `/`, `%`
_5_
Addition and subtraction
`+`, `-`
_6_
Bitwise shift operators
`<<`, `>>`
_7_
Bitwise AND
`&`
_8_
Bitwise XOR
`^`
_9_
Bitwise OR
`|`
_10_
Inequality operators
`<`, `>`, `<=`, `>=`
_11_
Equality operators
`==`, `!=`
_12_
Logical AND
`&&`
_13_
Logical OR
`||`
_14_
Ternary operator
`<conditional> ? <if-true> : <if-false>`
_15_
Assignment operators
`=`, `|=`, `^=`, `&=`, `<<=`, `>>=`, `+=`, `-=`, `*=`, `/=`, `%=`
_16_
Comma operator
`,`
### Global Variables[¶](#global-variables "Permalink to this headline")
* `abi.encode(...) returns (bytes)`: [ABI](https://docs.soliditylang.org/en/v0.4.26/abi-spec.html#abi)\-encodes the given arguments
* `abi.encodePacked(...) returns (bytes)`: Performes [packed encoding](https://docs.soliditylang.org/en/v0.4.26/abi-spec.html#abi-packed-mode) of the given arguments
* `abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)`: [ABI](https://docs.soliditylang.org/en/v0.4.26/abi-spec.html#abi)\-encodes the given arguments
 
 starting from the second and prepends the given four-byte selector
 
* `abi.encodeWithSignature(string signature, ...) returns (bytes)`: Equivalent to `` abi.encodeWithSelector(bytes4(keccak256(signature), ...)` ``
* `block.blockhash(uint blockNumber) returns (bytes32)`: hash of the given block - only works for 256 most recent, excluding current, blocks - deprecated in version 0.4.22 and replaced by `blockhash(uint blockNumber)`.
* `block.coinbase` (`address`): current block miner’s address
* `block.difficulty` (`uint`): current block difficulty
* `block.gaslimit` (`uint`): current block gaslimit
* `block.number` (`uint`): current block number
* `block.timestamp` (`uint`): current block timestamp
* `gasleft() returns (uint256)`: remaining gas
* `msg.data` (`bytes`): complete calldata
* `msg.gas` (`uint`): remaining gas - deprecated in version 0.4.21 and to be replaced by `gasleft()`
* `msg.sender` (`address`): sender of the message (current call)
* `msg.value` (`uint`): number of wei sent with the message
* `now` (`uint`): current block timestamp (alias for `block.timestamp`)
* `tx.gasprice` (`uint`): gas price of the transaction
* `tx.origin` (`address`): sender of the transaction (full call chain)
* `assert(bool condition)`: abort execution and revert state changes if condition is `false` (use for internal error)
* `require(bool condition)`: abort execution and revert state changes if condition is `false` (use for malformed input or error in external component)
* `require(bool condition, string message)`: abort execution and revert state changes if condition is `false` (use for malformed input or error in external component). Also provide error message.
* `revert()`: abort execution and revert state changes
* `revert(string message)`: abort execution and revert state changes providing an explanatory string
* `blockhash(uint blockNumber) returns (bytes32)`: hash of the given block - only works for 256 most recent blocks
* `keccak256(...) returns (bytes32)`: compute the Ethereum-SHA-3 (Keccak-256) hash of the [(tightly packed) arguments](https://docs.soliditylang.org/en/v0.4.26/abi-spec.html#abi-packed-mode)
* `sha3(...) returns (bytes32)`: an alias to `keccak256`
* `sha256(...) returns (bytes32)`: compute the SHA-256 hash of the [(tightly packed) arguments](https://docs.soliditylang.org/en/v0.4.26/abi-spec.html#abi-packed-mode)
* `ripemd160(...) returns (bytes20)`: compute the RIPEMD-160 hash of the [(tightly packed) arguments](https://docs.soliditylang.org/en/v0.4.26/abi-spec.html#abi-packed-mode)
* `ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)`: recover address associated with the public key from elliptic curve signature, return zero on error
* `addmod(uint x, uint y, uint k) returns (uint)`: compute `(x + y) % k` where the addition is performed with arbitrary precision and does not wrap around at `2**256`. Assert that `k != 0` starting from version 0.5.0.
* `mulmod(uint x, uint y, uint k) returns (uint)`: compute `(x * y) % k` where the multiplication is performed with arbitrary precision and does not wrap around at `2**256`. Assert that `k != 0` starting from version 0.5.0.
* `this` (current contract’s type): the current contract, explicitly convertible to `address`
* `super`: the contract one level higher in the inheritance hierarchy
* `selfdestruct(address recipient)`: destroy the current contract, sending its funds to the given address
* `suicide(address recipient)`: a deprecated alias to `selfdestruct`
* `<address>.balance` (`uint256`): balance of the [Address](https://docs.soliditylang.org/en/v0.4.26/types.html#address) in Wei
* `<address>.send(uint256 amount) returns (bool)`: send given amount of Wei to [Address](https://docs.soliditylang.org/en/v0.4.26/types.html#address), returns `false` on failure
* `<address>.transfer(uint256 amount)`: send given amount of Wei to [Address](https://docs.soliditylang.org/en/v0.4.26/types.html#address), throws on failure
Note
Do not rely on `block.timestamp`, `now` and `blockhash` as a source of randomness, unless you know what you are doing.
Both the timestamp and the block hash can be influenced by miners to some degree. Bad actors in the mining community can for example run a casino payout function on a chosen hash and just retry a different hash if they did not receive any money.
The current block timestamp must be strictly larger than the timestamp of the last block, but the only guarantee is that it will be somewhere between the timestamps of two consecutive blocks in the canonical chain.
Note
The block hashes are not available for all blocks for scalability reasons. You can only access the hashes of the most recent 256 blocks, all other values will be zero.
### Function Visibility Specifiers[¶](#function-visibility-specifiers "Permalink to this headline")
function myFunction() <visibility specifier\> returns (bool) {
 return true;
}
* `public`: visible externally and internally (creates a [getter function](https://docs.soliditylang.org/en/v0.4.26/contracts.html#getter-functions) for storage/state variables)
* `private`: only visible in the current contract
* `external`: only visible externally (only for functions) - i.e. can only be message-called (via `this.func`)
* `internal`: only visible internally
### Modifiers[¶](#modifiers "Permalink to this headline")
* `pure` for functions: Disallows modification or access of state - this is not enforced yet.
* `view` for functions: Disallows modification of state - this is not enforced yet.
* `payable` for functions: Allows them to receive Ether together with a call.
* `constant` for state variables: Disallows assignment (except initialisation), does not occupy storage slot.
* `constant` for functions: Same as `view`.
* `anonymous` for events: Does not store event signature as topic.
* `indexed` for event parameters: Stores the parameter as topic.
### Reserved Keywords[¶](#reserved-keywords "Permalink to this headline")
These keywords are reserved in Solidity. They might become part of the syntax in the future:
`abstract`, `after`, `case`, `catch`, `default`, `final`, `in`, `inline`, `let`, `match`, `null`, `of`, `relocatable`, `static`, `switch`, `try`, `type`, `typeof`.
### Language Grammar[¶](#language-grammar "Permalink to this headline")
SourceUnit = (PragmaDirective | ImportDirective | ContractDefinition)\*
// Pragma actually parses anything up to the trailing ';' to be fully forward-compatible.
PragmaDirective = 'pragma' Identifier (\[^;\]+) ';'
ImportDirective = 'import' StringLiteral ('as' Identifier)? ';'
 | 'import' ('\*' | Identifier) ('as' Identifier)? 'from' StringLiteral ';'
 | 'import' '{' Identifier ('as' Identifier)? ( ',' Identifier ('as' Identifier)? )\* '}' 'from' StringLiteral ';'
ContractDefinition = ( 'contract' | 'library' | 'interface' ) Identifier
 ( 'is' InheritanceSpecifier (',' InheritanceSpecifier )\* )?
 '{' ContractPart\* '}'
ContractPart = StateVariableDeclaration | UsingForDeclaration
 | StructDefinition | ModifierDefinition | FunctionDefinition | EventDefinition | EnumDefinition
InheritanceSpecifier = UserDefinedTypeName ( '(' Expression ( ',' Expression )\* ')' )?
StateVariableDeclaration = TypeName ( 'public' | 'internal' | 'private' | 'constant' )\* Identifier ('=' Expression)? ';'
UsingForDeclaration = 'using' Identifier 'for' ('\*' | TypeName) ';'
StructDefinition = 'struct' Identifier '{'
 ( VariableDeclaration ';' (VariableDeclaration ';')\* ) '}'
ModifierDefinition = 'modifier' Identifier ParameterList? Block
ModifierInvocation = Identifier ( '(' ExpressionList? ')' )?
FunctionDefinition = 'function' Identifier? ParameterList
 ( ModifierInvocation | StateMutability | 'external' | 'public' | 'internal' | 'private' )\*
 ( 'returns' ParameterList )? ( ';' | Block )
EventDefinition = 'event' Identifier EventParameterList 'anonymous'? ';'
EnumValue = Identifier
EnumDefinition = 'enum' Identifier '{' EnumValue? (',' EnumValue)\* '}'
ParameterList = '(' ( Parameter (',' Parameter)\* )? ')'
Parameter = TypeName StorageLocation? Identifier?
EventParameterList = '(' ( EventParameter (',' EventParameter )\* )? ')'
EventParameter = TypeName 'indexed'? Identifier?
FunctionTypeParameterList = '(' ( FunctionTypeParameter (',' FunctionTypeParameter )\* )? ')'
FunctionTypeParameter = TypeName StorageLocation?
// semantic restriction: mappings and structs (recursively) containing mappings
// are not allowed in argument lists
VariableDeclaration = TypeName StorageLocation? Identifier
TypeName = ElementaryTypeName
 | UserDefinedTypeName
 | Mapping
 | ArrayTypeName
 | FunctionTypeName
UserDefinedTypeName = Identifier ( '.' Identifier )\*
Mapping = 'mapping' '(' ElementaryTypeName '=>' TypeName ')'
ArrayTypeName = TypeName '\[' Expression? '\]'
FunctionTypeName = 'function' FunctionTypeParameterList ( 'internal' | 'external' | StateMutability )\*
 ( 'returns' FunctionTypeParameterList )?
StorageLocation = 'memory' | 'storage'
StateMutability = 'pure' | 'constant' | 'view' | 'payable'
Block = '{' Statement\* '}'
Statement = IfStatement | WhileStatement | ForStatement | Block | InlineAssemblyStatement |
 ( DoWhileStatement | PlaceholderStatement | Continue | Break | Return |
 Throw | EmitStatement | SimpleStatement ) ';'
ExpressionStatement = Expression
IfStatement = 'if' '(' Expression ')' Statement ( 'else' Statement )?
WhileStatement = 'while' '(' Expression ')' Statement
PlaceholderStatement = '\_'
SimpleStatement = VariableDefinition | ExpressionStatement
ForStatement = 'for' '(' (SimpleStatement)? ';' (Expression)? ';' (ExpressionStatement)? ')' Statement
InlineAssemblyStatement = 'assembly' StringLiteral? InlineAssemblyBlock
DoWhileStatement = 'do' Statement 'while' '(' Expression ')'
Continue = 'continue'
Break = 'break'
Return = 'return' Expression?
Throw = 'throw'
EmitStatement = 'emit' FunctionCall
VariableDefinition = ('var' IdentifierList | VariableDeclaration | '(' VariableDeclaration? (',' VariableDeclaration? )\* ')' ) ( '=' Expression )?
IdentifierList = '(' ( Identifier? ',' )\* Identifier? ')'
// Precedence by order (see github.com/ethereum/solidity/pull/732)
Expression
 = Expression ('++' | '--')
 | NewExpression
 | IndexAccess
 | MemberAccess
 | FunctionCall
 | '(' Expression ')'
 | ('!' | '~' | 'delete' | '++' | '--' | '+' | '-') Expression
 | Expression '\*\*' Expression
 | Expression ('\*' | '/' | '%') Expression
 | Expression ('+' | '-') Expression
 | Expression ('<<' | '>>') Expression
 | Expression '&' Expression
 | Expression '^' Expression
 | Expression '|' Expression
 | Expression ('<' | '>' | '<=' | '>=') Expression
 | Expression ('==' | '!=') Expression
 | Expression '&&' Expression
 | Expression '||' Expression
 | Expression '?' Expression ':' Expression
 | Expression ('=' | '|=' | '^=' | '&=' | '<<=' | '>>=' | '+=' | '-=' | '\*=' | '/=' | '%=') Expression
 | PrimaryExpression
PrimaryExpression = BooleanLiteral
 | NumberLiteral
 | HexLiteral
 | StringLiteral
 | TupleExpression
 | Identifier
 | ElementaryTypeNameExpression
ExpressionList = Expression ( ',' Expression )\*
NameValueList = Identifier ':' Expression ( ',' Identifier ':' Expression )\*
FunctionCall = Expression '(' FunctionCallArguments ')'
FunctionCallArguments = '{' NameValueList? '}'
 | ExpressionList?
NewExpression = 'new' TypeName
MemberAccess = Expression '.' Identifier
IndexAccess = Expression '\[' Expression? '\]'
BooleanLiteral = 'true' | 'false'
NumberLiteral = ( HexNumber | DecimalNumber ) (' ' NumberUnit)?
NumberUnit = 'wei' | 'szabo' | 'finney' | 'ether'
 | 'seconds' | 'minutes' | 'hours' | 'days' | 'weeks' | 'years'
HexLiteral = 'hex' ('"' (\[0-9a-fA-F\]{2})\* '"' | '\\'' (\[0-9a-fA-F\]{2})\* '\\'')
StringLiteral = '"' (\[^"\\r\\n\\\\\] | '\\\\' .)\* '"'
Identifier = \[a-zA-Z\_$\] \[a-zA-Z\_$0-9\]\*
HexNumber = '0x' \[0-9a-fA-F\]+
DecimalNumber = \[0-9\]+ ( '.' \[0-9\]\* )? ( \[eE\] \[0-9\]+ )?
TupleExpression = '(' ( Expression? ( ',' Expression? )\* )? ')'
 | '\[' ( Expression ( ',' Expression )\* )? '\]'
ElementaryTypeNameExpression = ElementaryTypeName
ElementaryTypeName = 'address' | 'bool' | 'string' | 'var'
 | Int | Uint | Byte | Fixed | Ufixed
Int = 'int' | 'int8' | 'int16' | 'int24' | 'int32' | 'int40' | 'int48' | 'int56' | 'int64' | 'int72' | 'int80' | 'int88' | 'int96' | 'int104' | 'int112' | 'int120' | 'int128' | 'int136' | 'int144' | 'int152' | 'int160' | 'int168' | 'int176' | 'int184' | 'int192' | 'int200' | 'int208' | 'int216' | 'int224' | 'int232' | 'int240' | 'int248' | 'int256'
Uint = 'uint' | 'uint8' | 'uint16' | 'uint24' | 'uint32' | 'uint40' | 'uint48' | 'uint56' | 'uint64' | 'uint72' | 'uint80' | 'uint88' | 'uint96' | 'uint104' | 'uint112' | 'uint120' | 'uint128' | 'uint136' | 'uint144' | 'uint152' | 'uint160' | 'uint168' | 'uint176' | 'uint184' | 'uint192' | 'uint200' | 'uint208' | 'uint216' | 'uint224' | 'uint232' | 'uint240' | 'uint248' | 'uint256'
Byte = 'byte' | 'bytes' | 'bytes1' | 'bytes2' | 'bytes3' | 'bytes4' | 'bytes5' | 'bytes6' | 'bytes7' | 'bytes8' | 'bytes9' | 'bytes10' | 'bytes11' | 'bytes12' | 'bytes13' | 'bytes14' | 'bytes15' | 'bytes16' | 'bytes17' | 'bytes18' | 'bytes19' | 'bytes20' | 'bytes21' | 'bytes22' | 'bytes23' | 'bytes24' | 'bytes25' | 'bytes26' | 'bytes27' | 'bytes28' | 'bytes29' | 'bytes30' | 'bytes31' | 'bytes32'
Fixed = 'fixed' | ( 'fixed' \[0-9\]+ 'x' \[0-9\]+ )
Ufixed = 'ufixed' | ( 'ufixed' \[0-9\]+ 'x' \[0-9\]+ )
InlineAssemblyBlock = '{' AssemblyItem\* '}'
AssemblyItem = Identifier | FunctionalAssemblyExpression | InlineAssemblyBlock | AssemblyLocalBinding | AssemblyAssignment | AssemblyLabel | NumberLiteral | StringLiteral | HexLiteral
AssemblyLocalBinding = 'let' Identifier ':=' FunctionalAssemblyExpression
AssemblyAssignment = ( Identifier ':=' FunctionalAssemblyExpression ) | ( '=:' Identifier )
AssemblyLabel = Identifier ':'
FunctionalAssemblyExpression = Identifier '(' AssemblyItem? ( ',' AssemblyItem )\* ')'

# [类型 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/types.html) 
 _https://docs.soliditylang.org/zh-cn/latest/types.html_

## 类型[](#types "此标题的永久链接")
Solidity 是一种静态类型语言，这意味着每个变量（状态变量和局部变量）都需要被指定类型。 Solidity 提供了几种基本类型，可以用来组合出复杂类型。
除此之外，各个类型之间可以在包含运算符号的表达式中进行交互。 关于各种运算符的快速参考，可以参考 [运算符的优先顺序](#order)。
Solidity中不存在“未定义”或“空”值的概念， 但新声明的变量总是有一个取决于其类型的 [默认值](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#default-value)。 为了处理任何意外的值，您应该使用 [revert 函数](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require) 来恢复整个事务， 或者返回一个带有第二个 `bool` 值的元组来表示成功。
## 值类型[](#value-types "此标题的永久链接")
以下类型之所以被称为值类型，是因为它们的变量总是通过值传递， 即在用作函数参数或赋值时总是被复制。
### 布尔类型[](#index-2 "此标题的永久链接")
`bool` ：可能的取值为常数值 `true` 和 `false`。
运算符：
* `!` (逻辑非)
 
* `&&` (逻辑与, “and”)
 
* `||` (逻辑或, “or”)
 
* `==` (等于)
 
* `!=` (不等于)
 
运算符 `||` 和 `&&` 都遵循同样的短路（ short-circuiting ）规则。 就是说在表达式 `f(x) || g(y)` 中， 如果 `f(x)` 的值为 `true` ， 那么 `g(y)` 就不会被执行，即使会出现一些副作用。
### 整型[](#integers "此标题的永久链接")
`int` / `uint`: 分别表示有符号和无符号的不同位数的整型变量。 关键字 `uint8` 到 `uint256` （无符号整型，从 8 位到 256 位）以及 `int8` 到 `int256`， 以 8 位为步长递增。 `uint` 和 `int` 分别是 `uint256` 和 `int256` 的别名。
运算符：
* 比较运算符： `<=`， `<`， `==`， `!=`， `>=`， `>` （返回布尔值）
 
* 位运算符： `&`， `|`， `^` (异或)， `~` (位取反)
 
* 移位运算符： `<<` （左移）， `>>` （右移）
 
* 算数运算符： `+`， `-`， 一元运算 `-` （只适用于有符号的整数）， `*`， `/`， `%` (取余)， `**` (幂)
 
对于一个整数类型 `X`，您可以使用 `type(X).min` 和 `type(X).max` 来访问该类型代表的最小值和最大值。
警告
Solidity 中的整数被限制在一个特定的范围内。例如，对于 `uint32`，这是 `0` 到 `2**32 - 1`。 有两种模式在这些类型上进行算术。“包装” 或 “不检查” 模式和 “检查” 模式。 默认情况下，算术总是 “检查” 模式的，这意味着如果一个操作的结果超出了该类型的值范围， 调用将通过一个 [失败的断言](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require) 而被恢复。 您可以用 `unchecked { ... }` 来转换到“未检查”模式。 更多的细节可以在关于 [未检查](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#unchecked) 的章节中找到。
#### 比较运算[](#id5 "此标题的永久链接")
比较的值是通过比较整数值得到的值。
#### 位运算[](#id6 "此标题的永久链接")
位操作是在数字的二进制补码表示上进行的。 这意味着，例如 `~int256(0) == int256(-1)`。
#### 移位运算[](#id7 "此标题的永久链接")
移位操作的结果具有左操作数的类型，将结果截断以符合类型。 右操作数必须是无符号类型，试图对有符号类型进行移位会产生一个编译错误。
移位可以通过以下方式用2的幂的乘法来 “模拟”。 请注意，对左边操作数类型的截断总是在最后进行，但没有明确提及。
* `x << y` 等同于数学表达式 `x * 2**y`。
 
* `x >> y` 等同于数学表达式 `x / 2**y`，向负无穷远的方向取整。
 
警告
在 `0.5.0` 版本之前，负数 `x` 的右移 `x >> y` 相当于数学表达式 `x / 2**y` 向零舍入， 即右移使用向上舍入（向零舍入）而不是向下舍入（向负无穷大）。
备注
就像对算术操作那样，对移位操作从不进行溢出检查。相反，结果总是被截断的。
#### 加法、减法和乘法[](#id8 "此标题的永久链接")
加法、减法和乘法具有通常的语义，在上溢和下溢方面有两种不同的模式：
默认情况下，所有的算术都会被检查是否有下溢或上溢，但这可以用 [不检查限制](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#unchecked) 来禁用。 这会导致包装的算术。更多细节可以在那一节中找到。
表达式 `-x` 等同于 `(T(0) - x)`，其中 `T` 是 `x` 的类型。它只能用于有符号的类型。 如果 `x` 是负的， `-x` 的值就是正的。 还有一个注意事项也是由二进制补码表示产生的：
如果您有（这样的表达式） `int x = type(int).min;`，那么 `-x` 就不符合正数范围。 这意味着 `unchecked { assert(-x == x); }` 可以工作， 而表达式 `-x` 在检查模式下使用时将导致断言失败。
#### 除法[](#id9 "此标题的永久链接")
由于运算结果的类型总是操作数之一的类型，整数除法的结果总是一个整数。 在 Solidity 中，除法是向零进位的。这意味着 `int256(-5) / int256(2) == int256(-2)`。
请注意，与此相反，在 [字面上](#rational-literals) 的除法会产生任意精度的分数值。
备注
除以0会导致 [异常](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require)。这个检查 **不能** 通过 `unchecked { ... }` 禁用。
备注
表达式 `type(int).min / (-1)` 是除法导致溢出的唯一情况。 在检查算术模式下，这将导致一个失败的断言， 而在包装模式下，值将是 `type(int).min`。
#### 取余[](#id10 "此标题的永久链接")
模数运算 `a % n` 是操作数 `a` 除以操作数 `n` 后产生余数 `r`， 其中 `q = int(a / n)` 和 `r = a - (n * q)`。 这意味着模数运算结果与它的左边操作数（或零）拥有相同的符号， `a % n == -(-a % n)` 对负的 `a` 来说成立。
* `int256(5) % int256(2) == int256(1)`
 
* `int256(5) % int256(-2) == int256(1)`
 
* `int256(-5) % int256(2) == int256(-1)`
 
* `int256(-5) % int256(-2) == int256(-1)`
 
备注
对0取余会导致 [异常](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require)。这个检查 **不能** 通过 `unchecked { ... }` 禁用。
#### 幂运算[](#id11 "此标题的永久链接")
幂运算只适用于指数中的无符号类型。幂运算的结果类型总是等于基数的类型。 请注意，它足够大以容纳结果，并为潜在的断言失败或包装行为做好准备。
备注
在检查模式下，幂运算只对小基数使用相对便宜的 `exp` 操作码。 对于 `x**3` 的情况，表达式 `x*x*x` 可能更便宜。 在任何情况下，燃料成本测试和使用优化器都是可取的。
### 定长浮点型[](#index-4 "此标题的永久链接")
警告
Solidity 还没有完全支持定长浮点型。可以声明定长浮点型的变量， 但不能给它们赋值或把它们赋值给其他变量。
`fixed` / `ufixed`：表示各种大小的有符号和无符号的定长浮点型。 在关键字 `ufixedMxN` 和 `fixedMxN` 中， `M` 表示该类型占用的位数， `N` 表示可用的小数位数。 `M` 必须能整除 8，即 8 到 256 位。 `N` 则可以是从 0 到 80 之间的任意数。 `ufixed` 和 `fixed` 分别是 `ufixed128x18` 和 `fixed128x18` 的别名。
运算符：
* 比较运算符： `<=`， `<`， `==`， `!=`， `>=`， `>` （返回值是布尔型）
 
* 算术运算符： `+`， `-`， 一元运算 `-`， `*`， `/`， `%` (取余数)
 
备注
浮点型（在许多语言中的 `float` 和 `double` ，更准确地说是 IEEE 754 类型）和定长浮点型之间最大的不同点是， 在前者中整数部分和小数部分（小数点后的部分）需要的位数是灵活可变的，而后者中这两部分的长度受到严格的规定。 一般来说，在浮点型中，几乎整个空间都用来表示数字，但只有少数的位来表示小数点的位置。
### 地址类型[](#address "此标题的永久链接")
地址类型有两种大致相同的类型：
* `address`: 保存一个20字节的值（一个以太坊地址的大小）。
 
* `address payable`: 与 `address` 类型相同，但有额外的方法 `transfer` 和 `send`。
 
这种区别背后的想法是， `address payable` 是一个您可以发送以太币的地址， 而您不应该发送以太币给一个普通的 `address`，例如，因为它可能是一个智能合约， 而这个合约不是为接受以太币而建立的。
类型转换：
允许从 `address payable` 到 `address` 的隐式转换， 而从 `address` 到 `address payable` 的转换必须通过 `payable(<address>)` 来明确。
对于 `uint160`、整数、 `bytes20` 和合约类型，允许对 `address` 进行明确的转换和输出。
只有 `address` 类型和合约类型的表达式可以通过 `payable(...)` 显式转换为 `address payable` 类型。 对于合约类型，只有在合约可以接收以太的情况下才允许这种转换，也就是说， 合约要么有一个 [receive](https://docs.soliditylang.org/zh-cn/latest/contracts.html#receive-ether-function) 函数，要么有一个 payable 类型的 fallback 的函数。 请注意， `payable(0)` 是有效的，是这个规则的例外。
备注
如果您需要一个 `address` 类型的变量，并计划向其发送以太，那么就将其类型声明为 `address payable`， 以使这一要求可行。另外，尽量尽早地进行这种区分或转换。
`address` 和 `address payable` 之间的区别是从 0.5.0 版本开始的。 同样从该版本开始，合约不能隐式地转换为 `address` 类型，但仍然可以显式地转换为 `address` 或 `address payable`，如果它们有一个 receive 或 payable 类型的 fallback 函数的话。
运算符：
* `<=`, `<`, `==`, `!=`, `>=` 和 `>`
 
警告
如果您使用较大字节的类型转换为 `address`，例如 `bytes32`，那么 `address` 就被截断了。 为了减少转换的模糊性，从 0.4.24 版本开始，编译器将强迫您在转换中明确地进行截断处理。以32字节的值 `0x111122333344556677888899AAAABBBBCCCCDDDDEEFFFFCCCC` 为例。
您可以使用 `address(uint160(bytes20(b)))`，结果是 `0x111122223333444455556666777788889999aAaa`， 或者您可以使用 `address(uint160(uint256(b)))`，结果是 `0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc`。
备注
符合 [EIP-55](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md) 的混合大小写十六进制数字会自动被视为 `address` 类型的字面数字。参见 [地址字面类型](#address-literals)。
#### 地址类型成员变量[](#members-of-addresses "此标题的永久链接")
快速参考，请见 [地址类型的成员](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#address-related)。
* `balance` 和 `transfer`
 
可以使用 `balance` 属性来查询一个地址的以太币余额， 也可以使用 `transfer` 函数向一个地址发送以太币（以 wei 为单位）：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=YWRkcmVzcyBwYXlhYmxlIHggPSBwYXlhYmxlKDB4MTIzKTsKYWRkcmVzcyBteUFkZHJlc3MgPSBhZGRyZXNzKHRoaXMpOwppZiAoeC5iYWxhbmNlIDwgMTAgJiYgbXlBZGRyZXNzLmJhbGFuY2UgPj0gMTApIHgudHJhbnNmZXIoMTApOw==)
address payable x \= payable(0x123);
address myAddress \= address(this);
if (x.balance < 10 && myAddress.balance \>= 10) x.transfer(10);
如果当前合约的余额不足，或者以太币转账被接收账户拒收，那么 `transfer` 功能就会失败。 `transfer` 功能在失败后会被还原。
备注
如果 `x` 是一个合约地址，它的代码（更具体地说：它的 [接收以太的函数](https://docs.soliditylang.org/zh-cn/latest/contracts.html#receive-ether-function)，如果有的话， 或者它的 [Fallback 函数](https://docs.soliditylang.org/zh-cn/latest/contracts.html#fallback-function)，如果有的话）将与 `transfer` 调用一起执行（这是EVM的一个特性，无法阻止）。 如果执行过程中耗尽了燃料或出现了任何故障，以太币的转移将被还原，当前的合约将以异常的方式停止。
* `send`
 
`send` 是 `transfer` 的低级对应部分。如果执行失败，当前的合约不会因异常而停止，但 `send` 会返回 `false`。
警告
使用 `send` 有一些危险：如果调用堆栈深度为1024，传输就会失败（这可以由调用者强制执行）， 如果接收者的燃料耗尽，也会失败。因此，为了安全地进行以太币转账， 一定要检查 `send` 的返回值，或者使用 `transfer`，甚至使用更好的方式： 使用收款人提取以太币的模式。
* `call`, `delegatecall` 和 `staticcall`
 
为了与不遵守ABI的合约对接，或者为了更直接地控制编码， 我们提供了 `call`, `delegatecall` 和 `staticcall` 函数。 它们都接受一个 `bytes memory` 参数，并返回成功条件（作为一个 `bool`） 和返回的数据（ `bytes memory`）。 函数 `abi.encode`, `abi.encodePacked`, `abi.encodeWithSelector` 和 `abi.encodeWithSignature` 可以用来编码结构化的数据。
示例：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ynl0ZXMgbWVtb3J5IHBheWxvYWQgPSBhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgicmVnaXN0ZXIoc3RyaW5nKSIsICJNeU5hbWUiKTsKKGJvb2wgc3VjY2VzcywgYnl0ZXMgbWVtb3J5IHJldHVybkRhdGEpID0gYWRkcmVzcyhuYW1lUmVnKS5jYWxsKHBheWxvYWQpOwpyZXF1aXJlKHN1Y2Nlc3MpOw==)
bytes memory payload \= abi.encodeWithSignature("register(string)", "MyName");
(bool success, bytes memory returnData) \= address(nameReg).call(payload);
require(success);
警告
所有这些函数都是低级别的函数，应该谨慎使用。 具体来说，任何未知的合约都可能是恶意的，如果您调用它， 您就把控制权交给了该合约，而该合约又可能回调到您的合约中， 所以要准备好在调用返回时改变您合约的状态变量。 与其他合约互动的常规方法是在合约对象上调用一个函数（ `x.f()`）。
备注
以前的 Solidity 版本允许这些函数接收任意的参数， 并且也会以不同的方式处理 `bytes4` 类型的第一个参数。 这些边缘情况在0.5.0版本中被移除。
可以用 `gas` 修饰器来调整所提供的燃料：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse2dhczogMTAwMDAwMH0oYWJpLmVuY29kZVdpdGhTaWduYXR1cmUoInJlZ2lzdGVyKHN0cmluZykiLCAiTXlOYW1lIikpOw==)
address(nameReg).call{gas: 1000000}(abi.encodeWithSignature("register(string)", "MyName"));
同样，所提供的以太值也可以被控制：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse3ZhbHVlOiAxIGV0aGVyfShhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgicmVnaXN0ZXIoc3RyaW5nKSIsICJNeU5hbWUiKSk7)
address(nameReg).call{value: 1 ether}(abi.encodeWithSignature("register(string)", "MyName"));
最后，这些修饰器可以合并。它们的顺序并不重要：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse2dhczogMTAwMDAwMCwgdmFsdWU6IDEgZXRoZXJ9KGFiaS5lbmNvZGVXaXRoU2lnbmF0dXJlKCJyZWdpc3RlcihzdHJpbmcpIiwgIk15TmFtZSIpKTs=)
address(nameReg).call{gas: 1000000, value: 1 ether}(abi.encodeWithSignature("register(string)", "MyName"));
以类似的方式，可以使用函数 `delegatecall`：不同的是，它只使用给定地址的代码， 所有其他方面（存储，余额，…）都取自当前的合约。 `delegatecall` 的目的是为了使用存储在另一个合约中的库代码。 用户必须确保两个合约中的存储结构都适合使用delegatecall。
备注
在 homestead 版本之前，只有一个功能类似但作用有限的 `callcode` 的函数可用， 但它不能获取委托方的 `msg.sender` 和 `msg.value`。这个功能在 0.5.0 版本中被移除。
从 byzantium 开始，也可以使用 `staticcall`。这基本上与 `call` 相同， 但如果被调用的函数以任何方式修改了状态，则会恢复。
这三个函数 `call`， `delegatecall` 和 `staticcall` 都是非常低级的函数， 只应该作为 _最后的手段_ 来使用，因为它们破坏了Solidity的类型安全。
`gas` 选项在所有三种方法中都可用，而 `value` 选项只在 `call` 中可用。
备注
最好避免在您的智能合约代码中依赖硬编码的燃料值，无论状态是读出还是写入， 因为这可能有很多隐患。另外，对燃料的访问在未来可能会改变。
* `code` 和 `codehash`
 
您可以查询任何智能合约的部署代码。使用 `.code` 获得作为 `bytes memory` 的EVM字节码， 这可能是空的。使用 `.codehash` 获得该代码的Keccak-256哈希值（作为 `bytes32`）。 注意，使用 `addr.codehash` 比 `keccak256(addr.code)` 更便宜。
备注
所有的合约都可以转换为 `address` 类型，所以可以用 `address(this).balance` 查询当前合约的余额。
### 合约类型[](#contract-types "此标题的永久链接")
每个 [合约](https://docs.soliditylang.org/zh-cn/latest/contracts.html#contracts) 都定义了自己的类型。 您可以隐式地将一个合约转换为它们所继承的另一个合约。 合约可以显式地转换为 `address` 类型，也可以从 `address` 类型中转换。
只有在合约类型具有 receive 或 payable 类型的 fallback 函数的情况下， 才有可能明确转换为 `address payable` 类型和从该类型转换。 这种转换仍然使用 `address(x)` 进行转换。如果合约类型没有一个 receive 或 payable 类型的 fallback 函数， 可以使用 `payable(address(x))` 来转换为 `address payable` 。 您可以在 [地址类型](#address) 一节中找到更多信息。
备注
在 0.5.0 版本之前，合约直接从地址类型派生出来， 并且在 `address` 和 `address payable` 之间没有区别。
如果您声明了一个本地类型的变量（ `MyContract c` ），您可以调用该合约上的函数。 注意要从相同合约类型的地方将其赋值。
您也可以实例化合约（这意味着它们是新创建的）。 您可以在 [‘通过关键字new创建合约’](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#creating-contracts) 部分找到更多细节。
合约的数据表示与 `address` 类型相同，该类型也用于 [ABI](https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi)。
合约不支持任何运算符。
合约类型的成员是合约的外部函数，包括任何标记为 `public` 的状态变量。
对于一个合约 `C`，您可以使用 `type(C)` 来访问 关于该合约的 [类型信息](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#meta-type) 。
### 定长字节数组[](#index-7 "此标题的永久链接")
值类型 `bytes1`, `bytes2`, `bytes3`, …, `bytes32` 代表从1到32的字节序列。
运算符：
比较运算符：<=， <， ==， !=， >=， > （返回布尔型）
* 比较运算符： `<=`， `<`， `==`， `!=`， `>=`， `>` (返回 `bool`)
 
* 位运算符： `&`， `|`， `^` （按位异或）， `~` （按位取反）
 
* 移位运算符： `<<` （左移位）， `>>` （右移位）
 
* 索引访问： 如果 `x` 是 `bytesI` 类型，那么当 `0 <= k < I` 时， `x[k]` 返回第 `k` 个字节（只读）。
 
移位运算符以无符号的整数类型作为右操作数（但返回左操作数的类型）， 它表示要移位的位数。有符号类型的移位将产生一个编译错误。
成员变量：
* `.length` 表示这个字节数组的长度（只读）.
 
备注
类型 `bytes1[]` 是一个字节数组，但是由于填充规则，它为每个元素浪费了31个字节的空间（在存储中除外）。 因此最好使用 `bytes` 类型来代替。
备注
在 0.8.0 版本之前， `byte` 曾经是 `bytes1` 的别名。
### 变长字节数组[](#id17 "此标题的永久链接")
`bytes`:
变长字节数组，参见 [数组](#arrays)。它并不是值类型！
`string`:
变长 UTF-8 编码字符串类型，参见 [数组](#arrays)。并不是值类型！
### 地址字面量（Address Literals）[](#address-literals "此标题的永久链接")
比如像 `0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF` 这样的 通过了地址校验测试的十六进制字属于 `address` 类型。 十六进制字数在39到41位之间，并且没有通过校验测试，会产生一个错误。 您可以预加（对于整数类型）或附加（对于bytesNN类型）零来消除该错误。
### 有理数和整数字面量[](#rational-literals "此标题的永久链接")
整数字面量由范围在 0-9 的一串数字组成，表现成十进制。 例如， `69` 表示十进制数字 69。 Solidity 中是没有八进制的，因此前置 0 是无效的。
小数字面常数由 `.` 和小数点后的至少一个数字组成。例如， `.1` 和 `1.3` （但不是 `1.`）。
也支持 `2e10` 形式的科学符号，其中尾数可以是小数，但指数必须是一个整数。 字面的 `MeE` 相当于 `M * 10**E`。 例子包括 `2e10`, `-2e10`, `2e-10`, `2.5e1`。
下划线可以用来分隔数字字面的数字，以帮助阅读。 例如，十进制 `123_000`，十六进制 `0x2eff_abde`，科学十进制 `1_2e345_678` 都是有效的。 下划线只允许在两个数字之间，并且只允许一个连续的下划线。 含有下划线的数字字面没有额外的语义，下划线被忽略。
数值字面量表达式保留任意精度，直到它们被转换为非字面量类型 （即通过与数字字面量表达式以外的任何东西一起使用（如布尔字面量）或通过显式转换）。 这意味着在数值常量表达式中，计算不会溢出，除法不会截断。
例如， `(2**800 + 1) - 2**800` 的结果是常数 `1` （类型 `uint8`）， 尽管中间的结果甚至不符合机器字的大小。此外， `.5 * 8` 的结果是整数 `4` （尽管中间使用了非整数）。
警告
虽然大多数运算符在应用于字面量时都会产生一个字面量表达式，但有一些运算符并不遵循这种模式：
* 三元运算符（ `...？ ...：...`）。
 
* 数组下标（ `<array>[<index>]`）。
 
您可能期望像 `255 + (true ? 1 : 0)` 或 `255 + [1, 2, 3][0]` 这样的表达式等同于直接使用字面量256， 但实际上它们是在 `uint8` 类型中计算的，可能会溢出。
只要操作数是整数，任何可以应用于整数的操作数也可以应用于数值字面量表达式。 如果两者中的任何一个是小数，则不允许进行位操作， 如果指数是小数，则不允许进行幂运算（因为这可能导致无理数）。
以数值字面量表达式为左（或基数）操作数，以整数类型为右（指数）操作数的移位和幂运算， 总是在 `uint256` （非负数数值字面量）或 `int256` （负数数值字面量）类型中进行。 无论右（指数）操作数的类型如何。
警告
在 0.4.0 版本之前，Solidity 中整数字的除法会被截断，但现在它转换为一个有理数，即 `5 / 2` 不等于 `2`，而是 `2.5`。
备注
Solidity 对每个有理数都有对应的数值字面量类型。 整数字面量和有理数字面量都属于数值字面量类型。 除此之外，所有的数值字面量表达式（即只包含数值字面量和运算符的表达式）都属于数值字面量类型。 因此数值字面量表达式 `1 + 2` 和 `2 + 1` 的结果跟有理数3的数值字面量类型相同。
备注
数字字面表达式一旦与非字面表达式一起使用，就会被转换为非字面类型。 不考虑类型，下面分配给 `b` 的表达式的值被评估为一个整数。 因为 `a` 的类型是 `uint128`，所以表达式 `2.5 + a` 必须有一个合适的类型。 由于 `2.5` 和 `uint128` 的类型没有共同的类型，Solidity编译器不接受这段代码。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=dWludDEyOCBhID0gMTsKdWludDEyOCBiID0gMi41ICsgYSArIDAuNTs=)
uint128 a \= 1;
uint128 b \= 2.5 + a + 0.5;
### 字符串字面量和类型[](#string-literals "此标题的永久链接")
字符串字面量是指由双引号或单引号引起来的字符串（ `"foo"` 或者 `'bar'`）。 它们也可以分成多个连续部分（ `"foo" "bar"` 相当于 `"foobar"` ），这在处理长字符串时很有帮助。 它们不像在 C 语言中那样带有结束符； `"foo"` 相当于3个字节而不是4个。 和整数字面量一样，字符串字面量的类型也可以发生改变， 但它们可以隐式地转换成 `bytes1`，……， `bytes32`，如果合适的话，还可以转换成 `bytes` 以及 `string`。
例如，使用 `bytes32 samevar = "stringliteral"`， 当分配给 `bytes32` 类型时，字符串字面量被解释成原始字节形式。
字符串字面量只能包含可打印的ASCII字符，也就是0x20 … 0x7E之间的字符。
此外，字符串字元还支持以下转义字符：
* `\<newline>` （转义一个实际的换行）
 
* `\\` （反斜杠）
 
* `\'` （单引号）
 
* `\"` （双引号）
 
* `\n` （换行）
 
* `\r` （回车键）
 
* `\t` （制表）
 
* `\xNN` （十六进制转义，见下文）
 
* `\uNNNN` （unicode转义，见下文）
 
`\xNN` 接收一个十六进制值并插入相应的字节，而 `\uNNNN` 接收一个Unicode编码点并插入一个UTF-8序列。
备注
在 0.8.0 版本之前，有三个额外的转义序列。 `\b`， `\f` 和 `v`。 它们在其他语言中通常是可用的，但在实践中很少需要。 如果您确实需要它们，仍然可以通过十六进制转义插入， 即分别为 `\x08`， `x0c` 和 `\x0b`，就像其他ASCII字符一样。
下面例子中的字符串的长度为10个字节。 它以一个换行字节开始，接着是一个双引号，一个单引号，一个反斜杠字符， 然后（没有分隔符）是字符序列 `abcdef`。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=IlxuXCJcJ1xcYWJjXApkZWYi)
任何非换行的 Unicode 行结束符（即LF, VF, FF, CR, NEL, LS, PS）都被认为是字符串字面的结束。 换行只在字符串字面内容前面没有 `\` 的情况下终止。
### Unicode 字面量[](#unicode "此标题的永久链接")
普通字符串字面量只能包含ASCII码，而 Unicode 字面量 - 以关键字 `unicode` 为前缀 - 可以包含任何有效的UTF-8序列。 它们也支持与普通字符串字面意义相同的转义序列。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=c3RyaW5nIG1lbW9yeSBhID0gdW5pY29kZSJIZWxsbyDwn5iDIjs=)
string memory a \= unicode"Hello 😃";
### 十六进制字面量[](#index-12 "此标题的永久链接")
十六进制字面量以关键字 `hex` 打头， 后面紧跟着用单引号或双引号引起来的字符串（ `hex"001122FF"`, `hex'0011_22_FF'`）。 它们的内容必须是十六进制的数字，可以选择使用一个下划线作为字节边界之间的分隔符。 字面的值将是十六进制序列的二进制表示。
由空格分隔的多个十六进制字面量被串联成一个字面量： `hex"00112233" hex"44556677"` 相当于 `hex"0011223344556677"`。
十六进制字面量在某些方面的行为类似 [字符串字面量](#string-literals) ，但不能隐式转换为 `string` 类型。
### 枚举类型[](#enums "此标题的永久链接")
枚举是在 Solidity 中创建用户定义类型的一种方式。 它们可以显式地转换为所有整数类型，和从整数类型来转换，但不允许隐式转换。 从整数的显式转换在运行时检查该值是否在枚举的范围内，否则会导致 [异常](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require)。 枚举要求至少有一个成员，其声明时的默认值是第一个成员。 枚举不能有超过256个成员。
数据表示与 C 语言中的枚举相同。选项由后续的从 `0` 开始无符号整数值表示。
使用 `type(NameOfEnum).min` 和 `type(NameOfEnum).max` 您可以得到给定枚举的最小值和最大值。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguODsKCmNvbnRyYWN0IHRlc3QgewogICAgZW51bSBBY3Rpb25DaG9pY2VzIHsgR29MZWZ0LCBHb1JpZ2h0LCBHb1N0cmFpZ2h0LCBTaXRTdGlsbCB9CiAgICBBY3Rpb25DaG9pY2VzIGNob2ljZTsKICAgIEFjdGlvbkNob2ljZXMgY29uc3RhbnQgZGVmYXVsdENob2ljZSA9IEFjdGlvbkNob2ljZXMuR29TdHJhaWdodDsKCiAgICBmdW5jdGlvbiBzZXRHb1N0cmFpZ2h0KCkgcHVibGljIHsKICAgICAgICBjaG9pY2UgPSBBY3Rpb25DaG9pY2VzLkdvU3RyYWlnaHQ7CiAgICB9CgogICAgLy8g55Sx5LqO5p6a5Li+57G75Z6L5LiN5bGe5LqOQUJJ55qE5LiA6YOo5YiG77yM5Zug5q2k5a+55LqO5omA5pyJ5p2l6IeqIFNvbGlkaXR5IOWklumDqOeahOiwg+eUqO+8jAogICAgLy8gImdldENob2ljZSIg55qE562+5ZCN5Lya6Ieq5Yqo6KKr5pS55oiQICJnZXRDaG9pY2UoKSByZXR1cm5zICh1aW50OCki44CCCiAgICBmdW5jdGlvbiBnZXRDaG9pY2UoKSBwdWJsaWMgdmlldyByZXR1cm5zIChBY3Rpb25DaG9pY2VzKSB7CiAgICAgICAgcmV0dXJuIGNob2ljZTsKICAgIH0KCiAgICBmdW5jdGlvbiBnZXREZWZhdWx0Q2hvaWNlKCkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiB1aW50KGRlZmF1bHRDaG9pY2UpOwogICAgfQoKICAgIGZ1bmN0aW9uIGdldExhcmdlc3RWYWx1ZSgpIHB1YmxpYyBwdXJlIHJldHVybnMgKEFjdGlvbkNob2ljZXMpIHsKICAgICAgICByZXR1cm4gdHlwZShBY3Rpb25DaG9pY2VzKS5tYXg7CiAgICB9CgogICAgZnVuY3Rpb24gZ2V0U21hbGxlc3RWYWx1ZSgpIHB1YmxpYyBwdXJlIHJldHVybnMgKEFjdGlvbkNob2ljZXMpIHsKICAgICAgICByZXR1cm4gdHlwZShBY3Rpb25DaG9pY2VzKS5taW47CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.8;
contract test {
 enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }
 ActionChoices choice;
 ActionChoices constant defaultChoice \= ActionChoices.GoStraight;
 function setGoStraight() public {
 choice \= ActionChoices.GoStraight;
 }
 // 由于枚举类型不属于ABI的一部分，因此对于所有来自 Solidity 外部的调用，
 // "getChoice" 的签名会自动被改成 "getChoice() returns (uint8)"。
 function getChoice() public view returns (ActionChoices) {
 return choice;
 }
 function getDefaultChoice() public pure returns (uint) {
 return uint(defaultChoice);
 }
 function getLargestValue() public pure returns (ActionChoices) {
 return type(ActionChoices).max;
 }
 function getSmallestValue() public pure returns (ActionChoices) {
 return type(ActionChoices).min;
 }
}
备注
枚举也可以在文件级别上声明，在合约或库定义之外。
### 用户定义的值类型[](#user-defined-value-types "此标题的永久链接")
一个用户定义的值类型允许在一个基本的值类型上创建一个零成本的抽象。 这类似于一个别名，但有更严格的类型要求。
一个用户定义的值类型是用 `type C is V` 定义的，其中 `C` 是新引入的类型的名称， `V` 必须是一个内置的值类型（“底层类型”）。 函数 `C.wrap` 被用来从底层类型转换到自定义类型。同样地， 函数 `C.unwrap` 用于从自定义类型转换到底层类型。
类型 `C` 没有任何运算符或附加成员函数。特别是，甚至运算符 `==` 也没有定义。 不允许对其他类型进行显式和隐式转换。
这种类型的值的数据表示是从底层类型中继承的，底层类型也被用于ABI中。
下面的例子说明了一个自定义类型 `UFixed256x18`， 代表一个有18位小数的十进制定点类型和一个最小的库来对该类型做算术运算。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguODsKCi8vIOS9v+eUqOeUqOaIt+WumuS5ieeahOWAvOexu+Wei+ihqOekuuWNgei/m+WItjE45L2N77yMMjU25L2N5a6955qE5a6a54K557G75Z6L44CCCnR5cGUgVUZpeGVkMjU2eDE4IGlzIHVpbnQyNTY7CgovLy8g5LiA5Liq5ZyoVUZpeGVkMjU2eDE45LiK6L+b6KGM5a6a54K55pON5L2c55qE5pyA5bCP5bqT44CCCmxpYnJhcnkgRml4ZWRNYXRoIHsKICAgIHVpbnQgY29uc3RhbnQgbXVsdGlwbGllciA9IDEwKioxODsKCiAgICAvLy8g5bCG5Lik5LiqVUZpeGVkMjU2eDE455qE5pWw5a2X55u45Yqg44CC5rqi5Ye65pe25bCG6L+U5Zue77yM5L6d6Z2gdWludDI1NueahOeul+acr+ajgOafpeOAggogICAgZnVuY3Rpb24gYWRkKFVGaXhlZDI1NngxOCBhLCBVRml4ZWQyNTZ4MTggYikgaW50ZXJuYWwgcHVyZSByZXR1cm5zIChVRml4ZWQyNTZ4MTgpIHsKICAgICAgICByZXR1cm4gVUZpeGVkMjU2eDE4LndyYXAoVUZpeGVkMjU2eDE4LnVud3JhcChhKSArIFVGaXhlZDI1NngxOC51bndyYXAoYikpOwogICAgfQogICAgLy8vIOWwhlVGaXhlZDI1NngxOOWSjHVpbnQyNTbnm7jkuZjjgILmuqLlh7rml7blsIbov5Tlm57vvIzkvp3pnaB1aW50MjU255qE566X5pyv5qOA5p+l44CCCiAgICBmdW5jdGlvbiBtdWwoVUZpeGVkMjU2eDE4IGEsIHVpbnQyNTYgYikgaW50ZXJuYWwgcHVyZSByZXR1cm5zIChVRml4ZWQyNTZ4MTgpIHsKICAgICAgICByZXR1cm4gVUZpeGVkMjU2eDE4LndyYXAoVUZpeGVkMjU2eDE4LnVud3JhcChhKSAqIGIpOwogICAgfQogICAgLy8vIOWvueS4gOS4qlVGaXhlZDI1NngxOOexu+Wei+eahOaVsOWtl+ebuOS4i+WPluaVtOOAggogICAgLy8vIEByZXR1cm4g5LiN6LaF6L+HIGBhYCDnmoTmnIDlpKfmlbTmlbDjgIIKICAgIGZ1bmN0aW9uIGZsb29yKFVGaXhlZDI1NngxOCBhKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnQyNTYpIHsKICAgICAgICByZXR1cm4gVUZpeGVkMjU2eDE4LnVud3JhcChhKSAvIG11bHRpcGxpZXI7CiAgICB9CiAgICAvLy8g5bCG5LiA5LiqdWludDI1Nui9rOWMluS4uuebuOWQjOWAvOeahFVGaXhlZDI1NngxOOOAggogICAgLy8vIOWmguaenOaVtOaVsOWkquWkp++8jOWImeaBouWkjeiuoeeul+OAggogICAgZnVuY3Rpb24gdG9VRml4ZWQyNTZ4MTgodWludDI1NiBhKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKFVGaXhlZDI1NngxOCkgewogICAgICAgIHJldHVybiBVRml4ZWQyNTZ4MTgud3JhcChhICogbXVsdGlwbGllcik7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.8;
// 使用用户定义的值类型表示十进制18位，256位宽的定点类型。
type UFixed256x18 is uint256;
/// 一个在UFixed256x18上进行定点操作的最小库。
library FixedMath {
 uint constant multiplier \= 10\*\*18;
 /// 将两个UFixed256x18的数字相加。溢出时将返回，依靠uint256的算术检查。
 function add(UFixed256x18 a, UFixed256x18 b) internal pure returns (UFixed256x18) {
 return UFixed256x18.wrap(UFixed256x18.unwrap(a) + UFixed256x18.unwrap(b));
 }
 /// 将UFixed256x18和uint256相乘。溢出时将返回，依靠uint256的算术检查。
 function mul(UFixed256x18 a, uint256 b) internal pure returns (UFixed256x18) {
 return UFixed256x18.wrap(UFixed256x18.unwrap(a) \* b);
 }
 /// 对一个UFixed256x18类型的数字相下取整。
 /// @return 不超过 \`a\` 的最大整数。
 function floor(UFixed256x18 a) internal pure returns (uint256) {
 return UFixed256x18.unwrap(a) / multiplier;
 }
 /// 将一个uint256转化为相同值的UFixed256x18。
 /// 如果整数太大，则恢复计算。
 function toUFixed256x18(uint256 a) internal pure returns (UFixed256x18) {
 return UFixed256x18.wrap(a \* multiplier);
 }
}
注意 `UFixed256x18.wrap` 和 `FixedMath.toUFixed256x18` 有相同的签名， 但执行两个非常不同的操作。 `UFixed256x18.wrap` 函数返回一个与输入的数据表示相同的 `UFixed256x18`， 而 `toUFixed256x18` 则返回一个具有相同数值的 `UFixed256x18`。
### 函数类型[](#function-types "此标题的永久链接")
函数类型是一种表示函数的类型。可以将一个函数赋值给另一个函数类型的变量， 也可以将一个函数作为参数进行传递，还能在函数调用中返回函数类型变量。 函数类型有两类：- _内部（internal）_ 函数和 _外部（external）_ 函数：
内部函数只能在当前合约内被调用（更具体来说， 在当前代码块内，包括内部库函数和继承的函数中）， 因为它们不能在当前合约上下文的外部被执行。 调用一个内部函数是通过跳转到它的入口标签来实现的， 就像在当前合约的内部调用一个函数。
外部函数由一个地址和一个函数签名组成，可以通过外部函数调用传递或者返回。
函数类型表示成如下的形式：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=ZnVuY3Rpb24gKDxwYXJhbWV0ZXIgdHlwZXM+KSB7aW50ZXJuYWx8ZXh0ZXJuYWx9IFtwdXJlfHZpZXd8cGF5YWJsZV0gW3JldHVybnMgKDxyZXR1cm4gdHlwZXM+KV0=)
function (<parameter types\>) {internal|external} \[pure|view|payable\] \[returns (<return types\>)\]
与参数类型相反，返回类型不能为空 —— 如果函数类型不需要返回， 则需要删除整个 `returns (<return types>)` 部分。
默认情况下，函数类型是内部函数，所以可以省略 `internal` 关键字。 注意，这只适用于函数类型。对于合约中定义的函数， 必须明确指定其可见性，它们没有默认类型。
转换：
当且仅当它们的参数类型相同，它们的返回类型相同，它们的内部/外部属性相同， 并且 `A` 的状态可变性比 `B` 的状态可变性更具限制性时， 一个函数类型 `A` 就可以隐式转换为一个函数类型 `B`。特别是：
* `pure` 函数可以转换为 `view` 和 `非 payable` 函数
 
* `view` 函数可以转换为 `非 payable` 函数
 
* `payable` 函数可以转换为 `非 payable` 函数
 
其他函数类型之间的转换是不可能的。
关于 `payable` 和 `非 payable` 的规则可能有点混乱， 但实质上，如果一个函数是 `payable`，这意味着 它也接受零以太的支付，所以它也是 `非 payable`。 另一方面，一个 `非 payable` 的函数将拒收发送给它的以太， 所以 `非 payable` 的函数不能被转换为 `payable` 的函数。 声明一下，拒收以太比不拒收以太更有限制性。 这意味着您可以用一个不可支付的函数覆写一个可支付的函数，但不能反过来。
此外，当您定义一个 `非 payable` 的函数指针时， 编译器并不强制要求被指向的函数实际拒收以太。 相反，它强制要求该函数指针永远不会被用来发送以太。 这使得我们有可能将一个 `payable` 的函数指针分配给一个 `非 payable` 的函数指针， 以确保这两种类型的函数表现相同，即都不能用来发送以太。
如果一个函数类型的变量没有被初始化，调用它将导致 会出现 [异常](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require)。如果您在一个函数上使用了 `delete` 之后再调用它， 也会发生同样的情况。
如果外部函数类型在 Solidity 的上下文中被使用， 它们将被视为 `function` 类型，它将地址和函数标识符一起编码为一个 `bytes24` 类型。
请注意，当前合约的公共函数既可以被当作内部函数也可以被当作外部函数使用。 如果想将一个函数当作内部函数使用，就用 `f` 调用， 如果想将其当作外部函数，使用 `this.f` 。
一个内部类型的函数可以被分配给一个内部函数类型的变量，无论它在哪里被定义。 这包括合约和库的私有，内部和公共函数，以及自由函数。 另一方面，外部函数类型只与公共和外部合约函数兼容。
备注
带有 `calldata` 参数的外部函数与带有 `calldata` 参数的外部函数类型不兼容。 它们与相应的带有 `memory` 参数的类型兼容。 例如，没有一个函数可以被 `function (string calldata) external` 类型的值所指向， 而 `function (string memory) external` 可以同时指向 `function f(string memory) external {}` 和 `function g(string calldata) external {}`。 这是因为对于这两个位置，参数是以同样的方式传递给函数的。 调用者不能直接将其calldata传递给外部函数，总是ABI将参数编码到内存中。 将参数标记为 `calldata` 只影响到外部函数的实现，在调用者一方的函数指针中是没有意义的。
警告
在启用了优化器的旧版优化流程中，内部函数指针的比较可能会产生意想不到的结果， 因为优化器可能会将相同的函数合并为一个，这将导致这些函数指针在比较时显示为相等， 而不是不相等。不建议进行此类比较，这会导致编译器发出警告，直到下一个重大更新版本（0.9.0）时， 该警告将升级为错误，从而禁止此类比较。
库合约被排除在外，因为它们需要用到 `delegatecall`， 并且 [对库合约的函数选择器使用不同的ABI约定](https://docs.soliditylang.org/zh-cn/latest/contracts.html#library-selectors)。 接口中声明的函数没有定义，所以指向它们也没有意义。
成员： 外部（或公共）函数有以下成员：
* `.address` 返回该函数的合约地址。
 
* `.selector` 返回 [ABI 函数选择器](https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi-function-selector)
 
备注
外部（或公共）函数曾经有额外的成员 `.gas(uint)` 和 `.value(uint)`。 这些在 Solidity 0.6.2 中被废弃，并在 Solidity 0.7.0 中被移除。取而代之的是 使用 `{gas: ...}` 和 `{value: ...}` 来分别指定发送到函数的燃料量或以太（wei为单位）量。 参见 [外部函数调用](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#external-function-calls) 以获得更多信息。
以下例子展示如何使用这些成员：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjQgPDAuOS4wOwoKY29udHJhY3QgRXhhbXBsZSB7CiAgICBmdW5jdGlvbiBmKCkgcHVibGljIHBheWFibGUgcmV0dXJucyAoYnl0ZXM0KSB7CiAgICAgICAgYXNzZXJ0KHRoaXMuZi5hZGRyZXNzID09IGFkZHJlc3ModGhpcykpOwogICAgICAgIHJldHVybiB0aGlzLmYuc2VsZWN0b3I7CiAgICB9CgogICAgZnVuY3Rpb24gZygpIHB1YmxpYyB7CiAgICAgICAgdGhpcy5me2dhczogMTAsIHZhbHVlOiA4MDB9KCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.4 <0.9.0;
contract Example {
 function f() public payable returns (bytes4) {
 assert(this.f.address \== address(this));
 return this.f.selector;
 }
 function g() public {
 this.f{gas: 10, value: 800}();
 }
}
以下例子展示如何使用内部函数类型：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmxpYnJhcnkgQXJyYXlVdGlscyB7CiAgICAvLyDlhoXpg6jlh73mlbDlj6/ku6XlnKjlhoXpg6jlupPlh73mlbDkuK3kvb/nlKjvvIzlm6DkuLrlroPku6zlsIbmmK/lkIzkuIDku6PnoIHkuIrkuIvmlofnmoTkuIDpg6jliIYKICAgIGZ1bmN0aW9uIG1hcCh1aW50W10gbWVtb3J5IHNlbGYsIGZ1bmN0aW9uICh1aW50KSBwdXJlIHJldHVybnMgKHVpbnQpIGYpCiAgICAgICAgaW50ZXJuYWwKICAgICAgICBwdXJlCiAgICAgICAgcmV0dXJucyAodWludFtdIG1lbW9yeSByKQogICAgewogICAgICAgIHIgPSBuZXcgdWludFtdKHNlbGYubGVuZ3RoKTsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIHJbaV0gPSBmKHNlbGZbaV0pOwogICAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiByZWR1Y2UoCiAgICAgICAgdWludFtdIG1lbW9yeSBzZWxmLAogICAgICAgIGZ1bmN0aW9uICh1aW50LCB1aW50KSBwdXJlIHJldHVybnMgKHVpbnQpIGYKICAgICkKICAgICAgICBpbnRlcm5hbAogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50IHIpCiAgICB7CiAgICAgICAgciA9IHNlbGZbMF07CiAgICAgICAgZm9yICh1aW50IGkgPSAxOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykgewogICAgICAgICAgICByID0gZihyLCBzZWxmW2ldKTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gcmFuZ2UodWludCBsZW5ndGgpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludFtdIG1lbW9yeSByKSB7CiAgICAgICAgciA9IG5ldyB1aW50W10obGVuZ3RoKTsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIHJbaV0gPSBpOwogICAgICAgIH0KICAgIH0KfQoKCmNvbnRyYWN0IFB5cmFtaWQgewogICAgdXNpbmcgQXJyYXlVdGlscyBmb3IgKjsKCiAgICBmdW5jdGlvbiBweXJhbWlkKHVpbnQgbCkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBBcnJheVV0aWxzLnJhbmdlKGwpLm1hcChzcXVhcmUpLnJlZHVjZShzdW0pOwogICAgfQoKICAgIGZ1bmN0aW9uIHNxdWFyZSh1aW50IHgpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiB4ICogeDsKICAgIH0KCiAgICBmdW5jdGlvbiBzdW0odWludCB4LCB1aW50IHkpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiB4ICsgeTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
library ArrayUtils {
 // 内部函数可以在内部库函数中使用，因为它们将是同一代码上下文的一部分
 function map(uint\[\] memory self, function (uint) pure returns (uint) f)
 internal
 pure
 returns (uint\[\] memory r)
 {
 r \= new uint\[\](self.length);
 for (uint i \= 0; i < self.length; i++) {
 r\[i\] \= f(self\[i\]);
 }
 }
 function reduce(
 uint\[\] memory self,
 function (uint, uint) pure returns (uint) f
 )
 internal
 pure
 returns (uint r)
 {
 r \= self\[0\];
 for (uint i \= 1; i < self.length; i++) {
 r \= f(r, self\[i\]);
 }
 }
 function range(uint length) internal pure returns (uint\[\] memory r) {
 r \= new uint\[\](length);
 for (uint i \= 0; i < r.length; i++) {
 r\[i\] \= i;
 }
 }
}
contract Pyramid {
 using ArrayUtils for \*;
 function pyramid(uint l) public pure returns (uint) {
 return ArrayUtils.range(l).map(square).reduce(sum);
 }
 function square(uint x) internal pure returns (uint) {
 return x \* x;
 }
 function sum(uint x, uint y) internal pure returns (uint) {
 return x + y;
 }
}
另一个使用外部函数类型的例子：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCgpjb250cmFjdCBPcmFjbGUgewogICAgc3RydWN0IFJlcXVlc3QgewogICAgICAgIGJ5dGVzIGRhdGE7CiAgICAgICAgZnVuY3Rpb24odWludCkgZXh0ZXJuYWwgY2FsbGJhY2s7CiAgICB9CgogICAgUmVxdWVzdFtdIHByaXZhdGUgcmVxdWVzdHM7CiAgICBldmVudCBOZXdSZXF1ZXN0KHVpbnQpOwoKICAgIGZ1bmN0aW9uIHF1ZXJ5KGJ5dGVzIG1lbW9yeSBkYXRhLCBmdW5jdGlvbih1aW50KSBleHRlcm5hbCBjYWxsYmFjaykgcHVibGljIHsKICAgICAgICByZXF1ZXN0cy5wdXNoKFJlcXVlc3QoZGF0YSwgY2FsbGJhY2spKTsKICAgICAgICBlbWl0IE5ld1JlcXVlc3QocmVxdWVzdHMubGVuZ3RoIC0gMSk7CiAgICB9CgogICAgZnVuY3Rpb24gcmVwbHkodWludCByZXF1ZXN0SUQsIHVpbnQgcmVzcG9uc2UpIHB1YmxpYyB7CiAgICAgICAgLy8g6L+Z6YeM6KaB5qOA5p+l55qE5piv6LCD55So6L+U5Zue5piv5ZCm5p2l6Ieq5Y+v5L+h55qE5p2l5rqQCiAgICAgICAgcmVxdWVzdHNbcmVxdWVzdElEXS5jYWxsYmFjayhyZXNwb25zZSk7CiAgICB9Cn0KCgpjb250cmFjdCBPcmFjbGVVc2VyIHsKICAgIE9yYWNsZSBjb25zdGFudCBwcml2YXRlIE9SQUNMRV9DT05TVCA9IE9yYWNsZShhZGRyZXNzKDB4MDAwMDAwMDAyMTlhYjU0MDM1NmNCQjgzOUNiZTA1MzAzZDc3MDVGYSkpOyAvLyDlt7Lnn6XnmoTlkIjnuqYKICAgIHVpbnQgcHJpdmF0ZSBleGNoYW5nZVJhdGU7CgogICAgZnVuY3Rpb24gYnV5U29tZXRoaW5nKCkgcHVibGljIHsKICAgICAgICBPUkFDTEVfQ09OU1QucXVlcnkoIlVTRCIsIHRoaXMub3JhY2xlUmVzcG9uc2UpOwogICAgfQoKICAgIGZ1bmN0aW9uIG9yYWNsZVJlc3BvbnNlKHVpbnQgcmVzcG9uc2UpIHB1YmxpYyB7CiAgICAgICAgcmVxdWlyZSgKICAgICAgICAgICAgbXNnLnNlbmRlciA9PSBhZGRyZXNzKE9SQUNMRV9DT05TVCksCiAgICAgICAgICAgICJPbmx5IG9yYWNsZSBjYW4gY2FsbCB0aGlzLiIKICAgICAgICApOwogICAgICAgIGV4Y2hhbmdlUmF0ZSA9IHJlc3BvbnNlOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.22 <0.9.0;
contract Oracle {
 struct Request {
 bytes data;
 function(uint) external callback;
 }
 Request\[\] private requests;
 event NewRequest(uint);
 function query(bytes memory data, function(uint) external callback) public {
 requests.push(Request(data, callback));
 emit NewRequest(requests.length \- 1);
 }
 function reply(uint requestID, uint response) public {
 // 这里要检查的是调用返回是否来自可信的来源
 requests\[requestID\].callback(response);
 }
}
contract OracleUser {
 Oracle constant private ORACLE\_CONST \= Oracle(address(0x00000000219ab540356cBB839Cbe05303d7705Fa)); // 已知的合约
 uint private exchangeRate;
 function buySomething() public {
 ORACLE\_CONST.query("USD", this.oracleResponse);
 }
 function oracleResponse(uint response) public {
 require(
 msg.sender \== address(ORACLE\_CONST),
 "Only oracle can call this."
 );
 exchangeRate \= response;
 }
}
备注
Lambda 或内联函数是计划中的，但还不支持。
## 引用类型[](#reference-types "此标题的永久链接")
引用类型的值可以通过多个不同的名称进行修改。 这与值类型形成鲜明对比，在值类型的变量被使用时，您会得到一个独立的副本。 正因为如此，对引用类型的处理要比对值类型的处理更加谨慎。目前， 引用类型包括结构、数组和映射。如果您使用一个引用类型， 您必须明确地提供存储该类型的数据区域。 `memory` （其寿命限于外部函数调用）， `storage` （存储状态变量的位置，其寿命限于合约的寿命） 或 `calldata` （包含函数参数的特殊数据位置）。
改变数据位置的赋值或类型转换将总是导致自动复制操作， 而同一数据位置内的赋值只在某些情况下对存储类型进行复制。
### 数据位置[](#data-location "此标题的永久链接")
每个引用类型都有一个额外的属性，即 “数据位置”， 关于它的存储位置。有三个数据位置。 `memory`, `storage` 和 `calldata`。 Calldata是一个不可修改的、非持久性的区域，用于存储函数参数，其行为主要类似于memory。
备注
如果可以的话，尽量使用 `calldata` 作为数据位置，因为这样可以避免复制， 也可以确保数据不能被修改。使用 `calldata` 数据位置的数组和结构也可以从函数中返回， 但不可能分配这种类型。
备注
在0.6.9版本之前，引用型参数的数据位置被限制在外部函数中的 `calldata`， 公开函数中的 `memory`，以及内部和私有函数中的 `memory` 或 `storage`。 现在 `memory` 和 `calldata` 在所有函数中都被允许使用，无论其可见性如何。
备注
在0.5.0版本之前，数据位置可以省略，并且会根据变量的种类、函数类型等默认为不同的位置， 但现在所有的复杂类型都必须给出一个明确的数据位置。
#### 数据位置和分配行为[](#data-location-assignment "此标题的永久链接")
数据位置不仅与数据的持久性有关，而且也与分配的语义有关：
* 在 `storage` 和 `memory` 之间的分配（或从 `calldata` 中分配） 总是创建一个独立的拷贝。
 
* 从 `memory` 到 `memory` 的赋值只创建引用。 这意味着对一个内存变量的改变在所有其他引用相同数据的内存变量中也是可见的。
 
* 从 `storage` 到 **local** 存储变量的赋值也只赋值一个引用。
 
* 所有其他对 `storage` 的赋值总是拷贝的。 这种情况的例子是对状态变量或存储结构类型的局部变量成员的赋值， 即使局部变量本身只是一个引用。
 
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICAvLyB4IOeahOaVsOaNruWtmOWCqOS9jee9ruaYryBzdG9yYWdl44CCCiAgICAvLyDov5nmmK/llK/kuIDlj6/ku6XnnIHnlaXmlbDmja7kvY3nva7nmoTlnLDmlrnjgIIKICAgIHVpbnRbXSB4OwoKICAgIC8vIG1lbW9yeUFycmF5IOeahOaVsOaNruWtmOWCqOS9jee9ruaYryBtZW1vcnnjgIIKICAgIGZ1bmN0aW9uIGYodWludFtdIG1lbW9yeSBtZW1vcnlBcnJheSkgcHVibGljIHsKICAgICAgICB4ID0gbWVtb3J5QXJyYXk7IC8vIOWwhuaVtOS4quaVsOe7hOaLt+i0neWIsCBzdG9yYWdlIOS4re+8jOWPr+ihjAogICAgICAgIHVpbnRbXSBzdG9yYWdlIHkgPSB4OyAvLyDliIbphY3kuIDkuKrmjIfpkojvvIzlhbbkuK0geSDnmoTmlbDmja7lrZjlgqjkvY3nva7mmK8gc3RvcmFnZe+8jOWPr+ihjAogICAgICAgIHlbN107IC8vIOi/lOWbnuesrCA4IOS4quWFg+e0oO+8jOWPr+ihjAogICAgICAgIHkucG9wKCk7IC8vIOmAmui/h3nkv67mlLl477yM5Y+v6KGMCiAgICAgICAgZGVsZXRlIHg7IC8vIOa4hemZpOaVsOe7hO+8jOWQjOaXtuS/ruaUuSB577yM5Y+v6KGMCiAgICAgICAgLy8g5LiL6Z2i55qE5bCx5LiN5Y+v6KGM5LqG77yb6ZyA6KaB5ZyoIHN0b3JhZ2Ug5Lit5Yib5bu65paw55qE5pyq5ZG95ZCN55qE5Li05pe25pWw57uE77yMLwogICAgICAgIC8vIOS9hiBzdG9yYWdlIOaYr+KAnOmdmeaAgeKAneWIhumFjeeahO+8mgogICAgICAgIC8vIHkgPSBtZW1vcnlBcnJheTsKICAgICAgICAvLyDlkIzmoLfvvIwgImRlbGV0ZSB5IiDkuZ/mmK/ml6DmlYjnmoTvvIwKICAgICAgICAvLyDlm6DkuLrlr7nlvJXnlKjlrZjlgqjlr7nosaHnmoTlsYDpg6jlj5jph4/nmoTotYvlgLzlj6rog73ku47njrDmnInnmoTlrZjlgqjlr7nosaHkuK3ov5vooYzjgIIKICAgICAgICAvLyDlroPlsIYg4oCc6YeN572u4oCdIOaMh+mSiO+8jOS9huayoeacieS7u+S9leWQiOeQhueahOS9jee9ruWPr+S7peaMh+WQkeWug+OAggogICAgICAgIC8vIOabtOWkmue7huiKguingSAiZGVsZXRlIiDmk43kvZznrKbnmoTmlofmoaPjgIIKICAgICAgICAvLyBkZWxldGUgeTsKICAgICAgICBnKHgpOyAvLyDosIPnlKggZyDlh73mlbDvvIzlkIzml7bnp7vkuqTlr7kgeCDnmoTlvJXnlKgKICAgICAgICBoKHgpOyAvLyDosIPnlKggaCDlh73mlbDvvIzlkIzml7blnKggbWVtb3J5IOS4reWIm+W7uuS4gOS4queLrOeri+eahOS4tOaXtuaLt+i0nQogICAgfQoKICAgIGZ1bmN0aW9uIGcodWludFtdIHN0b3JhZ2UpIGludGVybmFsIHB1cmUge30KICAgIGZ1bmN0aW9uIGgodWludFtdIG1lbW9yeSkgcHVibGljIHB1cmUge30KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
contract C {
 // x 的数据存储位置是 storage。
 // 这是唯一可以省略数据位置的地方。
 uint\[\] x;
 // memoryArray 的数据存储位置是 memory。
 function f(uint\[\] memory memoryArray) public {
 x \= memoryArray; // 将整个数组拷贝到 storage 中，可行
 uint\[\] storage y \= x; // 分配一个指针，其中 y 的数据存储位置是 storage，可行
 y\[7\]; // 返回第 8 个元素，可行
 y.pop(); // 通过y修改x，可行
 delete x; // 清除数组，同时修改 y，可行
 // 下面的就不可行了；需要在 storage 中创建新的未命名的临时数组，/
 // 但 storage 是“静态”分配的：
 // y = memoryArray;
 // 同样， "delete y" 也是无效的，
 // 因为对引用存储对象的局部变量的赋值只能从现有的存储对象中进行。
 // 它将 “重置” 指针，但没有任何合理的位置可以指向它。
 // 更多细节见 "delete" 操作符的文档。
 // delete y;
 g(x); // 调用 g 函数，同时移交对 x 的引用
 h(x); // 调用 h 函数，同时在 memory 中创建一个独立的临时拷贝
 }
 function g(uint\[\] storage) internal pure {}
 function h(uint\[\] memory) public pure {}
}
### 数组[](#arrays "此标题的永久链接")
数组可以在声明时指定长度，也可以动态调整大小。
一个元素类型为 `T`，固定长度为 `k` 的数组可以声明为 `T[k]`， 而动态数组声明为 `T[]`。
例如，一个由5个 `uint` 的动态数组组成的数组被写成 `uint[][5]`。 与其他一些语言相比, 这种记法是相反的。 在Solidity中, `X[3]` 总是一个包含三个 `X` 类型元素的数组， 即使 `X` 本身是一个数组。 这在其他语言中是不存在的，如C语言。
索引是基于零的，访问方向与声明相反。
例如，如果您有一个变量 `uint[][5] memory x`，您用 `x[2][6]` 访问第三个动态数组中的第七个 `uint`， 要访问第三个动态数组，用 `x[2]`。同样，如果您有一个数组 `T[5] a` 的类型 `T`， 也可以是一个数组，那么 `a[2]` 总是有类型 `T`。
数组元素可以是任何类型，包括映射或结构体。 并适用于类型的一般限制，映射只能存储在 `storage` 数据位置， 公开可见的函数需要参数是 [ABI类型](https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi)。
可以将状态变量数组标记为 `public`， 并让Solidity创建一个 [getter](https://docs.soliditylang.org/zh-cn/latest/contracts.html#visibility-and-getters) 函数。数字索引成为该函数的一个必要参数。
访问一个超过它的末端的数组会导致一个失败的断言。 方法 `.push()` 和 `.push(value)` 可以用来在动态大小的数组末端追加一个新的元素， 其中 `.push()` 追加一个零初始化的元素并返回它的引用。
备注
动态大小的数组只能在存储中调整大小。 在内存中，这样的数组可以是任意大小的，但是一旦分配了数组，就不能改变数组的大小。
#### `bytes` 和 `string` 类型的数组[](#bytes-string "此标题的永久链接")
`bytes` 和 `string` 类型的变量是特殊的数组。 `bytes` 类似于 `bytes1[]`， 但它在 calldata 中会被“紧打包”（译者注：将元素连续地存在一起，不会按每 32 字节一单元的方式来存放）。 `string` 与 `bytes` 相同，但不允许用长度或索引来访问。
Solidity没有字符串操作函数，但有第三方的字符串库。 您也可以用 `keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))` 来比较两个字符串的keccak256-hash，用 `string.concat(s1, s2)` 来连接两个字符串。
您应该使用 `bytes` 而不是 `bytes1[]`，因为它更便宜， 因为在 `memory` 中使用 `bytes1[]` 会在元素之间增加31个填充字节。 请注意，在 `storage` 中，由于紧打包，没有填充，参见 [字节和字符串](https://docs.soliditylang.org/zh-cn/latest/internals/layout_in_storage.html#bytes-and-string)。 一般来说，对于任意长度的原始字节数据使用 `bytes`，对于任意长度的字符串（UTF-8）数据使用 `string`。 如果您能将长度限制在一定的字节数，总是使用 `bytes1` 到 `bytes32` 中的一种值类型，因为它们更便宜。
备注
如果想要访问以字节表示的字符串 `s`， 请使用 `bytes(s).length` / `bytes(s)[7] = 'x';`。 注意这时您访问的是 UTF-8 形式的低级 bytes 类型，而不是单个的字符。
#### 函数 `bytes.concat` 和 `string.concat`[](#bytes-concat-string-concat "此标题的永久链接")
您可以使用 `string.concat` 连接任意数量的 `string` 值。 该函数返回一个单一的 `string memory` 数组，其中包含没有填充的参数内容。 如果您想使用不能隐式转换为 `string` 的其他类型的参数，您需要先将它们转换为 `string`。
同样， `bytes.concat` 函数可以连接任意数量的 `bytes` 或 `bytes1 ... bytes32` 值。 该函数返回一个单一的 `bytes memory` 数组，其中包含没有填充的参数内容。 如果您想使用字符串参数或其他不能隐式转换为 `bytes` 的类型， 您需要先将它们转换为 `bytes` 或 `bytes1` /…/ `bytes32`。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTI7Cgpjb250cmFjdCBDIHsKICAgIHN0cmluZyBzID0gIlN0b3JhZ2UiOwogICAgZnVuY3Rpb24gZihieXRlcyBjYWxsZGF0YSBiYywgc3RyaW5nIG1lbW9yeSBzbSwgYnl0ZXMxNiBiKSBwdWJsaWMgdmlldyB7CiAgICAgICAgc3RyaW5nIG1lbW9yeSBjb25jYXRTdHJpbmcgPSBzdHJpbmcuY29uY2F0KHMsIHN0cmluZyhiYyksICJMaXRlcmFsIiwgc20pOwogICAgICAgIGFzc2VydCgoYnl0ZXMocykubGVuZ3RoICsgYmMubGVuZ3RoICsgNyArIGJ5dGVzKHNtKS5sZW5ndGgpID09IGJ5dGVzKGNvbmNhdFN0cmluZykubGVuZ3RoKTsKCiAgICAgICAgYnl0ZXMgbWVtb3J5IGNvbmNhdEJ5dGVzID0gYnl0ZXMuY29uY2F0KGJ5dGVzKHMpLCBiYywgYmNbOjJdLCAiTGl0ZXJhbCIsIGJ5dGVzKHNtKSwgYik7CiAgICAgICAgYXNzZXJ0KChieXRlcyhzKS5sZW5ndGggKyBiYy5sZW5ndGggKyAyICsgNyArIGJ5dGVzKHNtKS5sZW5ndGggKyBiLmxlbmd0aCkgPT0gY29uY2F0Qnl0ZXMubGVuZ3RoKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.12;
contract C {
 string s \= "Storage";
 function f(bytes calldata bc, string memory sm, bytes16 b) public view {
 string memory concatString \= string.concat(s, string(bc), "Literal", sm);
 assert((bytes(s).length + bc.length + 7 + bytes(sm).length) \== bytes(concatString).length);
 bytes memory concatBytes \= bytes.concat(bytes(s), bc, bc\[:2\], "Literal", bytes(sm), b);
 assert((bytes(s).length + bc.length + 2 + 7 + bytes(sm).length + b.length) \== concatBytes.length);
 }
}
如果您不带参数调用 `string.concat` 或 `bytes.concat`，它们会返回一个空数组。
#### 创建内存数组[](#index-20 "此标题的永久链接")
具有动态长度的内存数组可以使用 `new` 操作符创建。 与存储数组不同的是，**不可能** 调整内存数组的大小（例如， `.push` 成员函数不可用）。 您必须事先计算出所需的大小，或者创建一个新的内存数组并复制每个元素。
正如Solidity中的所有变量一样，新分配的数组元素总是以 [默认值](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#default-value) 进行初始化。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50IGxlbikgcHVibGljIHB1cmUgewogICAgICAgIHVpbnRbXSBtZW1vcnkgYSA9IG5ldyB1aW50W10oNyk7CiAgICAgICAgYnl0ZXMgbWVtb3J5IGIgPSBuZXcgYnl0ZXMobGVuKTsKICAgICAgICBhc3NlcnQoYS5sZW5ndGggPT0gNyk7CiAgICAgICAgYXNzZXJ0KGIubGVuZ3RoID09IGxlbik7CiAgICAgICAgYVs2XSA9IDg7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 function f(uint len) public pure {
 uint\[\] memory a \= new uint\[\](7);
 bytes memory b \= new bytes(len);
 assert(a.length \== 7);
 assert(b.length \== len);
 a\[6\] \= 8;
 }
}
#### 数组字面常数[](#index-21 "此标题的永久链接")
数组字面常数表达式是一个逗号分隔的一个或多个表达式的列表，用方括号（ `[...]` ）括起来。 例如， `[1, a, f(3)]`。数组字面常数的类型确定如下：
它总是一个静态大小的内存数组，其长度是表达式的数量。
数组的基本类型是列表上第一个表达式的类型，这样所有其他表达式都可以隐含地转换为它。 如果不能做到这一点，则会有一个类型错误。
仅仅存在一个所有元素都可以转换的类型是不够的。其中一个元素必须是该类型的。
在下面的例子中， `[1, 2, 3]` 的类型是 `uint8[3] memory`， 因为这些常量的类型都是 `uint8`。如果您想让结果是 `uint[3] memory` 类型， 您需要把第一个元素转换为 `uint`。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHsKICAgICAgICBnKFt1aW50KDEpLCAyLCAzXSk7CiAgICB9CiAgICBmdW5jdGlvbiBnKHVpbnRbM10gbWVtb3J5KSBwdWJsaWMgcHVyZSB7CiAgICAgICAgLy8gLi4uCiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 function f() public pure {
 g(\[uint(1), 2, 3\]);
 }
 function g(uint\[3\] memory) public pure {
 // ...
 }
}
数组表达式 `[1, -1]` 是无效的，因为第一个表达式的类型是 `uint8`， 而第二个表达式的类型是 `int8`，它们不能相互隐式转换。为了使其有效， 例如，您可以使用 `[int8(1), -1]`。
由于不同类型的固定大小的内存数组不能相互转换（即使基类可以）， 如果您想使用二维数组字面常数，您必须总是明确指定一个共同的基类：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQyNFsyXVs0XSBtZW1vcnkpIHsKICAgICAgICB1aW50MjRbMl1bNF0gbWVtb3J5IHggPSBbW3VpbnQyNCgweDEpLCAxXSwgWzB4ZmZmZmZmLCAyXSwgW3VpbnQyNCgweGZmKSwgM10sIFt1aW50MjQoMHhmZmZmKSwgNF1dOwogICAgICAgIC8vIOS4i+mdoueahOaWueazleS4jeS8mui1t+S9nOeUqO+8jOWboOS4uuS4gOS6m+WGhemDqOaVsOe7hOeahOexu+Wei+S4jeWvueOAggogICAgICAgIC8vIHVpbnRbMl1bNF0gbWVtb3J5IHggPSBbWzB4MSwgMV0sIFsweGZmZmZmZiwgMl0sIFsweGZmLCAzXSwgWzB4ZmZmZiwgNF1dOwogICAgICAgIHJldHVybiB4OwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 function f() public pure returns (uint24\[2\]\[4\] memory) {
 uint24\[2\]\[4\] memory x \= \[\[uint24(0x1), 1\], \[0xffffff, 2\], \[uint24(0xff), 3\], \[uint24(0xffff), 4\]\];
 // 下面的方法不会起作用，因为一些内部数组的类型不对。
 // uint\[2\]\[4\] memory x = \[\[0x1, 1\], \[0xffffff, 2\], \[0xff, 3\], \[0xffff, 4\]\];
 return x;
 }
}
固定大小的内存数组不能分配给动态大小的内存数组，也就是说，以下情况是不可能的：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKLy8g6L+Z5LiN5Lya6KKr57yW6K+R44CCCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyB7CiAgICAgICAgLy8g5LiL5LiA6KGM5Lya5Lqn55Sf5LiA5Liq57G75Z6L6ZSZ6K+v77yM5Zug5Li6dWludFszXeWGheWtmOS4jeiDveiiq+i9rOaNouS4unVpbnRbXeWGheWtmOOAggogICAgICAgIHVpbnRbXSBtZW1vcnkgeCA9IFt1aW50KDEpLCAzLCA0XTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
// 这不会被编译。
contract C {
 function f() public {
 // 下一行会产生一个类型错误，因为uint\[3\]内存不能被转换为uint\[\]内存。
 uint\[\] memory x \= \[uint(1), 3, 4\];
 }
}
计划在将来取消这一限制，但由于ABI中数组的传递方式，它产生了一些复杂的问题。
如果您想初始化动态大小的数组，您必须分配各个元素：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHsKICAgICAgICB1aW50W10gbWVtb3J5IHggPSBuZXcgdWludFtdKDMpOwogICAgICAgIHhbMF0gPSAxOwogICAgICAgIHhbMV0gPSAzOwogICAgICAgIHhbMl0gPSA0OwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 function f() public pure {
 uint\[\] memory x \= new uint\[\](3);
 x\[0\] \= 1;
 x\[1\] \= 3;
 x\[2\] \= 4;
 }
}
#### 数组成员[](#array-members "此标题的永久链接")
**length**:
数组有 `length` 成员变量表示当前数组的长度。一经创建， 内存memory数组的大小就是固定的（但却是动态的，也就是说，它依赖于运行时的参数）。
**push()**:
动态存储数组和 `bytes` （不是 `string` ）有一个叫 `push()` 的成员函数， 您可以用它在数组的末尾追加一个零初始化的元素。它返回一个元素的引用， 因此可以像 `x.push().t = 2` 或 `x.push() = b` 那样使用。
**push(x)**:
动态存储数组和 `bytes` （不是 `string` ）有一个叫 `push(x)` 的成员函数， 您可以用它在数组的末端追加一个指定的元素。该函数不返回任何东西。
**pop()**:
动态存储数组和 `bytes` （不是 `string` ）有一个叫 `pop()` 的成员函数， 您可以用它来从数组的末端移除一个元素。 这也隐含地在被删除的元素上调用 [delete](#delete)。该函数不返回任何东西。
备注
通过调用 `push()` 增加存储数组的长度有恒定的燃料成本，因为存储是零初始化的， 而通过调用 `pop()` 减少长度的成本取决于被移除元素的 “大小”。 如果该元素是一个数组，它的成本可能非常高， 因为它包括明确地清除被移除的元素，类似于对它们调用 [delete](#delete)。
备注
要在外部（而不是公开）函数中使用数组的数组， 您需要激活ABI coder v2。
备注
在Byzantium之前的EVM版本中，不能访问从函数调用返回的动态数组。 如果您调用返回动态数组的函数，请确保使用设置为Byzantium模式的EVM。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQXJyYXlDb250cmFjdCB7CiAgICB1aW50WzIqKjIwXSBhTG90T2ZJbnRlZ2VyczsKICAgIC8vIOivt+azqOaEj++8jOS4i+mdouS4jeaYr+S4gOWvueWKqOaAgeaVsOe7hO+8jAogICAgLy8g6ICM5piv5LiA5Liq5Yqo5oCB5pWw57uE5a+577yI5Y2z6ZW/5bqm5Li6MueahOWbuuWumuWkp+Wwj+aVsOe7hO+8ieOAggogICAgLy8g5ZyoIFNvbGlkaXR5IOS4re+8jFRba13lkoxUW13mgLvmmK/lhbfmnIlU57G75Z6L5YWD57Sg55qE5pWw57uE77yMCiAgICAvLyDljbPkvb9U5pys6Lqr5piv5LiA5Liq5pWw57uE44CCCiAgICAvLyDmraPlm6DkuLrlpoLmraTvvIxib29sWzJdW13mmK/kuIDkuKrliqjmgIHmlbDnu4Tlr7nvvIzlhbblhYPntKDmmK9ib29sWzJd44CCCiAgICAvLyDov5nkuI7lhbbku5bor63oqIDkuI3lkIzvvIzmr5TlpoJD77yMCiAgICAvLyDmiYDmnInnirbmgIHlj5jph4/nmoTmlbDmja7kvY3nva7pg73mmK/lrZjlgqjjgIIKICAgIGJvb2xbMl1bXSBwYWlyc09mRmxhZ3M7CgogICAgLy8gbmV3UGFpcnPooqvlrZjlgqjlnKhtZW1vcnnkuK0tLei/meaYr+WFrOW8gOWQiOe6puWHveaVsOWPguaVsOeahOWUr+S4gOWPr+iDveaAp+OAggogICAgZnVuY3Rpb24gc2V0QWxsRmxhZ1BhaXJzKGJvb2xbMl1bXSBtZW1vcnkgbmV3UGFpcnMpIHB1YmxpYyB7CiAgICAgICAgLy8g6LWL5YC85Yiw5LiA5Liq5a2Y5YKo5pWw57uE5Lya5omn6KGMIGBgbmV3UGFpcnNgYCDnmoTmi7fotJ3vvIwKICAgICAgICAvLyDlubbmm7/mjaLlrozmlbTnmoTmlbDnu4QgYGBwYWlyc09mRmxhZ3NgYOOAggogICAgICAgIHBhaXJzT2ZGbGFncyA9IG5ld1BhaXJzOwogICAgfQoKICAgIHN0cnVjdCBTdHJ1Y3RUeXBlIHsKICAgICAgICB1aW50W10gY29udGVudHM7CiAgICAgICAgdWludCBtb3JlSW5mbzsKICAgIH0KICAgIFN0cnVjdFR5cGUgczsKCiAgICBmdW5jdGlvbiBmKHVpbnRbXSBtZW1vcnkgYykgcHVibGljIHsKICAgICAgICAvLyDlnKggYGBnYGAg5Lit5a2Y5YKo5LiA5Liq5a+5IGBgc2BgIOeahOW8leeUqOOAggogICAgICAgIFN0cnVjdFR5cGUgc3RvcmFnZSBnID0gczsKICAgICAgICAvLyDkuZ/mlLnlj5jkuoYgYGBzLm1vcmVJbmZvYGAuCiAgICAgICAgZy5tb3JlSW5mbyA9IDI7CiAgICAgICAgLy8g5oyH5a6a5LiA5Liq5ou36LSd77yM5Zug5Li6IGBgZy5jb250ZW50c2BgIOS4jeaYr+S4gOS4quWxgOmDqOWPmOmHj++8jAogICAgICAgIC8vIOiAjOaYr+S4gOS4quWxgOmDqOWPmOmHj+eahOaIkOWRmOOAggogICAgICAgIGcuY29udGVudHMgPSBjOwogICAgfQoKICAgIGZ1bmN0aW9uIHNldEZsYWdQYWlyKHVpbnQgaW5kZXgsIGJvb2wgZmxhZ0EsIGJvb2wgZmxhZ0IpIHB1YmxpYyB7CiAgICAgICAgLy8g6K6/6Zeu5LiA5Liq5LiN5a2Y5Zyo55qE5pWw57uE57Si5byV5Lya5byV5Y+R5LiA5Liq5byC5bi4CiAgICAgICAgcGFpcnNPZkZsYWdzW2luZGV4XVswXSA9IGZsYWdBOwogICAgICAgIHBhaXJzT2ZGbGFnc1tpbmRleF1bMV0gPSBmbGFnQjsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGFuZ2VGbGFnQXJyYXlTaXplKHVpbnQgbmV3U2l6ZSkgcHVibGljIHsKICAgICAgICAvLyDkvb/nlKhwdXNo5ZKMcG9w5piv5pS55Y+Y5pWw57uE6ZW/5bqm55qE5ZSv5LiA5pa55rOV44CCCiAgICAgICAgaWYgKG5ld1NpemUgPCBwYWlyc09mRmxhZ3MubGVuZ3RoKSB7CiAgICAgICAgICAgIHdoaWxlIChwYWlyc09mRmxhZ3MubGVuZ3RoID4gbmV3U2l6ZSkKICAgICAgICAgICAgICAgIHBhaXJzT2ZGbGFncy5wb3AoKTsKICAgICAgICB9IGVsc2UgaWYgKG5ld1NpemUgPiBwYWlyc09mRmxhZ3MubGVuZ3RoKSB7CiAgICAgICAgICAgIHdoaWxlIChwYWlyc09mRmxhZ3MubGVuZ3RoIDwgbmV3U2l6ZSkKICAgICAgICAgICAgICAgIHBhaXJzT2ZGbGFncy5wdXNoKCk7CiAgICAgICAgfQogICAgfQoKICAgIGZ1bmN0aW9uIGNsZWFyKCkgcHVibGljIHsKICAgICAgICAvLyDov5nkupvlrozlhajmuIXpmaTkuobmlbDnu4QKICAgICAgICBkZWxldGUgcGFpcnNPZkZsYWdzOwogICAgICAgIGRlbGV0ZSBhTG90T2ZJbnRlZ2VyczsKICAgICAgICAvLyDov5nph4zmnInnm7jlkIznmoTmlYjmnpwKICAgICAgICBwYWlyc09mRmxhZ3MgPSBuZXcgYm9vbFsyXVtdKDApOwogICAgfQoKICAgIGJ5dGVzIGJ5dGVEYXRhOwoKICAgIGZ1bmN0aW9uIGJ5dGVBcnJheXMoYnl0ZXMgbWVtb3J5IGRhdGEpIHB1YmxpYyB7CiAgICAgICAgLy8g5a2X6IqC5pWw57uE77yIImJ5dGUi77yJ5piv5LiN5ZCM55qE77yM5Zug5Li65a6D5Lus55qE5a2Y5YKo5rKh5pyJ5aGr5YWF77yMCiAgICAgICAgLy8g5L2G5Y+v5Lul5LiOICJ1aW50OFtdIuebuOWQjOOAggogICAgICAgIGJ5dGVEYXRhID0gZGF0YTsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCA3OyBpKyspCiAgICAgICAgICAgIGJ5dGVEYXRhLnB1c2goKTsKICAgICAgICBieXRlRGF0YVszXSA9IDB4MDg7CiAgICAgICAgZGVsZXRlIGJ5dGVEYXRhWzJdOwogICAgfQoKICAgIGZ1bmN0aW9uIGFkZEZsYWcoYm9vbFsyXSBtZW1vcnkgZmxhZykgcHVibGljIHJldHVybnMgKHVpbnQpIHsKICAgICAgICBwYWlyc09mRmxhZ3MucHVzaChmbGFnKTsKICAgICAgICByZXR1cm4gcGFpcnNPZkZsYWdzLmxlbmd0aDsKICAgIH0KCiAgICBmdW5jdGlvbiBjcmVhdGVNZW1vcnlBcnJheSh1aW50IHNpemUpIHB1YmxpYyBwdXJlIHJldHVybnMgKGJ5dGVzIG1lbW9yeSkgewogICAgICAgIC8vIOS9v+eUqCBgbmV3YCDliJvlu7rliqjmgIEgbWVtb3J5IOaVsOe7hO+8mgogICAgICAgIHVpbnRbMl1bXSBtZW1vcnkgYXJyYXlPZlBhaXJzID0gbmV3IHVpbnRbMl1bXShzaXplKTsKCiAgICAgICAgLy8g5YaF6IGU5pWw57uE5oC75piv6Z2Z5oCB5aSn5bCP55qE77yM5aaC5p6c5oKo5Y+q5L2/55So5a2X6Z2i5bi45pWw6KGo6L6+5byP77yM5oKo5b+F6aG76Iez5bCR5o+Q5L6b5LiA56eN57G75Z6L44CCCiAgICAgICAgYXJyYXlPZlBhaXJzWzBdID0gW3VpbnQoMSksIDJdOwoKICAgICAgICAvLyDliJvlu7rkuIDkuKrliqjmgIHlrZfoioLmlbDnu4TvvJoKICAgICAgICBieXRlcyBtZW1vcnkgYiA9IG5ldyBieXRlcygyMDApOwogICAgICAgIGZvciAodWludCBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspCiAgICAgICAgICAgIGJbaV0gPSBieXRlczEodWludDgoaSkpOwogICAgICAgIHJldHVybiBiOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract ArrayContract {
 uint\[2\*\*20\] aLotOfIntegers;
 // 请注意，下面不是一对动态数组，
 // 而是一个动态数组对（即长度为2的固定大小数组）。
 // 在 Solidity 中，T\[k\]和T\[\]总是具有T类型元素的数组，
 // 即使T本身是一个数组。
 // 正因为如此，bool\[2\]\[\]是一个动态数组对，其元素是bool\[2\]。
 // 这与其他语言不同，比如C，
 // 所有状态变量的数据位置都是存储。
 bool\[2\]\[\] pairsOfFlags;
 // newPairs被存储在memory中--这是公开合约函数参数的唯一可能性。
 function setAllFlagPairs(bool\[2\]\[\] memory newPairs) public {
 // 赋值到一个存储数组会执行 \`\`newPairs\`\` 的拷贝，
 // 并替换完整的数组 \`\`pairsOfFlags\`\`。
 pairsOfFlags \= newPairs;
 }
 struct StructType {
 uint\[\] contents;
 uint moreInfo;
 }
 StructType s;
 function f(uint\[\] memory c) public {
 // 在 \`\`g\`\` 中存储一个对 \`\`s\`\` 的引用。
 StructType storage g \= s;
 // 也改变了 \`\`s.moreInfo\`\`.
 g.moreInfo \= 2;
 // 指定一个拷贝，因为 \`\`g.contents\`\` 不是一个局部变量，
 // 而是一个局部变量的成员。
 g.contents \= c;
 }
 function setFlagPair(uint index, bool flagA, bool flagB) public {
 // 访问一个不存在的数组索引会引发一个异常
 pairsOfFlags\[index\]\[0\] \= flagA;
 pairsOfFlags\[index\]\[1\] \= flagB;
 }
 function changeFlagArraySize(uint newSize) public {
 // 使用push和pop是改变数组长度的唯一方法。
 if (newSize < pairsOfFlags.length) {
 while (pairsOfFlags.length \> newSize)
 pairsOfFlags.pop();
 } else if (newSize \> pairsOfFlags.length) {
 while (pairsOfFlags.length < newSize)
 pairsOfFlags.push();
 }
 }
 function clear() public {
 // 这些完全清除了数组
 delete pairsOfFlags;
 delete aLotOfIntegers;
 // 这里有相同的效果
 pairsOfFlags \= new bool\[2\]\[\](0);
 }
 bytes byteData;
 function byteArrays(bytes memory data) public {
 // 字节数组（"byte"）是不同的，因为它们的存储没有填充，
 // 但可以与 "uint8\[\]"相同。
 byteData \= data;
 for (uint i \= 0; i < 7; i++)
 byteData.push();
 byteData\[3\] \= 0x08;
 delete byteData\[2\];
 }
 function addFlag(bool\[2\] memory flag) public returns (uint) {
 pairsOfFlags.push(flag);
 return pairsOfFlags.length;
 }
 function createMemoryArray(uint size) public pure returns (bytes memory) {
 // 使用 \`new\` 创建动态 memory 数组：
 uint\[2\]\[\] memory arrayOfPairs \= new uint\[2\]\[\](size);
 // 内联数组总是静态大小的，如果您只使用字面常数表达式，您必须至少提供一种类型。
 arrayOfPairs\[0\] \= \[uint(1), 2\];
 // 创建一个动态字节数组：
 bytes memory b \= new bytes(200);
 for (uint i \= 0; i < b.length; i++)
 b\[i\] \= bytes1(uint8(i));
 return b;
 }
}
#### 对存储数组元素的悬空引用（Dangling References）[](#dangling-references "此标题的永久链接")
当使用存储数组时，您需要注意避免悬空引用。 悬空引用是指一个指向不再存在的或已经被移动而未更新引用的内容的引用。 例如，如果您将一个数组元素的引用存储在一个局部变量中， 然后从包含数组中使用 `.pop()`，就可能发生悬空引用：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50W11bXSBzOwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIC8vIOWtmOWCqOS4gOS4quaMh+WQkXPnmoTmnIDlkI7kuIDkuKrmlbDnu4TlhYPntKDnmoTmjIfpkojjgIIKICAgICAgICB1aW50W10gc3RvcmFnZSBwdHIgPSBzW3MubGVuZ3RoIC0gMV07CiAgICAgICAgLy8g5Yig6Zmkc+eahOacgOWQjuS4gOS4quaVsOe7hOWFg+e0oOOAggogICAgICAgIHMucG9wKCk7CiAgICAgICAgLy8g5YaZ5YWl5bey5LiN5Zyo5pWw57uE5YaF55qE5pWw57uE5YWD57Sg44CCCiAgICAgICAgcHRyLnB1c2goMHg0Mik7CiAgICAgICAgLy8g546w5Zyo5ZCRIGBgc2BgIOa3u+WKoOS4gOS4quaWsOWFg+e0oOS4jeS8mua3u+WKoOS4gOS4quepuuaVsOe7hO+8jAogICAgICAgIC8vIOiAjOaYr+S8muS6p+eUn+S4gOS4qumVv+W6puS4ujHnmoTmlbDnu4TvvIzlhYPntKDkuLogYGAweDQyYGDjgIIKICAgICAgICBzLnB1c2goKTsKICAgICAgICBhc3NlcnQoc1tzLmxlbmd0aCAtIDFdWzBdID09IDB4NDIpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0 <0.9.0;
contract C {
 uint\[\]\[\] s;
 function f() public {
 // 存储一个指向s的最后一个数组元素的指针。
 uint\[\] storage ptr \= s\[s.length \- 1\];
 // 删除s的最后一个数组元素。
 s.pop();
 // 写入已不在数组内的数组元素。
 ptr.push(0x42);
 // 现在向 \`\`s\`\` 添加一个新元素不会添加一个空数组，
 // 而是会产生一个长度为1的数组，元素为 \`\`0x42\`\`。
 s.push();
 assert(s\[s.length \- 1\]\[0\] \== 0x42);
 }
}
`ptr.push(0x42)` 中的写法 **不会** 恢复操作，尽管 `ptr` 不再指向 `s` 的一个有效元素。 由于编译器假定未使用的存储空间总是被清零， 随后的 `s.push()` 不会明确地将零写入存储空间， 所以在 `push()` 之后， `s` 的最后一个元素的长度是 `1`， 并且包含 `0x42` 作为其第一个元素。
注意，Solidity 不允许在存储中声明对值类型的引用。 这类显式的悬空引用被限制在嵌套引用类型中。然而， 当在数组赋值中使用复杂表达式时，悬空引用也会短暂发生：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50W10gczsKICAgIHVpbnRbXSB0OwogICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgLy8g5ZCR5a2Y5YKo5pWw57uE5o6o6YCB5LiA5Lqb5Yid5aeL5YC844CCCiAgICAgICAgcy5wdXNoKDB4MDcpOwogICAgICAgIHQucHVzaCgweDAzKTsKICAgIH0KCiAgICBmdW5jdGlvbiBnKCkgaW50ZXJuYWwgcmV0dXJucyAodWludFtdIHN0b3JhZ2UpIHsKICAgICAgICBzLnBvcCgpOwogICAgICAgIHJldHVybiB0OwogICAgfQoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgcmV0dXJucyAodWludFtdIG1lbW9yeSkgewogICAgICAgIC8vIOS4i+mdouWwhummluWFiOivhOS8sCBgYHMucHVzaCgpYCDliLDkuIDkuKrntKLlvJXkuLox55qE5paw5YWD57Sg55qE5byV55So44CCCiAgICAgICAgLy8g5LmL5ZCO77yM6LCD55SoIGBgZ2BgIOW8ueWHuui/meS4quaWsOWFg+e0oO+8jAogICAgICAgIC8vIOWvvOiHtOacgOW3pui+ueeahOWFg+e7hOWFg+e0oOaIkOS4uuS4gOS4quaCrOepuueahOW8leeUqOOAggogICAgICAgIC8vIOi1i+WAvOS7jeeEtuWPkeeUn++8jOW5tuWwhuWGmeWFpSBgYHNgYCDnmoTmlbDmja7ljLrln5/kuYvlpJbjgIIKICAgICAgICAocy5wdXNoKCksIGcoKVswXSkgPSAoMHg0MiwgMHgxNyk7CiAgICAgICAgLy8g6ZqP5ZCO5a+5IGBgc2BgIOeahOaOqOmAgeWwhuaYvuekuuWJjeS4gOS4quivreWPpeWGmeWFpeeahOWAvO+8jAogICAgICAgIC8vIOWNs+WcqOi/meS4quWHveaVsOe7k+adn+aXtiBgYHNgYCDnmoTmnIDlkI7kuIDkuKrlhYPntKDlsIbmnIkgYGAweDQyYGAg55qE5YC844CCCiAgICAgICAgcy5wdXNoKCk7CiAgICAgICAgcmV0dXJuIHM7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0 <0.9.0;
contract C {
 uint\[\] s;
 uint\[\] t;
 constructor() {
 // 向存储数组推送一些初始值。
 s.push(0x07);
 t.push(0x03);
 }
 function g() internal returns (uint\[\] storage) {
 s.pop();
 return t;
 }
 function f() public returns (uint\[\] memory) {
 // 下面将首先评估 \`\`s.push()\` 到一个索引为1的新元素的引用。
 // 之后，调用 \`\`g\`\` 弹出这个新元素，
 // 导致最左边的元组元素成为一个悬空的引用。
 // 赋值仍然发生，并将写入 \`\`s\`\` 的数据区域之外。
 (s.push(), g()\[0\]) \= (0x42, 0x17);
 // 随后对 \`\`s\`\` 的推送将显示前一个语句写入的值，
 // 即在这个函数结束时 \`\`s\`\` 的最后一个元素将有 \`\`0x42\`\` 的值。
 s.push();
 return s;
 }
}
每条语句只对存储进行一次赋值，并避免在赋值的左侧使用复杂的表达式，这样做总是比较安全的。
您需要特别小心处理对 `bytes` 数组元素的引用， 因为 bytes 数组的 `.push()` 操作可能会 [在存储中从短布局切换到长布局](https://docs.soliditylang.org/zh-cn/latest/internals/layout_in_storage.html#bytes-and-string)。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjAgPDAuOS4wOwoKLy8g6L+Z5bCG5oql5ZGK5LiA5Liq6K2m5ZGKCmNvbnRyYWN0IEMgewogICAgYnl0ZXMgeCA9ICIwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkiOwoKICAgIGZ1bmN0aW9uIHRlc3QoKSBleHRlcm5hbCByZXR1cm5zKHVpbnQpIHsKICAgICAgICAoeC5wdXNoKCksIHgucHVzaCgpKSA9ICgweDAxLCAweDAyKTsKICAgICAgICByZXR1cm4geC5sZW5ndGg7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0 <0.9.0;
// 这将报告一个警告
contract C {
 bytes x \= "012345678901234567890123456789";
 function test() external returns(uint) {
 (x.push(), x.push()) \= (0x01, 0x02);
 return x.length;
 }
}
这里，当第一个 `x.push()` 被运算时， `x` 仍然被存储在短布局中， 因此 `x.push()` 返回对 `x` 的第一个存储槽中元素的引用。 然而，第二个 `x.push()` 将字节数组切换为长布局。 现在 `x.push()` 所指的元素在数组的数据区， 而引用仍然指向它原来的位置，现在它是长度字段的一部分， 赋值将有效地扰乱 `x` 的长度。 为了安全起见，在一次赋值中最多只放大字节数组中的一个元素， 不要在同一语句中同时对数组进行索引存取。
虽然上面描述了当前版本的编译器中悬空存储引用的行为， 但任何带有悬空引用的代码都应被视为具有 _未定义行为_。 特别的是，这意味着任何未来版本的编译器都可能改变涉及悬空引用的代码的行为。
请确保避免在您的代码中出现悬空引用。
### 数组切片[](#array-slices "此标题的永久链接")
数组切片是对一个数组的连续部分的预览。 它们被写成 `x[start:end]`，其中 `start` 和 `end` 是表达式， 结果是uint256类型（或隐含的可转换类型）。分片的第一个元素是 `x[start]`， 最后一个元素是 `x[end - 1]`。
如果 `start` 大于 `end`，或者 `end` 大于数组的长度， 就会出现异常。
`start` 和 `end` 都是可选的： `start` 默认为 `0`， `end` 默认为数组的长度。
数组切片没有任何成员。它们可以隐含地转换为其底层类型的数组并支持索引访问。 索引访问在底层数组中不是绝对的，而是相对于分片的开始。
数组切片没有类型名，这意味着任何变量都不能以数组切片为类型， 它们只存在于中间表达式中。
备注
到现在为止，数组切片只有calldata数组可以实现。
数组切片对于ABI解码在函数参数中传递的二级数据很有用：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjUgPDAuOS4wOwpjb250cmFjdCBQcm94eSB7CiAgICAvLy8gQGRldiDnlLHku6PnkIbnrqHnkIbnmoTlrqLmiLflkIjnuqbnmoTlnLDlnYDvvIzljbPmnKzlkIjnuqbnmoTlnLDlnYAKICAgIGFkZHJlc3MgY2xpZW50OwoKICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MgY2xpZW50XykgewogICAgICAgIGNsaWVudCA9IGNsaWVudF87CiAgICB9CgogICAgLy8vIOi9rOWPkeWvuSAic2V0T3duZXIoYWRkcmVzcykiIOeahOiwg+eUqO+8jAogICAgLy8vIOivpeiwg+eUqOWcqOWvueWcsOWdgOWPguaVsOi/m+ihjOWfuuacrOmqjOivgeWQjueUseWuouaIt+err+aJp+ihjOOAggogICAgZnVuY3Rpb24gZm9yd2FyZChieXRlcyBjYWxsZGF0YSBwYXlsb2FkKSBleHRlcm5hbCB7CiAgICAgICAgYnl0ZXM0IHNpZyA9IGJ5dGVzNChwYXlsb2FkWzo0XSk7CiAgICAgICAgLy8g55Sx5LqO5oiq5pat6KGM5Li677yMYnl0ZXM0KHBheWxvYWQp55qE6KGo546w5piv55u45ZCM55qE44CCCiAgICAgICAgLy8gYnl0ZXM0IHNpZyA9IGJ5dGVzNChwYXlsb2FkKTsKICAgICAgICBpZiAoc2lnID09IGJ5dGVzNChrZWNjYWsyNTYoInNldE93bmVyKGFkZHJlc3MpIikpKSB7CiAgICAgICAgICAgIGFkZHJlc3Mgb3duZXIgPSBhYmkuZGVjb2RlKHBheWxvYWRbNDpdLCAoYWRkcmVzcykpOwogICAgICAgICAgICByZXF1aXJlKG93bmVyICE9IGFkZHJlc3MoMCksICJBZGRyZXNzIG9mIG93bmVyIGNhbm5vdCBiZSB6ZXJvLiIpOwogICAgICAgIH0KICAgICAgICAoYm9vbCBzdGF0dXMsKSA9IGNsaWVudC5kZWxlZ2F0ZWNhbGwocGF5bG9hZCk7CiAgICAgICAgcmVxdWlyZShzdGF0dXMsICJGb3J3YXJkZWQgY2FsbCBmYWlsZWQuIik7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.5 <0.9.0;
contract Proxy {
 /// @dev 由代理管理的客户合约的地址，即本合约的地址
 address client;
 constructor(address client\_) {
 client \= client\_;
 }
 /// 转发对 "setOwner(address)" 的调用，
 /// 该调用在对地址参数进行基本验证后由客户端执行。
 function forward(bytes calldata payload) external {
 bytes4 sig \= bytes4(payload\[:4\]);
 // 由于截断行为，bytes4(payload)的表现是相同的。
 // bytes4 sig = bytes4(payload);
 if (sig \== bytes4(keccak256("setOwner(address)"))) {
 address owner \= abi.decode(payload\[4:\], (address));
 require(owner != address(0), "Address of owner cannot be zero.");
 }
 (bool status,) \= client.delegatecall(payload);
 require(status, "Forwarded call failed.");
 }
}
### 结构体[](#structs "此标题的永久链接")
Solidity 提供了一种以结构形式定义新类型的方法，以下是一个结构体使用的示例：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKLy8g5a6a5LmJ5LiA5Liq5YyF5ZCr5Lik5Liq5bGe5oCn55qE5paw57G75Z6L44CCCi8vIOWcqOWQiOe6puS5i+WkluWjsOaYjuS4gOS4que7k+aehO+8jAovLyDlj6/ku6XorqnlroPooqvlpJrkuKrlkIjnuqbmiYDlhbHkuqvjgIIKLy8g5Zyo6L+Z6YeM77yM6L+Z5bm25LiN5piv55yf55qE6ZyA6KaB44CCCnN0cnVjdCBGdW5kZXIgewogICAgYWRkcmVzcyBhZGRyOwogICAgdWludCBhbW91bnQ7Cn0KCmNvbnRyYWN0IENyb3dkRnVuZGluZyB7CiAgICAvLyDnu5PmnoTkvZPkuZ/lj6/ku6XooqvlrprkuYnlnKjlkIjnuqblhoXpg6jvvIzov5nkvb/lvpflroPku6zlj6rlnKjmnKzlkIjnuqblkozmtL7nlJ/lkIjnuqbkuK3lj6/op4HjgIIKICAgIHN0cnVjdCBDYW1wYWlnbiB7CiAgICAgICAgYWRkcmVzcyBwYXlhYmxlIGJlbmVmaWNpYXJ5OwogICAgICAgIHVpbnQgZnVuZGluZ0dvYWw7CiAgICAgICAgdWludCBudW1GdW5kZXJzOwogICAgICAgIHVpbnQgYW1vdW50OwogICAgICAgIG1hcHBpbmcodWludCA9PiBGdW5kZXIpIGZ1bmRlcnM7CiAgICB9CgogICAgdWludCBudW1DYW1wYWlnbnM7CiAgICBtYXBwaW5nKHVpbnQgPT4gQ2FtcGFpZ24pIGNhbXBhaWduczsKCiAgICBmdW5jdGlvbiBuZXdDYW1wYWlnbihhZGRyZXNzIHBheWFibGUgYmVuZWZpY2lhcnksIHVpbnQgZ29hbCkgcHVibGljIHJldHVybnMgKHVpbnQgY2FtcGFpZ25JRCkgewogICAgICAgIGNhbXBhaWduSUQgPSBudW1DYW1wYWlnbnMrKzsgLy8gY2FtcGFpZ25JRCDkvZzkuLrkuIDkuKrlj5jph4/ov5Tlm54KICAgICAgICAvLyDmiJHku6zkuI3og73kvb/nlKggImNhbXBhaWduc1tjYW1wYWlnbklEXSA9IENhbXBhaWduKGJlbmVmaWNpYXJ5LCBnb2FsLCAwLCAwKSIKICAgICAgICAvLyDlm6DkuLrlj7PkvqfliJvlu7rkuobkuIDkuKrlhoXlrZjnu5PmnoQgIkNhbXBhaWduIu+8jOWFtuS4reWMheWQq+S4gOS4quaYoOWwhOOAggogICAgICAgIENhbXBhaWduIHN0b3JhZ2UgYyA9IGNhbXBhaWduc1tjYW1wYWlnbklEXTsKICAgICAgICBjLmJlbmVmaWNpYXJ5ID0gYmVuZWZpY2lhcnk7CiAgICAgICAgYy5mdW5kaW5nR29hbCA9IGdvYWw7CiAgICB9CgogICAgZnVuY3Rpb24gY29udHJpYnV0ZSh1aW50IGNhbXBhaWduSUQpIHB1YmxpYyBwYXlhYmxlIHsKICAgICAgICBDYW1wYWlnbiBzdG9yYWdlIGMgPSBjYW1wYWlnbnNbY2FtcGFpZ25JRF07CiAgICAgICAgLy8g5Lul57uZ5a6a55qE5YC85Yid5aeL5YyW77yM5Yib5bu65LiA5Liq5paw55qE5Li05pe2IG1lbW9yeSDnu5PmnoTkvZPvvIwKICAgICAgICAvLyDlubblsIblhbbmi7fotJ3liLAgc3RvcmFnZSDkuK3jgIIKICAgICAgICAvLyDms6jmhI/mgqjkuZ/lj6/ku6Xkvb/nlKggRnVuZGVyKG1zZy5zZW5kZXIsIG1zZy52YWx1ZSkg5p2l5Yid5aeL5YyW44CCCiAgICAgICAgYy5mdW5kZXJzW2MubnVtRnVuZGVycysrXSA9IEZ1bmRlcih7YWRkcjogbXNnLnNlbmRlciwgYW1vdW50OiBtc2cudmFsdWV9KTsKICAgICAgICBjLmFtb3VudCArPSBtc2cudmFsdWU7CiAgICB9CgogICAgZnVuY3Rpb24gY2hlY2tHb2FsUmVhY2hlZCh1aW50IGNhbXBhaWduSUQpIHB1YmxpYyByZXR1cm5zIChib29sIHJlYWNoZWQpIHsKICAgICAgICBDYW1wYWlnbiBzdG9yYWdlIGMgPSBjYW1wYWlnbnNbY2FtcGFpZ25JRF07CiAgICAgICAgaWYgKGMuYW1vdW50IDwgYy5mdW5kaW5nR29hbCkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIHVpbnQgYW1vdW50ID0gYy5hbW91bnQ7CiAgICAgICAgYy5hbW91bnQgPSAwOwogICAgICAgIGMuYmVuZWZpY2lhcnkudHJhbnNmZXIoYW1vdW50KTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
// 定义一个包含两个属性的新类型。
// 在合约之外声明一个结构，
// 可以让它被多个合约所共享。
// 在这里，这并不是真的需要。
struct Funder {
 address addr;
 uint amount;
}
contract CrowdFunding {
 // 结构体也可以被定义在合约内部，这使得它们只在本合约和派生合约中可见。
 struct Campaign {
 address payable beneficiary;
 uint fundingGoal;
 uint numFunders;
 uint amount;
 mapping(uint \=> Funder) funders;
 }
 uint numCampaigns;
 mapping(uint \=> Campaign) campaigns;
 function newCampaign(address payable beneficiary, uint goal) public returns (uint campaignID) {
 campaignID \= numCampaigns++; // campaignID 作为一个变量返回
 // 我们不能使用 "campaigns\[campaignID\] = Campaign(beneficiary, goal, 0, 0)"
 // 因为右侧创建了一个内存结构 "Campaign"，其中包含一个映射。
 Campaign storage c \= campaigns\[campaignID\];
 c.beneficiary \= beneficiary;
 c.fundingGoal \= goal;
 }
 function contribute(uint campaignID) public payable {
 Campaign storage c \= campaigns\[campaignID\];
 // 以给定的值初始化，创建一个新的临时 memory 结构体，
 // 并将其拷贝到 storage 中。
 // 注意您也可以使用 Funder(msg.sender, msg.value) 来初始化。
 c.funders\[c.numFunders++\] \= Funder({addr: msg.sender, amount: msg.value});
 c.amount += msg.value;
 }
 function checkGoalReached(uint campaignID) public returns (bool reached) {
 Campaign storage c \= campaigns\[campaignID\];
 if (c.amount < c.fundingGoal)
 return false;
 uint amount \= c.amount;
 c.amount \= 0;
 c.beneficiary.transfer(amount);
 return true;
 }
}
上面的合约并没有提供众筹合约的全部功能， 但它包含了理解结构体所需的基本概念。 结构类型可以在映射和数组内使用， 它们本身可以包含映射和数组。
结构体不可能包含其自身类型的成员，尽管结构本身可以是映射成员的值类型， 或者它可以包含其类型的动态大小的数组。 这一限制是必要的，因为结构的大小必须是有限的。
注意在所有的函数中，结构类型被分配到数据位置为 `storage` 的局部变量。 这并不是拷贝结构体，而只是存储一个引用， 因此对本地变量成员的赋值实际上是写入状态。
当然，您也可以直接访问该结构的成员， 而不把它分配给本地变量，如 `campaigns[campaignID].amount = 0`。
备注
在 Solidity 0.7.0 之前，包含仅有存储类型（例如映射）的成员的内存结构是允许的， 像上面例子中的 `campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0)` 这样的赋值是可以的， 只是会默默地跳过这些成员。
## 映射类型[](#mapping-types "此标题的永久链接")
映射类型使用语法 `mapping(KeyType KeyName? => ValueType ValueName?)`， 映射类型的变量使用语法 `mapping(KeyType KeyName? => ValueType ValueName?) VariableName` 声明。 `KeyType` 可以是任何内置的值类型， `bytes`， `string`，或任何合约或枚举类型。 其他用户定义的或复杂的类型，如映射，结构体或数组类型是不允许的。 `ValueType` 可以是任何类型，包括映射，数组和结构体。 `KeyName` 和 `ValueName` 是可选的（所以 `mapping(KeyType => ValueType)` 也可以使用）， 可以是任何有效的标识符，而不是一个类型。
您可以把映射想象成 [哈希表](https://en.wikipedia.org/wiki/Hash_table)， 它实际上被初始化了，使每一个可能的键都存在， 并将其映射到字节形式全是零的值，一个类型的 [默认值](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#default-value)。 相似性到此为止，键数据不存储在映射中，而是它的 `keccak256` 哈希值被用来查询。
正因为如此，映射没有长度，也没有被设置的键或值的概念， 因此，如果没有关于分配的键的额外信息，就不能被删除（见 [清除映射](https://docs.soliditylang.org/zh-cn/latest/security-considerations.html#clearing-mappings)）。
映射只能有一个 `storage` 的数据位置，因此允许用于状态变量， 可作为函数中的存储引用类型，或作为库函数的参数。 但它们不能被用作公开可见的合约函数的参数或返回参数。 这些限制对于包含映射的数组和结构也是如此。
您可以把映射类型的状态变量标记为 `public`， Solidity 会为您创建一个 [getter](https://docs.soliditylang.org/zh-cn/latest/contracts.html#visibility-and-getters) 函数。 `KeyType` 成为 getter 函数的参数，名称为 `KeyName` （如果指定）。 如果 `ValueType` 是一个值类型或一个结构，getter 返回 `ValueType`， 名称为 `ValueName` （如果指定）。 如果 `ValueType` 是一个数组或映射，getter 对每个 `KeyType` 递归出一个参数。
在下面的例子中， `MappingExample` 合约定义了一个公共的 `balances` 映射， 键类型是 `address`，值类型是 `uint`，将一个Ethereum地址映射到一个无符号整数值。 由于 `uint` 是一个值类型，getter 返回一个与该类型相匹配的值， 您可以在 `MappingUser` 合约中看到它返回指定地址对应的值。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgTWFwcGluZ0V4YW1wbGUgewogICAgbWFwcGluZyhhZGRyZXNzID0+IHVpbnQpIHB1YmxpYyBiYWxhbmNlczsKCiAgICBmdW5jdGlvbiB1cGRhdGUodWludCBuZXdCYWxhbmNlKSBwdWJsaWMgewogICAgICAgIGJhbGFuY2VzW21zZy5zZW5kZXJdID0gbmV3QmFsYW5jZTsKICAgIH0KfQoKY29udHJhY3QgTWFwcGluZ1VzZXIgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgTWFwcGluZ0V4YW1wbGUgbSA9IG5ldyBNYXBwaW5nRXhhbXBsZSgpOwogICAgICAgIG0udXBkYXRlKDEwMCk7CiAgICAgICAgcmV0dXJuIG0uYmFsYW5jZXMoYWRkcmVzcyh0aGlzKSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract MappingExample {
 mapping(address \=> uint) public balances;
 function update(uint newBalance) public {
 balances\[msg.sender\] \= newBalance;
 }
}
contract MappingUser {
 function f() public returns (uint) {
 MappingExample m \= new MappingExample();
 m.update(100);
 return m.balances(address(this));
 }
}
下面的例子是一个简化版本的 [ERC20 代币](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)。 `_allowances` 是一个映射类型在另一个映射类型中的例子。
在下面的例子中，为映射提供了可选的 `KeyName` 和 `ValueName`。 它不影响任何合约的功能或字节码， 它只是为映射的 getter 在 ABI 中设置输入和输出的 `name` 字段。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTg7Cgpjb250cmFjdCBNYXBwaW5nRXhhbXBsZVdpdGhOYW1lcyB7CiAgICBtYXBwaW5nKGFkZHJlc3MgdXNlciA9PiB1aW50IGJhbGFuY2UpIHB1YmxpYyBiYWxhbmNlczsKCiAgICBmdW5jdGlvbiB1cGRhdGUodWludCBuZXdCYWxhbmNlKSBwdWJsaWMgewogICAgICAgIGJhbGFuY2VzW21zZy5zZW5kZXJdID0gbmV3QmFsYW5jZTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.18;
contract MappingExampleWithNames {
 mapping(address user \=> uint balance) public balances;
 function update(uint newBalance) public {
 balances\[msg.sender\] \= newBalance;
 }
}
下面的例子使用 `_allowances` 来记录其他人可以从你的账户中提取的金额。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCmNvbnRyYWN0IE1hcHBpbmdFeGFtcGxlIHsKCiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gdWludDI1NikgcHJpdmF0ZSBfYmFsYW5jZXM7CiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gbWFwcGluZyhhZGRyZXNzID0+IHVpbnQyNTYpKSBwcml2YXRlIF9hbGxvd2FuY2VzOwoKICAgIGV2ZW50IFRyYW5zZmVyKGFkZHJlc3MgaW5kZXhlZCBmcm9tLCBhZGRyZXNzIGluZGV4ZWQgdG8sIHVpbnQyNTYgdmFsdWUpOwogICAgZXZlbnQgQXBwcm92YWwoYWRkcmVzcyBpbmRleGVkIG93bmVyLCBhZGRyZXNzIGluZGV4ZWQgc3BlbmRlciwgdWludDI1NiB2YWx1ZSk7CgogICAgZnVuY3Rpb24gYWxsb3dhbmNlKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3Mgc3BlbmRlcikgcHVibGljIHZpZXcgcmV0dXJucyAodWludDI1NikgewogICAgICAgIHJldHVybiBfYWxsb3dhbmNlc1tvd25lcl1bc3BlbmRlcl07CiAgICB9CgogICAgZnVuY3Rpb24gdHJhbnNmZXJGcm9tKGFkZHJlc3Mgc2VuZGVyLCBhZGRyZXNzIHJlY2lwaWVudCwgdWludDI1NiBhbW91bnQpIHB1YmxpYyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmVxdWlyZShfYWxsb3dhbmNlc1tzZW5kZXJdW21zZy5zZW5kZXJdID49IGFtb3VudCwgIkVSQzIwOiBBbGxvd2FuY2Ugbm90IGhpZ2ggZW5vdWdoLiIpOwogICAgICAgIF9hbGxvd2FuY2VzW3NlbmRlcl1bbXNnLnNlbmRlcl0gLT0gYW1vdW50OwogICAgICAgIF90cmFuc2ZlcihzZW5kZXIsIHJlY2lwaWVudCwgYW1vdW50KTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBhcHByb3ZlKGFkZHJlc3Mgc3BlbmRlciwgdWludDI1NiBhbW91bnQpIHB1YmxpYyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmVxdWlyZShzcGVuZGVyICE9IGFkZHJlc3MoMCksICJFUkMyMDogYXBwcm92ZSB0byB0aGUgemVybyBhZGRyZXNzIik7CgogICAgICAgIF9hbGxvd2FuY2VzW21zZy5zZW5kZXJdW3NwZW5kZXJdID0gYW1vdW50OwogICAgICAgIGVtaXQgQXBwcm92YWwobXNnLnNlbmRlciwgc3BlbmRlciwgYW1vdW50KTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBfdHJhbnNmZXIoYWRkcmVzcyBzZW5kZXIsIGFkZHJlc3MgcmVjaXBpZW50LCB1aW50MjU2IGFtb3VudCkgaW50ZXJuYWwgewogICAgICAgIHJlcXVpcmUoc2VuZGVyICE9IGFkZHJlc3MoMCksICJFUkMyMDogdHJhbnNmZXIgZnJvbSB0aGUgemVybyBhZGRyZXNzIik7CiAgICAgICAgcmVxdWlyZShyZWNpcGllbnQgIT0gYWRkcmVzcygwKSwgIkVSQzIwOiB0cmFuc2ZlciB0byB0aGUgemVybyBhZGRyZXNzIik7CiAgICAgICAgcmVxdWlyZShfYmFsYW5jZXNbc2VuZGVyXSA+PSBhbW91bnQsICJFUkMyMDogTm90IGVub3VnaCBmdW5kcy4iKTsKCiAgICAgICAgX2JhbGFuY2VzW3NlbmRlcl0gLT0gYW1vdW50OwogICAgICAgIF9iYWxhbmNlc1tyZWNpcGllbnRdICs9IGFtb3VudDsKICAgICAgICBlbWl0IFRyYW5zZmVyKHNlbmRlciwgcmVjaXBpZW50LCBhbW91bnQpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.22 <0.9.0;
contract MappingExample {
 mapping(address \=> uint256) private \_balances;
 mapping(address \=> mapping(address \=> uint256)) private \_allowances;
 event Transfer(address indexed from, address indexed to, uint256 value);
 event Approval(address indexed owner, address indexed spender, uint256 value);
 function allowance(address owner, address spender) public view returns (uint256) {
 return \_allowances\[owner\]\[spender\];
 }
 function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
 require(\_allowances\[sender\]\[msg.sender\] \>= amount, "ERC20: Allowance not high enough.");
 \_allowances\[sender\]\[msg.sender\] \-= amount;
 \_transfer(sender, recipient, amount);
 return true;
 }
 function approve(address spender, uint256 amount) public returns (bool) {
 require(spender != address(0), "ERC20: approve to the zero address");
 \_allowances\[msg.sender\]\[spender\] \= amount;
 emit Approval(msg.sender, spender, amount);
 return true;
 }
 function \_transfer(address sender, address recipient, uint256 amount) internal {
 require(sender != address(0), "ERC20: transfer from the zero address");
 require(recipient != address(0), "ERC20: transfer to the zero address");
 require(\_balances\[sender\] \>= amount, "ERC20: Not enough funds.");
 \_balances\[sender\] \-= amount;
 \_balances\[recipient\] += amount;
 emit Transfer(sender, recipient, amount);
 }
}
### 递归映射[](#iterable-mappings "此标题的永久链接")
您不能对映射进行递归调用，也就是说，您不能列举它们的键。 不过，可以在它们上层实现一个数据结构，并对其进行递归。例如， 下面的代码实现了一个 `IterableMapping` 库， 然后 `User` 合约将数据添加到该库中， `sum` 函数对所有的值进行递归调用去累加这些值。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguODsKCnN0cnVjdCBJbmRleFZhbHVlIHsgdWludCBrZXlJbmRleDsgdWludCB2YWx1ZTsgfQpzdHJ1Y3QgS2V5RmxhZyB7IHVpbnQga2V5OyBib29sIGRlbGV0ZWQ7IH0KCnN0cnVjdCBpdG1hcCB7CiAgICBtYXBwaW5nKHVpbnQgPT4gSW5kZXhWYWx1ZSkgZGF0YTsKICAgIEtleUZsYWdbXSBrZXlzOwogICAgdWludCBzaXplOwp9Cgp0eXBlIEl0ZXJhdG9yIGlzIHVpbnQ7CgpsaWJyYXJ5IEl0ZXJhYmxlTWFwcGluZyB7CiAgICBmdW5jdGlvbiBpbnNlcnQoaXRtYXAgc3RvcmFnZSBzZWxmLCB1aW50IGtleSwgdWludCB2YWx1ZSkgaW50ZXJuYWwgcmV0dXJucyAoYm9vbCByZXBsYWNlZCkgewogICAgICAgIHVpbnQga2V5SW5kZXggPSBzZWxmLmRhdGFba2V5XS5rZXlJbmRleDsKICAgICAgICBzZWxmLmRhdGFba2V5XS52YWx1ZSA9IHZhbHVlOwogICAgICAgIGlmIChrZXlJbmRleCA+IDApCiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIGVsc2UgewogICAgICAgICAgICBrZXlJbmRleCA9IHNlbGYua2V5cy5sZW5ndGg7CiAgICAgICAgICAgIHNlbGYua2V5cy5wdXNoKCk7CiAgICAgICAgICAgIHNlbGYuZGF0YVtrZXldLmtleUluZGV4ID0ga2V5SW5kZXggKyAxOwogICAgICAgICAgICBzZWxmLmtleXNba2V5SW5kZXhdLmtleSA9IGtleTsKICAgICAgICAgICAgc2VsZi5zaXplKys7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gcmVtb3ZlKGl0bWFwIHN0b3JhZ2Ugc2VsZiwgdWludCBrZXkpIGludGVybmFsIHJldHVybnMgKGJvb2wgc3VjY2VzcykgewogICAgICAgIHVpbnQga2V5SW5kZXggPSBzZWxmLmRhdGFba2V5XS5rZXlJbmRleDsKICAgICAgICBpZiAoa2V5SW5kZXggPT0gMCkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIGRlbGV0ZSBzZWxmLmRhdGFba2V5XTsKICAgICAgICBzZWxmLmtleXNba2V5SW5kZXggLSAxXS5kZWxldGVkID0gdHJ1ZTsKICAgICAgICBzZWxmLnNpemUgLS07CiAgICB9CgogICAgZnVuY3Rpb24gY29udGFpbnMoaXRtYXAgc3RvcmFnZSBzZWxmLCB1aW50IGtleSkgaW50ZXJuYWwgdmlldyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmV0dXJuIHNlbGYuZGF0YVtrZXldLmtleUluZGV4ID4gMDsKICAgIH0KCiAgICBmdW5jdGlvbiBpdGVyYXRlU3RhcnQoaXRtYXAgc3RvcmFnZSBzZWxmKSBpbnRlcm5hbCB2aWV3IHJldHVybnMgKEl0ZXJhdG9yKSB7CiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yU2tpcERlbGV0ZWQoc2VsZiwgMCk7CiAgICB9CgogICAgZnVuY3Rpb24gaXRlcmF0ZVZhbGlkKGl0bWFwIHN0b3JhZ2Ugc2VsZiwgSXRlcmF0b3IgaXRlcmF0b3IpIGludGVybmFsIHZpZXcgcmV0dXJucyAoYm9vbCkgewogICAgICAgIHJldHVybiBJdGVyYXRvci51bndyYXAoaXRlcmF0b3IpIDwgc2VsZi5rZXlzLmxlbmd0aDsKICAgIH0KCiAgICBmdW5jdGlvbiBpdGVyYXRlTmV4dChpdG1hcCBzdG9yYWdlIHNlbGYsIEl0ZXJhdG9yIGl0ZXJhdG9yKSBpbnRlcm5hbCB2aWV3IHJldHVybnMgKEl0ZXJhdG9yKSB7CiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yU2tpcERlbGV0ZWQoc2VsZiwgSXRlcmF0b3IudW53cmFwKGl0ZXJhdG9yKSArIDEpOwogICAgfQoKICAgIGZ1bmN0aW9uIGl0ZXJhdGVHZXQoaXRtYXAgc3RvcmFnZSBzZWxmLCBJdGVyYXRvciBpdGVyYXRvcikgaW50ZXJuYWwgdmlldyByZXR1cm5zICh1aW50IGtleSwgdWludCB2YWx1ZSkgewogICAgICAgIHVpbnQga2V5SW5kZXggPSBJdGVyYXRvci51bndyYXAoaXRlcmF0b3IpOwogICAgICAgIGtleSA9IHNlbGYua2V5c1trZXlJbmRleF0ua2V5OwogICAgICAgIHZhbHVlID0gc2VsZi5kYXRhW2tleV0udmFsdWU7CiAgICB9CgogICAgZnVuY3Rpb24gaXRlcmF0b3JTa2lwRGVsZXRlZChpdG1hcCBzdG9yYWdlIHNlbGYsIHVpbnQga2V5SW5kZXgpIHByaXZhdGUgdmlldyByZXR1cm5zIChJdGVyYXRvcikgewogICAgICAgIHdoaWxlIChrZXlJbmRleCA8IHNlbGYua2V5cy5sZW5ndGggJiYgc2VsZi5rZXlzW2tleUluZGV4XS5kZWxldGVkKQogICAgICAgICAgICBrZXlJbmRleCsrOwogICAgICAgIHJldHVybiBJdGVyYXRvci53cmFwKGtleUluZGV4KTsKICAgIH0KfQoKLy8g5aaC5L2V5L2/55SoCmNvbnRyYWN0IFVzZXIgewogICAgLy8g5Y+q5piv5LiA5Liq5L+d5a2Y5oiR5Lus5pWw5o2u55qE57uT5p6E5L2T44CCCiAgICBpdG1hcCBkYXRhOwogICAgLy8g5a+55pWw5o2u57G75Z6L5bqU55So5bqT5Ye95pWw44CCCiAgICB1c2luZyBJdGVyYWJsZU1hcHBpbmcgZm9yIGl0bWFwOwoKICAgIC8vIOaPkuWFpeS4gOS6m+aVsOaNrgogICAgZnVuY3Rpb24gaW5zZXJ0KHVpbnQgaywgdWludCB2KSBwdWJsaWMgcmV0dXJucyAodWludCBzaXplKSB7CiAgICAgICAgLy8g6L+Z5bCG6LCD55SoIEl0ZXJhYmxlTWFwcGluZy5pbnNlcnQoZGF0YSwgaywgdikKICAgICAgICBkYXRhLmluc2VydChrLCB2KTsKICAgICAgICAvLyDmiJHku6zku43nhLblj6/ku6Xorr/pl67nu5PmnoTkuK3nmoTmiJDlkZjvvIwKICAgICAgICAvLyDkvYbmiJHku6zlupTor6Xms6jmhI/kuI3opoHkubHliqjku5bku6zjgIIKICAgICAgICByZXR1cm4gZGF0YS5zaXplOwogICAgfQoKICAgIC8vIOiuoeeul+aJgOacieWtmOWCqOaVsOaNrueahOaAu+WSjOOAggogICAgZnVuY3Rpb24gc3VtKCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCBzKSB7CiAgICAgICAgZm9yICgKICAgICAgICAgICAgSXRlcmF0b3IgaSA9IGRhdGEuaXRlcmF0ZVN0YXJ0KCk7CiAgICAgICAgICAgIGRhdGEuaXRlcmF0ZVZhbGlkKGkpOwogICAgICAgICAgICBpID0gZGF0YS5pdGVyYXRlTmV4dChpKQogICAgICAgICkgewogICAgICAgICAgICAoLCB1aW50IHZhbHVlKSA9IGRhdGEuaXRlcmF0ZUdldChpKTsKICAgICAgICAgICAgcyArPSB2YWx1ZTsKICAgICAgICB9CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.8;
struct IndexValue { uint keyIndex; uint value; }
struct KeyFlag { uint key; bool deleted; }
struct itmap {
 mapping(uint \=> IndexValue) data;
 KeyFlag\[\] keys;
 uint size;
}
type Iterator is uint;
library IterableMapping {
 function insert(itmap storage self, uint key, uint value) internal returns (bool replaced) {
 uint keyIndex \= self.data\[key\].keyIndex;
 self.data\[key\].value \= value;
 if (keyIndex \> 0)
 return true;
 else {
 keyIndex \= self.keys.length;
 self.keys.push();
 self.data\[key\].keyIndex \= keyIndex + 1;
 self.keys\[keyIndex\].key \= key;
 self.size++;
 return false;
 }
 }
 function remove(itmap storage self, uint key) internal returns (bool success) {
 uint keyIndex \= self.data\[key\].keyIndex;
 if (keyIndex \== 0)
 return false;
 delete self.data\[key\];
 self.keys\[keyIndex \- 1\].deleted \= true;
 self.size \--;
 }
 function contains(itmap storage self, uint key) internal view returns (bool) {
 return self.data\[key\].keyIndex \> 0;
 }
 function iterateStart(itmap storage self) internal view returns (Iterator) {
 return iteratorSkipDeleted(self, 0);
 }
 function iterateValid(itmap storage self, Iterator iterator) internal view returns (bool) {
 return Iterator.unwrap(iterator) < self.keys.length;
 }
 function iterateNext(itmap storage self, Iterator iterator) internal view returns (Iterator) {
 return iteratorSkipDeleted(self, Iterator.unwrap(iterator) + 1);
 }
 function iterateGet(itmap storage self, Iterator iterator) internal view returns (uint key, uint value) {
 uint keyIndex \= Iterator.unwrap(iterator);
 key \= self.keys\[keyIndex\].key;
 value \= self.data\[key\].value;
 }
 function iteratorSkipDeleted(itmap storage self, uint keyIndex) private view returns (Iterator) {
 while (keyIndex < self.keys.length && self.keys\[keyIndex\].deleted)
 keyIndex++;
 return Iterator.wrap(keyIndex);
 }
}
// 如何使用
contract User {
 // 只是一个保存我们数据的结构体。
 itmap data;
 // 对数据类型应用库函数。
 using IterableMapping for itmap;
 // 插入一些数据
 function insert(uint k, uint v) public returns (uint size) {
 // 这将调用 IterableMapping.insert(data, k, v)
 data.insert(k, v);
 // 我们仍然可以访问结构中的成员，
 // 但我们应该注意不要乱动他们。
 return data.size;
 }
 // 计算所有存储数据的总和。
 function sum() public view returns (uint s) {
 for (
 Iterator i \= data.iterateStart();
 data.iterateValid(i);
 i \= data.iterateNext(i)
 ) {
 (, uint value) \= data.iterateGet(i);
 s += value;
 }
 }
}
## 运算符[](#index-28 "此标题的永久链接")
即使两个操作数的类型不一样，也可以应用算术和位操作数。 例如，您可以计算 `y = x + z`，其中 `x` 是 `uint8`， `z` 的类型为 `int32`。 在这种情况下，下面的机制将被用来确定计算操作的类型（这在溢出的情况下很重要）和操作结果的类型：
1. 如果右操作数的类型可以隐式转换为左操作数的类型，则使用左操作数的类型，
 
2. 如果左操作数的类型可以隐式转换为右操作数的类型，则使用右操作数的类型，
 
3. 否则的话，该操作不被允许。
 
如果其中一个操作数是 [字面常数](#rational-literals)， 它首先被转换为其 “移动类型（mobile type）”，也就是能容纳该值的最小类型 （相同位宽的无符号类型被认为比有符号类型 “小”）。 如果两者都是字面常数，那么运算的精度实际上是无限的， 因为表达式被转换到任何必要的精度，所以当结果被用于非字面类型时，没有任何损失。
操作符的结果类型与操作的类型相同，除了比较操作符，其结果总是 `bool`。
运算符 `**` （幂运算）， `<<` 和 `>>` 使用左边操作数的类型进行运算和以其作为结果。
### 三元运算符[](#id39 "此标题的永久链接")
三元运算符用于形式为 `<条件表达式> ? <true条件表达式> : <false条件表达式>`。 它根据主要的 `<条件表达式>` 的评估结果，计算后两个给定表达式中的一个。 如果 `<条件表达式>` 评估为 `true`，那么 `<true条件表达式>` 将被计算，否则 `<false条件表达式>` 被被计算。
三元运算符的结果没有有理数类型，即使它的操作数都是有理数字。 结果类型是由两个操作数的类型决定的，方法同上，如果需要的话，首先转换为它们的可移动计算的类型。
因此， `255 + (true ? 1 : 0)` 将由于算术溢出而恢复计算。 原因是 `(true ? 1 : 0)` 是 `uint8` 类型，这迫使加法也在 `uint8` 中进行， 而256超出了这个类型允许的范围。
另一个结果是，像 `1.5 + 1.5` 这样的表达式是有效的，但 `1.5 + (true ? 1.5 : 2.5)` 却无效。 这是因为前者是一个以无限精度计算的有理表达式，只有它的最终值才是重要的。 后者涉及到将小数有理数转换为整数，这在目前是不允许的。
### 复数和增量/减量运算符[](#index-29 "此标题的永久链接")
如果 `a` 是一个LValue（即是一个变量或者是可以被分配的东西）， 下列运算符可以作为速记：
`a += e` 相当于 `a = a + e`，运算符 `-=`， `*=`， `/=`， `%=`， `|=`， `&=`， `^=`， `<<=` 和 `>>=` 都有相应的定义。 `a++` 和 `a--` 相当于 `a += 1` / `a -= 1` 但是表达式本身仍然是以前的值 `a`。 相比之下， `--a` 和 `++a` 对 `a` 有同样的作用，但返回改变后的值。
### 删除[](#delete "此标题的永久链接")
`delete a` 为该类型分配初始值 `a`。例如，对于整数来说，它相当于 `a = 0`， 但是它也可以用于数组，它指定一个长度为0的动态数组或者一个相同长度的静态数组， 所有元素都设置为初始值。 `delete a[x]` 删除数组中索引为 `x` 的元素， 并保留所有其他元素和数组的长度不动。这特别意味着它在数组中留下一个缺口。 如果您打算删除项目，一个 [映射类型](#mapping-types) 可能是一个更好的选择。
对于结构体，则将结构体中的所有属性重置。换句话说，在 `delete a` 之后， `a` 的值与 `a` 在没有赋值的情况下被声明是一样的，但有以下注意事项：
`delete` 对映射类型没有影响（因为映射的键可能是任意的，通常是未知的）。 因此，如果您删除一个结构体，它将重置所有不是映射类型的成员， 同时也会递归到这些成员，除非它们是映射。 然而，单个键和它们所映射的内容可以被删除。 如果 `a` 是一个映射，那么 `delete a[x]` 将删除存储在 `x` 的值。
值得注意的是， `delete a` 的行为实际上是对 `a` 的赋值， 也就是说，它在 `a` 中存储了一个新的对象。 当 `a` 是引用变量时，这种区别是明显的。 它只会重置 `a` 本身，而不是它之前引用的值。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgRGVsZXRlRXhhbXBsZSB7CiAgICB1aW50IGRhdGE7CiAgICB1aW50W10gZGF0YUFycmF5OwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIHVpbnQgeCA9IGRhdGE7CiAgICAgICAgZGVsZXRlIHg7IC8vIOWwhiB4IOiuvuS4uiAw77yM5bm25LiN5b2x5ZONZGF0YeWPmOmHjwogICAgICAgIGRlbGV0ZSBkYXRhOyAvLyDlsIYgZGF0YSDorr7kuLogMO+8jOW5tuS4jeW9seWTjSB4CiAgICAgICAgdWludFtdIHN0b3JhZ2UgeSA9IGRhdGFBcnJheTsKICAgICAgICBkZWxldGUgZGF0YUFycmF5OyAvLyDlsIYgZGF0YUFycmF5Lmxlbmd0aCDorr7kuLogMO+8jOS9hueUseS6jiB1aW50W10g5piv5LiA5Liq5aSN5p2C55qE5a+56LGh77yMCiAgICAgICAgLy8geSDkuZ/lsIblj5fliLDlvbHlk43vvIzlroPmmK/kuIDkuKrlrZjlgqjkvY3nva7mmK8gc3RvcmFnZSDnmoTlr7nosaHnmoTliKvlkI3jgIIKICAgICAgICAvLyDlj6bkuIDmlrnpnaLvvJoiZGVsZXRlIHkiIOaYr+mdnuazleeahO+8jOW8leeUqOS6hiBzdG9yYWdlIOWvueixoeeahOWxgOmDqOWPmOmHj+WPquiDveeUseW3suacieeahCBzdG9yYWdlIOWvueixoei1i+WAvOOAggogICAgICAgIGFzc2VydCh5Lmxlbmd0aCA9PSAwKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract DeleteExample {
 uint data;
 uint\[\] dataArray;
 function f() public {
 uint x \= data;
 delete x; // 将 x 设为 0，并不影响data变量
 delete data; // 将 data 设为 0，并不影响 x
 uint\[\] storage y \= dataArray;
 delete dataArray; // 将 dataArray.length 设为 0，但由于 uint\[\] 是一个复杂的对象，
 // y 也将受到影响，它是一个存储位置是 storage 的对象的别名。
 // 另一方面："delete y" 是非法的，引用了 storage 对象的局部变量只能由已有的 storage 对象赋值。
 assert(y.length \== 0);
 }
}
### 运算符的优先顺序[](#order "此标题的永久链接")
以下是按评估顺序列出的操作符优先级。
优先级
描述
操作符
_1_
后置自增和自减
`++`， `--`
创建类型实例
`new <类型名>`
数组元素
`<数组>[<索引>]`
访问成员
`<对象>.<成员名>`
函数调用
`<函数>(<参数...>)`
小括号
`(<表达式>)`
_2_
前置自增和自减
`++`， `--`
一元运算减
`-`
一元操作符
`delete`
逻辑非
`!`
按位非
`~`
_3_
乘方
`**`
_4_
乘、除和模运算
`*`， `/`， `%`
_5_
算术加和减
`+`， `-`
_6_
移位操作符
`<<`， `>>`
_7_
按位与
`&`
_8_
按位异或
`^`
_9_
按位或
`|`
_10_
非等操作符
`<`， `>`， `<=`， `>=`
_11_
等于操作符
`==`， `!=`
_12_
逻辑与
`&&`
_13_
逻辑或
`==`
_14_
三元操作符
`<判断条件> ? <如果为真时执行的表达式> : <如果为假时执行的表达式>`
赋值操作符
`=`， `|=`， `^=`， `&=`， `<<=`， `>>=`， `+=`， `-=`， `*=`， `/=`， `%=`
_15_
逗号
`,`
## 基本类型之间的转换[](#types-conversion-elementary-types "此标题的永久链接")
### 隐式转换[](#id44 "此标题的永久链接")
在某些情况下，在赋值过程中，在向函数传递参数和应用运算符时， 编译器会自动应用隐式类型转换。一般来说，如果在语义上有意义， 并且不会丢失信息，那么值-类型之间的隐式转换是可能的。
例如， `uint8` 可以转换为 `uint16`， `int128` 可以转换为 `int256`， 但是 `int8` 不能转换为 `uint256`，因为 `uint256` 不能容纳 `-1` 这样的值。
如果一个运算符被应用于不同的类型， 编译器会尝试将其中一个操作数隐含地转换为另一个的类型（对于赋值也是如此）。 这意味着操作总是以其中一个操作数的类型进行。
关于哪些隐式转换是可能的，请参考关于类型本身的章节。
在下面的例子中， `y` 和 `z`，即加法的操作数，没有相同的类型， 但是 `uint8` 可以隐式转换为 `uint16`，反之则不行。正因为如此， `y` 被转换为 `z` 的类型，然后在 `uint16` 类型中进行加法。 结果表达式 `y + z` 的类型是 `uint16`。 因为它被分配到一个 `uint32` 类型的变量中，所以在加法后又进行了一次隐式转换。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=dWludDggeTsKdWludDE2IHo7CnVpbnQzMiB4ID0geSArIHo7)
uint8 y;
uint16 z;
uint32 x \= y + z;
### 显式转换[](#id45 "此标题的永久链接")
如果编译器不允许隐式转换，但您确信转换会成功， 有时可以进行显式类型转换。 这可能会导致意想不到的行为，并使您绕过编译器的一些安全特性， 所以一定要测试结果是否是您想要的和期望的!
以下面的例子为例，将一个负的 `int` 转换为 `uint`：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=aW50ICB5ID0gLTM7CnVpbnQgeCA9IHVpbnQoeSk7)
int y \= \-3;
uint x \= uint(y);
在这个代码片断的最后， `x` 变成 `0xfffff..fd` 的值（64个十六进制字符）， 这在256位的二进制补码中表示是-3。
如果一个整数被明确地转换为一个较小的类型，高阶位就会被切断：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=dWludDMyIGEgPSAweDEyMzQ1Njc4Owp1aW50MTYgYiA9IHVpbnQxNihhKTsgLy8gYiDnjrDlnKjkvJrmmK8gMHg1Njc4)
uint32 a \= 0x12345678;
uint16 b \= uint16(a); // b 现在会是 0x5678
如果一个整数被明确地转换为一个更大的类型，它将在左边被填充（即在高阶的一端）。 转换的结果将与原整数比较相等：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=dWludDE2IGEgPSAweDEyMzQ7CnVpbnQzMiBiID0gdWludDMyKGEpOyAvLyBiIOeOsOWcqOS8muaYryAweDAwMDAxMjM0CmFzc2VydChhID09IGIpOw==)
uint16 a \= 0x1234;
uint32 b \= uint32(a); // b 现在会是 0x00001234
assert(a \== b);
固定大小的字节类型在转换过程中的行为是不同的。 它们可以被认为是单个字节的序列，转换到一个较小的类型将切断序列：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ynl0ZXMyIGEgPSAweDEyMzQ7CmJ5dGVzMSBiID0gYnl0ZXMxKGEpOyAvLyBiIOeOsOWcqOS8muaYryAweDEy)
bytes2 a \= 0x1234;
bytes1 b \= bytes1(a); // b 现在会是 0x12
如果一个固定大小的字节类型被明确地转换为一个更大的类型，它将在右边被填充。 访问固定索引的字节将导致转换前后的数值相同（如果索引仍在范围内）：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ynl0ZXMyIGEgPSAweDEyMzQ7CmJ5dGVzNCBiID0gYnl0ZXM0KGEpOyAvLyBiIOeOsOWcqOS8muaYryAweDEyMzQwMDAwCmFzc2VydChhWzBdID09IGJbMF0pOwphc3NlcnQoYVsxXSA9PSBiWzFdKTs=)
bytes2 a \= 0x1234;
bytes4 b \= bytes4(a); // b 现在会是 0x12340000
assert(a\[0\] \== b\[0\]);
assert(a\[1\] \== b\[1\]);
于整数和固定大小的字节数组在截断或填充时表现不同， 只有在整数和固定大小的字节数组具有相同大小的情况下，才允许在两者之间进行显式转换。 如果您想在不同大小的整数和固定大小的字节数组之间进行转换，您必须使用中间转换， 使所需的截断和填充规则明确：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ynl0ZXMyIGEgPSAweDEyMzQ7CnVpbnQzMiBiID0gdWludDE2KGEpOyAvLyBiIOWwhuS8muaYryAweDAwMDAxMjM0CnVpbnQzMiBjID0gdWludDMyKGJ5dGVzNChhKSk7IC8vIGMg5bCG5Lya5pivIDB4MTIzNDAwMDAKdWludDggZCA9IHVpbnQ4KHVpbnQxNihhKSk7IC8vIGQg5bCG5Lya5pivIDB4MzQKdWludDggZSA9IHVpbnQ4KGJ5dGVzMShhKSk7IC8vIGUg5bCG5Lya5pivIDB4MTI=)
bytes2 a \= 0x1234;
uint32 b \= uint16(a); // b 将会是 0x00001234
uint32 c \= uint32(bytes4(a)); // c 将会是 0x12340000
uint8 d \= uint8(uint16(a)); // d 将会是 0x34
uint8 e \= uint8(bytes1(a)); // e 将会是 0x12
`bytes` 数组和 `bytes` calldata 切片可以明确转换为固定字节类型（ `bytes1` /…/ `bytes32`）。 如果数组比目标的固定字节类型长，在末端会发生截断的情况。如果数组比目标类型短，它将在末尾被填充零。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNTsKCmNvbnRyYWN0IEMgewogICAgYnl0ZXMgcyA9ICJhYmNkZWZnaCI7CiAgICBmdW5jdGlvbiBmKGJ5dGVzIGNhbGxkYXRhIGMsIGJ5dGVzIG1lbW9yeSBtKSBwdWJsaWMgdmlldyByZXR1cm5zIChieXRlczE2LCBieXRlczMpIHsKICAgICAgICByZXF1aXJlKGMubGVuZ3RoID09IDE2LCAiIik7CiAgICAgICAgYnl0ZXMxNiBiID0gYnl0ZXMxNihtKTsgIC8vIOWmguaenG3nmoTplb/luqblpKfkuo4xNu+8jOWwhuWPkeeUn+aIquaWreOAggogICAgICAgIGIgPSBieXRlczE2KHMpOyAgLy8g5Y+z6L656L+b6KGM5aGr5YWF77yM5omA5Lul57uT5p6c5pivICJhYmNkZWZnaFwwXDBcMFwwXDBcMFwwXDAiCiAgICAgICAgYnl0ZXMzIGIxID0gYnl0ZXMzKHMpOyAvLyDlj5HnlJ/miKrmlq0sIGIxIOebuOW9k+S6jiAiYWJjIgogICAgICAgIGIgPSBieXRlczE2KGNbOjhdKTsgIC8vIOWQjOagt+eUqDDov5vooYzloavlhYUKICAgICAgICByZXR1cm4gKGIsIGIxKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.5;
contract C {
 bytes s \= "abcdefgh";
 function f(bytes calldata c, bytes memory m) public view returns (bytes16, bytes3) {
 require(c.length \== 16, "");
 bytes16 b \= bytes16(m); // 如果m的长度大于16，将发生截断。
 b \= bytes16(s); // 右边进行填充，所以结果是 "abcdefgh\\0\\0\\0\\0\\0\\0\\0\\0"
 bytes3 b1 \= bytes3(s); // 发生截断, b1 相当于 "abc"
 b \= bytes16(c\[:8\]); // 同样用0进行填充
 return (b, b1);
 }
}
## 字面常数和基本类型之间的转换[](#types-conversion-literals "此标题的永久链接")
### 整数类型[](#id47 "此标题的永久链接")
十进制和十六进制的数字字面常数可以隐含地转换为任何足够大的整数类型去表示它而不被截断：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=dWludDggYSA9IDEyOyAvLyDlj6/ooYwKdWludDMyIGIgPSAxMjM0OyAvLyDlj6/ooYwKdWludDE2IGMgPSAweDEyMzQ1NjsgLy8g5oql6ZSZLCDlm6DkuLrov5nlsIbkvJrmiKrmlq3miJAgMHgzNDU2)
uint8 a \= 12; // 可行
uint32 b \= 1234; // 可行
uint16 c \= 0x123456; // 报错, 因为这将会截断成 0x3456
备注
在0.8.0版本之前，任何十进制或十六进制的数字字面常数都可以显式转换为整数类型。 从0.8.0开始，这种显式转换和隐式转换一样严格，也就是说，只有当字面意义符合所产生的范围时，才允许转换。
### 固定大小的字节数组[](#index-34 "此标题的永久链接")
十进制数字字面常数不能被隐含地转换为固定大小的字节数组。 十六进制数字字面常数是可以的，但只有当十六进制数字的数量正好符合字节类型的大小时才可以。 但是有一个例外，数值为0的十进制和十六进制数字字面常数都可以被转换为任何固定大小的字节类型：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ynl0ZXMyIGEgPSA1NDMyMTsgLy8g5LiN5YWB6K64CmJ5dGVzMiBiID0gMHgxMjsgLy8g5LiN5YWB6K64CmJ5dGVzMiBjID0gMHgxMjM7IC8vIOS4jeWFgeiuuApieXRlczIgZCA9IDB4MTIzNDsgLy8g5Y+v6KGMCmJ5dGVzMiBlID0gMHgwMDEyOyAvLyDlj6/ooYwKYnl0ZXM0IGYgPSAwOyAvLyDlj6/ooYwKYnl0ZXM0IGcgPSAweDA7IC8vIOWPr+ihjA==)
bytes2 a \= 54321; // 不允许
bytes2 b \= 0x12; // 不允许
bytes2 c \= 0x123; // 不允许
bytes2 d \= 0x1234; // 可行
bytes2 e \= 0x0012; // 可行
bytes4 f \= 0; // 可行
bytes4 g \= 0x0; // 可行
字符串和十六进制字符串字面常数可以被隐含地转换为固定大小的字节数组， 如果它们的字符数与字节类型的大小相匹配：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ynl0ZXMyIGEgPSBoZXgiMTIzNCI7IC8vIOWPr+ihjApieXRlczIgYiA9ICJ4eSI7IC8vIOWPr+ihjApieXRlczIgYyA9IGhleCIxMiI7IC8vIOS4jeWFgeiuuApieXRlczIgZCA9IGhleCIxMjMiOyAvLyDkuI3lhYHorrgKYnl0ZXMyIGUgPSAieCI7IC8vIOS4jeWFgeiuuApieXRlczIgZiA9ICJ4eXoiOyAvLyDkuI3lhYHorrg=)
bytes2 a \= hex"1234"; // 可行
bytes2 b \= "xy"; // 可行
bytes2 c \= hex"12"; // 不允许
bytes2 d \= hex"123"; // 不允许
bytes2 e \= "x"; // 不允许
bytes2 f \= "xyz"; // 不允许
### 地址类型[](#index-35 "此标题的永久链接")
正如在 [地址字面量（Address Literals）](#address-literals) 中所描述的那样，正确大小并通过校验测试的十六进制字是 `address` 类型。 其他字面常数不能隐含地转换为 `address` 类型。
只允许从 `bytes20` 和 `uint160` 显式转换到 `address`。
`address a` 可以通过 `payable(a)` 显式转换为 `address payable`。
备注
在 0.8.0 版本之前，可以显式地从任何整数类型（任何大小，有符号或无符号）转换为 `address` 或 `address payable` 类型。 从 0.8.0 开始，只允许从 `uint160` 转换。

# [Solidity v0.7.0 Breaking Changes — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/070-breaking-changes.html) 
 _https://docs.soliditylang.org/en/v0.8.30/070-breaking-changes.html_

This section highlights the main breaking changes introduced in Solidity version 0.7.0, along with the reasoning behind the changes and how to update affected code. For the full list check [the release changelog](https://github.com/ethereum/solidity/releases/tag/v0.7.0).
## Silent Changes of the Semantics[](#silent-changes-of-the-semantics "Link to this heading")
* Exponentiation and shifts of literals by non-literals (e.g. `1 << x` or `2 ** x`) will always use either the type `uint256` (for non-negative literals) or `int256` (for negative literals) to perform the operation. Previously, the operation was performed in the type of the shift amount / the exponent which can be misleading.
 
## Changes to the Syntax[](#changes-to-the-syntax "Link to this heading")
* In external function and contract creation calls, Ether and gas is now specified using a new syntax: `x.f{gas: 10000, value: 2 ether}(arg1, arg2)`. The old syntax – `x.f.gas(10000).value(2 ether)(arg1, arg2)` – will cause an error.
 
* The global variable `now` is deprecated, `block.timestamp` should be used instead. The single identifier `now` is too generic for a global variable and could give the impression that it changes during transaction processing, whereas `block.timestamp` correctly reflects the fact that it is just a property of the block.
 
* NatSpec comments on variables are only allowed for public state variables and not for local or internal variables.
 
* The token `gwei` is a keyword now (used to specify, e.g. `2 gwei` as a number) and cannot be used as an identifier.
 
* String literals now can only contain printable ASCII characters and this also includes a variety of escape sequences, such as hexadecimal (`\xff`) and unicode escapes (`\u20ac`).
 
* Unicode string literals are supported now to accommodate valid UTF-8 sequences. They are identified with the `unicode` prefix: `unicode"Hello 😃"`.
 
* State Mutability: The state mutability of functions can now be restricted during inheritance: Functions with default state mutability can be overridden by `pure` and `view` functions while `view` functions can be overridden by `pure` functions. At the same time, public state variables are considered `view` and even `pure` if they are constants.
 
### Inline Assembly[](#inline-assembly "Link to this heading")
* Disallow `.` in user-defined function and variable names in inline assembly. It is still valid if you use Solidity in Yul-only mode.
 
* Slot and offset of storage pointer variable `x` are accessed via `x.slot` and `x.offset` instead of `x_slot` and `x_offset`.
 
## Removal of Unused or Unsafe Features[](#removal-of-unused-or-unsafe-features "Link to this heading")
### Mappings outside Storage[](#mappings-outside-storage "Link to this heading")
* If a struct or array contains a mapping, it can only be used in storage. Previously, mapping members were silently skipped in memory, which is confusing and error-prone.
 
* Assignments to structs or arrays in storage does not work if they contain mappings. Previously, mappings were silently skipped during the copy operation, which is misleading and error-prone.
 
### Functions and Events[](#functions-and-events "Link to this heading")
* Visibility (`public` / `internal`) is not needed for constructors anymore: To prevent a contract from being created, it can be marked `abstract`. This makes the visibility concept for constructors obsolete.
 
* Type Checker: Disallow `virtual` for library functions: Since libraries cannot be inherited from, library functions should not be virtual.
 
* Multiple events with the same name and parameter types in the same inheritance hierarchy are disallowed.
 
* `using A for B` only affects the contract it is mentioned in. Previously, the effect was inherited. Now, you have to repeat the `using` statement in all derived contracts that make use of the feature.
 
### Expressions[](#expressions "Link to this heading")
* Shifts by signed types are disallowed. Previously, shifts by negative amounts were allowed, but reverted at runtime.
 
* The `finney` and `szabo` denominations are removed. They are rarely used and do not make the actual amount readily visible. Instead, explicit values like `1e20` or the very common `gwei` can be used.
 
### Declarations[](#declarations "Link to this heading")
* The keyword `var` cannot be used anymore. Previously, this keyword would parse but result in a type error and a suggestion about which type to use. Now, it results in a parser error.
 
## Interface Changes[](#interface-changes "Link to this heading")
* JSON AST: Mark hex string literals with `kind: "hexString"`.
 
* JSON AST: Members with value `null` are removed from JSON output.
 
* NatSpec: Constructors and functions have consistent userdoc output.
 
## How to update your code[](#how-to-update-your-code "Link to this heading")
This section gives detailed instructions on how to update prior code for every breaking change.
* Change `x.f.value(...)()` to `x.f{value: ...}()`. Similarly `(new C).value(...)()` to `new C{value: ...}()` and `x.f.gas(...).value(...)()` to `x.f{gas: ..., value: ...}()`.
 
* Change `now` to `block.timestamp`.
 
* Change types of right operand in shift operators to unsigned types. For example change `x >> (256 - y)` to `x >> uint(256 - y)`.
 
* Repeat the `using A for B` statements in all derived contracts if needed.
 
* Remove the `public` keyword from every constructor.
 
* Remove the `internal` keyword from every constructor and add `abstract` to the contract (if not already present).
 
* Change `_slot` and `_offset` suffixes in inline assembly to `.slot` and `.offset`, respectively.

# [Bellekteki Düzen — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/internals/layout_in_memory.html) 
 _https://docs.soliditylang.org/tr/latest/internals/layout_in_memory.html_

Solidity, belirli bayt aralıklarını (uç noktalar dahil) aşağıdaki şekilde kullanılmak üzere dört adet 32 baytlık yuva ayırır:
* `0x00` - `0x3f` (64 bytes): Hash metotları için scratch(kazıma) alanı
 
* `0x40` - `0x5f` (32 bytes): Şuan ayrılmış olan bellek boyutu (boş bellek pointer’ı olarak da bilinir)
 
* `0x60` - `0x7f` (32 bytes): zero slot (sıfır yuva)
 
Durumlar arasında (yani assembly içinde) scratch alanı kullanılabilir. Sıfır yuvası, dinamik bellek dizilerinin başlangıç değeri olarak kullanılır ve asla başlangıçta `0x80`’i gösteren boş bellek pointer noktasına yazılmamalıdır.
Solidity her zaman yeni nesneleri boş bellek işaretçisine yerleştirir ve hafıza asla serbest bırakılmaz (Bu özellik gelecekte değişebilir).
Solidity’de bulunan bellek dizilerindeki öğeler her zaman 32 baytın katlarını kaplar (Bu `bytes1[]` için bile doğrudur, ama `bytes` ve `string` için geçerli değildir). Çok boyutlu bellek dizileri, bellek dizilerinin işaretçileridir. Bir dinamik dizinin uzunluğu dizinin ilk yuvasında depolanır ve ardından dizinin elemanları gelir.
Uyarı
Solidity’de 64 bayttan daha büyük bir geçici bellek alanına ihtiyaç duyan ve bu nedenle scratch alanına sığmayan bazı işlemler vardır. Bu işlemler boş bellek noktalarına yerleştirilecektir, ama kısa ömürleri nedeniyle işaretçi güncellenemez. Bellek sıfırlanmış olabilir ya da olmayabilir. Bu nedenle, boş hafızanın sıfırlanmış hafızayı göstermesi beklenmemelidir.
Net bir sıfırlanmış bellek alanına ulaşmak için `msize` kullanmak iyi bir fikir gibi görünse de, boş bellek işaretçisi güncellenmeden geçici olmayan bir işaretçi kullanmak beklenmeyen sonuçlara neden olabilir.
## Depolama Düzeni Farklılıkları[](#depolama-duzeni-farkliliklari "Permalink to this heading")
Yukarıda açıklandığı üzere bellekteki düzen ile depolama düzeni ([storage](https://docs.soliditylang.org/tr/latest/internals/layout_in_storage.html#storage-inplace-encoding)) farklıdır. Aşağıda bunlara yönelik bazı örnekler bulunmaktadır.
### Dizilerdeki Farklılıklara Bir Örnek[](#dizilerdeki-farkliliklara-bir-ornek "Permalink to this heading")
Aşağıdaki dizi, depolamada 32 bayt (1 yuva) yer kaplar, ancak bellekte 128 bayt (her biri 32 bayt olan 4 öğe) yer kaplar.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=dWludDhbNF0gYTs=)
### Yapı(Struct) Düzeni Farklılıklarına Bir Örnek[](#yapi-struct-duzeni-farkliliklarina-bir-ornek "Permalink to this heading")
Aşağıdaki struct, depolamada 96 bayt (32 baytlık 3 yuva) kaplar, ama bellekte 128 bayt (her biri 32 bayt olan 4 öğe) yer kaplar.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=c3RydWN0IFMgewogICAgdWludCBhOwogICAgdWludCBiOwogICAgdWludDggYzsKICAgIHVpbnQ4IGQ7Cn0=)
struct S {
 uint a;
 uint b;
 uint8 c;
 uint8 d;
}

# [基于 Solidity 中间表征的 Codegen 变化 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/ir-breaking-changes.html) 
 _https://docs.soliditylang.org/zh-cn/latest/ir-breaking-changes.html_

Solidity 可以通过两种不同的方式生成 EVM 字节码： 要么直接从 Solidity 到 EVM 操作码（“旧编码”）， 要么通过在 Yul 中的中间表示法（“IR”）（“新编码” 或 “基于IR的编码”）。
引入基于 IR 的代码生成器的目的是，不仅使代码生成更加透明和可审计， 而且能够实现更强大的跨函数的优化通道。
您可以在命令行中使用 `--via-ir` 或在 standard-json 中使用 `{"viaIR": true}` 选项来启用它， 我们鼓励大家尝试一下！
由于一些原因，旧的和基于IR的代码生成器之间存在着微小的语义差异， 主要是在那些我们无论如何也不会期望人们依赖这种行为的领域。 本节强调了旧的和基于IR的代码生成器之间的主要区别。
## 仅有语义上的变化[](#id1 "此标题的永久链接")
本节列出了仅有语义的变化，从而有可能在现有的代码中隐藏新的和不同的行为。
* 在继承的情况下，状态变量初始化的顺序已经改变。
 
 以前的顺序是：
 
 * 所有的状态变量在开始时都被零初始化。
 
 * 从最终派生合约到最基础的合约评估基础构造函数参数。
 
 * 从最基础的继承关系到最终派生的继承关系初始化整个继承层次结构中的所有状态变量。
 
 * 如果存在，在线性化层次结构中从最基础的合约到最终派生的合约依次运行构造函数。
 
 
 新的顺序：
 
 * 所有的状态变量在开始时都被零初始化。
 
 * 从最终派生合约到最基础的合约评估基础构造函数参数。
 
 * 对于每一个合约，按照从最基础到最终派生的合约的线性化层次结构的顺序执行：
 
 1. 初始化状态变量。
 
 2. 运行构造函数（如果存在）。
 
 
 这导致了合约中的差异，即一个状态变量的初始值依赖于另一个合约中构造函数的结果：
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjE7Cgpjb250cmFjdCBBIHsKICAgIHVpbnQgeDsKICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgIHggPSA0MjsKICAgIH0KICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgdmlldyByZXR1cm5zKHVpbnQyNTYpIHsKICAgICAgICByZXR1cm4geDsKICAgIH0KfQpjb250cmFjdCBCIGlzIEEgewogICAgdWludCBwdWJsaWMgeSA9IGYoKTsKfQ==)
 
 // SPDX-License-Identifier: GPL-3.0
 pragma solidity \>=0.7.1;
 
 contract A {
 uint x;
 constructor() {
 x \= 42;
 }
 function f() public view returns(uint256) {
 return x;
 }
 }
 contract B is A {
 uint public y \= f();
 }
 
 以前， `y` 会被设置为0。这是由于我们会先初始化状态变量：首先， `x` 被设置为0，当初始化 `y` 时， `f()` 将返回0，导致 `y` 也为0。 在新的规则下， `y` 将被设置为42。我们首先将 `x` 初始化为0，然后调用 A 的构造函数，将 `x` 设置为42。最后，在初始化 `y` 时， `f()` 返回42，导致 `y` 为42。
 
* 当存储结构被删除时，包含该结构成员的每个存储槽都被完全设置为零。 以前，填充空间是不被触动的。 因此，如果结构中的填充空间被用来存储数据（例如在合约升级的背景下）， 您必须注意， `delete` 现在也会清除添加的成员（而在过去不会被清除）。
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjE7Cgpjb250cmFjdCBDIHsKICAgIHN0cnVjdCBTIHsKICAgICAgICB1aW50NjQgeTsKICAgICAgICB1aW50NjQgejsKICAgIH0KICAgIFMgczsKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIC8vIC4uLgogICAgICAgIGRlbGV0ZSBzOwogICAgICAgIC8vIHPlj6rljaDnlKjkuoYzMuS4quWtl+iKguanveeahOWJjTE25Liq5a2X6IqCCiAgICAgICAgLy8gZGVsZXRlIOWwhuaKiumbtuWGmeWIsOWujOaVtOeahOaPkuanveS4rQogICAgfQp9)
 
 // SPDX-License-Identifier: GPL-3.0
 pragma solidity \>=0.7.1;
 
 contract C {
 struct S {
 uint64 y;
 uint64 z;
 }
 S s;
 function f() public {
 // ...
 delete s;
 // s只占用了32个字节槽的前16个字节
 // delete 将把零写到完整的插槽中
 }
 }
 
 我们对隐式删除也有同样的行为，例如当结构体的数组被缩短时。
 
* 关于函数参数和返回变量，函数修改器的实现方式略有不同。 如果占位符 `_;` 在一个修饰符中被多次使用，这尤其有影响。 在旧的代码生成器中，每个函数参数和返回变量在堆栈中都有一个固定的槽。 如果因为多次使用 `_;` 而使函数运行多次，或者在一个循环中使用， 那么函数参数或返回变量的值的变化在函数的下一次执行中是可见的。 新的代码生成器使用实际的函数来实现修改器，并将函数参数传递下去。 这意味着对一个函数主体的多次使用将得到相同的参数值，而对返回变量的影响是， 它们在每次执行时都被重置为其默认值（零）。
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjA7CmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50IGEpIHB1YmxpYyBwdXJlIG1vZCgpIHJldHVybnMgKHVpbnQgcikgewogICAgICAgIHIgPSBhKys7CiAgICB9CiAgICBtb2RpZmllciBtb2QoKSB7IF87IF87IH0KfQ==)
 
 // SPDX-License-Identifier: GPL-3.0
 pragma solidity \>=0.7.0;
 contract C {
 function f(uint a) public pure mod() returns (uint r) {
 r \= a++;
 }
 modifier mod() { \_; \_; }
 }
 
 如果您在旧的代码生成器中执行 `f(0)`，它将返回 `1`， 而在使用新的代码生成器时，它将返回 `0`。
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBib29sIGFjdGl2ZSA9IHRydWU7CiAgICBtb2RpZmllciBtb2QoKQogICAgewogICAgICAgIF87CiAgICAgICAgYWN0aXZlID0gZmFsc2U7CiAgICAgICAgXzsKICAgIH0KICAgIGZ1bmN0aW9uIGZvbygpIGV4dGVybmFsIG1vZCgpIHJldHVybnMgKHVpbnQgcmV0KQogICAgewogICAgICAgIGlmIChhY3RpdmUpCiAgICAgICAgICAgIHJldCA9IDE7IC8vIOS4jiBgYHJldHVybiAxYGAg55u45ZCMCiAgICB9Cn0=)
 
 // SPDX-License-Identifier: GPL-3.0
 pragma solidity \>=0.7.1 <0.9.0;
 
 contract C {
 bool active \= true;
 modifier mod()
 {
 \_;
 active \= false;
 \_;
 }
 function foo() external mod() returns (uint ret)
 {
 if (active)
 ret \= 1; // 与 \`\`return 1\`\` 相同
 }
 }
 
 函数 `C.foo()` 返回以下值：
 
 * 旧的代码生成器： `1` 作为返回变量在第一次 `_;` 使用前只被初始化为 `0`， 然后被 `return 1;` 覆盖。在第二次 `_;` 使用时，它没有被再次初始化， 而且 `foo()` 也没有明确地分配给它（由于 `active == false`），因此它保持了它的第一个值。
 
 * 新的代码生成器： `0` 作为所有参数，包括返回参数，将在每次 `_;` 使用前被重新初始化。
 
* 对于旧的代码生成器，表达式的评估顺序是没有规定的。 对于新的代码生成器，我们试图按照源顺序（从左到右）进行评估，但并不保证这一点。 这可能会导致语义上的差异。
 
 例如：
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjE7CmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gcHJlaW5jcl91OCh1aW50OCBhKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50OCkgewogICAgICAgIHJldHVybiArK2EgKyBhOwogICAgfQp9)
 
 // SPDX-License-Identifier: GPL-3.0
 pragma solidity \>=0.8.1;
 contract C {
 function preincr\_u8(uint8 a) public pure returns (uint8) {
 return ++a + a;
 }
 }
 
 函数 `preincr_u8(1)` 返回以下值：
 
 * 旧的代码生成器： `3` ( `1 + 2` )，但一般情况下返回值是不指定的
 
 * 新的代码生成器： `4` ( `2 + 2` )，但不能保证返回值
 
 
 另一方面，除了全局函数 `addmod` 和 `mulmod` 外，两个代码生成器对函数参数表达式的评估顺序是一样的。 例如：
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjE7CmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gYWRkKHVpbnQ4IGEsIHVpbnQ4IGIpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQ4KSB7CiAgICAgICAgcmV0dXJuIGEgKyBiOwogICAgfQogICAgZnVuY3Rpb24gZyh1aW50OCBhLCB1aW50OCBiKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50OCkgewogICAgICAgIHJldHVybiBhZGQoKythICsgKytiLCBhICsgYik7CiAgICB9Cn0=)
 
 // SPDX-License-Identifier: GPL-3.0
 pragma solidity \>=0.8.1;
 contract C {
 function add(uint8 a, uint8 b) public pure returns (uint8) {
 return a + b;
 }
 function g(uint8 a, uint8 b) public pure returns (uint8) {
 return add(++a + ++b, a + b);
 }
 }
 
 函数 `g(1, 2)` 返回以下值：
 
 * 旧的代码生成器： `10` ( `add(2+3, 2+3)` )，但返回值一般不指定。
 
 * 新的代码生成器： `10`，但不能保证返回值
 
 
 全局函数 `addmod` 和 `mulmod` 的参数由旧代码生成器从右向左评估，新代码生成器从左向右评估。 例如：
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjE7CmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQyNTYgYU1vZCwgdWludDI1NiBtTW9kKSB7CiAgICAgICAgdWludDI1NiB4ID0gMzsKICAgICAgICAvLyDml6fnmoTku6PnoIHnlJ/miJDlmajvvJogYWRkL211bG1vZCg1LCA0LCAzKQogICAgICAgIC8vIOaWsOeahOS7o+eggeeUn+aIkOWZqO+8miBhZGQvbXVsbW9kKDQsIDUsIDUpCiAgICAgICAgYU1vZCA9IGFkZG1vZCgrK3gsICsreCwgeCk7CiAgICAgICAgbU1vZCA9IG11bG1vZCgrK3gsICsreCwgeCk7CiAgICB9Cn0=)
 
 // SPDX-License-Identifier: GPL-3.0
 pragma solidity \>=0.8.1;
 contract C {
 function f() public pure returns (uint256 aMod, uint256 mMod) {
 uint256 x \= 3;
 // 旧的代码生成器： add/mulmod(5, 4, 3)
 // 新的代码生成器： add/mulmod(4, 5, 5)
 aMod \= addmod(++x, ++x, x);
 mMod \= mulmod(++x, ++x, x);
 }
 }
 
 函数 `f()` 返回以下值：
 
 * 旧的代码生成器： `aMod = 0` 和 `mMod = 2`
 
 * 新的代码生成器： `aMod = 4` 和 `mMod = 0`
 
* 新的代码生成器对自由内存指针施加了一个硬性限制 `type(uint64).max` （ `0xffffffffffffffff`）。其增加值超过这个限制的分配会被恢复。 旧的代码生成器没有这个限制。
 
 例如：
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID4wLjguMDsKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKCkgcHVibGljIHsKICAgICAgICB1aW50W10gbWVtb3J5IGFycjsKICAgICAgICAvLyDliIbphY3nqbrpl7TvvJogNTc2NDYwNzUyMzAzNDIzNDgxCiAgICAgICAgLy8g5YGH6K6+ZnJlZU1lbVB0cuacgOWIneaMh+WQkTB4ODAKICAgICAgICB1aW50IHNvbFl1bE1heEFsbG9jYXRpb25CZWZvcmVNZW1QdHJPdmVyZmxvdyA9ICh0eXBlKHVpbnQ2NCkubWF4IC0gMHg4MCAtIDMxKSAvIDMyOwogICAgICAgIC8vIGZyZWVNZW1QdHIg5ZugIFVJTlQ2NF9NQVgg6ZmQ5Yi25rqi5Ye6CiAgICAgICAgYXJyID0gbmV3IHVpbnRbXShzb2xZdWxNYXhBbGxvY2F0aW9uQmVmb3JlTWVtUHRyT3ZlcmZsb3cpOwogICAgfQp9)
 
 // SPDX-License-Identifier: GPL-3.0
 pragma solidity \>0.8.0;
 contract C {
 function f() public {
 uint\[\] memory arr;
 // 分配空间： 576460752303423481
 // 假设freeMemPtr最初指向0x80
 uint solYulMaxAllocationBeforeMemPtrOverflow \= (type(uint64).max \- 0x80 \- 31) / 32;
 // freeMemPtr 因 UINT64\_MAX 限制溢出
 arr \= new uint\[\](solYulMaxAllocationBeforeMemPtrOverflow);
 }
 }
 
 函数 `f()` 的作用如下：
 
 * 旧的代码生成器：在大内存分配后对数组内容进行清零时耗尽了燃料
 
 * 新的代码生成器：由于自由内存指针溢出而还原（不会耗尽燃料）。
 
## 内部结构[](#id2 "此标题的永久链接")
### 内部函数指针[](#id3 "此标题的永久链接")
旧的代码生成器对内部函数指针的值使用代码偏移量或标签。 这一点特别复杂，因为这些偏移量在构造时和部署后是不同的，而且这些值可以通过存储跨越这个边界。 正因为如此，这两个偏移量在构造时被编码为同一个值（进入不同的字节）。
在新的代码生成器中，函数指针使用依次分配的内部ID。 由于通过跳转的调用是不可能的，通过函数指针的调用总是要使用内部调度函数， 使用 `switch` 语句来选择正确的函数。
ID `0` 是为未初始化的函数指针保留的，这些指针在被调用时，会引起调度函数的panic错误。
在旧的代码生成器中，内部函数指针是用一个特殊的函数初始化的，它总是引起panic错误。 这导致在构造时对存储中的内部函数指针进行存储写入。
### 清理[](#id4 "此标题的永久链接")
旧的代码生成器只在操作前执行清理，而操作的结果可能会受到脏位值的影响。 新的代码生成器在任何可能导致脏位的操作之后执行清理。 我们希望优化器能够强大到足以消除多余的清理操作。
例如：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjE7CmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50OCBhKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IHIxLCB1aW50IHIyKQogICAgewogICAgICAgIGEgPSB+YTsKICAgICAgICBhc3NlbWJseSB7CiAgICAgICAgICAgIHIxIDo9IGEKICAgICAgICB9CiAgICAgICAgcjIgPSBhOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.1;
contract C {
 function f(uint8 a) public pure returns (uint r1, uint r2)
 {
 a \= ~a;
 assembly {
 r1 := a
 }
 r2 \= a;
 }
}
函数 `f(1)` 返回以下值：
* 旧的代码生成器：（ `fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe`, `00000000000000000000000000000000000000000000000000000000000000fe`）
 
* 新的代码生成器：（ `00000000000000000000000000000000000000000000000000000000000000fe`, `00000000000000000000000000000000000000000000000000000000000000fe`）
 
请注意，与新的代码生成器不同，旧的代码生成器在位取反赋值（ `a = ~a` ）后没有进行清理。 这导致新旧代码生成器之间对返回值 `r1` 的赋值（在内联汇编块内）不同。 然而，两个代码生成器在 `a` 的新值被分配到 `r2` 之前都进行了清理。

# [undefined](undefined) 
 _undefined_

undefined

# [存储中的状态变量储存结构 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/internals/layout_in_storage.html) 
 _https://docs.soliditylang.org/zh-cn/latest/internals/layout_in_storage.html_

## 存储中的状态变量储存结构[](#index-0 "此标题的永久链接")
合约的状态变量以一种紧凑的方式存储， 这样多个值有时会使用同一个存储槽。 除了动态大小的数组和映射（见下文）之外， 数据是被逐项存储的，从第一个状态变量开始， 它被存储在槽 `0` 中。对于每个变量， 根据它的类型确定一个字节的大小。如果可能的话，需要少于32字节的多个连续项目被打包到一个存储槽中， 根据以下规则：
* 存储插槽的第一项会以低位对齐（即右对齐）的方式储存。
 
* 值类型只使用存储它们所需的字节数。
 
* 如果一个值类型不适合一个存储槽的剩余部分，它将被存储在下一个存储槽。
 
* 结构和数组数据总是从一个新的存储槽开始，它们的项根据这些规则被紧密地打包。
 
* 结构或数组数据之后的变量总是开辟一个新的存储槽。
 
对于使用继承的合约，状态变量的排序是从最基础的合约开始，由合约的C3线性化顺序决定的。 如果上述规则允许，来自不同合约的状态变量确实共享同一个存储槽。
结构体和数组中的元素都是顺序存储的，就像它们被明确给定的那样。
警告
当使用小于32字节的元素时，您的合约的燃料用量可能会更高。 这是因为EVM每次对32字节进行操作。因此，如果元素小于这个大小， EVM必须使用更多的操作，以便将元素的大小从32字节减少到所需的大小。
如果您处理的是存储值，使用缩小尺寸的类型可能是有益的， 因为编译器会将多个元素打包到一个存储槽中， 从而将多个读或写合并到一个操作中。 如果您不是在同一时间读取或写入一个槽中的所有值， 这可能会产生相反的效果，虽然。当一个值被写入一个多值存储槽时， 该存储槽必须先被读取， 然后与新值结合，这样同一槽中的其他数据就不会被破坏。
在处理函数参数或内存值时，因为编译器不会打包这些值，所以没有什么好处，
最后，为了让EVM对此进行优化， 确保您的存储变量和 `struct` 成员的顺序，使它们能够被紧密地包装起来。 例如，按照 `uint128, uint128, uint256` 的顺序声明您的存储变量， 而不是 `uint128, uint256, uint128`，因为前者只占用两个存储槽， 而后者则占用三个存储槽。
备注
由于存储指针可以传递给库，存储中的状态变量的结构被认为是 Solidity 外部接口的一部分。 这意味着对这一节中概述的规则的任何改变都被认为是对语言的重大改变， 由于它的关键性质，在执行之前应该非常仔细地考虑。 在发生这种重大变化的情况下，我们希望发布一种兼容模式， 在这种模式下，编译器将生成支持旧结构的字节码。
## 映射和动态数组[](#id2 "此标题的永久链接")
由于映射和动态数组的大小是不可预知的，他们不能被存储在其前后的状态变量之间。 相反，它们被认为只占用32个字节， 与 [上述规则](#storage-inplace-encoding) 有关， 它们所包含的元素被存储在一个不同的存储槽，该存储槽是用Keccak-256哈希计算的。
假设映射或数组的存储位置在适应了 [存储结构规则](#storage-inplace-encoding) 后，最终位于一个槽 `p`。 对于动态数组，这个槽存储了数组中的元素数量 （字节数组和字符串是一个例外，参见 [下文](#bytes-and-string)）。 对于映射来说，这个槽保持空的状态， 但是仍然需要它来确保即使有两个映射相邻，它们的内容最终也是在不同的存储位置。
数组数据从 `keccak256(p)` 开始，它的排列方式与静态大小的阵列数据相同： 一个元素接着一个元素，如果元素的长度不超过16字节， 就有可能共享存储槽。包含动态数组的动态数组递归地应用这一规则。 元素 `x[i][j]` 的位置为，其中 `x` 的类型是 `uint24[][]` ， 计算方法如下（同样，假设 `x` 本身存储在槽 `p`）： 槽是 `keccak256(keccak256(p)+i)+ floor(j / floor(256 / 24))`， 元素可以从槽数据 `v` 得到，使用 `(v >> ((j % floor(256 / 24)) * 24)) & type(uint24).max`。
对应于映射键 `k` 的值位于 `keccak256(h(k) . p)`， 其中 `.` 是连接符， `h` 是一个函数，根据键的类型应用于键。
* 对于值类型， 函数 `h` 将与在内存中存储值的相同方式来将值填充为32字节。
 
* 对于字符串和字节数组， `h(k)` 只是未填充的数据。
 
如果映射类型的值是一个非值类型，则计算的槽会标记为数据的开始位置。 例如，如果值是结构体类型，您必须添加一个与结构体成员相对应的偏移量才能访问到该成员。
作为示例，参考以下合约：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKCmNvbnRyYWN0IEMgewogICAgc3RydWN0IFMgeyB1aW50MTYgYTsgdWludDE2IGI7IHVpbnQyNTYgYzsgfQogICAgdWludCB4OwogICAgbWFwcGluZyh1aW50ID0+IG1hcHBpbmcodWludCA9PiBTKSkgZGF0YTsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract C {
 struct S { uint16 a; uint16 b; uint256 c; }
 uint x;
 mapping(uint \=> mapping(uint \=> S)) data;
}
让我们计算一下 `data[4][9].c` 的存储位置。 映射本身的位置是 `1` （变量 `x` 前面有32字节）。 这意味着 `data[4]` 存储在 `keccak256(uint256(4) . uint256(1))`。 `data[4]` 的类型还是一个映射， `data[4][9]` 的数据从 `keccak256(uint256(9) . keccak256(uint256(4) . uint256(1)))` 槽开始。 成员 `c` 在结构 `S` 中的槽位偏移是 `1`，因为 `a` 和 `b` 被装在一个槽位中。 这意味着 `data[4][9].c` 的插槽是 `keccak256(uint256(9) . keccak256(uint256(4) . uint256(1))) + 1`。 该值的类型是 `uint256`，所以它占用一个槽。
### `bytes` 和 `string`[](#bytes-string "此标题的永久链接")
`bytes` 和 `string` 的编码是相同的。 一般来说，编码与 `bytes1[]` 类似，即有一个槽用于存放数组本身和一个数据区， 这个数据区是用该槽的位置的 `keccak256` 哈希值计算的。 然而，对于较短的值（短于32字节），数组元素与长度一起存储在同一个槽中。
特别是：如果数据最多只有 `31` 字节长， 元素被存储在高阶字节中（左对齐），最低阶字节存储值 `length * 2`。 对于存储数据长度为 `32` 或更多字节的字节数，主槽 `p` 存储 `length * 2 + 1`， 数据照常存储在 `keccak256(p)`。这意味着您可以通过检查最低位是否被设置来区分短数组和长数组： 短数组（未设置）和长数组（设置）。
备注
目前不支持处理无效编码的槽，但将来可能会加入。 如果您通过 IR 进行编译，读取一个无效编码的槽会导致 `Panic(0x22)` 错误。
## JSON输出[](#json "此标题的永久链接")
合约的存储结构可以通过 [标准的JSON接口](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#compiler-api) 请求获得。 输出的是一个JSON对象，包含两个键， `storage` 和 `types`。 `storage` 对象是一个数组，每个元素都有以下形式：
{
 "astId": 2,
 "contract": "fileA:A",
 "label": "x",
 "offset": 0,
 "slot": "0",
 "type": "t\_uint256"
}
上面的例子来自源于项目 `fileA` 的 `contract A { uint x; }` 的存储结构，并且
* `astId` 是状态变量声明的AST节点的ID
 
* `contract` 是合约的名称，包括其路径作为前缀
 
* `label` 是状态变量的名称
 
* `offset` 是根据编码在存储槽中的字节偏移量
 
* `slot` 是状态变量所在或开始的存储槽。这个数字可能非常大，因此它的JSON值被表示为一个字符串
 
* `type` 是一个标识符，作为变量类型信息的关键（如下所述）
 
给定的 `type`，在这里是 `t_uint256`，代表 `types` 中的一个元素，它的形式是：
{
 "encoding": "inplace",
 "label": "uint256",
 "numberOfBytes": "32",
}
这里
* `encoding` 数据在存储中是如何编码的，可能的值是：
 
 * `inplace`： 数据在存储中是连续布置的（参见 [上文](#storage-inplace-encoding)）。
 
 * `mapping`： 基于Keccak-256的哈希方法（参见 [上文](#storage-hashed-encoding)）。
 
 * `dynamic_array`： 基于Keccak-256的哈希方法（参见 [上文](#storage-hashed-encoding)）。
 
 * `bytes`： 单槽或基于Keccak-256哈希值，取决于数据大小（参见 [上文](#bytes-and-string)）。
 
* `label` 是典型的类型名称。
 
* `numberOfBytes` 是使用的字节数（十进制字符串）。 注意，如果 `numberOfBytes > 32` 这意味着使用了一个以上的槽。
 
除了上述四种类型外，有些类型还有额外的信息。 映射包含它的 `key` 和 `value` 类型（再次引用这个类型映射中的一个项）， 数组有它的 `base` 类型，结构体会列出它们的 `成员`， 其格式与高层次的 `storage` 相同（参见 [上文](#storage-layout-top-level)）。
备注
合约的存储结构的JSON输出格式仍被认为是实验性的，并且在Solidity的非重大版本中会有变化。
下面的例子显示了一个合约及其存储结构，包含值类型和引用类型，被编码打包的类型，以及嵌套的类型。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwpjb250cmFjdCBBIHsKICAgIHN0cnVjdCBTIHsKICAgICAgICB1aW50MTI4IGE7CiAgICAgICAgdWludDEyOCBiOwogICAgICAgIHVpbnRbMl0gc3RhdGljQXJyYXk7CiAgICAgICAgdWludFtdIGR5bkFycmF5OwogICAgfQoKICAgIHVpbnQgeDsKICAgIHVpbnQgeTsKICAgIFMgczsKICAgIGFkZHJlc3MgYWRkcjsKICAgIG1hcHBpbmcodWludCA9PiBtYXBwaW5nKGFkZHJlc3MgPT4gYm9vbCkpIG1hcDsKICAgIHVpbnRbXSBhcnJheTsKICAgIHN0cmluZyBzMTsKICAgIGJ5dGVzIGIxOwp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract A {
 struct S {
 uint128 a;
 uint128 b;
 uint\[2\] staticArray;
 uint\[\] dynArray;
 }
 uint x;
 uint y;
 S s;
 address addr;
 mapping(uint \=> mapping(address \=> bool)) map;
 uint\[\] array;
 string s1;
 bytes b1;
}
{
 "storage": \[
 {
 "astId": 15,
 "contract": "fileA:A",
 "label": "x",
 "offset": 0,
 "slot": "0",
 "type": "t\_uint256"
 },
 {
 "astId": 17,
 "contract": "fileA:A",
 "label": "y",
 "offset": 0,
 "slot": "1",
 "type": "t\_uint256"
 },
 {
 "astId": 20,
 "contract": "fileA:A",
 "label": "s",
 "offset": 0,
 "slot": "2",
 "type": "t\_struct(S)13\_storage"
 },
 {
 "astId": 22,
 "contract": "fileA:A",
 "label": "addr",
 "offset": 0,
 "slot": "6",
 "type": "t\_address"
 },
 {
 "astId": 28,
 "contract": "fileA:A",
 "label": "map",
 "offset": 0,
 "slot": "7",
 "type": "t\_mapping(t\_uint256,t\_mapping(t\_address,t\_bool))"
 },
 {
 "astId": 31,
 "contract": "fileA:A",
 "label": "array",
 "offset": 0,
 "slot": "8",
 "type": "t\_array(t\_uint256)dyn\_storage"
 },
 {
 "astId": 33,
 "contract": "fileA:A",
 "label": "s1",
 "offset": 0,
 "slot": "9",
 "type": "t\_string\_storage"
 },
 {
 "astId": 35,
 "contract": "fileA:A",
 "label": "b1",
 "offset": 0,
 "slot": "10",
 "type": "t\_bytes\_storage"
 }
 \],
 "types": {
 "t\_address": {
 "encoding": "inplace",
 "label": "address",
 "numberOfBytes": "20"
 },
 "t\_array(t\_uint256)2\_storage": {
 "base": "t\_uint256",
 "encoding": "inplace",
 "label": "uint256\[2\]",
 "numberOfBytes": "64"
 },
 "t\_array(t\_uint256)dyn\_storage": {
 "base": "t\_uint256",
 "encoding": "dynamic\_array",
 "label": "uint256\[\]",
 "numberOfBytes": "32"
 },
 "t\_bool": {
 "encoding": "inplace",
 "label": "bool",
 "numberOfBytes": "1"
 },
 "t\_bytes\_storage": {
 "encoding": "bytes",
 "label": "bytes",
 "numberOfBytes": "32"
 },
 "t\_mapping(t\_address,t\_bool)": {
 "encoding": "mapping",
 "key": "t\_address",
 "label": "mapping(address => bool)",
 "numberOfBytes": "32",
 "value": "t\_bool"
 },
 "t\_mapping(t\_uint256,t\_mapping(t\_address,t\_bool))": {
 "encoding": "mapping",
 "key": "t\_uint256",
 "label": "mapping(uint256 => mapping(address => bool))",
 "numberOfBytes": "32",
 "value": "t\_mapping(t\_address,t\_bool)"
 },
 "t\_string\_storage": {
 "encoding": "bytes",
 "label": "string",
 "numberOfBytes": "32"
 },
 "t\_struct(S)13\_storage": {
 "encoding": "inplace",
 "label": "struct A.S",
 "members": \[
 {
 "astId": 3,
 "contract": "fileA:A",
 "label": "a",
 "offset": 0,
 "slot": "0",
 "type": "t\_uint128"
 },
 {
 "astId": 5,
 "contract": "fileA:A",
 "label": "b",
 "offset": 16,
 "slot": "0",
 "type": "t\_uint128"
 },
 {
 "astId": 9,
 "contract": "fileA:A",
 "label": "staticArray",
 "offset": 0,
 "slot": "1",
 "type": "t\_array(t\_uint256)2\_storage"
 },
 {
 "astId": 12,
 "contract": "fileA:A",
 "label": "dynArray",
 "offset": 0,
 "slot": "3",
 "type": "t\_array(t\_uint256)dyn\_storage"
 }
 \],
 "numberOfBytes": "128"
 },
 "t\_uint128": {
 "encoding": "inplace",
 "label": "uint128",
 "numberOfBytes": "16"
 },
 "t\_uint256": {
 "encoding": "inplace",
 "label": "uint256",
 "numberOfBytes": "32"
 }
 }
}

# [合约ABI规范 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/abi-spec.html) 
 _https://docs.soliditylang.org/zh-cn/latest/abi-spec.html_

## 基本设计[](#id2 "此标题的永久链接")
合约应用二进制接口（ABI）是在以太坊生态系统中与合约交互的标准方式， 包括从区块链外部和合约间的交互。数据根据其类型进行编码，如本规范中所述。 编码不是自描述的，因此需要一种特定的概要（schema）来进行解码。
我们假设合约的接口函数是强类型的，在编译时就知道，并且是静态的。 我们假设所有合约在编译时都有它们所调用的任何合约的接口定义。
本规范不涉及其接口是动态的或其他只有在运行时才知道的合约。
## 函数选择器[](#index-1 "此标题的永久链接")
一个函数调用数据的前四个字节指定了要调用的函数。 它是函数签名的 Keccak-256 哈希值的前4字节（高位在左的大端序）。 签名被定义为基本原型的典型表达，没有数据位置的指定， 也就是带有括号的参数类型列表的函数名。参数类型由一个逗号分割 - 不使用空格。
备注
一个函数的返回类型不是这个签名的一部分。在 [Solidity的函数重写](https://docs.soliditylang.org/zh-cn/latest/contracts.html#overload-function) 中， 返回类型不被考虑。原因是为了保持函数调用解析与上下文无关。 然而 [JSON描述的ABI](#abi-json) 却同时包含了输入和输出。
## 参数编码[](#id4 "此标题的永久链接")
从第5字节开始是被编码的参数。这种编码也被用在其他地方， 比如，返回值和事件的参数也会被用同样的方式进行编码， 而用来指定函数的4个字节则不需要再进行编码。
## 类型[](#id5 "此标题的永久链接")
以下是基础类型：
* `uint<M>`： `M` 位的无符号整数， `0 < M <= 256`， `M % 8 == 0`。例如： `uint32`， `uint8`， `uint256`。
 
* `int<M>`： 以 2 的补码作为符号的 `M` 位整数， `0 < M <= 256`， `M % 8 == 0`。
 
* `address`： 除了字面上的意思和语言类型的区别以外，等价于 `uint160`， 在计算和函数选择器中，通常使用 `address`。
 
* `uint`， `int`： `uint256`， `int256` 各自的同义词. 在计算和函数选择器中，通常使用 `uint256` 和 `int256`。
 
* `bool`： 等价于 `uint8`，取值限定为 0 或 1。在计算和函数选择器中，通常使用 `bool`。
 
* `fixed<M>x<N>`： `M` 位的有符号的固定小数位的十进制数字， `8 <= M <= 256`， `M % 8 == 0`， 且 `0 < N <= 80`， 其中值 `v` 是 `v / (10 ** N)`。
 
* `ufixed<M>x<N>`： 无符号的 `fixed<M>x<N>`.
 
* `fixed`， `ufixed`： `fixed128x18`， `ufixed128x18` 各自的同义词。 在计算和函数选择器中，通常使用 `fixed128x18` 和 `ufixed128x18`。
 
* `bytes<M>`： `M` 字节的二进制类型， `0 < M <= 32`。
 
* `function`： 一个地址（20 字节）之后紧跟一个函数选择器 （4 字节）。编码之后等价于 `bytes24`。
 
以下是定长数组类型：
* `<type>[M]`： 有 `M` 个元素的定长数组， `M >= 0`，数组元素为给定类型。
 
 备注
 
 虽然这个ABI规范可以表达零元素的固定长度数组，但编译器不支持它们。
 
以下是非定长类型：
* `bytes`： 动态大小的字节序列。
 
* `string`： 动态大小的 unicode 字符串，通常呈现为 UTF-8 编码。
 
* `<type>[]`： 元素为给定类型的变长数组。
 
可以将若干类型放到一对括号中，用逗号分隔开，以此来构成一个元组（tuple）：
* `(T1,T2,...,Tn)`： 由 `T1`，…， `Tn`， `n >= 0` 构成的 元组
 
用元组构成元组，用元组构成数组等等也是可能的。另外也可以构成零元组（当 `n == 0` 时）。
### 将Solidity映射到ABI类型[](#solidityabi "此标题的永久链接")
Solidity 支持上面介绍的除了元祖之外的所有同名类型。 另一方面，一些 Solidity 类型不被 ABI 支持。 下表在左栏显示了不属于ABI的Solidity类型，在右栏显示了代表它们的ABI类型。
警告
在 `0.8.0` 版本之前，枚举可以有超过256个成员，并由最小的整数类型表示，其大小刚好可以容纳任何成员的值。
## 编码的设计标准[](#id6 "此标题的永久链接")
编码被设计为具有以下属性，如果一些参数是嵌套的数组，这些属性特别有用：
1. 访问一个值所需的读取次数最多是参数数组结构内的值的深度， 即需要四次读取次数来检索 `a_i[k][l][r]`。 在ABI的前一个版本中，在最坏的情况下，读取次数的数量与动态参数的总数成线性比例。
 
2. 变量或数组元素的数据不与其他数据交错，它是可重定位的，即它只使用相对的 “地址”。
 
## 编码的形式化规范[](#id7 "此标题的永久链接")
我们区分了静态和动态类型。静态类型是直接编码的， 而动态类型是在当前块之后的一个单独分配的位置进行编码。
**定义：** 以下类型被称为“动态”：
* `bytes`
 
* `string`
 
* 任意类型 `T` 的数组 `T[]`
 
* 任意动态类型 `T` 的定长数组 `T[k]`，其中 `k >= 0`
 
* 由动态的 `Ti` （ `1 <= i <= k` ）构成的元组 `(T1,...,Tk)`
 
所有其他类型都被称为“静态”。
**定义：** `len(a)` 是一个二进制字符串 `a` 的字节长度。 `len(a)` 的类型被呈现为 `uint256`。
我们把实际的编码 `enc` 定义为一个由ABI类型到二进制字符串的值的映射， 因而，当且仅当 `X` 的类型是动态的， `len(enc(X))` 才会依赖于 `X` 的值。
**定义：** 对任意ABI值 `X`，我们根据 `X` 的实际类型递归地定义 `enc(X)`。
* `(T1,...,Tk)` 对于 `k >= 0` 且任意类型 `T1`， …， `Tk`
 
 `enc(X) = head(X(1)) ... head(X(k)) tail(X(1)) ... tail(X(k))`
 
 这里， `X = (X(1), ..., X(k))` 并且 `head` 和 `tail` 被定义为如下 `Ti` ：
 
 如果 `Ti` 是静态类型：
 
 > `head(X(i)) = enc(X(i))` 和 `tail(X(i)) = ""` （空字符串）
 
 否则，即 `Ti` 是动态类型时，它们被定义为：
 
 > `head(X(i)) = enc(len( head(X(1)) ... head(X(k)) tail(X(1)) ... tail(X(i-1)) ))` `tail(X(i)) = enc(X(i))`
 
 注意，在动态类型的情况下，由于 head 部分的长度仅取决于类型而非值，所以 `head(X(i))` 是定义明确的。 它的值是从 `enc(X)` 的开始算起的， `tail(X(i))` 的起始位在 `head(X(i))` 中的偏移量。
 
* `T[k]` 对于任意 `T` 和 `k`：
 
 `enc(X) = enc((X[0], ..., X[k-1]))`
 
 即，它就像是个由相同类型的 `k` 个元素组成的元组那样被编码的。
 
* `T[]` 当 `X` 有 `k` 个元素 （ `k` 的类型为 `uint256`）：
 
 `enc(X) = enc(k) enc((X[0], ..., X[k-1]))`
 
 也就是说，它被编码为具有相同类型的 `k` 元素的元组（即静态大小为 `k` 的数组），前缀为元素的数量。
 
* 具有 `k` 字节长度的 `bytes`， （假设其类型为 `uint256`）：
 
 `enc(X) = enc(k) pad_right(X)`，即，字节数被编码为 `uint256`，紧跟着实际的 `X` 的字节码序列， 再在前边（左边）补上可以使 `len(enc(X))` 成为 32 的倍数的最少数量的 0 值字节数据。
 
* `string`：
 
 `enc(X) = enc(enc_utf8(X))`， 即 `X` 被 UTF-8 编码，且在后续编码中将这个值解释为 `bytes` 类型。 注意，在随后的编码中使用的长度是其 UTF-8 编码的字符串的字节数，而不是其字符数。
 
* `uint<M>`： `enc(X)` 是在 `X` 的大端序编码的高位（左侧）补充若干 0 值字节以使其长度成为 32 字节。
 
* `address`： 与 `uint160` 的情况相同。
 
* `int<M>`： `enc(X)` 是在 `X` 的大端序的 2 的补码编码的高位（左侧）添加若干字节数据以使其长度成为 32 字节； 对于负数，添加值为 `0xff` 的字节数据，对于正数，添加 0 值字节数据。
 
* `bool`： 与 `uint8` 的情况相同， `1` 用来表示 `true`， `0` 表示 `false`。
 
* `fixed<M>x<N>`： `enc(X)` 就是 `enc(X * 10**N)`，其中 `X * 10**N` 可以理解为 `int256`。
 
* `fixed`： 与 `fixed128x18` 的情况相同。
 
* `ufixed<M>x<N>`： `enc(X)` 就是 `enc(X * 10**N)` ，其中 `X * 10**N` 可以理解为 `uint256`。
 
* `ufixed`： 与 `ufixed128x18` 的情况相同。
 
* `bytes<M>`： `enc(X)` 就是 `X` 的字节序列加上为使长度成为 32 字节而添加的若干 0 值字节。
 
注意，对于任意的 `X`， `len(enc(X))` 都是 32 的倍数。
## 函数选择器和参数编码[](#id8 "此标题的永久链接")
总而言之，对带有参数 `a_1, ..., a_n` 的函数 `f` 的调用被编码为：
> `function_selector(f) enc((a_1, ..., a_n))`
`f` 的返回值 `v_1, ..., v_k` 会被编码为：
> `enc((v_1, ..., v_k))`
也就是说，返回值会被组合为一个元组（tuple）进行编码。
## 示例[](#id9 "此标题的永久链接")
给定一个合约：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEZvbyB7CiAgICBmdW5jdGlvbiBiYXIoYnl0ZXMzWzJdIG1lbW9yeSkgcHVibGljIHB1cmUge30KICAgIGZ1bmN0aW9uIGJheih1aW50MzIgeCwgYm9vbCB5KSBwdWJsaWMgcHVyZSByZXR1cm5zIChib29sIHIpIHsgciA9IHggPiAzMiB8fCB5OyB9CiAgICBmdW5jdGlvbiBzYW0oYnl0ZXMgbWVtb3J5LCBib29sLCB1aW50W10gbWVtb3J5KSBwdWJsaWMgcHVyZSB7fQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract Foo {
 function bar(bytes3\[2\] memory) public pure {}
 function baz(uint32 x, bool y) public pure returns (bool r) { r \= x \> 32 || y; }
 function sam(bytes memory, bool, uint\[\] memory) public pure {}
}
因此，对于我们的示例 `Foo` 合约，如果我们想用 `["abc", "def"]` 做参数调用函数 `bar`，我们总共需要传送68字节，可以分解为：
* `0xfce353f6`： 方法ID。这是从 `bar(bytes3[2])` 的签名派生出来的。
 
* `0x6162630000000000000000000000000000000000000000000000000000000000`： 第一个参数的第一部分， 一个 `bytes3` 类型的值 `"abc"` （左对齐）。
 
* `0x6465660000000000000000000000000000000000000000000000000000000000`： 第一个参数的第二部分， 一个 `bytes3` 类型的值 `"def"` （左对齐）。
 
合起来就是：
0xfce353f661626300000000000000000000000000000000000000000000000000000000006465660000000000000000000000000000000000000000000000000000000000
如果我们想用 `69` 和 `true` 做参数调用函数 `baz`， 我们总共需要传送68字节，可以分解为：
* `0xcdcd77c0`： 方法ID。这源自ASCII格式的 `baz(uint32,bool)` 签名的Keccak哈希的前4字节。
 
* `0x0000000000000000000000000000000000000000000000000000000000000045`： 第一个参数， 一个被用0值字节补充到32字节的uint32值 `69`。
 
* `0x0000000000000000000000000000000000000000000000000000000000000001`： 第二个参数， 一个被用0值字节补充到32字节的boolean值 `true`。
 
合起来就是:
0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001
它返回一个 `bool`。比如它返回 `false`， 那么它的输出将是一个字节数组 `0x0000000000000000000000000000000000000000000000000000000000000000`， 一个 `bool` 值。
如果我们想用 `"dave"`， `true` 和 `[1,2,3]` 作为参数调用 `sam`， 我们总共需要传送292字节，可以分解为：
* `0xa5643bf2`： 方法ID。这是从签名 `sam(bytes,bool,uint256[])` 中导出的。注意， `uint` 被替换为其典型代表 `uint256`。
 
* `0x0000000000000000000000000000000000000000000000000000000000000060`： 第一个参数（动态类型）的数据部分的位置，即从参数编码块开始位置算起的字节数。在这里，是 `0x60` 。
 
* `0x0000000000000000000000000000000000000000000000000000000000000001`： 第二个参数：boolean 的 true。
 
* `0x00000000000000000000000000000000000000000000000000000000000000a0`： 第三个参数（动态类型）的数据部分的位置，由字节数计量。在这里，是 `0xa0`。
 
* `0x0000000000000000000000000000000000000000000000000000000000000004`： 第一个参数的数据部分，以字节数组的元素个数作为开始，在这里，是 4。
 
* `0x6461766500000000000000000000000000000000000000000000000000000000`： 第一个参数的内容： `"dave"` 的 UTF-8 编码（在这里等同于 ASCII 编码），并在右侧（低位）用 0 值字节补充到 32 字节。
 
* `0x0000000000000000000000000000000000000000000000000000000000000003`： 第三个参数的数据部分，以数组的元素个数作为开始，在这里，是 3。
 
* `0x0000000000000000000000000000000000000000000000000000000000000001`： 第三个参数的第一个数组元素。
 
* `0x0000000000000000000000000000000000000000000000000000000000000002`： 第三个参数的第二个数组元素。
 
* `0x0000000000000000000000000000000000000000000000000000000000000003`： 第三个参数的第三个数组元素。
 
合起来就是:
0xa5643bf20000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003
## 动态类型的使用[](#id10 "此标题的永久链接")
用值为 `(0x123, [0x456, 0x789], "1234567890", "Hello, world!")` 的签名参数调用 函数 `f(uint256,uint32[],bytes10,bytes)`，其的编码方式如下：
我们取 `keccak("f(uint256,uint32[],bytes10,bytes)")` 的前四个字节，即 `0x8be65246`。 然后我们对所有四个参数的头部部分进行编码。对静态类型 `uint256` 和 `bytes10`， 这些是我们要直接传递的值，而对于动态类型 `uint32[]` 和 `bytes`， 我们使用其数据区开始的偏移量，从需编码的值的开始位置算起 （即不计算包含函数签名哈希值的前四个字节）。也就是：
* `0x0000000000000000000000000000000000000000000000000000000000000123` （ `0x123` 补充到 32 字节）
 
* `0x0000000000000000000000000000000000000000000000000000000000000080` （第二个参数的数据部分起始位置的偏移量，4\*32 字节，正好是头部的大小）
 
* `0x3132333435363738393000000000000000000000000000000000000000000000` （ `"1234567890"` 从右边补充到 32 字节）
 
* `0x00000000000000000000000000000000000000000000000000000000000000e0` （第四个参数的数据部分起始位置的偏移量 = 第一个动态参数的数据部分起始位置的偏移量 + 第一个动态参数的数据部分的长度 = 4\*32 + 3\*32，参考后文）
 
在此之后，跟着第一个动态参数的数据部分， `[0x456, 0x789]` ：
* `0x0000000000000000000000000000000000000000000000000000000000000002` （数组元素个数，2）
 
* `0x0000000000000000000000000000000000000000000000000000000000000456` （第一个数组元素）
 
* `0x0000000000000000000000000000000000000000000000000000000000000789` （第二个数组元素）
 
最后，我们将第二个动态参数的数据部分 `"Hello, world!"` 进行编码：
* `0x000000000000000000000000000000000000000000000000000000000000000d` （元素个数，在这里是字节数：13）
 
* `0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000` （ `"Hello, world!"` 从右边补充到 32 字节）
 
最后，合并到一起的编码就是（为了清晰，在函数选择器和每 32 字节之后加了换行）：
0x8be65246
 0000000000000000000000000000000000000000000000000000000000000123
 0000000000000000000000000000000000000000000000000000000000000080
 3132333435363738393000000000000000000000000000000000000000000000
 00000000000000000000000000000000000000000000000000000000000000e0
 0000000000000000000000000000000000000000000000000000000000000002
 0000000000000000000000000000000000000000000000000000000000000456
 0000000000000000000000000000000000000000000000000000000000000789
 000000000000000000000000000000000000000000000000000000000000000d
 48656c6c6f2c20776f726c642100000000000000000000000000000000000000
让我们使用相同的原理来对一个签名为 `g(uint256[][],string[])` ，参数值为 `([[1, 2], [3]], ["one", "two", "three"])` 的函数来进行编码；但从最原子的部分开始：
首先我们将第一个根数组 `[[1, 2], [3]]` 的第一个嵌入的动态数组 `[1, 2]` 的长度和数据进行编码：
* `0x0000000000000000000000000000000000000000000000000000000000000002` (第一个数组中的元素数量 2；元素本身是 `1` 和 `2`)
 
* `0x0000000000000000000000000000000000000000000000000000000000000001` (第一个元素)
 
* `0x0000000000000000000000000000000000000000000000000000000000000002` (第二个元素)
 
然后我们对第一个根数组 `[[1, 2], [3]]` 的第二个嵌入式动态数组 `[3]` 的长度和数据进行编码：
* `0x0000000000000000000000000000000000000000000000000000000000000001` (第二个数组中的元素数量 1；元素数据是 `3`)
 
* `0x0000000000000000000000000000000000000000000000000000000000000003` (第一个元素)
 
然后我们需要为各自的动态数组 `[1, 2]` 和 `[3]` 找到偏移量 `a` 和 `b`。 为了计算偏移量，我们可以看一下第一个根数组的编码数据 `[[1, 2], [3]]` 在编码中枚举每一行。
0 - a - \[1, 2\] 的偏移量
1 - b - \[3\] 的偏移量
2 - 0000000000000000000000000000000000000000000000000000000000000002 - \[1, 2\] 数组的计数
3 - 0000000000000000000000000000000000000000000000000000000000000001 - 1 的编码
4 - 0000000000000000000000000000000000000000000000000000000000000002 - 2 的编码
5 - 0000000000000000000000000000000000000000000000000000000000000001 - \[3\] 数组的计数
6 - 0000000000000000000000000000000000000000000000000000000000000003 - 3 的编码
偏移量 `a` 指向数组 `[1, 2]` 内容的开始位置，即第 2 行的开始（64 字节）； 所以 `a = 0x0000000000000000000000000000000000000000000000000000000000000040`。
偏移量 `b` 指向数组 `[3]` 内容的开始位置，即第 5 行的开始（160 字节）； 所以 `b = 0x00000000000000000000000000000000000000000000000000000000000000a0`。
然后我们对第二个根数组的嵌入字符串进行编码：
* `0x0000000000000000000000000000000000000000000000000000000000000003` (单词 `"one"` 中的字符个数)
 
* `0x6f6e650000000000000000000000000000000000000000000000000000000000` (单词 `"one"` 的 utf8 编码)
 
* `0x0000000000000000000000000000000000000000000000000000000000000003` (单词 `"two"` 中的字符个数)
 
* `0x74776f0000000000000000000000000000000000000000000000000000000000` (单词 `"two"` 的 utf8 编码)
 
* `0x0000000000000000000000000000000000000000000000000000000000000005` (单词 `"three"` 中的字符个数)
 
* `0x7468726565000000000000000000000000000000000000000000000000000000` (单词 `"three"` 的 utf8 编码)
 
作为与第一个根数组的并列，因为字符串也属于动态元素，我们也需要找到它们的偏移量 `c`, `d` 和 `e`：
0 - c - "one" 的偏移量
1 - d - "two" 的偏移量
2 - e - "three" 的偏移量
3 - 0000000000000000000000000000000000000000000000000000000000000003 - "one" 的字符计数
4 - 6f6e650000000000000000000000000000000000000000000000000000000000 - "one" 的编码
5 - 0000000000000000000000000000000000000000000000000000000000000003 - "two" 的字符计数
6 - 74776f0000000000000000000000000000000000000000000000000000000000 - "two" 的编码
7 - 0000000000000000000000000000000000000000000000000000000000000005 - "three" 的字符计数
8 - 7468726565000000000000000000000000000000000000000000000000000000 - "three" 的编码
偏移量 `c` 指向字符串 `"one"` 内容的开始位置，即第 3 行的开始（96 字节）； 所以 `c = 0x0000000000000000000000000000000000000000000000000000000000000060`。
偏移量 `d` 指向字符串 `"two"` 内容的开始位置，即第 5 行的开始（160 字节）； 所以 `d = 0x00000000000000000000000000000000000000000000000000000000000000a0`。
偏移量 `e` 指向字符串 `"three"` 内容的开始位置，即第 7 行的开始（224 字节）； 所以 `e = 0x00000000000000000000000000000000000000000000000000000000000000e0`。
注意，根数组的嵌入元素的编码并不互相依赖，且具有对于函数签名 `g(string[],uint256[][])` 所相同的编码。
然后我们对第一个根数组的长度进行编码：
* `0x0000000000000000000000000000000000000000000000000000000000000002` (第一个根数组的元素数量 2；这些元素本身是 `[1, 2]` 和 `[3]`)
 
而后我们对第二个根数组的长度进行编码：
* `0x0000000000000000000000000000000000000000000000000000000000000003` (第二个根数组的元素数量 3；这些字符串本身是 `"one"`， `"two"` 和 `"three"`)
 
最后，我们找到根动态数组元素 `[[1, 2], [3]]` 和 `["one", "two", "three"]` 的偏移量 `f` 和 `g`。 汇编数据的正确顺序如下：
0x2289b18c - 函数签名
 0 - f - \[\[1, 2\], \[3\]\] 的偏移量
 1 - g - \["one", "two", "three"\] 的偏移量
 2 - 0000000000000000000000000000000000000000000000000000000000000002 - \[\[1, 2\], \[3\]\] 的元素计数
 3 - 0000000000000000000000000000000000000000000000000000000000000040 - \[1, 2\] 的偏移量
 4 - 00000000000000000000000000000000000000000000000000000000000000a0 - \[3\] 的偏移量
 5 - 0000000000000000000000000000000000000000000000000000000000000002 - \[1, 2\] 的元素计数
 6 - 0000000000000000000000000000000000000000000000000000000000000001 - 1 的编码
 7 - 0000000000000000000000000000000000000000000000000000000000000002 - 2 的编码
 8 - 0000000000000000000000000000000000000000000000000000000000000001 - \[3\] 的元素计数
 9 - 0000000000000000000000000000000000000000000000000000000000000003 - 3 的编码
10 - 0000000000000000000000000000000000000000000000000000000000000003 - \["one", "two", "three"\] 的元素计数
11 - 0000000000000000000000000000000000000000000000000000000000000060 - 的偏移量"one"
12 - 00000000000000000000000000000000000000000000000000000000000000a0 - 的偏移量"two"
13 - 00000000000000000000000000000000000000000000000000000000000000e0 - 的偏移量"three"
14 - 0000000000000000000000000000000000000000000000000000000000000003 - "one" 的字符计数
15 - 6f6e650000000000000000000000000000000000000000000000000000000000 - "one" 的编码
16 - 0000000000000000000000000000000000000000000000000000000000000003 - "two" 的字符计数
17 - 74776f0000000000000000000000000000000000000000000000000000000000 - "two" 的编码
18 - 0000000000000000000000000000000000000000000000000000000000000005 - "three" 的字符计数
19 - 7468726565000000000000000000000000000000000000000000000000000000 - "three" 的编码
偏移量 `f` 指向数组 `[[1, 2], [3]]` 内容的开始位置，即第 2 行的开始（64 字节）； 所以 `f = 0x0000000000000000000000000000000000000000000000000000000000000040`。
偏移量 `g` 指向数组 `["one", "two", "three"]` 内容的开始位置，即第 10 行的开始（320 字节）； 所以 `g = 0x0000000000000000000000000000000000000000000000000000000000000140`。
## 事件[](#abi-events "此标题的永久链接")
事件是Ethereum日志/事件观察协议的一个抽象。日志条目提供了合约的地址， 一系列最多四个主题和一些任意长度的二进制数据。 事件利用现有的函数ABI，以便将其（连同接口规范）解释为一个正确的类型化结构。
给定一个事件名称和一系列的事件参数，我们把它们分成两个子系列：那些有索引的和那些没有索引的。 那些被索引的参数，可能多达3个（对于非匿名事件）或4个（对于匿名事件）， 与事件签名的Keccak散列一起使用，形成日志条目的主题。 那些没有索引的则构成事件的字节数组。
实际上，使用该ABI的日志条目被描述为:
* `address`： 合约的地址（由以太坊真正提供）;
 
* `topics[0]`： `keccak(EVENT_NAME+"("+EVENT_ARGS.map(canonical_type_of).join(",")+")")` `canonical_type_of` 是一个可以返回给定参数的权威类型的函数，例如，对 `uint indexed foo` 它会返回 `uint256`）。 如果事件被声明为 `anonymous`，那么 `topics[0]` 不会被生成；
 
* `topics[n]`： 如果事件没有被声明为 `anonymous`， 则为 `abi_encode(EVENT_INDEXED_ARGS[n - 1])` 或者如果它被声明为该类型，则为 `abi_encode(EVENT_INDEXED_ARGS[n])` （ `EVENT_INDEXED_ARGS` 是被索引的 `EVENT_ARGS` 的系列）;
 
* `data`： `EVENT_NON_INDEXED_ARGS` 的ABI编码 （ `EVENT_NON_INDEXED_ARGS` 是一系列没有索引的 `EVENT_ARGS`， `abi_encode` 是ABI编码函数， 用于从一个函数返回一系列类型的值，如上所述）。
 
对于所有长度不超过32字节的类型， `EVENT_INDEXED_ARGS` 数组直接包含数值，填充或符号扩展（对于有符号整数）到32字节， 就像常规ABI编码一样。然而，对于所有 “复杂” 类型或动态长度的类型，包括所有数组， `string`， `bytes` 和结构， `EVENT_INDEXED_ARGS` 将包含 _Keccak散列_ 的特殊就地编码值（见 [索引事件参数的编码](#indexed-event-encoding)）， 而不是直接编码的值。这允许应用程序有效地查询动态长度类型的值（通过设置编码值的哈希值作为主题）， 但使应用程序无法解码他们没有查询到的索引值。对于动态长度类型， 应用程序开发人员面临着对预定值的快速搜索（如果参数有索引）和任意值的可读性之间的权衡（这要求参数不被索引）。 开发者可以通过定义具有两个参数的事件 – 一个是索引的，一个是不索引的 – 来克服这种权衡，实现高效搜索和任意可读性。
## 错误[](#index-2 "此标题的永久链接")
在合约内部发生故障的情况下，合约可以使用一个特殊的操作码来中止执行，并恢复所有的状态变化。 除了这些效果之外，描述性数据可以返回给调用者。 这种描述性数据是对一个错误及其参数的编码，其方式与函数调用的数据相同。
作为一个例子，让我们考虑以下合约，它的 `transfer` 函数总是以 “余额不足” 的自定义错误返回。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IFRlc3RUb2tlbiB7CiAgICBlcnJvciBJbnN1ZmZpY2llbnRCYWxhbmNlKHVpbnQyNTYgYXZhaWxhYmxlLCB1aW50MjU2IHJlcXVpcmVkKTsKICAgIGZ1bmN0aW9uIHRyYW5zZmVyKGFkZHJlc3MgLyp0byovLCB1aW50IGFtb3VudCkgcHVibGljIHB1cmUgewogICAgICAgIHJldmVydCBJbnN1ZmZpY2llbnRCYWxhbmNlKDAsIGFtb3VudCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract TestToken {
 error InsufficientBalance(uint256 available, uint256 required);
 function transfer(address /\*to\*/, uint amount) public pure {
 revert InsufficientBalance(0, amount);
 }
}
返回数据的编码方式与函数 `InsufficientBalance(0, amount)` 对函数 `InsufficientBalance(uint256,uint256)` 的调用方式相同。 即 `0xcf479181`， `uint256(0)`， `uint256(amount)`。
错误选择器 `0x00000000` 和 `0xffffffff` 是保留给将来使用的。
警告
永远不要相信错误数据。 默认情况下，错误数据通过外部调用在链向上冒泡产生， 这意味着一个合约可能会收到一个它直接调用的任何合约中没有定义的错误。 此外，任何合约都可以通过返回与错误签名相匹配的数据来伪造任何错误，即使该错误没有在任何地方定义。
## JSON[](#json "此标题的永久链接")
合约接口的JSON格式是由一个函数，事件和错误描述的数组给出的。 一个函数描述是一个带有字段的JSON对象：
* `type`： `"function"`， `"constructor"`， `"receive"` （ [“接收以太币” 函数](https://docs.soliditylang.org/zh-cn/latest/contracts.html#receive-ether-function) ） 或者 `"fallback"` （ [“默认” 函数](https://docs.soliditylang.org/zh-cn/latest/contracts.html#fallback-function)）；
 
* `name`： 函数名称；
 
* `inputs`： 数组对象，每个数组对象会包含：
 
 * `name`： 参数名称；
 
 * `type`： 参数的权威类型（详见下文）
 
 * `components`： 供元组（tuple） 类型使用（详见下文）
 
* `outputs`： 一个类似于 `inputs` 的数组对象。
 
* `stateMutability`： 为下列值之一： `pure` （[指定为不读取区块链状态](https://docs.soliditylang.org/zh-cn/latest/contracts.html#pure-functions)）， `view` （[指定为不修改区块链状态](https://docs.soliditylang.org/zh-cn/latest/contracts.html#view-functions)）， `nonpayable` （函数不接受以太币 - 默认选项） 和 `payable` （函数可接收以太币）。
 
构造函数（constructor）， receive 函数 和 fallback 函数没有 `name` 或 `outputs` 属性。 receive 函数 和 fallback 函数也没有 `inputs` 属性。
备注
向不接收以太币函数发送非零的以太币将使交易回滚。
备注
在Solidity中，状态可变性 `不可支付` 是完全不指定状态可变性时的修饰语。
一个事件描述是一个有极其相似字段的 JSON 对象：
* `type`： 总是 `"event"`
 
* `name`： 事件名称；
 
* `inputs`： 对象数组，每个数组对象会包含：
 
 * `name`： 参数名称。
 
 * `type`： 参数的规范类型（详见下文）。
 
 * `components`： 供元组（tuple） 类型使用（详见下文）
 
 * `indexed`： 如果字段是日志主题的一部分，则为 `true`；如果它是日志数据段的一部分，则为 `false`。
 
* `anonymous`： 如果事件被声明为 `anonymous`，则为 `true`。
 
错误消息如下：
* `type`： 总是 `"error"`
 
* `name`： 错误名称；
 
* `inputs`： 对象数组，每个数组对象会包含：
 
 * `name`： 参数名称。
 
 * `type`： 参数的权威类型（相见下文）。
 
 * `components`： 供元组（tuple） 类型使用（详见下文）。
 
备注
在 JSON 数组中可能有多个具有相同名称的错误，甚至具有相同的签名； 例如，如果错误源自合约中的不同文件或从另一个合约引用。 对于ABI来说，只有错误本身的名称是相关的，而不是它的定义位置。
例如，
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCgpjb250cmFjdCBUZXN0IHsKICAgIGNvbnN0cnVjdG9yKCkgeyBiID0gaGV4IjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyIjsgfQogICAgZXZlbnQgRXZlbnQodWludCBpbmRleGVkIGEsIGJ5dGVzMzIgYik7CiAgICBldmVudCBFdmVudDIodWludCBpbmRleGVkIGEsIGJ5dGVzMzIgYik7CiAgICBlcnJvciBJbnN1ZmZpY2llbnRCYWxhbmNlKHVpbnQyNTYgYXZhaWxhYmxlLCB1aW50MjU2IHJlcXVpcmVkKTsKICAgIGZ1bmN0aW9uIGZvbyh1aW50IGEpIHB1YmxpYyB7IGVtaXQgRXZlbnQoYSwgYik7IH0KICAgIGJ5dGVzMzIgYjsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract Test {
 constructor() { b \= hex"12345678901234567890123456789012"; }
 event Event(uint indexed a, bytes32 b);
 event Event2(uint indexed a, bytes32 b);
 error InsufficientBalance(uint256 available, uint256 required);
 function foo(uint a) public { emit Event(a, b); }
 bytes32 b;
}
可由如下 JSON 来表示：
\[{
"type":"error",
"inputs": \[{"name":"available","type":"uint256"},{"name":"required","type":"uint256"}\],
"name":"InsufficientBalance"
}, {
"type":"event",
"inputs": \[{"name":"a","type":"uint256","indexed":true},{"name":"b","type":"bytes32","indexed":false}\],
"name":"Event"
}, {
"type":"event",
"inputs": \[{"name":"a","type":"uint256","indexed":true},{"name":"b","type":"bytes32","indexed":false}\],
"name":"Event2"
}, {
"type":"function",
"inputs": \[{"name":"a","type":"uint256"}\],
"name":"foo",
"outputs": \[\]
}\]
### 处理元组类型[](#id13 "此标题的永久链接")
尽管名称被有意地不作为 ABI 编码的一部分，但将它们包含进 JSON 来显示给最终用户是非常合理的。 其结构会按下列方式进行嵌套：
一个拥有 `name`， `type` 和潜在的 `components` 成员的对象描述了某种类型的变量。 直至到达一个元组（tuple） 类型且到那点的存储在 `type` 属性中的字符串以 `tuple` 为前缀， 也就是说，在 `tuple` 之后紧跟一个 `[]` 或有整数 `k` 的 `[k]`，才 能确定一个元组。 元组的组件元素会被存储在成员 `components` 中， 它是一个数组类型，且与顶级对象具有同样的结构，只是在这里不允许 `已索引的（indexed）` 数组元素。
示例代码：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjUgPDAuOS4wOwpwcmFnbWEgYWJpY29kZXIgdjI7Cgpjb250cmFjdCBUZXN0IHsKICAgIHN0cnVjdCBTIHsgdWludCBhOyB1aW50W10gYjsgVFtdIGM7IH0KICAgIHN0cnVjdCBUIHsgdWludCB4OyB1aW50IHk7IH0KICAgIGZ1bmN0aW9uIGYoUyBtZW1vcnksIFQgbWVtb3J5LCB1aW50KSBwdWJsaWMgcHVyZSB7fQogICAgZnVuY3Rpb24gZygpIHB1YmxpYyBwdXJlIHJldHVybnMgKFMgbWVtb3J5LCBUIG1lbW9yeSwgdWludCkge30KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.5 <0.9.0;
pragma abicoder v2;
contract Test {
 struct S { uint a; uint\[\] b; T\[\] c; }
 struct T { uint x; uint y; }
 function f(S memory, T memory, uint) public pure {}
 function g() public pure returns (S memory, T memory, uint) {}
}
可由如下 JSON 来表示：
\[
 {
 "name": "f",
 "type": "function",
 "inputs": \[
 {
 "name": "s",
 "type": "tuple",
 "components": \[
 {
 "name": "a",
 "type": "uint256"
 },
 {
 "name": "b",
 "type": "uint256\[\]"
 },
 {
 "name": "c",
 "type": "tuple\[\]",
 "components": \[
 {
 "name": "x",
 "type": "uint256"
 },
 {
 "name": "y",
 "type": "uint256"
 }
 \]
 }
 \]
 },
 {
 "name": "t",
 "type": "tuple",
 "components": \[
 {
 "name": "x",
 "type": "uint256"
 },
 {
 "name": "y",
 "type": "uint256"
 }
 \]
 },
 {
 "name": "a",
 "type": "uint256"
 }
 \],
 "outputs": \[\]
 }
\]
## 严格的编码模式[](#abi-packed-mode "此标题的永久链接")
严格的编码模式是指导致与上述正式规范中定义的编码完全相同的模式。 这意味着偏移量必须尽可能小，同时还不能在数据区域产生重叠， 因此不允许有间隙。
通常，ABI 解码器是通过遵循偏移指针以简单的方式编写的， 但有些解码器可能会强制执行严格模式。 Solidity ABI 解码器目前并不强制执行严格模式，但编码器总是以严格模式创建数据。
## 非标准打包模式[](#id15 "此标题的永久链接")
通过 `abi.encodePacked()`，Solidity支持一种非标准的打包模式，其中：
* 短于32字节的类型直接连接，没有填充或符号扩展。
 
* 动态类型是直接编码的，没有长度。
 
* 数组元素被填充，但仍被是直接编码
 
此外，不支持结构以及嵌套数组。
例如，对 `int16(-1), bytes1(0x42), uint16(0x03), string("Hello, world!")` 进行编码将生成如下结果
0xffff42000348656c6c6f2c20776f726c6421
 ^^^^ int16(-1)
 ^^ bytes1(0x42)
 ^^^^ uint16(0x03)
 ^^^^^^^^^^^^^^^^^^^^^^^^^^ 字符串（"Hello, world!"） 没有长度字段
更具体地说：
* 在编码过程中，所有东西都是直接编码的。这意味着没有像ABI编码那样区分头和尾，也没有对数组的长度进行编码。
 
* `abi.encodePacked` 的直接参数被编码， 只要不是数组（或 `string` 或 `bytes` ），就不需要填充。
 
* 一个数组的编码是其元素的编码 **与** 填充的连接。
 
* 动态大小的类型，如 `string`， `bytes` 或 `uint[]`，在编码时没有长度字段。
 
* `string` 或 `bytes` 的编码不会在末尾应用填充， 除非它是数组或结构体的一部分（然后它被填充为32字节的倍数）。
 
一般来说，只要有两个动态大小的元素，编码就会模糊不清，因为缺少长度字段。
如果需要填充，可以使用明确的类型转换： `abi.encodePacked(uint16(0x12)) == hex"0012"`。
由于在调用函数时不使用打包编码，所以没有特别支持预留函数选择器。 由于编码是模糊的，所以没有解码功能。
警告
如果使用 `keccak256(abi.encodePacked(a，b))` 并且 `a` 和 `b` 都是动态类型， 那么通过将 `a` 的部分移动到 `b` 中，很容易在哈希值中产生冲突，反之亦然。 更具体地说， `abi.encodePacked("a", "bc") == abi.encodePacked("ab", "c")`。 如果你使用 `abi.encodePacked` 进行签名、认证或数据完整性，确保总是使用相同的类型， 并检查其中最多一个是动态的。除非有令人信服的理由，否则应首选 `abi.encode`。
## 索引事件参数的编码[](#indexed-event-encoding "此标题的永久链接")
不属于值类型的索引事件参数，即数组和结构，不直接存储， 而是存储一个编码的 Keccak-256 哈希值。这个编码的定义如下：
* `bytes` 和 `string` 值的编码只是字符串的内容，没有任何填充或长度前缀。
 
* 结构的编码是其成员编码的串联，总是填充为32字节的倍数（甚至是 `bytes` 和 `string`）。
 
* 数组的编码（包括动态和静态大小）是其元素编码的连接， 总是填充为32字节的倍数（甚至是 `bytes` 和 `string`），没有任何长度前缀。
 
在上面，像往常一样，一个负数被填充符号扩展，而不是零填充。 `bytesNN` 类型被填充在右边，而 `uintNN` / `intNN` 被填充在左边。
警告
如果一个结构包含一个以上的动态大小的数组，那么它的编码是不明确的。 正因为如此，要经常重新检查事件数据，不要只依赖基于索引参数的搜索结果。

# [Contracts — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/contracts.html) 
 _https://docs.soliditylang.org/en/latest/contracts.html_

Contracts in Solidity are similar to classes in object-oriented languages. They contain persistent data in state variables, and functions that can modify these variables. Calling a function on a different contract (instance) will perform an EVM function call and thus switch the context such that state variables in the calling contract are inaccessible. A contract and its functions need to be called for anything to happen. There is no “cron” concept in Ethereum to call a function at a particular event automatically.
## Creating Contracts[](#creating-contracts "Link to this heading")
Contracts can be created “from outside” via Ethereum transactions or from within Solidity contracts.
IDEs, such as [Remix](https://remix.ethereum.org/), make the creation process seamless using UI elements.
One way to create contracts programmatically on Ethereum is via the JavaScript API [web3.js](https://github.com/web3/web3.js). It has a function called [web3.eth.Contract](https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract) to facilitate contract creation.
When a contract is created, its [constructor](#constructor) (a function declared with the `constructor` keyword) is executed once.
A constructor is optional. Only one constructor is allowed, which means overloading is not supported.
After the constructor has executed, the final code of the contract is stored on the blockchain. This code includes all public and external functions and all functions that are reachable from there through function calls. The deployed code does not include the constructor code or internal functions only called from the constructor.
Internally, constructor arguments are passed [ABI encoded](https://docs.soliditylang.org/en/latest/abi-spec.html#abi) after the code of the contract itself, but you do not have to care about this if you use `web3.js`.
If a contract wants to create another contract, the source code (and the binary) of the created contract has to be known to the creator. This means that cyclic creation dependencies are impossible.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCgpjb250cmFjdCBPd25lZFRva2VuIHsKICAgIC8vIGBUb2tlbkNyZWF0b3JgIGlzIGEgY29udHJhY3QgdHlwZSB0aGF0IGlzIGRlZmluZWQgYmVsb3cuCiAgICAvLyBJdCBpcyBmaW5lIHRvIHJlZmVyZW5jZSBpdCBhcyBsb25nIGFzIGl0IGlzIG5vdCB1c2VkCiAgICAvLyB0byBjcmVhdGUgYSBuZXcgY29udHJhY3QuCiAgICBUb2tlbkNyZWF0b3IgY3JlYXRvcjsKICAgIGFkZHJlc3Mgb3duZXI7CiAgICBieXRlczMyIG5hbWU7CgogICAgLy8gVGhpcyBpcyB0aGUgY29uc3RydWN0b3Igd2hpY2ggcmVnaXN0ZXJzIHRoZQogICAgLy8gY3JlYXRvciBhbmQgdGhlIGFzc2lnbmVkIG5hbWUuCiAgICBjb25zdHJ1Y3RvcihieXRlczMyIG5hbWVfKSB7CiAgICAgICAgLy8gU3RhdGUgdmFyaWFibGVzIGFyZSBhY2Nlc3NlZCB2aWEgdGhlaXIgbmFtZQogICAgICAgIC8vIGFuZCBub3QgdmlhIGUuZy4gYHRoaXMub3duZXJgLiBGdW5jdGlvbnMgY2FuCiAgICAgICAgLy8gYmUgYWNjZXNzZWQgZGlyZWN0bHkgb3IgdGhyb3VnaCBgdGhpcy5mYCwKICAgICAgICAvLyBidXQgdGhlIGxhdHRlciBwcm92aWRlcyBhbiBleHRlcm5hbCB2aWV3CiAgICAgICAgLy8gdG8gdGhlIGZ1bmN0aW9uLiBFc3BlY2lhbGx5IGluIHRoZSBjb25zdHJ1Y3RvciwKICAgICAgICAvLyB5b3Ugc2hvdWxkIG5vdCBhY2Nlc3MgZnVuY3Rpb25zIGV4dGVybmFsbHksCiAgICAgICAgLy8gYmVjYXVzZSB0aGUgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QgeWV0LgogICAgICAgIC8vIFNlZSB0aGUgbmV4dCBzZWN0aW9uIGZvciBkZXRhaWxzLgogICAgICAgIG93bmVyID0gbXNnLnNlbmRlcjsKCiAgICAgICAgLy8gV2UgcGVyZm9ybSBhbiBleHBsaWNpdCB0eXBlIGNvbnZlcnNpb24gZnJvbSBgYWRkcmVzc2AKICAgICAgICAvLyB0byBgVG9rZW5DcmVhdG9yYCBhbmQgYXNzdW1lIHRoYXQgdGhlIHR5cGUgb2YKICAgICAgICAvLyB0aGUgY2FsbGluZyBjb250cmFjdCBpcyBgVG9rZW5DcmVhdG9yYCwgdGhlcmUgaXMKICAgICAgICAvLyBubyByZWFsIHdheSB0byB2ZXJpZnkgdGhhdC4KICAgICAgICAvLyBUaGlzIGRvZXMgbm90IGNyZWF0ZSBhIG5ldyBjb250cmFjdC4KICAgICAgICBjcmVhdG9yID0gVG9rZW5DcmVhdG9yKG1zZy5zZW5kZXIpOwogICAgICAgIG5hbWUgPSBuYW1lXzsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGFuZ2VOYW1lKGJ5dGVzMzIgbmV3TmFtZSkgcHVibGljIHsKICAgICAgICAvLyBPbmx5IHRoZSBjcmVhdG9yIGNhbiBhbHRlciB0aGUgbmFtZS4KICAgICAgICAvLyBXZSBjb21wYXJlIHRoZSBjb250cmFjdCBiYXNlZCBvbiBpdHMKICAgICAgICAvLyBhZGRyZXNzIHdoaWNoIGNhbiBiZSByZXRyaWV2ZWQgYnkKICAgICAgICAvLyBleHBsaWNpdCBjb252ZXJzaW9uIHRvIGFkZHJlc3MuCiAgICAgICAgaWYgKG1zZy5zZW5kZXIgPT0gYWRkcmVzcyhjcmVhdG9yKSkKICAgICAgICAgICAgbmFtZSA9IG5ld05hbWU7CiAgICB9CgogICAgZnVuY3Rpb24gdHJhbnNmZXIoYWRkcmVzcyBuZXdPd25lcikgcHVibGljIHsKICAgICAgICAvLyBPbmx5IHRoZSBjdXJyZW50IG93bmVyIGNhbiB0cmFuc2ZlciB0aGUgdG9rZW4uCiAgICAgICAgaWYgKG1zZy5zZW5kZXIgIT0gb3duZXIpIHJldHVybjsKCiAgICAgICAgLy8gV2UgYXNrIHRoZSBjcmVhdG9yIGNvbnRyYWN0IGlmIHRoZSB0cmFuc2ZlcgogICAgICAgIC8vIHNob3VsZCBwcm9jZWVkIGJ5IHVzaW5nIGEgZnVuY3Rpb24gb2YgdGhlCiAgICAgICAgLy8gYFRva2VuQ3JlYXRvcmAgY29udHJhY3QgZGVmaW5lZCBiZWxvdy4gSWYKICAgICAgICAvLyB0aGUgY2FsbCBmYWlscyAoZS5nLiBkdWUgdG8gb3V0LW9mLWdhcyksCiAgICAgICAgLy8gdGhlIGV4ZWN1dGlvbiBhbHNvIGZhaWxzIGhlcmUuCiAgICAgICAgaWYgKGNyZWF0b3IuaXNUb2tlblRyYW5zZmVyT0sob3duZXIsIG5ld093bmVyKSkKICAgICAgICAgICAgb3duZXIgPSBuZXdPd25lcjsKICAgIH0KfQoKCmNvbnRyYWN0IFRva2VuQ3JlYXRvciB7CiAgICBmdW5jdGlvbiBjcmVhdGVUb2tlbihieXRlczMyIG5hbWUpCiAgICAgICAgcHVibGljCiAgICAgICAgcmV0dXJucyAoT3duZWRUb2tlbiB0b2tlbkFkZHJlc3MpCiAgICB7CiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGBUb2tlbmAgY29udHJhY3QgYW5kIHJldHVybiBpdHMgYWRkcmVzcy4KICAgICAgICAvLyBGcm9tIHRoZSBKYXZhU2NyaXB0IHNpZGUsIHRoZSByZXR1cm4gdHlwZQogICAgICAgIC8vIG9mIHRoaXMgZnVuY3Rpb24gaXMgYGFkZHJlc3NgLCBhcyB0aGlzIGlzCiAgICAgICAgLy8gdGhlIGNsb3Nlc3QgdHlwZSBhdmFpbGFibGUgaW4gdGhlIEFCSS4KICAgICAgICByZXR1cm4gbmV3IE93bmVkVG9rZW4obmFtZSk7CiAgICB9CgogICAgZnVuY3Rpb24gY2hhbmdlTmFtZShPd25lZFRva2VuIHRva2VuQWRkcmVzcywgYnl0ZXMzMiBuYW1lKSBwdWJsaWMgewogICAgICAgIC8vIEFnYWluLCB0aGUgZXh0ZXJuYWwgdHlwZSBvZiBgdG9rZW5BZGRyZXNzYCBpcwogICAgICAgIC8vIHNpbXBseSBgYWRkcmVzc2AuCiAgICAgICAgdG9rZW5BZGRyZXNzLmNoYW5nZU5hbWUobmFtZSk7CiAgICB9CgogICAgLy8gUGVyZm9ybSBjaGVja3MgdG8gZGV0ZXJtaW5lIGlmIHRyYW5zZmVycmluZyBhIHRva2VuIHRvIHRoZQogICAgLy8gYE93bmVkVG9rZW5gIGNvbnRyYWN0IHNob3VsZCBwcm9jZWVkCiAgICBmdW5jdGlvbiBpc1Rva2VuVHJhbnNmZXJPSyhhZGRyZXNzIGN1cnJlbnRPd25lciwgYWRkcmVzcyBuZXdPd25lcikKICAgICAgICBwdWJsaWMKICAgICAgICBwdXJlCiAgICAgICAgcmV0dXJucyAoYm9vbCBvaykKICAgIHsKICAgICAgICAvLyBDaGVjayBhbiBhcmJpdHJhcnkgY29uZGl0aW9uIHRvIHNlZSBpZiB0cmFuc2ZlciBzaG91bGQgcHJvY2VlZAogICAgICAgIHJldHVybiBrZWNjYWsyNTYoYWJpLmVuY29kZVBhY2tlZChjdXJyZW50T3duZXIsIG5ld093bmVyKSlbMF0gPT0gMHg3ZjsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.22 <0.9.0;
contract OwnedToken {
 // \`TokenCreator\` is a contract type that is defined below.
 // It is fine to reference it as long as it is not used
 // to create a new contract.
 TokenCreator creator;
 address owner;
 bytes32 name;
 // This is the constructor which registers the
 // creator and the assigned name.
 constructor(bytes32 name\_) {
 // State variables are accessed via their name
 // and not via e.g. \`this.owner\`. Functions can
 // be accessed directly or through \`this.f\`,
 // but the latter provides an external view
 // to the function. Especially in the constructor,
 // you should not access functions externally,
 // because the function does not exist yet.
 // See the next section for details.
 owner \= msg.sender;
 // We perform an explicit type conversion from \`address\`
 // to \`TokenCreator\` and assume that the type of
 // the calling contract is \`TokenCreator\`, there is
 // no real way to verify that.
 // This does not create a new contract.
 creator \= TokenCreator(msg.sender);
 name \= name\_;
 }
 function changeName(bytes32 newName) public {
 // Only the creator can alter the name.
 // We compare the contract based on its
 // address which can be retrieved by
 // explicit conversion to address.
 if (msg.sender \== address(creator))
 name \= newName;
 }
 function transfer(address newOwner) public {
 // Only the current owner can transfer the token.
 if (msg.sender != owner) return;
 // We ask the creator contract if the transfer
 // should proceed by using a function of the
 // \`TokenCreator\` contract defined below. If
 // the call fails (e.g. due to out-of-gas),
 // the execution also fails here.
 if (creator.isTokenTransferOK(owner, newOwner))
 owner \= newOwner;
 }
}
contract TokenCreator {
 function createToken(bytes32 name)
 public
 returns (OwnedToken tokenAddress)
 {
 // Create a new \`Token\` contract and return its address.
 // From the JavaScript side, the return type
 // of this function is \`address\`, as this is
 // the closest type available in the ABI.
 return new OwnedToken(name);
 }
 function changeName(OwnedToken tokenAddress, bytes32 name) public {
 // Again, the external type of \`tokenAddress\` is
 // simply \`address\`.
 tokenAddress.changeName(name);
 }
 // Perform checks to determine if transferring a token to the
 // \`OwnedToken\` contract should proceed
 function isTokenTransferOK(address currentOwner, address newOwner)
 public
 pure
 returns (bool ok)
 {
 // Check an arbitrary condition to see if transfer should proceed
 return keccak256(abi.encodePacked(currentOwner, newOwner))\[0\] \== 0x7f;
 }
}
## Visibility and Getters[](#visibility-and-getters "Link to this heading")
### State Variable Visibility[](#state-variable-visibility "Link to this heading")
`public`
Public state variables differ from internal ones only in that the compiler automatically generates [getter functions](#getter-functions) for them, which allows other contracts to read their values. When used within the same contract, the external access (e.g. `this.x`) invokes the getter while internal access (e.g. `x`) gets the variable value directly from storage. Setter functions are not generated so other contracts cannot directly modify their values.
`internal`
Internal state variables can only be accessed from within the contract they are defined in and in derived contracts. They cannot be accessed externally. This is the default visibility level for state variables.
`private`
Private state variables are like internal ones but they are not visible in derived contracts.
Warning
Making something `private` or `internal` only prevents other contracts from reading or modifying the information, but it will still be visible to the whole world outside of the blockchain.
### Function Visibility[](#function-visibility "Link to this heading")
Solidity knows two kinds of function calls: external ones that do create an actual EVM message call and internal ones that do not. Furthermore, internal functions can be made inaccessible to derived contracts. This gives rise to four types of visibility for functions.
`external`
External functions are part of the contract interface, which means they can be called from other contracts and via transactions. An external function `f` cannot be called internally (i.e. `f()` does not work, but `this.f()` works).
`public`
Public functions are part of the contract interface and can be either called internally or via message calls.
`internal`
Internal functions can only be accessed from within the current contract or contracts deriving from it. They cannot be accessed externally. Since they are not exposed to the outside through the contract’s ABI, they can take parameters of internal types like mappings or storage references.
`private`
Private functions are like internal ones but they are not visible in derived contracts.
Warning
Making something `private` or `internal` only prevents other contracts from reading or modifying the information, but it will still be visible to the whole world outside of the blockchain.
The visibility specifier is given after the type for state variables and between parameter list and return parameter list for functions.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50IGEpIHByaXZhdGUgcHVyZSByZXR1cm5zICh1aW50IGIpIHsgcmV0dXJuIGEgKyAxOyB9CiAgICBmdW5jdGlvbiBzZXREYXRhKHVpbnQgYSkgaW50ZXJuYWwgeyBkYXRhID0gYTsgfQogICAgdWludCBwdWJsaWMgZGF0YTsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 function f(uint a) private pure returns (uint b) { return a + 1; }
 function setData(uint a) internal { data \= a; }
 uint public data;
}
In the following example, `D`, can call `c.getData()` to retrieve the value of `data` in state storage, but is not able to call `f`. Contract `E` is derived from `C` and, thus, can call `compute`.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludCBwcml2YXRlIGRhdGE7CgogICAgZnVuY3Rpb24gZih1aW50IGEpIHByaXZhdGUgcHVyZSByZXR1cm5zKHVpbnQgYikgeyByZXR1cm4gYSArIDE7IH0KICAgIGZ1bmN0aW9uIHNldERhdGEodWludCBhKSBwdWJsaWMgeyBkYXRhID0gYTsgfQogICAgZnVuY3Rpb24gZ2V0RGF0YSgpIHB1YmxpYyB2aWV3IHJldHVybnModWludCkgeyByZXR1cm4gZGF0YTsgfQogICAgZnVuY3Rpb24gY29tcHV0ZSh1aW50IGEsIHVpbnQgYikgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7IHJldHVybiBhICsgYjsgfQp9CgovLyBUaGlzIHdpbGwgbm90IGNvbXBpbGUKY29udHJhY3QgRCB7CiAgICBmdW5jdGlvbiByZWFkRGF0YSgpIHB1YmxpYyB7CiAgICAgICAgQyBjID0gbmV3IEMoKTsKICAgICAgICB1aW50IGxvY2FsID0gYy5mKDcpOyAvLyBlcnJvcjogbWVtYmVyIGBmYCBpcyBub3QgdmlzaWJsZQogICAgICAgIGMuc2V0RGF0YSgzKTsKICAgICAgICBsb2NhbCA9IGMuZ2V0RGF0YSgpOwogICAgICAgIGxvY2FsID0gYy5jb21wdXRlKDMsIDUpOyAvLyBlcnJvcjogbWVtYmVyIGBjb21wdXRlYCBpcyBub3QgdmlzaWJsZQogICAgfQp9Cgpjb250cmFjdCBFIGlzIEMgewogICAgZnVuY3Rpb24gZygpIHB1YmxpYyB7CiAgICAgICAgQyBjID0gbmV3IEMoKTsKICAgICAgICB1aW50IHZhbCA9IGNvbXB1dGUoMywgNSk7IC8vIGFjY2VzcyB0byBpbnRlcm5hbCBtZW1iZXIgKGZyb20gZGVyaXZlZCB0byBwYXJlbnQgY29udHJhY3QpCiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 uint private data;
 function f(uint a) private pure returns(uint b) { return a + 1; }
 function setData(uint a) public { data \= a; }
 function getData() public view returns(uint) { return data; }
 function compute(uint a, uint b) internal pure returns (uint) { return a + b; }
}
// This will not compile
contract D {
 function readData() public {
 C c \= new C();
 uint local \= c.f(7); // error: member \`f\` is not visible
 c.setData(3);
 local \= c.getData();
 local \= c.compute(3, 5); // error: member \`compute\` is not visible
 }
}
contract E is C {
 function g() public {
 C c \= new C();
 uint val \= compute(3, 5); // access to internal member (from derived to parent contract)
 }
}
### Getter Functions[](#getter-functions "Link to this heading")
The compiler automatically creates getter functions for all **public** state variables. For the contract given below, the compiler will generate a function called `data` that does not take any arguments and returns a `uint`, the value of the state variable `data`. State variables can be initialized when they are declared.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludCBwdWJsaWMgZGF0YSA9IDQyOwp9Cgpjb250cmFjdCBDYWxsZXIgewogICAgQyBjID0gbmV3IEMoKTsKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGMuZGF0YSgpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 uint public data \= 42;
}
contract Caller {
 C c \= new C();
 function f() public view returns (uint) {
 return c.data();
 }
}
The getter functions have external visibility. If the symbol is accessed internally (i.e. without `this.`), it evaluates to a state variable. If it is accessed externally (i.e. with `this.`), it evaluates to a function.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50IHB1YmxpYyBkYXRhOwogICAgZnVuY3Rpb24geCgpIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgZGF0YSA9IDM7IC8vIGludGVybmFsIGFjY2VzcwogICAgICAgIHJldHVybiB0aGlzLmRhdGEoKTsgLy8gZXh0ZXJuYWwgYWNjZXNzCiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract C {
 uint public data;
 function x() public returns (uint) {
 data \= 3; // internal access
 return this.data(); // external access
 }
}
If you have a `public` state variable of array type, then you can only retrieve single elements of the array via the generated getter function. This mechanism exists to avoid high gas costs when returning an entire array. You can use arguments to specify which individual element to return, for example `myArray(0)`. If you want to return an entire array in one call, then you need to write a function, for example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IGFycmF5RXhhbXBsZSB7CiAgICAvLyBwdWJsaWMgc3RhdGUgdmFyaWFibGUKICAgIHVpbnRbXSBwdWJsaWMgbXlBcnJheTsKCiAgICAvLyBHZXR0ZXIgZnVuY3Rpb24gZ2VuZXJhdGVkIGJ5IHRoZSBjb21waWxlcgogICAgLyoKICAgIGZ1bmN0aW9uIG15QXJyYXkodWludCBpKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIG15QXJyYXlbaV07CiAgICB9CiAgICAqLwoKICAgIC8vIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBlbnRpcmUgYXJyYXkKICAgIGZ1bmN0aW9uIGdldEFycmF5KCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludFtdIG1lbW9yeSkgewogICAgICAgIHJldHVybiBteUFycmF5OwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract arrayExample {
 // public state variable
 uint\[\] public myArray;
 // Getter function generated by the compiler
 /\*
 function myArray(uint i) public view returns (uint) {
 return myArray\[i\];
 }
 \*/
 // function that returns entire array
 function getArray() public view returns (uint\[\] memory) {
 return myArray;
 }
}
Now you can use `getArray()` to retrieve the entire array, instead of `myArray(i)`, which returns a single element per call.
The next example is more complex:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQ29tcGxleCB7CiAgICBzdHJ1Y3QgRGF0YSB7CiAgICAgICAgdWludCBhOwogICAgICAgIGJ5dGVzMyBiOwogICAgICAgIG1hcHBpbmcodWludCA9PiB1aW50KSBtYXA7CiAgICAgICAgdWludFszXSBjOwogICAgICAgIHVpbnRbXSBkOwogICAgICAgIGJ5dGVzIGU7CiAgICB9CiAgICBtYXBwaW5nKHVpbnQgPT4gbWFwcGluZyhib29sID0+IERhdGFbXSkpIHB1YmxpYyBkYXRhOwp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract Complex {
 struct Data {
 uint a;
 bytes3 b;
 mapping(uint \=> uint) map;
 uint\[3\] c;
 uint\[\] d;
 bytes e;
 }
 mapping(uint \=> mapping(bool \=> Data\[\])) public data;
}
It generates a function of the following form. The mapping and arrays (with the exception of byte arrays) in the struct are omitted because there is no good way to select individual struct members or provide a key for the mapping:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=ZnVuY3Rpb24gZGF0YSh1aW50IGFyZzEsIGJvb2wgYXJnMiwgdWludCBhcmczKQogICAgcHVibGljCiAgICByZXR1cm5zICh1aW50IGEsIGJ5dGVzMyBiLCBieXRlcyBtZW1vcnkgZSkKewogICAgYSA9IGRhdGFbYXJnMV1bYXJnMl1bYXJnM10uYTsKICAgIGIgPSBkYXRhW2FyZzFdW2FyZzJdW2FyZzNdLmI7CiAgICBlID0gZGF0YVthcmcxXVthcmcyXVthcmczXS5lOwp9)
function data(uint arg1, bool arg2, uint arg3)
 public
 returns (uint a, bytes3 b, bytes memory e)
{
 a \= data\[arg1\]\[arg2\]\[arg3\].a;
 b \= data\[arg1\]\[arg2\]\[arg3\].b;
 e \= data\[arg1\]\[arg2\]\[arg3\].e;
}
## Function Modifiers[](#function-modifiers "Link to this heading")
Modifiers can be used to change the behavior of functions in a declarative way. For example, you can use a modifier to automatically check a condition prior to executing the function.
Modifiers are inheritable properties of contracts and may be overridden by derived contracts, but only if they are marked `virtual`. For details, please see [Modifier Overriding](#modifier-overriding).
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwoKICAgIC8vIFRoaXMgY29udHJhY3Qgb25seSBkZWZpbmVzIGEgbW9kaWZpZXIgYnV0IGRvZXMgbm90IHVzZQogICAgLy8gaXQ6IGl0IHdpbGwgYmUgdXNlZCBpbiBkZXJpdmVkIGNvbnRyYWN0cy4KICAgIC8vIFRoZSBmdW5jdGlvbiBib2R5IGlzIGluc2VydGVkIHdoZXJlIHRoZSBzcGVjaWFsIHN5bWJvbAogICAgLy8gYF87YCBpbiB0aGUgZGVmaW5pdGlvbiBvZiBhIG1vZGlmaWVyIGFwcGVhcnMuCiAgICAvLyBUaGlzIG1lYW5zIHRoYXQgaWYgdGhlIG93bmVyIGNhbGxzIHRoaXMgZnVuY3Rpb24sIHRoZQogICAgLy8gZnVuY3Rpb24gaXMgZXhlY3V0ZWQgYW5kIG90aGVyd2lzZSwgYW4gZXhjZXB0aW9uIGlzCiAgICAvLyB0aHJvd24uCiAgICBtb2RpZmllciBvbmx5T3duZXIgewogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgIG1zZy5zZW5kZXIgPT0gb3duZXIsCiAgICAgICAgICAgICJPbmx5IG93bmVyIGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24uIgogICAgICAgICk7CiAgICAgICAgXzsKICAgIH0KfQoKY29udHJhY3QgcHJpY2VkIHsKICAgIC8vIE1vZGlmaWVycyBjYW4gcmVjZWl2ZSBhcmd1bWVudHM6CiAgICBtb2RpZmllciBjb3N0cyh1aW50IHByaWNlKSB7CiAgICAgICAgaWYgKG1zZy52YWx1ZSA+PSBwcmljZSkgewogICAgICAgICAgICBfOwogICAgICAgIH0KICAgIH0KfQoKY29udHJhY3QgUmVnaXN0ZXIgaXMgcHJpY2VkLCBvd25lZCB7CiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gYm9vbCkgcmVnaXN0ZXJlZEFkZHJlc3NlczsKICAgIHVpbnQgcHJpY2U7CgogICAgY29uc3RydWN0b3IodWludCBpbml0aWFsUHJpY2UpIHsgcHJpY2UgPSBpbml0aWFsUHJpY2U7IH0KCiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gYWxzbyBwcm92aWRlIHRoZQogICAgLy8gYHBheWFibGVgIGtleXdvcmQgaGVyZSwgb3RoZXJ3aXNlIHRoZSBmdW5jdGlvbiB3aWxsCiAgICAvLyBhdXRvbWF0aWNhbGx5IHJlamVjdCBhbGwgRXRoZXIgc2VudCB0byBpdC4KICAgIGZ1bmN0aW9uIHJlZ2lzdGVyKCkgcHVibGljIHBheWFibGUgY29zdHMocHJpY2UpIHsKICAgICAgICByZWdpc3RlcmVkQWRkcmVzc2VzW21zZy5zZW5kZXJdID0gdHJ1ZTsKICAgIH0KCiAgICAvLyBUaGlzIGNvbnRyYWN0IGluaGVyaXRzIHRoZSBgb25seU93bmVyYCBtb2RpZmllciBmcm9tCiAgICAvLyB0aGUgYG93bmVkYCBjb250cmFjdC4gQXMgYSByZXN1bHQsIGNhbGxzIHRvIGBjaGFuZ2VQcmljZWAgd2lsbAogICAgLy8gb25seSB0YWtlIGVmZmVjdCBpZiB0aGV5IGFyZSBtYWRlIGJ5IHRoZSBzdG9yZWQgb3duZXIuCiAgICBmdW5jdGlvbiBjaGFuZ2VQcmljZSh1aW50IHByaWNlXykgcHVibGljIG9ubHlPd25lciB7CiAgICAgICAgcHJpY2UgPSBwcmljZV87CiAgICB9Cn0KCmNvbnRyYWN0IE11dGV4IHsKICAgIGJvb2wgbG9ja2VkOwogICAgbW9kaWZpZXIgbm9SZWVudHJhbmN5KCkgewogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgICFsb2NrZWQsCiAgICAgICAgICAgICJSZWVudHJhbnQgY2FsbC4iCiAgICAgICAgKTsKICAgICAgICBsb2NrZWQgPSB0cnVlOwogICAgICAgIF87CiAgICAgICAgbG9ja2VkID0gZmFsc2U7CiAgICB9CgogICAgLy8vIFRoaXMgZnVuY3Rpb24gaXMgcHJvdGVjdGVkIGJ5IGEgbXV0ZXgsIHdoaWNoIG1lYW5zIHRoYXQKICAgIC8vLyByZWVudHJhbnQgY2FsbHMgZnJvbSB3aXRoaW4gYG1zZy5zZW5kZXIuY2FsbGAgY2Fubm90IGNhbGwgYGZgIGFnYWluLgogICAgLy8vIFRoZSBgcmV0dXJuIDdgIHN0YXRlbWVudCBhc3NpZ25zIDcgdG8gdGhlIHJldHVybiB2YWx1ZSBidXQgc3RpbGwKICAgIC8vLyBleGVjdXRlcyB0aGUgc3RhdGVtZW50IGBsb2NrZWQgPSBmYWxzZWAgaW4gdGhlIG1vZGlmaWVyLgogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBub1JlZW50cmFuY3kgcmV0dXJucyAodWludCkgewogICAgICAgIChib29sIHN1Y2Nlc3MsKSA9IG1zZy5zZW5kZXIuY2FsbCgiIik7CiAgICAgICAgcmVxdWlyZShzdWNjZXNzKTsKICAgICAgICByZXR1cm4gNzsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.1 <0.9.0;
contract owned {
 constructor() { owner \= payable(msg.sender); }
 address payable owner;
 // This contract only defines a modifier but does not use
 // it: it will be used in derived contracts.
 // The function body is inserted where the special symbol
 // \`\_;\` in the definition of a modifier appears.
 // This means that if the owner calls this function, the
 // function is executed and otherwise, an exception is
 // thrown.
 modifier onlyOwner {
 require(
 msg.sender \== owner,
 "Only owner can call this function."
 );
 \_;
 }
}
contract priced {
 // Modifiers can receive arguments:
 modifier costs(uint price) {
 if (msg.value \>= price) {
 \_;
 }
 }
}
contract Register is priced, owned {
 mapping(address \=> bool) registeredAddresses;
 uint price;
 constructor(uint initialPrice) { price \= initialPrice; }
 // It is important to also provide the
 // \`payable\` keyword here, otherwise the function will
 // automatically reject all Ether sent to it.
 function register() public payable costs(price) {
 registeredAddresses\[msg.sender\] \= true;
 }
 // This contract inherits the \`onlyOwner\` modifier from
 // the \`owned\` contract. As a result, calls to \`changePrice\` will
 // only take effect if they are made by the stored owner.
 function changePrice(uint price\_) public onlyOwner {
 price \= price\_;
 }
}
contract Mutex {
 bool locked;
 modifier noReentrancy() {
 require(
 !locked,
 "Reentrant call."
 );
 locked \= true;
 \_;
 locked \= false;
 }
 /// This function is protected by a mutex, which means that
 /// reentrant calls from within \`msg.sender.call\` cannot call \`f\` again.
 /// The \`return 7\` statement assigns 7 to the return value but still
 /// executes the statement \`locked = false\` in the modifier.
 function f() public noReentrancy returns (uint) {
 (bool success,) \= msg.sender.call("");
 require(success);
 return 7;
 }
}
If you want to access a modifier `m` defined in a contract `C`, you can use `C.m` to reference it without virtual lookup. It is only possible to use modifiers defined in the current contract or its base contracts. Modifiers can also be defined in libraries but their use is limited to functions of the same library.
Multiple modifiers are applied to a function by specifying them in a whitespace-separated list and are evaluated in the order presented.
Modifiers cannot implicitly access or change the arguments and return values of functions they modify. Their values can only be passed to them explicitly at the point of invocation.
In function modifiers, it is necessary to specify when you want the function to which the modifier is applied to be run. The placeholder statement (denoted by a single underscore character `_`) is used to denote where the body of the function being modified should be inserted. Note that the placeholder operator is different from using underscores as leading or trailing characters in variable names, which is a stylistic choice.
Explicit returns from a modifier or function body only leave the current modifier or function body. Return variables are assigned and control flow continues after the `_` in the preceding modifier.
Warning
In an earlier version of Solidity, `return` statements in functions having modifiers behaved differently.
An explicit return from a modifier with `return;` does not affect the values returned by the function. The modifier can, however, choose not to execute the function body at all and in that case the return variables are set to their [default values](https://docs.soliditylang.org/en/latest/control-structures.html#default-value) just as if the function had an empty body.
The `_` symbol can appear in the modifier multiple times. Each occurrence is replaced with the function body, and the function returns the return value of the final occurrence.
Arbitrary expressions are allowed for modifier arguments and in this context, all symbols visible from the function are visible in the modifier. Symbols introduced in the modifier are not visible in the function (as they might change by overriding).
## Transient Storage[](#transient-storage "Link to this heading")
Transient storage is another data location besides memory, storage, calldata (and return-data and code) which was introduced alongside its respective opcodes `TSTORE` and `TLOAD` by [EIP-1153](https://eips.ethereum.org/EIPS/eip-1153). This new data location behaves as a key-value store similar to storage with the main difference being that data in transient storage is not permanent, but is scoped to the current transaction only, after which it will be reset to zero. Since the content of transient storage has very limited lifetime and size, it does not need to be stored permanently as a part of state and the associated gas costs are much lower than in case of storage. EVM version `cancun` or newer is required for transient storage to be available.
Transient storage variables cannot be initialized in place, i.e., they cannot be assigned to upon declaration, since the value would be cleared at the end of the creation transaction, rendering the initialization ineffective. Transient variables will be [default value](https://docs.soliditylang.org/en/latest/control-structures.html#default-value) initialized depending on their underlying type. `constant` and `immutable` variables conflict with transient storage, since their values are either inlined or directly stored in code.
Transient storage variables have completely independent address space from storage, so that the order of transient state variables does not affect the layout of storage state variables and vice-versa. They do need distinct names though because all state variables share the same namespace. It is also important to note that the values in transient storage are packed in the same fashion as those in persistent storage. See [Storage Layout](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#storage-inplace-encoding) for more information.
Besides that, transient variables can have visibility as well and `public` ones will have a getter function generated automatically as usual.
Note that, currently, such use of `transient` as a data location is only allowed for [value type](https://docs.soliditylang.org/en/latest/types.html#value-types) state variable declarations. Reference types, such as arrays, mappings and structs, as well as local or parameter variables are not yet supported.
An expected canonical use case for transient storage is cheaper reentrancy locks, which can be readily implemented with the opcodes as showcased next.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjg7Cgpjb250cmFjdCBHZW5lcm9zaXR5IHsKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiBib29sKSBzZW50R2lmdHM7CiAgICBib29sIHRyYW5zaWVudCBsb2NrZWQ7CgogICAgbW9kaWZpZXIgbm9uUmVlbnRyYW50IHsKICAgICAgICByZXF1aXJlKCFsb2NrZWQsICJSZWVudHJhbmN5IGF0dGVtcHQiKTsKICAgICAgICBsb2NrZWQgPSB0cnVlOwogICAgICAgIF87CiAgICAgICAgLy8gVW5sb2NrcyB0aGUgZ3VhcmQsIG1ha2luZyB0aGUgcGF0dGVybiBjb21wb3NhYmxlLgogICAgICAgIC8vIEFmdGVyIHRoZSBmdW5jdGlvbiBleGl0cywgaXQgY2FuIGJlIGNhbGxlZCBhZ2FpbiwgZXZlbiBpbiB0aGUgc2FtZSB0cmFuc2FjdGlvbi4KICAgICAgICBsb2NrZWQgPSBmYWxzZTsKICAgIH0KCiAgICBmdW5jdGlvbiBjbGFpbUdpZnQoKSBub25SZWVudHJhbnQgcHVibGljIHsKICAgICAgICByZXF1aXJlKGFkZHJlc3ModGhpcykuYmFsYW5jZSA+PSAxIGV0aGVyKTsKICAgICAgICByZXF1aXJlKCFzZW50R2lmdHNbbXNnLnNlbmRlcl0pOwogICAgICAgIChib29sIHN1Y2Nlc3MsICkgPSBtc2cuc2VuZGVyLmNhbGx7dmFsdWU6IDEgZXRoZXJ9KCIiKTsKICAgICAgICByZXF1aXJlKHN1Y2Nlc3MpOwoKICAgICAgICAvLyBJbiBhIHJlZW50cmFudCBmdW5jdGlvbiwgZG9pbmcgdGhpcyBsYXN0IHdvdWxkIG9wZW4gdXAgdGhlIHZ1bG5lcmFiaWxpdHkKICAgICAgICBzZW50R2lmdHNbbXNnLnNlbmRlcl0gPSB0cnVlOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.28;
contract Generosity {
 mapping(address \=> bool) sentGifts;
 bool transient locked;
 modifier nonReentrant {
 require(!locked, "Reentrancy attempt");
 locked \= true;
 \_;
 // Unlocks the guard, making the pattern composable.
 // After the function exits, it can be called again, even in the same transaction.
 locked \= false;
 }
 function claimGift() nonReentrant public {
 require(address(this).balance \>= 1 ether);
 require(!sentGifts\[msg.sender\]);
 (bool success, ) \= msg.sender.call{value: 1 ether}("");
 require(success);
 // In a reentrant function, doing this last would open up the vulnerability
 sentGifts\[msg.sender\] \= true;
 }
}
Transient storage is private to the contract that owns it, in the same way as persistent storage. Only owning contract frames may access their transient storage, and when they do, all the frames access the same transient store.
Transient storage is part of the EVM state and is subject to the same mutability enforcements as persistent storage. As such, any read access to it is not `pure` and writing access is not `view`.
If the `TSTORE` opcode is called within the context of a `STATICCALL`, it will result in an exception instead of performing the modification. `TLOAD` is allowed within the context of a `STATICCALL`.
When transient storage is used in the context of `DELEGATECALL` or `CALLCODE`, then the owning contract of the transient storage is the contract that issued `DELEGATECALL` or `CALLCODE` instruction (the caller) as with persistent storage. When transient storage is used in the context of `CALL` or `STATICCALL`, then the owning contract of the transient storage is the contract that is the target of the `CALL` or `STATICCALL` instruction (the callee).
Note
In the case of `DELEGATECALL`, since references to transient storage variables are currently not supported, it is not possible to pass those into library calls. In libraries, access to transient storage is only possible using inline assembly.
If a frame reverts, all writes to transient storage that took place between entry to the frame and the return are reverted, including those that took place in inner calls. The caller of an external call may employ a `try ... catch` block to prevent reverts bubbling up from the inner calls.
## Composability of Smart Contracts and the Caveats of Transient Storage[](#composability-of-smart-contracts-and-the-caveats-of-transient-storage "Link to this heading")
Given the caveats mentioned in the specification of EIP-1153, in order to preserve the composability of your smart contract, utmost care is recommended for more advanced use cases of transient storage.
For smart contracts, composability is a very important design principle to achieve self-contained behaviour, such that multiple calls into individual smart contracts can be composed to more complex applications. So far the EVM largely guaranteed composable behaviour, since multiple calls into a smart contract within a complex transaction are virtually indistinguishable from multiple calls to the contract stretched over several transactions. However, transient storage allows a violation of this principle, and incorrect use may lead to complex bugs that only surface when used across several calls.
Let’s illustrate the problem with a simple example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjg7Cgpjb250cmFjdCBNdWxTZXJ2aWNlIHsKICAgIHVpbnQgdHJhbnNpZW50IG11bHRpcGxpZXI7CiAgICBmdW5jdGlvbiBzZXRNdWx0aXBsaWVyKHVpbnQgbXVsKSBleHRlcm5hbCB7CiAgICAgICAgbXVsdGlwbGllciA9IG11bDsKICAgIH0KCiAgICBmdW5jdGlvbiBtdWx0aXBseSh1aW50IHZhbHVlKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4gdmFsdWUgKiBtdWx0aXBsaWVyOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.28;
contract MulService {
 uint transient multiplier;
 function setMultiplier(uint mul) external {
 multiplier \= mul;
 }
 function multiply(uint value) external view returns (uint) {
 return value \* multiplier;
 }
}
and a sequence of external calls:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=c2V0TXVsdGlwbGllcig0Mik7Cm11bHRpcGx5KDEpOwptdWx0aXBseSgyKTs=)
setMultiplier(42);
multiply(1);
multiply(2);
If the example used memory or storage to store the multiplier, it would be fully composable. It would not matter whether you split the sequence into separate transactions or grouped them in some way. You would always get the same result: after `multiplier` is set to `42`, the subsequent calls would return `42` and `84` respectively. This enables use cases such as batching calls from multiple transactions together to reduce gas costs. Transient storage potentially breaks such use cases since composability can no longer be taken for granted. In the example, if the calls are not executed in the same transaction, then `multiplier` is reset and the next calls to function `multiply` would always return `0`.
As another example, since transient storage is constructed as a relatively cheap key-value store, a smart contract author may be tempted to use transient storage as a replacement for in-memory mappings without keeping track of the modified keys in the mapping and thereby without clearing the mapping at the end of the call. This, however, can easily lead to unexpected behaviour in complex transactions, in which values set by a previous call into the contract within the same transaction remain.
The use of transient storage for reentrancy locks that are cleared at the end of the call frame into the contract, is safe. However, be sure to resist the temptation to save the 100 gas used for resetting the reentrancy lock, since failing to do so, will restrict your contract to only one call within a transaction, preventing its use in complex composed transactions, which have been a cornerstone for complex applications on chain.
It is recommend to generally always clear transient storage completely at the end of a call into your smart contract to avoid these kinds of issues and to simplify the analysis of the behaviour of your contract within complex transactions. Check the [Security Considerations section of EIP-1153](https://eips.ethereum.org/EIPS/eip-1153#security-considerations) for further details.
## Constant and Immutable State Variables[](#constant-and-immutable-state-variables "Link to this heading")
State variables can be declared as `constant` or `immutable`. In both cases, the variables cannot be modified after the contract has been constructed. For `constant` variables, the value has to be fixed at compile-time, while for `immutable`, it can still be assigned at construction time.
It is also possible to define `constant` variables at the file level.
Every occurrence of such a variable in the source is replaced by its underlying value and the compiler does not reserve a storage slot for it. It cannot be assigned a slot in transient storage using the `transient` keyword either.
Compared to regular state variables, the gas costs of constant and immutable variables are much lower. For a constant variable, the expression assigned to it is copied to all the places where it is accessed and also re-evaluated each time. This allows for local optimizations. Immutable variables are evaluated once at construction time and their value is copied to all the places in the code where they are accessed. For these values, 32 bytes are reserved, even if they would fit in fewer bytes. Due to this, constant values can sometimes be cheaper than immutable values.
Not all types for constants and immutables are implemented at this time. The only supported types are [strings](https://docs.soliditylang.org/en/latest/types.html#strings) (only for constants) and [value types](https://docs.soliditylang.org/en/latest/types.html#value-types).
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjE7Cgp1aW50IGNvbnN0YW50IFggPSAzMioqMjIgKyA4OwoKY29udHJhY3QgQyB7CiAgICBzdHJpbmcgY29uc3RhbnQgVEVYVCA9ICJhYmMiOwogICAgYnl0ZXMzMiBjb25zdGFudCBNWV9IQVNIID0ga2VjY2FrMjU2KCJhYmMiKTsKICAgIHVpbnQgaW1tdXRhYmxlIGRlY2ltYWxzID0gMTg7CiAgICB1aW50IGltbXV0YWJsZSBtYXhCYWxhbmNlOwogICAgYWRkcmVzcyBpbW11dGFibGUgb3duZXIgPSBtc2cuc2VuZGVyOwoKICAgIGNvbnN0cnVjdG9yKHVpbnQgZGVjaW1hbHNfLCBhZGRyZXNzIHJlZikgewogICAgICAgIGlmIChkZWNpbWFsc18gIT0gMCkKICAgICAgICAgICAgLy8gSW1tdXRhYmxlcyBhcmUgb25seSBpbW11dGFibGUgd2hlbiBkZXBsb3llZC4KICAgICAgICAgICAgLy8gQXQgY29uc3RydWN0aW9uIHRpbWUgdGhleSBjYW4gYmUgYXNzaWduZWQgdG8gYW55IG51bWJlciBvZiB0aW1lcy4KICAgICAgICAgICAgZGVjaW1hbHMgPSBkZWNpbWFsc187CgogICAgICAgIC8vIEFzc2lnbm1lbnRzIHRvIGltbXV0YWJsZXMgY2FuIGV2ZW4gYWNjZXNzIHRoZSBlbnZpcm9ubWVudC4KICAgICAgICBtYXhCYWxhbmNlID0gcmVmLmJhbGFuY2U7CiAgICB9CgogICAgZnVuY3Rpb24gaXNCYWxhbmNlVG9vSGlnaChhZGRyZXNzIG90aGVyKSBwdWJsaWMgdmlldyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmV0dXJuIG90aGVyLmJhbGFuY2UgPiBtYXhCYWxhbmNlOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.21;
uint constant X \= 32\*\*22 + 8;
contract C {
 string constant TEXT \= "abc";
 bytes32 constant MY\_HASH \= keccak256("abc");
 uint immutable decimals \= 18;
 uint immutable maxBalance;
 address immutable owner \= msg.sender;
 constructor(uint decimals\_, address ref) {
 if (decimals\_ != 0)
 // Immutables are only immutable when deployed.
 // At construction time they can be assigned to any number of times.
 decimals \= decimals\_;
 // Assignments to immutables can even access the environment.
 maxBalance \= ref.balance;
 }
 function isBalanceTooHigh(address other) public view returns (bool) {
 return other.balance \> maxBalance;
 }
}
### Constant[](#constant "Link to this heading")
For `constant` variables, the value has to be a constant at compile time and it has to be assigned where the variable is declared. Any expression that accesses storage, blockchain data (e.g. `block.timestamp`, `address(this).balance` or `block.number`) or execution data (`msg.value` or `gasleft()`) or makes calls to external contracts is disallowed. Expressions that might have a side-effect on memory allocation are allowed, but those that might have a side-effect on other memory objects are not. The built-in functions `keccak256`, `sha256`, `ripemd160`, `ecrecover`, `addmod` and `mulmod` are allowed (even though, with the exception of `keccak256`, they do call external contracts).
The reason behind allowing side-effects on the memory allocator is that it should be possible to construct complex objects like e.g. lookup-tables. This feature is not yet fully usable.
### Immutable[](#immutable "Link to this heading")
Variables declared as `immutable` are a bit less restricted than those declared as `constant`: Immutable variables can be assigned a value at construction time. The value can be changed at any time before deployment and then it becomes permanent.
One additional restriction is that immutables can only be assigned to inside expressions for which there is no possibility of being executed after creation. This excludes all modifier definitions and functions other than constructors.
There are no restrictions on reading immutable variables. The read is even allowed to happen before the variable is written to for the first time because variables in Solidity always have a well-defined initial value. For this reason it is also allowed to never explicitly assign a value to an immutable.
Warning
When accessing immutables at construction time, please keep the [initialization order](https://docs.soliditylang.org/en/latest/ir-breaking-changes.html#state-variable-initialization-order) in mind. Even if you provide an explicit initializer, some expressions may end up being evaluated before that initializer, especially when they are at a different level in inheritance hierarchy.
Note
Before Solidity 0.8.21 initialization of immutable variables was more restrictive. Such variables had to be initialized exactly once at construction time and could not be read before then.
The contract creation code generated by the compiler will modify the contract’s runtime code before it is returned by replacing all references to immutables with the values assigned to them. This is important if you are comparing the runtime code generated by the compiler with the one actually stored in the blockchain. The compiler outputs where these immutables are located in the deployed bytecode in the `immutableReferences` field of the [compiler JSON standard output](https://docs.soliditylang.org/en/latest/using-the-compiler.html#compiler-api).
## Custom Storage Layout[](#custom-storage-layout "Link to this heading")
A contract can define an arbitrary location for its storage using the `layout` specifier. The contract’s state variables, including those inherited from base contracts, start from the specified base slot instead of the default slot zero.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjk7Cgpjb250cmFjdCBDIGxheW91dCBhdCAweEFBQUEgKyAweDExIHsKICAgIHVpbnRbM10geDsgLy8gT2NjdXBpZXMgc2xvdHMgMHhBQUJCLi4weEFBQkQKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.29;
contract C layout at 0xAAAA + 0x11 {
 uint\[3\] x; // Occupies slots 0xAABB..0xAABD
}
As the above example shows, the specifier uses the `layout at <base-slot-expression>` syntax and is located in the header of a contract definition.
The layout specifier can be placed either before or after the inheritance specifier, and can appear at most once. The `base-slot-expression` must be an [integer literal](https://docs.soliditylang.org/en/latest/types.html#rational-literals) expression that can be evaluated at compilation time and yields a value in the range of `uint256`.
A custom layout cannot make contract’s storage “wrap around”. If the selected base slot would push the static variables past the end of storage, the compiler will issue an error. Note that the data areas of dynamic arrays and mappings are not affected by this check because their layout is not linear. Regardless of the base slot used, their locations are calculated in a way that always puts them within the range of `uint256` and their sizes are not known at compilation time.
While there are no other limits placed on the base slot, it is recommended to avoid locations that are too close to the end of the address space. Leaving too little space may complicate contract upgrades or cause problems for contracts that store additional values past their allocated space using inline assembly.
The storage layout can only be specified for the topmost contract of an inheritance tree, and affects locations of all the storage variables in all the contracts in that tree. Variables are laid out according to the order of their definitions and the positions of their contracts in the [linearized inheritance hierarchy](#multi-inheritance) and a custom base slot preserves their relative positions, shifting them all by the same amount.
The storage layout cannot be specified for abstract contracts, interfaces and libraries. Also, it is important to note that it does _not_ affect transient state variables.
For details about storage layout and the effect of the layout specifier on it see [layout of storage variables](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#storage-inplace-encoding).
Warning
The identifiers `layout` and `at` are not yet reserved as keywords in the language. It is strongly recommended to avoid using them since they will become reserved in a future breaking release.
## Functions[](#functions "Link to this heading")
Functions can be defined inside and outside of contracts.
Functions outside of a contract, also called “free functions”, always have implicit `internal` [visibility](#visibility-and-getters). Their code is included in all contracts that call them, similar to internal library functions.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKZnVuY3Rpb24gc3VtKHVpbnRbXSBtZW1vcnkgYXJyKSBwdXJlIHJldHVybnMgKHVpbnQgcykgewogICAgZm9yICh1aW50IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKQogICAgICAgIHMgKz0gYXJyW2ldOwp9Cgpjb250cmFjdCBBcnJheUV4YW1wbGUgewogICAgYm9vbCBmb3VuZDsKICAgIGZ1bmN0aW9uIGYodWludFtdIG1lbW9yeSBhcnIpIHB1YmxpYyB7CiAgICAgICAgLy8gVGhpcyBjYWxscyB0aGUgZnJlZSBmdW5jdGlvbiBpbnRlcm5hbGx5LgogICAgICAgIC8vIFRoZSBjb21waWxlciB3aWxsIGFkZCBpdHMgY29kZSB0byB0aGUgY29udHJhY3QuCiAgICAgICAgdWludCBzID0gc3VtKGFycik7CiAgICAgICAgcmVxdWlyZShzID49IDEwKTsKICAgICAgICBmb3VuZCA9IHRydWU7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.1 <0.9.0;
function sum(uint\[\] memory arr) pure returns (uint s) {
 for (uint i \= 0; i < arr.length; i++)
 s += arr\[i\];
}
contract ArrayExample {
 bool found;
 function f(uint\[\] memory arr) public {
 // This calls the free function internally.
 // The compiler will add its code to the contract.
 uint s \= sum(arr);
 require(s \>= 10);
 found \= true;
 }
}
Note
Functions defined outside a contract are still always executed in the context of a contract. They still can call other contracts, send them Ether and destroy the contract that called them, among other things. The main difference to functions defined inside a contract is that free functions do not have direct access to the variable `this`, storage variables and functions not in their scope.
### Function Parameters and Return Variables[](#function-parameters-and-return-variables "Link to this heading")
Functions take typed parameters as input and may, unlike in many other languages, also return an arbitrary number of values as output.
#### Function Parameters[](#function-parameters "Link to this heading")
Function parameters are declared the same way as variables, and the name of unused parameters can be omitted.
For example, if you want your contract to accept one kind of external call with two integers, you would use something like the following:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICB1aW50IHN1bTsKICAgIGZ1bmN0aW9uIHRha2VyKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgewogICAgICAgIHN1bSA9IGEgKyBiOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract Simple {
 uint sum;
 function taker(uint a, uint b) public {
 sum \= a + b;
 }
}
Function parameters can be used as any other local variable and they can also be assigned to.
#### Return Variables[](#return-variables "Link to this heading")
Function return variables are declared with the same syntax after the `returns` keyword.
For example, suppose you want to return two results: the sum and the product of two integers passed as function parameters, then you use something like:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICBmdW5jdGlvbiBhcml0aG1ldGljKHVpbnQgYSwgdWludCBiKQogICAgICAgIHB1YmxpYwogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50IHN1bSwgdWludCBwcm9kdWN0KQogICAgewogICAgICAgIHN1bSA9IGEgKyBiOwogICAgICAgIHByb2R1Y3QgPSBhICogYjsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract Simple {
 function arithmetic(uint a, uint b)
 public
 pure
 returns (uint sum, uint product)
 {
 sum \= a + b;
 product \= a \* b;
 }
}
The names of return variables can be omitted. Return variables can be used as any other local variable and they are initialized with their [default value](https://docs.soliditylang.org/en/latest/control-structures.html#default-value) and have that value until they are (re-)assigned.
You can either explicitly assign to return variables and then leave the function as above, or you can provide return values (either a single or [multiple ones](#multi-return)) directly with the `return` statement:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICBmdW5jdGlvbiBhcml0aG1ldGljKHVpbnQgYSwgdWludCBiKQogICAgICAgIHB1YmxpYwogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50IHN1bSwgdWludCBwcm9kdWN0KQogICAgewogICAgICAgIHJldHVybiAoYSArIGIsIGEgKiBiKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract Simple {
 function arithmetic(uint a, uint b)
 public
 pure
 returns (uint sum, uint product)
 {
 return (a + b, a \* b);
 }
}
If you use an early `return` to leave a function that has return variables, you must provide return values together with the return statement.
Note
You cannot return some types from non-internal functions. This includes the types listed below and any composite types that recursively contain them:
* mappings,
 
* internal function types,
 
* reference types with location set to `storage`,
 
* multi-dimensional arrays (applies only to [ABI coder v1](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#abi-coder)),
 
* structs (applies only to [ABI coder v1](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#abi-coder)).
 
This restriction does not apply to library functions because of their different [internal ABI](#library-selectors).
#### Returning Multiple Values[](#returning-multiple-values "Link to this heading")
When a function has multiple return types, the statement `return (v0, v1, ..., vn)` can be used to return multiple values. The number of components must be the same as the number of return variables and their types have to match, potentially after an [implicit conversion](https://docs.soliditylang.org/en/latest/types.html#types-conversion-elementary-types).
### State Mutability[](#state-mutability "Link to this heading")
#### View Functions[](#view-functions "Link to this heading")
Functions can be declared `view` in which case they promise not to modify the state.
Note
If the compiler’s EVM target is Byzantium or newer (default) the opcode `STATICCALL` is used when `view` functions are called, which enforces the state to stay unmodified as part of the EVM execution. For library `view` functions `DELEGATECALL` is used, because there is no combined `DELEGATECALL` and `STATICCALL`. This means library `view` functions do not have run-time checks that prevent state modifications. This should not impact security negatively because library code is usually known at compile-time and the static checker performs compile-time checks.
The following statements are considered modifying the state:
1. Writing to state variables (storage and transient storage).
 
2. [Emitting events](#events).
 
3. [Creating other contracts](https://docs.soliditylang.org/en/latest/control-structures.html#creating-contracts).
 
4. Using `selfdestruct`.
 
5. Sending Ether via calls.
 
6. Calling any function not marked `view` or `pure`.
 
7. Using low-level calls.
 
8. Using inline assembly that contains certain opcodes.
 
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgKiAoYiArIDQyKSArIGJsb2NrLnRpbWVzdGFtcDsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
contract C {
 function f(uint a, uint b) public view returns (uint) {
 return a \* (b + 42) + block.timestamp;
 }
}
Note
`constant` on functions used to be an alias to `view`, but this was dropped in version 0.5.0.
Note
Getter methods are automatically marked `view`.
Note
Prior to version 0.5.0, the compiler did not use the `STATICCALL` opcode for `view` functions. This enabled state modifications in `view` functions through the use of invalid explicit type conversions. By using `STATICCALL` for `view` functions, modifications to the state are prevented on the level of the EVM.
#### Pure Functions[](#pure-functions "Link to this heading")
Functions can be declared `pure` in which case they promise not to read from or modify the state. In particular, it should be possible to evaluate a `pure` function at compile-time given only its inputs and `msg.data`, but without any knowledge of the current blockchain state. This means that reading from `immutable` variables can be a non-pure operation.
Note
If the compiler’s EVM target is Byzantium or newer (default) the opcode `STATICCALL` is used, which does not guarantee that the state is not read, but at least that it is not modified.
In addition to the list of state modifying statements explained above, the following are considered reading from the state:
1. Reading from state variables (storage and transient storage).
 
2. Accessing `address(this).balance` or `<address>.balance`.
 
3. Accessing any of the members of `block`, `tx`, `msg` (with the exception of `msg.sig` and `msg.data`).
 
4. Calling any function not marked `pure`.
 
5. Using inline assembly that contains certain opcodes.
 
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgKiAoYiArIDQyKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
contract C {
 function f(uint a, uint b) public pure returns (uint) {
 return a \* (b + 42);
 }
}
Pure functions are able to use the `revert()` and `require()` functions to revert potential state changes when an [error occurs](https://docs.soliditylang.org/en/latest/control-structures.html#assert-and-require).
Reverting a state change is not considered a “state modification”, as only changes to the state made previously in code that did not have the `view` or `pure` restriction are reverted and that code has the option to catch the `revert` and not pass it on.
This behavior is also in line with the `STATICCALL` opcode.
Warning
It is not possible to prevent functions from reading the state at the level of the EVM, it is only possible to prevent them from writing to the state (i.e. only `view` can be enforced at the EVM level, `pure` can not).
Note
Prior to version 0.5.0, the compiler did not use the `STATICCALL` opcode for `pure` functions. This enabled state modifications in `pure` functions through the use of invalid explicit type conversions. By using `STATICCALL` for `pure` functions, modifications to the state are prevented on the level of the EVM.
Note
Prior to version 0.4.17 the compiler did not enforce that `pure` is not reading the state. It is a compile-time type check, which can be circumvented by doing invalid explicit conversions between contract types, because the compiler can verify that the type of the contract does not do state-changing operations, but it cannot check that the contract that will be called at runtime is actually of that type.
### Special Functions[](#special-functions "Link to this heading")
#### Receive Ether Function[](#receive-ether-function "Link to this heading")
A contract can have at most one `receive` function, declared using `receive() external payable { ... }` (without the `function` keyword). This function cannot have arguments, cannot return anything and must have `external` visibility and `payable` state mutability. It can be virtual, can override and can have modifiers.
The receive function is executed on a call to the contract with empty calldata. This is the function that is executed on plain Ether transfers (e.g. via `.send()` or `.transfer()`). If no such function exists, but a payable [fallback function](#fallback-function) exists, the fallback function will be called on a plain Ether transfer. If neither a receive Ether nor a payable fallback function is present, the contract cannot receive Ether through a transaction that does not represent a payable function call and throws an exception.
In the worst case, the `receive` function can only rely on 2300 gas being available (for example when `send` or `transfer` is used), leaving little room to perform other operations except basic logging. The following operations will consume more gas than the 2300 gas stipend:
* Writing to storage
 
* Creating a contract
 
* Calling an external function which consumes a large amount of gas
 
* Sending Ether
 
Warning
When Ether is sent directly to a contract (without a function call, i.e. sender uses `send` or `transfer`) but the receiving contract does not define a receive Ether function or a payable fallback function, an exception will be thrown, sending back the Ether (this was different before Solidity v0.4.0). If you want your contract to receive Ether, you have to implement a receive Ether function (using payable fallback functions for receiving Ether is not recommended, since the fallback is invoked and would not fail for interface confusions on the part of the sender).
Warning
A contract without a receive Ether function can receive Ether as a recipient of a _coinbase transaction_ (aka _miner block reward_) or as a destination of a `selfdestruct`.
A contract cannot react to such Ether transfers and thus also cannot reject them. This is a design choice of the EVM and Solidity cannot work around it.
It also means that `address(this).balance` can be higher than the sum of some manual accounting implemented in a contract (i.e. having a counter updated in the receive Ether function).
Below you can see an example of a Sink contract that uses function `receive`.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKLy8gVGhpcyBjb250cmFjdCBrZWVwcyBhbGwgRXRoZXIgc2VudCB0byBpdCB3aXRoIG5vIHdheQovLyB0byBnZXQgaXQgYmFjay4KY29udHJhY3QgU2luayB7CiAgICBldmVudCBSZWNlaXZlZChhZGRyZXNzLCB1aW50KTsKICAgIHJlY2VpdmUoKSBleHRlcm5hbCBwYXlhYmxlIHsKICAgICAgICBlbWl0IFJlY2VpdmVkKG1zZy5zZW5kZXIsIG1zZy52YWx1ZSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
// This contract keeps all Ether sent to it with no way
// to get it back.
contract Sink {
 event Received(address, uint);
 receive() external payable {
 emit Received(msg.sender, msg.value);
 }
}
#### Fallback Function[](#fallback-function "Link to this heading")
A contract can have at most one `fallback` function, declared using either `fallback () external [payable]` or `fallback (bytes calldata input) external [payable] returns (bytes memory output)` (both without the `function` keyword). This function must have `external` visibility. A fallback function can be virtual, can override and can have modifiers.
The fallback function is executed on a call to the contract if none of the other functions match the given function signature, or if no data was supplied at all and there is no [receive Ether function](#receive-ether-function). The fallback function always receives data, but in order to also receive Ether it must be marked `payable`.
If the version with parameters is used, `input` will contain the full data sent to the contract (equal to `msg.data`) and can return data in `output`. The returned data will not be ABI-encoded. Instead it will be returned without modifications (not even padding).
In the worst case, if a payable fallback function is also used in place of a receive function, it can only rely on 2300 gas being available (see [receive Ether function](#receive-ether-function) for a brief description of the implications of this).
Like any function, the fallback function can execute complex operations as long as there is enough gas passed on to it.
Warning
A `payable` fallback function is also executed for plain Ether transfers, if no [receive Ether function](#receive-ether-function) is present. It is recommended to always define a receive Ether function as well, if you define a payable fallback function to distinguish Ether transfers from interface confusions.
Note
If you want to decode the input data, you can check the first four bytes for the function selector and then you can use `abi.decode` together with the array slice syntax to decode ABI-encoded data: `(c, d) = abi.decode(input[4:], (uint256, uint256));` Note that this should only be used as a last resort and proper functions should be used instead.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKY29udHJhY3QgVGVzdCB7CiAgICB1aW50IHg7CiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgYWxsIG1lc3NhZ2VzIHNlbnQgdG8KICAgIC8vIHRoaXMgY29udHJhY3QgKHRoZXJlIGlzIG5vIG90aGVyIGZ1bmN0aW9uKS4KICAgIC8vIFNlbmRpbmcgRXRoZXIgdG8gdGhpcyBjb250cmFjdCB3aWxsIGNhdXNlIGFuIGV4Y2VwdGlvbiwKICAgIC8vIGJlY2F1c2UgdGhlIGZhbGxiYWNrIGZ1bmN0aW9uIGRvZXMgbm90IGhhdmUgdGhlIGBwYXlhYmxlYAogICAgLy8gbW9kaWZpZXIuCiAgICBmYWxsYmFjaygpIGV4dGVybmFsIHsgeCA9IDE7IH0KfQoKY29udHJhY3QgVGVzdFBheWFibGUgewogICAgdWludCB4OwogICAgdWludCB5OwogICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGFsbCBtZXNzYWdlcyBzZW50IHRvCiAgICAvLyB0aGlzIGNvbnRyYWN0LCBleGNlcHQgcGxhaW4gRXRoZXIgdHJhbnNmZXJzCiAgICAvLyAodGhlcmUgaXMgbm8gb3RoZXIgZnVuY3Rpb24gZXhjZXB0IHRoZSByZWNlaXZlIGZ1bmN0aW9uKS4KICAgIC8vIEFueSBjYWxsIHdpdGggbm9uLWVtcHR5IGNhbGxkYXRhIHRvIHRoaXMgY29udHJhY3Qgd2lsbCBleGVjdXRlCiAgICAvLyB0aGUgZmFsbGJhY2sgZnVuY3Rpb24gKGV2ZW4gaWYgRXRoZXIgaXMgc2VudCBhbG9uZyB3aXRoIHRoZSBjYWxsKS4KICAgIGZhbGxiYWNrKCkgZXh0ZXJuYWwgcGF5YWJsZSB7IHggPSAxOyB5ID0gbXNnLnZhbHVlOyB9CgogICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIHBsYWluIEV0aGVyIHRyYW5zZmVycywgaS5lLgogICAgLy8gZm9yIGV2ZXJ5IGNhbGwgd2l0aCBlbXB0eSBjYWxsZGF0YS4KICAgIHJlY2VpdmUoKSBleHRlcm5hbCBwYXlhYmxlIHsgeCA9IDI7IHkgPSBtc2cudmFsdWU7IH0KfQoKY29udHJhY3QgQ2FsbGVyIHsKICAgIGZ1bmN0aW9uIGNhbGxUZXN0KFRlc3QgdGVzdCkgcHVibGljIHJldHVybnMgKGJvb2wpIHsKICAgICAgICAoYm9vbCBzdWNjZXNzLCkgPSBhZGRyZXNzKHRlc3QpLmNhbGwoYWJpLmVuY29kZVdpdGhTaWduYXR1cmUoIm5vbkV4aXN0aW5nRnVuY3Rpb24oKSIpKTsKICAgICAgICByZXF1aXJlKHN1Y2Nlc3MpOwogICAgICAgIC8vIHJlc3VsdHMgaW4gdGVzdC54IGJlY29taW5nID09IDEuCgogICAgICAgIC8vIGFkZHJlc3ModGVzdCkgd2lsbCBub3QgYWxsb3cgdG8gY2FsbCBgYHNlbmRgYCBkaXJlY3RseSwgc2luY2UgYGB0ZXN0YGAgaGFzIG5vIHBheWFibGUKICAgICAgICAvLyBmYWxsYmFjayBmdW5jdGlvbi4KICAgICAgICAvLyBJdCBoYXMgdG8gYmUgY29udmVydGVkIHRvIHRoZSBgYGFkZHJlc3MgcGF5YWJsZWBgIHR5cGUgdG8gZXZlbiBhbGxvdyBjYWxsaW5nIGBgc2VuZGBgIG9uIGl0LgogICAgICAgIGFkZHJlc3MgcGF5YWJsZSB0ZXN0UGF5YWJsZSA9IHBheWFibGUoYWRkcmVzcyh0ZXN0KSk7CgogICAgICAgIC8vIElmIHNvbWVvbmUgc2VuZHMgRXRoZXIgdG8gdGhhdCBjb250cmFjdCwKICAgICAgICAvLyB0aGUgdHJhbnNmZXIgd2lsbCBmYWlsLCBpLmUuIHRoaXMgcmV0dXJucyBmYWxzZSBoZXJlLgogICAgICAgIHJldHVybiB0ZXN0UGF5YWJsZS5zZW5kKDIgZXRoZXIpOwogICAgfQoKICAgIGZ1bmN0aW9uIGNhbGxUZXN0UGF5YWJsZShUZXN0UGF5YWJsZSB0ZXN0KSBwdWJsaWMgcmV0dXJucyAoYm9vbCkgewogICAgICAgIChib29sIHN1Y2Nlc3MsKSA9IGFkZHJlc3ModGVzdCkuY2FsbChhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgibm9uRXhpc3RpbmdGdW5jdGlvbigpIikpOwogICAgICAgIHJlcXVpcmUoc3VjY2Vzcyk7CiAgICAgICAgLy8gcmVzdWx0cyBpbiB0ZXN0LnggYmVjb21pbmcgPT0gMSBhbmQgdGVzdC55IGJlY29taW5nIDAuCiAgICAgICAgKHN1Y2Nlc3MsKSA9IGFkZHJlc3ModGVzdCkuY2FsbHt2YWx1ZTogMX0oYWJpLmVuY29kZVdpdGhTaWduYXR1cmUoIm5vbkV4aXN0aW5nRnVuY3Rpb24oKSIpKTsKICAgICAgICByZXF1aXJlKHN1Y2Nlc3MpOwogICAgICAgIC8vIHJlc3VsdHMgaW4gdGVzdC54IGJlY29taW5nID09IDEgYW5kIHRlc3QueSBiZWNvbWluZyAxLgoKICAgICAgICAvLyBJZiBzb21lb25lIHNlbmRzIEV0aGVyIHRvIHRoYXQgY29udHJhY3QsIHRoZSByZWNlaXZlIGZ1bmN0aW9uIGluIFRlc3RQYXlhYmxlIHdpbGwgYmUgY2FsbGVkLgogICAgICAgIC8vIFNpbmNlIHRoYXQgZnVuY3Rpb24gd3JpdGVzIHRvIHN0b3JhZ2UsIGl0IHRha2VzIG1vcmUgZ2FzIHRoYW4gaXMgYXZhaWxhYmxlIHdpdGggYQogICAgICAgIC8vIHNpbXBsZSBgYHNlbmRgYCBvciBgYHRyYW5zZmVyYGAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgaGF2ZSB0byB1c2UgYSBsb3ctbGV2ZWwgY2FsbC4KICAgICAgICAoc3VjY2VzcywpID0gYWRkcmVzcyh0ZXN0KS5jYWxse3ZhbHVlOiAyIGV0aGVyfSgiIik7CiAgICAgICAgcmVxdWlyZShzdWNjZXNzKTsKICAgICAgICAvLyByZXN1bHRzIGluIHRlc3QueCBiZWNvbWluZyA9PSAyIGFuZCB0ZXN0LnkgYmVjb21pbmcgMiBldGhlci4KCiAgICAgICAgcmV0dXJuIHRydWU7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.2 <0.9.0;
contract Test {
 uint x;
 // This function is called for all messages sent to
 // this contract (there is no other function).
 // Sending Ether to this contract will cause an exception,
 // because the fallback function does not have the \`payable\`
 // modifier.
 fallback() external { x \= 1; }
}
contract TestPayable {
 uint x;
 uint y;
 // This function is called for all messages sent to
 // this contract, except plain Ether transfers
 // (there is no other function except the receive function).
 // Any call with non-empty calldata to this contract will execute
 // the fallback function (even if Ether is sent along with the call).
 fallback() external payable { x \= 1; y \= msg.value; }
 // This function is called for plain Ether transfers, i.e.
 // for every call with empty calldata.
 receive() external payable { x \= 2; y \= msg.value; }
}
contract Caller {
 function callTest(Test test) public returns (bool) {
 (bool success,) \= address(test).call(abi.encodeWithSignature("nonExistingFunction()"));
 require(success);
 // results in test.x becoming == 1.
 // address(test) will not allow to call \`\`send\`\` directly, since \`\`test\`\` has no payable
 // fallback function.
 // It has to be converted to the \`\`address payable\`\` type to even allow calling \`\`send\`\` on it.
 address payable testPayable \= payable(address(test));
 // If someone sends Ether to that contract,
 // the transfer will fail, i.e. this returns false here.
 return testPayable.send(2 ether);
 }
 function callTestPayable(TestPayable test) public returns (bool) {
 (bool success,) \= address(test).call(abi.encodeWithSignature("nonExistingFunction()"));
 require(success);
 // results in test.x becoming == 1 and test.y becoming 0.
 (success,) \= address(test).call{value: 1}(abi.encodeWithSignature("nonExistingFunction()"));
 require(success);
 // results in test.x becoming == 1 and test.y becoming 1.
 // If someone sends Ether to that contract, the receive function in TestPayable will be called.
 // Since that function writes to storage, it takes more gas than is available with a
 // simple \`\`send\`\` or \`\`transfer\`\`. Because of that, we have to use a low-level call.
 (success,) \= address(test).call{value: 2 ether}("");
 require(success);
 // results in test.x becoming == 2 and test.y becoming 2 ether.
 return true;
 }
}
### Function Overloading[](#function-overloading "Link to this heading")
A contract can have multiple functions of the same name but with different parameter types. This process is called “overloading” and also applies to inherited functions. The following example shows overloading of the function `f` in the scope of contract `A`.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEEgewogICAgZnVuY3Rpb24gZih1aW50IHZhbHVlKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IG91dCkgewogICAgICAgIG91dCA9IHZhbHVlOwogICAgfQoKICAgIGZ1bmN0aW9uIGYodWludCB2YWx1ZSwgYm9vbCByZWFsbHkpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQgb3V0KSB7CiAgICAgICAgaWYgKHJlYWxseSkKICAgICAgICAgICAgb3V0ID0gdmFsdWU7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract A {
 function f(uint value) public pure returns (uint out) {
 out \= value;
 }
 function f(uint value, bool really) public pure returns (uint out) {
 if (really)
 out \= value;
 }
}
Overloaded functions are also present in the external interface. It is an error if two externally visible functions differ by their Solidity types but not by their external types.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCi8vIFRoaXMgd2lsbCBub3QgY29tcGlsZQpjb250cmFjdCBBIHsKICAgIGZ1bmN0aW9uIGYoQiB2YWx1ZSkgcHVibGljIHB1cmUgcmV0dXJucyAoQiBvdXQpIHsKICAgICAgICBvdXQgPSB2YWx1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBmKGFkZHJlc3MgdmFsdWUpIHB1YmxpYyBwdXJlIHJldHVybnMgKGFkZHJlc3Mgb3V0KSB7CiAgICAgICAgb3V0ID0gdmFsdWU7CiAgICB9Cn0KCmNvbnRyYWN0IEIgewp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
// This will not compile
contract A {
 function f(B value) public pure returns (B out) {
 out \= value;
 }
 function f(address value) public pure returns (address out) {
 out \= value;
 }
}
contract B {
}
Both `f` function overloads above end up accepting the address type for the ABI although they are considered different inside Solidity.
#### Overload resolution and Argument matching[](#overload-resolution-and-argument-matching "Link to this heading")
Overloaded functions are selected by matching the function declarations in the current scope to the arguments supplied in the function call. Functions are selected as overload candidates if all arguments can be implicitly converted to the expected types. If there is not exactly one candidate, resolution fails.
Note
Return parameters are not taken into account for overload resolution.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEEgewogICAgZnVuY3Rpb24gZih1aW50OCB2YWwpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQ4IG91dCkgewogICAgICAgIG91dCA9IHZhbDsKICAgIH0KCiAgICBmdW5jdGlvbiBmKHVpbnQyNTYgdmFsKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50MjU2IG91dCkgewogICAgICAgIG91dCA9IHZhbDsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract A {
 function f(uint8 val) public pure returns (uint8 out) {
 out \= val;
 }
 function f(uint256 val) public pure returns (uint256 out) {
 out \= val;
 }
}
Calling `f(50)` would create a type error since `50` can be implicitly converted both to `uint8` and `uint256` types. On another hand `f(256)` would resolve to `f(uint256)` overload as `256` cannot be implicitly converted to `uint8`.
## Events[](#events "Link to this heading")
Solidity events give an abstraction on top of the EVM’s logging functionality. Applications can subscribe and listen to these events through the RPC interface of an Ethereum client.
Events can be defined at file level or as inheritable members of contracts (including interfaces and libraries). When you call them, they cause the arguments to be stored in the transaction’s log - a special data structure in the blockchain. These logs are associated with the address of the contract that emitted them, are incorporated into the blockchain, and stay there as long as a block is accessible (forever as of now, but this might change in the future). The Log and its event data are not accessible from within contracts (not even from the contract that created them).
It is possible to request a Merkle proof for logs, so if an external entity supplies a contract with such a proof, it can check that the log actually exists inside the blockchain. You have to supply block headers because the contract can only see the last 256 block hashes.
You can add the attribute `indexed` to up to three parameters which adds them to a special data structure known as [“topics”](https://docs.soliditylang.org/en/latest/abi-spec.html#abi-events) instead of the data part of the log. A topic can only hold a single word (32 bytes) so if you use a [reference type](https://docs.soliditylang.org/en/latest/types.html#reference-types) for an indexed argument, the Keccak-256 hash of the value is stored as a topic instead.
All parameters without the `indexed` attribute are [ABI-encoded](https://docs.soliditylang.org/en/latest/abi-spec.html#abi) into the data part of the log.
Topics allow you to search for events, for example when filtering a sequence of blocks for certain events. You can also filter events by the address of the contract that emitted the event.
For example, the code below uses the web3.js `subscribe("logs")` [method](https://web3js.readthedocs.io/en/1.0/web3-eth-subscribe.html#subscribe-logs) to filter logs that match a topic with a certain address value:
var options \= {
 fromBlock: 0,
 address: web3.eth.defaultAccount,
 topics: \["0x0000000000000000000000000000000000000000000000000000000000000000", null, null\]
};
web3.eth.subscribe('logs', options, function (error, result) {
 if (!error)
 console.log(result);
})
 .on("data", function (log) {
 console.log(log);
 })
 .on("changed", function (log) {
});
The hash of the signature of the event is one of the topics, except if you declared the event with the `anonymous` specifier. This means that it is not possible to filter for specific anonymous events by name, you can only filter by the contract address. The advantage of anonymous events is that they are cheaper to deploy and call. It also allows you to declare four indexed arguments rather than three.
Note
Since the transaction log only stores the event data and not the type, you have to know the type of the event, including which parameter is indexed and if the event is anonymous in order to correctly interpret the data. In particular, it is possible to “fake” the signature of another event using an anonymous event.
### Members of Events[](#members-of-events "Link to this heading")
* `event.selector`: For non-anonymous events, this is a `bytes32` value containing the `keccak256` hash of the event signature, as used in the default topic.
 
### Example[](#example "Link to this heading")
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIxIDwwLjkuMDsKCmNvbnRyYWN0IENsaWVudFJlY2VpcHQgewogICAgZXZlbnQgRGVwb3NpdCgKICAgICAgICBhZGRyZXNzIGluZGV4ZWQgZnJvbSwKICAgICAgICBieXRlczMyIGluZGV4ZWQgaWQsCiAgICAgICAgdWludCB2YWx1ZQogICAgKTsKCiAgICBmdW5jdGlvbiBkZXBvc2l0KGJ5dGVzMzIgaWQpIHB1YmxpYyBwYXlhYmxlIHsKICAgICAgICAvLyBFdmVudHMgYXJlIGVtaXR0ZWQgdXNpbmcgYGVtaXRgLCBmb2xsb3dlZCBieQogICAgICAgIC8vIHRoZSBuYW1lIG9mIHRoZSBldmVudCBhbmQgdGhlIGFyZ3VtZW50cwogICAgICAgIC8vIChpZiBhbnkpIGluIHBhcmVudGhlc2VzLiBBbnkgc3VjaCBpbnZvY2F0aW9uCiAgICAgICAgLy8gKGV2ZW4gZGVlcGx5IG5lc3RlZCkgY2FuIGJlIGRldGVjdGVkIGZyb20KICAgICAgICAvLyB0aGUgSmF2YVNjcmlwdCBBUEkgYnkgZmlsdGVyaW5nIGZvciBgRGVwb3NpdGAuCiAgICAgICAgZW1pdCBEZXBvc2l0KG1zZy5zZW5kZXIsIGlkLCBtc2cudmFsdWUpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.21 <0.9.0;
contract ClientReceipt {
 event Deposit(
 address indexed from,
 bytes32 indexed id,
 uint value
 );
 function deposit(bytes32 id) public payable {
 // Events are emitted using \`emit\`, followed by
 // the name of the event and the arguments
 // (if any) in parentheses. Any such invocation
 // (even deeply nested) can be detected from
 // the JavaScript API by filtering for \`Deposit\`.
 emit Deposit(msg.sender, id, msg.value);
 }
}
The use in the JavaScript API is as follows:
var abi \= /\* abi as generated by the compiler \*/;
var ClientReceipt \= web3.eth.contract(abi);
var clientReceipt \= ClientReceipt.at("0x1234...ab67" /\* address \*/);
var depositEvent \= clientReceipt.Deposit();
// watch for changes
depositEvent.watch(function(error, result){
 // result contains non-indexed arguments and topics
 // given to the \`Deposit\` call.
 if (!error)
 console.log(result);
});
// Or pass a callback to start watching immediately
var depositEvent \= clientReceipt.Deposit(function(error, result) {
 if (!error)
 console.log(result);
});
The output of the above looks like the following (trimmed):
{
 "returnValues": {
 "from": "0x1111…FFFFCCCC",
 "id": "0x50…sd5adb20",
 "value": "0x420042"
 },
 "raw": {
 "data": "0x7f…91385",
 "topics": \["0xfd4…b4ead7", "0x7f…1a91385"\]
 }
}
### Additional Resources for Understanding Events[](#additional-resources-for-understanding-events "Link to this heading")
* [JavaScript documentation](https://github.com/web3/web3.js/blob/1.x/docs/web3-eth-contract.rst#events)
 
* [Example usage of events](https://github.com/ethchange/smart-exchange/blob/master/lib/contracts/SmartExchange.sol)
 
* [How to access them in js](https://github.com/ethchange/smart-exchange/blob/master/lib/exchange_transactions.js)
 
## Custom Errors[](#custom-errors "Link to this heading")
Errors in Solidity provide a convenient and gas-efficient way to explain to the user why an operation failed. They can be defined inside and outside of contracts (including interfaces and libraries).
They have to be used together with the [revert statement](https://docs.soliditylang.org/en/latest/control-structures.html#revert-statement) or the [require function](https://docs.soliditylang.org/en/latest/control-structures.html#assert-and-require-statements). In the case of `revert` statements, or `require` calls where the condition is evaluated to be false, all changes in the current call are reverted, and the error data passed back to the caller.
The example below shows custom error usage with the `revert` statement in function `transferWithRevertError`, as well as the newer approach with `require` in function `transferWithRequireError`.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjc7CgovLy8gSW5zdWZmaWNpZW50IGJhbGFuY2UgZm9yIHRyYW5zZmVyLiBOZWVkZWQgYHJlcXVpcmVkYCBidXQgb25seQovLy8gYGF2YWlsYWJsZWAgYXZhaWxhYmxlLgovLy8gQHBhcmFtIGF2YWlsYWJsZSBiYWxhbmNlIGF2YWlsYWJsZS4KLy8vIEBwYXJhbSByZXF1aXJlZCByZXF1ZXN0ZWQgYW1vdW50IHRvIHRyYW5zZmVyLgplcnJvciBJbnN1ZmZpY2llbnRCYWxhbmNlKHVpbnQyNTYgYXZhaWxhYmxlLCB1aW50MjU2IHJlcXVpcmVkKTsKCmNvbnRyYWN0IFRlc3RUb2tlbiB7CiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gdWludCkgYmFsYW5jZTsKICAgIGZ1bmN0aW9uIHRyYW5zZmVyV2l0aFJldmVydEVycm9yKGFkZHJlc3MgdG8sIHVpbnQyNTYgYW1vdW50KSBwdWJsaWMgewogICAgICAgIGlmIChhbW91bnQgPiBiYWxhbmNlW21zZy5zZW5kZXJdKQogICAgICAgICAgICByZXZlcnQgSW5zdWZmaWNpZW50QmFsYW5jZSh7CiAgICAgICAgICAgICAgICBhdmFpbGFibGU6IGJhbGFuY2VbbXNnLnNlbmRlcl0sCiAgICAgICAgICAgICAgICByZXF1aXJlZDogYW1vdW50CiAgICAgICAgICAgIH0pOwogICAgICAgIGJhbGFuY2VbbXNnLnNlbmRlcl0gLT0gYW1vdW50OwogICAgICAgIGJhbGFuY2VbdG9dICs9IGFtb3VudDsKICAgIH0KICAgIGZ1bmN0aW9uIHRyYW5zZmVyV2l0aFJlcXVpcmVFcnJvcihhZGRyZXNzIHRvLCB1aW50MjU2IGFtb3VudCkgcHVibGljIHsKICAgICAgICByZXF1aXJlKGFtb3VudCA8PSBiYWxhbmNlW21zZy5zZW5kZXJdLCBJbnN1ZmZpY2llbnRCYWxhbmNlKGJhbGFuY2VbbXNnLnNlbmRlcl0sIGFtb3VudCkpOwogICAgICAgIGJhbGFuY2VbbXNnLnNlbmRlcl0gLT0gYW1vdW50OwogICAgICAgIGJhbGFuY2VbdG9dICs9IGFtb3VudDsKICAgIH0KICAgIC8vIC4uLgp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.27;
/// Insufficient balance for transfer. Needed \`required\` but only
/// \`available\` available.
/// @param available balance available.
/// @param required requested amount to transfer.
error InsufficientBalance(uint256 available, uint256 required);
contract TestToken {
 mapping(address \=> uint) balance;
 function transferWithRevertError(address to, uint256 amount) public {
 if (amount \> balance\[msg.sender\])
 revert InsufficientBalance({
 available: balance\[msg.sender\],
 required: amount
 });
 balance\[msg.sender\] \-= amount;
 balance\[to\] += amount;
 }
 function transferWithRequireError(address to, uint256 amount) public {
 require(amount <= balance\[msg.sender\], InsufficientBalance(balance\[msg.sender\], amount));
 balance\[msg.sender\] \-= amount;
 balance\[to\] += amount;
 }
 // ...
}
Another important detail to mention when it comes to using `require` with custom errors, is that memory allocation for the error-based revert reason will only happen in the reverting case, which, along with optimization of constants and string literals makes this about as gas-efficient as the `if (!condition) revert CustomError(args)` pattern.
Errors cannot be overloaded or overridden but are inherited. The same error can be defined in multiple places as long as the scopes are distinct. Instances of errors can only be created using `revert` statements, or as the second argument to `require` functions.
The error creates data that is then passed to the caller with the revert operation to either return to the off-chain component or catch it in a [try/catch statement](https://docs.soliditylang.org/en/latest/control-structures.html#try-catch). Note that an error can only be caught when coming from an external call, reverts happening in internal calls or inside the same function cannot be caught.
If you do not provide any parameters, the error only needs four bytes of data and you can use [NatSpec](https://docs.soliditylang.org/en/latest/natspec-format.html#natspec) as above to further explain the reasons behind the error, which is not stored on chain. This makes this a very cheap and convenient error-reporting feature at the same time.
More specifically, an error instance is ABI-encoded in the same way as a function call to a function of the same name and types would be and then used as the return data in the `revert` opcode. This means that the data consists of a 4-byte selector followed by [ABI-encoded](https://docs.soliditylang.org/en/latest/abi-spec.html#abi) data. The selector consists of the first four bytes of the keccak256-hash of the signature of the error type.
Note
It is possible for a contract to revert with different errors of the same name or even with errors defined in different places that are indistinguishable by the caller. For the outside, i.e. the ABI, only the name of the error is relevant, not the contract or file where it is defined.
The statement `require(condition, "description");` would be equivalent to `if (!condition) revert Error("description")` if you could define `error Error(string)`. Note, however, that `Error` is a built-in type and cannot be defined in user-supplied code.
Similarly, a failing `assert` or similar conditions will revert with an error of the built-in type `Panic(uint256)`.
Note
Error data should only be used to give an indication of failure, but not as a means for control-flow. The reason is that the revert data of inner calls is propagated back through the chain of external calls by default. This means that an inner call can “forge” revert data that looks like it could have come from the contract that called it.
### Members of Errors[](#members-of-errors "Link to this heading")
* `error.selector`: A `bytes4` value containing the error selector.
 
## Inheritance[](#inheritance "Link to this heading")
Solidity supports multiple inheritance including polymorphism.
Polymorphism means that a function call (internal and external) always executes the function of the same name (and parameter types) in the most derived contract in the inheritance hierarchy. This has to be explicitly enabled on each function in the hierarchy using the `virtual` and `override` keywords. See [Function Overriding](#function-overriding) for more details.
It is possible to call functions further up in the inheritance hierarchy internally by explicitly specifying the contract using `ContractName.functionName()` or using `super.functionName()` if you want to call the function one level higher up in the flattened inheritance hierarchy (see below).
When a contract inherits from other contracts, only a single contract is created on the blockchain, and the code from all the base contracts is compiled into the created contract. This means that all internal calls to functions of base contracts also just use internal function calls (`super.f(..)` will use JUMP and not a message call).
State variable shadowing is considered as an error. A derived contract can only declare a state variable `x`, if there is no visible state variable with the same name in any of its bases.
The general inheritance system is very similar to [Python’s](https://docs.python.org/3/tutorial/classes.html#inheritance), especially concerning multiple inheritance, but there are also some [differences](#multi-inheritance).
Details are given in the following example.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgT3duZWQgewogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQp9CgovLyBVc2UgYGlzYCB0byBkZXJpdmUgZnJvbSBhbm90aGVyIGNvbnRyYWN0LiBEZXJpdmVkCi8vIGNvbnRyYWN0cyBjYW4gYWNjZXNzIGFsbCBub24tcHJpdmF0ZSBtZW1iZXJzIGluY2x1ZGluZwovLyBpbnRlcm5hbCBmdW5jdGlvbnMgYW5kIHN0YXRlIHZhcmlhYmxlcy4gVGhlc2UgY2Fubm90IGJlCi8vIGFjY2Vzc2VkIGV4dGVybmFsbHkgdmlhIGB0aGlzYCwgdGhvdWdoLgpjb250cmFjdCBFbWl0dGFibGUgaXMgT3duZWQgewogICAgZXZlbnQgRW1pdHRlZCgpOwoKICAgIC8vIFRoZSBrZXl3b3JkIGB2aXJ0dWFsYCBtZWFucyB0aGF0IHRoZSBmdW5jdGlvbiBjYW4gY2hhbmdlCiAgICAvLyBpdHMgYmVoYXZpb3IgaW4gZGVyaXZlZCBjbGFzc2VzICgib3ZlcnJpZGluZyIpLgogICAgZnVuY3Rpb24gZW1pdEV2ZW50KCkgdmlydHVhbCBwdWJsaWMgewogICAgICAgIGlmIChtc2cuc2VuZGVyID09IG93bmVyKQogICAgICAgICAgICBlbWl0IEVtaXR0ZWQoKTsKICAgIH0KfQoKLy8gVGhlc2UgYWJzdHJhY3QgY29udHJhY3RzIGFyZSBvbmx5IHByb3ZpZGVkIHRvIG1ha2UgdGhlCi8vIGludGVyZmFjZSBrbm93biB0byB0aGUgY29tcGlsZXIuIE5vdGUgdGhlIGZ1bmN0aW9uCi8vIHdpdGhvdXQgYm9keS4gSWYgYSBjb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgYWxsCi8vIGZ1bmN0aW9ucyBpdCBjYW4gb25seSBiZSB1c2VkIGFzIGFuIGludGVyZmFjZS4KYWJzdHJhY3QgY29udHJhY3QgQ29uZmlnIHsKICAgIGZ1bmN0aW9uIGxvb2t1cCh1aW50IGlkKSBwdWJsaWMgdmlydHVhbCByZXR1cm5zIChhZGRyZXNzIGFkcik7Cn0KCmFic3RyYWN0IGNvbnRyYWN0IE5hbWVSZWcgewogICAgZnVuY3Rpb24gcmVnaXN0ZXIoYnl0ZXMzMiBuYW1lKSBwdWJsaWMgdmlydHVhbDsKICAgIGZ1bmN0aW9uIHVucmVnaXN0ZXIoKSBwdWJsaWMgdmlydHVhbDsKfQoKLy8gTXVsdGlwbGUgaW5oZXJpdGFuY2UgaXMgcG9zc2libGUuIE5vdGUgdGhhdCBgT3duZWRgIGlzCi8vIGFsc28gYSBiYXNlIGNsYXNzIG9mIGBFbWl0dGFibGVgLCB5ZXQgdGhlcmUgaXMgb25seSBhIHNpbmdsZQovLyBpbnN0YW5jZSBvZiBgT3duZWRgIChhcyBmb3IgdmlydHVhbCBpbmhlcml0YW5jZSBpbiBDKyspLgpjb250cmFjdCBOYW1lZCBpcyBPd25lZCwgRW1pdHRhYmxlIHsKICAgIGNvbnN0cnVjdG9yKGJ5dGVzMzIgbmFtZSkgewogICAgICAgIENvbmZpZyBjb25maWcgPSBDb25maWcoMHhENWY5RDhEOTQ4ODZFNzBiMDZFNDc0YzNmQjE0RmQ0M0UyZjIzOTcwKTsKICAgICAgICBOYW1lUmVnKGNvbmZpZy5sb29rdXAoMSkpLnJlZ2lzdGVyKG5hbWUpOwogICAgfQoKICAgIC8vIEZ1bmN0aW9ucyBjYW4gYmUgb3ZlcnJpZGRlbiBieSBhbm90aGVyIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgbmFtZSBhbmQKICAgIC8vIHRoZSBzYW1lIG51bWJlci90eXBlcyBvZiBpbnB1dHMuIElmIHRoZSBvdmVycmlkaW5nIGZ1bmN0aW9uIGhhcyBkaWZmZXJlbnQKICAgIC8vIHR5cGVzIG9mIG91dHB1dCBwYXJhbWV0ZXJzLCB0aGF0IGNhdXNlcyBhbiBlcnJvci4KICAgIC8vIEJvdGggbG9jYWwgYW5kIG1lc3NhZ2UtYmFzZWQgZnVuY3Rpb24gY2FsbHMgdGFrZSB0aGVzZSBvdmVycmlkZXMKICAgIC8vIGludG8gYWNjb3VudC4KICAgIC8vIElmIHlvdSB3YW50IHRoZSBmdW5jdGlvbiB0byBvdmVycmlkZSwgeW91IG5lZWQgdG8gdXNlIHRoZQogICAgLy8gYG92ZXJyaWRlYCBrZXl3b3JkLiBZb3UgbmVlZCB0byBzcGVjaWZ5IHRoZSBgdmlydHVhbGAga2V5d29yZCBhZ2FpbgogICAgLy8gaWYgeW91IHdhbnQgdGhpcyBmdW5jdGlvbiB0byBiZSBvdmVycmlkZGVuIGFnYWluLgogICAgZnVuY3Rpb24gZW1pdEV2ZW50KCkgcHVibGljIHZpcnR1YWwgb3ZlcnJpZGUgewogICAgICAgIGlmIChtc2cuc2VuZGVyID09IG93bmVyKSB7CiAgICAgICAgICAgIENvbmZpZyBjb25maWcgPSBDb25maWcoMHhENWY5RDhEOTQ4ODZFNzBiMDZFNDc0YzNmQjE0RmQ0M0UyZjIzOTcwKTsKICAgICAgICAgICAgTmFtZVJlZyhjb25maWcubG9va3VwKDEpKS51bnJlZ2lzdGVyKCk7CiAgICAgICAgICAgIC8vIEl0IGlzIHN0aWxsIHBvc3NpYmxlIHRvIGNhbGwgYSBzcGVjaWZpYwogICAgICAgICAgICAvLyBvdmVycmlkZGVuIGZ1bmN0aW9uLgogICAgICAgICAgICBFbWl0dGFibGUuZW1pdEV2ZW50KCk7CiAgICAgICAgfQogICAgfQp9CgoKLy8gSWYgYSBjb25zdHJ1Y3RvciB0YWtlcyBhbiBhcmd1bWVudCwgaXQgbmVlZHMgdG8gYmUKLy8gcHJvdmlkZWQgaW4gdGhlIGhlYWRlciBvciBtb2RpZmllci1pbnZvY2F0aW9uLXN0eWxlIGF0Ci8vIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZGVyaXZlZCBjb250cmFjdCAoc2VlIGJlbG93KS4KY29udHJhY3QgUHJpY2VGZWVkIGlzIE93bmVkLCBFbWl0dGFibGUsIE5hbWVkKCJHb2xkRmVlZCIpIHsKICAgIHVpbnQgaW5mbzsKCiAgICBmdW5jdGlvbiB1cGRhdGVJbmZvKHVpbnQgbmV3SW5mbykgcHVibGljIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgaW5mbyA9IG5ld0luZm87CiAgICB9CgogICAgLy8gSGVyZSwgd2Ugb25seSBzcGVjaWZ5IGBvdmVycmlkZWAgYW5kIG5vdCBgdmlydHVhbGAuCiAgICAvLyBUaGlzIG1lYW5zIHRoYXQgY29udHJhY3RzIGRlcml2aW5nIGZyb20gYFByaWNlRmVlZGAKICAgIC8vIGNhbm5vdCBjaGFuZ2UgdGhlIGJlaGF2aW9yIG9mIGBlbWl0RXZlbnRgIGFueW1vcmUuCiAgICBmdW5jdGlvbiBlbWl0RXZlbnQoKSBwdWJsaWMgb3ZlcnJpZGUoRW1pdHRhYmxlLCBOYW1lZCkgeyBOYW1lZC5lbWl0RXZlbnQoKTsgfQogICAgZnVuY3Rpb24gZ2V0KCkgcHVibGljIHZpZXcgcmV0dXJucyh1aW50IHIpIHsgcmV0dXJuIGluZm87IH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Owned {
 address payable owner;
 constructor() { owner \= payable(msg.sender); }
}
// Use \`is\` to derive from another contract. Derived
// contracts can access all non-private members including
// internal functions and state variables. These cannot be
// accessed externally via \`this\`, though.
contract Emittable is Owned {
 event Emitted();
 // The keyword \`virtual\` means that the function can change
 // its behavior in derived classes ("overriding").
 function emitEvent() virtual public {
 if (msg.sender \== owner)
 emit Emitted();
 }
}
// These abstract contracts are only provided to make the
// interface known to the compiler. Note the function
// without body. If a contract does not implement all
// functions it can only be used as an interface.
abstract contract Config {
 function lookup(uint id) public virtual returns (address adr);
}
abstract contract NameReg {
 function register(bytes32 name) public virtual;
 function unregister() public virtual;
}
// Multiple inheritance is possible. Note that \`Owned\` is
// also a base class of \`Emittable\`, yet there is only a single
// instance of \`Owned\` (as for virtual inheritance in C++).
contract Named is Owned, Emittable {
 constructor(bytes32 name) {
 Config config \= Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
 NameReg(config.lookup(1)).register(name);
 }
 // Functions can be overridden by another function with the same name and
 // the same number/types of inputs. If the overriding function has different
 // types of output parameters, that causes an error.
 // Both local and message-based function calls take these overrides
 // into account.
 // If you want the function to override, you need to use the
 // \`override\` keyword. You need to specify the \`virtual\` keyword again
 // if you want this function to be overridden again.
 function emitEvent() public virtual override {
 if (msg.sender \== owner) {
 Config config \= Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
 NameReg(config.lookup(1)).unregister();
 // It is still possible to call a specific
 // overridden function.
 Emittable.emitEvent();
 }
 }
}
// If a constructor takes an argument, it needs to be
// provided in the header or modifier-invocation-style at
// the constructor of the derived contract (see below).
contract PriceFeed is Owned, Emittable, Named("GoldFeed") {
 uint info;
 function updateInfo(uint newInfo) public {
 if (msg.sender \== owner) info \= newInfo;
 }
 // Here, we only specify \`override\` and not \`virtual\`.
 // This means that contracts deriving from \`PriceFeed\`
 // cannot change the behavior of \`emitEvent\` anymore.
 function emitEvent() public override(Emittable, Named) { Named.emitEvent(); }
 function get() public view returns(uint r) { return info; }
}
Note that above, we call `Emittable.emitEvent()` to “forward” the emit event request. The way this is done is problematic, as seen in the following example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgT3duZWQgewogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQp9Cgpjb250cmFjdCBFbWl0dGFibGUgaXMgT3duZWQgewogICAgZXZlbnQgRW1pdHRlZCgpOwoKICAgIGZ1bmN0aW9uIGVtaXRFdmVudCgpIHZpcnR1YWwgcHVibGljIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgewogICAgICAgICAgICBlbWl0IEVtaXR0ZWQoKTsKICAgICAgICB9CiAgICB9Cn0KCmNvbnRyYWN0IEJhc2UxIGlzIEVtaXR0YWJsZSB7CiAgICBldmVudCBCYXNlMUVtaXR0ZWQoKTsKICAgIGZ1bmN0aW9uIGVtaXRFdmVudCgpIHB1YmxpYyB2aXJ0dWFsIG92ZXJyaWRlIHsKICAgICAgICAvKiBIZXJlLCB3ZSBlbWl0IGFuIGV2ZW50IHRvIHNpbXVsYXRlIHNvbWUgQmFzZTEgbG9naWMgKi8KICAgICAgICBlbWl0IEJhc2UxRW1pdHRlZCgpOwogICAgICAgIEVtaXR0YWJsZS5lbWl0RXZlbnQoKTsKICAgIH0KfQoKY29udHJhY3QgQmFzZTIgaXMgRW1pdHRhYmxlIHsKICAgIGV2ZW50IEJhc2UyRW1pdHRlZCgpOwogICAgZnVuY3Rpb24gZW1pdEV2ZW50KCkgcHVibGljIHZpcnR1YWwgb3ZlcnJpZGUgewogICAgICAgIC8qIEhlcmUsIHdlIGVtaXQgYW4gZXZlbnQgdG8gc2ltdWxhdGUgc29tZSBCYXNlMiBsb2dpYyAqLwogICAgICAgIGVtaXQgQmFzZTJFbWl0dGVkKCk7CiAgICAgICAgRW1pdHRhYmxlLmVtaXRFdmVudCgpOwogICAgfQp9Cgpjb250cmFjdCBGaW5hbCBpcyBCYXNlMSwgQmFzZTIgewogICAgZXZlbnQgRmluYWxFbWl0dGVkKCk7CiAgICBmdW5jdGlvbiBlbWl0RXZlbnQoKSBwdWJsaWMgb3ZlcnJpZGUoQmFzZTEsIEJhc2UyKSB7CiAgICAgICAgLyogSGVyZSwgd2UgZW1pdCBhbiBldmVudCB0byBzaW11bGF0ZSBzb21lIEZpbmFsIGxvZ2ljICovCiAgICAgICAgZW1pdCBGaW5hbEVtaXR0ZWQoKTsKICAgICAgICBCYXNlMi5lbWl0RXZlbnQoKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Owned {
 address payable owner;
 constructor() { owner \= payable(msg.sender); }
}
contract Emittable is Owned {
 event Emitted();
 function emitEvent() virtual public {
 if (msg.sender \== owner) {
 emit Emitted();
 }
 }
}
contract Base1 is Emittable {
 event Base1Emitted();
 function emitEvent() public virtual override {
 /\* Here, we emit an event to simulate some Base1 logic \*/
 emit Base1Emitted();
 Emittable.emitEvent();
 }
}
contract Base2 is Emittable {
 event Base2Emitted();
 function emitEvent() public virtual override {
 /\* Here, we emit an event to simulate some Base2 logic \*/
 emit Base2Emitted();
 Emittable.emitEvent();
 }
}
contract Final is Base1, Base2 {
 event FinalEmitted();
 function emitEvent() public override(Base1, Base2) {
 /\* Here, we emit an event to simulate some Final logic \*/
 emit FinalEmitted();
 Base2.emitEvent();
 }
}
A call to `Final.emitEvent()` will call `Base2.emitEvent` because we specify it explicitly in the final override, but this function will bypass `Base1.emitEvent`, resulting in the following sequence of events: `FinalEmitted -> Base2Emitted -> Emitted`, instead of the expected sequence: `FinalEmitted -> Base2Emitted -> Base1Emitted -> Emitted`. The way around this is to use `super`:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgT3duZWQgewogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQp9Cgpjb250cmFjdCBFbWl0dGFibGUgaXMgT3duZWQgewogICAgZXZlbnQgRW1pdHRlZCgpOwoKICAgIGZ1bmN0aW9uIGVtaXRFdmVudCgpIHZpcnR1YWwgcHVibGljIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgewogICAgICAgICAgICBlbWl0IEVtaXR0ZWQoKTsKICAgICAgICB9CiAgICB9Cn0KCmNvbnRyYWN0IEJhc2UxIGlzIEVtaXR0YWJsZSB7CiAgICBldmVudCBCYXNlMUVtaXR0ZWQoKTsKICAgIGZ1bmN0aW9uIGVtaXRFdmVudCgpIHB1YmxpYyB2aXJ0dWFsIG92ZXJyaWRlIHsKICAgICAgICAvKiBIZXJlLCB3ZSBlbWl0IGFuIGV2ZW50IHRvIHNpbXVsYXRlIHNvbWUgQmFzZTEgbG9naWMgKi8KICAgICAgICBlbWl0IEJhc2UxRW1pdHRlZCgpOwogICAgICAgIHN1cGVyLmVtaXRFdmVudCgpOwogICAgfQp9CgoKY29udHJhY3QgQmFzZTIgaXMgRW1pdHRhYmxlIHsKICAgIGV2ZW50IEJhc2UyRW1pdHRlZCgpOwogICAgZnVuY3Rpb24gZW1pdEV2ZW50KCkgcHVibGljIHZpcnR1YWwgb3ZlcnJpZGUgewogICAgICAgIC8qIEhlcmUsIHdlIGVtaXQgYW4gZXZlbnQgdG8gc2ltdWxhdGUgc29tZSBCYXNlMiBsb2dpYyAqLwogICAgICAgIGVtaXQgQmFzZTJFbWl0dGVkKCk7CiAgICAgICAgc3VwZXIuZW1pdEV2ZW50KCk7CiAgICB9Cn0KCmNvbnRyYWN0IEZpbmFsIGlzIEJhc2UxLCBCYXNlMiB7CiAgICBldmVudCBGaW5hbEVtaXR0ZWQoKTsKICAgIGZ1bmN0aW9uIGVtaXRFdmVudCgpIHB1YmxpYyBvdmVycmlkZShCYXNlMSwgQmFzZTIpIHsKICAgICAgICAvKiBIZXJlLCB3ZSBlbWl0IGFuIGV2ZW50IHRvIHNpbXVsYXRlIHNvbWUgRmluYWwgbG9naWMgKi8KICAgICAgICBlbWl0IEZpbmFsRW1pdHRlZCgpOwogICAgICAgIHN1cGVyLmVtaXRFdmVudCgpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Owned {
 address payable owner;
 constructor() { owner \= payable(msg.sender); }
}
contract Emittable is Owned {
 event Emitted();
 function emitEvent() virtual public {
 if (msg.sender \== owner) {
 emit Emitted();
 }
 }
}
contract Base1 is Emittable {
 event Base1Emitted();
 function emitEvent() public virtual override {
 /\* Here, we emit an event to simulate some Base1 logic \*/
 emit Base1Emitted();
 super.emitEvent();
 }
}
contract Base2 is Emittable {
 event Base2Emitted();
 function emitEvent() public virtual override {
 /\* Here, we emit an event to simulate some Base2 logic \*/
 emit Base2Emitted();
 super.emitEvent();
 }
}
contract Final is Base1, Base2 {
 event FinalEmitted();
 function emitEvent() public override(Base1, Base2) {
 /\* Here, we emit an event to simulate some Final logic \*/
 emit FinalEmitted();
 super.emitEvent();
 }
}
If `Final` calls a function of `super`, it does not simply call this function on one of its base contracts. Rather, it calls this function on the next base contract in the final inheritance graph, so it will call `Base1.emitEvent()` (note that the final inheritance sequence is – starting with the most derived contract: Final, Base2, Base1, Emittable, Owned). The actual function that is called when using super is not known in the context of the class where it is used, although its type is known. This is similar for ordinary virtual method lookup.
### Function Overriding[](#function-overriding "Link to this heading")
Base functions can be overridden by inheriting contracts to change their behavior if they are marked as `virtual`. The overriding function must then use the `override` keyword in the function header. The overriding function may only change the visibility of the overridden function from `external` to `public`. The mutability may be changed to a more strict one following the order: `nonpayable` can be overridden by `view` and `pure`. `view` can be overridden by `pure`. `payable` is an exception and cannot be changed to any other mutability.
The following example demonstrates changing mutability and visibility:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZQp7CiAgICBmdW5jdGlvbiBmb28oKSB2aXJ0dWFsIGV4dGVybmFsIHZpZXcge30KfQoKY29udHJhY3QgTWlkZGxlIGlzIEJhc2Uge30KCmNvbnRyYWN0IEluaGVyaXRlZCBpcyBNaWRkbGUKewogICAgZnVuY3Rpb24gZm9vKCkgb3ZlcnJpZGUgcHVibGljIHB1cmUge30KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Base
{
 function foo() virtual external view {}
}
contract Middle is Base {}
contract Inherited is Middle
{
 function foo() override public pure {}
}
For multiple inheritance, the most derived base contracts that define the same function must be specified explicitly after the `override` keyword. In other words, you have to specify all base contracts that define the same function and have not yet been overridden by another base contract (on some path through the inheritance graph). Additionally, if a contract inherits the same function from multiple (unrelated) bases, it has to explicitly override it:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEKewogICAgZnVuY3Rpb24gZm9vKCkgdmlydHVhbCBwdWJsaWMge30KfQoKY29udHJhY3QgQmFzZTIKewogICAgZnVuY3Rpb24gZm9vKCkgdmlydHVhbCBwdWJsaWMge30KfQoKY29udHJhY3QgSW5oZXJpdGVkIGlzIEJhc2UxLCBCYXNlMgp7CiAgICAvLyBEZXJpdmVzIGZyb20gbXVsdGlwbGUgYmFzZXMgZGVmaW5pbmcgZm9vKCksIHNvIHdlIG11c3QgZXhwbGljaXRseQogICAgLy8gb3ZlcnJpZGUgaXQKICAgIGZ1bmN0aW9uIGZvbygpIHB1YmxpYyBvdmVycmlkZShCYXNlMSwgQmFzZTIpIHt9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract Base1
{
 function foo() virtual public {}
}
contract Base2
{
 function foo() virtual public {}
}
contract Inherited is Base1, Base2
{
 // Derives from multiple bases defining foo(), so we must explicitly
 // override it
 function foo() public override(Base1, Base2) {}
}
An explicit override specifier is not required if the function is defined in a common base contract or if there is a unique function in a common base contract that already overrides all other functions.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQSB7IGZ1bmN0aW9uIGYoKSBwdWJsaWMgcHVyZXt9IH0KY29udHJhY3QgQiBpcyBBIHt9CmNvbnRyYWN0IEMgaXMgQSB7fQovLyBObyBleHBsaWNpdCBvdmVycmlkZSByZXF1aXJlZApjb250cmFjdCBEIGlzIEIsIEMge30=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract A { function f() public pure{} }
contract B is A {}
contract C is A {}
// No explicit override required
contract D is B, C {}
More formally, it is not required to override a function (directly or indirectly) inherited from multiple bases if there is a base contract that is part of all override paths for the signature, and (1) that base implements the function and no paths from the current contract to the base mentions a function with that signature or (2) that base does not implement the function and there is at most one mention of the function in all paths from the current contract to that base.
In this sense, an override path for a signature is a path through the inheritance graph that starts at the contract under consideration and ends at a contract mentioning a function with that signature that does not override.
If you do not mark a function that overrides as `virtual`, derived contracts can no longer change the behavior of that function.
Note
Functions with the `private` visibility cannot be `virtual`.
Note
Functions without implementation have to be marked `virtual` outside of interfaces. In interfaces, all functions are automatically considered `virtual`.
Note
Starting from Solidity 0.8.8, the `override` keyword is not required when overriding an interface function, except for the case where the function is defined in multiple bases.
Public state variables can override external functions if the parameter and return types of the function matches the getter function of the variable:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQQp7CiAgICBmdW5jdGlvbiBmKCkgZXh0ZXJuYWwgdmlldyB2aXJ0dWFsIHJldHVybnModWludCkgeyByZXR1cm4gNTsgfQp9Cgpjb250cmFjdCBCIGlzIEEKewogICAgdWludCBwdWJsaWMgb3ZlcnJpZGUgZjsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract A
{
 function f() external view virtual returns(uint) { return 5; }
}
contract B is A
{
 uint public override f;
}
Note
While public state variables can override external functions, they themselves cannot be overridden.
### Modifier Overriding[](#modifier-overriding "Link to this heading")
Function modifiers can override each other. This works in the same way as [function overriding](#function-overriding) (except that there is no overloading for modifiers). The `virtual` keyword must be used on the overridden modifier and the `override` keyword must be used in the overriding modifier:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZQp7CiAgICBtb2RpZmllciBmb28oKSB2aXJ0dWFsIHtfO30KfQoKY29udHJhY3QgSW5oZXJpdGVkIGlzIEJhc2UKewogICAgbW9kaWZpZXIgZm9vKCkgb3ZlcnJpZGUge187fQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract Base
{
 modifier foo() virtual {\_;}
}
contract Inherited is Base
{
 modifier foo() override {\_;}
}
In case of multiple inheritance, all direct base contracts must be specified explicitly:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEKewogICAgbW9kaWZpZXIgZm9vKCkgdmlydHVhbCB7Xzt9Cn0KCmNvbnRyYWN0IEJhc2UyCnsKICAgIG1vZGlmaWVyIGZvbygpIHZpcnR1YWwge187fQp9Cgpjb250cmFjdCBJbmhlcml0ZWQgaXMgQmFzZTEsIEJhc2UyCnsKICAgIG1vZGlmaWVyIGZvbygpIG92ZXJyaWRlKEJhc2UxLCBCYXNlMikge187fQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract Base1
{
 modifier foo() virtual {\_;}
}
contract Base2
{
 modifier foo() virtual {\_;}
}
contract Inherited is Base1, Base2
{
 modifier foo() override(Base1, Base2) {\_;}
}
### Constructors[](#constructors "Link to this heading")
A constructor is an optional function declared with the `constructor` keyword which is executed upon contract creation, and where you can run contract initialization code.
Before the constructor code is executed, state variables are initialised to their specified value if you initialise them inline, or their [default value](https://docs.soliditylang.org/en/latest/control-structures.html#default-value) if you do not.
After the constructor has run, the final code of the contract is deployed to the blockchain. The deployment of the code costs additional gas linear to the length of the code. This code includes all functions that are part of the public interface and all functions that are reachable from there through function calls. It does not include the constructor code or internal functions that are only called from the constructor.
If there is no constructor, the contract will assume the default constructor, which is equivalent to `constructor() {}`. For example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgQSB7CiAgICB1aW50IHB1YmxpYyBhOwoKICAgIGNvbnN0cnVjdG9yKHVpbnQgYV8pIHsKICAgICAgICBhID0gYV87CiAgICB9Cn0KCmNvbnRyYWN0IEIgaXMgQSgxKSB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
abstract contract A {
 uint public a;
 constructor(uint a\_) {
 a \= a\_;
 }
}
contract B is A(1) {
 constructor() {}
}
You can use internal parameters in a constructor (for example storage pointers). In this case, the contract has to be marked [abstract](#abstract-contract), because these parameters cannot be assigned valid values from outside but only through the constructors of derived contracts.
Warning
Prior to version 0.4.22, constructors were defined as functions with the same name as the contract. This syntax was deprecated and is not allowed anymore in version 0.5.0.
Warning
Prior to version 0.7.0, you had to specify the visibility of constructors as either `internal` or `public`.
### Arguments for Base Constructors[](#arguments-for-base-constructors "Link to this heading")
The constructors of all the base contracts will be called following the linearization rules explained below. If the base constructors have arguments, derived contracts need to specify all of them. This can be done in two ways:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZSB7CiAgICB1aW50IHg7CiAgICBjb25zdHJ1Y3Rvcih1aW50IHhfKSB7IHggPSB4XzsgfQp9CgovLyBFaXRoZXIgZGlyZWN0bHkgc3BlY2lmeSBpbiB0aGUgaW5oZXJpdGFuY2UgbGlzdC4uLgpjb250cmFjdCBEZXJpdmVkMSBpcyBCYXNlKDcpIHsKICAgIGNvbnN0cnVjdG9yKCkge30KfQoKLy8gb3IgdGhyb3VnaCBhICJtb2RpZmllciIgb2YgdGhlIGRlcml2ZWQgY29uc3RydWN0b3IuLi4KY29udHJhY3QgRGVyaXZlZDIgaXMgQmFzZSB7CiAgICBjb25zdHJ1Y3Rvcih1aW50IHkpIEJhc2UoeSAqIHkpIHt9Cn0KCi8vIG9yIGRlY2xhcmUgYWJzdHJhY3QuLi4KYWJzdHJhY3QgY29udHJhY3QgRGVyaXZlZDMgaXMgQmFzZSB7Cn0KCi8vIGFuZCBoYXZlIHRoZSBuZXh0IGNvbmNyZXRlIGRlcml2ZWQgY29udHJhY3QgaW5pdGlhbGl6ZSBpdC4KY29udHJhY3QgRGVyaXZlZEZyb21EZXJpdmVkIGlzIERlcml2ZWQzIHsKICAgIGNvbnN0cnVjdG9yKCkgQmFzZSgxMCArIDEwKSB7fQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Base {
 uint x;
 constructor(uint x\_) { x \= x\_; }
}
// Either directly specify in the inheritance list...
contract Derived1 is Base(7) {
 constructor() {}
}
// or through a "modifier" of the derived constructor...
contract Derived2 is Base {
 constructor(uint y) Base(y \* y) {}
}
// or declare abstract...
abstract contract Derived3 is Base {
}
// and have the next concrete derived contract initialize it.
contract DerivedFromDerived is Derived3 {
 constructor() Base(10 + 10) {}
}
One way is directly in the inheritance list (`is Base(7)`). The other is in the way a modifier is invoked as part of the derived constructor (`Base(y * y)`). The first way to do it is more convenient if the constructor argument is a constant and defines the behavior of the contract or describes it. The second way has to be used if the constructor arguments of the base depend on those of the derived contract. Arguments have to be given either in the inheritance list or in modifier-style in the derived constructor. Specifying arguments in both places is an error.
If a derived contract does not specify the arguments to all of its base contracts’ constructors, it must be declared abstract. In that case, when another contract derives from it, that other contract’s inheritance list or constructor must provide the necessary parameters for all base classes that haven’t had their parameters specified (otherwise, that other contract must be declared abstract as well). For example, in the above code snippet, see `Derived3` and `DerivedFromDerived`.
### Multiple Inheritance and Linearization[](#multiple-inheritance-and-linearization "Link to this heading")
Languages that allow multiple inheritance have to deal with several problems. One is the [Diamond Problem](https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem). Solidity is similar to Python in that it uses C3 Linearization to force a specific order in the directed acyclic graph (DAG) of base classes. This results in the desirable property of monotonicity but disallows some inheritance graphs. Especially, the order in which the base classes are given in the `is` directive is important: You have to list the direct base contracts in the order from “most base-like” to “most derived”. Note that this order is the reverse of the one used in Python.
Another simplifying way to explain this is that when a function is called that is defined multiple times in different contracts, the given bases are searched from right to left (left to right in Python) in a depth-first manner, stopping at the first match. If a base contract has already been searched, it is skipped.
In the following code, Solidity will give the error “Linearization of inheritance graph impossible”.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgWCB7fQpjb250cmFjdCBBIGlzIFgge30KLy8gVGhpcyB3aWxsIG5vdCBjb21waWxlCmNvbnRyYWN0IEMgaXMgQSwgWCB7fQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract X {}
contract A is X {}
// This will not compile
contract C is A, X {}
The reason for this is that `C` requests `X` to override `A` (by specifying `A, X` in this order), but `A` itself requests to override `X`, which is a contradiction that cannot be resolved.
Due to the fact that you have to explicitly override a function that is inherited from multiple bases without a unique override, C3 linearization is not too important in practice.
One area where inheritance linearization is especially important and perhaps not as clear is when there are multiple constructors in the inheritance hierarchy. The constructors will always be executed in the linearized order, regardless of the order in which their arguments are provided in the inheriting contract’s constructor. For example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEgewogICAgY29uc3RydWN0b3IoKSB7fQp9Cgpjb250cmFjdCBCYXNlMiB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0KCi8vIENvbnN0cnVjdG9ycyBhcmUgZXhlY3V0ZWQgaW4gdGhlIGZvbGxvd2luZyBvcmRlcjoKLy8gIDEgLSBCYXNlMQovLyAgMiAtIEJhc2UyCi8vICAzIC0gRGVyaXZlZDEKY29udHJhY3QgRGVyaXZlZDEgaXMgQmFzZTEsIEJhc2UyIHsKICAgIGNvbnN0cnVjdG9yKCkgQmFzZTEoKSBCYXNlMigpIHt9Cn0KCi8vIENvbnN0cnVjdG9ycyBhcmUgZXhlY3V0ZWQgaW4gdGhlIGZvbGxvd2luZyBvcmRlcjoKLy8gIDEgLSBCYXNlMgovLyAgMiAtIEJhc2UxCi8vICAzIC0gRGVyaXZlZDIKY29udHJhY3QgRGVyaXZlZDIgaXMgQmFzZTIsIEJhc2UxIHsKICAgIGNvbnN0cnVjdG9yKCkgQmFzZTIoKSBCYXNlMSgpIHt9Cn0KCi8vIENvbnN0cnVjdG9ycyBhcmUgc3RpbGwgZXhlY3V0ZWQgaW4gdGhlIGZvbGxvd2luZyBvcmRlcjoKLy8gIDEgLSBCYXNlMgovLyAgMiAtIEJhc2UxCi8vICAzIC0gRGVyaXZlZDMKY29udHJhY3QgRGVyaXZlZDMgaXMgQmFzZTIsIEJhc2UxIHsKICAgIGNvbnN0cnVjdG9yKCkgQmFzZTEoKSBCYXNlMigpIHt9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Base1 {
 constructor() {}
}
contract Base2 {
 constructor() {}
}
// Constructors are executed in the following order:
// 1 - Base1
// 2 - Base2
// 3 - Derived1
contract Derived1 is Base1, Base2 {
 constructor() Base1() Base2() {}
}
// Constructors are executed in the following order:
// 1 - Base2
// 2 - Base1
// 3 - Derived2
contract Derived2 is Base2, Base1 {
 constructor() Base2() Base1() {}
}
// Constructors are still executed in the following order:
// 1 - Base2
// 2 - Base1
// 3 - Derived3
contract Derived3 is Base2, Base1 {
 constructor() Base1() Base2() {}
}
### Inheriting Different Kinds of Members of the Same Name[](#inheriting-different-kinds-of-members-of-the-same-name "Link to this heading")
The only situations where, due to inheritance, a contract may contain multiple definitions sharing the same name are:
* Overloading of functions.
 
* Overriding of virtual functions.
 
* Overriding of external virtual functions by state variable getters.
 
* Overriding of virtual modifiers.
 
* Overloading of events.
 
## Abstract Contracts[](#abstract-contracts "Link to this heading")
Contracts must be marked as abstract when at least one of their functions is not implemented or when they do not provide arguments for all of their base contract constructors. Even if this is not the case, a contract may still be marked abstract, such as when you do not intend for the contract to be created directly. Abstract contracts are similar to [Interfaces](#interfaces) but an interface is more limited in what it can declare.
An abstract contract is declared using the `abstract` keyword as shown in the following example. Note that this contract needs to be defined as abstract, because the function `utterance()` is declared, but no implementation was provided (no implementation body `{ }` was given).
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgRmVsaW5lIHsKICAgIGZ1bmN0aW9uIHV0dGVyYW5jZSgpIHB1YmxpYyB2aXJ0dWFsIHJldHVybnMgKGJ5dGVzMzIpOwp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
abstract contract Feline {
 function utterance() public virtual returns (bytes32);
}
Such abstract contracts can not be instantiated directly. This is also true, if an abstract contract itself does implement all defined functions. The usage of an abstract contract as a base class is shown in the following example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgRmVsaW5lIHsKICAgIGZ1bmN0aW9uIHV0dGVyYW5jZSgpIHB1YmxpYyBwdXJlIHZpcnR1YWwgcmV0dXJucyAoYnl0ZXMzMik7Cn0KCmNvbnRyYWN0IENhdCBpcyBGZWxpbmUgewogICAgZnVuY3Rpb24gdXR0ZXJhbmNlKCkgcHVibGljIHB1cmUgb3ZlcnJpZGUgcmV0dXJucyAoYnl0ZXMzMikgeyByZXR1cm4gIm1pYW93IjsgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
abstract contract Feline {
 function utterance() public pure virtual returns (bytes32);
}
contract Cat is Feline {
 function utterance() public pure override returns (bytes32) { return "miaow"; }
}
If a contract inherits from an abstract contract and does not implement all non-implemented functions by overriding, it needs to be marked as abstract as well.
Note that a function without implementation is different from a [Function Type](https://docs.soliditylang.org/en/latest/types.html#function-types) even though their syntax looks very similar.
Example of function without implementation (a function declaration):
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=ZnVuY3Rpb24gZm9vKGFkZHJlc3MpIGV4dGVybmFsIHJldHVybnMgKGFkZHJlc3MpOw==)
function foo(address) external returns (address);
Example of a declaration of a variable whose type is a function type:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=ZnVuY3Rpb24oYWRkcmVzcykgZXh0ZXJuYWwgcmV0dXJucyAoYWRkcmVzcykgZm9vOw==)
function(address) external returns (address) foo;
Abstract contracts decouple the definition of a contract from its implementation providing better extensibility and self-documentation and facilitating patterns like the [Template method](https://en.wikipedia.org/wiki/Template_method_pattern) and removing code duplication. Abstract contracts are useful in the same way that defining methods in an interface is useful. It is a way for the designer of the abstract contract to say “any child of mine must implement this method”.
Note
Abstract contracts cannot override an implemented virtual function with an unimplemented one.
## Interfaces[](#interfaces "Link to this heading")
Interfaces are similar to abstract contracts, but they cannot have any functions implemented. There are further restrictions:
* They cannot inherit from other contracts, but they can inherit from other interfaces.
 
* All declared functions must be external in the interface, even if they are public in the contract.
 
* They cannot declare a constructor.
 
* They cannot declare state variables.
 
* They cannot declare modifiers.
 
Some of these restrictions might be lifted in the future.
Interfaces are basically limited to what the Contract ABI can represent, and the conversion between the ABI and an interface should be possible without any information loss.
Interfaces are denoted by their own keyword:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKaW50ZXJmYWNlIFRva2VuIHsKICAgIGVudW0gVG9rZW5UeXBlIHsgRnVuZ2libGUsIE5vbkZ1bmdpYmxlIH0KICAgIHN0cnVjdCBDb2luIHsgc3RyaW5nIG9idmVyc2U7IHN0cmluZyByZXZlcnNlOyB9CiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIHJlY2lwaWVudCwgdWludCBhbW91bnQpIGV4dGVybmFsOwp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.2 <0.9.0;
interface Token {
 enum TokenType { Fungible, NonFungible }
 struct Coin { string obverse; string reverse; }
 function transfer(address recipient, uint amount) external;
}
Contracts can inherit interfaces as they would inherit other contracts.
All functions declared in interfaces are implicitly `virtual` and any functions that override them do not need the `override` keyword. This does not automatically mean that an overriding function can be overridden again - this is only possible if the overriding function is marked `virtual`.
Interfaces can inherit from other interfaces. This has the same rules as normal inheritance.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKaW50ZXJmYWNlIFBhcmVudEEgewogICAgZnVuY3Rpb24gdGVzdCgpIGV4dGVybmFsIHJldHVybnMgKHVpbnQyNTYpOwp9CgppbnRlcmZhY2UgUGFyZW50QiB7CiAgICBmdW5jdGlvbiB0ZXN0KCkgZXh0ZXJuYWwgcmV0dXJucyAodWludDI1Nik7Cn0KCmludGVyZmFjZSBTdWJJbnRlcmZhY2UgaXMgUGFyZW50QSwgUGFyZW50QiB7CiAgICAvLyBNdXN0IHJlZGVmaW5lIHRlc3QgaW4gb3JkZXIgdG8gYXNzZXJ0IHRoYXQgdGhlIHBhcmVudAogICAgLy8gbWVhbmluZ3MgYXJlIGNvbXBhdGlibGUuCiAgICBmdW5jdGlvbiB0ZXN0KCkgZXh0ZXJuYWwgb3ZlcnJpZGUoUGFyZW50QSwgUGFyZW50QikgcmV0dXJucyAodWludDI1Nik7Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.2 <0.9.0;
interface ParentA {
 function test() external returns (uint256);
}
interface ParentB {
 function test() external returns (uint256);
}
interface SubInterface is ParentA, ParentB {
 // Must redefine test in order to assert that the parent
 // meanings are compatible.
 function test() external override(ParentA, ParentB) returns (uint256);
}
Types defined inside interfaces and other contract-like structures can be accessed from other contracts: `Token.TokenType` or `Token.Coin`.
Warning
Interfaces have supported `enum` types since [Solidity version 0.5.0](https://docs.soliditylang.org/en/latest/050-breaking-changes.html), make sure the pragma version specifies this version as a minimum.
## Libraries[](#libraries "Link to this heading")
Libraries are similar to contracts, but their purpose is that they are deployed only once at a specific address and their code is reused using the `DELEGATECALL` (`CALLCODE` until Homestead) feature of the EVM. This means that if library functions are called, their code is executed in the context of the calling contract, i.e. `this` points to the calling contract, and especially the storage from the calling contract can be accessed. As a library is an isolated piece of source code, it can only access state variables of the calling contract if they are explicitly supplied (it would have no way to name them, otherwise). Library functions can only be called directly (i.e. without the use of `DELEGATECALL`) if they do not modify the state (i.e. if they are `view` or `pure` functions), because libraries are assumed to be stateless. In particular, it is not possible to destroy a library.
Note
Until version 0.4.20, it was possible to destroy libraries by circumventing Solidity’s type system. Starting from that version, libraries contain a [mechanism](#call-protection) that disallows state-modifying functions to be called directly (i.e. without `DELEGATECALL`).
Libraries can be seen as implicit base contracts of the contracts that use them. They will not be explicitly visible in the inheritance hierarchy, but calls to library functions look just like calls to functions of explicit base contracts (using qualified access like `L.f()`). Of course, calls to internal functions use the internal calling convention, which means that all internal types can be passed and types [stored in memory](https://docs.soliditylang.org/en/latest/types.html#data-location) will be passed by reference and not copied. To realize this in the EVM, the code of internal library functions that are called from a contract and all functions called from therein will at compile time be included in the calling contract, and a regular `JUMP` call will be used instead of a `DELEGATECALL`.
Note
The inheritance analogy breaks down when it comes to public functions. Calling a public library function with `L.f()` results in an external call (`DELEGATECALL` to be precise). In contrast, `A.f()` is an internal call when `A` is a base contract of the current contract.
The following example illustrates how to use libraries (but using a manual method, be sure to check out [using for](#using-for) for a more advanced example to implement a set).
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKCi8vIFdlIGRlZmluZSBhIG5ldyBzdHJ1Y3QgZGF0YXR5cGUgdGhhdCB3aWxsIGJlIHVzZWQgdG8KLy8gaG9sZCBpdHMgZGF0YSBpbiB0aGUgY2FsbGluZyBjb250cmFjdC4Kc3RydWN0IERhdGEgewogICAgbWFwcGluZyh1aW50ID0+IGJvb2wpIGZsYWdzOwp9CgpsaWJyYXJ5IFNldCB7CiAgICAvLyBOb3RlIHRoYXQgdGhlIGZpcnN0IHBhcmFtZXRlciBpcyBvZiB0eXBlICJzdG9yYWdlCiAgICAvLyByZWZlcmVuY2UiIGFuZCB0aHVzIG9ubHkgaXRzIHN0b3JhZ2UgYWRkcmVzcyBhbmQgbm90CiAgICAvLyBpdHMgY29udGVudHMgaXMgcGFzc2VkIGFzIHBhcnQgb2YgdGhlIGNhbGwuICBUaGlzIGlzIGEKICAgIC8vIHNwZWNpYWwgZmVhdHVyZSBvZiBsaWJyYXJ5IGZ1bmN0aW9ucy4gIEl0IGlzIGlkaW9tYXRpYwogICAgLy8gdG8gY2FsbCB0aGUgZmlyc3QgcGFyYW1ldGVyIGBzZWxmYCwgaWYgdGhlIGZ1bmN0aW9uIGNhbgogICAgLy8gYmUgc2VlbiBhcyBhIG1ldGhvZCBvZiB0aGF0IG9iamVjdC4KICAgIGZ1bmN0aW9uIGluc2VydChEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgICAgICBwdWJsaWMKICAgICAgICByZXR1cm5zIChib29sKQogICAgewogICAgICAgIGlmIChzZWxmLmZsYWdzW3ZhbHVlXSkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBhbHJlYWR5IHRoZXJlCiAgICAgICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSB0cnVlOwogICAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICAgIGZ1bmN0aW9uIHJlbW92ZShEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgICAgICBwdWJsaWMKICAgICAgICByZXR1cm5zIChib29sKQogICAgewogICAgICAgIGlmICghc2VsZi5mbGFnc1t2YWx1ZV0pCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gbm90IHRoZXJlCiAgICAgICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSBmYWxzZTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBjb250YWlucyhEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgICAgICBwdWJsaWMKICAgICAgICB2aWV3CiAgICAgICAgcmV0dXJucyAoYm9vbCkKICAgIHsKICAgICAgICByZXR1cm4gc2VsZi5mbGFnc1t2YWx1ZV07CiAgICB9Cn0KCgpjb250cmFjdCBDIHsKICAgIERhdGEga25vd25WYWx1ZXM7CgogICAgZnVuY3Rpb24gcmVnaXN0ZXIodWludCB2YWx1ZSkgcHVibGljIHsKICAgICAgICAvLyBUaGUgbGlicmFyeSBmdW5jdGlvbnMgY2FuIGJlIGNhbGxlZCB3aXRob3V0IGEKICAgICAgICAvLyBzcGVjaWZpYyBpbnN0YW5jZSBvZiB0aGUgbGlicmFyeSwgc2luY2UgdGhlCiAgICAgICAgLy8gImluc3RhbmNlIiB3aWxsIGJlIHRoZSBjdXJyZW50IGNvbnRyYWN0LgogICAgICAgIHJlcXVpcmUoU2V0Lmluc2VydChrbm93blZhbHVlcywgdmFsdWUpKTsKICAgIH0KICAgIC8vIEluIHRoaXMgY29udHJhY3QsIHdlIGNhbiBhbHNvIGRpcmVjdGx5IGFjY2VzcyBrbm93blZhbHVlcy5mbGFncywgaWYgd2Ugd2FudC4KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
// We define a new struct datatype that will be used to
// hold its data in the calling contract.
struct Data {
 mapping(uint \=> bool) flags;
}
library Set {
 // Note that the first parameter is of type "storage
 // reference" and thus only its storage address and not
 // its contents is passed as part of the call. This is a
 // special feature of library functions. It is idiomatic
 // to call the first parameter \`self\`, if the function can
 // be seen as a method of that object.
 function insert(Data storage self, uint value)
 public
 returns (bool)
 {
 if (self.flags\[value\])
 return false; // already there
 self.flags\[value\] \= true;
 return true;
 }
 function remove(Data storage self, uint value)
 public
 returns (bool)
 {
 if (!self.flags\[value\])
 return false; // not there
 self.flags\[value\] \= false;
 return true;
 }
 function contains(Data storage self, uint value)
 public
 view
 returns (bool)
 {
 return self.flags\[value\];
 }
}
contract C {
 Data knownValues;
 function register(uint value) public {
 // The library functions can be called without a
 // specific instance of the library, since the
 // "instance" will be the current contract.
 require(Set.insert(knownValues, value));
 }
 // In this contract, we can also directly access knownValues.flags, if we want.
}
Of course, you do not have to follow this way to use libraries: they can also be used without defining struct data types. Functions also work without any storage reference parameters, and they can have multiple storage reference parameters and in any position.
The calls to `Set.contains`, `Set.insert` and `Set.remove` are all compiled as calls (`DELEGATECALL`) to an external contract/library. If you use libraries, be aware that an actual external function call is performed. `msg.sender`, `msg.value` and `this` will retain their values in this call, though (prior to Homestead, because of the use of `CALLCODE`, `msg.sender` and `msg.value` changed, though).
The following example shows how to use [types stored in memory](https://docs.soliditylang.org/en/latest/types.html#data-location) and internal functions in libraries in order to implement custom types without the overhead of external function calls:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMDsKCnN0cnVjdCBiaWdpbnQgewogICAgdWludFtdIGxpbWJzOwp9CgpsaWJyYXJ5IEJpZ0ludCB7CiAgICBmdW5jdGlvbiBmcm9tVWludCh1aW50IHgpIGludGVybmFsIHB1cmUgcmV0dXJucyAoYmlnaW50IG1lbW9yeSByKSB7CiAgICAgICAgci5saW1icyA9IG5ldyB1aW50W10oMSk7CiAgICAgICAgci5saW1ic1swXSA9IHg7CiAgICB9CgogICAgZnVuY3Rpb24gYWRkKGJpZ2ludCBtZW1vcnkgYSwgYmlnaW50IG1lbW9yeSBiKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKGJpZ2ludCBtZW1vcnkgcikgewogICAgICAgIHIubGltYnMgPSBuZXcgdWludFtdKG1heChhLmxpbWJzLmxlbmd0aCwgYi5saW1icy5sZW5ndGgpKTsKICAgICAgICB1aW50IGNhcnJ5ID0gMDsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCByLmxpbWJzLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICAgIHVpbnQgbGltYkEgPSBsaW1iKGEsIGkpOwogICAgICAgICAgICB1aW50IGxpbWJCID0gbGltYihiLCBpKTsKICAgICAgICAgICAgdW5jaGVja2VkIHsKICAgICAgICAgICAgICAgIHIubGltYnNbaV0gPSBsaW1iQSArIGxpbWJCICsgY2Fycnk7CgogICAgICAgICAgICAgICAgaWYgKGxpbWJBICsgbGltYkIgPCBsaW1iQSB8fCAobGltYkEgKyBsaW1iQiA9PSB0eXBlKHVpbnQpLm1heCAmJiBjYXJyeSA+IDApKQogICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gMTsKICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICBjYXJyeSA9IDA7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKGNhcnJ5ID4gMCkgewogICAgICAgICAgICAvLyB0b28gYmFkLCB3ZSBoYXZlIHRvIGFkZCBhIGxpbWIKICAgICAgICAgICAgdWludFtdIG1lbW9yeSBuZXdMaW1icyA9IG5ldyB1aW50W10oci5saW1icy5sZW5ndGggKyAxKTsKICAgICAgICAgICAgdWludCBpOwogICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgci5saW1icy5sZW5ndGg7ICsraSkKICAgICAgICAgICAgICAgIG5ld0xpbWJzW2ldID0gci5saW1ic1tpXTsKICAgICAgICAgICAgbmV3TGltYnNbaV0gPSBjYXJyeTsKICAgICAgICAgICAgci5saW1icyA9IG5ld0xpbWJzOwogICAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiBsaW1iKGJpZ2ludCBtZW1vcnkgYSwgdWludCBpbmRleCkgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGluZGV4IDwgYS5saW1icy5sZW5ndGggPyBhLmxpbWJzW2luZGV4XSA6IDA7CiAgICB9CgogICAgZnVuY3Rpb24gbWF4KHVpbnQgYSwgdWludCBiKSBwcml2YXRlIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBhID4gYiA/IGEgOiBiOwogICAgfQp9Cgpjb250cmFjdCBDIHsKICAgIHVzaW5nIEJpZ0ludCBmb3IgYmlnaW50OwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgcHVyZSB7CiAgICAgICAgYmlnaW50IG1lbW9yeSB4ID0gQmlnSW50LmZyb21VaW50KDcpOwogICAgICAgIGJpZ2ludCBtZW1vcnkgeSA9IEJpZ0ludC5mcm9tVWludCh0eXBlKHVpbnQpLm1heCk7CiAgICAgICAgYmlnaW50IG1lbW9yeSB6ID0geC5hZGQoeSk7CiAgICAgICAgYXNzZXJ0KHoubGltYigxKSA+IDApOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;
struct bigint {
 uint\[\] limbs;
}
library BigInt {
 function fromUint(uint x) internal pure returns (bigint memory r) {
 r.limbs \= new uint\[\](1);
 r.limbs\[0\] \= x;
 }
 function add(bigint memory a, bigint memory b) internal pure returns (bigint memory r) {
 r.limbs \= new uint\[\](max(a.limbs.length, b.limbs.length));
 uint carry \= 0;
 for (uint i \= 0; i < r.limbs.length; ++i) {
 uint limbA \= limb(a, i);
 uint limbB \= limb(b, i);
 unchecked {
 r.limbs\[i\] \= limbA + limbB + carry;
 if (limbA + limbB < limbA || (limbA + limbB \== type(uint).max && carry \> 0))
 carry \= 1;
 else
 carry \= 0;
 }
 }
 if (carry \> 0) {
 // too bad, we have to add a limb
 uint\[\] memory newLimbs \= new uint\[\](r.limbs.length + 1);
 uint i;
 for (i \= 0; i < r.limbs.length; ++i)
 newLimbs\[i\] \= r.limbs\[i\];
 newLimbs\[i\] \= carry;
 r.limbs \= newLimbs;
 }
 }
 function limb(bigint memory a, uint index) internal pure returns (uint) {
 return index < a.limbs.length ? a.limbs\[index\] : 0;
 }
 function max(uint a, uint b) private pure returns (uint) {
 return a \> b ? a : b;
 }
}
contract C {
 using BigInt for bigint;
 function f() public pure {
 bigint memory x \= BigInt.fromUint(7);
 bigint memory y \= BigInt.fromUint(type(uint).max);
 bigint memory z \= x.add(y);
 assert(z.limb(1) \> 0);
 }
}
It is possible to obtain the address of a library by converting the library type to the `address` type, i.e. using `address(LibraryName)`.
As the compiler does not know the address where the library will be deployed, the compiled hex code will contain placeholders of the form `__$30bbc0abd4d6364515865950d3e0d10953$__` [(format was different <v0.5.0)](https://docs.soliditylang.org/en/v0.4.26/contracts.html#libraries). The placeholder is a 34 character prefix of the hex encoding of the keccak256 hash of the fully qualified library name, which would be for example `libraries/bigint.sol:BigInt` if the library was stored in a file called `bigint.sol` in a `libraries/` directory. Such bytecode is incomplete and should not be deployed. Placeholders need to be replaced with actual addresses. You can do that by either passing them to the compiler when the library is being compiled or by using the linker to update an already compiled binary. See [Library Linking](https://docs.soliditylang.org/en/latest/using-the-compiler.html#library-linking) for information on how to use the commandline compiler for linking.
In comparison to contracts, libraries are restricted in the following ways:
* they cannot have state variables
 
* they cannot inherit nor be inherited
 
* they cannot receive Ether
 
* they cannot be destroyed
 
(These might be lifted at a later point.)
### Function Signatures and Selectors in Libraries[](#function-signatures-and-selectors-in-libraries "Link to this heading")
While external calls to public or external library functions are possible, the calling convention for such calls is considered to be internal to Solidity and not the same as specified for the regular [contract ABI](https://docs.soliditylang.org/en/latest/abi-spec.html#abi). External library functions support more argument types than external contract functions, for example recursive structs and storage pointers. For that reason, the function signatures used to compute the 4-byte selector are computed following an internal naming schema and arguments of types not supported in the contract ABI use an internal encoding.
The following identifiers are used for the types in the signatures:
* Value types, non-storage `string` and non-storage `bytes` use the same identifiers as in the contract ABI.
 
* Non-storage array types follow the same convention as in the contract ABI, i.e. `<type>[]` for dynamic arrays and `<type>[M]` for fixed-size arrays of `M` elements.
 
* Non-storage structs are referred to by their fully qualified name, i.e. `C.S` for `contract C { struct S { ... } }`.
 
* Storage pointer mappings use `mapping(<keyType> => <valueType>) storage` where `<keyType>` and `<valueType>` are the identifiers for the key and value types of the mapping, respectively.
 
* Other storage pointer types use the type identifier of their corresponding non-storage type, but append a single space followed by `storage` to it.
 
The argument encoding is the same as for the regular contract ABI, except for storage pointers, which are encoded as a `uint256` value referring to the storage slot to which they point.
Similarly to the contract ABI, the selector consists of the first four bytes of the Keccak256-hash of the signature. Its value can be obtained from Solidity using the `.selector` member as follows:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjE0IDwwLjkuMDsKCmxpYnJhcnkgTCB7CiAgICBmdW5jdGlvbiBmKHVpbnQyNTYpIGV4dGVybmFsIHt9Cn0KCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZygpIHB1YmxpYyBwdXJlIHJldHVybnMgKGJ5dGVzNCkgewogICAgICAgIHJldHVybiBMLmYuc2VsZWN0b3I7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.14 <0.9.0;
library L {
 function f(uint256) external {}
}
contract C {
 function g() public pure returns (bytes4) {
 return L.f.selector;
 }
}
### Call Protection For Libraries[](#call-protection-for-libraries "Link to this heading")
As mentioned in the introduction, if a library’s code is executed using a `CALL` instead of a `DELEGATECALL` or `CALLCODE`, it will revert unless a `view` or `pure` function is called.
The EVM does not provide a direct way for a contract to detect whether it was called using `CALL` or not, but a contract can use the `ADDRESS` opcode to find out “where” it is currently running. The generated code compares this address to the address used at construction time to determine the mode of calling.
More specifically, the runtime code of a library always starts with a push instruction, which is a zero of 20 bytes at compilation time. When the deploy code runs, this constant is replaced in memory by the current address and this modified code is stored in the contract. At runtime, this causes the deploy time address to be the first constant to be pushed onto the stack and the dispatcher code compares the current address against this constant for any non-view and non-pure function.
This means that the actual code stored on chain for a library is different from the code reported by the compiler as `deployedBytecode`.
## Using For[](#using-for "Link to this heading")
The directive `using A for B` can be used to attach functions (`A`) as operators to user-defined value types or as member functions to any type (`B`). The member functions receive the object they are called on as their first parameter (like the `self` variable in Python). The operator functions receive operands as parameters.
It is valid either at file level or inside a contract, at contract level.
The first part, `A`, can be one of:
* A list of functions, optionally with an operator name assigned (e.g. `using {f, g as +, h, L.t} for uint`). If no operator is specified, the function can be either a library function or a free function and is attached to the type as a member function. Otherwise it must be a free function and it becomes the definition of that operator on the type.
 
* The name of a library (e.g. `using L for uint`) - all non-private functions of the library are attached to the type as member functions
 
At file level, the second part, `B`, has to be an explicit type (without data location specifier). Inside contracts, you can also use `*` in place of the type (e.g. `using L for *;`), which has the effect that all functions of the library `L` are attached to _all_ types.
If you specify a library, _all_ non-private functions in the library get attached, even those where the type of the first parameter does not match the type of the object. The type is checked at the point the function is called and function overload resolution is performed.
If you use a list of functions (e.g. `using {f, g, h, L.t} for uint`), then the type (`uint`) has to be implicitly convertible to the first parameter of each of these functions. This check is performed even if none of these functions are called. Note that private library functions can only be specified when `using for` is inside a library.
If you define an operator (e.g. `using {f as +} for T`), then the type (`T`) must be a [user-defined value type](https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types) and the definition must be a `pure` function. Operator definitions must be global. The following operators can be defined this way:
Category
Operator
Possible signatures
Bitwise
`&`
`function (T, T) pure returns (T)`
`|`
`function (T, T) pure returns (T)`
`^`
`function (T, T) pure returns (T)`
`~`
`function (T) pure returns (T)`
Arithmetic
`+`
`function (T, T) pure returns (T)`
`-`
`function (T, T) pure returns (T)`
`function (T) pure returns (T)`
`*`
`function (T, T) pure returns (T)`
`/`
`function (T, T) pure returns (T)`
`%`
`function (T, T) pure returns (T)`
Comparison
`==`
`function (T, T) pure returns (bool)`
`!=`
`function (T, T) pure returns (bool)`
`<`
`function (T, T) pure returns (bool)`
`<=`
`function (T, T) pure returns (bool)`
`>`
`function (T, T) pure returns (bool)`
`>=`
`function (T, T) pure returns (bool)`
Note that unary and binary `-` need separate definitions. The compiler will choose the right definition based on how the operator is invoked.
The `using A for B;` directive is active only within the current scope (either the contract or the current module/source unit), including within all of its functions, and has no effect outside of the contract or module in which it is used.
When the directive is used at file level and applied to a user-defined type which was defined at file level in the same file, the word `global` can be added at the end. This will have the effect that the functions and operators are attached to the type everywhere the type is available (including other files), not only in the scope of the using statement.
Let us rewrite the set example from the [Libraries](#libraries) section in this way, using file-level functions instead of library functions.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTM7CgpzdHJ1Y3QgRGF0YSB7IG1hcHBpbmcodWludCA9PiBib29sKSBmbGFnczsgfQovLyBOb3cgd2UgYXR0YWNoIGZ1bmN0aW9ucyB0byB0aGUgdHlwZS4KLy8gVGhlIGF0dGFjaGVkIGZ1bmN0aW9ucyBjYW4gYmUgdXNlZCB0aHJvdWdob3V0IHRoZSByZXN0IG9mIHRoZSBtb2R1bGUuCi8vIElmIHlvdSBpbXBvcnQgdGhlIG1vZHVsZSwgeW91IGhhdmUgdG8KLy8gcmVwZWF0IHRoZSB1c2luZyBkaXJlY3RpdmUgdGhlcmUsIGZvciBleGFtcGxlIGFzCi8vICAgaW1wb3J0ICJmbGFncy5zb2wiIGFzIEZsYWdzOwovLyAgIHVzaW5nIHtGbGFncy5pbnNlcnQsIEZsYWdzLnJlbW92ZSwgRmxhZ3MuY29udGFpbnN9Ci8vICAgICBmb3IgRmxhZ3MuRGF0YTsKdXNpbmcge2luc2VydCwgcmVtb3ZlLCBjb250YWluc30gZm9yIERhdGE7CgpmdW5jdGlvbiBpbnNlcnQoRGF0YSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICByZXR1cm5zIChib29sKQp7CiAgICBpZiAoc2VsZi5mbGFnc1t2YWx1ZV0pCiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBhbHJlYWR5IHRoZXJlCiAgICBzZWxmLmZsYWdzW3ZhbHVlXSA9IHRydWU7CiAgICByZXR1cm4gdHJ1ZTsKfQoKZnVuY3Rpb24gcmVtb3ZlKERhdGEgc3RvcmFnZSBzZWxmLCB1aW50IHZhbHVlKQogICAgcmV0dXJucyAoYm9vbCkKewogICAgaWYgKCFzZWxmLmZsYWdzW3ZhbHVlXSkKICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG5vdCB0aGVyZQogICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSBmYWxzZTsKICAgIHJldHVybiB0cnVlOwp9CgpmdW5jdGlvbiBjb250YWlucyhEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgIHZpZXcKICAgIHJldHVybnMgKGJvb2wpCnsKICAgIHJldHVybiBzZWxmLmZsYWdzW3ZhbHVlXTsKfQoKCmNvbnRyYWN0IEMgewogICAgRGF0YSBrbm93blZhbHVlczsKCiAgICBmdW5jdGlvbiByZWdpc3Rlcih1aW50IHZhbHVlKSBwdWJsaWMgewogICAgICAgIC8vIEhlcmUsIGFsbCB2YXJpYWJsZXMgb2YgdHlwZSBEYXRhIGhhdmUKICAgICAgICAvLyBjb3JyZXNwb25kaW5nIG1lbWJlciBmdW5jdGlvbnMuCiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBmdW5jdGlvbiBjYWxsIGlzIGlkZW50aWNhbCB0bwogICAgICAgIC8vIGBTZXQuaW5zZXJ0KGtub3duVmFsdWVzLCB2YWx1ZSlgCiAgICAgICAgcmVxdWlyZShrbm93blZhbHVlcy5pbnNlcnQodmFsdWUpKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.13;
struct Data { mapping(uint \=> bool) flags; }
// Now we attach functions to the type.
// The attached functions can be used throughout the rest of the module.
// If you import the module, you have to
// repeat the using directive there, for example as
// import "flags.sol" as Flags;
// using {Flags.insert, Flags.remove, Flags.contains}
// for Flags.Data;
using {insert, remove, contains} for Data;
function insert(Data storage self, uint value)
 returns (bool)
{
 if (self.flags\[value\])
 return false; // already there
 self.flags\[value\] \= true;
 return true;
}
function remove(Data storage self, uint value)
 returns (bool)
{
 if (!self.flags\[value\])
 return false; // not there
 self.flags\[value\] \= false;
 return true;
}
function contains(Data storage self, uint value)
 view
 returns (bool)
{
 return self.flags\[value\];
}
contract C {
 Data knownValues;
 function register(uint value) public {
 // Here, all variables of type Data have
 // corresponding member functions.
 // The following function call is identical to
 // \`Set.insert(knownValues, value)\`
 require(knownValues.insert(value));
 }
}
It is also possible to extend built-in types in that way. In this example, we will use a library.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTM7CgpsaWJyYXJ5IFNlYXJjaCB7CiAgICBmdW5jdGlvbiBpbmRleE9mKHVpbnRbXSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICAgICAgcHVibGljCiAgICAgICAgdmlldwogICAgICAgIHJldHVybnMgKHVpbnQpCiAgICB7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykKICAgICAgICAgICAgaWYgKHNlbGZbaV0gPT0gdmFsdWUpIHJldHVybiBpOwogICAgICAgIHJldHVybiB0eXBlKHVpbnQpLm1heDsKICAgIH0KfQp1c2luZyBTZWFyY2ggZm9yIHVpbnRbXTsKCmNvbnRyYWN0IEMgewogICAgdWludFtdIGRhdGE7CgogICAgZnVuY3Rpb24gYXBwZW5kKHVpbnQgdmFsdWUpIHB1YmxpYyB7CiAgICAgICAgZGF0YS5wdXNoKHZhbHVlKTsKICAgIH0KCiAgICBmdW5jdGlvbiByZXBsYWNlKHVpbnQgZnJvbSwgdWludCB0bykgcHVibGljIHsKICAgICAgICAvLyBUaGlzIHBlcmZvcm1zIHRoZSBsaWJyYXJ5IGZ1bmN0aW9uIGNhbGwKICAgICAgICB1aW50IGluZGV4ID0gZGF0YS5pbmRleE9mKGZyb20pOwogICAgICAgIGlmIChpbmRleCA9PSB0eXBlKHVpbnQpLm1heCkKICAgICAgICAgICAgZGF0YS5wdXNoKHRvKTsKICAgICAgICBlbHNlCiAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gdG87CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.13;
library Search {
 function indexOf(uint\[\] storage self, uint value)
 public
 view
 returns (uint)
 {
 for (uint i \= 0; i < self.length; i++)
 if (self\[i\] \== value) return i;
 return type(uint).max;
 }
}
using Search for uint\[\];
contract C {
 uint\[\] data;
 function append(uint value) public {
 data.push(value);
 }
 function replace(uint from, uint to) public {
 // This performs the library function call
 uint index \= data.indexOf(from);
 if (index \== type(uint).max)
 data.push(to);
 else
 data\[index\] \= to;
 }
}
Note that all external library calls are actual EVM function calls. This means that if you pass memory or value types, a copy will be performed, even in case of the `self` variable. The only situation where no copy will be performed is when storage reference variables are used or when internal library functions are called.
Another example shows how to define a custom operator for a user-defined type:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTk7Cgp0eXBlIFVGaXhlZDE2eDIgaXMgdWludDE2OwoKdXNpbmcgewogICAgYWRkIGFzICssCiAgICBkaXYgYXMgLwp9IGZvciBVRml4ZWQxNngyIGdsb2JhbDsKCnVpbnQzMiBjb25zdGFudCBTQ0FMRSA9IDEwMDsKCmZ1bmN0aW9uIGFkZChVRml4ZWQxNngyIGEsIFVGaXhlZDE2eDIgYikgcHVyZSByZXR1cm5zIChVRml4ZWQxNngyKSB7CiAgICByZXR1cm4gVUZpeGVkMTZ4Mi53cmFwKFVGaXhlZDE2eDIudW53cmFwKGEpICsgVUZpeGVkMTZ4Mi51bndyYXAoYikpOwp9CgpmdW5jdGlvbiBkaXYoVUZpeGVkMTZ4MiBhLCBVRml4ZWQxNngyIGIpIHB1cmUgcmV0dXJucyAoVUZpeGVkMTZ4MikgewogICAgdWludDMyIGEzMiA9IFVGaXhlZDE2eDIudW53cmFwKGEpOwogICAgdWludDMyIGIzMiA9IFVGaXhlZDE2eDIudW53cmFwKGIpOwogICAgdWludDMyIHJlc3VsdDMyID0gYTMyICogU0NBTEUgLyBiMzI7CiAgICByZXF1aXJlKHJlc3VsdDMyIDw9IHR5cGUodWludDE2KS5tYXgsICJEaXZpZGUgb3ZlcmZsb3ciKTsKICAgIHJldHVybiBVRml4ZWQxNngyLndyYXAodWludDE2KGEzMiAqIFNDQUxFIC8gYjMyKSk7Cn0KCmNvbnRyYWN0IE1hdGggewogICAgZnVuY3Rpb24gYXZnKFVGaXhlZDE2eDIgYSwgVUZpeGVkMTZ4MiBiKSBwdWJsaWMgcHVyZSByZXR1cm5zIChVRml4ZWQxNngyKSB7CiAgICAgICAgcmV0dXJuIChhICsgYikgLyBVRml4ZWQxNngyLndyYXAoMjAwKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.19;
type UFixed16x2 is uint16;
using {
 add as +,
 div as /
} for UFixed16x2 global;
uint32 constant SCALE \= 100;
function add(UFixed16x2 a, UFixed16x2 b) pure returns (UFixed16x2) {
 return UFixed16x2.wrap(UFixed16x2.unwrap(a) + UFixed16x2.unwrap(b));
}
function div(UFixed16x2 a, UFixed16x2 b) pure returns (UFixed16x2) {
 uint32 a32 \= UFixed16x2.unwrap(a);
 uint32 b32 \= UFixed16x2.unwrap(b);
 uint32 result32 \= a32 \* SCALE / b32;
 require(result32 <= type(uint16).max, "Divide overflow");
 return UFixed16x2.wrap(uint16(a32 \* SCALE / b32));
}
contract Math {
 function avg(UFixed16x2 a, UFixed16x2 b) public pure returns (UFixed16x2) {
 return (a + b) / UFixed16x2.wrap(200);
 }
}

# [单位和全局可用变量 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html) 
 _https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html_

## 单位和全局可用变量[](#index-0 "此标题的永久链接")
## 以太坊（Ether） 单位[](#ether "此标题的永久链接")
一个字面常量可以带一个后缀 `wei`， `gwei` 或 `ether` 来指定一个以太币的数量， 其中没有后缀的以太数字被认为单位是wei。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=YXNzZXJ0KDEgd2VpID09IDEpOwphc3NlcnQoMSBnd2VpID09IDFlOSk7CmFzc2VydCgxIGV0aGVyID09IDFlMTgpOw==)
assert(1 wei \== 1);
assert(1 gwei \== 1e9);
assert(1 ether \== 1e18);
单位后缀的唯一作用是乘以10的幂次方。
备注
0.7.0 版本中删除了 `finney` 和 `szabo` 这两个单位。
## 时间单位[](#index-2 "此标题的永久链接")
诸如 `seconds`， `minutes`， `hours`， `days` 和 `weeks` 等 后缀在字面常量后面，可以用来指定时间单位，其中秒是基本单位，单位的考虑方式很直白：
* `1 == 1 seconds`
 
* `1 minutes == 60 seconds`
 
* `1 hours == 60 minutes`
 
* `1 days == 24 hours`
 
* `1 weeks == 7 days`
 
如果您使用这些单位进行日历计算，请注意，由于 [闰秒](https://en.wikipedia.org/wiki/Leap_second) 会造成不是每一年都等于365天，甚至不是每一天都有24小时，而且因为闰秒是无法预测的， 所以需要借助外部的预言机（oracle，是一种链外数据服务，译者注）来对一个确定的日期代码库进行时间矫正。
备注
由于上述原因，在 0.5.0 版本中删除了后缀 `years`。
这些后缀单位不能应用于变量。例如， 如果您想用时间单位（例如 days）来将输入变量换算为时间，您可以用以下方式：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=ZnVuY3Rpb24gZih1aW50IHN0YXJ0LCB1aW50IGRheXNBZnRlcikgcHVibGljIHsKICAgIGlmIChibG9jay50aW1lc3RhbXAgPj0gc3RhcnQgKyBkYXlzQWZ0ZXIgKiAxIGRheXMpIHsKICAgICAgICAvLyAuLi4KICAgIH0KfQ==)
function f(uint start, uint daysAfter) public {
 if (block.timestamp \>= start + daysAfter \* 1 days) {
 // ...
 }
}
## 特殊变量和函数[](#special-variables-functions "此标题的永久链接")
有一些特殊的变量和函数总是存在于全局命名空间，主要用于提供区块链的信息，或者是通用的工具函数。
### 区块和交易属性[](#index-3 "此标题的永久链接")
* `blockhash(uint blockNumber) returns (bytes32)`： 给定区块的哈希值 - 只对最近的256个区块有效
 
* `blobhash(uint index) returns (bytes32)`： 与当前交易相关联的第 `index` 个blob。 此带版本的哈希值是由一个表示版本的单字节（当前为 `0x01` ）和紧随其后的KZG证明的SHA256哈希的最后31个字节组成。 （ [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844) ）。
 
* `block.basefee` (`uint`)： 当前区块的基本费用 （ [EIP-3198](https://eips.ethereum.org/EIPS/eip-3198) 和 [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) ）
 
* `block.blobbasefee` (`uint`): 当前区块的blob基础费用（ [EIP-7516](https://eips.ethereum.org/EIPS/eip-7516) 和 [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844)）
 
* `block.chainid` (`uint`)： 当前链的ID
 
* `block.coinbase` (`address payable`)： 当前区块矿工的地址
 
* `block.difficulty` (`uint`)： 当前区块的难度值（ `EVM < Paris` ）。对于其他EVM版本，它是 `block.prevrandao` 的一个废弃的别名，将在下一个重大改变版本中被删除。
 
* `block.gaslimit` (`uint`)： 当前区块的燃料上限
 
* `block.number` (`uint`)： 当前区块的区块号
 
* `block.prevrandao` (`uint`)： 由信标链提供的随机数（ `EVM >= Paris` ）（见 [EIP-4399](https://eips.ethereum.org/EIPS/eip-4399) ）。
 
* `block.timestamp` (`uint`)： 当前区块的时间戳，自Unix epoch以来的秒数
 
* `gasleft() returns (uint256)`： 剩余燃料
 
* `msg.data` (`bytes`)： 完整的调用数据
 
* `msg.sender` (`address`)： 消息发送方（当前调用）
 
* `msg.sig` (`bytes4`)： 调用数据的前四个字节（即函数标识符）。
 
* `msg.value` (`uint`)： 随消息发送的 wei 的数量
 
* `tx.gasprice` (`uint`)： 交易的燃料价格
 
* `tx.origin` (`address`)： 交易发送方（完整调用链上的原始发送方）
 
备注
对于每一个 **外部（external）** 函数调用， 包括 `msg.sender` 和 `msg.value` 在内所有 `msg` 成员的值都会变化。 这里包括对库函数的调用。
备注
当合约在链下而不是在区块中包含的交易的背景下计算时， 您不应该认为 `block.*` 和 `tx.*` 是指任何特定区块或交易的值。 这些值是由执行合约的EVM实现提供的，可以是任意的。
备注
不要依赖 `block.timestamp` 和 `blockhash` 产生随机数，除非您知道自己在做什么。
时间戳和区块哈希在一定程度上都可能受到挖矿矿工影响。 例如，挖矿社区中的恶意矿工可以用某个给定的哈希来运行赌场合约的支付函数， 而如果他们没收到任何奖励，例如以太币，还可以用一个不同的哈希重新尝试。
当前区块的时间戳必须严格大于最后一个区块的时间戳， 但这里唯一能确保的只是它会是在权威链上的两个连续区块的时间戳之间的数值。
备注
基于可扩展因素，区块哈希不是对所有区块都有效。 您仅仅可以访问最近 256 个区块的哈希，其余的哈希均为零。
备注
函数 `blockhash` 以前被称为 `block.blockhash`， 在 0.4.22 版本中被废弃，在 0.5.0 版本中被删除。
备注
函数 `gasleft` 的前身是 `msg.gas`， 在 0.4.21 版本中被弃用，在 0.5.0 版本中被删除。
备注
在 0.7.0 版本中，删除了别名 `now` （用于 `block.timestamp`）。
### ABI编码和解码函数[](#abi "此标题的永久链接")
* `abi.decode(bytes memory encodedData, (...)) returns (...)`: ABI-解码给定的数据，而类型在括号中作为第二个参数给出。例如： `(uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))`
 
* `abi.encode(...) returns (bytes memory)`： 对给定的参数进行ABI编码
 
* `abi.encodePacked(...) returns (bytes memory)`： 对给定参数执行 [紧打包编码](https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi-packed-mode)。 请注意，打包编码可能会有歧义!
 
* `abi.encodeWithSelector(bytes4 selector, ...) returns (bytes memory)`： ABI-对给定参数进行编码，并以给定的函数选择器作为起始的4字节数据一起返回
 
* `abi.encodeWithSignature(string memory signature, ...) returns (bytes memory)`： 相当于 `abi.encodeWithSelector(bytes4(keccak256(bytes(signature))), ...)`
 
* `abi.encodeCall(function functionPointer, (...)) returns (bytes memory)`： 对 `函数指针` 的调用进行ABI编码，参数在元组中找到。执行全面的类型检查，确保类型与函数签名相符。结果相当于 `abi.encodeWithSelector(functionPointer.selector, (...))`。
 
备注
这些编码函数可用于制作外部函数调用的数据，而无需实际调用外部函数。 此外， `keccak256(abi.encodePacked(a, b))` 是一种计算结构化数据的哈希值的方法 （但是要注意有可能使用不同的函数参数类型会制作出一个 “哈希碰撞”）。
更多详情请参考 [ABI](https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi) 和 [紧打包编码](https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi-packed-mode)。
### 字节类型的成员[](#index-5 "此标题的永久链接")
* `bytes.concat(...) returns (bytes memory)`: [将可变数量的字节和byte1, …, byte32参数串联成一个字节数组](https://docs.soliditylang.org/zh-cn/latest/types.html#bytes-concat)
 
### 字符串的成员[](#index-6 "此标题的永久链接")
* `string.concat(...) returns (string memory)`: [将可变数量的字符串参数串联成一个字符串数组](https://docs.soliditylang.org/zh-cn/latest/types.html#string-concat)
 
### 错误处理[](#index-7 "此标题的永久链接")
关于错误处理和何时使用哪个函数的更多细节， 请参见 [assert 和 require](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#assert-and-require) 的专门章节。
`assert(bool condition)`
如果条件不满足，会导致异常，因此，状态变化会被恢复 - 用于内部错误。
`require(bool condition)`
如果条件不满足，则恢复状态更改 - 用于输入或外部组件的错误。
`require(bool condition, string memory message)`
如果条件不满足，则恢复状态更改 - 用于输入或外部组件的错误，可以同时提供一个错误消息。
`revert()`
终止运行并恢复状态更改。
`revert(string memory reason)`
终止运行并恢复状态更改，可以同时提供一个解释性的字符串。
### 数学和密码学函数[](#mathematical-and-cryptographic-functions "此标题的永久链接")
`addmod(uint x, uint y, uint k) returns (uint)`
计算 `(x + y) % k`，加法会在任意精度下执行，并且加法的结果即使超过 `2**256` 也不会被截取。从 0.5.0 版本的编译器开始会加入对 `k != 0` 的校验（assert）。
`mulmod(uint x, uint y, uint k) returns (uint)`
计算 `(x * y) % k`，乘法会在任意精度下执行，并且乘法的结果即使超过 `2**256` 也不会被截取。从 0.5.0 版本的编译器开始会加入对 `k != 0` 的校验（assert）。
`keccak256(bytes memory) returns (bytes32)`
计算输入的 Keccak-256 哈希值。
备注
以前 `keccak256` 的别名叫 `sha3` ，在 0.5.0 版本中被删除。
`sha256(bytes memory) returns (bytes32)`
计算输入的 SHA-256 哈希值。
`ripemd160(bytes memory) returns (bytes20)`
计算输入的 RIPEMD-160 哈希值。
`ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)`
利用椭圆曲线签名恢复与公钥相关的地址，错误返回零值。 函数参数对应于签名的 ECDSA 值：
* `r` = 签名的前32字节
 
* `s` = 签名的第二个32字节
 
* `v` = 签名的最后1个字节
 
`ecrecover` 返回一个 `address`，而不是 `address payable`。 参见 [地址类型](https://docs.soliditylang.org/zh-cn/latest/types.html#address) 进行转换，以备您需要向恢复的地址转移资金。
更多细节，请阅读 [使用示例](https://ethereum.stackexchange.com/questions/1777/workflow-on-signing-a-string-with-private-key-followed-by-signature-verificatio).
警告
如果您使用 `ecrecover`，请注意，一个有效的签名可以变成另一个有效的签名，而不需要知道相应的私钥。 在 Homestead 硬分叉中，这个问题对 \_transaction\_ 签名进行了修复 （见 [EIP-2](https://eips.ethereum.org/EIPS/eip-2#specification)）， 但 ecrecover 函数仍然没有改变。
这通常不是一个问题，除非您要求签名是唯一的，或者用它们来识别个体。 OpenZeppelin 有一个 [ECDSA 辅助库](https://docs.openzeppelin.com/contracts/4.x/api/utils#ECDSA)， 您可以用它作为 `ecrecover` 的包装，那样就没有这个问题。
备注
当在 _私有区块链_ 上运行 `sha256`， `ripemd160` 或 `ecrecover` 时，您可能会遇到燃料耗尽（Out-of-Gas）的错误。这是因为这些功能是作为 “预编译合约” 实现的，只有在它们收到第一个消息后才真正存在（尽管它们的合约代码是硬编码的）。向不存在的合约发送消息的成本较高，因此执行时可能会遇到 Out-of-Gas 错误。这个问题的一个变通方法是，在您的实际合约中使用它们之前，先向每个合约发送 Wei（例如1）。这在主网和测试网上都没有问题。
### 合约相关[](#index-10 "此标题的永久链接")
`this` （当前合约类型）
当前合约，可以显式转换为 [地址类型](https://docs.soliditylang.org/zh-cn/latest/types.html#address)
`super`
继承层次结构中上一级的合约
`selfdestruct(address payable recipient)`
销毁当前合约，将其资金发送到给定的 [地址类型](https://docs.soliditylang.org/zh-cn/latest/types.html#address) 并结束执行。 注意， `selfdestruct` 有一些从EVM继承的特殊性：
* 接收合约的接收函数不会被执行。
 
* 合约只有在交易结束时才真正被销毁， 任何一个 `revert` 可能会 “恢复” 销毁。
 
此外，当前合约的所有函数都可以直接调用，包括当前函数。
警告
从 0.8.18 及以上版本开始，在 Solidity 和 Yul 中使用 `selfdestruct` 将触发一个已废弃警告， 因为 `SELFDESTRUCT` 操作码最终会发生如 [EIP-6049](https://eips.ethereum.org/EIPS/eip-6049) 中所述的行为上的重大变化。
备注
在 0.5.0 版本之前，有一个叫做 `suicide` 的函数，其语义与 `selfdestruct` 相同。
### 类型信息[](#meta-type "此标题的永久链接")
表达式 `type(X)` 可以用来检索关于 `X` 类型的信息。 目前，对这一功能的支持是有限的（ `X` 可以是合约类型或整数型），但在未来可能会扩展。
以下是合约类型 `C` 的可用属性：
`type(C).name`
合约的名称。
`type(C).creationCode`
内存字节数组，包含合约的创建字节码。 可以在内联程序中用来建立自定义的创建程序， 特别是通过使用 `create2` 操作码。 这个属性 **不能** 在合约本身或任何派生合约中被访问。 它会导致字节码被包含在调用站点的字节码中，因此像这样的循环引用是不可能的。
`type(C).runtimeCode`
内存字节数组，包含合约运行时的字节码。 通常是由 `C` 的构造函数部署的代码。 如果 `C` 有一个使用内联汇编的构造函数，这可能与实际部署的字节码不同。 还要注意的是，库合约在部署时修改其运行时字节码，以防止常规调用。 与 `.creationCode` 相同的限制也适用于这个属性。
除了上述属性外，以下属性对接口类型 `I` 可用：
`type(I).interfaceId`
一个 `bytes4` 值，是包含给定接口 `I` 的 [EIP-165](https://eips.ethereum.org/EIPS/eip-165) 接口标识符。 这个标识符被定义为接口本身定义的所有函数选择器的 `XOR`，不包括所有继承的函数。
以下属性可用于整数类型 `T`：
`type(T).min`
类型 `T` 所能代表的最小值。
`type(T).max`
类型 `T` 所能代表的最大值。
## 保留关键词[](#id15 "此标题的永久链接")
这些关键字在 Solidity 中是保留的。它们在将来可能成为语法的一部分：
`after`， `alias`， `apply`， `auto`， `byte`， `case`， `copyof`， `default`， `define`， `final`， `implements`， `in`， `inline`， `let`， `macro`， `match`， `mutable`， `null`， `of`， `partial`， `promise`， `reference`， `relocatable`， `sealed`， `sizeof`， `static`， `supports`， `switch`， `typedef`， `typeof`， `var`。

# [Unités et variables disponibles dans le monde entier — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/units-and-global-variables.html) 
 _https://docs.soliditylang.org/fr/latest/units-and-global-variables.html_

## Unités d’éther[](#unites-d-ether "Lien permanent vers cette rubrique")
Un nombre littéral peut prendre un suffixe de `wei`, `gwei` ou `ether` pour spécifier une sous-dénomination d’Ether, où les nombres d’Ether sans postfixe sont supposés être Wei.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=YXNzZXJ0KDEgd2VpID09IDEpOwphc3NlcnQoMSBnd2VpID09IDFlOSk7CmFzc2VydCgxIGV0aGVyID09IDFlMTgpOw==)
assert(1 wei \== 1);
assert(1 gwei \== 1e9);
assert(1 ether \== 1e18);
Le seul effet du suffixe de sous-dénomination est une multiplication par une puissance de dix.
Note
Les dénominations `finney` et `szabo` ont été supprimées dans la version 0.7.0.
## Unités de temps[](#unites-de-temps "Lien permanent vers cette rubrique")
Les suffixes comme `seconds`, `minutes`, `hours`, `days` et `weeks`, après des nombres littéraux, peuvent être utilisés pour spécifier des unités de temps où les secondes sont l’unité de base et les unités sont considérées naïvement de la manière suivante :
* `1 == 1 seconds`
 
* `1 minutes == 60 seconds`
 
* `1 hours == 60 minutes`
 
* `1 days == 24 hours`
 
* `1 weeks == 7 days`
 
Faites attention si vous effectuez des calculs de calendrier en utilisant ces unités, car chaque année n’est pas égale à 365 jours et chaque jour n’a pas 24 heures à cause des [secondes intercalaires](https://en.wikipedia.org/wiki/Leap_second). En raison du fait que les secondes intercalaires ne peuvent pas être prédites, un calendrier exact doit être mis à jour par une bibliothèque doit être mise à jour par un oracle externe.
Note
Le suffixe `years` a été supprimé dans la version 0.5.0 pour les raisons ci-dessus.
Ces suffixes ne peuvent pas être appliqués aux variables. Par exemple, si vous voulez interpréter un paramètre de fonction en jours, vous pouvez le faire de la manière suivante :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZnVuY3Rpb24gZih1aW50IHN0YXJ0LCB1aW50IGRheXNBZnRlcikgcHVibGljIHsKICAgIGlmIChibG9jay50aW1lc3RhbXAgPj0gc3RhcnQgKyBkYXlzQWZ0ZXIgKiAxIGRheXMpIHsKICAgICAgLy8gLi4uCiAgICB9Cn0=)
function f(uint start, uint daysAfter) public {
 if (block.timestamp \>= start + daysAfter \* 1 days) {
 // ...
 }
}
## Variables et fonctions spéciales[](#variables-et-fonctions-speciales "Lien permanent vers cette rubrique")
Certaines variables et fonctions spéciales existent toujours dans l’espace de nom global, et sont principalement utilisées pour fournir des informations sur la blockchain, ou sont des fonctions utilitaires d’usage général.
### Propriétés des blocs et des transactions[](#proprietes-des-blocs-et-des-transactions "Lien permanent vers cette rubrique")
* `blockhash(uint blockNumber) retourne (bytes32)`: hachage du bloc donné si `blocknumber` est l’un des 256 blocs les plus récents ; sinon retourne zéro.
 
* `block.basefee` (`uint`): la redevance de base du bloc actuel ([EIP-3198](https://eips.ethereum.org/EIPS/eip-3198) et [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559))
 
* `block.chainid` (`uint`): identifiant de la chaîne actuelle
 
* `block.coinbase` (`address payable`): adresse du mineur du bloc actuel
 
* `block.difficulty` (`uint`): difficulté actuelle du bloc
 
* `block.gaslimit` (`uint`): limite de gaz du bloc actuel
 
* `block.number` (`uint`): numéro du bloc actuel
 
* `block.timestamp` (`uint`): horodatage du bloc actuel en secondes depuis l’époque unix
 
* `gasleft() returns (uint256)`: gaz résiduel
 
* `msg.data` (`bytes calldata`): données d’appel complètes
 
* `msg.sender` (`address`): expéditeur du message (appel en cours)
 
* `msg.sig` (`bytes4`): les quatre premiers octets des données d’appel (c’est-à-dire l’identifiant de la fonction)
 
* `msg.value` (`uint`): nombre de wei envoyés avec le message
 
* `tx.gasprice` (`uint`): prix du gaz de la transaction
 
* `tx.origin` (`address`): expéditeur de la transaction (chaîne d’appel complète)
 
Note
Les valeurs de tous les membres de `msg`, y compris `msg.sender` et `msg.value` peuvent changer à chaque appel de fonction **externe**. Cela inclut les appels aux fonctions de la bibliothèque.
Note
Lorsque les contrats sont évalués hors chaîne plutôt que dans le contexte d’une transaction comprise dans un bloc, vous ne devez pas supposer que `block.*` et `tx.*` font référence à des valeurs d’un bloc ou d’une transaction spécifique. Ces valeurs sont fournies par l’implémentation EVM qui exécute le contrat et peuvent être arbitraires.
Note
Ne comptez pas sur `block.timestamp` ou `blockhash` comme source d’aléatoire, à moins que vous ne sachiez ce que vous faites.
L’horodatage et le hachage du bloc peuvent tous deux être influencés par les mineurs dans une certaine mesure. De mauvais acteurs dans la communauté minière peuvent par exemple exécuter une fonction de paiement de casino sur un hash choisi et réessayer un autre hash s’ils n’ont pas reçu d’argent.
L’horodatage du bloc actuel doit être strictement plus grand que l’horodatage du dernier bloc, mais la seule garantie est qu’il se situera quelque part entre les horodatages de deux blocs consécutifs dans la chaîne canonique.
Note
Les hachages des blocs ne sont pas disponibles pour tous les blocs pour des raisons d’évolutivité. Vous ne pouvez accéder qu’aux hachages des 256 blocs les plus récents. autres valeurs seront nulles.
Note
La fonction `blockhash` était auparavant connue sous le nom de `block.blockhash`, qui a été dépréciée dans la version 0.4.22 et supprimée dans la version 0.5.0.
Note
La fonction `gasleft` était auparavant connue sous le nom de `msg.gas`, qui a été dépréciée dans la version 0.4.21 et supprimée dans la version 0.5.0.
Note
Dans la version 0.7.0, l’alias `now` (pour `block.timestamp`) a été supprimé.
### Fonctions de codage et de décodage de l’ABI[](#fonctions-de-codage-et-de-decodage-de-l-abi "Lien permanent vers cette rubrique")
* `abi.decode(bytes memory encodedData, (...)) retourne (...)`: ABI-décode les données données, tandis que les types sont donnés entre parenthèses comme deuxième argument. Exemple : `(uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))`
 
* `abi.encode(...) returns (bytes memory)`: ABI-encode les arguments donnés
 
* `abi.encodePacked(...) returns (bytes memory)`: Effectue [l’encodage emballé](https://docs.soliditylang.org/fr/latest/abi-spec.html#abi-packed-mode) des arguments donnés. Notez que l’encodage emballé peut être ambigu !
 
* `abi.encodeWithSelector(bytes4 selector, ...) retourne (bytes memory)`: ABI-encode les arguments donnés en commençant par le deuxième et ajoute en préambule le sélecteur de quatre octets donné.
 
* `abi.encodeWithSignature(string memory signature, ...) retourne (bytes memory)`: Équivalent à `abi.encodeWithSelector(bytes4(keccak256(bytes(signature))), ...)`
 
* `abi.encodeCall(function functionPointer, (...)) retourne (bytes memory)`: ABI-encode un appel à `functionPointer` avec les arguments trouvés dans le tuple. Effectue un contrôle de type complet, en s’assurant que les types correspondent à la signature de la fonction. Le résultat est égal à `abi.encodeWithSelector(functionPointer.selector, (...))`
 
Note
Ces fonctions d’encodage peuvent être utilisées pour créer des données pour les appels de fonctions externes sans réellement appeler une fonction externe. De plus, `keccak256(abi.encodePacked(a, b))` est un moyen de calculer le hachage de données structurées (attention, il est possible de créer une « collision de hachage » en utilisant différents types de paramètres de fonction).
Reportez-vous à la documentation sur le [ABI](https://docs.soliditylang.org/fr/latest/abi-spec.html#abi) et le [codage étroitement emballé](https://docs.soliditylang.org/fr/latest/abi-spec.html#abi-packed-mode) pour plus de détails sur le codage.
### Membres des octets[](#membres-des-octets "Lien permanent vers cette rubrique")
* `bytes.concat(...) retourne (bytes memory)`: [Concatène un nombre variable d’octets et les arguments bytes1, …, bytes32 dans un tableau d’octets.](https://docs.soliditylang.org/fr/latest/types.html#bytes-concat)
 
### Traitement des erreurs[](#traitement-des-erreurs "Lien permanent vers cette rubrique")
Consultez la section dédiée à [assert et require](https://docs.soliditylang.org/fr/latest/control-structures.html#assert-and-require) pour plus de détails sur la gestion des erreurs et quand utiliser telle ou telle fonction.
`assert(bool condition)`
provoque une erreur de panique et donc un changement d’état si la condition n’est pas remplie - à utiliser pour les erreurs internes.
`require(bool condition)`
revient en arrière si la condition n’est pas remplie - à utiliser pour les erreurs dans les entrées ou les composants externes.
`require(bool condition, string memory message)`
fait marche arrière si la condition n’est pas remplie - à utiliser pour les erreurs dans les entrées ou les composants externes. Fournit également un message d’erreur.
`revert()`
interrompt l’exécution et renverse les changements d’état
`revert(string memory reason)`
interrompt l’exécution et annule les changements d’état, en fournissant une chaîne explicative.
### Fonctions mathématiques et cryptographiques[](#fonctions-mathematiques-et-cryptographiques "Lien permanent vers cette rubrique")
`addmod(uint x, uint y, uint k) retourne (uint)`
calcule `(x + y) % k` où l’addition est effectuée avec une précision arbitraire et ne s’arrête pas à `2**256`. Affirme que `k != 0` à partir de la version 0.5.0.
`mulmod(uint x, uint y, uint k) retourne (uint)`
calcule `(x * y) % k` où la multiplication est effectuée avec une précision arbitraire et ne s’arrête pas à `2**256`. Affirme que `k != 0` à partir de la version 0.5.0.
`keccak256(octets mémoire) retourne (octets32)`
calcule le hachage Keccak-256 de l’entrée
Note
Il y avait auparavant un alias pour `keccak256` appelé `sha3`, qui a été supprimé dans la version 0.5.0.
`sha256(bytes memory) retourne (bytes32)`
calcule le hachage SHA-256 de l’entrée
`ripemd160(bytes memory) retourne (bytes20)`
calcule le hachage RIPEMD-160 de l’entrée
`ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) retourne (address)`
récupère l’adresse associée à la clé publique de la signature à courbe elliptique ou renvoie zéro en cas d’erreur. Les paramètres de la fonction correspondent aux valeurs ECDSA de la signature :
* `r` = premiers 32 octets de la signature
 
* `s` = deuxième 32 octets de la signature
 
* `v` = dernier 1 octet de la signature
 
`ecrecover` retourne une `adresse`, et non une `adresse payable`. Voir [address payable](https://docs.soliditylang.org/fr/latest/types.html#address) pour la conversion, au cas où vous auriez besoin de transférer des fonds à l’adresse récupérée.
Pour plus de détails, lisez [example usage](https://ethereum.stackexchange.com/questions/1777/workflow-on-signing-a-string-with-private-key-followed-by-signature-verificatio).
Avertissement
Si vous utilisez `ecrecover`, soyez conscient qu’une signature valide peut être transformée en une signature valide différente sans avoir besoin de connaître la clé privée correspondante. Dans le hard fork de Homestead, ce problème a été corrigé pour les signatures \_transaction\_ (voir [EIP-2](https://eips.ethereum.org/EIPS/eip-2#specification)), mais la fonction ecrecover est restée inchangée.
Ce n’est généralement pas un problème, à moins que vous n’exigiez que les signatures soient uniques ou que vous les utilisiez pour identifier des éléments. OpenZeppelin a une [ECDSA helper library](https://docs.openzeppelin.com/contracts/2.x/api/cryptography#ECDSA) que vous pouvez utiliser comme un wrapper pour `ecrecover` sans ce problème.
Note
Lorsque vous exécutez les fonctions `sha256`, `ripemd160` ou `ecrecover` sur une _blockchain privée_, vous pouvez rencontrer des problèmes d’épuisement. Cela est dû au fait que ces fonctions sont implémentées en tant que « contrats précompilés » et n’existent réellement qu’après avoir reçu le premier message (bien que leur code de contrat soit codé en dur). Les messages destinés à des contrats inexistants sont plus coûteux et l’exécution peut donc se heurter à une erreur Out-of-Gas. Une solution à ce problème consiste à envoyer d’abord du Wei (1 par exemple) à chacun des contrats avant de les utiliser dans vos contrats réels. Ce n’est pas un problème sur le réseau principal ou le réseau de test.
### Membres des types d’adresses[](#membres-des-types-d-adresses "Lien permanent vers cette rubrique")
`<address>.balance` (`uint256`)
solde de l”adresse dans Wei
`<address>.code` (`bytes memory`)
code à l”adresse (peut être vide)
`<address>.codehash` (`bytes32`)
le codehash de l’adresse [Address](https://docs.soliditylang.org/fr/latest/types.html#address).
`<address payable>.transfer(uint256 amount)`
envoie une quantité donnée de Wei à adress, revient en arrière en cas d’échec, envoie 2300 de gaz, non réglable
`<address payable>.send(uint256 amount) returns (bool)`
envoie un montant donné de Wei à [Address](https://docs.soliditylang.org/fr/latest/types.html#address), renvoie `false` en cas d’échec, envoie 2300 de gaz, non réglable
`<address>.call(bytes memory) returns (bool, bytes memory)`
émet un `CALL` de bas niveau avec la charge utile donnée, renvoie la condition de succès et les données de retour, transmet tous les gaz disponibles, ajustable
`<address>.delegatecall(bytes memory) returns (bool, bytes memory)`
émet un `DELEGATECALL` de bas niveau avec la charge utile donnée, renvoie la condition de succès et les données de retour, transmet tous les gaz disponibles, réglable
`<address>.staticcall(bytes memory) returns (bool, bytes memory)`
émet un `STATICCALL` de bas niveau avec la charge utile donnée, renvoie la condition de succès et les données de retour, transmet tous les gaz disponibles, réglable
Pour plus d’informations, consultez la section sur adress.
Avertissement
Vous devez éviter d’utiliser `.call()` chaque fois que possible lors de l’exécution d’une autre fonction de contrat car elle contourne la vérification de type le contrôle d’existence de la fonction et l’emballage des arguments.
Avertissement
Il y a quelques dangers à utiliser `send` : Le transfert échoue si la profondeur de la pile d’appel est à 1024 (ceci peut toujours être forcé par l’appelant) et il échoue également si le destinataire tombe en panne sèche. Donc, afin de de faire des transferts d’Ether sûrs, vérifiez toujours la valeur de retour de `send`, utilisez `transfer` ou encore mieux : Utilisez un modèle où le destinataire retire l’argent.
Avertissement
En raison du fait que l’EVM considère qu’un appel à un contrat inexistant réussit toujours, Solidity inclut une vérification supplémentaire en utilisant l’opcode `extcodesize` lors des appels externes. Cela garantit que le contrat qui est sur le point d’être appelé existe réellement (il contient du code) soit une exception est levée.
Les appels de bas niveau qui opèrent sur des adresses plutôt que sur des instances de contrat (c’est-à-dire `.call()`, `.delegatecall()`, `.staticcall()`, `.send()` et `.transfer()`) **n’incluent pas** cette vérification, ce qui les rend moins coûteux en termes de gaz mais aussi moins sûrs.
Note
Avant la version 0.5.0, Solidity permettait d’accéder aux membres adresse par une instance de contrat, par exemple `this.balance`. Ceci est maintenant interdit et une conversion explicite en adresse doit être faite : `address(this).balance`.
Note
Si l’on accède à des variables d’état via un appel de délégué de bas niveau, la disposition de stockage des deux contrats doit s’aligner pour que le contrat appelé puisse accéder correctement aux variables de stockage du contrat appelant par leur nom. Ce n’est évidemment pas le cas si les pointeurs de stockage sont passés comme arguments de fonction, comme dans le cas des bibliothèques de haut niveau.
Note
Avant la version 0.5.0, `.call`, `.delegatecall` et `.staticcall` retournaient uniquement la condition de réussite et non les données de retour.
Note
Avant la version 0.5.0, il existait un membre appelé ```callcode`' avec une sémantique similaire mais légèrement différente de celle de ``deallcode```, sémantique similaire mais légèrement différente de celle de `delegatecall`.
### Concernant les contrats[](#concernant-les-contrats "Lien permanent vers cette rubrique")
`this` (le type du contrat actuel)
le contrat actuel, explicitement convertible en [Address](https://docs.soliditylang.org/fr/latest/types.html#address).
`selfdestruct(address payable recipient)`
Détruit le contrat actuel, en envoyant ses fonds à l’adresse [Address](https://docs.soliditylang.org/fr/latest/types.html#address) donnée et mettre fin à l’exécution. Notez que `selfdestruct` a quelques particularités héritées de l’EVM :
* la fonction de réception du contrat récepteur n’est pas exécutée.
 
* le contrat n’est réellement détruit qu’à la fin de la transaction et les `revert` peuvent « annuler » la destruction.
 
En outre, toutes les fonctions du contrat en cours sont appelables directement, y compris la fonction en cours.
Note
Avant la version 0.5.0, il existait une fonction appelée `suicide` ayant la même sémantique que la fonction `selfdestruct`.
### Informations sur le type de produit[](#informations-sur-le-type-de-produit "Lien permanent vers cette rubrique")
L’expression `type(X)` peut être utilisée pour récupérer des informations sur le type `X`. Actuellement, la prise en charge de cette fonctionnalité est limitée (`X` peut être soit un contrat ou un type entier) mais elle pourrait être étendue dans le futur.
Les propriétés suivantes sont disponibles pour un type de contrat `C` :
`type(C).name`
Le nom du contrat.
`type(C).creationCode`
Tableau d’octets en mémoire qui contient le bytecode de création du contrat. Ceci peut être utilisé dans l’assemblage en ligne pour construire des routines de création personnalisées, notamment en utilisant l’opcode `create2`. Cette propriété n’est **pas** accessible dans le contrat lui-même ou dans un contrat dérivé. Elle provoque l’inclusion du bytecode dans le bytecode du site d’appel et donc les références circulaires de ce genre ne sont pas possibles.
`type(C).runtimeCode`
Tableau d’octets en mémoire qui contient le bytecode d’exécution du contrat. Il s’agit du code qui est généralement déployé par le constructeur de `C`. Si `C` a un constructeur qui utilise l’assemblage en ligne, cela peut être différent du bytecode réellement déployé. Notez également que les bibliothèques modifient leur code d’exécution au moment du déploiement pour se prémunir contre les appels réguliers. Les mêmes restrictions que pour `.creationCode` s’appliquent à cette propriété.
En plus des propriétés ci-dessus, les propriétés suivantes sont disponibles pour une interface de type `I` :
`type(I).interfaceId`:
Une valeur `bytes4` contenant le [EIP-165](https://eips.ethereum.org/EIPS/eip-165) de l’interface `I` donnée. Cet identificateur est défini comme étant le `XOR` de tous les sélecteurs de fonctions définis dans l’interface elle-même - à l’exclusion de toutes les fonctions héritées.
Les propriétés suivantes sont disponibles pour un type entier `T` :
`type(T).min`
La plus petite valeur représentable par le type `T`.
`type(T).max`
La plus grande valeur représentable par le type `T`.

# [Aide-mémoire — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/cheatsheet.html) 
 _https://docs.soliditylang.org/fr/latest/cheatsheet.html_

## Ordre de Préséance des Opérateurs[](#ordre-de-preseance-des-operateurs "Lien permanent vers cette rubrique")
Voici l’ordre de préséance des opérateurs, classés par ordre d’évaluation.
 
Prédominance
Description
Opérateur
_1_
Incrément et décrément de Postfix
`++`, `--`
Nouvelle expression
`new <nomdutilisateur>`
Subscription de tableau
`<array>[<index>]`
Accès des membres
`<objet>.<membre>`
Appel de type fonctionnel
`<func>(<args...>)`
Parenthèses
`(<déclaration>)`
_2_
Préfixe d’incrémentation et de décrémentation
`++`, `--`
Moins unaire
`-`
Opérations unaires
`delete`
Logique NON
`!`
NON par bit
`~`
_3_
Exponentité
`**`
_4_
Multiplication, division et modulo
`*`, `/`, `%`
_5_
Addition et soustraction
`+`, `-`
_6_
Opérateurs de décalage par bit
`<<`, `>>`
_7_
ET par bit
`&`
_8_
XOR par bit
`^`
_9_
OU par bit
`|`
_10_
Opérateurs d’inégalité
`<`, `>`, `<=`, `>=`
_11_
Opérateurs d’égalité
`==`, `!=`
_12_
ET logique
`&&`
_13_
OU logique
`||`
_14_
Opérateur ternaire
`<conditional> ? <if-true> : <if-false>`
Opérateurs d’assignation
`=`, `|=`, `^=`, `&=`, `<<=`, `>>=`, `+=`, `-=`, `*=`, `/=`, `%=`
_15_
Opérateur de virgule
`,`
## Variables Globales[](#variables-globales "Lien permanent vers cette rubrique")
* `abi.decode(bytes memory encodedData, (...)) returns (...)`: [ABI](https://docs.soliditylang.org/fr/latest/abi-spec.html#abi)\-décode les données fournies. Les types sont donnés entre parenthèses comme deuxième argument. Exemple: `(uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))`
 
* `abi.encode(...) returns (bytes memory)`: [ABI](https://docs.soliditylang.org/fr/latest/abi-spec.html#abi)\-encode les arguments donnés
 
* `abi.encodePacked(...) returns (bytes memory)`: Performe l”[encodage emballé](https://docs.soliditylang.org/fr/latest/abi-spec.html#abi-packed-mode) des arguments donnés. Notez que cet encodage peut être ambigu !
 
* `abi.encodeWithSelector(bytes4 selector, ...) returns (bytes memory)`: [ABI](https://docs.soliditylang.org/fr/latest/abi-spec.html#abi)\-encode les arguments donnés en commençant par le deuxième et en ajoutant au début le sélecteur de quatre octets donné.
 
* `abi.encodeCall(function functionPointer, (...)) returns (bytes memory)`: ABI-encode un appel à `functionPointer` avec les arguments trouvés dans le tuple. Effectue une vérification complète des types, en s’assurant que les types correspondent à la signature de la fonction. Le résultat est égal à `abi.encodeWithSelector(functionPointer.selector, (...))`
 
* `abi.encodeWithSignature(string memory signature, ...) returns (bytes memory)`: Equivalent à `abi.encodeWithSelector(bytes4(keccak256(bytes(signature)), ...)`
 
* `bytes.concat(...) returns (bytes memory)`: [Concatène un nombre variable d’arguments d’arguments dans un tableau d’un octet](https://docs.soliditylang.org/fr/latest/types.html#bytes-concat)
 
* `block.basefee` (`uint`): redevance de base du bloc actuel ([EIP-3198](https://eips.ethereum.org/EIPS/eip-3198) et [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559))
 
* `block.chainid` (`uint`): identifiant de la chaîne actuelle
 
* `block.coinbase` (`address payable`): adresse du mineur du bloc actuel
 
* `block.difficulty` (`uint`): difficulté actuelle du bloc
 
* `block.gaslimit` (`uint`): limite de gaz du bloc actuel
 
* `block.number` (`uint`): numéro du bloc actuel
 
* `block.timestamp` (`uint`): Horodatage du bloc actuel
 
* `gasleft() returns (uint256)`: gaz résiduel
 
* `msg.data` (`bytes`): données d’appel complètes
 
* `msg.sender` (`address`): expéditeur du message (appel en cours)
 
* `msg.value` (`uint`): nombre de wei envoyés avec le message
 
* `tx.gasprice` (`uint`): prix du gaz de la transaction
 
* `tx.origin` (`address`): expéditeur de la transaction (chaîne d’appel complète)
 
* `assert(bool condition)`: interrompt l’exécution et annule les changements d’état si la condition est « fausse » (à utiliser pour les erreurs internes).
 
* `require(bool condition)`: interrompre l’exécution et annuler les changements d’état si la condition est « fausse » (à utiliser pour une entrée malformée ou une erreur dans un composant externe)
 
* `require(bool condition, string memory message)`: interrompt l’exécution et annule les changements d’état si la condition est « fausse » (à utiliser en cas d’entrée malformée ou d’erreur dans un composant externe). Fournit également un message d’erreur.
 
* `revert()`: interrompre l’exécution et revenir sur les changements d’état
 
* `revert(string memory message)`: interrompre l’exécution et revenir sur les changements d’état en fournissant une chaîne explicative
 
* `blockhash(uint blockNumber) returns (bytes32)`: hachage du bloc donné - ne fonctionne que pour les 256 blocs les plus récents
 
* `keccak256(bytes memory) returns (bytes32)`: calculer le hachage Keccak-256 de l’entrée
 
* `sha256(bytes memory) returns (bytes32)`: calculer le hachage SHA-256 de l’entrée
 
* `ripemd160(bytes memory) returns (bytes20)`: calculer le hachage RIPEMD-160 de l’entrée
 
* `ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)`: récupérer l’adresse associée à la clé publique de la signature de la courbe elliptique, renvoie zéro en cas d’erreur
 
* `addmod(uint x, uint y, uint k) returns (uint)`: compute `(x + y) % k` où l’addition est effectuée avec une précision arbitraire et ne s’arrête pas à `2**256`. Affirmer que `k != 0` à partir de la version 0.5.0.
 
* `mulmod(uint x, uint y, uint k) returns (uint)`: compute `(x * y) % k` où la multiplication est effectuée avec une précision arbitraire et ne s’arrête pas à `2**256`. Affirmer que `k != 0` à partir de la version 0.5.0.
 
* `this` (current contract’s type): le contrat en cours, explicitement convertible en « adresse » ou « adresse payable ».
 
* `super`: le contrat un niveau plus haut dans la hiérarchie d’héritage
 
* `selfdestruct(address payable recipient)`: détruire le contrat en cours, en envoyant ses fonds à l’adresse donnée
 
* `<address>.balance` (`uint256`): solde de la [Address](https://docs.soliditylang.org/fr/latest/types.html#address) dans Wei
 
* `<address>.code` (`bytes memory`): le code à [Address](https://docs.soliditylang.org/fr/latest/types.html#address) (peut être vide)
 
* `<address>.codehash` (`bytes32`): le codehash de l’adresse [Address](https://docs.soliditylang.org/fr/latest/types.html#address)
 
* `<address payable>.send(uint256 amount) returns (bool)`: envoie une quantité donnée de Wei à [Address](https://docs.soliditylang.org/fr/latest/types.html#address), renvoie `false` en cas d’échec
 
* `<address payable>.transfer(uint256 amount)`: envoie une quantité donnée de Wei à [Address](https://docs.soliditylang.org/fr/latest/types.html#address), lance en cas d’échec
 
* `type(C).name` (`string`): le nom du contrat
 
* `type(C).creationCode` (`bytes memory`): bytecode de création du contrat donné, voir [Type Information](https://docs.soliditylang.org/fr/latest/units-and-global-variables.html#meta-type).
 
* `type(C).runtimeCode` (`bytes memory`): le bytecode d’exécution du contrat donné, voir [Type Information](https://docs.soliditylang.org/fr/latest/units-and-global-variables.html#meta-type).
 
* `type(I).interfaceId` (`bytes4`): contenant l’identificateur d’interface EIP-165 de l’interface donnée, voir [Type Information](https://docs.soliditylang.org/fr/latest/units-and-global-variables.html#meta-type).
 
* `type(T).min` (`T`): la valeur minimale représentable par le type entier `T`, voir [Type Information](https://docs.soliditylang.org/fr/latest/units-and-global-variables.html#meta-type).
 
* `type(T).max` (`T`): la valeur maximale représentable par le type entier `T`, voir [Type Information](https://docs.soliditylang.org/fr/latest/units-and-global-variables.html#meta-type).
 
Note
Lorsque les contrats sont évalués hors chaîne plutôt que dans le contexte d’une transaction comprise dans un bloc, vous ne devez pas supposer que `block.*` et `tx.*` font référence à des valeurs d’un bloc ou d’une transaction d’un bloc ou d’une transaction spécifique. Ces valeurs sont fournies par l’implémentation EVM qui exécute le contrat et peuvent être arbitraires. contrat et peuvent être arbitraires.
Note
Ne comptez pas sur `block.timestamp` ou `blockhash` comme source d’aléatoire, à moins que vous ne sachiez ce que vous faites.
L’horodatage et le hachage du bloc peuvent tous deux être influencés par les mineurs dans une certaine mesure. De mauvais acteurs dans la communauté minière peuvent par exemple exécuter une fonction de paiement de casino sur un hash choisi et réessayer un autre hash s’ils n’ont pas reçu d’argent.
L’horodatage du bloc actuel doit être strictement plus grand que l’horodatage du dernier bloc, mais la seule garantie est qu’il se situera quelque part entre les horodatages de deux blocs consécutifs dans la chaîne canonique.
Note
Les hachages des blocs ne sont pas disponibles pour tous les blocs pour des raisons d’évolutivité. Vous ne pouvez accéder qu’aux hachages des 256 blocs les plus récents. autres valeurs seront nulles.
Note
Dans la version 0.5.0, les alias suivants ont été supprimés : `suicide` comme alias pour `selfdestruct`, `msg.gas` comme alias pour `gasleft`, `block.blockhash` comme alias pour `blockhash` et `sha3` comme alias pour `keccak256`.
Note
Dans la version 0.7.0, l’alias `now` (pour `block.timestamp`) a été supprimé.
## Spécification de la Visibilité des Fonctions[](#specification-de-la-visibilite-des-fonctions "Lien permanent vers cette rubrique")
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZnVuY3Rpb24gbXlGdW5jdGlvbigpIDx2aXNpYmlsaXR5IHNwZWNpZmllcj4gcmV0dXJucyAoYm9vbCkgewogICAgcmV0dXJuIHRydWU7Cn0=)
function myFunction() <visibility specifier\> returns (bool) {
 return true;
}
* `public`: visible en externe et en interne (crée une [fonction réceptrice](https://docs.soliditylang.org/fr/latest/contracts.html#getter-functions) pour les variables de stockage/d’état)
 
* `private`: uniquement visible dans le contrat en cours
 
* `external`: visible uniquement en externe (uniquement pour les fonctions) - c’est-à-dire qu’il ne peut être appelé que par message (via `this.func`)
 
* `internal`: uniquement visible en interne
 
## Modificateurs[](#modificateurs "Lien permanent vers cette rubrique")
* `pure` pour les fonctions : Interdit la modification ou l’accès à l’état.
 
* `view` pour les fonctions : Interdit la modification de l’état.
 
* `payable` pour les fonctions : Leur permet de recevoir de l’Ether en même temps qu’un appel.
 
* `constant` pour les variables d’état : Ne permet pas l’affectation (sauf l’initialisation), n’occupe pas d’emplacement de stockage.
 
* `immutable` pour les variables d’état : Permet exactement une affectation au moment de la construction et est constante par la suite. Est stockée dans le code.
 
* `anonymous` pour les événements : Ne stocke pas la signature de l’événement comme sujet.
 
* `indexed` pour les paramètres d’événements : Stocke le paramètre en tant que sujet.
 
* `virtual` pour les fonctions et les modificateurs : Permet de modifier le comportement de la fonction ou du modificateur dans les contrats dérivés.
 
* `override`: Indique que cette fonction, ce modificateur ou cette variable d’état publique change le comportement d’une fonction ou d’un modificateur dans un contrat de base.
 
## Mots clés réservés[](#mots-cles-reserves "Lien permanent vers cette rubrique")
Ces mots-clés sont réservés dans Solidity. Ils pourraient faire partie de la syntaxe à l’avenir :
`after`, `alias`, `apply`, `auto`, `byte`, `case`, `copyof`, `default`, `define`, `final`, `implements`, `in`, `inline`, `let`, `macro`, `match`, `mutable`, `null`, `of`, `partial`, `promise`, `reference`, `relocatable`, `sealed`, `sizeof`, `static`, `supports`, `switch`, `typedef`, `typeof`, `var`.

# [Layout of Call Data — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/internals/layout_in_calldata.html) 
 _https://docs.soliditylang.org/en/v0.8.30/internals/layout_in_calldata.html_

The input data for a function call is assumed to be in the format defined by the [ABI specification](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#abi). Among others, the ABI specification requires arguments to be padded to multiples of 32 bytes. The internal function calls use a different convention.
Arguments for the constructor of a contract are directly appended at the end of the contract’s code, also in ABI encoding. The constructor will access them through a hard-coded offset, and not by using the `codesize` opcode, since this of course changes when appending data to the code.

# [Çağrı Verilerinin Düzeni — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/internals/layout_in_calldata.html) 
 _https://docs.soliditylang.org/tr/latest/internals/layout_in_calldata.html_

Bir fonksiyon çağrısı için alınan girdi verisinin [ABI belirtimi](https://docs.soliditylang.org/tr/latest/abi-spec.html#abi) tarafından tanımlanan formatta olduğu varsayılır. Diğerlerinin yanı sıra, ABI tanımlaması argümanların 32 baytın katları olacak şekilde eklenmesini zorunlu kılar. Dahili(internal) fonksiyon çağrıları bundan farklı bir kural kullanır.
Bir sözleşmenin constructor fonksiyonu için argümanlar, ABI şifrelemesinde de olduğu gibi sözleşmenin kodunun sonuna doğrudan eklenir. Constructor fonksiyonu argümanlara `codesize` işlem kodunu kullanarak değil, sabit kodlanmış bir ofset üzerinden erişir. Bunun nedeni ise koda veri eklerken bu ofsetin değişmesidir.

# [Solidity v0.5.0 Changements de rupture — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/050-breaking-changes.html) 
 _https://docs.soliditylang.org/fr/latest/050-breaking-changes.html_

Cette section met en évidence les principaux changements introduits dans la version 0.5.0 de Solidity, ainsi que les raisons de ces changements et la façon de mettre à jour le code concerné. Pour la liste complète, consultez [le journal des modifications de la version](https://github.com/ethereum/solidity/releases/tag/v0.5.0).
Note
Les contrats compilés avec Solidity v0.5.0 peuvent toujours s’interfacer avec des contrats et même des bibliothèques compilés avec des versions plus anciennes sans avoir à les recompiler ou à les redéployer. Il suffit de modifier les interfaces pour inclure les emplacements des données et les spécificateurs de visibilité et de mutabilité. Voir la section [Interopérabilité avec les contrats plus anciens](#interoperability) en dessous.
## Changements uniquement sémantiques[](#changements-uniquement-semantiques "Lien permanent vers cette rubrique")
Cette section énumère les changements qui sont uniquement sémantiques, donc potentiellement cacher un comportement nouveau et différent dans le code existant.
* Le décalage signé vers la droite utilise maintenant le décalage arithmétique
 
approprié, c’est-à-dire qu’il arrondit vers l’infini négatif au lieu d’arrondir vers zéro. l’infini négatif, au lieu d’arrondir vers zéro. Les décalages signés et non signés auront des opcodes dédiés dans Constantinople, et sont émulés par Solidity pour le moment. Solidity pour le moment.
* La déclaration `continue` dans une boucle `do...while` saute maintenant au comportement commun dans de tels cas. Auparavant, il sautait vers le corps de la boucle. Ainsi, si la condition est fausse, la boucle se termine.
 
* Les fonctions `.call()`, `.delegatecall()` et `.staticcall()` ne tamponnent plus lorsqu’on leur donne un seul paramètre `bytes`.
 
* Les fonctions Pure et View sont désormais appelées en utilisant l’opcode `STATICCALL` au lieu de `CALL` si la version de l’EVM est Byzantium ou ultérieure. Cela interdit les changements d’état au niveau de l’EVM.
 
* L’encodeur ABI pallie désormais correctement les tableaux d’octets et les chaînes de caractères des données d’appel (`msg.data` et paramètres de fonctions externes) lorsqu’ils sont utilisés dans des appels externes et dans `abi.encode`. Pour un encodage non codé, utilisez `abi.encodePacked`.
 
* Le décodeur ABI revient en arrière au début des fonctions et dans `abi.decode()` si les données d’appel passées sont trop courtes ou pointent hors des limites. Notez que les bits d’ordre supérieur sales sont toujours simplement ignorés.
 
* Transférer tout le gaz disponible avec des appels de fonctions externes à partir de Tangerine Whistle.
 
## Changements sémantiques et syntaxiques[](#changements-semantiques-et-syntaxiques "Lien permanent vers cette rubrique")
Cette section met en évidence les changements qui affectent la syntaxe et la sémantique.
* Les fonctions `.call()`, `.delegatecall()`, `staticcall()`, `keccak256()`, `sha256()` et `ripemd160()` n’acceptent plus qu’un seul argument `bytes`. unique, `bytes`. De plus, l’argument n’est pas paddé. Ceci a été changé pour rendre plus explicite et clair la façon dont les arguments sont concaténés. Changez chaque `.call()` (et famille) en un `.call("")` et chaque `.call(signature, a, b, c)` en utilisant `.call(abi.encodeWithSignature(signature, a, b, c))` (le dernier ne fonctionne que pour les types dernière ne fonctionne que pour les types de valeurs). Changez chaque `keccak256(a, b, c)` en `keccak256(abi.encodePacked(a, b, c))`. Même s’il ne s’agit pas d’une il est suggéré que les développeurs changent `x.call(bytes4(keccak256("f(uint256)")), a, b)` en `x.call(abi.encodeWithSignature("f(uint256)", a, b))`.
 
* Les fonctions `.call()`, `.delegatecall()` et `.staticcall()` retournent maintenant `(bool, bytes memory)` pour donner accès aux données de retour. Modifier `bool success = otherContract.call("f")` en `(bool success, bytes memory données) = otherContract.call("f")`.
 
* Solidity met désormais en œuvre les règles de délimitation du style C99 pour les locales de fonctions, c’est-à-dire que les variables ne peuvent être utilisées que déclarées et seulement dans le même périmètre ou dans des périmètres imbriqués. Les variables déclarées dans le bloc d’initialisation d’une boucle [\`\`](#id1)for\`”” sont valides en tout point de la boucle. boucle.
 
## Exigences d’explicitation[](#exigences-d-explicitation "Lien permanent vers cette rubrique")
Cette section liste les modifications pour lesquelles le code doit être plus explicite. Pour la plupart des sujets, le compilateur fournira des suggestions.
* La visibilité explicite des fonctions est maintenant obligatoire. Ajouter `public` à chaque fonction et constructeur fonction et constructeur, et `external` à chaque fonction de fallback ou d’interface d’interface qui ne spécifie pas déjà sa visibilité.
 
* La localisation explicite des données pour toutes les variables de type struct, array ou mapping est maintenant obligatoire. Ceci s’applique également aux paramètres des fonctions et aux de retour. Par exemple, changez `uint[] x = m_x` en `uint[] storage x = m_x`, et `fonction f(uint[][] x)` en `fonction f(uint[][] mémoire x)` où « memory » est l’emplacement des données et peut être remplacé par « storage » ou « calldata ». `calldata` en conséquence. Notez que les fonctions `externes` requièrent des paramètres dont l’emplacement des données est `calldata`.
 
* Les types de contrats n’incluent plus les membres `addresses` afin de afin de séparer les espaces de noms. Par conséquent, il est maintenant nécessaire de convertir explicitement les valeurs du type de contrat en adresses avant d’utiliser une membre `address`. Exemple : si `c` est un contrat, changez `c.transfert(...)` en `adresse(c).transfert(...)`, et `c.balance` en `address(c).balance`.
 
* Les conversions explicites entre des types de contrats non liés sont désormais interdites. Vous pouvez seulement convertir un type de contrat en l’un de ses types de base ou ancêtres. Si vous êtes sûr que un contrat est compatible avec le type de contrat vers lequel vous voulez le convertir, bien qu’il n’en hérite pas. bien qu’il n’en hérite pas, vous pouvez contourner ce problème en convertissant d’abord en `adresse`. Exemple : si `A` et `B` sont des types de contrat, `B` n’hérite pas de `A` et `b` est un contrat de type `B`, vous pouvez toujours convertir `b` en type `A` en utilisant `A(adresse(b))`. Notez que vous devez toujours faire attention aux fonctions de repli payantes correspondantes, comme expliqué ci-dessous.
 
* Le type « adresse » a été divisé en « adresse » et « adresse payable », où seule « l’adresse payable » fournit la fonction « transfert ». Un site Une « adresse payable » peut être directement convertie en une « adresse », mais l’inverse n’est pas autorisé. l’inverse n’est pas autorisé. La conversion de `adresse` en `adresse payable" est possible par conversion via ``uint160`. Si `c` est un contrat, `address(c)` résulte en `address payable` seulement si `c` possède une fonction de repli payable. Si vous utilisez le modèle [withdraw pattern](https://docs.soliditylang.org/fr/latest/common-patterns.html#withdrawal-pattern), vous n’avez probablement pas à modifier votre code car `transfer` est uniquement utilisé sur `msg.sender` au lieu des adresses stockées et `msg.sender` est une `adresse`. est une `adresse payable`.
 
* Les conversions entre `bytesX` et `uintY` de taille différente sont maintenant sont désormais interdites en raison du remplissage de `bytesX` à droite et du remplissage de `uintY` à gauche. gauche, ce qui peut entraîner des résultats de conversion inattendus. La taille doit maintenant être ajustée dans le type avant la conversion. Par exemple, vous pouvez convertir un `bytes4` (4 octets) en un `uint64` (8 octets) en convertissant d’abord le `bytes4` en un ```uint64`'. en convertissant d'abord la variable ``bytes4``` en `bytes8`, puis en ```uint64`'. Vous obtenez le inverse en convertissant en ``uint32```. Avant la version 0.5.0, toute conversion entre `bytesX` et `uintY` passait par `uint8X`. Pour Par exemple, `uint8(bytes3(0x291807))` sera converti en `uint8(uint24(bytes3(0x291807))` (le résultat est (le résultat est `0x07`).
 
* L’utilisation de `msg.value` dans des fonctions non payantes (ou son introduction par le biais d’un modificateur) est interdit par mesure de sécurité. Transformez la fonction en payante  » ou créez une nouvelle fonction interne pour la logique du programme qui utilise `msg.value`.
 
* Pour des raisons de clarté, l’interface de la ligne de commande exige maintenant `-` si l” l’entrée standard est utilisée comme source.
 
## Éléments dépréciés[](#elements-deprecies "Lien permanent vers cette rubrique")
Cette section liste les changements qui déprécient des fonctionnalités ou des syntaxes antérieures. Notez que plusieurs de ces changements étaient déjà activés dans le mode expérimental `v0.5.0`.
### Interfaces en ligne de commande et JSON[](#interfaces-en-ligne-de-commande-et-json "Lien permanent vers cette rubrique")
* L’option de ligne de commande `--formal` (utilisée pour générer la sortie de Why3 pour une pour une vérification formelle plus poussée) était dépréciée et est maintenant supprimée. Un nouveau module de vérification formelle, le SMTChecker, est activé via `pragma experimental SMTChecker;`.
 
* L’option de ligne de commande `--julia` a été renommée en `--yul` en raison du changement de nom du langage intermédiaire [\`\`](#id3). en raison du changement de nom du langage intermédiaire « Julia » en « Yul ».
 
* Les options de ligne de commande `--clone-bin` et `--combined-json clone-bin` ont été supprimées. ont été supprimées.
 
* Les remappages avec un préfixe vide ne sont pas autorisés.
 
* Les champs AST JSON `constant` et [\`\`](#id5)payable\`” ont été supprimés. L’adresse informations sont maintenant présentes dans le champ [\`\`](#id7)stateMutability\`”.
 
* Le champ JSON AST `isConstructor` du noeud `FunctionDefinition` a été remplacé par un champ appelé `Fonctions''. a été remplacé par un champ appelé ``kind` qui peut avoir la valeur valeur `"constructor"`, `"fallback"` ou `"function"`.
 
* Dans les fichiers hexadécimaux binaires non liés, les adresses des bibliothèques sont maintenant les 36 premiers caractères hexadécimaux de la clé. sont désormais les 36 premiers caractères hexadécimaux du hachage keccak256 du nom de bibliothèque nom de bibliothèque entièrement qualifié, entouré de « $…$ ». Auparavant, seul le nom complet de la bibliothèque était utilisé. Cela réduit les risques de collisions, en particulier lorsque de longs chemins sont utilisés. Les fichiers binaires contiennent maintenant aussi une liste de correspondances entre ces caractères de remplacement vers les noms pleinement qualifiés.
 
### Constructeurs[](#constructeurs "Lien permanent vers cette rubrique")
* Les constructeurs doivent désormais être définis à l’aide du mot clé « constructeur ».
 
* L’appel de constructeurs de base sans parenthèses est désormais interdit.
 
* La spécification des arguments des constructeurs de base plusieurs fois dans la même même hiérarchie d’héritage est maintenant interdit.
 
* L’appel d’un constructeur avec des arguments mais avec un nombre d’arguments incorrect est maintenant désapprouvé. Si vous souhaitez seulement spécifier une relation d’héritage sans sans donner d’arguments, ne fournissez pas de parenthèses du tout.
 
### Fonctions[](#fonctions "Lien permanent vers cette rubrique")
* La fonction `callcode` est maintenant désapprouvée (en faveur de `delegatecall`). Il est Il est toujours possible de l’utiliser via l’assemblage en ligne.
 
* La fonction `suicide` n’est plus autorisée (au profit de `selfdestruct`).
 
* `sha3` n’est plus autorisé (au profit de `keccak256`).
 
* `throw` est maintenant désapprouvé (en faveur de `revert`, `require` et de `assert`).
 
### Conversions[](#conversions "Lien permanent vers cette rubrique")
* Les conversions explicites et implicites des littéraux décimaux en types [\`\`](#id9)bytesXX\`”” sont maintenant désactivées. est désormais interdit.
 
* Les conversions explicites et implicites de littéraux hexadécimaux en types [\`\`](#id11)bytesXX\`”” de taille différente sont désormais interdites. de taille différente sont désormais interdites.
 
### Littéraux et suffixes[](#litteraux-et-suffixes "Lien permanent vers cette rubrique")
* L’unité de dénomination « années » n’est plus autorisée en raison de complications et de confusions concernant les années bissextiles. complications et de confusions concernant les années bissextiles.
 
* Les points de fin de ligne qui ne sont pas suivis d’un nombre ne sont plus autorisés.
 
* La combinaison de nombres hexadécimaux avec des unités (par exemple, « 0x1e wei ») n’est plus autorisée. interdites.
 
* Le préfixe `0X` pour les nombres hexadécimaux n’est plus autorisé, seul `0x` est possible.
 
### Variables[](#variables "Lien permanent vers cette rubrique")
* La déclaration de structures vides n’est plus autorisée pour des raisons de clarté.
 
* Le mot clé « var » n’est plus autorisé pour favoriser l’explicitation.
 
* Les affectations entre les tuples avec un nombre différent de composants sont maintenant interdites. désapprouvé.
 
* Les valeurs des constantes qui ne sont pas des constantes de compilation ne sont pas autorisées.
 
* Les déclarations multi-variables avec un nombre de valeurs non concordant sont maintenant désapprouvées.
 
* Les variables de stockage non initialisées ne sont plus autorisées.
 
* Les composants de tuple vides ne sont plus admis.
 
* La détection des dépendances cycliques dans les variables et les structures est limitée en récursion à 256. récursion à 256.
 
* Les tableaux de taille fixe avec une longueur de zéro ne sont plus autorisés.
 
### Syntaxe[](#syntaxe "Lien permanent vers cette rubrique")
* L’utilisation de `constant` comme modificateur de mutabilité de l’état de la fonction est désormais interdite.
 
* Les expressions booléennes ne peuvent pas utiliser d’opérations arithmétiques.
 
* L’opérateur unaire « + » n’est plus autorisé.
 
* Les littéraux ne peuvent plus être utilisés avec `abi.encodePacked` sans conversion conversion préalable vers un type explicite.
 
* Les déclarations de retour vides pour les fonctions avec une ou plusieurs valeurs de retour ne sont plus sont désormais interdites.
 
* La syntaxe « loose assembly », c’est-à-dire les étiquettes de saut, est maintenant totalement interdite, les sauts et les instructions non fonctionnelles ne peuvent plus être utilisés. Utilisez les nouvelles fonctions `while`, `switch` et `if` à la place.
 
* Les fonctions sans implémentation ne peuvent plus utiliser de modificateurs.
 
* Les types de fonctions avec des valeurs de retour nommées ne sont plus autorisés.
 
* Les déclarations de variables d’une seule déclaration à l’intérieur de corps if/while/for qui ne sont pas qui ne sont pas des blocs ne sont plus autorisées.
 
* Nouveaux mots-clés : `calldata` et `constructor`.
 
* Nouveaux mots-clés réservés : `alias`, `apply`, `auto`, `copyof`, `définir'', ``immutable'', ``implements'', ``macro'', ``mutable'', ``override`, `partiel`, `promise`, `reference`, `sealed`, [\`\`](#id13)sizeof””, [\`\`](#id15)supports””, [\`\`](#id17)typedef”” et [\`\`](#id19)unchecked””.
 
## Interopérabilité avec les anciens contrats[](#interoperabilite-avec-les-anciens-contrats "Lien permanent vers cette rubrique")
Il est toujours possible de s’interfacer avec des contrats écrits pour des versions de Solidity antérieures à la v0.5.0 (ou l’inverse) en définissant des interfaces pour eux. Considérons que vous avez le contrat suivant, antérieur à la version 0.5.0, déjà déployé :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjQuMjU7Ci8vIFRoaXMgd2lsbCByZXBvcnQgYSB3YXJuaW5nIHVudGlsIHZlcnNpb24gMC40LjI1IG9mIHRoZSBjb21waWxlcgovLyBUaGlzIHdpbGwgbm90IGNvbXBpbGUgYWZ0ZXIgMC41LjAKY29udHJhY3QgT2xkQ29udHJhY3QgewogICAgZnVuY3Rpb24gc29tZU9sZEZ1bmN0aW9uKHVpbnQ4IGEpIHsKICAgICAgICAvLy4uLgogICAgfQogICAgZnVuY3Rpb24gYW5vdGhlck9sZEZ1bmN0aW9uKCkgY29uc3RhbnQgcmV0dXJucyAoYm9vbCkgewogICAgICAgIC8vLi4uCiAgICB9CiAgICAvLyAuLi4KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.4.25;
// This will report a warning until version 0.4.25 of the compiler
// This will not compile after 0.5.0
contract OldContract {
 function someOldFunction(uint8 a) {
 //...
 }
 function anotherOldFunction() constant returns (bool) {
 //...
 }
 // ...
}
Il ne compilera plus avec Solidity v0.5.0. Cependant, vous pouvez lui définir une interface compatible :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwppbnRlcmZhY2UgT2xkQ29udHJhY3QgewogICAgZnVuY3Rpb24gc29tZU9sZEZ1bmN0aW9uKHVpbnQ4IGEpIGV4dGVybmFsOwogICAgZnVuY3Rpb24gYW5vdGhlck9sZEZ1bmN0aW9uKCkgZXh0ZXJuYWwgcmV0dXJucyAoYm9vbCk7Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
interface OldContract {
 function someOldFunction(uint8 a) external;
 function anotherOldFunction() external returns (bool);
}
Notez que nous n’avons pas déclaré « anotherOldFunction » comme étant « view », bien qu’elle soit déclarée « constante » dans le contrat original. contrat original. Cela est dû au fait qu’à partir de la version 0.5.0 de Solidity, l’option `staticcall` est utilisée pour appeler les fonctions `view`. Avant la v0.5.0, le mot-clé `constant` n’était pas appliqué, donc appeler une fonction déclarée `constante` avec `staticcall` peut encore se retourner, puisque la fonction `constant` peut encore tenter de modifier le stockage. Par conséquent, lorsque vous définissez une pour des contrats plus anciens, vous ne devriez utiliser `view` à la place de `constant` que si vous êtes absolument sûr que la fonction fonctionnera avec `staticcall`.
Avec l’interface définie ci-dessus, vous pouvez maintenant facilement utiliser le contrat pré-0.5.0 déjà déployé :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKaW50ZXJmYWNlIE9sZENvbnRyYWN0IHsKICAgIGZ1bmN0aW9uIHNvbWVPbGRGdW5jdGlvbih1aW50OCBhKSBleHRlcm5hbDsKICAgIGZ1bmN0aW9uIGFub3RoZXJPbGRGdW5jdGlvbigpIGV4dGVybmFsIHJldHVybnMgKGJvb2wpOwp9Cgpjb250cmFjdCBOZXdDb250cmFjdCB7CiAgICBmdW5jdGlvbiBkb1NvbWV0aGluZyhPbGRDb250cmFjdCBhKSBwdWJsaWMgcmV0dXJucyAoYm9vbCkgewogICAgICAgIGEuc29tZU9sZEZ1bmN0aW9uKDB4NDIpOwogICAgICAgIHJldHVybiBhLmFub3RoZXJPbGRGdW5jdGlvbigpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
interface OldContract {
 function someOldFunction(uint8 a) external;
 function anotherOldFunction() external returns (bool);
}
contract NewContract {
 function doSomething(OldContract a) public returns (bool) {
 a.someOldFunction(0x42);
 return a.anotherOldFunction();
 }
}
De même, les bibliothèques pré-0.5.0 peuvent être utilisées en définissant les fonctions de la bibliothèque sans implémentation et en en fournissant l’adresse de la bibliothèque pré-0.5.0 lors de l’édition de liens (voir :ref:[\`\`](#id21)commandline-compiler\` pour savoir comment utiliser le pour savoir comment utiliser le compilateur en ligne de commande pour l’édition de liens) :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gVGhpcyB3aWxsIG5vdCBjb21waWxlIGFmdGVyIDAuNi4wCi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBHUEwtMy4wCnByYWdtYSBzb2xpZGl0eSBeMC41LjA7CgpsaWJyYXJ5IE9sZExpYnJhcnkgewogICAgZnVuY3Rpb24gc29tZUZ1bmN0aW9uKHVpbnQ4IGEpIHB1YmxpYyByZXR1cm5zKGJvb2wpOwp9Cgpjb250cmFjdCBOZXdDb250cmFjdCB7CiAgICBmdW5jdGlvbiBmKHVpbnQ4IGEpIHB1YmxpYyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmV0dXJuIE9sZExpYnJhcnkuc29tZUZ1bmN0aW9uKGEpOwogICAgfQp9)
// This will not compile after 0.6.0
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.5.0;
library OldLibrary {
 function someFunction(uint8 a) public returns(bool);
}
contract NewContract {
 function f(uint8 a) public returns (bool) {
 return OldLibrary.someFunction(a);
 }
}
## Exemple[](#exemple "Lien permanent vers cette rubrique")
L’exemple suivant montre un contrat et sa version mise à jour pour Solidity v0.5.0 avec certaines des modifications énumérées dans cette section.
Ancienne version :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjQuMjU7Ci8vIFRoaXMgd2lsbCBub3QgY29tcGlsZSBhZnRlciAwLjUuMAoKY29udHJhY3QgT3RoZXJDb250cmFjdCB7CiAgICB1aW50IHg7CiAgICBmdW5jdGlvbiBmKHVpbnQgeSkgZXh0ZXJuYWwgewogICAgICAgIHggPSB5OwogICAgfQogICAgZnVuY3Rpb24oKSBwYXlhYmxlIGV4dGVybmFsIHt9Cn0KCmNvbnRyYWN0IE9sZCB7CiAgICBPdGhlckNvbnRyYWN0IG90aGVyOwogICAgdWludCBteU51bWJlcjsKCiAgICAvLyBGdW5jdGlvbiBtdXRhYmlsaXR5IG5vdCBwcm92aWRlZCwgbm90IGFuIGVycm9yLgogICAgZnVuY3Rpb24gc29tZUludGVnZXIoKSBpbnRlcm5hbCByZXR1cm5zICh1aW50KSB7IHJldHVybiAyOyB9CgogICAgLy8gRnVuY3Rpb24gdmlzaWJpbGl0eSBub3QgcHJvdmlkZWQsIG5vdCBhbiBlcnJvci4KICAgIC8vIEZ1bmN0aW9uIG11dGFiaWxpdHkgbm90IHByb3ZpZGVkLCBub3QgYW4gZXJyb3IuCiAgICBmdW5jdGlvbiBmKHVpbnQgeCkgcmV0dXJucyAoYnl0ZXMpIHsKICAgICAgICAvLyBWYXIgaXMgZmluZSBpbiB0aGlzIHZlcnNpb24uCiAgICAgICAgdmFyIHogPSBzb21lSW50ZWdlcigpOwogICAgICAgIHggKz0gejsKICAgICAgICAvLyBUaHJvdyBpcyBmaW5lIGluIHRoaXMgdmVyc2lvbi4KICAgICAgICBpZiAoeCA+IDEwMCkKICAgICAgICAgICAgdGhyb3c7CiAgICAgICAgYnl0ZXMgbWVtb3J5IGIgPSBuZXcgYnl0ZXMoeCk7CiAgICAgICAgeSA9IC0zID4+IDE7CiAgICAgICAgLy8geSA9PSAtMSAod3JvbmcsIHNob3VsZCBiZSAtMikKICAgICAgICBkbyB7CiAgICAgICAgICAgIHggKz0gMTsKICAgICAgICAgICAgaWYgKHggPiAxMCkgY29udGludWU7CiAgICAgICAgICAgIC8vICdDb250aW51ZScgY2F1c2VzIGFuIGluZmluaXRlIGxvb3AuCiAgICAgICAgfSB3aGlsZSAoeCA8IDExKTsKICAgICAgICAvLyBDYWxsIHJldHVybnMgb25seSBhIEJvb2wuCiAgICAgICAgYm9vbCBzdWNjZXNzID0gYWRkcmVzcyhvdGhlcikuY2FsbCgiZiIpOwogICAgICAgIGlmICghc3VjY2VzcykKICAgICAgICAgICAgcmV2ZXJ0KCk7CiAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIC8vIExvY2FsIHZhcmlhYmxlcyBjb3VsZCBiZSBkZWNsYXJlZCBhZnRlciB0aGVpciB1c2UuCiAgICAgICAgICAgIGludCB5OwogICAgICAgIH0KICAgICAgICByZXR1cm4gYjsKICAgIH0KCiAgICAvLyBObyBuZWVkIGZvciBhbiBleHBsaWNpdCBkYXRhIGxvY2F0aW9uIGZvciAnYXJyJwogICAgZnVuY3Rpb24gZyh1aW50W10gYXJyLCBieXRlczggeCwgT3RoZXJDb250cmFjdCBvdGhlckNvbnRyYWN0KSBwdWJsaWMgewogICAgICAgIG90aGVyQ29udHJhY3QudHJhbnNmZXIoMSBldGhlcik7CgogICAgICAgIC8vIFNpbmNlIHVpbnQzMiAoNCBieXRlcykgaXMgc21hbGxlciB0aGFuIGJ5dGVzOCAoOCBieXRlcyksCiAgICAgICAgLy8gdGhlIGZpcnN0IDQgYnl0ZXMgb2YgeCB3aWxsIGJlIGxvc3QuIFRoaXMgbWlnaHQgbGVhZCB0bwogICAgICAgIC8vIHVuZXhwZWN0ZWQgYmVoYXZpb3Igc2luY2UgYnl0ZXNYIGFyZSByaWdodCBwYWRkZWQuCiAgICAgICAgdWludDMyIHkgPSB1aW50MzIoeCk7CiAgICAgICAgbXlOdW1iZXIgKz0geSArIG1zZy52YWx1ZTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.4.25;
// This will not compile after 0.5.0
contract OtherContract {
 uint x;
 function f(uint y) external {
 x \= y;
 }
 function() payable external {}
}
contract Old {
 OtherContract other;
 uint myNumber;
 // Function mutability not provided, not an error.
 function someInteger() internal returns (uint) { return 2; }
 // Function visibility not provided, not an error.
 // Function mutability not provided, not an error.
 function f(uint x) returns (bytes) {
 // Var is fine in this version.
 var z \= someInteger();
 x += z;
 // Throw is fine in this version.
 if (x \> 100)
 throw;
 bytes memory b \= new bytes(x);
 y \= \-3 \>> 1;
 // y == -1 (wrong, should be -2)
 do {
 x += 1;
 if (x \> 10) continue;
 // 'Continue' causes an infinite loop.
 } while (x < 11);
 // Call returns only a Bool.
 bool success \= address(other).call("f");
 if (!success)
 revert();
 else {
 // Local variables could be declared after their use.
 int y;
 }
 return b;
 }
 // No need for an explicit data location for 'arr'
 function g(uint\[\] arr, bytes8 x, OtherContract otherContract) public {
 otherContract.transfer(1 ether);
 // Since uint32 (4 bytes) is smaller than bytes8 (8 bytes),
 // the first 4 bytes of x will be lost. This might lead to
 // unexpected behavior since bytesX are right padded.
 uint32 y \= uint32(x);
 myNumber += y + msg.value;
 }
}
Nouvelle version :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjUuMDsKLy8gVGhpcyB3aWxsIG5vdCBjb21waWxlIGFmdGVyIDAuNi4wCgpjb250cmFjdCBPdGhlckNvbnRyYWN0IHsKICAgIHVpbnQgeDsKICAgIGZ1bmN0aW9uIGYodWludCB5KSBleHRlcm5hbCB7CiAgICAgICAgeCA9IHk7CiAgICB9CiAgICBmdW5jdGlvbigpIHBheWFibGUgZXh0ZXJuYWwge30KfQoKY29udHJhY3QgTmV3IHsKICAgIE90aGVyQ29udHJhY3Qgb3RoZXI7CiAgICB1aW50IG15TnVtYmVyOwoKICAgIC8vIEZ1bmN0aW9uIG11dGFiaWxpdHkgbXVzdCBiZSBzcGVjaWZpZWQuCiAgICBmdW5jdGlvbiBzb21lSW50ZWdlcigpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludCkgeyByZXR1cm4gMjsgfQoKICAgIC8vIEZ1bmN0aW9uIHZpc2liaWxpdHkgbXVzdCBiZSBzcGVjaWZpZWQuCiAgICAvLyBGdW5jdGlvbiBtdXRhYmlsaXR5IG11c3QgYmUgc3BlY2lmaWVkLgogICAgZnVuY3Rpb24gZih1aW50IHgpIHB1YmxpYyByZXR1cm5zIChieXRlcyBtZW1vcnkpIHsKICAgICAgICAvLyBUaGUgdHlwZSBtdXN0IG5vdyBiZSBleHBsaWNpdGx5IGdpdmVuLgogICAgICAgIHVpbnQgeiA9IHNvbWVJbnRlZ2VyKCk7CiAgICAgICAgeCArPSB6OwogICAgICAgIC8vIFRocm93IGlzIG5vdyBkaXNhbGxvd2VkLgogICAgICAgIHJlcXVpcmUoeCA8PSAxMDApOwogICAgICAgIGludCB5ID0gLTMgPj4gMTsKICAgICAgICByZXF1aXJlKHkgPT0gLTIpOwogICAgICAgIGRvIHsKICAgICAgICAgICAgeCArPSAxOwogICAgICAgICAgICBpZiAoeCA+IDEwKSBjb250aW51ZTsKICAgICAgICAgICAgLy8gJ0NvbnRpbnVlJyBqdW1wcyB0byB0aGUgY29uZGl0aW9uIGJlbG93LgogICAgICAgIH0gd2hpbGUgKHggPCAxMSk7CgogICAgICAgIC8vIENhbGwgcmV0dXJucyAoYm9vbCwgYnl0ZXMpLgogICAgICAgIC8vIERhdGEgbG9jYXRpb24gbXVzdCBiZSBzcGVjaWZpZWQuCiAgICAgICAgKGJvb2wgc3VjY2VzcywgYnl0ZXMgbWVtb3J5IGRhdGEpID0gYWRkcmVzcyhvdGhlcikuY2FsbCgiZiIpOwogICAgICAgIGlmICghc3VjY2VzcykKICAgICAgICAgICAgcmV2ZXJ0KCk7CiAgICAgICAgcmV0dXJuIGRhdGE7CiAgICB9CgogICAgdXNpbmcgYWRkcmVzc19tYWtlX3BheWFibGUgZm9yIGFkZHJlc3M7CiAgICAvLyBEYXRhIGxvY2F0aW9uIGZvciAnYXJyJyBtdXN0IGJlIHNwZWNpZmllZAogICAgZnVuY3Rpb24gZyh1aW50W10gbWVtb3J5IC8qIGFyciAqLywgYnl0ZXM4IHgsIE90aGVyQ29udHJhY3Qgb3RoZXJDb250cmFjdCwgYWRkcmVzcyB1bmtub3duQ29udHJhY3QpIHB1YmxpYyBwYXlhYmxlIHsKICAgICAgICAvLyAnb3RoZXJDb250cmFjdC50cmFuc2ZlcicgaXMgbm90IHByb3ZpZGVkLgogICAgICAgIC8vIFNpbmNlIHRoZSBjb2RlIG9mICdPdGhlckNvbnRyYWN0JyBpcyBrbm93biBhbmQgaGFzIHRoZSBmYWxsYmFjawogICAgICAgIC8vIGZ1bmN0aW9uLCBhZGRyZXNzKG90aGVyQ29udHJhY3QpIGhhcyB0eXBlICdhZGRyZXNzIHBheWFibGUnLgogICAgICAgIGFkZHJlc3Mob3RoZXJDb250cmFjdCkudHJhbnNmZXIoMSBldGhlcik7CgogICAgICAgIC8vICd1bmtub3duQ29udHJhY3QudHJhbnNmZXInIGlzIG5vdCBwcm92aWRlZC4KICAgICAgICAvLyAnYWRkcmVzcyh1bmtub3duQ29udHJhY3QpLnRyYW5zZmVyJyBpcyBub3QgcHJvdmlkZWQKICAgICAgICAvLyBzaW5jZSAnYWRkcmVzcyh1bmtub3duQ29udHJhY3QpJyBpcyBub3QgJ2FkZHJlc3MgcGF5YWJsZScuCiAgICAgICAgLy8gSWYgdGhlIGZ1bmN0aW9uIHRha2VzIGFuICdhZGRyZXNzJyB3aGljaCB5b3Ugd2FudCB0byBzZW5kCiAgICAgICAgLy8gZnVuZHMgdG8sIHlvdSBjYW4gY29udmVydCBpdCB0byAnYWRkcmVzcyBwYXlhYmxlJyB2aWEgJ3VpbnQxNjAnLgogICAgICAgIC8vIE5vdGU6IFRoaXMgaXMgbm90IHJlY29tbWVuZGVkIGFuZCB0aGUgZXhwbGljaXQgdHlwZQogICAgICAgIC8vICdhZGRyZXNzIHBheWFibGUnIHNob3VsZCBiZSB1c2VkIHdoZW5ldmVyIHBvc3NpYmxlLgogICAgICAgIC8vIFRvIGluY3JlYXNlIGNsYXJpdHksIHdlIHN1Z2dlc3QgdGhlIHVzZSBvZiBhIGxpYnJhcnkgZm9yCiAgICAgICAgLy8gdGhlIGNvbnZlcnNpb24gKHByb3ZpZGVkIGFmdGVyIHRoZSBjb250cmFjdCBpbiB0aGlzIGV4YW1wbGUpLgogICAgICAgIGFkZHJlc3MgcGF5YWJsZSBhZGRyID0gdW5rbm93bkNvbnRyYWN0Lm1ha2VfcGF5YWJsZSgpOwogICAgICAgIHJlcXVpcmUoYWRkci5zZW5kKDEgZXRoZXIpKTsKCiAgICAgICAgLy8gU2luY2UgdWludDMyICg0IGJ5dGVzKSBpcyBzbWFsbGVyIHRoYW4gYnl0ZXM4ICg4IGJ5dGVzKSwKICAgICAgICAvLyB0aGUgY29udmVyc2lvbiBpcyBub3QgYWxsb3dlZC4KICAgICAgICAvLyBXZSBuZWVkIHRvIGNvbnZlcnQgdG8gYSBjb21tb24gc2l6ZSBmaXJzdDoKICAgICAgICBieXRlczQgeDQgPSBieXRlczQoeCk7IC8vIFBhZGRpbmcgaGFwcGVucyBvbiB0aGUgcmlnaHQKICAgICAgICB1aW50MzIgeSA9IHVpbnQzMih4NCk7IC8vIENvbnZlcnNpb24gaXMgY29uc2lzdGVudAogICAgICAgIC8vICdtc2cudmFsdWUnIGNhbm5vdCBiZSB1c2VkIGluIGEgJ25vbi1wYXlhYmxlJyBmdW5jdGlvbi4KICAgICAgICAvLyBXZSBuZWVkIHRvIG1ha2UgdGhlIGZ1bmN0aW9uIHBheWFibGUKICAgICAgICBteU51bWJlciArPSB5ICsgbXNnLnZhbHVlOwogICAgfQp9CgovLyBXZSBjYW4gZGVmaW5lIGEgbGlicmFyeSBmb3IgZXhwbGljaXRseSBjb252ZXJ0aW5nIGBgYWRkcmVzc2BgCi8vIHRvIGBgYWRkcmVzcyBwYXlhYmxlYGAgYXMgYSB3b3JrYXJvdW5kLgpsaWJyYXJ5IGFkZHJlc3NfbWFrZV9wYXlhYmxlIHsKICAgIGZ1bmN0aW9uIG1ha2VfcGF5YWJsZShhZGRyZXNzIHgpIGludGVybmFsIHB1cmUgcmV0dXJucyAoYWRkcmVzcyBwYXlhYmxlKSB7CiAgICAgICAgcmV0dXJuIGFkZHJlc3ModWludDE2MCh4KSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.5.0;
// This will not compile after 0.6.0
contract OtherContract {
 uint x;
 function f(uint y) external {
 x \= y;
 }
 function() payable external {}
}
contract New {
 OtherContract other;
 uint myNumber;
 // Function mutability must be specified.
 function someInteger() internal pure returns (uint) { return 2; }
 // Function visibility must be specified.
 // Function mutability must be specified.
 function f(uint x) public returns (bytes memory) {
 // The type must now be explicitly given.
 uint z \= someInteger();
 x += z;
 // Throw is now disallowed.
 require(x <= 100);
 int y \= \-3 \>> 1;
 require(y \== \-2);
 do {
 x += 1;
 if (x \> 10) continue;
 // 'Continue' jumps to the condition below.
 } while (x < 11);
 // Call returns (bool, bytes).
 // Data location must be specified.
 (bool success, bytes memory data) \= address(other).call("f");
 if (!success)
 revert();
 return data;
 }
 using address\_make\_payable for address;
 // Data location for 'arr' must be specified
 function g(uint\[\] memory /\* arr \*/, bytes8 x, OtherContract otherContract, address unknownContract) public payable {
 // 'otherContract.transfer' is not provided.
 // Since the code of 'OtherContract' is known and has the fallback
 // function, address(otherContract) has type 'address payable'.
 address(otherContract).transfer(1 ether);
 // 'unknownContract.transfer' is not provided.
 // 'address(unknownContract).transfer' is not provided
 // since 'address(unknownContract)' is not 'address payable'.
 // If the function takes an 'address' which you want to send
 // funds to, you can convert it to 'address payable' via 'uint160'.
 // Note: This is not recommended and the explicit type
 // 'address payable' should be used whenever possible.
 // To increase clarity, we suggest the use of a library for
 // the conversion (provided after the contract in this example).
 address payable addr \= unknownContract.make\_payable();
 require(addr.send(1 ether));
 // Since uint32 (4 bytes) is smaller than bytes8 (8 bytes),
 // the conversion is not allowed.
 // We need to convert to a common size first:
 bytes4 x4 \= bytes4(x); // Padding happens on the right
 uint32 y \= uint32(x4); // Conversion is consistent
 // 'msg.value' cannot be used in a 'non-payable' function.
 // We need to make the function payable
 myNumber += y + msg.value;
 }
}
// We can define a library for explicitly converting \`\`address\`\`
// to \`\`address payable\`\` as a workaround.
library address\_make\_payable {
 function make\_payable(address x) internal pure returns (address payable) {
 return address(uint160(x));
 }
}

# [Langue Grammaire — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/grammar.html) 
 _https://docs.soliditylang.org/fr/latest/grammar.html_

[Solidity](https://docs.soliditylang.org/fr/latest/index.html)
_parser grammar_ SolidityParser[](#a4.SolidityParser "Lien permanent vers cette définition")
Solidity est un langage de haut niveau statiquement typé, orienté vers les contrats et destiné à la mise en œuvre de contrats intelligents sur la plateforme Ethereum.
_rule_ source-unit[](#a4.SolidityParser.sourceUnit "Lien permanent vers cette définition")
Au niveau le plus élevé, Solidity permet les pragmas, les directives d’importation et les définitions de contrats, d’interfaces, de bibliothèques, de structs, d’enums et de constantes.
pragmapragma-token;import-directivecontract-definitioninterface-definitionlibrary-definitionfunction-definitionconstant-variable-declarationstruct-definitionenum-definitionuser-defined-value-type-definitionerror-definitioneof
_rule_ import-directive[](#a4.SolidityParser.importDirective "Lien permanent vers cette définition")
Les directives d’importation importent les identifiants de différents fichiers.
importpathasidentifiersymbol-aliasesfrompath\*asidentifierfrompath;
_rule_ path[](#a4.SolidityParser.path "Lien permanent vers cette définition")
Chemin d’un fichier à importer.
non-empty-string-literal
_rule_ symbol-aliases[](#a4.SolidityParser.symbolAliases "Lien permanent vers cette définition")
Liste d’alias pour les symboles à importer.
{identifierasidentifier,}
_rule_ contract-definition[](#a4.SolidityParser.contractDefinition "Lien permanent vers cette définition")
Définition de haut niveau d’un contrat.
abstractcontractidentifierisinheritance-specifier,{contract-body-element}
_rule_ interface-definition[](#a4.SolidityParser.interfaceDefinition "Lien permanent vers cette définition")
Définition de haut niveau d’une interface.
interfaceidentifierisinheritance-specifier,{contract-body-element}
_rule_ library-definition[](#a4.SolidityParser.libraryDefinition "Lien permanent vers cette définition")
Définition de haut niveau d’une bibliothèque.
libraryidentifier{contract-body-element}
_rule_ inheritance-specifier[](#a4.SolidityParser.inheritanceSpecifier "Lien permanent vers cette définition")
Spécification de l’héritage pour les contrats et les interfaces. Peut optionnellement fournir les arguments du constructeur de base.
identifier-pathcall-argument-list
_rule_ contract-body-element[](#a4.SolidityParser.contractBodyElement "Lien permanent vers cette définition")
Déclarations pouvant être utilisées dans les contrats, les interfaces et les bibliothèques.
Les interfaces et les bibliothèques ne peuvent pas contenir de constructeurs, les interfaces ne peuvent pas contenir de variables d’état, et les bibliothèques ne peuvent pas contenir de fonctions de repli, de réception ou de variables d’état non constantes.
constructor-definitionfunction-definitionmodifier-definitionfallback-function-definitionreceive-function-definitionstruct-definitionenum-definitionuser-defined-value-type-definitionstate-variable-declarationevent-definitionerror-definitionusing-directive
_rule_ call-argument-list[](#a4.SolidityParser.callArgumentList "Lien permanent vers cette définition")
Arguments lors de l’appel d’une fonction ou d’un objet appelable similaire. Les arguments sont donnés soit sous forme de liste séparée par des virgules, soit sous forme de carte d’arguments nommés.
(expression,{identifier:expression,})
_rule_ identifier-path[](#a4.SolidityParser.identifierPath "Lien permanent vers cette définition")
Nom qualifié.
identifier.
_rule_ modifier-invocation[](#a4.SolidityParser.modifierInvocation "Lien permanent vers cette définition")
Appel à un modificateur. Si le modificateur ne prend pas d’arguments, la liste des arguments peut être entièrement ignorée. (y compris les parenthèses ouvrantes et fermantes).
identifier-pathcall-argument-list
_rule_ visibility[](#a4.SolidityParser.visibility "Lien permanent vers cette définition")
Visibilité des fonctions et des types de fonctions.
internalexternalprivatepublic
_rule_ parameter-list[](#a4.SolidityParser.parameterList "Lien permanent vers cette définition")
Une liste de paramètres, tels que les arguments de la fonction ou les valeurs de retour.
type-namedata-locationidentifier,
_rule_ constructor-definition[](#a4.SolidityParser.constructorDefinition "Lien permanent vers cette définition")
Définition d’un constructeur. Doit toujours fournir une implémentation. Notez que la spécification de la visibilité interne ou publique est dépréciée.
constructor(parameter-list)modifier-invocationpayableinternalpublicblock
_rule_ state-mutability[](#a4.SolidityParser.stateMutability "Lien permanent vers cette définition")
Indiquer la mutabilité pour les types de fonctions. La mutabilité par défaut “non-payable” est supposée si aucune mutabilité n’est spécifiée.
pureviewpayable
_rule_ override-specifier[](#a4.SolidityParser.overrideSpecifier "Lien permanent vers cette définition")
Un spécificateur de surcharge utilisé pour les fonctions, les modificateurs ou les variables d’état. Dans les cas où il y a des déclarations ambiguës dans plusieurs contrats de base qui sont remplacés, une liste complète des contrats de base doit être donnée.
override(identifier-path,)
_rule_ function-definition[](#a4.SolidityParser.functionDefinition "Lien permanent vers cette définition")
La définition des fonctions de contrat, de bibliothèque et d’interface. Selon le contexte dans lequel la fonction est définie, d’autres restrictions peuvent s’appliquer. Par exemple, les fonctions des interfaces doivent être non implémentées, c’est-à-dire qu’elles ne peuvent pas contenir de bloc de corps.
functionidentifierfallbackreceive(parameter-list)visibilitystate-mutabilitymodifier-invocationvirtualoverride-specifierreturns(parameter-list);block
_rule_ modifier-definition[](#a4.SolidityParser.modifierDefinition "Lien permanent vers cette définition")
La définition d’un modificateur. Notez que dans le corps d’un modificateur, l’underscore ne peut pas être utilisé comme identifiant, mais est utilisé comme déclaration de remplacement pour le corps d’une fonction à laquelle le modificateur est appliqué.
modifieridentifier(parameter-list)virtualoverride-specifier;block
_rule_ fallback-function-definition[](#a4.SolidityParser.fallbackFunctionDefinition "Lien permanent vers cette définition")
Définition de la fonction spéciale de repli.
fallback(parameter-list)externalstate-mutabilitymodifier-invocationvirtualoverride-specifierreturns(parameter-list);block
_rule_ receive-function-definition[](#a4.SolidityParser.receiveFunctionDefinition "Lien permanent vers cette définition")
Définition de la fonction de réception spéciale.
receive()externalpayablemodifier-invocationvirtualoverride-specifier;block
_rule_ struct-definition[](#a4.SolidityParser.structDefinition "Lien permanent vers cette définition")
Définition d’une structure. Peut se trouver au niveau supérieur dans une unité source ou dans un contrat, une bibliothèque ou une interface.
structidentifier{struct-member}
_rule_ struct-member[](#a4.SolidityParser.structMember "Lien permanent vers cette définition")
La déclaration d’un membre de structure nommé.
type-nameidentifier;
_rule_ enum-definition[](#a4.SolidityParser.enumDefinition "Lien permanent vers cette définition")
Définition d’un enum. Peut se produire au niveau supérieur dans une unité source ou dans un contrat, une bibliothèque ou une interface.
enumidentifier{identifier,}
_rule_ user-defined-value-type-definition[](#a4.SolidityParser.userDefinedValueTypeDefinition "Lien permanent vers cette définition")
Définition d’un type de valeur défini par l’utilisateur. Peut se produire au niveau supérieur dans une unité source ou dans un contrat, une bibliothèque ou une interface.
typeidentifieriselementary-type-name;
_rule_ state-variable-declaration[](#a4.SolidityParser.stateVariableDeclaration "Lien permanent vers cette définition")
La déclaration d’une variable d’état.
type-namepublicprivateinternalconstantoverride-specifierimmutableidentifier\=expression;
_rule_ constant-variable-declaration[](#a4.SolidityParser.constantVariableDeclaration "Lien permanent vers cette définition")
La déclaration d’une variable constante.
type-nameconstantidentifier\=expression;
_rule_ event-parameter[](#a4.SolidityParser.eventParameter "Lien permanent vers cette définition")
Paramètre d’un événement.
type-nameindexedidentifier
_rule_ event-definition[](#a4.SolidityParser.eventDefinition "Lien permanent vers cette définition")
Définition d’un événement. Peut se produire dans les contrats, les bibliothèques ou les interfaces.
eventidentifier(event-parameter,)anonymous;
_rule_ error-parameter[](#a4.SolidityParser.errorParameter "Lien permanent vers cette définition")
Paramètre d’une erreur.
type-nameidentifier
_rule_ error-definition[](#a4.SolidityParser.errorDefinition "Lien permanent vers cette définition")
Définition d’une erreur.
erroridentifier(error-parameter,);
_rule_ using-directive[](#a4.SolidityParser.usingDirective "Lien permanent vers cette définition")
Utilisation de directives pour lier des fonctions de bibliothèques à des types. Peut se produire dans les contrats et les bibliothèques.
usingidentifier-pathfor\*type-name;
_rule_ type-name[](#a4.SolidityParser.typeName "Lien permanent vers cette définition")
Un nom de type peut être un type élémentaire, un type de fonction, un type de mappage, un type défini par l’utilisateur (par exemple, un contrat ou un struct) ou un type de tableau.
elementary-type-namefunction-type-namemapping-typeidentifier-pathtype-name\[expression\]
_rule_ elementary-type-name[](#a4.SolidityParser.elementaryTypeName "Lien permanent vers cette définition")
addressaddresspayableboolstringbytessigned-integer-typeunsigned-integer-typefixed-bytesfixedufixed
_rule_ function-type-name[](#a4.SolidityParser.functionTypeName "Lien permanent vers cette définition")
function(parameter-list)visibilitystate-mutabilityreturns(parameter-list)
_rule_ variable-declaration[](#a4.SolidityParser.variableDeclaration "Lien permanent vers cette définition")
La déclaration d’une seule variable.
type-namedata-locationidentifier
_rule_ data-location[](#a4.SolidityParser.dataLocation "Lien permanent vers cette définition")
memorystoragecalldata
_rule_ expression[](#a4.SolidityParser.expression "Lien permanent vers cette définition")
Expression complexe. Peut être un accès à un index, un accès à une plage d’index, un accès à un membre, un appel de fonction (avec des options d’appel de fonction facultatives), une conversion de type, une expression unaire ou binaire, une comparaison ou une affectation, une expression ternaire, une nouvelle expression (c’est-à-dire la création d’un contrat ou l’allocation d’un tableau de mémoire dynamique), un tuple, un tableau en ligne ou une expression primaire (c’est-à-dire un identifiant, un littéral ou un nom de type).
expression\[expression\]expression\[expression:expression\]expression.identifieraddressexpression{identifier:expression,}expressioncall-argument-listpayablecall-argument-listtype(type-name)++\--!~delete\-expressionexpression++\--expression\*\*expressionexpression\*/%expressionexpression+\-expressionexpression<<\>>\>>>expressionexpression&expressionexpression^expressionexpression|expressionexpression<\><=\>=expressionexpression\==!=expressionexpression&&expressionexpression||expressionexpression?expression:expressionexpression\=|=^=&=<<=\>>=\>>>=+=\-=\*=/=%=expressionnewtype-nametuple-expressioninline-array-expressionidentifierliteralelementary-type-name
_rule_ tuple-expression[](#a4.SolidityParser.tupleExpression "Lien permanent vers cette définition")
(expression,)
_rule_ inline-array-expression[](#a4.SolidityParser.inlineArrayExpression "Lien permanent vers cette définition")
Une expression de tableau en ligne désigne un tableau de taille statique du type commun des expressions contenues.
\[expression,\]
_rule_ identifier[](#a4.SolidityParser.identifier "Lien permanent vers cette définition")
Outre les identificateurs ordinaires sans mot-clé, certains mots-clés comme « from » et « error » peuvent également être utilisés comme identificateurs.
identifierfromerrorrevert
_rule_ literal[](#a4.SolidityParser.literal "Lien permanent vers cette définition")
string-literalnumber-literalboolean-literalhex-string-literalunicode-string-literal
_rule_ boolean-literal[](#a4.SolidityParser.booleanLiteral "Lien permanent vers cette définition")
truefalse
_rule_ string-literal[](#a4.SolidityParser.stringLiteral "Lien permanent vers cette définition")
Une chaîne de caractères complète est constituée d’une ou plusieurs chaînes de caractères consécutives entre guillemets.
non-empty-string-literalempty-string-literal
_rule_ hex-string-literal[](#a4.SolidityParser.hexStringLiteral "Lien permanent vers cette définition")
Un littéral de chaîne hexagonale complète qui consiste en une ou plusieurs chaînes hexagonales consécutives.
hex-string
_rule_ unicode-string-literal[](#a4.SolidityParser.unicodeStringLiteral "Lien permanent vers cette définition")
Un littéral de chaîne unicode complet qui consiste en une ou plusieurs chaînes unicode consécutives.
unicode-string-literal
_rule_ number-literal[](#a4.SolidityParser.numberLiteral "Lien permanent vers cette définition")
Les littéraux numériques peuvent être des nombres décimaux ou hexadécimaux avec une unité optionnelle.
decimal-numberhex-numbernumber-unit
_rule_ block[](#a4.SolidityParser.block "Lien permanent vers cette définition")
Un bloc d’instructions avec des accolades. Ouvre sa propre portée.
{statementunchecked-block}
_rule_ unchecked-block[](#a4.SolidityParser.uncheckedBlock "Lien permanent vers cette définition")
uncheckedblock
_rule_ statement[](#a4.SolidityParser.statement "Lien permanent vers cette définition")
blockvariable-declaration-statementexpression-statementif-statementfor-statementwhile-statementdo-while-statementcontinue-statementbreak-statementtry-statementreturn-statementemit-statementrevert-statementassembly-statement
_rule_ if-statement[](#a4.SolidityParser.ifStatement "Lien permanent vers cette définition")
Déclaration If avec partie else facultative.
if(expression)statementelsestatement
_rule_ for-statement[](#a4.SolidityParser.forStatement "Lien permanent vers cette définition")
Instruction For avec une partie facultative init, condition et post-boucle.
for(variable-declaration-statementexpression-statement;expression-statement;expression)statement
_rule_ while-statement[](#a4.SolidityParser.whileStatement "Lien permanent vers cette définition")
while(expression)statement
_rule_ do-while-statement[](#a4.SolidityParser.doWhileStatement "Lien permanent vers cette définition")
dostatementwhile(expression);
_rule_ continue-statement[](#a4.SolidityParser.continueStatement "Lien permanent vers cette définition")
Une instruction continue. Uniquement autorisé dans les boucles for, while ou do-while.
continue;
_rule_ break-statement[](#a4.SolidityParser.breakStatement "Lien permanent vers cette définition")
Une instruction break. Uniquement autorisé dans les boucles for, while ou do-while.
break;
_rule_ try-statement[](#a4.SolidityParser.tryStatement "Lien permanent vers cette définition")
Une instruction try. L’expression contenue doit être un appel de fonction externe ou une création de contrat.
tryexpressionreturns(parameter-list)blockcatch-clause
_rule_ catch-clause[](#a4.SolidityParser.catchClause "Lien permanent vers cette définition")
La clause catch d’une déclaration try.
catchidentifier(parameter-list)block
_rule_ return-statement[](#a4.SolidityParser.returnStatement "Lien permanent vers cette définition")
returnexpression;
_rule_ emit-statement[](#a4.SolidityParser.emitStatement "Lien permanent vers cette définition")
Une instruction emit. L’expression contenue doit faire référence à un événement.
emitexpressioncall-argument-list;
_rule_ revert-statement[](#a4.SolidityParser.revertStatement "Lien permanent vers cette définition")
Une déclaration de retour en arrière. L’expression contenue doit faire référence à une erreur.
revertexpressioncall-argument-list;
_rule_ assembly-statement[](#a4.SolidityParser.assemblyStatement "Lien permanent vers cette définition")
Un bloc d’assemblage en ligne. Le contenu d’un bloc d’assemblage en ligne utilise un analyseur/lexeur séparé, c’est-à-dire que l’ensemble des mots-clés et d’identificateurs autorisés est différent à l’intérieur d’un bloc d’assemblage en ligne.
assembly'"evmasm"'{yul-statement}
_rule_ variable-declaration-tuple[](#a4.SolidityParser.variableDeclarationTuple "Lien permanent vers cette définition")
Un tuple de noms de variables à utiliser dans les déclarations de variables. Peut contenir des champs vides.
(,variable-declaration,variable-declaration)
_rule_ variable-declaration-statement[](#a4.SolidityParser.variableDeclarationStatement "Lien permanent vers cette définition")
Une déclaration de variable. Une seule variable peut être déclarée sans valeur initiale, alors qu’un tuple de variables ne peut être déclaré avec une valeur initiale.
variable-declaration\=expressionvariable-declaration-tuple\=expression;
_rule_ expression-statement[](#a4.SolidityParser.expressionStatement "Lien permanent vers cette définition")
expression;
_rule_ mapping-type[](#a4.SolidityParser.mappingType "Lien permanent vers cette définition")
mapping(mapping-key-type\=>type-name)
_rule_ mapping-key-type[](#a4.SolidityParser.mappingKeyType "Lien permanent vers cette définition")
Seuls les types élémentaires ou les types définis par l’utilisateur sont viables comme clés de mappage.
elementary-type-nameidentifier-path
_rule_ yul-statement[](#a4.SolidityParser.yulStatement "Lien permanent vers cette définition")
Une instruction Yul dans un bloc d’assemblage en ligne. Les instructions continue et break ne sont valables que dans les boucles for. Les instructions leave ne sont valables que dans les corps de fonctions.
yul-blockyul-variable-declarationyul-assignmentyul-function-callyul-if-statementyul-for-statementyul-switch-statementleavebreakcontinueyul-function-definition
_rule_ yul-block[](#a4.SolidityParser.yulBlock "Lien permanent vers cette définition")
{yul-statement}
_rule_ yul-variable-declaration[](#a4.SolidityParser.yulVariableDeclaration "Lien permanent vers cette définition")
La déclaration d’une ou plusieurs variables Yul avec une valeur initiale facultative. Si plusieurs variables sont déclarées, seul un appel de fonction constitue une valeur initiale valide.
letyul-identifier:=yul-expressionletyul-identifier,:=yul-function-call
_rule_ yul-assignment[](#a4.SolidityParser.yulAssignment "Lien permanent vers cette définition")
Toute expression peut être assignée à une seule variable Yul, alors que les affectations multiples nécessitent un appel de fonction sur le côté droit.
yul-path:=yul-expressionyul-path,yul-path:=yul-function-call
_rule_ yul-if-statement[](#a4.SolidityParser.yulIfStatement "Lien permanent vers cette définition")
ifyul-expressionyul-block
_rule_ yul-for-statement[](#a4.SolidityParser.yulForStatement "Lien permanent vers cette définition")
foryul-blockyul-expressionyul-blockyul-block
_rule_ yul-switch-statement[](#a4.SolidityParser.yulSwitchStatement "Lien permanent vers cette définition")
Une déclaration Yul switch peut consister uniquement en un cas par défaut (déprécié) ou en un ou plusieurs cas non-définis par défaut, éventuellement suivis d’un cas-défini par défaut.
switchyul-expressioncaseyul-literalyul-blockdefaultyul-blockdefaultyul-block
_rule_ yul-function-definition[](#a4.SolidityParser.yulFunctionDefinition "Lien permanent vers cette définition")
functionyul-identifier(yul-identifier,)\->yul-identifier,yul-block
_rule_ yul-path[](#a4.SolidityParser.yulPath "Lien permanent vers cette définition")
Alors que seuls les identifiants sans points peuvent être déclarés dans un bloc d’assemblage en ligne, les chemins contenant des points peuvent faire référence à des déclarations en dehors du bloc d’assemblage en ligne.
yul-identifier.
_rule_ yul-function-call[](#a4.SolidityParser.yulFunctionCall "Lien permanent vers cette définition")
Un appel à une fonction avec des valeurs de retour ne peut se produire qu’à droite d’une affectation ou d’une déclaration de variable.
yul-identifieryul-evm-builtin(yul-expression,)
_rule_ yul-boolean[](#a4.SolidityParser.yulBoolean "Lien permanent vers cette définition")
truefalse
_rule_ yul-literal[](#a4.SolidityParser.yulLiteral "Lien permanent vers cette définition")
yul-decimal-numberyul-string-literalyul-hex-numberyul-booleanhex-string
_rule_ yul-expression[](#a4.SolidityParser.yulExpression "Lien permanent vers cette définition")
yul-pathyul-function-callyul-literal
_lexer grammar_ SolidityLexer[](#a4.SolidityLexer "Lien permanent vers cette définition")
_rule_ fixed-bytes[](#a4.SolidityLexer.FixedBytes "Lien permanent vers cette définition")
Types d’octets de longueur fixe.
'bytes1''bytes2''bytes3''bytes4''bytes5''bytes6''bytes7''bytes8''bytes9''bytes10''bytes11''bytes12''bytes13''bytes14''bytes15''bytes16''bytes17''bytes18''bytes19''bytes20''bytes21''bytes22''bytes23''bytes24''bytes25''bytes26''bytes27''bytes28''bytes29''bytes30''bytes31''bytes32'
_rule_ number-unit[](#a4.SolidityLexer.NumberUnit "Lien permanent vers cette définition")
Dénomination unitaire pour les nombres.
'wei''gwei''ether''seconds''minutes''hours''days''weeks''years'
_rule_ signed-integer-type[](#a4.SolidityLexer.SignedIntegerType "Lien permanent vers cette définition")
Types d’entiers signés dimensionnés. int est un alias de int256.
'int''int8''int16''int24''int32''int40''int48''int56''int64''int72''int80''int88''int96''int104''int112''int120''int128''int136''int144''int152''int160''int168''int176''int184''int192''int200''int208''int216''int224''int232''int240''int248''int256'
_rule_ unsigned-integer-type[](#a4.SolidityLexer.UnsignedIntegerType "Lien permanent vers cette définition")
Types d’entiers non signés dimensionnés. uint est un alias de uint256.
'uint''uint8''uint16''uint24''uint32''uint40''uint48''uint56''uint64''uint72''uint80''uint88''uint96''uint104''uint112''uint120''uint128''uint136''uint144''uint152''uint160''uint168''uint176''uint184''uint192''uint200''uint208''uint216''uint224''uint232''uint240''uint248''uint256'
_rule_ non-empty-string-literal[](#a4.SolidityLexer.NonEmptyStringLiteral "Lien permanent vers cette définition")
Une chaîne de caractères non vide, entre guillemets, limitée aux caractères imprimables.
'"'double-quoted-printableescape-sequence'"''\\''single-quoted-printableescape-sequence'\\''
_rule_ empty-string-literal[](#a4.SolidityLexer.EmptyStringLiteral "Lien permanent vers cette définition")
Une chaîne littérale vide
'"''"''\\'''\\''
_rule_ single-quoted-printable[](#a4.SolidityLexer.SingleQuotedPrintable "Lien permanent vers cette définition")
Tout caractère imprimable, sauf le guillemet simple ou la barre oblique inversée.
\[\\u0020-\\u0026\\u0028-\\u005B\\u005D-\\u007E\]
_rule_ double-quoted-printable[](#a4.SolidityLexer.DoubleQuotedPrintable "Lien permanent vers cette définition")
Tout caractère imprimable, sauf le guillemet double ou la barre oblique inversée.
\[\\u0020-\\u0021\\u0023-\\u005B\\u005D-\\u007E\]
_rule_ escape-sequence[](#a4.SolidityLexer.EscapeSequence "Lien permanent vers cette définition")
Séquence d’échappement. Outre les séquences d’échappement à un seul caractère, il est possible d’échapper aux sauts de ligne ainsi que les séquences d’échappement unicode à quatre chiffres hexagonaux (uXXXX) et les séquences d’échappement hexagonales à deux chiffres (xXX) sont autorisées.
'\\\\'\['"\\\\nrt\\n\\r\]'u'\[0-9A-Fa-f\]\[0-9A-Fa-f\]\[0-9A-Fa-f\]\[0-9A-Fa-f\]'x'\[0-9A-Fa-f\]\[0-9A-Fa-f\]
_rule_ unicode-string-literal[](#a4.SolidityLexer.UnicodeStringLiteral "Lien permanent vers cette définition")
Un littéral de chaîne de caractères entre guillemets permettant des caractères unicodes arbitraires.
'unicode"'~\["\\r\\n\\\\\]escape-sequence'"''unicode\\''~\['\\r\\n\\\\\]escape-sequence'\\''
_rule_ hex-string[](#a4.SolidityLexer.HexString "Lien permanent vers cette définition")
Les chaînes hexadécimales doivent être composées d’un nombre pair de chiffres hexadécimaux qui peuvent être groupés à l’aide de caractères de soulignement.
'hex''"'\[0-9A-Fa-f\]\[0-9A-Fa-f\]'\_''"''\\''\[0-9A-Fa-f\]\[0-9A-Fa-f\]'\_''\\''
_rule_ hex-number[](#a4.SolidityLexer.HexNumber "Lien permanent vers cette définition")
Les nombres hexadécimaux se composent d’un préfixe et d’un nombre arbitraire de chiffres hexadécimaux qui peuvent être délimités par des traits de soulignement.
'0''x'\[0-9A-Fa-f\]'\_'
_rule_ decimal-number[](#a4.SolidityLexer.DecimalNumber "Lien permanent vers cette définition")
Un littéral de nombre décimal est constitué de chiffres décimaux qui peuvent être délimités par des traits de soulignement et un exposant positif ou négatif facultatif. Si les chiffres contiennent un point décimal, le littéral est de type à virgule fixe.
\[0-9\]'\_'\[0-9\]'\_''.'\[0-9\]'\_'\[eE\]'-'\[0-9\]'\_'
_rule_ identifier[](#a4.SolidityLexer.Identifier "Lien permanent vers cette définition")
Un identifiant dans solidity doit commencer par une lettre, un symbole dollar ou un trait de soulignement et peut en outre contenir des chiffres après le premier symbole.
\[a-zA-Z$\_\]\[a-zA-Z0-9$\_\]
_rule_ yul-evm-builtin[](#a4.SolidityLexer.YulEVMBuiltin "Lien permanent vers cette définition")
Fonctions intégrées dans le dialecte EVM Yul.
'stop''add''sub''mul''div''sdiv''mod''smod''exp''not''lt''gt''slt''sgt''eq''iszero''and''or''xor''byte''shl''shr''sar''addmod''mulmod''signextend''keccak256''pop''mload''mstore''mstore8''sload''sstore''msize''gas''address''balance''selfbalance''caller''callvalue''calldataload''calldatasize''calldatacopy''extcodesize''extcodecopy''returndatasize''returndatacopy''extcodehash''create''create2''call''callcode''delegatecall''staticcall''return''revert''selfdestruct''invalid''log0''log1''log2''log3''log4''chainid''origin''gasprice''blockhash''coinbase''timestamp''number''difficulty''gaslimit''basefee'
_rule_ yul-identifier[](#a4.SolidityLexer.YulIdentifier "Lien permanent vers cette définition")
Les identifiants définis par l’utilisateur sont constitués de lettres, de signes de dollar, d’underscores et de chiffres, mais ne peuvent pas commencer par un chiffre. Dans l’assemblage en ligne, il ne peut y avoir de points dans les identificateurs définis par l’utilisateur. Voir plutôt yulPath pour les expressions consistant en des identificateurs avec des points.
\[a-zA-Z$\_\]\[a-zA-Z0-9$\_\]
_rule_ yul-hex-number[](#a4.SolidityLexer.YulHexNumber "Lien permanent vers cette définition")
Les littéraux hexadécimaux dans Yul consistent en un préfixe et un ou plusieurs chiffres hexadécimaux.
'0''x'\[0-9a-fA-F\]
_rule_ yul-decimal-number[](#a4.SolidityLexer.YulDecimalNumber "Lien permanent vers cette définition")
Les littéraux décimaux dans Yul peuvent être zéro ou toute séquence de chiffres décimaux sans zéros de tête.
'0'\[1-9\]\[0-9\]
_rule_ yul-string-literal[](#a4.SolidityLexer.YulStringLiteral "Lien permanent vers cette définition")
Les chaînes de caractères dans Yul consistent en une ou plusieurs chaînes de caractères entre guillemets ou entre guillemets simples qui peuvent contenir des séquences d’échappement et des caractères imprimables, à l’exception des sauts de ligne non encodés ou des des guillemets doubles ou simples non masqués, respectivement.
'"'double-quoted-printableescape-sequence'"''\\''single-quoted-printableescape-sequence'\\''
_rule_ pragma-token[](#a4.SolidityLexer.PragmaToken "Lien permanent vers cette définition")
Jeton de pragmatisme. Peut contenir n’importe quel type de symbole sauf un point-virgule. Notez qu’actuellement l’analyseur de Solidity ne permet qu’un sous-ensemble de ceci.

# [Solidity — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/) 
 _https://docs.soliditylang.org/zh-cn/latest/_

警告
You are reading a community translation of the Solidity documentation. The Solidity team can give no guarantees on the quality and accuracy of the translations provided. The English reference version is and will remain the only officially supported version by the Solidity team and will always be the most accurate and most up-to-date one. When in doubt, please always refer to the [English (original) documentation](https://docs.soliditylang.org/en/latest/).
Solidity是一门为实现智能合约而创建的面向对象的高级编程语言。 智能合约是管理以太坊中账户行为的程序。
Solidity 是一种面向以太坊虚拟机 (EVM) 的 [带花括号的语言](https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Curly-bracket_languages)。 它受 C++，Python 和 JavaScript 的影响。 您可以在 [语言的影响因素](https://docs.soliditylang.org/zh-cn/latest/language-influences.html) 部分中找到更多有关 Solidity 受哪些语言启发的细节。
Solidity 是静态类型语言，支持继承，库和复杂的用户自定义的类型以及其他特性。
使用 Solidity，您可以创建用于投票、众筹、秘密竞价（盲拍）以及多重签名钱包等用途的合约。
当开发智能合约时，您应该使用最新版本的Solidity。 除某些特殊情况之外，只有最新版本才会收到 [安全修复](https://github.com/ethereum/solidity/security/policy#supported-versions)。 此外，重大的变化以及新功能会定期引入。 目前，我们使用 0.y.z 版本号 [来表明这种快速的变化](https://semver.org/#spec-item-4)。
警告
Solidity最近发布了0.8.x版本，该版本引入了许多重大更新。 请务必阅读 [完整列表](https://docs.soliditylang.org/zh-cn/latest/080-breaking-changes.html)。
始终欢迎改进 Solidity 或此文档的想法, 请阅读我们的 [贡献者指南](https://docs.soliditylang.org/zh-cn/latest/contributing.html) 以了解更多细节。
提示
您可以通过点击左下角的版本号弹出的菜单来选择首选的下载格式来下载该文档的 PDF，HTML 或 Epub 格式。
## 入门指南[](#id4 "此标题的永久链接")
**1\. 了解智能合约基础知识**
如果您是智能合约概念的新手，我们建议您从深入了解“智能合约介绍”部分开始，其中包括：
* 用 Solidity 编写的 [一个简单的智能合约例子](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#simple-smart-contract)。
 
* [区块链基础知识](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#blockchain-basics).
 
* [以太坊虚拟机](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#the-ethereum-virtual-machine).
 
**2\. 了解 Solidity**
一旦您熟悉了基础知识，我们建议您阅读 [“Solidity 示例”](https://docs.soliditylang.org/zh-cn/latest/solidity-by-example.html) 和 “语言描述” 部分，以了解该语言的核心概念。
**3.安装 Solidity 编译器**
有多种方法可以安装 Solidity 编译器， 只需选择您喜欢的选项，并按照 [安装页面](https://docs.soliditylang.org/zh-cn/latest/installing-solidity.html#installing-solidity) 上提供的步骤操作即可。
提示
您可以通过 [Remix IDE](https://remix.ethereum.org/) 在浏览器中直接尝试代码示例。 Remix 是一个基于网络浏览器的IDE，允许您编写，部署和管理Solidity智能合约， 无需在本地安装 Solidity。
警告
由于人类编写的软件可能会存在错误， 因此在编写智能合约时应遵循软件开发的最佳实践。 这包括代码审查，测试，审计和正确性证明。 智能合约用户有时对代码的信心甚至超过了作者， 区块链和智能合约也有其独特的问题需要注意， 因此在开始编写生产代码之前，请确保您已阅读 [安全考虑](https://docs.soliditylang.org/zh-cn/latest/security-considerations.html#security-considerations) 部分。
**4\. 了解更多**
如果您想更深入了解如何在以太坊上构建去中心化应用， [以太坊开发者资源](https://ethereum.org/en/developers/) 可以为您提供有关以太坊的更多文档， 以及各种教程、工具和开发框架。
如果您有任何问题，可以在 [以太坊 StackExchange](https://ethereum.stackexchange.com/) 上， 或者在我们的 [Gitter 频道](https://gitter.im/ethereum/solidity) 上搜索答案或提问。
## 翻译[](#translations "此标题的永久链接")
社区贡献者帮助将本文档翻译成多种语言。 请注意，这些翻译的完整度和及时性各不相同。 因此英文版才是参考的标准。
您可以通过点击左下角的语言切换器来切换语言。 在弹出的菜单中，选择您需要的语言即可切换。
* [简体中文](https://docs.soliditylang.org/zh/latest/)
 
* [法语](https://docs.soliditylang.org/fr/latest/)
 
* [印度尼西亚语](https://github.com/solidity-docs/id-indonesian)
 
* [日语](https://github.com/solidity-docs/ja-japanese)
 
* [韩语](https://github.com/solidity-docs/ko-korean)
 
* [波斯语](https://github.com/solidity-docs/fa-persian)
 
* [俄语](https://github.com/solidity-docs/ru-russian)
 
* [西班牙语](https://github.com/solidity-docs/es-spanish)
 
* [土耳其语](https://docs.soliditylang.org/tr/latest/)
 
备注
我们建立了一个 GitHub 组织和翻译工作流程，以帮助简化社区的工作。 请参考 [solidity-文档 组织](https://github.com/solidity-docs) 中的翻译指南， 了解如何开启新的语言翻译或为社区翻译做出贡献。

# [Resources — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/resources.html) 
 _https://docs.soliditylang.org/en/v0.8.30/resources.html_

## General Resources[](#general-resources "Link to this heading")
* [Ethereum.org Developers page](https://ethereum.org/en/developers/)
 
* [Ethereum StackExchange](https://ethereum.stackexchange.com/)
 
* [Solidity website](https://soliditylang.org/)
 
* [Solidity changelog](https://github.com/ethereum/solidity/blob/develop/Changelog.md)
 
* [Solidity codebase on GitHub](https://github.com/ethereum/solidity/)
 
* [Solidity language users chat](https://matrix.to/#/#ethereum_solidity:gitter.im)
 
* [Solidity compiler developers chat](https://matrix.to/#/#ethereum_solidity-dev:gitter.im)
 
* [awesome-solidity](https://github.com/bkrem/awesome-solidity)
 
* [Solidity by Example](https://solidity-by-example.org/)
 
* [Solidity documentation community translations](https://github.com/solidity-docs)
 
## Integrated (Ethereum) Development Environments[](#integrated-ethereum-development-environments "Link to this heading")
* [Ape](https://docs.apeworx.io/ape)
 
 A Python-based web3 development tool for compiling, testing, and interacting with smart contracts.
 
* [Brownie](https://eth-brownie.readthedocs.io/en/stable/)
 
 A Python-based development and testing framework for smart contracts targeting the Ethereum Virtual Machine. 💡 Note: As per the official docs, Brownie is no longer actively maintained. Future releases may come sporadically - or never at all. Check out Ape Framework (first in list) for all your python Ethereum development needs.
 
* [Dapp](https://dapp.tools/)
 
 Tool for building, testing and deploying smart contracts from the command-line.
 
* [Foundry](https://github.com/foundry-rs/foundry)
 
 Fast, portable and modular toolkit for Ethereum application development written in Rust.
 
* [Hardhat](https://hardhat.org/)
 
 Ethereum development environment with local Ethereum network, debugging features and plugin ecosystem.
 
* [Remix](https://remix.ethereum.org/)
 
 Browser-based IDE with integrated compiler and Solidity runtime environment without server-side components.
 
* [Truffle](https://trufflesuite.com/truffle/)
 
 Ethereum development framework. 💡 Note: Consensys announced the sunset of Truffle on September 21, 2023. Current users may check out the migration path and available product support [here.](https://consensys.io/blog/consensys-announces-the-sunset-of-truffle-and-ganache-and-new-hardhat)
 
## Editor Integrations[](#editor-integrations "Link to this heading")
* Emacs
 
 > * [Emacs Solidity](https://github.com/ethereum/emacs-solidity/)
 > 
 > Plugin for the Emacs editor providing syntax highlighting and compilation error reporting.
 > 
 
* IntelliJ
 
 > * [IntelliJ IDEA plugin](https://plugins.jetbrains.com/plugin/9475-solidity/)
 > 
 > Solidity plugin for IntelliJ IDEA (and all other JetBrains IDEs).
 > 
 
* Sublime Text
 
 > * [Package for SublimeText - Solidity language syntax](https://packagecontrol.io/packages/Ethereum/)
 > 
 > Solidity syntax highlighting for SublimeText editor.
 > 
 
* Vim
 
 > * [Vim Solidity by Thesis](https://github.com/thesis/vim-solidity/)
 > 
 > Syntax highlighting for Solidity in Vim.
 > 
 > * [Vim Solidity by TovarishFin](https://github.com/TovarishFin/vim-solidity)
 > 
 > Vim syntax file for Solidity.
 > 
 > * [Vim Syntastic](https://github.com/vim-syntastic/syntastic)
 > 
 > Plugin for the Vim editor providing compile checking.
 > 
 
* Visual Studio Code (VS Code)
 
 > * [Ethereum Remix Visual Studio Code extension](https://github.com/ethereum/remix-vscode)
 > 
 > Ethereum Remix extension pack for VS Code 💡 Note: As per the official repository, this extension has been removed from the VSCODE marketplace and will be replaced by a dedicated stand-alone desktop application.
 > 
 > * [Solidity Visual Studio Code extension, by Juan Blanco](https://juan.blanco.ws/solidity-contracts-in-visual-studio-code/)
 > 
 > Solidity plugin for Microsoft Visual Studio Code that includes syntax highlighting and the Solidity compiler.
 > 
 > * [Solidity Visual Studio Code extension, by Nomic Foundation](https://marketplace.visualstudio.com/items?itemName=NomicFoundation.hardhat-solidity)
 > 
 > Solidity and Hardhat support by the Hardhat team, including: syntax highlighting, jump to definition, renames, quick fixes and inline solc warnings and errors.
 > 
 > * [Solidity Visual Auditor extension](https://marketplace.visualstudio.com/items?itemName=tintinweb.solidity-visual-auditor)
 > 
 > Adds security centric syntax and semantic highlighting to Visual Studio Code.
 > 
 > * [Truffle for VS Code](https://marketplace.visualstudio.com/items?itemName=trufflesuite-csi.truffle-vscode)
 > 
 > Build, debug and deploy smart contracts on Ethereum and EVM-compatible blockchains. 💡 Note: This extension has built-in support for the Truffle Suite which is being sunset. For information on ongoing support, migration options and FAQs, visit the [Consensys blog.](https://consensys.io/blog/consensys-announces-the-sunset-of-truffle-and-ganache-and-new-hardhat)
 > 
 
## Solidity Tools[](#solidity-tools "Link to this heading")
* [ABI to Solidity interface converter](https://gist.github.com/chriseth/8f533d133fa0c15b0d6eaf3ec502c82b)
 
 A script for generating contract interfaces from the ABI of a smart contract.
 
* [abi-to-sol](https://github.com/gnidan/abi-to-sol)
 
 Tool to generate Solidity interface source from a given ABI JSON.
 
* [Aderyn](https://github.com/Cyfrin/aderyn)
 
 Rust-based solidity smart contract static analyzer designed to help find vulnerabilities in Solidity code bases.
 
* [Doxity](https://github.com/DigixGlobal/doxity)
 
 Documentation Generator for Solidity.
 
* [ethdebug](https://github.com/ethdebug/format)
 
 A standard debugging data format for smart contracts on Ethereum-compatible networks.
 
* [Ethlint](https://github.com/duaraghav8/Ethlint)
 
 Linter to identify and fix style and security issues in Solidity.
 
* [evmdis](https://github.com/Arachnid/evmdis)
 
 EVM Disassembler that performs static analysis on the bytecode to provide a higher level of abstraction than raw EVM operations.
 
* [EVM Lab](https://github.com/ethereum/evmlab/)
 
 A collection of tools to interact with the EVM. The package includes a VM, Etherchain API, and a trace-viewer with gas cost display.
 
* [hevm](https://github.com/dapphub/dapptools/tree/master/src/hevm#readme)
 
 EVM debugger and symbolic execution engine.
 
* [leafleth](https://github.com/clemlak/leafleth)
 
 A documentation generator for Solidity smart-contracts.
 
* [Scaffold-ETH 2](https://github.com/scaffold-eth/scaffold-eth-2)
 
 Forkable Ethereum development stack focused on fast product iterations.
 
* [sol2uml](https://www.npmjs.com/package/sol2uml)
 
 Unified Modeling Language (UML) class diagram generator for Solidity contracts.
 
* [solc-select](https://github.com/crytic/solc-select)
 
 A script to quickly switch between Solidity compiler versions.
 
* [Solidity prettier plugin](https://github.com/prettier-solidity/prettier-plugin-solidity)
 
 A Prettier Plugin for Solidity.
 
* [Solidity REPL](https://github.com/raineorshine/solidity-repl)
 
 Try Solidity instantly with a command-line Solidity console.
 
* [solgraph](https://github.com/raineorshine/solgraph)
 
 Visualize Solidity control flow and highlight potential security vulnerabilities.
 
* [Solhint](https://github.com/protofire/solhint)
 
 Solidity linter that provides security, style guide and best practice rules for smart contract validation.
 
* [Sourcify](https://sourcify.dev/)
 
 Decentralized automated contract verification service and public repository of contract metadata.
 
* [Sūrya](https://github.com/ConsenSys/surya/)
 
 Utility tool for smart contract systems, offering a number of visual outputs and information about the contracts’ structure. Also supports querying the function call graph.
 
* [Universal Mutator](https://github.com/agroce/universalmutator)
 
 A tool for mutation generation, with configurable rules and support for Solidity and Vyper.
 
* [Wake](https://github.com/Ackee-Blockchain/wake)
 
 A Python-based Solidity development and testing framework with built-in vulnerability detectors.
 
## Third-Party Solidity Parsers and Grammars[](#third-party-solidity-parsers-and-grammars "Link to this heading")
* [Solidity Parser for JavaScript](https://github.com/solidity-parser/parser)
 
 A Solidity parser for JS built on top of a robust ANTLR4 grammar.

# [L’optimiseur — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/internals/optimizer.html) 
 _https://docs.soliditylang.org/fr/latest/internals/optimizer.html_

Le compilateur Solidity utilise deux modules d’optimisation différents : L“« ancien » optimiseur qui opère au niveau de l’opcode et le « nouvel » optimiseur qui opère sur le code Yul IR.
L’optimiseur basé sur les opcodes applique un ensemble de [règles de simplification](https://github.com/ethereum/solidity/blob/develop/libevmasm/RuleList.h) aux opcodes. Il combine également des ensembles de codes égaux et supprime le code inutilisé.
L’optimiseur basé sur Yul est beaucoup plus puissant, car il peut travailler à travers les appels de fonctions. Par exemple, les sauts arbitraires ne sont pas possibles dans Yul, il est possible de calculer les effets secondaires de chaque fonction. Considérons deux appels de fonction, où la première ne modifie pas le stockage et la seconde le fait. Si leurs arguments et valeurs de retour ne dépendent pas les uns des autres, nous pouvons réordonner les appels de fonction. De même, si une fonction est sans effet secondaire et que son résultat est multiplié par zéro, on peut supprimer complètement l’appel de fonction.
Actuellement, le paramètre `--optimize` active l’optimiseur basé sur le code optique pour le bytecode généré et l’optimiseur Yul pour le code Yul généré en interne, par exemple pour ABI coder v2. On peut utiliser `solc --ir-optimized --optimize` pour produire un Yul expérimental optimisé pour une source Solidity. De même, on peut utiliser `solc --strict-assembly --optimize` pour un mode Yul autonome.
Vous pouvez trouver plus de détails sur les deux modules d’optimisation et leurs étapes d’optimisation ci-dessous.
## Avantages de l’optimisation du code Solidity[](#avantages-de-l-optimisation-du-code-solidity "Lien permanent vers cette rubrique")
Globalement, l’optimiseur tente de simplifier les expressions compliquées, ce qui réduit à la fois la taille du code et le coût d’exécution, c’est-à-dire qu’il peut réduire le gaz nécessaire au déploiement du contrat ainsi qu’aux appels externes faits au contrat. Il spécialise également les fonctions ou les met en ligne. En particulier, l’inlining de fonctions est une opération qui peut entraîner un code beaucoup plus gros, mais elle est souvent effectuée car elle permet d’obtenir des simplifications supplémentaires.
## Différences entre le code optimisé et le code non optimisé[](#differences-entre-le-code-optimise-et-le-code-non-optimise "Lien permanent vers cette rubrique")
En général, la différence la plus visible est que les expressions constantes sont évaluées au moment de la compilation. En ce qui concerne la sortie ASM, on peut également noter une réduction des blocs de code équivalents ou dupliqués (comparez la sortie des drapeaux `--asm` et `--asm --optimize`). Cependant, lorsqu’il s’agit de la représentation Yul/intermédiaire, il peut y avoir des différences significatives, par exemple, les fonctions peuvent être inlined, combinées ou réécrites pour redondances, etc. (comparez la sortie entre les drapeaux `--ir` et `--optimize --ir-optimized`).
## Exécution des paramètres de l’optimiseur[](#execution-des-parametres-de-l-optimiseur "Lien permanent vers cette rubrique")
Le nombre d’exécutions (`--optimize-runs`) spécifie approximativement combien de fois chaque opcode du code déployé sera exécuté pendant la durée de vie du contrat. Cela signifie qu’il s’agit d’un paramètre de compromis entre la taille du code (coût de déploiement) et le coût d’exécution du code (coût après déploiement). Un paramètre « runs » de « 1 » produira un code court mais coûteux. En revanche, un paramètre « runs » plus grand produira un code plus long mais plus efficace en termes de gaz. La valeur maximale du paramètre est `2**32-1`.
Note
Une idée fausse courante est que ce paramètre spécifie le nombre d’itérations de l’optimiseur. Ce n’est pas vrai : l’optimiseur s’exécutera toujours autant de fois qu’il peut encore améliorer le code.
## Module d’optimisation basé sur l’opcode[](#module-d-optimisation-base-sur-l-opcode "Lien permanent vers cette rubrique")
Le module d’optimisation basé sur le code opcode opère sur le code assembleur. Il divise la séquence d’instructions en blocs de base aux `JUMPs` et `JUMPDESTs`. À l’intérieur de ces blocs, l’optimiseur analyse les instructions et enregistre chaque modification de la pile, de la mémoire ou du stockage sous la forme d’une expression constituée d’une instruction et une liste d’arguments qui sont des pointeurs vers d’autres expressions.
De plus, l’optimiseur basé sur les opcodes utilise un composant appelé « CommonSubexpressionEliminator » qui, entre autres, trouve les expressions qui sont toujours égales (sur chaque entrée) et les combine en une classe d’expressions. Il essaie d’abord de trouver chaque nouvelle expression dans une liste d’expressions déjà connues. Si aucune correspondance n’est trouvée, il simplifie l’expression selon des règles comme `constant + constant = sum_of_constants` ou `X * 1 = X`. Comme il s’agit d’un processus récursif, nous pouvons également appliquer cette dernière règle si le deuxième facteur est une expression plus complexe dont nous savons que l’évaluation est toujours égale à un.
Certaines étapes de l’optimiseur suivent symboliquement les emplacements de stockage et de mémoire. Par exemple, cela est utilisée pour calculer les hachages Keccak-256 qui peuvent être évalués lors de la compilation. Considérons la séquence :
PUSH 32
PUSH 0
CALLDATALOAD
PUSH 100
DUP2
MSTORE
KECCAK256
ou l’équivalent Yul
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.12&code=bGV0IHggOj0gY2FsbGRhdGFsb2FkKDApCm1zdG9yZSh4LCAxMDApCmxldCB2YWx1ZSA6PSBrZWNjYWsyNTYoeCwgMzIp)
let x := calldataload(0)
mstore(x, 100)
let value := keccak256(x, 32)
Dans ce cas, l’optimiseur suit la valeur à un emplacement mémoire `calldataload(0)` et réalise que le hachage Keccak-256 peut être évalué au moment de la compilation. Cela ne fonctionne que s’il n’y a pas autre instruction qui modifie la mémoire entre le `mstore` et le `keccak256`. Donc s’il y a une instruction qui écrit dans la mémoire (ou le stockage), alors nous devons effacer la connaissance de la mémoire (ou stockage) actuelle. Il y a cependant une exception à cet effacement, lorsque nous pouvons facilement voir que l’instruction n’écrit pas à un certain endroit.
Par exemple,
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.12&code=bGV0IHggOj0gY2FsbGRhdGFsb2FkKDApCm1zdG9yZSh4LCAxMDApCi8vIEVtcGxhY2VtZW50IGRlIGxhIG3DqW1vaXJlIGRlIGxhIGNvbm5haXNzYW5jZSBhY3R1ZWxsZSB4IC0+IDEwMApsZXQgeSA6PSBhZGQoeCwgMzIpCi8vIE4nZWZmYWNlIHBhcyBsYSBjb25uYWlzc2FuY2UgcXVlIHggLT4gMTAwLCBwdWlzcXVlIHkgbifDqWNyaXQgcGFzIGRhbnMgW3gsIHggKyAzMikKbXN0b3JlKHksIDIwMCkKLy8gQ2UgS2VjY2FrLTI1NiBwZXV0IG1haW50ZW5hbnQgw6p0cmUgw6l2YWx1w6kuCmxldCB2YWx1ZSA6PSBrZWNjYWsyNTYoeCwgMzIp)
let x := calldataload(0)
mstore(x, 100)
// Emplacement de la mémoire de la connaissance actuelle x -> 100
let y := add(x, 32)
// N'efface pas la connaissance que x -> 100, puisque y n'écrit pas dans \[x, x + 32)
mstore(y, 200)
// Ce Keccak-256 peut maintenant être évalué.
let value := keccak256(x, 32)
Par conséquent, les modifications apportées aux emplacements de stockage et de mémoire, par exemple à l’emplacement `l`, doivent effacer la connaissance des emplacements de stockage ou de mémoire qui peuvent être égaux à `l`. Plus précisément, pour le stockage, l’optimiseur doit effacer toute connaissance des emplacements symboliques, qui peuvent être égaux à `l`. Et, pour la mémoire, l’optimiseur doit effacer toute connaissance des emplacements symboliques qui ne sont pas au moins 32 octets. Si `m` représente un emplacement arbitraire, alors la décision d’effacement est prise en calculant la valeur `sub(l, m)`. Pour le stockage, si cette valeur s’évalue à un littéral qui est non-zéro, alors la connaissance de `m` sera conservée. Pour la mémoire, si la valeur correspond à une valeur littérale comprise entre `32` et `2**256 - 32`, alors la connaissance de `m` sera conservée. Dans tous les autres cas, la connaissance de `m` sera effacée.
Après ce processus, nous savons quelles expressions doivent se trouver sur la pile à la fin, et nous avons une liste des modifications de la mémoire et du stockage. Ces informations sont stockées avec les blocs de base et est utilisée pour les relier. En outre, les connaissances sur la configuration de la pile, du stockage et de la mémoire sont transmises au(x) bloc(s) suivant(s).
Si nous connaissons les cibles de toutes les instructions `JUMP` et `JUMPI`, nous pouvons construire un graphe complet du flux de contrôle du programme. S’il y a seulement une cible que nous ne connaissons pas (cela peut arriver car en principe, les cibles de saut peuvent être calculées à partir des entrées), nous devons effacer toute connaissance sur l’état d’entrée d’un bloc car il peut être la cible du `JUMP` inconnu. Si le module d’optimisation basé sur les opcodes d’opération trouve un `JUMPI` dont la condition s’évalue à une constante, il le transforme en un saut inconditionnel.
Comme dernière étape, le code de chaque bloc est re-généré. L’optimiseur crée un graphe de dépendance à partir des expressions sur la pile à la fin du bloc, et il abandonne toute opération qui ne fait pas partie de ce graphe. Il génère du code qui applique les modifications à la mémoire et au stockage dans l’ordre dans lequel elles ont été faites dans le code d’origine (en abandonnant les modifications qui ne sont pas nécessaires). Enfin, il génère toutes les valeurs qui doivent se trouver sur la pile au bon endroit.
Ces étapes sont appliquées à chaque bloc de base et le code nouvellement généré est utilisé comme remplacement s’il est plus petit. Si un bloc de base est divisé à un `JUMPI` et que pendant l’analyse, la condition s’évalue à une constante, le `JUMPI` est remplacé en fonction de la valeur de la constante. Ainsi, un code comme
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=dWludCB4ID0gNzsKZGF0YVs3XSA9IDk7CmlmIChkYXRhW3hdICE9IHggKyAyKSAvLyBjZXR0ZSBjb25kaXRpb24gbidlc3QgamFtYWlzIHZyYWllCiAgcmV0dXJuIDI7CmVsc2UKICByZXR1cm4gMTs=)
uint x \= 7;
data\[7\] \= 9;
if (data\[x\] != x + 2) // cette condition n'est jamais vraie
 return 2;
else
 return 1;
se simplifie comme suit :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZGF0YVs3XSA9IDk7CnJldHVybiAxOw==)
### Doublure simple[](#doublure-simple "Lien permanent vers cette rubrique")
Depuis la version 0.8.2 de Solidity, il existe une autre étape d’optimisation qui remplace certains sauts vers des blocs contenant des instructions « simples » se terminant par un « saut » par une copie de ces instructions. Cela correspond à l’inlining de petites fonctions simples de Solidity ou de Yul. En particulier, la séquence `PUSHTAG(tag) JUMP` peut être remplacée, dès lors que le `JUMP` est marqué comme un saut « dans » une fonction et que derrière le `tag` se trouve un bloc de base (comme décrit ci-dessus pour la fonction « CommonSubexpressionEliminator ») qui se termine par un autre `JUMP` marqué comme étant un saut « hors » d’une fonction.
En particulier, considérez l’exemple prototypique suivant d’assemblage généré pour un appel à une fonction interne de Solidity :
 tag\_return
 tag\_f
 jump // sur
tag\_return:
 ...opcodes après l'appel à f...
tag\_f:
 ...corps de fonction f...
 jump // hors
Tant que le corps de la fonction est un bloc de base continu, le « Inliner » peut remplacer `tag_f jump` par le bloc à `tag_f`, ce qui donne :
 tag\_return
 ...corps de fonction f...
 jump
tag\_return:
 ...opcodes après l'appel à f...
tag\_f:
 ...corps de fonction f...
 jump // hors
Maintenant, idéalement, les autres étapes de l’optimiseur décrites ci-dessus auront pour résultat de déplacer le push de la balise de retour vers le saut restant, résultant en :
 ...corps de fonction f...
 tag\_return
 jump
tag\_return:
 ...opcodes après l'appel à f...
tag\_f:
 ...corps de fonction f...
 jump // out
Dans cette situation, le « PeepholeOptimizer » supprimera le saut de retour. Idéalement, tout ceci peut être fait pour toutes les références à `tag_f` en le laissant inutilisé, s.t. il peut être enlevé, donnant :
...corps de fonction f...
...opcodes après l'appel à f...
Ainsi, l’appel à la fonction `f` est inlined et la définition originale de `f` peut être supprimée.
Un tel inlining est tenté chaque fois qu’une heuristique suggère que l’inlining est moins coûteux sur la durée de vie d’un contrat que de ne pas le faire. Cette heuristique dépend de la taille du corps de la fonction, du nombre d’autres références à sa balise (approximativement le nombre d’appels à la fonction) et le nombre prévu d’exécutions du contrat (le paramètre « runs » de l’optimiseur global).
## Module optimiseur basé sur Yul[](#module-optimiseur-base-sur-yul "Lien permanent vers cette rubrique")
L’optimiseur basé sur Yul se compose de plusieurs étapes et composants qui transforment tout l’AST d’une manière sémantiquement équivalente. L’objectif est d’obtenir un code plus court ou au moins légèrement plus long, mais qui permettra d’autres étapes d’optimisation.
Avertissement
L’optimiseur étant en cours de développement, les informations fournies ici peuvent être obsolètes. Si vous dépendez d’une certaine fonctionnalité, veuillez contacter l’équipe directement.
L’optimiseur suit actuellement une stratégie purement avide et ne fait aucun retour en arrière.
Tous les composants du module optimiseur basé sur Yul sont expliqués ci-dessous. Les étapes de transformation suivantes sont les principaux composants :
* Transformation SSA
 
* Éliminateur de sous-expression commune
 
* Simplicateur d’expression
 
* Eliminateur d’assignation redondante
 
* Inliner complet
 
### Étapes de l’optimiseur[](#etapes-de-l-optimiseur "Lien permanent vers cette rubrique")
Il s’agit d’une liste de toutes les étapes de l’optimiseur basé sur Yul, classées par ordre alphabétique. Vous pouvez trouver plus d’informations sur les étapes individuelles et leur séquence ci-dessous.
* [BlockFlattener](#block-flattener).
 
* [CircularReferencesPruner](#circular-reference-pruner).
 
* [CommonSubexpressionEliminator](#common-subexpression-eliminator).
 
* [ConditionalSimplifier](#conditional-simplifier).
 
* [ConditionalUnsimplifier](#conditional-unsimplifier).
 
* [ControlFlowSimplifier](#control-flow-simplifier).
 
* [DeadCodeEliminator](#dead-code-eliminator).
 
* [EqualStoreEliminator](#equal-store-eliminator).
 
* [EquivalentFunctionCombiner](#equivalent-function-combiner).
 
* [ExpressionJoiner](#expression-joiner).
 
* [Expression Simplifier](#expression-simplifier).
 
* [ExpressionSplitter](#expression-splitter).
 
* [ForLoopConditionIntoBody](#for-loop-condition-into-body).
 
* [ForLoopConditionOutOfBody](#for-loop-condition-out-of-body).
 
* [ForLoopInitRewriter](#for-loop-init-rewriter).
 
* [ExpressionInliner](#expression-inliner).
 
* [FullInliner](#full-inliner).
 
* [FunctionGrouper](#function-grouper).
 
* [FunctionHoister](#function-hoister).
 
* [FunctionSpecializer](#function-specializer).
 
* [LiteralRematerialiser](#literal-rematerialiser).
 
* [LoadResolver](#load-resolver).
 
* [LoopInvariantCodeMotion](#loop-invariant-code-motion).
 
* [RedundantAssignEliminator](#redundant-assign-eliminator).
 
* [ReasoningBasedSimplifier](#reasoning-based-simplifier).
 
* [Rematerialiser](#rematerialiser).
 
* [SSAReverser](#ssa-reverser).
 
* [SSATransform](#ssa-transform).
 
* [StructuralSimplifier](#structural-simplifier).
 
* [UnusedFunctionParameterPruner](#unused-function-parameter-pruner).
 
* [UnusedPruner](#unused-pruner).
 
* [VarDeclInitializer](#var-decl-initializer).
 
### Sélection des optimisations[](#selection-des-optimisations "Lien permanent vers cette rubrique")
Par défaut, l’optimiseur applique sa séquence prédéfinie d’étapes d’optimisation à l’assemblage généré. Vous pouvez remplacer cette séquence et fournir la vôtre en utilisant l’option `--yul-optimizations` :
solc --optimize --ir-optimized --yul-optimizations 'dhfoD\[xarrscLMcCTU\]uljmul'
La séquence à l’intérieur de `[...]` sera appliquée plusieurs fois dans une boucle jusqu’à ce que le code Yul reste inchangé ou jusqu’à ce que le nombre maximum de tours (actuellement 12) ait été atteint.
Les abréviations disponibles sont listées dans les docs [Yul optimizer](https://docs.soliditylang.org/fr/latest/internals/yul.rst#optimization-step-sequence).
### Prétraitement[](#pretraitement "Lien permanent vers cette rubrique")
Les composants de prétraitement effectuent des transformations pour mettre le programme dans une certaine forme normale avec laquelle il est plus facile de travailler. Cette forme normale est conservée pendant le reste du processus d’optimisation.
#### Disambiguateur[](#disambiguateur "Lien permanent vers cette rubrique")
Le désambiguïsateur prend un AST et retourne une copie fraîche où tous les identifiants ont des noms uniques dans l’AST d’entrée. C’est une condition préalable pour toutes les autres étapes de l’optimiseur. Un des avantages est que la recherche d’identificateurs n’a pas besoin de prendre en compte les scopes, ce qui simplifie l’analyse nécessaire pour les autres étapes.
Toutes les étapes suivantes ont la propriété que tous les noms restent uniques. Cela signifie que si un nouvel identifiant doit être introduit, un nouveau nom unique est généré.
#### FunctionHoister[](#functionhoister "Lien permanent vers cette rubrique")
Le hoister de fonction déplace toutes les définitions de fonction à la fin du bloc le plus haut. Il s’agit d’une une transformation sémantiquement équivalente tant qu’elle est effectuée après l’étape de désambiguïsation. La raison en est que le déplacement d’une définition vers un bloc de niveau supérieur ne peut pas diminuer sa visibilité et il est impossible de référencer des variables définies dans une autre fonction.
L’avantage de cette étape est que les définitions de fonctions peuvent être recherchées plus facilement, et les fonctions peuvent être optimisées de manière isolée sans avoir à traverser complètement l’AST.
#### FunctionGrouper[](#functiongrouper "Lien permanent vers cette rubrique")
Le groupeur de fonctions doit être appliqué après le désambiguïsateur et le hachoir de fonctions. Son effet est que tous les éléments les plus hauts qui ne sont pas des définitions de fonction sont déplacés dans un seul bloc qui est la première déclaration du bloc racine.
Après cette étape, un programme a la forme normale suivante :
Où `I` est un bloc (potentiellement vide) qui ne contient aucune définition de fonction (même pas de manière récursive), et `F` est une liste de définitions de fonctions telle qu’aucune fonction ne contient une définition de fonction.
L’avantage de cette étape est que nous savons toujours où commence la liste des fonctions.
#### ForLoopConditionIntoBody[](#forloopconditionintobody "Lien permanent vers cette rubrique")
Cette transformation déplace la condition d’itération de boucle d’une boucle for dans le corps de la boucle. Nous avons besoin de cette transformation car [ExpressionSplitter](#expression-splitter) ne s’appliquera pas aux expressions de condition d’itération (le `C` dans l’exemple suivant).
for { Init... } C { Post... } {
 Body...
}
est transformé en
for { Init... } 1 { Post... } {
 if iszero(C) { break }
 Body...
}
Cette transformation peut également être utile lorsqu’elle est couplée avec `LoopInvariantCodeMotion`, puisque les invariants des conditions invariantes de la boucle peuvent alors être pris en dehors de la boucle.
#### ForLoopInitRewriter[](#forloopinitrewriter "Lien permanent vers cette rubrique")
Cette transformation permet de déplacer la partie d’initialisation d’une boucle for avant la boucle :
for { Init... } C { Post... } {
 Body...
}
est transformé en
Init...
for {} C { Post... } {
 Body...
}
Cela facilite le reste du processus d’optimisation car nous pouvons ignorer les règles de scoping compliquées du bloc d’initialisation de la boucle for.
#### VarDeclInitializer[](#vardeclinitializer "Lien permanent vers cette rubrique")
Cette étape réécrit les déclarations de variables afin qu’elles soient toutes initialisées. Les déclarations comme `let x, y` sont divisées en plusieurs déclarations.
Pour l’instant, elle ne supporte que l’initialisation avec le littéral zéro.
### Transformation Pseudo-SSA[](#transformation-pseudo-ssa "Lien permanent vers cette rubrique")
Le but de ce composant est de mettre le programme sous une forme plus longue, afin que les autres composants puissent plus facilement travailler avec lui. La représentation finale sera similaire à une forme SSA (static-single-assignment), à la différence qu’elle ne fait pas appel à des fonctions « phi » explicites qui combinent les valeurs provenant de différentes branches du flux de contrôle, car une telle fonctionnalité n’existe pas dans le langage Yul. Au lieu de cela, lors de la fusion du flux de contrôle, si une variable est réaffectée dans l’une des branches, une nouvelle variable SSA est déclarée pour contenir sa valeur actuelle, de sorte que les expressions suivantes ne doivent toujours faire référence qu’à des variables SSA.
Un exemple de transformation est le suivant :
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.12&code=ewogICAgbGV0IGEgOj0gY2FsbGRhdGFsb2FkKDApCiAgICBsZXQgYiA6PSBjYWxsZGF0YWxvYWQoMHgyMCkKICAgIGlmIGd0KGEsIDApIHsKICAgICAgICBiIDo9IG11bChiLCAweDIwKQogICAgfQogICAgYSA6PSBhZGQoYSwgMSkKICAgIHNzdG9yZShhLCBhZGQoYiwgMHgyMCkpCn0=)
{
 let a := calldataload(0)
 let b := calldataload(0x20)
 if gt(a, 0) {
 b := mul(b, 0x20)
 }
 a := add(a, 1)
 sstore(a, add(b, 0x20))
}
Lorsque toutes les étapes de transformation suivantes sont appliquées, le programme aura l’aspect suivant comme suit :
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.12&code=ewogICAgbGV0IF8xIDo9IDAKICAgIGxldCBhXzkgOj0gY2FsbGRhdGFsb2FkKF8xKQogICAgbGV0IGEgOj0gYV85CiAgICBsZXQgXzIgOj0gMHgyMAogICAgbGV0IGJfMTAgOj0gY2FsbGRhdGFsb2FkKF8yKQogICAgbGV0IGIgOj0gYl8xMAogICAgbGV0IF8zIDo9IDAKICAgIGxldCBfNCA6PSBndChhXzksIF8zKQogICAgaWYgXzQKICAgIHsKICAgICAgICBsZXQgXzUgOj0gMHgyMAogICAgICAgIGxldCBiXzExIDo9IG11bChiXzEwLCBfNSkKICAgICAgICBiIDo9IGJfMTEKICAgIH0KICAgIGxldCBiXzEyIDo9IGIKICAgIGxldCBfNiA6PSAxCiAgICBsZXQgYV8xMyA6PSBhZGQoYV85LCBfNikKICAgIGxldCBfNyA6PSAweDIwCiAgICBsZXQgXzggOj0gYWRkKGJfMTIsIF83KQogICAgc3N0b3JlKGFfMTMsIF84KQp9)
{
 let \_1 := 0
 let a\_9 := calldataload(\_1)
 let a := a\_9
 let \_2 := 0x20
 let b\_10 := calldataload(\_2)
 let b := b\_10
 let \_3 := 0
 let \_4 := gt(a\_9, \_3)
 if \_4
 {
 let \_5 := 0x20
 let b\_11 := mul(b\_10, \_5)
 b := b\_11
 }
 let b\_12 := b
 let \_6 := 1
 let a\_13 := add(a\_9, \_6)
 let \_7 := 0x20
 let \_8 := add(b\_12, \_7)
 sstore(a\_13, \_8)
}
Notez que la seule variable qui est réassignée dans cet extrait est `b`. Cette réaffectation ne peut être évitée car `b` a des valeurs différentes en fonction du flux de contrôle. Toutes les autres variables ne changent jamais de valeur une fois qu’elles sont définies. L’avantage de cette propriété est que les variables peuvent être déplacées librement et les références à celles-ci peuvent être échangées par leur valeur initiale (et vice-versa), tant que ces valeurs sont encore valables dans le nouveau contexte.
Bien sûr, le code ici est loin d’être optimisé. Au contraire, il est beaucoup plus long. L’espoir est que ce code soit plus facile à travailler et que, de plus, il y a des étapes d’optimisation qui annulent ces changements et rendent le code plus compact à la fin.
#### ExpressionSplitter[](#expressionsplitter "Lien permanent vers cette rubrique")
Le séparateur d’expression transforme des expressions comme `add(mload(0x123), mul(mload(0x456), 0x20))` en une séquence de déclarations de variables uniques auxquelles sont attribuées des sous-expressions de cette expression, de sorte que chaque appel de fonction n’a que des variables comme arguments.
Ce qui précède serait transformé en
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.12&code=ewogICAgbGV0IF8xIDo9IDB4MjAKICAgIGxldCBfMiA6PSAweDQ1NgogICAgbGV0IF8zIDo9IG1sb2FkKF8yKQogICAgbGV0IF80IDo9IG11bChfMywgXzEpCiAgICBsZXQgXzUgOj0gMHgxMjMKICAgIGxldCBfNiA6PSBtbG9hZChfNSkKICAgIGxldCB6IDo9IGFkZChfNiwgXzQpCn0=)
{
 let \_1 := 0x20
 let \_2 := 0x456
 let \_3 := mload(\_2)
 let \_4 := mul(\_3, \_1)
 let \_5 := 0x123
 let \_6 := mload(\_5)
 let z := add(\_6, \_4)
}
Notez que cette transformation ne change pas l’ordre des opcodes ou des appels de fonction.
Elle n’est pas appliquée à la condition d’itération de la boucle, car le flux de contrôle de la boucle ne permet pas ce « contournement » des expressions internes dans tous les cas. Nous pouvons contourner cette limitation en appliquant la condition-boucle-for-dans-corps pour déplacer la condition d’itération dans le corps de la boucle.
Le programme final doit être sous une forme telle que (à l’exception des conditions de boucle) les appels de fonction ne peuvent pas être imbriqués dans des expressions et tous les arguments des appels de fonction doivent être des variables.
Les avantages de cette forme sont qu’il est beaucoup plus facile de réorganiser la séquence des opcodes et il est également plus facile d’effectuer l’inlining des appels de fonction. En outre, il est plus simple de remplacer des parties individuelles d’expressions ou de réorganiser l“« arbre d’expression ». L’inconvénient est qu’un tel code est beaucoup plus difficile à lire pour les humains.
#### SSATransform[](#ssatransform "Lien permanent vers cette rubrique")
Cette étape tente de remplacer les affectations répétées à existantes par des déclarations de nouvelles variables. Les réaffectations sont toujours présentes, mais toutes les références aux variables réaffectées sont remplacées par des variables nouvellement déclarées.
Exemple :
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.12&code=ewogICAgbGV0IGEgOj0gMQogICAgbXN0b3JlKGEsIDIpCiAgICBhIDo9IDMKfQ==)
{
 let a := 1
 mstore(a, 2)
 a := 3
}
est transformé en
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.12&code=ewogICAgbGV0IGFfMSA6PSAxCiAgICBsZXQgYSA6PSBhXzEKICAgIG1zdG9yZShhXzEsIDIpCiAgICBsZXQgYV8zIDo9IDMKICAgIGEgOj0gYV8zCn0=)
{
 let a\_1 := 1
 let a := a\_1
 mstore(a\_1, 2)
 let a\_3 := 3
 a := a\_3
}
Sémantique exacte :
Pour toute variable `a` qui est assignée quelque part dans le code (les variables qui sont déclarées avec une valeur et ne sont jamais réassignées ne sont pas modifiées), effectuez les transformations suivantes :
* remplacer `let a := v` par `let a_i := v let a := a_i`
 
* remplacer `a := v` par `let a_i := v a := a_i` où `i` est un nombre tel que `a_i` est encore inutilisé.
 
En outre, enregistrez toujours la valeur actuelle de `i` utilisée pour `a` et remplacez chaque référence à `a` par `a_i`. Le mappage de la valeur courante est effacé pour une variable `a` à la fin de chaque bloc dans lequel elle a été affectée et à la fin du bloc d’initialisation de la boucle for si elle est affectée à l’intérieur du corps de la boucle for ou du bloc post. Si la valeur d’une variable est effacée selon la règle ci-dessus et que la variable est déclarée en dehors du bloc, une nouvelle variable SSA sera créée à l’endroit où le flux de contrôle se rejoint, cela inclut le début du bloc post-boucle/corps et l’emplacement juste après l’instruction If/Switch/ForLoop/Block.
Après cette étape, il est recommandé d’utiliser le Redundant Assign Eliminator pour supprimer les assignations intermédiaires inutiles.
Cette étape donne de meilleurs résultats si le séparateur d’expressions et l’éliminateur de sous-expressions communes sont exécutés juste avant, car elle ne génère alors pas de quantités excessives de variables. D’autre part, l’éliminateur de sous-expressions communes pourrait être plus efficace s’il était exécuté après la transformation SSA.
#### RedundantAssignEliminator[](#redundantassigneliminator "Lien permanent vers cette rubrique")
La transformation SSA génère toujours une affectation de la forme `a := a_i`, même si cela n’est pas nécessaire dans de nombreux cas, comme dans l’exemple suivant :
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.12&code=ewogICAgbGV0IGEgOj0gMQogICAgYSA6PSBtbG9hZChhKQogICAgYSA6PSBzbG9hZChhKQogICAgc3N0b3JlKGEsIDEpCn0=)
{
 let a := 1
 a := mload(a)
 a := sload(a)
 sstore(a, 1)
}
La transformation SSA convertit cet extrait en ce qui suit :
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.12&code=ewogICAgbGV0IGFfMSA6PSAxCiAgICBsZXQgYSA6PSBhXzEKICAgIGxldCBhXzIgOj0gbWxvYWQoYV8xKQogICAgYSA6PSBhXzIKICAgIGxldCBhXzMgOj0gc2xvYWQoYV8yKQogICAgYSA6PSBhXzMKICAgIHNzdG9yZShhXzMsIDEpCn0=)
{
 let a\_1 := 1
 let a := a\_1
 let a\_2 := mload(a\_1)
 a := a\_2
 let a\_3 := sload(a\_2)
 a := a\_3
 sstore(a\_3, 1)
}
L’éliminateur d’assignations redondantes supprime les trois assignations à `a`, car la valeur de `a` n’est pas utilisée et transforme ainsi ce cet extrait en une forme SSA stricte :
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.12&code=ewogICAgbGV0IGFfMSA6PSAxCiAgICBsZXQgYV8yIDo9IG1sb2FkKGFfMSkKICAgIGxldCBhXzMgOj0gc2xvYWQoYV8yKQogICAgc3N0b3JlKGFfMywgMSkKfQ==)
{
 let a\_1 := 1
 let a\_2 := mload(a\_1)
 let a\_3 := sload(a\_2)
 sstore(a\_3, 1)
}
Bien sûr, les parties complexes pour déterminer si une affectation est redondante ou non sont liées à la jonction du flux de contrôle.
Le composant fonctionne en détail comme suit :
L’AST est parcouru deux fois : dans une étape de collecte d’informations et dans l’étape de suppression proprement dite. Pendant la collecte d’informations, nous maintenons une correspondance entre les instructions d’affectation et les trois états « unused », « undecided » et « used » qui signifie si la valeur assignée sera utilisée ultérieurement par une référence à la variable.
Lorsqu’une affectation est visitée, elle est ajoutée au mappage dans l’état « undecided » (voir la remarque sur les boucles for ci-dessous), et chaque autre affectation à la même variable qui est toujours dans l’état « undecided » est changée en « unused ». Lorsqu’une variable est référencée, l’état de toute affectation à cette variable qui se trouve encore dans l’état « undecided » est changé en « used ».
Aux points où le flux de contrôle se divise, une copie de la cartographie est remise à chaque branche. Aux points où le flux de contrôle se rejoint, les deux mappings provenant des deux branches sont combinés de la manière suivante : Les déclarations qui ne figurent que dans un seul mappage ou qui ont le même état sont utilisées sans modification. Les valeurs conflictuelles sont résolues de la manière suivante :
* « unused », « undecided » -> « undecided »
 
* « unused », « used » -> « used »
 
* « undecided, « used » -> « used »
 
Pour les boucles for, la condition, le corps et la partie post sont visités deux fois, en tenant compte du flux de contrôle de jonction à la condition. En d’autres termes, nous créons trois chemins de flux de contrôle : zéro parcours de la boucle, un parcours et deux parcours, puis nous les combinons à la fin.
Il n’est pas nécessaire de simuler une troisième exécution ou même plus, ce qui peut être vu comme suit :
L’état d’une affectation au début de l’itération entraînera de manière déterministe un état de cette affectation à la fin de l’itération. Soit cette fonction de mappage d’état soit appelée `f`. La combinaison des trois états différents états différents `unused`, `undecided` et `used`, comme expliqué ci-dessus, est l’opération `max`, où `unused = 0`. où `unused = 0`, `undecided = 1` et `used = 2`.
La bonne méthode serait de calculer
max(s, f(s), f(f(s)), f(f(f(s))), ...)
comme état après la boucle. Puisque `f` a juste une plage de trois valeurs différentes, en l’itérant, on doit atteindre un cycle après au plus trois itérations, et donc `f(f(f(s)))` doit être égal à l’une des valeurs `s`, `f(s)`, ou `f(f(s))`. et donc
max(s, f(s), f(f(s))) = max(s, f(s), f(f(s)), f(f(f(s))), ...).
En résumé, exécuter la boucle au maximum deux fois est suffisant car il n’y a que trois états différents.
Pour les instructions switch qui ont un cas « par défaut », il n’y a pas de flux de contrôle qui saute le switch.
Lorsqu’une variable sort de sa portée, toutes les instructions qui se trouvent encore dans l’état « undecided » sont transformées en « unused », sauf si la variable est le paramètre de retour d’une fonction - dans ce cas, l’état passe à « used ».
Dans la deuxième traversée, toutes les affectations qui sont dans l’état « unused » sont supprimées.
Cette étape est généralement exécutée juste après la transformation SSA pour compléter la génération du pseudo-SSA.
### Outils[](#outils "Lien permanent vers cette rubrique")
#### Movability[](#movability "Lien permanent vers cette rubrique")
Movability est une propriété d’une expression. Elle signifie en gros que l’expression est sans effet secondaire et que son évaluation ne dépend que des valeurs des variables et de l’état des constantes d’appel de l’environnement. La plupart des expressions sont mobiles. Les parties suivantes rendent une expression non-mobile :
* les appels de fonction (cela pourrait être assoupli à l’avenir si toutes les instructions de la fonction sont mobiles)
 
* les opcodes qui ont (peuvent avoir) des effets secondaires (comme `call` ou `selfdestruct`)
 
* les opcodes qui lisent ou écrivent des informations de mémoire, de stockage ou d’état externe
 
* les opcodes qui dépendent de l’ordinateur actuel, de la taille de la mémoire ou de la taille des données de retour.
 
#### DataflowAnalyzer[](#dataflowanalyzer "Lien permanent vers cette rubrique")
L’analyseur de flux de données n’est pas une étape d’optimisation en soi mais est utilisé comme un outil par d’autres composants. Tout en parcourant l’AST, il suit la valeur actuelle de chaque variable, tant que cette valeur est une expression mobile. Il enregistre les variables qui font partie de l’expression qui est actuellement assignée à chaque autre variable. Lors de chaque affectation à une variable `a`, la valeur courante stockée de `a` est mise à jour et toutes les valeurs stockées de toutes les variables `b` sont effacées chaque fois que `a` fait partie de l’expression actuellement stockée pour b\`.
Aux jonctions du flux de contrôle, la connaissance des variables est effacée si elles ont été ou seraient affectées dans l’un des chemins du flux de contrôle. Par exemple, en entrant dans une boucle for, on efface toutes les variables qui seront affectées pendant le bloc body ou le bloc post.
### Simplifications à l’échelle de l’expression[](#simplifications-a-l-echelle-de-l-expression "Lien permanent vers cette rubrique")
Ces passes de simplification modifient les expressions et les remplacent par des expressions équivalentes et, espérons-le, plus simples.
#### CommonSubexpressionEliminator[](#commonsubexpressioneliminator "Lien permanent vers cette rubrique")
Cette étape utilise l’analyseur de flux de données et remplace les sous-expressions qui correspondent syntaxiquement à la valeur actuelle d’une variable par une référence à cette variable. Il s’agit d’une transformation d’équivalence car ces sous-expressions doivent être déplaçables.
Toutes les sous-expressions qui sont elles-mêmes des identificateurs sont remplacées par leur valeur courante si la valeur est un identificateur.
La combinaison des deux règles ci-dessus permet de calculer une valeur locale numérotation, ce qui signifie que si deux variables ont la même valeur, l’une d’entre elles sera toujours inutilisée. L’élagueur d’inutilisation ou l’éliminateur d’assignations redondantes Redundant Assign Eliminator seront alors en mesure d’éliminer complètement de telles variables.
Cette étape est particulièrement efficace si le séparateur d’expression est exécuté avant. Si le code est sous forme de pseudo-SSA, les valeurs des variables sont disponibles pendant un temps plus long et donc nous avons une plus grande chance que les expressions soient remplaçables.
Le simplifieur d’expression sera capable d’effectuer de meilleurs remplacements si l’éliminateur de sous-expressions communes a été exécuté juste avant lui.
#### Expression Simplifier[](#expression-simplifier "Lien permanent vers cette rubrique")
Le simplificateur d’expression utilise l’analyseur de flux de données et utilise d’une liste de transformations d’équivalence sur des expressions comme `X + 0 -> X` pour simplifier le code.
Il essaie de faire correspondre des motifs comme `X + 0` sur chaque sous-expression. Au cours de la procédure de correspondance, il résout les variables en fonction de leur variables actuellement assignées afin de pouvoir faire correspondre des motifs plus profondément imbriqués, même lorsque le code est sous forme de pseudo-SSA.
Certains motifs comme `X - X -> 0` ne peuvent être appliqués qu’à condition que que l’expression `X` est mobile, parce que sinon, cela supprimerait ses effets secondaires potentiels. Puisque les références aux variables sont toujours mobiles, même si leur valeur actuelle ne l’est pas, le simplificateur d’expression est encore plus puissant sous forme fractionnée ou pseudo-SSA.
#### LiteralRematerialiser[](#literalrematerialiser "Lien permanent vers cette rubrique")
À documenter.
#### LoadResolver[](#loadresolver "Lien permanent vers cette rubrique")
Étape d’optimisation qui remplace les expressions de type `sload(x)` et `mload(x)` par la valeur actuellement stockée dans le stockage resp. La mémoire, si elle est connue.
Fonctionne mieux si le code est sous forme SSA.
Prérequis : Disambiguator, ForLoopInitRewriter.
#### ReasoningBasedSimplifier[](#reasoningbasedsimplifier "Lien permanent vers cette rubrique")
Cet optimiseur utilise les solveurs SMT pour vérifier si les conditions `if` sont constantes.
* Si `constraints AND condition` est UNSAT, la condition n’est jamais vraie et le corps entier peut être supprimé.
 
* Si `constraints AND NOT condition` est UNSAT, la condition est toujours vraie et peut être remplacée par `1`.
 
Les simplifications ci-dessus ne peuvent être appliquées que si la condition est mobile.
Elles ne sont efficaces que sur le dialecte EVM, mais peuvent être utilisées sans danger sur les autres dialectes.
Prérequis : Disambiguator, SSATransform.
### Simplifications à l’échelle de la déclaration[](#simplifications-a-l-echelle-de-la-declaration "Lien permanent vers cette rubrique")
#### CircularReferencesPruner[](#circularreferencespruner "Lien permanent vers cette rubrique")
Cette étape supprime les fonctions qui s’appellent les unes les autres mais qui ne sont ni référencées de manière externe ni référencées depuis le contexte le plus externe.
#### ConditionalSimplifier[](#conditionalsimplifier "Lien permanent vers cette rubrique")
Le simplificateur conditionnel insère des affectations aux variables de condition si la valeur peut être déterminée à partir du flux de contrôle.
Détruit le formulaire SSA.
Actuellement, cet outil est très limité, surtout parce que nous n’avons pas encore de support pour les types booléens. Puisque les conditions vérifient seulement si les expressions sont non nulles, nous ne pouvons pas attribuer une valeur spécifique.
Fonctions actuelles :
* switch cases : insérer « <condition> := <caseLabel> »
 
* après une instruction if avec un flux de contrôle terminant, insérez « <condition> := 0 »
 
Fonctionnalités futures :
* permettre les remplacements par « 1 »
 
* prise en compte de la terminaison des fonctions définies par l’utilisateur
 
Fonctionne mieux avec le formulaire SSA et si la suppression du code mort a été exécutée auparavant.
Prérequis : Disambiguator
#### ConditionalUnsimplifier[](#conditionalunsimplifier "Lien permanent vers cette rubrique")
Inverse du simplificateur conditionnel.
#### ControlFlowSimplifier[](#controlflowsimplifier "Lien permanent vers cette rubrique")
Simplifie plusieurs structures de flux de contrôle :
* remplacer if par un corps vide par pop(condition)
 
* supprimer le cas vide de switch par défaut
 
* supprimer le cas vide du switch si aucun cas par défaut n’existe
 
* remplacer switch sans cas par pop(expression)
 
* transformer un switch avec un seul cas en if
 
* remplacer un switch avec un seul cas par défaut avec pop(expression) et body
 
* remplacer le switch avec const expr par le cas body correspondant
 
* remplacer `for` par un flux de contrôle terminant et sans autre break/continue par `if`
 
* supprimer `leave` à la fin d’une fonction.
 
Aucune de ces opérations ne dépend du flux de données. Le StructuralSimplifier effectue des tâches similaires qui dépendent du flux de données.
Le ControlFlowSimplifier enregistre la présence ou l’absence de `break` et `continue` pendant sa traversée.
Prérequis : Disambiguator, FunctionHoister, ForLoopInitRewriter Important : Introduit les opcodes EVM et ne peut donc être utilisé que sur du code EVM pour le moment.
#### DeadCodeEliminator[](#deadcodeeliminator "Lien permanent vers cette rubrique")
Cette étape d’optimisation supprime le code inaccessible.
Le code inaccessible est tout code à l’intérieur d’un bloc qui est précédé d’une commande leave, return, invalid, break, continue, selfdestruct ou revert.
Les définitions de fonctions sont conservées car elles peuvent être appelées par du code précédent et sont donc considérées comme accessibles.
Parce que les variables déclarées dans le bloc init d’une boucle for ont leur portée étendue au corps de la boucle, nous avons besoin que ForLoopInitRewriter soit exécuté avant cette étape.
Prérequis : ForLoopInitRewriter, Function Hoister, Function Grouper
#### EqualStoreEliminator[](#equalstoreeliminator "Lien permanent vers cette rubrique")
Cette étape supprime les appels à `mstore(k, v)` et `sstore(k, v)` s’il y avait un appel précédent à `mstore(k, v)` / `sstore(k, v)`, aucun autre magasin entre les deux et les valeurs de `k` et `v` n’ont pas changé.
Cette simple étape est efficace si elle est exécutée après la transformation SSA et l’éliminateur de sous-expression commune, parce que SSA s’assurera que les variables ne changeront pas et l’éliminateur de sous-expression commune réutilise exactement la même variable si la valeur est connue pour être la même.
Prérequis : Désambiguïsateur, ForLoopInitRewriter
#### UnusedPruner[](#unusedpruner "Lien permanent vers cette rubrique")
Cette étape supprime les définitions de toutes les fonctions qui ne sont jamais référencées.
Elle supprime également la déclaration des variables qui ne sont jamais référencées. Si la déclaration affecte une valeur qui n’est pas déplaçable, l’expression est conservée, mais sa valeur est supprimée.
Toutes les déclarations d’expressions mobiles (expressions qui ne sont pas assignées) sont supprimées.
#### StructuralSimplifier[](#structuralsimplifier "Lien permanent vers cette rubrique")
Il s’agit d’une étape générale qui permet d’effectuer différents types de simplifications au niveau structurel :
* remplacer l’instruction if avec un corps vide par `pop(condition)`
 
* remplacer l’instruction if avec une condition vraie par son corps
 
* supprimer l’instruction if avec une condition fausse
 
* transformer un switch avec un seul cas en if
 
* remplacer le commutateur avec un seul cas par défaut par `pop(expression)` et son corps
 
* remplacer le commutateur avec une expression littérale par le corps du cas correspondant
 
* remplacer la boucle for avec une fausse condition par sa partie initialisation.
 
Ce composant utilise le Dataflow Analyzer.
#### BlockFlattener[](#blockflattener "Lien permanent vers cette rubrique")
Cette étape élimine les blocs imbriqués en insérant l’instruction du bloc interne à l’endroit approprié du bloc externe. Elle dépend du FunctionGrouper et n’aplatit pas le bloc le plus extérieur pour conserver la forme produite par le FunctionGrouper.
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.12&code=ewogICAgewogICAgICAgIGxldCB4IDo9IDIKICAgICAgICB7CiAgICAgICAgICAgIGxldCB5IDo9IDMKICAgICAgICAgICAgbXN0b3JlKHgsIHkpCiAgICAgICAgfQogICAgfQp9)
{
 {
 let x := 2
 {
 let y := 3
 mstore(x, y)
 }
 }
}
est transformé en
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.12&code=ewogICAgewogICAgICAgIGxldCB4IDo9IDIKICAgICAgICBsZXQgeSA6PSAzCiAgICAgICAgbXN0b3JlKHgsIHkpCiAgICB9Cn0=)
{
 {
 let x := 2
 let y := 3
 mstore(x, y)
 }
}
Tant que le code est désambiguïsé, cela ne pose pas de problème car la portée des variables ne peut que croître.
#### LoopInvariantCodeMotion[](#loopinvariantcodemotion "Lien permanent vers cette rubrique")
Cette optimisation déplace les déclarations de variables SSA mobiles en dehors de la boucle.
Seules les déclarations au niveau supérieur dans le corps ou le post-bloc d’une boucle sont prises en compte à l’intérieur de branches conditionnelles ne seront pas déplacées hors de la boucle.
Exigences :
* Le Disambiguator, ForLoopInitRewriter et FunctionHoister doivent être exécutés en amont.
 
* Le séparateur d’expression et la transformation SSA doivent être exécutés en amont pour obtenir un meilleur résultat.
 
### Optimisations au niveau des fonctions[](#optimisations-au-niveau-des-fonctions "Lien permanent vers cette rubrique")
#### FunctionSpecializer[](#functionspecializer "Lien permanent vers cette rubrique")
Cette étape spécialise la fonction avec ses arguments littéraux.
Si une fonction, disons, `function f(a, b) { sstore (a, b) }`, est appelée avec des arguments littéraux, par exemple, `f(x, 5)`, où `x` est un identificateur, elle peut être spécialisée en créant une nouvelle fonction `f_1` qui ne prend qu’un seul argument, c’est-à-dire,
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.12&code=ZnVuY3Rpb24gZl8xKGFfMSkgewogICAgbGV0IGJfMSA6PSA1CiAgICBzc3RvcmUoYV8xLCBiXzEpCn0=)
function f\_1(a\_1) {
 let b\_1 := 5
 sstore(a\_1, b\_1)
}
D’autres étapes d’optimisation permettront de simplifier davantage la fonction. L’étape d’optimisation est principalement utile pour les fonctions qui ne seraient pas inlined.
Prérequis : Disambiguator, FunctionHoister
LiteralRematerialiser est recommandé comme prérequis, même s’il n’est pas nécessaire pour la l’exactitude.
#### UnusedFunctionParameterPruner[](#unusedfunctionparameterpruner "Lien permanent vers cette rubrique")
Cette étape supprime les paramètres inutilisés dans une fonction.
Si un paramètre est inutilisé, comme `c` et `y` dans, `fonction f(a,b,c) -> x, y { x := div(a,b) }`, on supprime le paramètre et créons une nouvelle fonction de « liaison » comme suit :
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.12&code=ZnVuY3Rpb24gZihhLGIpIC0+IHggeyB4IDo9IGRpdihhLGIpIH0KZnVuY3Rpb24gZjIoYSxiLGMpIC0+IHgsIHkgeyB4IDo9IGYoYSxiKSB9)
function f(a,b) \-> x { x := div(a,b) }
function f2(a,b,c) \-> x, y { x := f(a,b) }
et remplace toutes les références à `f` par `f2`. L’inliner doit être exécuté ensuite pour s’assurer que toutes les références à `f2` sont remplacées par `f`.
Conditions préalables : Disambiguator, FunctionHoister, LiteralRematerialiser.
L’étape LiteralRematerialiser n’est pas nécessaire pour l’exactitude. Elle permet de traiter des cas tels que : `fonction f(x) -> y { revert(y, y} }` où le littéral `y` sera remplacé par sa valeur `0`, ce qui nous permet de réécrire la fonction.
#### EquivalentFunctionCombiner[](#equivalentfunctioncombiner "Lien permanent vers cette rubrique")
Si deux fonctions sont syntaxiquement équivalentes, tout en autorisant le renommage de variables mais pas de réorganisation, toute référence à l’une des fonctions est remplacée par l’autre.
La suppression effective de la fonction est effectuée par l’élagueur inutilisé.
### Mise en ligne des fonctions[](#mise-en-ligne-des-fonctions "Lien permanent vers cette rubrique")
#### ExpressionInliner[](#expressioninliner "Lien permanent vers cette rubrique")
Ce composant de l’optimiseur effectue une mise en ligne restreinte des fonctions en mettant en ligne les fonctions qui peuvent être inlined à l’intérieur des expressions fonctionnelles, c’est-à-dire les fonctions qui :
* retournent une seule valeur
 
* ont un corps tel que `r := <expression fonctionnelle>`
 
* ne font ni référence à elles-mêmes ni à `r` dans la partie droite.
 
De plus, pour tous les paramètres, tous les éléments suivants doivent être vrais :
* L’argument est mobile.
 
* Le paramètre est soit référencé moins de deux fois dans le corps de la fonction, soit l’argument est plutôt bon marché (« coût » d’au plus 1, comme une constante jusqu’à 0xff).
 
Exemple : La fonction à inliner a la forme de `fonction f(...) -> r { r := E }` où `E` est une expression qui ne fait pas référence à `r` et tous les arguments de l’appel de fonction sont des expressions mobiles.
Le résultat de cet inlining est toujours une seule expression.
Ce composant ne peut être utilisé que sur des sources ayant des noms uniques.
#### FullInliner[](#fullinliner "Lien permanent vers cette rubrique")
Le Full Inliner remplace certains appels de certaines fonctions par le corps de la fonction. Ceci n’est pas très utile dans la plupart des cas, car cela ne fait qu’augmenter la taille du code sans en tirer aucun avantage. De plus, le code est généralement très coûteux et nous préférons souvent avoir un code plus court qu’un code plus efficace. Dans certains cas, cependant, l’inlining d’une fonction peut avoir des effets positifs sur les étapes suivantes de l’optimiseur. C’est le cas si l’un des arguments de la fonction est une constante, par exemple.
Pendant l’inlining, une heuristique est utilisée pour déterminer si l’appel de fonction doit être inline ou non. L’heuristique actuelle n’inline pas les « grandes » fonctions, à moins que la fonction appelée est minuscule. Les fonctions qui ne sont utilisées qu’une seule fois sont inlined, ainsi que les fonctions de taille moyenne, tandis que les appels de fonction avec des arguments constants permettent des fonctions légèrement plus grandes.
À l’avenir, nous pourrions inclure un composant de retour en arrière qui, au lieu d’inliner immédiatement une fonction, ne fait que la spécialiser, ce qui signifie qu’une copie de la fonction est générée où un certain paramètre est toujours remplacé par une constante. Après cela, nous pouvons exécuter l’optimiseur sur cette fonction spécialisée. Si cela résulte en des gains importants, la fonction spécialisée est conservée, sinon la fonction originale est utilisée à la place.
### Nettoyage[](#nettoyage "Lien permanent vers cette rubrique")
Le nettoyage est effectué à la fin de l’exécution de l’optimiseur. Il essaie de combiner à nouveau les expressions divisées en expressions profondément imbriquées, améliore également la « compilabilité » pour les machines à pile en éliminant les variables autant que possible.
#### ExpressionJoiner[](#expressionjoiner "Lien permanent vers cette rubrique")
C’est l’opération inverse du séparateur d’expression. Elle transforme une séquence de déclarations de variables qui ont exactement une référence en une expression complexe. Cette étape préserve entièrement l’ordre des appels de fonctions et des exécutions d’opcodes. Elle n’utilise aucune information concernant la commutativité des opcodes ; si le déplacement de la valeur d’une variable vers son lieu d’utilisation devait changer l’ordre d’un appel de fonction ou d’une exécution d’opcode, la transformation n’est pas effectuée.
Notez que le composant ne déplacera pas la valeur d’une affectation de variable ou une variable qui est référencée plus d’une fois.
Le snippet `let x := add(0, 2) let y := mul(x, mload(2))` n’est pas transformé, car il entraînerait l’ordre d’appel des opcodes `add` et `mload` - même si cela ne ferait pas de différence car `add` est mobile.
Lorsque l’on réordonne les opcodes de cette manière, les références de variables et les littéraux sont ignorés. Pour cette raison, l’extrait `let x := add(0, 2) let y := mul(x, 3)` est transformé en `let y := mul(x, 3)`. même si l’opcode `add` serait exécuté après l’évaluation du code serait exécuté après l’évaluation du littéral `3`.
#### SSAReverser[](#ssareverser "Lien permanent vers cette rubrique")
Il s’agit d’un petit pas qui permet d’inverser les effets de la transformation SSA si elle est combinée avec l’Éliminateur de sous-expression commune et l’Éliminateur d’élagueurs inutilisés.
La forme SSA que nous générons est préjudiciable à la génération de code sur l’EVM et sur WebAssembly car elle génère de nombreuses variables locales. Il serait préférable de réutiliser les variables existantes avec des affectations au lieu de de nouvelles déclarations de variables.
La transformation SSA réécrit
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.12&code=bGV0IGEgOj0gY2FsbGRhdGFsb2FkKDApCm1zdG9yZShhLCAxKQ==)
let a := calldataload(0)
mstore(a, 1)
à
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.12&code=bGV0IGFfMSA6PSBjYWxsZGF0YWxvYWQoMCkKbGV0IGEgOj0gYV8xCm1zdG9yZShhXzEsIDEpCmxldCBhXzIgOj0gY2FsbGRhdGFsb2FkKDB4MjApCmEgOj0gYV8y)
let a\_1 := calldataload(0)
let a := a\_1
mstore(a\_1, 1)
let a\_2 := calldataload(0x20)
a := a\_2
Le problème est qu’au lieu de `a`, la variable `a_1` est utilisée chaque fois que `a` est référencé. La transformation SSA modifie les déclarations de cette forme en échangeant simplement la déclaration et l’affectation. L’extrait ci-dessus est transformé en
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.12&code=bGV0IGEgOj0gY2FsbGRhdGFsb2FkKDApCmxldCBhXzEgOj0gYQptc3RvcmUoYV8xLCAxKQphIDo9IGNhbGxkYXRhbG9hZCgweDIwKQpsZXQgYV8yIDo9IGE=)
let a := calldataload(0)
let a\_1 := a
mstore(a\_1, 1)
a := calldataload(0x20)
let a\_2 := a
Il s’agit d’une transformation d’équivalence très simple, mais lorsque nous lançons maintenant l’éliminateur de sous-expression commune Common Subexpression Eliminator, il remplacera toutes les occurrences de `a_1` par `a` (jusqu’à ce que `a` soit réassigné). L’élagueur inutilisé va ensuite éliminer alors la variable `a_1` et inversera ainsi complètement la transformation SSA.
#### StackCompressor[](#stackcompressor "Lien permanent vers cette rubrique")
Un problème qui rend la génération de code pour la machine virtuelle d’Ethereum est le fait qu’il y a une limite stricte de 16 emplacements pour atteindre la pile d’expression. Cela se traduit plus ou moins par une limite de 16 variables locales. Le compresseur de pile prend le code Yul et le compile en bytecode EVM. Chaque fois que la différence de pile est trop importante, il enregistre la fonction dans laquelle cela s’est produit.
Pour chaque fonction qui a causé un tel problème, le Rematerialiser est appelé avec une demande spéciale pour éliminer agressivement des variables spécifiques triées par le coût de leurs valeurs.
En cas d’échec, cette procédure est répétée plusieurs fois.
#### Rematerialiser[](#rematerialiser "Lien permanent vers cette rubrique")
L’étape de rematérialisation tente de remplacer les références de variables par l’expression qui a été affectée en dernier lieu à la variable. Ceci n’est bien sûr bénéfique que si cette expression est comparativement bon marché à évaluer. En outre, elle n’est sémantiquement équivalente que si la valeur de l’expression n’a pas changé entre le point d’affectation et le point d’utilisation. Le principal avantage de cette étape est qu’elle peut économiser des emplacements de pile si elle conduit à l’élimination complète d’une variable (voir ci-dessous), mais elle peut aussi sauver un opcode DUP sur l’EVM si l’expression est très bon marché.
Le rematérialisateur utilise l’analyseur de flux de données pour suivre les valeurs actuelles des variables, qui sont toujours mobiles. Si la valeur est très bon marché ou si l’élimination de la variable a été explicitement demandée, la référence de la variable est remplacée par sa valeur actuelle.
#### ForLoopConditionOutOfBody[](#forloopconditionoutofbody "Lien permanent vers cette rubrique")
Inverse la transformation de ForLoopConditionIntoBody.
Pour tout mobile `c`, il se transforme en
for { ... } 1 { ... } {
if iszero(c) { break }
...
}
en
for { ... } c { ... } {
...
}
et il tourne
for { ... } 1 { ... } {
if c { break }
...
}
en
for { ... } iszero(c) { ... } {
...
}
Le LiteralRematerialiser doit être exécuté avant cette étape.
### Spécifique à WebAssembly[](#specifique-a-webassembly "Lien permanent vers cette rubrique")
#### MainFunction[](#mainfunction "Lien permanent vers cette rubrique")
Change le bloc le plus haut en une fonction avec un nom spécifique (« main ») qui n’a ni entrées ni sorties.
Dépend du Function Grouper.

# [图标列表和属性 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/credits-and-attribution.html) 
 _https://docs.soliditylang.org/zh-cn/latest/credits-and-attribution.html_

* [](https://docs.soliditylang.org/zh-cn/latest/index.html)
* 图标列表和属性
* [在 GitHub 上编辑](https://github.com/solidity-docs/zh-chinese/blob/develop/docs/credits-and-attribution.rst)
* * *
## 图标列表和属性[](#id1 "此标题的永久链接")
## 网站图标[](#id2 "此标题的永久链接")
图标
属性
* 来源： [分享图标](https://fontawesome.com/v5.15/icons/share?style=solid) 来自 Font Awesome 5.15.0。
 
* 许可： [Font Awesome 免费许可证](https://fontawesome.com/license/free) （CC BY 4.0）。

# [已知bug列表 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/bugs.html) 
 _https://docs.soliditylang.org/zh-cn/latest/bugs.html_

下面，您可以找到一个JSON格式的列表，其中包括Solidity编译器中一些已知的与安全有关的错误。 该文件本身托管在 [Github 仓库](https://github.com/ethereum/solidity/blob/develop/docs/bugs.json)。 该列表最早可以追溯到0.3.0版本，只有在此之前的版本中已知的错误没有列出。
还有一个文件叫 [bugs\_by\_version.json](https://github.com/ethereum/solidity/blob/develop/docsbugs_by_version.json)， 它可以用来检查哪些bug影响到特定版本的编译器。
合约源码验证工具以及其他与合约交互的工具应根据以下标准查阅此列表：
* 如果合约是用夜间编译器版本而不是发布版本编译的，那就有点可疑了。 此列表不跟踪未发布或夜间版本。
 
* 如果合约的编译版本不是合约创建时的最新版本，则也有点可疑。 对于从其他合约创建的合约，您必须按照创建链返回到事务，并使用该事务的日期作为创建日期。
 
* 如果合约是用包含已知bug的编译器编译的，并且合约是在已发布包含修复程序的较新编译器版本时创建的， 则这是高度可疑的。
 
下面的已知错误的JSON文件是一个对象数组，每个错误都有一个对象，其键值如下：
uid
以 `SOL-<year>-<number>` 的形式给予该错误的唯一标识符。 有可能存在多个具有相同uid的条目。 这意味着多个版本范围受到同一错误的影响。
name
给予该错误的唯一名称
summary
对该错误的简短描述
description
该错误的详细描述
link
有更多详细信息的网站的URL，可选
introduced
第一个包含该错误的发布的编译器版本，可选
fixed
第一个不再包含该错误的发布的编译器版本
publish
bug公开的日期，可选
severity
bug的严重程度：非常低，低，中，高。 考虑合约测试中的可发现性，发生的可能性和错误造成的潜在损害。
conditions
必须满足的条件才能触发该错误。可以使用以下键： `optimizer`, 布尔值，表示优化器必须打开才会出现该错误。 `evmVersion`, 一个字符串，表示哪个EVM版本的编译器设置触发了该错误。 这个字符串可以包含比较运算符。例如， `">=constantinople"` 表示 当EVM版本设置为 `constantinople` 或更高时，该错误就会出现。 如果没有给出条件，则假定该错误存在。
check
这个字段包含不同的检查，报告智能合约是否包含错误。 第一种类型的检查是JavaScript正则表达式，如果存在该错误，将与源代码（“source-regex”）进行匹配。 如果没有匹配，那么该漏洞很可能不存在。如果有一个匹配，则该错误可能存在。 为了提高准确性，检查应该在剥离注释后应用于源代码。 第二种类型的检查是在Solidity程序的紧凑AST上检查的模式（“ast-compact-json path”）。 指定的搜索查询是一个 [JsonPath](https://github.com/json-path/JsonPath) 表达式。 如果Solidity AST中至少有一个路径与该查询相匹配，则可能存在错误。
\[
 {
 "uid": "SOL-2023-3",
 "name": "VerbatimInvalidDeduplication",
 "summary": "All \`\`verbatim\`\` blocks are considered identical by deduplicator and can incorrectly be unified when surrounded by identical opcodes.",
 "description": "The block deduplicator is a step of the opcode-based optimizer which identifies equivalent assembly blocks and merges them into a single one. However, when blocks contained \`\`verbatim\`\`, their comparison was performed incorrectly, leading to the collapse of assembly blocks which are identical except for the contents of the \`\`verbatim\`\` items. Since \`\`verbatim\`\` is only available in Yul, compilation of Solidity sources is not affected.",
 "link": "https://blog.soliditylang.org/2023/11/08/verbatim-invalid-deduplication-bug/",
 "introduced": "0.8.5",
 "fixed": "0.8.23",
 "severity": "low"
 },
 {
 "uid": "SOL-2023-2",
 "name": "FullInlinerNonExpressionSplitArgumentEvaluationOrder",
 "summary": "Optimizer sequences containing FullInliner do not preserve the evaluation order of arguments of inlined function calls in code that is not in expression-split form.",
 "description": "Function call arguments in Yul are evaluated right to left. This order matters when the argument expressions have side-effects, and changing it may change contract behavior. FullInliner is an optimizer step that can replace a function call with the body of that function. The transformation involves assigning argument expressions to temporary variables, which imposes an explicit evaluation order. FullInliner was written with the assumption that this order does not necessarily have to match usual argument evaluation order because the argument expressions have no side-effects. In most circumstances this assumption is true because the default optimization step sequence contains the ExpressionSplitter step. ExpressionSplitter ensures that the code is in \*expression-split form\*, which means that function calls cannot appear nested inside expressions, and all function call arguments have to be variables. The assumption is, however, not guaranteed to be true in general. Version 0.6.7 introduced a setting allowing users to specify an arbitrary optimization step sequence, making it possible for the FullInliner to actually encounter argument expressions with side-effects, which can result in behavior differences between optimized and unoptimized bytecode. Contracts compiled without optimization or with the default optimization sequence are not affected. To trigger the bug the user has to explicitly choose compiler settings that contain a sequence with FullInliner step not preceded by ExpressionSplitter.",
 "link": "https://blog.soliditylang.org/2023/07/19/full-inliner-non-expression-split-argument-evaluation-order-bug/",
 "introduced": "0.6.7",
 "fixed": "0.8.21",
 "severity": "low",
 "conditions": {
 "yulOptimizer": true
 }
 },
 {
 "uid": "SOL-2023-1",
 "name": "MissingSideEffectsOnSelectorAccess",
 "summary": "Accessing the \`\`.selector\`\` member on complex expressions leaves the expression unevaluated in the legacy code generation.",
 "description": "When accessing the \`\`.selector\`\` member on an expression with side-effects, like an assignment, a function call or a conditional, the expression would not be evaluated in the legacy code generation. This would happen in expressions where the functions used in the expression were all known at compilation time, regardless of whether the whole expression could be evaluated at compilation time or not. Note that the code generated by the IR pipeline was unaffected and would behave as expected.",
 "link": "https://blog.soliditylang.org/2023/07/19/missing-side-effects-on-selector-access-bug/",
 "introduced": "0.6.2",
 "fixed": "0.8.21",
 "severity": "low",
 "conditions": {
 "viaIR": false
 }
 },
 {
 "uid": "SOL-2022-7",
 "name": "StorageWriteRemovalBeforeConditionalTermination",
 "summary": "Calling functions that conditionally terminate the external EVM call using the assembly statements \`\`return(...)\`\` or \`\`stop()\`\` may result in incorrect removals of prior storage writes.",
 "description": "A call to a Yul function that conditionally terminates the external EVM call could result in prior storage writes being incorrectly removed by the Yul optimizer. This used to happen in cases in which it would have been valid to remove the store, if the Yul function in question never actually terminated the external call, and the control flow always returned back to the caller instead. Conditional termination within the same Yul block instead of within a called function was not affected. In Solidity with optimized via-IR code generation, any storage write before a function conditionally calling \`\`return(...)\`\` or \`\`stop()\`\` in inline assembly, may have been incorrectly removed, whenever it would have been valid to remove the write without the \`\`return(...)\`\` or \`\`stop()\`\`. In optimized legacy code generation, only inline assembly that did not refer to any Solidity variables and that involved conditionally-terminating user-defined assembly functions could be affected.",
 "link": "https://blog.soliditylang.org/2022/09/08/storage-write-removal-before-conditional-termination/",
 "introduced": "0.8.13",
 "fixed": "0.8.17",
 "severity": "medium/high",
 "conditions": {
 "yulOptimizer": true
 }
 },
 {
 "uid": "SOL-2022-6",
 "name": "AbiReencodingHeadOverflowWithStaticArrayCleanup",
 "summary": "ABI-encoding a tuple with a statically-sized calldata array in the last component would corrupt 32 leading bytes of its first dynamically encoded component.",
 "description": "When ABI-encoding a statically-sized calldata array, the compiler always pads the data area to a multiple of 32-bytes and ensures that the padding bytes are zeroed. In some cases, this cleanup used to be performed by always writing exactly 32 bytes, regardless of how many needed to be zeroed. This was done with the assumption that the data that would eventually occupy the area past the end of the array had not yet been written, because the encoder processes tuple components in the order they were given. While this assumption is mostly true, there is an important corner case: dynamically encoded tuple components are stored separately from the statically-sized ones in an area called the \*tail\* of the encoding and the tail immediately follows the \*head\*, which is where the statically-sized components are placed. The aforementioned cleanup, if performed for the last component of the head would cross into the tail and overwrite up to 32 bytes of the first component stored there with zeros. The only array type for which the cleanup could actually result in an overwrite were arrays with \`\`uint256\`\` or \`\`bytes32\`\` as the base element type and in this case the size of the corrupted area was always exactly 32 bytes. The problem affected tuples at any nesting level. This included also structs, which are encoded as tuples in the ABI. Note also that lists of parameters and return values of functions, events and errors are encoded as tuples.",
 "link": "https://blog.soliditylang.org/2022/08/08/calldata-tuple-reencoding-head-overflow-bug/",
 "introduced": "0.5.8",
 "fixed": "0.8.16",
 "severity": "medium",
 "conditions": {
 "ABIEncoderV2": true
 }
 },
 {
 "uid": "SOL-2022-5",
 "name": "DirtyBytesArrayToStorage",
 "summary": "Copying \`\`bytes\`\` arrays from memory or calldata to storage may result in dirty storage values.",
 "description": "Copying \`\`bytes\`\` arrays from memory or calldata to storage is done in chunks of 32 bytes even if the length is not a multiple of 32. Thereby, extra bytes past the end of the array may be copied from calldata or memory to storage. These dirty bytes may then become observable after a \`\`.push()\`\` without arguments to the bytes array in storage, i.e. such a push will not result in a zero value at the end of the array as expected. This bug only affects the legacy code generation pipeline, the new code generation pipeline via IR is not affected.",
 "link": "https://blog.soliditylang.org/2022/06/15/dirty-bytes-array-to-storage-bug/",
 "introduced": "0.0.1",
 "fixed": "0.8.15",
 "severity": "low"
 },
 {
 "uid": "SOL-2022-4",
 "name": "InlineAssemblyMemorySideEffects",
 "summary": "The Yul optimizer may incorrectly remove memory writes from inline assembly blocks, that do not access solidity variables.",
 "description": "The Yul optimizer considers all memory writes in the outermost Yul block that are never read from as unused and removes them. This is valid when that Yul block is the entire Yul program, which is always the case for the Yul code generated by the new via-IR pipeline. Inline assembly blocks are never optimized in isolation when using that pipeline. Instead they are optimized as a part of the whole Yul input. However, the legacy code generation pipeline (which is still the default) runs the Yul optimizer individually on an inline assembly block if the block does not refer to any local variables defined in the surrounding Solidity code. Consequently, memory writes in such inline assembly blocks are removed as well, if the written memory is never read from in the same assembly block, even if the written memory is accessed later, for example by a subsequent inline assembly block.",
 "link": "https://blog.soliditylang.org/2022/06/15/inline-assembly-memory-side-effects-bug/",
 "introduced": "0.8.13",
 "fixed": "0.8.15",
 "severity": "medium",
 "conditions": {
 "yulOptimizer": true
 }
 },
 {
 "uid": "SOL-2022-3",
 "name": "DataLocationChangeInInternalOverride",
 "summary": "It was possible to change the data location of the parameters or return variables from \`\`calldata\`\` to \`\`memory\`\` and vice-versa while overriding internal and public functions. This caused invalid code to be generated when calling such a function internally through virtual function calls.",
 "description": "When calling external functions, it is irrelevant if the data location of the parameters is \`\`calldata\`\` or \`\`memory\`\`, the encoding of the data does not change. Because of that, changing the data location when overriding external functions is allowed. The compiler incorrectly also allowed a change in the data location for overriding public and internal functions. Since public functions can be called internally as well as externally, this causes invalid code to be generated when such an incorrectly overridden function is called internally through the base contract. The caller provides a memory pointer, but the called function interprets it as a calldata pointer or vice-versa.",
 "link": "https://blog.soliditylang.org/2022/05/17/data-location-inheritance-bug/",
 "introduced": "0.6.9",
 "fixed": "0.8.14",
 "severity": "very low"
 },
 {
 "uid": "SOL-2022-2",
 "name": "NestedCalldataArrayAbiReencodingSizeValidation",
 "summary": "ABI-reencoding of nested dynamic calldata arrays did not always perform proper size checks against the size of calldata and could read beyond \`\`calldatasize()\`\`.",
 "description": "Calldata validation for nested dynamic types is deferred until the first access to the nested values. Such an access may for example be a copy to memory or an index or member access to the outer type. While in most such accesses calldata validation correctly checks that the data area of the nested array is completely contained in the passed calldata (i.e. in the range \[0, calldatasize()\]), this check may not be performed, when ABI encoding such nested types again directly from calldata. For instance, this can happen, if a value in calldata with a nested dynamic array is passed to an external call, used in \`\`abi.encode\`\` or emitted as event. In such cases, if the data area of the nested array extends beyond \`\`calldatasize()\`\`, ABI encoding it did not revert, but continued reading values from beyond \`\`calldatasize()\`\` (i.e. zero values).",
 "link": "https://blog.soliditylang.org/2022/05/17/calldata-reencode-size-check-bug/",
 "introduced": "0.5.8",
 "fixed": "0.8.14",
 "severity": "very low"
 },
 {
 "uid": "SOL-2022-1",
 "name": "AbiEncodeCallLiteralAsFixedBytesBug",
 "summary": "Literals used for a fixed length bytes parameter in \`\`abi.encodeCall\`\` were encoded incorrectly.",
 "description": "For the encoding, the compiler only considered the types of the expressions in the second argument of \`\`abi.encodeCall\`\` itself, but not the parameter types of the function given as first argument. In almost all cases the abi encoding of the type of the expression matches the abi encoding of the parameter type of the given function. This is because the type checker ensures the expression is implicitly convertible to the respective parameter type. However this is not true for number literals used for fixed bytes types shorter than 32 bytes, nor for string literals used for any fixed bytes type. Number literals were encoded as numbers instead of being shifted to become left-aligned. String literals were encoded as dynamically sized memory strings instead of being converted to a left-aligned bytes value.",
 "link": "https://blog.soliditylang.org/2022/03/16/encodecall-bug/",
 "introduced": "0.8.11",
 "fixed": "0.8.13",
 "severity": "very low"
 },
 {
 "uid": "SOL-2021-4",
 "name": "UserDefinedValueTypesBug",
 "summary": "User defined value types with underlying type shorter than 32 bytes used incorrect storage layout and wasted storage",
 "description": "The compiler did not correctly compute the storage layout of user defined value types based on types that are shorter than 32 bytes. It would always use a full storage slot for these types, even if the underlying type was shorter. This was wasteful and might have problems with tooling or contract upgrades.",
 "link": "https://blog.soliditylang.org/2021/09/29/user-defined-value-types-bug/",
 "introduced": "0.8.8",
 "fixed": "0.8.9",
 "severity": "very low"
 },
 {
 "uid": "SOL-2021-3",
 "name": "SignedImmutables",
 "summary": "Immutable variables of signed integer type shorter than 256 bits can lead to values with invalid higher order bits if inline assembly is used.",
 "description": "When immutable variables of signed integer type shorter than 256 bits are read, their higher order bits were unconditionally set to zero. The correct operation would be to sign-extend the value, i.e. set the higher order bits to one if the sign bit is one. This sign-extension is performed by Solidity just prior to when it matters, i.e. when a value is stored in memory, when it is compared or when a division is performed. Because of that, to our knowledge, the only way to access the value in its unclean state is by reading it through inline assembly.",
 "link": "https://blog.soliditylang.org/2021/09/29/signed-immutables-bug/",
 "introduced": "0.6.5",
 "fixed": "0.8.9",
 "severity": "very low"
 },
 {
 "uid": "SOL-2021-2",
 "name": "ABIDecodeTwoDimensionalArrayMemory",
 "summary": "If used on memory byte arrays, result of the function \`\`abi.decode\`\` can depend on the contents of memory outside of the actual byte array that is decoded.",
 "description": "The ABI specification uses pointers to data areas for everything that is dynamically-sized. When decoding data from memory (instead of calldata), the ABI decoder did not properly validate some of these pointers. More specifically, it was possible to use large values for the pointers inside arrays such that computing the offset resulted in an undetected overflow. This could lead to these pointers targeting areas in memory outside of the actual area to be decoded. This way, it was possible for \`\`abi.decode\`\` to return different values for the same encoded byte array.",
 "link": "https://blog.soliditylang.org/2021/04/21/decoding-from-memory-bug/",
 "introduced": "0.4.16",
 "fixed": "0.8.4",
 "conditions": {
 "ABIEncoderV2": true
 },
 "severity": "very low"
 },
 {
 "uid": "SOL-2021-1",
 "name": "KeccakCaching",
 "summary": "The bytecode optimizer incorrectly re-used previously evaluated Keccak-256 hashes. You are unlikely to be affected if you do not compute Keccak-256 hashes in inline assembly.",
 "description": "Solidity's bytecode optimizer has a step that can compute Keccak-256 hashes, if the contents of the memory are known during compilation time. This step also has a mechanism to determine that two Keccak-256 hashes are equal even if the values in memory are not known during compile time. This mechanism had a bug where Keccak-256 of the same memory content, but different sizes were considered equal. More specifically, \`\`keccak256(mpos1, length1)\`\` and \`\`keccak256(mpos2, length2)\`\` in some cases were considered equal if \`\`length1\`\` and \`\`length2\`\`, when rounded up to nearest multiple of 32 were the same, and when the memory contents at \`\`mpos1\`\` and \`\`mpos2\`\` can be deduced to be equal. You maybe affected if you compute multiple Keccak-256 hashes of the same content, but with different lengths inside inline assembly. You are unaffected if your code uses \`\`keccak256\`\` with a length that is not a compile-time constant or if it is always a multiple of 32.",
 "link": "https://blog.soliditylang.org/2021/03/23/keccak-optimizer-bug/",
 "fixed": "0.8.3",
 "conditions": {
 "optimizer": true
 },
 "severity": "medium"
 },
 {
 "uid": "SOL-2020-11",
 "name": "EmptyByteArrayCopy",
 "summary": "Copying an empty byte array (or string) from memory or calldata to storage can result in data corruption if the target array's length is increased subsequently without storing new data.",
 "description": "The routine that copies byte arrays from memory or calldata to storage stores unrelated data from after the source array in the storage slot if the source array is empty. If the storage array's length is subsequently increased either by using \`\`.push()\`\` or by assigning to its \`\`.length\`\` attribute (only before 0.6.0), the newly created byte array elements will not be zero-initialized, but contain the unrelated data. You are not affected if you do not assign to \`\`.length\`\` and do not use \`\`.push()\`\` on byte arrays, or only use \`\`.push(<arg>)\`\` or manually initialize the new elements.",
 "link": "https://blog.soliditylang.org/2020/10/19/empty-byte-array-copy-bug/",
 "fixed": "0.7.4",
 "severity": "medium"
 },
 {
 "uid": "SOL-2020-10",
 "name": "DynamicArrayCleanup",
 "summary": "When assigning a dynamically-sized array with types of size at most 16 bytes in storage causing the assigned array to shrink, some parts of deleted slots were not zeroed out.",
 "description": "Consider a dynamically-sized array in storage whose base-type is small enough such that multiple values can be packed into a single slot, such as \`uint128\[\]\`. Let us define its length to be \`l\`. When this array gets assigned from another array with a smaller length, say \`m\`, the slots between elements \`m\` and \`l\` have to be cleaned by zeroing them out. However, this cleaning was not performed properly. Specifically, after the slot corresponding to \`m\`, only the first packed value was cleaned up. If this array gets resized to a length larger than \`m\`, the indices corresponding to the unclean parts of the slot contained the original value, instead of 0. The resizing here is performed by assigning to the array \`length\`, by a \`push()\` or via inline assembly. You are not affected if you are only using \`.push(<arg>)\` or if you assign a value (even zero) to the new elements after increasing the length of the array.",
 "link": "https://blog.soliditylang.org/2020/10/07/solidity-dynamic-array-cleanup-bug/",
 "fixed": "0.7.3",
 "severity": "medium"
 },
 {
 "uid": "SOL-2020-9",
 "name": "FreeFunctionRedefinition",
 "summary": "The compiler does not flag an error when two or more free functions with the same name and parameter types are defined in a source unit or when an imported free function alias shadows another free function with a different name but identical parameter types.",
 "description": "In contrast to functions defined inside contracts, free functions with identical names and parameter types did not create an error. Both definition of free functions with identical name and parameter types and an imported free function with an alias that shadows another function with a different name but identical parameter types were permitted due to which a call to either the multiply defined free function or the imported free function alias within a contract led to the execution of that free function which was defined first within the source unit. Subsequently defined identical free function definitions were silently ignored and their code generation was skipped.",
 "introduced": "0.7.1",
 "fixed": "0.7.2",
 "severity": "low"
 },
 {
 "uid": "SOL-2020-8",
 "name": "UsingForCalldata",
 "summary": "Function calls to internal library functions with calldata parameters called via \`\`using for\`\` can result in invalid data being read.",
 "description": "Function calls to internal library functions using the \`\`using for\`\` mechanism copied all calldata parameters to memory first and passed them on like that, regardless of whether it was an internal or an external call. Due to that, the called function would receive a memory pointer that is interpreted as a calldata pointer. Since dynamically sized arrays are passed using two stack slots for calldata, but only one for memory, this can lead to stack corruption. An affected library call will consider the JUMPDEST to which it is supposed to return as part of its arguments and will instead jump out to whatever was on the stack before the call.",
 "introduced": "0.6.9",
 "fixed": "0.6.10",
 "severity": "very low"
 },
 {
 "uid": "SOL-2020-7",
 "name": "MissingEscapingInFormatting",
 "summary": "String literals containing double backslash characters passed directly to external or encoding function calls can lead to a different string being used when ABIEncoderV2 is enabled.",
 "description": "When ABIEncoderV2 is enabled, string literals passed directly to encoding functions or external function calls are stored as strings in the intemediate code. Characters outside the printable range are handled correctly, but backslashes are not escaped in this procedure. This leads to double backslashes being reduced to single backslashes and consequently re-interpreted as escapes potentially resulting in a different string being encoded.",
 "introduced": "0.5.14",
 "fixed": "0.6.8",
 "severity": "very low",
 "conditions": {
 "ABIEncoderV2": true
 }
 },
 {
 "uid": "SOL-2020-6",
 "name": "ArraySliceDynamicallyEncodedBaseType",
 "summary": "Accessing array slices of arrays with dynamically encoded base types (e.g. multi-dimensional arrays) can result in invalid data being read.",
 "description": "For arrays with dynamically sized base types, index range accesses that use a start expression that is non-zero will result in invalid array slices. Any index access to such array slices will result in data being read from incorrect calldata offsets. Array slices are only supported for dynamic calldata types and all problematic type require ABIEncoderV2 to be enabled.",
 "introduced": "0.6.0",
 "fixed": "0.6.8",
 "severity": "very low",
 "conditions": {
 "ABIEncoderV2": true
 }
 },
 {
 "uid": "SOL-2020-5",
 "name": "ImplicitConstructorCallvalueCheck",
 "summary": "The creation code of a contract that does not define a constructor but has a base that does define a constructor did not revert for calls with non-zero value.",
 "description": "Starting from Solidity 0.4.5 the creation code of contracts without explicit payable constructor is supposed to contain a callvalue check that results in contract creation reverting, if non-zero value is passed. However, this check was missing in case no explicit constructor was defined in a contract at all, but the contract has a base that does define a constructor. In these cases it is possible to send value in a contract creation transaction or using inline assembly without revert, even though the creation code is supposed to be non-payable.",
 "introduced": "0.4.5",
 "fixed": "0.6.8",
 "severity": "very low"
 },
 {
 "uid": "SOL-2020-4",
 "name": "TupleAssignmentMultiStackSlotComponents",
 "summary": "Tuple assignments with components that occupy several stack slots, i.e. nested tuples, pointers to external functions or references to dynamically sized calldata arrays, can result in invalid values.",
 "description": "Tuple assignments did not correctly account for tuple components that occupy multiple stack slots in case the number of stack slots differs between left-hand-side and right-hand-side. This can either happen in the presence of nested tuples or if the right-hand-side contains external function pointers or references to dynamic calldata arrays, while the left-hand-side contains an omission.",
 "introduced": "0.1.6",
 "fixed": "0.6.6",
 "severity": "very low"
 },
 {
 "uid": "SOL-2020-3",
 "name": "MemoryArrayCreationOverflow",
 "summary": "The creation of very large memory arrays can result in overlapping memory regions and thus memory corruption.",
 "description": "No runtime overflow checks were performed for the length of memory arrays during creation. In cases for which the memory size of an array in bytes, i.e. the array length times 32, is larger than 2^256-1, the memory allocation will overflow, potentially resulting in overlapping memory areas. The length of the array is still stored correctly, so copying or iterating over such an array will result in out-of-gas.",
 "link": "https://blog.soliditylang.org/2020/04/06/memory-creation-overflow-bug/",
 "introduced": "0.2.0",
 "fixed": "0.6.5",
 "severity": "low"
 },
 {
 "uid": "SOL-2020-1",
 "name": "YulOptimizerRedundantAssignmentBreakContinue",
 "summary": "The Yul optimizer can remove essential assignments to variables declared inside for loops when Yul's continue or break statement is used. You are unlikely to be affected if you do not use inline assembly with for loops and continue and break statements.",
 "description": "The Yul optimizer has a stage that removes assignments to variables that are overwritten again or are not used in all following control-flow branches. This logic incorrectly removes such assignments to variables declared inside a for loop if they can be removed in a control-flow branch that ends with \`\`break\`\` or \`\`continue\`\` even though they cannot be removed in other control-flow branches. Variables declared outside of the respective for loop are not affected.",
 "introduced": "0.6.0",
 "fixed": "0.6.1",
 "severity": "medium",
 "conditions": {
 "yulOptimizer": true
 }
 },
 {
 "uid": "SOL-2020-2",
 "name": "privateCanBeOverridden",
 "summary": "Private methods can be overridden by inheriting contracts.",
 "description": "While private methods of base contracts are not visible and cannot be called directly from the derived contract, it is still possible to declare a function of the same name and type and thus change the behaviour of the base contract's function.",
 "introduced": "0.3.0",
 "fixed": "0.5.17",
 "severity": "low"
 },
 {
 "uid": "SOL-2020-1",
 "name": "YulOptimizerRedundantAssignmentBreakContinue0.5",
 "summary": "The Yul optimizer can remove essential assignments to variables declared inside for loops when Yul's continue or break statement is used. You are unlikely to be affected if you do not use inline assembly with for loops and continue and break statements.",
 "description": "The Yul optimizer has a stage that removes assignments to variables that are overwritten again or are not used in all following control-flow branches. This logic incorrectly removes such assignments to variables declared inside a for loop if they can be removed in a control-flow branch that ends with \`\`break\`\` or \`\`continue\`\` even though they cannot be removed in other control-flow branches. Variables declared outside of the respective for loop are not affected.",
 "introduced": "0.5.8",
 "fixed": "0.5.16",
 "severity": "low",
 "conditions": {
 "yulOptimizer": true
 }
 },
 {
 "uid": "SOL-2019-10",
 "name": "ABIEncoderV2LoopYulOptimizer",
 "summary": "If both the experimental ABIEncoderV2 and the experimental Yul optimizer are activated, one component of the Yul optimizer may reuse data in memory that has been changed in the meantime.",
 "description": "The Yul optimizer incorrectly replaces \`\`mload\`\` and \`\`sload\`\` calls with values that have been previously written to the load location (and potentially changed in the meantime) if all of the following conditions are met: (1) there is a matching \`\`mstore\`\` or \`\`sstore\`\` call before; (2) the contents of memory or storage is only changed in a function that is called (directly or indirectly) in between the first store and the load call; (3) called function contains a for loop where the same memory location is changed in the condition or the post or body block. When used in Solidity mode, this can only happen if the experimental ABIEncoderV2 is activated and the experimental Yul optimizer has been activated manually in addition to the regular optimizer in the compiler settings.",
 "introduced": "0.5.14",
 "fixed": "0.5.15",
 "severity": "low",
 "conditions": {
 "ABIEncoderV2": true,
 "optimizer": true,
 "yulOptimizer": true
 }
 },
 {
 "uid": "SOL-2019-9",
 "name": "ABIEncoderV2CalldataStructsWithStaticallySizedAndDynamicallyEncodedMembers",
 "summary": "Reading from calldata structs that contain dynamically encoded, but statically-sized members can result in incorrect values.",
 "description": "When a calldata struct contains a dynamically encoded, but statically-sized member, the offsets for all subsequent struct members are calculated incorrectly. All reads from such members will result in invalid values. Only calldata structs are affected, i.e. this occurs in external functions with such structs as argument. Using affected structs in storage or memory or as arguments to public functions on the other hand works correctly.",
 "introduced": "0.5.6",
 "fixed": "0.5.11",
 "severity": "low",
 "conditions": {
 "ABIEncoderV2": true
 }
 },
 {
 "uid": "SOL-2019-8",
 "name": "SignedArrayStorageCopy",
 "summary": "Assigning an array of signed integers to a storage array of different type can lead to data corruption in that array.",
 "description": "In two's complement, negative integers have their higher order bits set. In order to fit into a shared storage slot, these have to be set to zero. When a conversion is done at the same time, the bits to set to zero were incorrectly determined from the source and not the target type. This means that such copy operations can lead to incorrect values being stored.",
 "link": "https://blog.soliditylang.org/2019/06/25/solidity-storage-array-bugs/",
 "introduced": "0.4.7",
 "fixed": "0.5.10",
 "severity": "low/medium"
 },
 {
 "uid": "SOL-2019-7",
 "name": "ABIEncoderV2StorageArrayWithMultiSlotElement",
 "summary": "Storage arrays containing structs or other statically-sized arrays are not read properly when directly encoded in external function calls or in abi.encode\*.",
 "description": "When storage arrays whose elements occupy more than a single storage slot are directly encoded in external function calls or using abi.encode\*, their elements are read in an overlapping manner, i.e. the element pointer is not properly advanced between reads. This is not a problem when the storage data is first copied to a memory variable or if the storage array only contains value types or dynamically-sized arrays.",
 "link": "https://blog.soliditylang.org/2019/06/25/solidity-storage-array-bugs/",
 "introduced": "0.4.16",
 "fixed": "0.5.10",
 "severity": "low",
 "conditions": {
 "ABIEncoderV2": true
 }
 },
 {
 "uid": "SOL-2019-6",
 "name": "DynamicConstructorArgumentsClippedABIV2",
 "summary": "A contract's constructor that takes structs or arrays that contain dynamically-sized arrays reverts or decodes to invalid data.",
 "description": "During construction of a contract, constructor parameters are copied from the code section to memory for decoding. The amount of bytes to copy was calculated incorrectly in case all parameters are statically-sized but contain dynamically-sized arrays as struct members or inner arrays. Such types are only available if ABIEncoderV2 is activated.",
 "introduced": "0.4.16",
 "fixed": "0.5.9",
 "severity": "very low",
 "conditions": {
 "ABIEncoderV2": true
 }
 },
 {
 "uid": "SOL-2019-5",
 "name": "UninitializedFunctionPointerInConstructor",
 "summary": "Calling uninitialized internal function pointers created in the constructor does not always revert and can cause unexpected behaviour.",
 "description": "Uninitialized internal function pointers point to a special piece of code that causes a revert when called. Jump target positions are different during construction and after deployment, but the code for setting this special jump target only considered the situation after deployment.",
 "introduced": "0.5.0",
 "fixed": "0.5.8",
 "severity": "very low"
 },
 {
 "uid": "SOL-2019-5",
 "name": "UninitializedFunctionPointerInConstructor\_0.4.x",
 "summary": "Calling uninitialized internal function pointers created in the constructor does not always revert and can cause unexpected behaviour.",
 "description": "Uninitialized internal function pointers point to a special piece of code that causes a revert when called. Jump target positions are different during construction and after deployment, but the code for setting this special jump target only considered the situation after deployment.",
 "introduced": "0.4.5",
 "fixed": "0.4.26",
 "severity": "very low"
 },
 {
 "uid": "SOL-2019-4",
 "name": "IncorrectEventSignatureInLibraries",
 "summary": "Contract types used in events in libraries cause an incorrect event signature hash",
 "description": "Instead of using the type \`address\` in the hashed signature, the actual contract name was used, leading to a wrong hash in the logs.",
 "introduced": "0.5.0",
 "fixed": "0.5.8",
 "severity": "very low"
 },
 {
 "uid": "SOL-2019-4",
 "name": "IncorrectEventSignatureInLibraries\_0.4.x",
 "summary": "Contract types used in events in libraries cause an incorrect event signature hash",
 "description": "Instead of using the type \`address\` in the hashed signature, the actual contract name was used, leading to a wrong hash in the logs.",
 "introduced": "0.3.0",
 "fixed": "0.4.26",
 "severity": "very low"
 },
 {
 "uid": "SOL-2019-3",
 "name": "ABIEncoderV2PackedStorage",
 "summary": "Storage structs and arrays with types shorter than 32 bytes can cause data corruption if encoded directly from storage using the experimental ABIEncoderV2.",
 "description": "Elements of structs and arrays that are shorter than 32 bytes are not properly decoded from storage when encoded directly (i.e. not via a memory type) using ABIEncoderV2. This can cause corruption in the values themselves but can also overwrite other parts of the encoded data.",
 "link": "https://blog.soliditylang.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/",
 "introduced": "0.5.0",
 "fixed": "0.5.7",
 "severity": "low",
 "conditions": {
 "ABIEncoderV2": true
 }
 },
 {
 "uid": "SOL-2019-3",
 "name": "ABIEncoderV2PackedStorage\_0.4.x",
 "summary": "Storage structs and arrays with types shorter than 32 bytes can cause data corruption if encoded directly from storage using the experimental ABIEncoderV2.",
 "description": "Elements of structs and arrays that are shorter than 32 bytes are not properly decoded from storage when encoded directly (i.e. not via a memory type) using ABIEncoderV2. This can cause corruption in the values themselves but can also overwrite other parts of the encoded data.",
 "link": "https://blog.soliditylang.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/",
 "introduced": "0.4.19",
 "fixed": "0.4.26",
 "severity": "low",
 "conditions": {
 "ABIEncoderV2": true
 }
 },
 {
 "uid": "SOL-2019-2",
 "name": "IncorrectByteInstructionOptimization",
 "summary": "The optimizer incorrectly handles byte opcodes whose second argument is 31 or a constant expression that evaluates to 31. This can result in unexpected values.",
 "description": "The optimizer incorrectly handles byte opcodes that use the constant 31 as second argument. This can happen when performing index access on bytesNN types with a compile-time constant value (not index) of 31 or when using the byte opcode in inline assembly.",
 "link": "https://blog.soliditylang.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/",
 "introduced": "0.5.5",
 "fixed": "0.5.7",
 "severity": "very low",
 "conditions": {
 "optimizer": true
 }
 },
 {
 "uid": "SOL-2019-1",
 "name": "DoubleShiftSizeOverflow",
 "summary": "Double bitwise shifts by large constants whose sum overflows 256 bits can result in unexpected values.",
 "description": "Nested logical shift operations whose total shift size is 2\*\*256 or more are incorrectly optimized. This only applies to shifts by numbers of bits that are compile-time constant expressions.",
 "link": "https://blog.soliditylang.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/",
 "introduced": "0.5.5",
 "fixed": "0.5.6",
 "severity": "low",
 "conditions": {
 "optimizer": true,
 "evmVersion": ">=constantinople"
 }
 },
 {
 "uid": "SOL-2018-4",
 "name": "ExpExponentCleanup",
 "summary": "Using the \*\* operator with an exponent of type shorter than 256 bits can result in unexpected values.",
 "description": "Higher order bits in the exponent are not properly cleaned before the EXP opcode is applied if the type of the exponent expression is smaller than 256 bits and not smaller than the type of the base. In that case, the result might be larger than expected if the exponent is assumed to lie within the value range of the type. Literal numbers as exponents are unaffected as are exponents or bases of type uint256.",
 "link": "https://blog.soliditylang.org/2018/09/13/solidity-bugfix-release/",
 "fixed": "0.4.25",
 "severity": "medium/high",
 "check": {"regex-source": "\[^/\]\\\\\*\\\\\* \*\[^/0-9 \]"}
 },
 {
 "uid": "SOL-2018-3",
 "name": "EventStructWrongData",
 "summary": "Using structs in events logged wrong data.",
 "description": "If a struct is used in an event, the address of the struct is logged instead of the actual data.",
 "link": "https://blog.soliditylang.org/2018/09/13/solidity-bugfix-release/",
 "introduced": "0.4.17",
 "fixed": "0.4.25",
 "severity": "very low",
 "check": {"ast-compact-json-path": "$..\[?(@.nodeType === 'EventDefinition')\]..\[?(@.nodeType === 'UserDefinedTypeName' && @.typeDescriptions.typeString.startsWith('struct'))\]"}
 },
 {
 "uid": "SOL-2018-2",
 "name": "NestedArrayFunctionCallDecoder",
 "summary": "Calling functions that return multi-dimensional fixed-size arrays can result in memory corruption.",
 "description": "If Solidity code calls a function that returns a multi-dimensional fixed-size array, array elements are incorrectly interpreted as memory pointers and thus can cause memory corruption if the return values are accessed. Calling functions with multi-dimensional fixed-size arrays is unaffected as is returning fixed-size arrays from function calls. The regular expression only checks if such functions are present, not if they are called, which is required for the contract to be affected.",
 "link": "https://blog.soliditylang.org/2018/09/13/solidity-bugfix-release/",
 "introduced": "0.1.4",
 "fixed": "0.4.22",
 "severity": "medium",
 "check": {"regex-source": "returns\[^;{\]\*\\\\\[\\\\s\*\[^\\\\\] \\\\t\\\\r\\\\n\\\\v\\\\f\]\[^\\\\\]\]\*\\\\\]\\\\s\*\\\\\[\\\\s\*\[^\\\\\] \\\\t\\\\r\\\\n\\\\v\\\\f\]\[^\\\\\]\]\*\\\\\]\[^{;\]\*\[;{\]"}
 },
 {
 "uid": "SOL-2018-1",
 "name": "OneOfTwoConstructorsSkipped",
 "summary": "If a contract has both a new-style constructor (using the constructor keyword) and an old-style constructor (a function with the same name as the contract) at the same time, one of them will be ignored.",
 "description": "If a contract has both a new-style constructor (using the constructor keyword) and an old-style constructor (a function with the same name as the contract) at the same time, one of them will be ignored. There will be a compiler warning about the old-style constructor, so contracts only using new-style constructors are fine.",
 "introduced": "0.4.22",
 "fixed": "0.4.23",
 "severity": "very low"
 },
 {
 "uid": "SOL-2017-5",
 "name": "ZeroFunctionSelector",
 "summary": "It is possible to craft the name of a function such that it is executed instead of the fallback function in very specific circumstances.",
 "description": "If a function has a selector consisting only of zeros, is payable and part of a contract that does not have a fallback function and at most five external functions in total, this function is called instead of the fallback function if Ether is sent to the contract without data.",
 "fixed": "0.4.18",
 "severity": "very low"
 },
 {
 "uid": "SOL-2017-4",
 "name": "DelegateCallReturnValue",
 "summary": "The low-level .delegatecall() does not return the execution outcome, but converts the value returned by the functioned called to a boolean instead.",
 "description": "The return value of the low-level .delegatecall() function is taken from a position in memory, where the call data or the return data resides. This value is interpreted as a boolean and put onto the stack. This means if the called function returns at least 32 zero bytes, .delegatecall() returns false even if the call was successful.",
 "introduced": "0.3.0",
 "fixed": "0.4.15",
 "severity": "low"
 },
 {
 "uid": "SOL-2017-3",
 "name": "ECRecoverMalformedInput",
 "summary": "The ecrecover() builtin can return garbage for malformed input.",
 "description": "The ecrecover precompile does not properly signal failure for malformed input (especially in the 'v' argument) and thus the Solidity function can return data that was previously present in the return area in memory.",
 "fixed": "0.4.14",
 "severity": "medium"
 },
 {
 "uid": "SOL-2017-2",
 "name": "SkipEmptyStringLiteral",
 "summary": "If \\"\\" is used in a function call, the following function arguments will not be correctly passed to the function.",
 "description": "If the empty string literal \\"\\" is used as an argument in a function call, it is skipped by the encoder. This has the effect that the encoding of all arguments following this is shifted left by 32 bytes and thus the function call data is corrupted.",
 "fixed": "0.4.12",
 "severity": "low"
 },
 {
 "uid": "SOL-2017-1",
 "name": "ConstantOptimizerSubtraction",
 "summary": "In some situations, the optimizer replaces certain numbers in the code with routines that compute different numbers.",
 "description": "The optimizer tries to represent any number in the bytecode by routines that compute them with less gas. For some special numbers, an incorrect routine is generated. This could allow an attacker to e.g. trick victims about a specific amount of ether, or function calls to call different functions (or none at all).",
 "link": "https://blog.soliditylang.org/2017/05/03/solidity-optimizer-bug/",
 "fixed": "0.4.11",
 "severity": "low",
 "conditions": {
 "optimizer": true
 }
 },
 {
 "uid": "SOL-2016-11",
 "name": "IdentityPrecompileReturnIgnored",
 "summary": "Failure of the identity precompile was ignored.",
 "description": "Calls to the identity contract, which is used for copying memory, ignored its return value. On the public chain, calls to the identity precompile can be made in a way that they never fail, but this might be different on private chains.",
 "severity": "low",
 "fixed": "0.4.7"
 },
 {
 "uid": "SOL-2016-10",
 "name": "OptimizerStateKnowledgeNotResetForJumpdest",
 "summary": "The optimizer did not properly reset its internal state at jump destinations, which could lead to data corruption.",
 "description": "The optimizer performs symbolic execution at certain stages. At jump destinations, multiple code paths join and thus it has to compute a common state from the incoming edges. Computing this common state was simplified to just use the empty state, but this implementation was not done properly. This bug can cause data corruption.",
 "severity": "medium",
 "introduced": "0.4.5",
 "fixed": "0.4.6",
 "conditions": {
 "optimizer": true
 }
 },
 {
 "uid": "SOL-2016-9",
 "name": "HighOrderByteCleanStorage",
 "summary": "For short types, the high order bytes were not cleaned properly and could overwrite existing data.",
 "description": "Types shorter than 32 bytes are packed together into the same 32 byte storage slot, but storage writes always write 32 bytes. For some types, the higher order bytes were not cleaned properly, which made it sometimes possible to overwrite a variable in storage when writing to another one.",
 "link": "https://blog.soliditylang.org/2016/11/01/security-alert-solidity-variables-can-overwritten-storage/",
 "severity": "high",
 "introduced": "0.1.6",
 "fixed": "0.4.4"
 },
 {
 "uid": "SOL-2016-8",
 "name": "OptimizerStaleKnowledgeAboutSHA3",
 "summary": "The optimizer did not properly reset its knowledge about SHA3 operations resulting in some hashes (also used for storage variable positions) not being calculated correctly.",
 "description": "The optimizer performs symbolic execution in order to save re-evaluating expressions whose value is already known. This knowledge was not properly reset across control flow paths and thus the optimizer sometimes thought that the result of a SHA3 operation is already present on the stack. This could result in data corruption by accessing the wrong storage slot.",
 "severity": "medium",
 "fixed": "0.4.3",
 "conditions": {
 "optimizer": true
 }
 },
 {
 "uid": "SOL-2016-7",
 "name": "LibrariesNotCallableFromPayableFunctions",
 "summary": "Library functions threw an exception when called from a call that received Ether.",
 "description": "Library functions are protected against sending them Ether through a call. Since the DELEGATECALL opcode forwards the information about how much Ether was sent with a call, the library function incorrectly assumed that Ether was sent to the library and threw an exception.",
 "severity": "low",
 "introduced": "0.4.0",
 "fixed": "0.4.2"
 },
 {
 "uid": "SOL-2016-6",
 "name": "SendFailsForZeroEther",
 "summary": "The send function did not provide enough gas to the recipient if no Ether was sent with it.",
 "description": "The recipient of an Ether transfer automatically receives a certain amount of gas from the EVM to handle the transfer. In the case of a zero-transfer, this gas is not provided which causes the recipient to throw an exception.",
 "severity": "low",
 "fixed": "0.4.0"
 },
 {
 "uid": "SOL-2016-5",
 "name": "DynamicAllocationInfiniteLoop",
 "summary": "Dynamic allocation of an empty memory array caused an infinite loop and thus an exception.",
 "description": "Memory arrays can be created provided a length. If this length is zero, code was generated that did not terminate and thus consumed all gas.",
 "severity": "low",
 "fixed": "0.3.6"
 },
 {
 "uid": "SOL-2016-4",
 "name": "OptimizerClearStateOnCodePathJoin",
 "summary": "The optimizer did not properly reset its internal state at jump destinations, which could lead to data corruption.",
 "description": "The optimizer performs symbolic execution at certain stages. At jump destinations, multiple code paths join and thus it has to compute a common state from the incoming edges. Computing this common state was not done correctly. This bug can cause data corruption, but it is probably quite hard to use for targeted attacks.",
 "severity": "low",
 "fixed": "0.3.6",
 "conditions": {
 "optimizer": true
 }
 },
 {
 "uid": "SOL-2016-3",
 "name": "CleanBytesHigherOrderBits",
 "summary": "The higher order bits of short bytesNN types were not cleaned before comparison.",
 "description": "Two variables of type bytesNN were considered different if their higher order bits, which are not part of the actual value, were different. An attacker might use this to reach seemingly unreachable code paths by providing incorrectly formatted input data.",
 "severity": "medium/high",
 "fixed": "0.3.3"
 },
 {
 "uid": "SOL-2016-2",
 "name": "ArrayAccessCleanHigherOrderBits",
 "summary": "Access to array elements for arrays of types with less than 32 bytes did not correctly clean the higher order bits, causing corruption in other array elements.",
 "description": "Multiple elements of an array of values that are shorter than 17 bytes are packed into the same storage slot. Writing to a single element of such an array did not properly clean the higher order bytes and thus could lead to data corruption.",
 "severity": "medium/high",
 "fixed": "0.3.1"
 },
 {
 "uid": "SOL-2016-1",
 "name": "AncientCompiler",
 "summary": "This compiler version is ancient and might contain several undocumented or undiscovered bugs.",
 "description": "The list of bugs is only kept for compiler versions starting from 0.3.0, so older versions might contain undocumented bugs.",
 "severity": "high",
 "fixed": "0.3.0"
 }
\]

# [语言的影响因素 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/language-influences.html) 
 _https://docs.soliditylang.org/zh-cn/latest/language-influences.html_

* [](https://docs.soliditylang.org/zh-cn/latest/index.html)
* 语言的影响因素
* [在 GitHub 上编辑](https://github.com/solidity-docs/zh-chinese/blob/develop/docs/language-influences.rst)
* * *
## 语言的影响因素[](#id1 "此标题的永久链接")
Solidity是一种 [花括号语言](https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Curly-bracket_languages)， 受到几种著名编程语言的影响和启发。
Solidity受C++的影响最深，但也借用了Python，JavaScript等语言的概念。
从变量声明的语法，for循环，重写函数的概念，隐式和显式类型转换以及许多其他细节中可以看出C++的影响。
这是由于变量的函数级范围和关键字 `var` 的使用。 从0.4.0版本开始，JavaScript的影响已经减少。 现在，剩下的与JavaScript的主要相似之处是，使用关键字 `function` 来定义函数。 Solidity还支持导入语法和语义，这些都与JavaScript中的相似。 除了这些点，Solidity看起来和其他大多数花括号语言一样，不再有主要的JavaScript影响。
对Solidity的另一个影响是Python。 Solidity的修改器是为了模拟Python的装饰器而添加的，但其功能受到很大限制。 此外，多重继承，C3线性化和 `super` 关键字以及值和引用类型的一般赋值和复制语义都来自Python。

# [索引 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/genindex.html) 
 _https://docs.soliditylang.org/zh-cn/latest/genindex.html_

## 索引
[**符号**](#符号) | [**A**](#A) | [**B**](#B) | [**C**](#C) | [**D**](#D) | [**E**](#E) | [**F**](#F) | [**G**](#G) | [**H**](#H) | [**I**](#I) | [**J**](#J) | [**K**](#K) | [**L**](#L) | [**M**](#M) | [**N**](#N) | [**O**](#O) | [**P**](#P) | [**R**](#R) | [**S**](#S) | [**T**](#T) | [**U**](#U) | [**V**](#V) | [**W**](#W) | [**Y**](#Y)
## 符号
* [**\--allow-paths**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-8), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#index-1)
* [**\--base-path**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-7), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#index-1), [\[2\]](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#index-3)
* [**\--include-path**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-7), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#index-1)
* [**\--libraries**](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#index-2)
* [**\--link**](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#index-2)
* [**\--no-import-callback**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-1)
* [**\--standard-json**](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#index-5), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#index-3)
* [<stdin>](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-3)
## A
* [abi](https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#index-0), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-3), [\[2\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-4)
 * [decode](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-1)
 * [encode](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-1)
 * [encodeCall](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-1)
 * [encodePacked](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-1)
 * [encodeWithSelector](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-1)
 * [encodeWithSignature](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-1)
* [**ABI coder**](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-3)
* [**abstract contract**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-23), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-21)
* access
 * [restricting](https://docs.soliditylang.org/zh-cn/latest/common-patterns.html#index-1)
* [**account**](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-7)
* [addmod](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-8)
* [address](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-7), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/types.html#index-5), [\[2\]](https://docs.soliditylang.org/zh-cn/latest/types.html#index-8)
 * [balance](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-3)
 * [code](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-3)
 * [codehash](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-3)
 * [send](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-3)
 * [transfer](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-3)
* [**allowed paths**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-8), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#index-1)
* [analyse](https://docs.soliditylang.org/zh-cn/latest/analysing-compilation-output.html#index-0)
* [anonymous](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-11)
* [application binary interface](https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#index-0)
* [**array**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-17), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-8), [\[2\]](https://docs.soliditylang.org/zh-cn/latest/types.html#index-16)
 * [**allocating**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-20)
 * [**dangling storage references**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-23)
 * [**length**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-22)
 * [**pop**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-22)
 * [**push**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-22)
 * [**slice**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-24)
* [array of strings](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-8)
* [**asm**](https://docs.soliditylang.org/zh-cn/latest/assembly.html#index-0), [**\[1\]**](https://docs.soliditylang.org/zh-cn/latest/yul.html#index-0), [\[2\]](https://docs.soliditylang.org/zh-cn/latest/analysing-compilation-output.html#index-0)
* [**assembly**](https://docs.soliditylang.org/zh-cn/latest/assembly.html#index-0), [**\[1\]**](https://docs.soliditylang.org/zh-cn/latest/yul.html#index-0)
* [assembly-flags (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.assemblyFlags)
* [assembly-statement (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.assemblyStatement)
* [**assert**](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-8), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-6), [\[2\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-7)
* [**assignment**](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-4), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/types.html#index-29)
 * [**destructuring**](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-5)
* auction
 * [blind](https://docs.soliditylang.org/zh-cn/latest/solidity-by-example.html#index-1)
 * [open](https://docs.soliditylang.org/zh-cn/latest/solidity-by-example.html#index-1)
## B
* [balance](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-7), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/types.html#index-5), [\[2\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-9)
* [ballot](https://docs.soliditylang.org/zh-cn/latest/solidity-by-example.html#index-0)
* base
 * [**constructor**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-21)
* [**base class**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-17)
* [**base path**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-7), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#index-1)
* [blind auction](https://docs.soliditylang.org/zh-cn/latest/solidity-by-example.html#index-1)
* [blobhash](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-4)
* [**block**](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-5), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-4), [\[2\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-3)
 * [basefee](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-4), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-3)
 * [blobbasefee](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-4), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-3)
 * [chainid](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-4)
 * [coinbase](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-4)
 * [difficulty](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-4)
 * [gaslimit](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-4)
 * [number](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-4), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-3)
 * [prevrandao](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-4)
 * [timestamp](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-4), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-3)
* [block (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.block)
* [blockhash](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-4)
* [**bool**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-2)
* [boolean-literal (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.booleanLiteral)
* [break](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-1)
* [break-statement (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.breakStatement)
* [Bugs](https://docs.soliditylang.org/zh-cn/latest/bugs.html#index-0)
* [byte array](https://docs.soliditylang.org/zh-cn/latest/types.html#index-7)
* [**bytes**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-18), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/types.html#index-12)
 * [concat](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-2)
* [bytes members](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-5)
* [**bytes-concat**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-19)
* [bytes32](https://docs.soliditylang.org/zh-cn/latest/types.html#index-7)
## C
* [**C3 linearization**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-22)
* [call](https://docs.soliditylang.org/zh-cn/latest/types.html#index-5), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-9)
* [call-argument-list (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.callArgumentList)
* [callcode](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-25), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-9)
* [**cast**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-32)
* [catch-clause (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.catchClause)
* [checked](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-7)
* [cleanup](https://docs.soliditylang.org/zh-cn/latest/ir-breaking-changes.html#index-3)
* [codehash](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-9)
* [coding style](https://docs.soliditylang.org/zh-cn/latest/style-guide.html#index-0)
* [coin](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-3)
* [coinbase](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-3)
* [**commandline compiler**](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#index-0)
* [**comment**](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-9)
* [common subexpression elimination](https://docs.soliditylang.org/zh-cn/latest/internals/optimizer.html#index-0)
* [compile target](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#index-4)
* compiler
 * [commandline](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#index-0)
* [**compound operators**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-29)
* [**constant**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-6), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-11)
* [constant propagation](https://docs.soliditylang.org/zh-cn/latest/internals/optimizer.html#index-0)
* [constant-variable-declaration (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.constantVariableDeclaration)
* [**constructor**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-20), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-1)
 * [arguments](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-2)
* [constructor-definition (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.constructorDefinition)
* [continue](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-1)
* [continue-statement (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.continueStatement)
* [**contract**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-0), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#index-0)
 * [**abstract**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-23), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-21)
 * [**base**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-17)
 * [**creation**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-1)
 * [**interface**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-24)
 * [modular](https://docs.soliditylang.org/zh-cn/latest/solidity-by-example.html#index-3)
 * [**precompiled**](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-17)
* [contract creation](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-15)
* [**contract type**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-6)
* [contract verification](https://docs.soliditylang.org/zh-cn/latest/metadata.html#index-0)
* [contract-body-element (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.contractBodyElement)
* [contract-definition (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.contractDefinition)
* contracts
 * [creating](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-3)
* [creationCode](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-11)
* [cryptography](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-8)
* [custom type](https://docs.soliditylang.org/zh-cn/latest/types.html#index-14)
## D
* [data](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-3)
* [data-location (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.dataLocation)
* [**days**](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-2)
* [deactivate](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-16)
* [decimal-number (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer.DecimalNumber)
* [declarations](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-6)
* [default value](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-6)
* [delegatecall](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-25), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-13), [\[2\]](https://docs.soliditylang.org/zh-cn/latest/types.html#index-5), [\[3\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-9)
* [**delete**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-30)
* [**denomination**](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-0)
 * [**ether**](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-1)
 * [**time**](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-2)
* [**deriving**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-17)
* [difficulty](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-3)
* [**direct import**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-5)
* [dirty bits](https://docs.soliditylang.org/zh-cn/latest/ir-breaking-changes.html#index-3)
* [do-while-statement (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.doWhileStatement)
* [do/while](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-1)
* [double-quoted-printable (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer.DoubleQuotedPrintable)
* [dynamic array](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-8)
## E
* [ecrecover](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-8)
* [elementary-type-name (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.elementaryTypeName)
* [else](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-1)
* [emit-statement (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.emitStatement)
* [empty-string-literal (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer.EmptyStringLiteral)
* [encode](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-3)
* [encoding](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-4)
* [enum](https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#index-0), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/types.html#index-13)
* [enum-definition (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.enumDefinition)
* [**error**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-16), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#index-2)
* [error-definition (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.errorDefinition)
* [error-parameter (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.errorParameter)
* [**errors**](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-8)
* [escape-sequence (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer.EscapeSequence)
* [escrow](https://docs.soliditylang.org/zh-cn/latest/solidity-by-example.html#index-2)
* [**ether**](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-1)
* [**ethereum virtual machine**](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-6)
* evaluation order
 * [**expression**](https://docs.soliditylang.org/zh-cn/latest/ir-breaking-changes.html#index-0)
 * [**function arguments**](https://docs.soliditylang.org/zh-cn/latest/ir-breaking-changes.html#index-1)
* [**event**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-14), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-2), [\[2\]](https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#index-0)
 * [**anonymous**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-14)
 * [**indexed**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-14)
 * [**topic**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-14)
* [event-definition (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.eventDefinition)
* [event-parameter (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.eventParameter)
* [**evm**](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-6)
* [**EVM version**](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#index-4)
* [**evmasm**](https://docs.soliditylang.org/zh-cn/latest/assembly.html#index-0), [**\[1\]**](https://docs.soliditylang.org/zh-cn/latest/yul.html#index-0)
* [**exception**](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-8)
* [expression (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.expression)
* [expression-statement (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.expressionStatement)
* [external](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-10), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-3)
## F
* [**fallback function**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-12)
* [fallback-function-definition (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.fallbackFunctionDefinition)
* [**false**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-2)
* [file://](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-10)
* [filesystem path](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-8)
* [**finney**](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-1)
* [**fixed**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-4)
* [**fixed point number**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-4)
* [fixed-bytes (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer.FixedBytes)
* [for](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-1)
* [for-statement (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.forStatement)
* [function](https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#index-0)
 * [**call**](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-2), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-12)
 * [external](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-2)
 * [fallback](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-12)
 * [**free**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-7), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-28)
 * [**getter**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-4)
 * [internal](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-2)
 * [**modifier**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-5), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/common-patterns.html#index-2), [\[2\]](https://docs.soliditylang.org/zh-cn/latest/common-patterns.html#index-4), [\[3\]](https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#index-0)
 * [pure](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-10)
 * [receive](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-11)
 * [view](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-9)
* [function parameter](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-0)
* [function pointers](https://docs.soliditylang.org/zh-cn/latest/ir-breaking-changes.html#index-2)
* [**function type**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-15)
* [function-definition (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.functionDefinition)
* [function-type-name (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.functionTypeName)
* [**functions**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-7)
## G
* [**gas**](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-9), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-3)
* [**gas price**](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-9), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-3)
* [gasleft](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-5)
* getter
 * [**function**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-4)
* [goto](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-1)
* [**gwei**](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-1)
## H
* [hex-number (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer.HexNumber)
* [hex-string (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer.HexString)
* [hex-string-literal (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.hexStringLiteral)
* [**Host Filesystem Loader**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-1)
* [**hours**](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-2)
## I
* [identifier (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer.Identifier), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.identifier)
* [identifier-path (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.identifierPath)
* [if](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-1)
* [if-statement (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.ifStatement)
* [**import**](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-7)
 * [direct](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-5)
 * [**path**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-4), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-8)
 * [**relative**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-6)
 * [**remapping**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-9)
* [**import callback**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-1), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-8)
* [import-directive (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.importDirective)
* [**include paths**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-7), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#index-1)
* [indexed](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-11)
* [**inheritance**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-17)
 * [**multiple**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-22)
* [inheritance list](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-21)
* [inheritance-specifier (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.inheritanceSpecifier)
* inline
 * [**arrays**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-21)
* [inline-array-expression (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.inlineArrayExpression)
* [**installing**](https://docs.soliditylang.org/zh-cn/latest/installing-solidity.html#index-0)
* [**instruction**](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-11)
* [**int**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-3)
* [**integer**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-3), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/types.html#index-9)
* [**interface contract**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-24)
* [interface-definition (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.interfaceDefinition)
* [internal](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-10), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-3)
* [**iterable mappings**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-27)
* [iulia](https://docs.soliditylang.org/zh-cn/latest/yul.html#index-0)
## J
* [julia](https://docs.soliditylang.org/zh-cn/latest/yul.html#index-0)
## K
* [keccak256](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-8)
## L
* [length](https://docs.soliditylang.org/zh-cn/latest/types.html#index-22)
* [**library**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-25), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-28), [\[2\]](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-13)
* [library-definition (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.libraryDefinition)
* [**license**](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-0)
* [**linearization**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-22)
* [**linker**](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#index-2)
* literal
 * [**address**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-8), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/types.html#index-35)
 * [**array**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-21)
 * [**conversion**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-33)
 * [**hexadecimal**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-12), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/types.html#index-34)
 * [hexadecimal number](https://docs.soliditylang.org/zh-cn/latest/types.html#index-33)
 * [**in Yul**](https://docs.soliditylang.org/zh-cn/latest/yul.html#index-1)
 * [**rational**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-9), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/types.html#index-33)
 * [**string**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-10), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/types.html#index-34)
 * [**unicode**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-11)
* [literal (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.literal)
* [literal-with-sub-denomination (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.literalWithSubDenomination)
* [location](https://docs.soliditylang.org/zh-cn/latest/types.html#index-16)
* [log](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-14)
* [lvalue](https://docs.soliditylang.org/zh-cn/latest/types.html#index-29)
## M
* [**mapping**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-26), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/internals/layout_in_storage.html#index-0), [\[2\]](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-1)
* [mapping-key-type (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.mappingKeyType)
* [mapping-type (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.mappingType)
* [**memory**](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-10), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/types.html#index-16)
* [**message call**](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-12)
* [metadata](https://docs.soliditylang.org/zh-cn/latest/metadata.html#index-0)
* [**minutes**](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-2)
* [modifier-definition (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.modifierDefinition)
* [modifier-invocation (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.modifierInvocation)
* [modifiers](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-11)
* [modular contract](https://docs.soliditylang.org/zh-cn/latest/solidity-by-example.html#index-3)
* [module](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-7)
* [msg](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-3)
 * [data](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-5)
 * [sender](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-5)
 * [sig](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-5)
 * [value](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-5)
* [mulmod](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-8)
## N
* [natspec](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-9)
* [**new**](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-3), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/types.html#index-20)
* [non-empty-string-literal (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer.NonEmptyStringLiteral)
* [number](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-3)
* [number-literal (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.numberLiteral)
## O
* [open auction](https://docs.soliditylang.org/zh-cn/latest/solidity-by-example.html#index-1)
* [**operator**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-28)
 * [**precedence**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-31), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-0)
 * [**user-defined**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-28)
* [optimiser](https://docs.soliditylang.org/zh-cn/latest/internals/optimizer.html#index-0)
* [optimizer](https://docs.soliditylang.org/zh-cn/latest/internals/optimizer.html#index-0)
* [origin](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-3)
* [**overload**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-13)
* [override-specifier (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.overrideSpecifier)
* overriding
 * [**function**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-18)
 * [**modifier**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-19)
## P
* [packed](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-4)
* [**parameter**](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-0)
 * [function](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-0)
 * [input](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-0)
 * [output](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-0)
* [parameter-list (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.parameterList)
* [path (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.path)
* [payable](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-11)
* [pop](https://docs.soliditylang.org/zh-cn/latest/types.html#index-22)
* [**pragma**](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-1)
 * [**abicoder**](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-3)
 * [**ABIEncoderV2**](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-5), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-3)
 * [**experimental**](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-4)
 * [**SMTChecker**](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-6)
 * [**version**](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-2)
* [pragma-token (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer.PragmaToken)
* [**precompiled contracts**](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-17)
* [**precompiles**](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-17)
* [prevrandao](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-3)
* [private](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-10), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-3)
* [public](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-10), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-3)
* [purchase](https://docs.soliditylang.org/zh-cn/latest/solidity-by-example.html#index-2)
* [pure](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-11)
* [**pure function**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-10)
* [push](https://docs.soliditylang.org/zh-cn/latest/types.html#index-22)
## R
* [rational number](https://docs.soliditylang.org/zh-cn/latest/types.html#index-9)
* [**receive**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-11)
* [**receive ether function**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-11)
* [receive-function-definition (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.receiveFunctionDefinition)
* [**reference type**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-16)
* [**relative import**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-6)
* remapping
 * [**context**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-9)
 * [**import**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-9)
 * [**prefix**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-9)
 * [**target**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-9), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-8)
* [Remix IDE](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-8), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-10)
* [remote purchase](https://docs.soliditylang.org/zh-cn/latest/solidity-by-example.html#index-2)
* [**require**](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-8), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-6), [\[2\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-7)
* [return](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-0), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-1)
* [return array](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-8)
* [return string](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-8)
* [return struct](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-8)
* [return variable](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-0)
* [return-statement (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.returnStatement)
* [**revert**](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-8), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-6), [\[2\]](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-16), [\[3\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-7)
* [revert-statement (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.revertStatement)
* [ripemd160](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-8)
* [runtimeCode](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-11)
## S
* [**safe math**](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-7)
* [safemath](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-7)
* [**scoping**](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-6)
* [**seconds**](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-2)
* selector
 * [**of a function**](https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#index-1), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/assembly.html#index-1)
 * [**of a library function**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-27)
 * [**of an error**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-16), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#index-2)
 * [**of an event**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-15)
* [**selfdestruct**](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-16), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-8), [\[2\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-10)
* [send](https://docs.soliditylang.org/zh-cn/latest/types.html#index-5), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-9)
* [sender](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-3)
* [set](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-26)
* [sha256](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-8)
* [signed-integer-type (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer.SignedIntegerType)
* [single-quoted-printable (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer.SingleQuotedPrintable)
* [**solc**](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#index-0)
* [SolidityLexer (Antlr4 lexer grammar)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer)
* [SolidityParser (Antlr4 parser grammar)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser)
* [source file](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-7)
* [source mappings](https://docs.soliditylang.org/zh-cn/latest/internals/source_mappings.html#index-0)
* [source unit](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-7)
* [**source unit name**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-0), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-8)
* [source-unit (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.sourceUnit)
* [spdx](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-0)
* [**stack**](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-10)
* [standard input](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-3)
* [**standard JSON**](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#index-5), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-2)
* [state machine](https://docs.soliditylang.org/zh-cn/latest/common-patterns.html#index-3)
* [state variable](https://docs.soliditylang.org/zh-cn/latest/internals/layout_in_storage.html#index-0), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#index-0)
* [state-mutability (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.stateMutability)
* [state-variable-declaration (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.stateVariableDeclaration)
* [statement (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.statement)
* [staticcall](https://docs.soliditylang.org/zh-cn/latest/types.html#index-5), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-9)
* [stdin](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-3)
* [**storage**](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-10), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/internals/layout_in_storage.html#index-0), [\[2\]](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-7), [\[3\]](https://docs.soliditylang.org/zh-cn/latest/types.html#index-16)
* [**string**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-18), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-8), [\[2\]](https://docs.soliditylang.org/zh-cn/latest/types.html#index-10)
 * [concat](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-2)
* [string members](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-6)
* [**string-concat**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-19)
* [string-literal (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.stringLiteral)
* [**struct**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-25), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-8), [\[2\]](https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#index-0), [\[3\]](https://docs.soliditylang.org/zh-cn/latest/types.html#index-16)
* [struct-definition (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.structDefinition)
* [struct-member (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.structMember)
* [style](https://docs.soliditylang.org/zh-cn/latest/style-guide.html#index-0)
* [sub-denomination (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer.SubDenomination)
* [**subcurrency**](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-0)
* [super](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-8), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-10)
* [switch](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-1)
* [symbol-aliases (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.symbolAliases)
* [**szabo**](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-1)
## T
* [this](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-8), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-10)
* [**throw**](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-8)
* [timestamp](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-3)
* [**transaction**](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-8), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/introduction-to-smart-contracts.html#index-4)
* [transfer](https://docs.soliditylang.org/zh-cn/latest/types.html#index-5), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-9)
* [**true**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-2)
* [try-statement (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.tryStatement)
* [tuple-expression (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.tupleExpression)
* tx
 * [gasprice](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-5)
 * [origin](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-5)
* [type](https://docs.soliditylang.org/zh-cn/latest/types.html#index-0), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-11)
 * [**contract**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-6)
 * [**conversion**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-32)
 * [creationCode](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-9)
 * [**function**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-15)
 * [interfaceId](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-9)
 * [max](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-9)
 * [min](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-9)
 * [name](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-9)
 * [**reference**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-16)
 * [runtimeCode](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-9)
 * [**struct**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-25)
 * [**value**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-1)
* [type-name (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.typeName)
## U
* [**ufixed**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-4)
* [**uint**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-3)
* [unchecked](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-7)
* [unchecked-block (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.uncheckedBlock)
* [unicode-string-literal (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer.UnicodeStringLiteral), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.unicodeStringLiteral)
* [unsigned-integer-type (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer.UnsignedIntegerType)
* [**unused store eliminator**](https://docs.soliditylang.org/zh-cn/latest/internals/optimizer.html#index-1)
* [**user defined value type**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-14)
* [user-definable-operator (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.userDefinableOperator)
* [user-defined-value-type-definition (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.userDefinedValueTypeDefinition)
* [**using for**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-28), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-26)
* [using-directive (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.usingDirective)
## V
* [value](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-3)
* [**value type**](https://docs.soliditylang.org/zh-cn/latest/types.html#index-1)
* variable
 * [return](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-0)
* [variable-declaration (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.variableDeclaration)
* [variable-declaration-statement (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.variableDeclarationStatement)
* [variable-declaration-tuple (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.variableDeclarationTuple)
* [variably sized array](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-8)
* [**VFS**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-0)
* [view](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-11)
* [**view function**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-9)
* [**virtual filesystem**](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#index-0), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#index-8)
* [**visibility**](https://docs.soliditylang.org/zh-cn/latest/contracts.html#index-3), [\[1\]](https://docs.soliditylang.org/zh-cn/latest/cheatsheet.html#index-10)
 * [(Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.visibility)
* [voting](https://docs.soliditylang.org/zh-cn/latest/solidity-by-example.html#index-0)
## W
* [**weeks**](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-2)
* [**wei**](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-1)
* [while](https://docs.soliditylang.org/zh-cn/latest/control-structures.html#index-1)
* [while-statement (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.whileStatement)
* [withdrawal](https://docs.soliditylang.org/zh-cn/latest/common-patterns.html#index-0)
## Y
* [**years**](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#index-2)
* [**yul**](https://docs.soliditylang.org/zh-cn/latest/yul.html#index-0)
* [yul-assignment (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.yulAssignment)
* [yul-block (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.yulBlock)
* [yul-boolean (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.yulBoolean)
* [yul-decimal-number (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer.YulDecimalNumber)
* [yul-evm-builtin (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer.YulEVMBuiltin)
* [yul-expression (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.yulExpression)
* [yul-for-statement (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.yulForStatement)
* [yul-function-call (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.yulFunctionCall)
* [yul-function-definition (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.yulFunctionDefinition)
* [yul-hex-number (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer.YulHexNumber)
* [yul-identifier (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer.YulIdentifier)
* [yul-if-statement (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.yulIfStatement)
* [yul-literal (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.yulLiteral)
* [yul-path (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.yulPath)
* [yul-statement (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.yulStatement)
* [yul-string-literal (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityLexer.YulStringLiteral)
* [yul-switch-statement (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.yulSwitchStatement)
* [yul-variable-declaration (Antlr4 production rule)](https://docs.soliditylang.org/zh-cn/latest/grammar.html#a4.SolidityParser.yulVariableDeclaration)

# [Language Influences — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/language-influences.html) 
 _https://docs.soliditylang.org/en/latest/language-influences.html_

Solidity is a [curly-bracket language](https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Curly_bracket_languages) that has been influenced and inspired by several well-known programming languages.
Solidity is most profoundly influenced by C++, but also borrowed concepts from languages like Python, JavaScript, and others.
The influence from C++ can be seen in the syntax for variable declarations, for loops, the concept of overloading functions, implicit and explicit type conversions and many other details.
In the early days of the language, Solidity used to be partly influenced by JavaScript. This was due to function-level scoping of variables and the use of the keyword `var`. The JavaScript influence was reduced starting from version 0.4.0. Now, the main remaining similarity to JavaScript is that functions are defined using the keyword `function`. Solidity also supports import syntax and semantics that are similar to those available in JavaScript. Besides those points, Solidity looks like most other curly-bracket languages and has no major JavaScript influence anymore.
Another influence to Solidity was Python. Solidity’s modifiers were added trying to model Python’s decorators with a much more restricted functionality. Furthermore, multiple inheritance, C3 linearization, and the `super` keyword are taken from Python as well as the general assignment and copy semantics of value and reference types.

# [Résolution du chemin d’importation — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/path-resolution.html) 
 _https://docs.soliditylang.org/fr/latest/path-resolution.html_

Afin de pouvoir supporter des constructions reproductibles sur toutes les plateformes, le compilateur Solidity doit faire abstraction des détails du système de fichiers où sont stockés les fichiers sources. Les chemins utilisés dans les importations doivent fonctionner de la même manière partout, tandis que l’interface de la ligne de commande doit être capable de travailler avec des chemins spécifiques à la plate-forme pour fournir une bonne expérience utilisateur. Cette section vise à expliquer en détail comment Solidity concilie ces exigences.
## Système de fichiers virtuel[](#systeme-de-fichiers-virtuel "Lien permanent vers cette rubrique")
Le compilateur maintient une base de données interne (_système de fichiers virtuel_ ou _VFS_ en abrégé) dans laquelle chaque unité source se voit attribuer un _nom d’unité source_ unique qui est un identifiant opaque et non structuré. Lorsque vous utilisez l’instruction [import](https://docs.soliditylang.org/fr/latest/layout-of-source-files.html#import), vous spécifiez un _chemin d’accès à l’importation_ qui fait référence à un nom d’unité source.
### Rappel d’importation[](#rappel-d-importation "Lien permanent vers cette rubrique")
Le VFS n’est initialement peuplé que de fichiers que le compilateur a reçus en entrée. Des fichiers supplémentaires peuvent être chargés pendant la compilation en utilisant un _import callback_, qui est différent selon le type de compilateur que vous utilisez (voir ci-dessous). Si le compilateur ne trouve pas de nom d’unité source correspondant au chemin d’importation dans le VFS, il invoque le callback, qui est chargé d’obtenir le code source à placer sous ce nom. Un callback d’importation est libre d’interpréter les noms d’unité source d’une manière arbitraire, pas seulement comme des chemins. S’il n’y a pas de callback disponible lorsqu’on en a besoin ou s’il ne parvient pas à localiser le code source, la compilation échoue.
Le compilateur en ligne de commande fournit le _Host Filesystem Loader_ - un rappel rudimentaire qui interprète un nom d’unité source comme un chemin dans le système de fichiers local. L’interface [JavaScript](https://github.com/ethereum/solc-js) n’en fournit pas par défaut, mais un peut être fourni par l’utilisateur. Ce mécanisme peut être utilisé pour obtenir du code source à partir d’emplacements autres que le système de fichiers local (qui peut même ne pas être accessible, par exemple lorsque le compilateur est exécuté dans un navigateur). Par exemple l’IDE [Remix](https://remix.ethereum.org/) fournit un callback polyvalent qui vous permet [d’importer des fichiers à partir d’URL HTTP, IPFS et Swarm ou de vous référer directement à des paquets dans le registre NPM](https://remix-ide.readthedocs.io/en/latest/import.html).
Note
La recherche de fichiers du Host Filesystem Loader dépend de la plate-forme. Par exemple, les barres obliques inverses dans le nom d’une unité source peuvent être interprétées comme des séparateurs de répertoire ou non, et la recherche peut être sensible à la casse ou non, selon la plate-forme sous-jacente.
Pour des raisons de portabilité, il est recommandé d’éviter d’utiliser des chemins d’importation qui ne fonctionnent correctement qu’avec avec une fonction d’appel d’importation spécifique ou uniquement sur une plate-forme. Par exemple, vous devriez toujours utiliser des slashs avant car ils fonctionnent comme des séparateurs de chemin également sur plateformes qui prennent en charge les barres obliques inversées.
### Contenu initial du système de fichiers virtuel[](#contenu-initial-du-systeme-de-fichiers-virtuel "Lien permanent vers cette rubrique")
Le contenu initial du VFS dépend de la façon dont vous invoquez le compilateur :
1. **solc / command-line interface**
 
 Lorsque vous compilez un fichier à l’aide de l’interface de ligne de commande du compilateur, vous fournissez un ou plusieurs chemins d’accès à des fichiers contenant du code Solidity :
 
 solc contract.sol /usr/local/dapp-bin/token.sol
 
 Le nom de l’unité source d’un fichier chargé de cette façon est construit en convertissant son chemin d’accès à une forme canonique et, si possible, en le rendant relatif au chemin de base ou à l’un des chemins d’inclusion. Reportez-vous à [CLI Path Normalization and Stripping](#cli-path-normalization-and-stripping) pour une une description détaillée de ce processus.
 
2. **Standard JSON**
 
 Le nom de l’unité source d’un fichier chargé de cette façon est construit en convertissant son chemin d’accès à une forme canonique et, si possible, en le rendant relatif au chemin de base ou à l’un des chemins d’inclusion. Reportez-vous à [CLI Path Normalization and Stripping](#cli-path-normalization-and-stripping) pour une description détaillée de ce processus.
 
 {
 "language": "Solidity",
 "sources": {
 "contract.sol": {
 "content": "import \\"./util.sol\\";\\ncontract C {}"
 },
 "util.sol": {
 "content": "library Util {}"
 },
 "/usr/local/dapp-bin/token.sol": {
 "content": "contract Token {}"
 }
 },
 "settings": {"outputSelection": {"\*": { "\*": \["metadata", "evm.bytecode"\]}}}
 }
 
 Le dictionnaire `sources` devient le contenu initial du système de fichiers virtuel et ses clés sont utilisées comme noms d’unités sources.
 
3. **Standard JSON (via import callback)**
 
 Avec Standard JSON, il est également possible d’indiquer au compilateur d’utiliser le callback d’importation pour obtenir le code source :
 
 {
 "language": "Solidity",
 "sources": {
 "/usr/local/dapp-bin/token.sol": {
 "urls": \[
 "/projects/mytoken.sol",
 "https://example.com/projects/mytoken.sol"
 \]
 }
 },
 "settings": {"outputSelection": {"\*": { "\*": \["metadata", "evm.bytecode"\]}}}
 }
 
 Si un import callback est disponible, le compilateur lui donnera les chaînes spécifiées dans `urls` une par une, jusqu’à ce qu’une soit chargée avec succès ou que la fin de la liste soit atteinte.
 
 Les noms des unités de sources sont déterminés de la même manière que lors de l’utilisation de `content` - ce sont des clés du dictionnaire `sources` et le contenu de `urls` ne les affecte en aucune façon.
 
4. **Entrée standard**
 
 En ligne de commande, il est également possible de fournir la source en l’envoyant à l’entrée standard du compilateur :
 
 echo 'import "./util.sol"; contract C {}' | solc -
 
 `-` utilisé comme l’un des arguments indique au compilateur de placer le contenu de l’entrée standard dans le système de fichiers virtuel sous un nom d’unité source spécial : `<stdin>`.
 
Une fois le VFS initialisé, des fichiers supplémentaires ne peuvent y être ajoutés que par le biais de la fonction import pour y ajouter des fichiers.
## Importations[](#importations "Lien permanent vers cette rubrique")
L’instruction d’importation spécifie un _chemin d’importation_. En fonction de la façon dont le chemin d’importation est spécifié, nous pouvons diviser les importations en deux catégories :
* [Imports directs](#direct-imports), où vous spécifiez directement le nom complet de l’unité source.
 
* [Relative imports](#relative-imports), où vous spécifiez un chemin commençant par `./` ou `../` à combiner avec le nom de l’unité source du fichier d’importation.
 
contracts/contract.sol[](#id3 "Lien permanent vers ce code")
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=aW1wb3J0ICIuL21hdGgvbWF0aC5zb2wiOwppbXBvcnQgImNvbnRyYWN0cy90b2tlbnMvdG9rZW4uc29sIjs=)
import "./math/math.sol";
import "contracts/tokens/token.sol";
Dans l’exemple ci-dessus, `./math/math.sol` et `contracts/tokens/token.sol` sont des chemins d’importation alors que les noms d’unités sources vers lesquels ils sont traduits sont respectivement `contracts/math/math.sol` et `contracts/tokens/token.sol`.
### Importations directes[](#importations-directes "Lien permanent vers cette rubrique")
Une importation qui ne commence pas par `./` ou `../` est une _importation directe_.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=aW1wb3J0ICIvcHJvamVjdC9saWIvdXRpbC5zb2wiOyAgICAgICAgIC8vIG5vbSBkZSBsJ3VuaXTDqSBzb3VyY2U6IC9wcm9qZWN0L2xpYi91dGlsLnNvbAppbXBvcnQgImxpYi91dGlsLnNvbCI7ICAgICAgICAgICAgICAgICAgLy8gbm9tIGRlIGwndW5pdMOpIHNvdXJjZTogbGliL3V0aWwuc29sCmltcG9ydCAiQG9wZW56ZXBwZWxpbi9hZGRyZXNzLnNvbCI7ICAgICAvLyBub20gZGUgbCd1bml0w6kgc291cmNlOiBAb3BlbnplcHBlbGluL2FkZHJlc3Muc29sCmltcG9ydCAiaHR0cHM6Ly9leGFtcGxlLmNvbS90b2tlbi5zb2wiOyAvLyBub20gZGUgbCd1bml0w6kgc291cmNlOiBodHRwczovL2V4YW1wbGUuY29tL3Rva2VuLnNvbA==)
import "/project/lib/util.sol"; // nom de l'unité source: /project/lib/util.sol
import "lib/util.sol"; // nom de l'unité source: lib/util.sol
import "@openzeppelin/address.sol"; // nom de l'unité source: @openzeppelin/address.sol
import "https://example.com/token.sol"; // nom de l'unité source: https://example.com/token.sol
Après avoir appliqué tout [import remappings](#import-remapping), le chemin d’importation devient simplement le nom de l’unité source.
Note
Le nom d’une unité source n’est qu’un identifiant et même si sa valeur ressemble à un chemin, il n’est pas soumis aux règles de normalisation que l’on peut attendre d’un shell. Tous les segments `/./` ou `../` ou les séquences de barres obliques multiples en font toujours partie. Lorsque la source est fournie via une interface JSON standard, il est tout à fait possible d’associer différents contenus à des noms d’unités de source qui feraient référence au même fichier sur le disque.
Lorsque la source n’est pas disponible dans le système de fichiers virtuel, le compilateur transmet le nom de l’unité source à l’import callback. Le Host Filesystem Loader tentera de l’utiliser comme chemin et de rechercher le fichier sur le disque. À ce stade, les règles de normalisation spécifiques à la plate-forme entrent en jeu et les noms qui étaient considérés comme différents dans le VFS peuvent en fait aboutir au chargement du même fichier. Par exemple, `/projet/lib/math.sol` et `/projet/lib/../lib///math.sol` sont considérés comme complètement différents dans le VFS même s’ils font référence au même fichier sur le disque.
Note
Même si un callback d’importation finit par charger du code source pour deux noms d’unité source différents à partir du même fichier sur le disque, le compilateur les verra toujours comme des unités sources distinctes. C’est le nom de l’unité source qui importe, pas l’emplacement physique du code.
### Importations relatives[](#importations-relatives "Lien permanent vers cette rubrique")
Une importation commençant par `./` ou `../` est une importation _relative_. Ces importations spécifient un chemin relatif au nom de l’unité source de l’unité source importatrice :
/project/lib/math.sol[](#id4 "Lien permanent vers ce code")
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=aW1wb3J0ICIuL3V0aWwuc29sIiBhcyB1dGlsOyAgICAvLyBub20gZGUgbCd1bml0w6kgc291cmNlOiAvcHJvamVjdC9saWIvdXRpbC5zb2wKaW1wb3J0ICIuLi90b2tlbi5zb2wiIGFzIHRva2VuOyAvLyBub20gZGUgbCd1bml0w6kgc291cmNlOiAvcHJvamVjdC90b2tlbi5zb2w=)
import "./util.sol" as util; // nom de l'unité source: /project/lib/util.sol
import "../token.sol" as token; // nom de l'unité source: /project/token.sol
lib/math.sol[](#id5 "Lien permanent vers ce code")
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=aW1wb3J0ICIuL3V0aWwuc29sIiBhcyB1dGlsOyAgICAvLyBub20gZGUgbCd1bml0w6kgc291cmNlOiBsaWIvdXRpbC5zb2wKaW1wb3J0ICIuLi90b2tlbi5zb2wiIGFzIHRva2VuOyAvLyBub20gZGUgbCd1bml0w6kgc291cmNlOiB0b2tlbi5zb2w=)
import "./util.sol" as util; // nom de l'unité source: lib/util.sol
import "../token.sol" as token; // nom de l'unité source: token.sol
Note
Les importations relatives commencent toujours par `./` ou `../`. `import "./util.sol"`, est une importation directe. Alors que les deux chemins seraient considérés comme relatifs dans le système de fichiers hôte, `util.sol` est en fait absolu dans le VFS.
Définissons un _segment de chemin_ comme toute partie non vide du chemin qui ne contient pas de séparateur et qui est délimitée par deux séparateurs de chemin. Un séparateur est un slash avant ou le début/la fin de la chaîne. Par exemple, dans `./abc/..//`, il y a trois segments de chemin : `.`, `abc` et `..`.
Le compilateur calcule un nom d’unité source à partir du chemin d’importation de la manière suivante :
1. Un préfixe est d’abord calculé
 
 > * Le préfixe est initialisé avec le nom de l’unité source de l’unité source importatrice.
 > 
 > * Le dernier segment de chemin avec les barres obliques précédentes est supprimé du préfixe.
 > 
 > * Ensuite, la partie avant du chemin d’importation normalisé, composée uniquement de caractères `/` et `.`, est prise en compte. Pour chaque segment `..` trouvé dans cette partie, le dernier segment de chemin avec les barres obliques précédant est supprimé du préfixe.
 > 
 
2. Ensuite, le préfixe est ajouté au chemin d’importation normalisé. Si le préfixe n’est pas vide, une seule barre oblique est insérée entre lui et le chemin d’importation.
 
L’élimination du dernier segment de chemin avec les barres obliques précédentes fonctionne comme suit :
1. Tout ce qui dépasse la dernière barre oblique est supprimé (c’est-à-dire que `a/b//c.sol` devient `a/b//`).
 
2. Toutes les barres obliques de fin de ligne sont supprimées (par exemple, `a/b//` devient `a/b`).
 
Les règles de normalisation sont les mêmes que pour les chemins UNIX, à savoir :
* Tous les segments internes `.` sont supprimés.
 
* Chaque segment interne `..` remonte d’un niveau dans la hiérarchie.
 
* Les slashs multiples sont écrasés en un seul.
 
Notez que la normalisation est effectuée uniquement sur le chemin d’importation. Le nom de l’unité source du module d’importation qui est utilisé pour le préfixe n’est pas normalisé. Cela garantit que la partie `protocol://` ne se transforme pas en `protocol:/` si le fichier d’importation est identifié par une URL.
Si vos chemins d’importation sont déjà normalisés, vous pouvez vous attendre à ce que l’algorithme ci-dessus produise des résultats très intuitifs. Voici quelques exemples de ce que vous pouvez attendre s’ils ne le sont pas :
lib/src/../contract.sol[](#id6 "Lien permanent vers ce code")
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=aW1wb3J0ICIuL3V0aWwvLi91dGlsLnNvbCI7ICAgICAgICAgLy8gbm9tIGRlIGwndW5pdMOpIHNvdXJjZTogbGliL3NyYy8uLi91dGlsL3V0aWwuc29sCmltcG9ydCAiLi91dGlsLy91dGlsLnNvbCI7ICAgICAgICAgIC8vIG5vbSBkZSBsJ3VuaXTDqSBzb3VyY2U6IGxpYi9zcmMvLi4vdXRpbC91dGlsLnNvbAppbXBvcnQgIi4uL3V0aWwvLi4vYXJyYXkvdXRpbC5zb2wiOyAvLyBub20gZGUgbCd1bml0w6kgc291cmNlOiBsaWIvc3JjL2FycmF5L3V0aWwuc29sCmltcG9ydCAiLi4vLi4vLi8uLi91dGlsLnNvbCI7ICAgICAgIC8vIG5vbSBkZSBsJ3VuaXTDqSBzb3VyY2U6IHV0aWwuc29sCmltcG9ydCAiLi4vLi4vLi4vLi8uLi91dGlsLnNvbCI7ICAgIC8vIG5vbSBkZSBsJ3VuaXTDqSBzb3VyY2U6IHV0aWwuc29s)
import "./util/./util.sol"; // nom de l'unité source: lib/src/../util/util.sol
import "./util//util.sol"; // nom de l'unité source: lib/src/../util/util.sol
import "../util/../array/util.sol"; // nom de l'unité source: lib/src/array/util.sol
import "../.././../util.sol"; // nom de l'unité source: util.sol
import "../../.././../util.sol"; // nom de l'unité source: util.sol
Note
L’utilisation d’importations relatives contenant des segments `..` en tête n’est pas recommandée. Le même effet peut être obtenu de manière plus fiable en utilisant des importations directes avec base path et include path.
## Chemin de base et chemins d’inclusion[](#chemin-de-base-et-chemins-d-inclusion "Lien permanent vers cette rubrique")
Le chemin de base et les chemins d’inclusion représentent les répertoires à partir desquels le Host Filesystem Loader chargera les fichiers. Lorsqu’un nom d’unité source est transmis au chargeur, il y ajoute en préambule le chemin de base et effectue une recherche dans le système de fichiers. Si la recherche n’aboutit pas, la même chose est faite avec tous les répertoires de la liste des chemins d’inclusion.
Il est recommandé de définir le chemin de base au répertoire racine de votre projet et d’utiliser les chemins d’inclusion pour spécifier des emplacements supplémentaires qui peuvent contenir des bibliothèques dont dépend votre projet. Cela vous permet d’importer à partir de ces bibliothèques d’une manière uniforme, peu importe où elles sont situées dans le système de fichiers par rapport à votre projet. Par exemple, si vous utilisez npm pour installer des paquets et que votre contrat importe `@openzeppelin/contracts/utils/Strings.sol`, vous pouvez utiliser ces options pour indiquer au compilateur que que la bibliothèque peut être trouvée dans l’un des répertoires de paquets npm :
solc contract.sol \\
 --base-path . \\
 --include-path node\_modules/ \\
 --include-path /usr/local/lib/node\_modules/
Votre contrat sera compilé (avec les mêmes métadonnées exactes), peu importe que vous installiez la bibliothèque dans le répertoire du paquetage local ou global ou même directement sous la racine de votre projet.
Par défaut, le chemin de base est vide, ce qui laisse le nom de l’unité source inchangé. Lorsque le nom de l’unité source est un chemin relatif, cela a pour conséquence que le fichier est recherché dans le répertoire à partir duquel le compilateur a été invoqué. C’est aussi la seule valeur qui permet d’interpréter les chemins absolus dans les noms d’unités sources interprétés comme des chemins absolus sur le disque. Si le chemin de base est lui-même relatif, il est interprété comme relatif au répertoire de travail actuel du compilateur. du compilateur.
Note
Les chemins d’inclusion ne peuvent pas avoir de valeurs vides et doivent être utilisés avec un chemin de base non vide.
Note
Les chemins d’inclusion et de base peuvent se chevaucher tant que cela ne rend pas la résolution des importations ambiguë. Par exemple, vous pouvez spécifier un répertoire à l’intérieur du chemin de base comme un répertoire d’inclusion ou avoir un répertoire d’inclusion qui est un sous-répertoire d’un autre répertoire include. Le compilateur n’émettra une erreur que si le nom de l’unité source transmis au Host Filesystem Loader représente un chemin existant lorsqu’il est combiné avec plusieurs chemins d’inclusion ou un chemin d’inclusion et un chemin de base.
### Normalisation et suppression des chemins CLI[](#normalisation-et-suppression-des-chemins-cli "Lien permanent vers cette rubrique")
Sur la ligne de commande, le compilateur se comporte comme vous le feriez avec n’importe quel autre programme : Il accepte les chemins dans un format natif de la plate-forme et les chemins relatifs sont relatifs au répertoire de travail actuel. Les noms d’unités sources attribués aux fichiers dont les chemins sont spécifiés sur la ligne de commande, cependant, ne doivent pas changer simplement parce que le projet est compilé sur une plate-forme différente ou parce que le compilateur a été invoqué à partir d’un répertoire différent. Pour cela, les chemins des fichiers sources provenant de la ligne de commande doivent être convertis en une forme canonique et, si possible, rendus relatifs au chemin de base ou à l’un des chemins d’inclusion.
Les règles de normalisation sont les suivantes :
* Si un chemin est relatif, il est rendu absolu en y ajoutant le répertoire de travail actuel.
 
* Les segments internes `.` et [\`\`](#id1).\`”” sont réduits.
 
* Les séparateurs de chemin spécifiques à la plate-forme sont remplacés par des barres obliques.
 
* Les séquences de plusieurs séparateurs de chemin consécutifs sont écrasées en un seul séparateur (à moins qu’il s’agisse des barres obliques de tête d’un chemin [UNC](https://en.wikipedia.org/wiki/Path_\(computing\)#UNC)).
 
* Si le chemin comprend un nom de racine (par exemple une lettre de lecteur sous Windows) et que la racine est la même que la racine du répertoire de travail actuel, la racine est remplacée par `/`.
 
* Les liens symboliques dans le chemin ne sont **pas** résolus.
 
 * La seule exception est le chemin d’accès au répertoire de travail actuel ajouté aux chemins relatifs dans le but de les rendre absolus. Sur certaines plateformes, le répertoire de travail est toujours signalé avec les liens symboliques résolus, donc pour des raisons de cohérence, le compilateur les résout partout.
 
* La casse originale du chemin est préservée même si le système de fichiers est insensible à la casse mais [case-preserving](https://en.wikipedia.org/wiki/Case_preservation) et que la casse réelle sur le disque est différent.
 
Note
Il existe des situations où les chemins ne peuvent pas être rendus indépendants de la plate-forme. Par exemple, sous Windows, le compilateur peut éviter d’utiliser les lettres de lecteur en se référant au répertoire racine du lecteur actuel comme `/` mais les lettres de lecteur sont toujours nécessaires pour les chemins menant à d’autres lecteurs. Vous pouvez éviter de telles situations en vous assurant que tous les fichiers sont disponibles dans une seule arborescence de répertoire sur le même lecteur.
Après la normalisation, le compilateur essaie de rendre le chemin du fichier source relatif. Il essaie d’abord le chemin de base, puis les chemins d’inclusion dans l’ordre où ils ont été donnés. Si le chemin de base est vide ou non spécifié, il est traité comme s’il était égal au chemin du répertoire de travail actuel (avec tous les liens symboliques résolus). Le résultat est accepté seulement si le chemin du répertoire normalisé est le préfixe exact du chemin du fichier normalisé. Sinon, le chemin du fichier reste absolu. Cela rend la conversion non ambiguë et assure que le chemin relatif ne commence pas par `../`. Le chemin de fichier résultant devient le nom de l’unité source.
Note
Le chemin relatif produit par le dépouillement doit rester unique dans le chemin de base et les chemins d’inclusion. Par exemple, le compilateur émettra une erreur pour la commande suivante si à la fois `/projet/contract.sol` et `/lib/contract.sol` existent :
solc /project/contract.sol --base-path /project --include-path /lib
Note
Avant la version 0.8.8, la suppression des chemins d’accès de l’interface CLI n’était pas effectuée et la seule normalisation appliquée était la conversion des séparateurs de chemin. Lorsque vous travaillez avec des versions plus anciennes du compilateur, il est recommandé d’invoquer le compilateur à partir du chemin de base et de n’utiliser que des chemins relatifs sur la ligne de commande.
## Chemins autorisés[](#chemins-autorises "Lien permanent vers cette rubrique")
Par mesure de sécurité, le Host Filesystem Loader refusera de charger des fichiers en dehors de quelques emplacements qui sont considérés comme sûrs par défaut :
* En dehors du mode JSON standard :
 
 * Les répertoires contenant les fichiers d’entrée listés sur la ligne de commande.
 
 * Les répertoires utilisés comme cibles [remapping](#import-remapping). Si la cible n’est pas un répertoire (c’est-à-dire ne se termine pas par `/`, `/.` ou `/..`), le répertoire contenant la cible est utilisé à la place.
 
 * Chemin de base et chemins d’inclusion.
 
* En mode JSON standard :
 
 * Le chemin de base et les chemins d’inclusion.
 
Des répertoires supplémentaires peuvent être mis sur une liste blanche en utilisant l’option `--allow-paths`. L’option accepte une liste de chemins séparés par des virgules :
cd /home/user/project/
solc token/contract.sol \\
 lib/util.sol\=libs/util.sol \\
 --base-path\=token/ \\
 --include-path\=/lib/ \\
 --allow-paths\=../utils/,/tmp/libraries
Lorsque le compilateur est invoqué avec la commande indiquée ci-dessus, le Host Filesystem Loader permet d’importer des fichiers depuis les répertoires suivants :
* `/home/user/project/token/` (parce que `token/` contient le fichier d’entrée et aussi parce qu’il s’agit du chemin de base),
 
* `/lib/` (parce que `/lib/` est un des chemins d’inclusion),
 
* /home/user/project/libs/\` (parce que libs/\` est un répertoire contenant une cible de remappage),
 
* `/home/user/utils/` (à cause de ../utils/\` passé à –allow-paths\`),
 
* `/tmp/libraries/` (à cause de `/tmp/libraries` passé dans –allow-paths\`),
 
Note
Le répertoire de travail du compilateur est l’un des chemins autorisés par défaut uniquement s’il se trouve être le chemin de base (ou le chemin de base n’est pas spécifié ou a une valeur vide).
Note
Le compilateur ne vérifie pas si les chemins autorisés existent réellement et s’ils sont des répertoires. Les chemins inexistants ou vides sont simplement ignorés. Si un chemin autorisé correspond à un fichier plutôt qu’à un répertoire, le fichier est également considéré comme étant sur la liste blanche.
Note
Les chemins autorisés sont sensibles à la casse, même si le système de fichiers ne l’est pas. La casse doit correspondre exactement à celle utilisée dans vos importations. Par exemple, `--allow-paths tokens` ne correspondra pas à `import "Tokens/IERC20.sol"`.
Avertissement
Les fichiers et répertoires accessibles uniquement par des liens symboliques à partir de répertoires autorisés ne sont pas automatiquement sur la liste blanche. Par exemple, si `token/contract.sol` dans l’exemple ci-dessus était en fait un lien symbolique pointant sur `/etc/passwd`, le compilateur refuserait de le charger à moins que `/etc/` ne fasse aussi partie des chemins autorisés.
## Remappage des importations[](#remappage-des-importations "Lien permanent vers cette rubrique")
Le remappage des importations vous permet de rediriger les importations vers un emplacement différent dans le système de fichiers virtuel. Le mécanisme fonctionne en modifiant la traduction entre les chemins d’importation et les noms d’unités sources. Par exemple, vous pouvez configurer un remappage de sorte que toute importation à partir du répertoire virtuel `github.com/ethereum/dapp-bin/library/` soit considérée comme une importation depuis `dapp-bin/library/`.
Vous pouvez limiter la portée d’un remappage en spécifiant un _contexte_. Cela permet de créer des remappages qui ne s’appliquent qu’aux importations situées dans une bibliothèque spécifique ou un fichier spécifique. Sans contexte, un remappage est appliqué à chaque import correspondant dans tous les fichiers du système de fichiers virtuel.
Les remappages d’importation ont la forme de `context:prefix=target` :
* `context` doit correspondre au début du nom de l’unité source du fichier contenant l’importation.
 
* `prefix` doit correspondre au début du nom de l’unité source résultant de l’importation.
 
* `target` est la valeur avec laquelle le préfixe est remplacé.
 
Par exemple, si vous clonez [https://github.com/ethereum/dapp-bin/](https://github.com/ethereum/dapp-bin/) localement dans `/projet/dapp-bin` et que vous exécutez le compilateur avec :
solc github.com/ethereum/dapp-bin/\=dapp-bin/ --base-path /project source.sol
vous pouvez utiliser ce qui suit dans votre fichier source :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=aW1wb3J0ICJnaXRodWIuY29tL2V0aGVyZXVtL2RhcHAtYmluL2xpYnJhcnkvbWF0aC5zb2wiOyAvLyBzb3VyY2UgdW5pdCBuYW1lOiBkYXBwLWJpbi9saWJyYXJ5L21hdGguc29s)
import "github.com/ethereum/dapp-bin/library/math.sol"; // source unit name: dapp-bin/library/math.sol
Le compilateur cherchera le fichier dans le VFS sous `dapp-bin/library/math.sol`. Si le fichier n’est pas disponible à cet endroit, le nom de l’unité source sera transmis au Host Filesystem Loader, qui cherchera alors dans `/project/dapp-bin/library/iterable_mapping.sol`.
Avertissement
Les informations sur les remappages sont stockées dans les métadonnées du contrat. Comme le binaire produit par le compilateur contient un hachage des métadonnées, toute modification des réaffectations se traduira par un bytecode différent.
C’est pourquoi vous devez veiller à ne pas inclure d’informations locales dans les cibles de remappage. Par exemple, si votre bibliothèque est située dans le répertoire `/home/user/packages/mymath/math.sol`, un remappage comme `@math/=/home/user/packages/mymath/` aurait pour conséquence d’inclure votre répertoire personnel dans les métadonnées. Pour être en mesure de reproduire le même bytecode avec un tel remappage sur une autre machine, vous devrez recréer des parties de votre structure de répertoire locale dans le VFS et (si vous utilisez le Host Filesystem Loader) également dans le système de fichiers de l’hôte.
Pour éviter que votre structure de répertoire locale ne soit intégrée dans les métadonnées, il est recommandé de désigner les répertoires contenant les bibliothèques comme des _chemins d’inclusion_. Par exemple, dans l’exemple ci-dessus, `--include-path /home/user/packages/` vous permettrait d’utiliser les importations commençant par `mymath/`. Contrairement au remappage, l’option seule ne fera pas apparaître `mymath` comme `@math`, mais cela peut être réalisé en créant un lien symbolique ou en renommant le sous-répertoire du paquetage.
Pour un exemple plus complexe, supposons que vous dépendez d’un module qui utilise une ancienne version de dapp-bin que vous avez extraite vers `/project/dapp-bin_old`, alors vous pouvez exécuter :
solc module1:github.com/ethereum/dapp-bin/\=dapp-bin/ \\
 module2:github.com/ethereum/dapp-bin/\=dapp-bin\_old/ \\
 --base-path /project \\
 source.sol
Cela signifie que tous les imports de `module2` pointent vers l’ancienne version mais que les imports de `module1` pointent vers la nouvelle version.
Voici les règles détaillées qui régissent le comportement des remappages :
1. **Les remappages n’affectent que la traduction entre les chemins d’importation et les noms d’unités sources.**
 
 Les noms d’unités sources ajoutés au VFS de toute autre manière ne peuvent pas être remappés. Par exemple, les chemins que vous spécifiez sur la ligne de commande et ceux qui se trouvent dans `sources.urls` en JSON standard ne sont pas affectés.
 
 solc /project/\=/contracts/ /project/contract.sol ＃ source unit name: /project/contract.sol
 
 Dans l’exemple ci-dessus, le compilateur chargera le code source à partir de `/project/contract.sol` et le placera sous ce nom exact d’unité source dans le VFS, et non sous `/contract/contract.sol`.
 
2. **Le contexte et le préfixe doivent correspondre aux noms des unités sources, et non aux chemins d’importation.**
 
 * Cela signifie que vous ne pouvez pas remapper `./` ou `./` directement puisqu’ils sont remplacés pendant la traduction en nom d’unité source, mais vous pouvez remapper la partie du nom par laquelle ils sont remplacés avec :
 
 solc ./\=a/ /project/\=b/ /project/contract.sol ＃ source unit name: /project/contract.sol
 
 /project/contract.sol[](#id7 "Lien permanent vers ce code")
 
 [open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=aW1wb3J0ICIuL3V0aWwuc29sIiBhcyB1dGlsOyAvLyBzb3VyY2UgdW5pdCBuYW1lOiBiL3V0aWwuc29s)
 
 import "./util.sol" as util; // source unit name: b/util.sol
 
 * Vous ne pouvez pas remapper le chemin de base ou toute autre partie du chemin qui est seulement ajouté en interne par un rappel d’importation :
 
 solc /project/\=/contracts/ /project/contract.sol --base-path /project ＃ source unit name: contract.sol
 
 /project/contract.sol[](#id8 "Lien permanent vers ce code")
 
 [open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=aW1wb3J0ICJ1dGlsLnNvbCIgYXMgdXRpbDsgLy8gc291cmNlIHVuaXQgbmFtZTogdXRpbC5zb2w=)
 
 import "util.sol" as util; // source unit name: util.sol
 
3. **La cible est insérée directement dans le nom de l’unité source et ne doit pas nécessairement être un chemin d’accès valide.**
 
 * Il peut s’agir de n’importe quoi tant que le callback d’importation peut le gérer. Dans le cas du Host Filesystem Loader, cela inclut également les chemins relatifs. Lorsque vous utilisez l’interface JavaScript, vous pouvez même utiliser des URL et des identifiants abstraits si votre callback peut les gérer.
 
 * Le remappage se produit après que les importations relatives aient déjà été résolues en noms d’unités sources. Cela signifie que les cibles commençant par `./` et `./` n’ont pas de signification particulière et sont relatives au chemin de base plutôt qu’à l’emplacement du fichier source.
 
 * Les cibles de remappage ne sont pas normalisées, donc `@root/=./a/b//` remappera `@root/contract.sol` en `./a/b/`. vers `./a/b//contract.sol` et non `a/b/contract.sol`.
 
 * Si la cible ne se termine pas par un slash, le compilateur ne l’ajoutera pas automatiquement :
 
 solc /project/\=/contracts /project/contract.sol ＃ source unit name: /project/contract.sol
 
 /project/contract.sol[](#id9 "Lien permanent vers ce code")
 
 [open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=aW1wb3J0ICIvcHJvamVjdC91dGlsLnNvbCIgYXMgdXRpbDsgLy8gc291cmNlIHVuaXQgbmFtZTogL2NvbnRyYWN0c3V0aWwuc29s)
 
 import "/project/util.sol" as util; // source unit name: /contractsutil.sol
 
4. **Le contexte et le préfixe sont des modèles et les correspondances doivent être exactes.**
 
 * `a//b=c` ne correspondra pas à a/b\`.
 
 * Les noms des unités sources ne sont pas normalisés, donc `a/b=c` ne correspondra pas non plus à `a//b`.
 
 * Les parties des noms de fichiers et de répertoires peuvent également correspondre. `/newProject/con:/new=old` correspondra à `/newProject/contract.sol` et le remappera à `oldProject/contrat.sol`.
 
5. **Un remappage au maximum est appliqué à une seule importation.**
 
 * Si plusieurs réaffectations correspondent au même nom d’unité source, celle dont le préfixe est le plus long est choisi.
 
 * Si les préfixes sont identiques, celui qui est spécifié en dernier l’emporte.
 
 * Les réaffectations ne fonctionnent pas sur d’autres réaffectations. Par exemple, `a=b b=c c=d` n’aura pas pour résultat de transformer a\` en `d`.
 
6. **Le préfixe ne peut être vide, mais le contexte et la cible sont facultatifs.**
 
 * Si `target` est une chaîne vide, `prefix` est simplement supprimé des chemins d’importation.
 
 * Un `context` vide signifie que le remappage s’applique à toutes les importations dans toutes les unités sources.
 
## Utilisation des URLs dans les importations[](#utilisation-des-urls-dans-les-importations "Lien permanent vers cette rubrique")
La plupart des préfixes d’URL tels que `https://` ou `data://` n’ont pas de signification particulière dans les chemins d’importation. La seule exception est `file://` qui est supprimé des noms d’unités sources par le Host Filesystem Loader.
Lorsque vous compilez localement, vous pouvez utiliser le remappage d’importation pour remplacer la partie protocole et domaine par une partie chemin local :
solc :https://github.com/ethereum/dapp-bin\=/usr/local/dapp-bin contract.sol
Notez le premier `:`, qui est nécessaire lorsque le contexte de remappage est vide. Sinon, la partie `https:` serait interprétée par le compilateur comme le contexte.

# [Nettoyer les variables — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/internals/variable_cleanup.html) 
 _https://docs.soliditylang.org/fr/latest/internals/variable_cleanup.html_

[Solidity](https://docs.soliditylang.org/fr/latest/index.html)
Lorsqu’une valeur est inférieure à 256 bits, dans certains cas, les bits restants doivent être nettoyé. Le compilateur Solidity est conçu pour nettoyer ces bits restants avant toute opération qui pourraient être affectés par les déchets potentiels dans les bits restants. Par exemple, avant d’écrire une valeur en mémoire, les bits restants doivent être effacés car le contenu de la mémoire peut être utilisé pour le calcul hachages ou être envoyés en tant que données d’un appel de fonction. De même, avant de stocker une valeur dans le stockage, les bits restants doivent être nettoyés car sinon des valeurs brouillées peuvent être observées.
Notez que l’accès via assembly dans le code Solidity n’est pas considéré comme une telle opération : Si vous utilisez assembly dans votre code pour accéder aux variables Solidity plus court que 256 bits, le compilateur ne garantit pas que la valeur est correctement nettoyée.
De plus, nous ne nettoyons pas les bits si l’opération suivante n’est pas affectée par l’opération actuelle. Par exemple, puisque tout valeurs non nul est considérée comme `true` par l’instruction `JUMPI`, nous ne nettoyons pas les valeurs booléennes avant qu’elles ne soient utilisées comme condition pour `JUMPI`.
En plus du principe ci-dessus, le compilateur Solidity nettoie les données d’entrée lorsqu’elles sont chargées sur la stack.
Différents types ont des règles différentes pour nettoyer les valeurs non valides :
 
Type
Valeurs valides
Valeurs invalides
enum of n members
0 until n - 1
exception
bool
0 or 1
1
signed integers
sign-extended word
currently silently wraps; in the future exceptions will be thrown\*
unsigned integers
higher bits zeroed
currently silently wraps; in the future exceptions will be thrown\*
* enveloppe actuellement silencieusement ; à l’avenir, des exceptions seront levées

# [Language Influences — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/language-influences.html) 
 _https://docs.soliditylang.org/en/v0.8.30/language-influences.html_

Solidity is a [curly-bracket language](https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Curly_bracket_languages) that has been influenced and inspired by several well-known programming languages.
Solidity is most profoundly influenced by C++, but also borrowed concepts from languages like Python, JavaScript, and others.
The influence from C++ can be seen in the syntax for variable declarations, for loops, the concept of overloading functions, implicit and explicit type conversions and many other details.
In the early days of the language, Solidity used to be partly influenced by JavaScript. This was due to function-level scoping of variables and the use of the keyword `var`. The JavaScript influence was reduced starting from version 0.4.0. Now, the main remaining similarity to JavaScript is that functions are defined using the keyword `function`. Solidity also supports import syntax and semantics that are similar to those available in JavaScript. Besides those points, Solidity looks like most other curly-bracket languages and has no major JavaScript influence anymore.
Another influence to Solidity was Python. Solidity’s modifiers were added trying to model Python’s decorators with a much more restricted functionality. Furthermore, multiple inheritance, C3 linearization, and the `super` keyword are taken from Python as well as the general assignment and copy semantics of value and reference types.

# [SMTChecker and Formal Verification — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/smtchecker.html) 
 _https://docs.soliditylang.org/en/v0.8.30/smtchecker.html_

Using formal verification it is possible to perform an automated mathematical proof that your source code fulfills a certain formal specification. The specification is still formal (just as the source code), but usually much simpler.
Note that formal verification itself can only help you understand the difference between what you did (the specification) and how you did it (the actual implementation). You still need to check whether the specification is what you wanted and that you did not miss any unintended effects of it.
Solidity implements a formal verification approach based on [SMT (Satisfiability Modulo Theories)](https://en.wikipedia.org/wiki/Satisfiability_modulo_theories) and [Horn](https://en.wikipedia.org/wiki/Horn-satisfiability) solving. The SMTChecker module automatically tries to prove that the code satisfies the specification given by `require` and `assert` statements. That is, it considers `require` statements as assumptions and tries to prove that the conditions inside `assert` statements are always true. If an assertion failure is found, a counterexample may be given to the user showing how the assertion can be violated. If no warning is given by the SMTChecker for a property, it means that the property is safe.
The other verification targets that the SMTChecker checks at compile time are:
* Arithmetic underflow and overflow.
 
* Division by zero.
 
* Trivial conditions and unreachable code.
 
* Popping an empty array.
 
* Out of bounds index access.
 
* Insufficient funds for a transfer.
 
All the targets above are automatically checked by default if all engines are enabled, except underflow and overflow for Solidity >=0.8.7.
The potential warnings that the SMTChecker reports are:
* `<failing  property> happens here.`. This means that the SMTChecker proved that a certain property fails. A counterexample may be given, however in complex situations it may also not show a counterexample. This result may also be a false positive in certain cases, when the SMT encoding adds abstractions for Solidity code that is either hard or impossible to express.
 
* `<failing property> might happen here`. This means that the solver could not prove either case within the given timeout. Since the result is unknown, the SMTChecker reports the potential failure for soundness. This may be solved by increasing the query timeout, but the problem might also simply be too hard for the engine to solve.
 
To enable the SMTChecker, you must select [which engine should run](#smtchecker-engines), where the default is no engine. Selecting the engine enables the SMTChecker on all files.
Note
Prior to Solidity 0.8.4, the default way to enable the SMTChecker was via `pragma experimental SMTChecker;` and only the contracts containing the pragma would be analyzed. That pragma has been deprecated, and although it still enables the SMTChecker for backwards compatibility, it will be removed in Solidity 0.9.0. Note also that now using the pragma even in a single file enables the SMTChecker for all files.
Note
The lack of warnings for a verification target represents an undisputed mathematical proof of correctness, assuming no bugs in the SMTChecker and the underlying solver. Keep in mind that these problems are _very hard_ and sometimes _impossible_ to solve automatically in the general case. Therefore, several properties might not be solved or might lead to false positives for large contracts. Every proven property should be seen as an important achievement. For advanced users, see [SMTChecker Tuning](#smtchecker-options) to learn a few options that might help proving more complex properties.
## Tutorial[](#tutorial "Link to this heading")
### Overflow[](#overflow "Link to this heading")
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBPdmVyZmxvdyB7CiAgICB1aW50IGltbXV0YWJsZSB4OwogICAgdWludCBpbW11dGFibGUgeTsKCiAgICBmdW5jdGlvbiBhZGQodWludCB4XywgdWludCB5XykgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIHhfICsgeV87CiAgICB9CgogICAgY29uc3RydWN0b3IodWludCB4XywgdWludCB5XykgewogICAgICAgICh4LCB5KSA9ICh4XywgeV8pOwogICAgfQoKICAgIGZ1bmN0aW9uIHN0YXRlQWRkKCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBhZGQoeCwgeSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Overflow {
 uint immutable x;
 uint immutable y;
 function add(uint x\_, uint y\_) internal pure returns (uint) {
 return x\_ + y\_;
 }
 constructor(uint x\_, uint y\_) {
 (x, y) \= (x\_, y\_);
 }
 function stateAdd() public view returns (uint) {
 return add(x, y);
 }
}
The contract above shows an overflow check example. The SMTChecker does not check underflow and overflow by default for Solidity >=0.8.7, so we need to use the command-line option `--model-checker-targets "underflow,overflow"` or the JSON option `settings.modelChecker.targets = ["underflow", "overflow"]`. See [this section for targets configuration](#smtchecker-targets). Here, it reports the following:
Warning: CHC: Overflow (resulting value larger than 2\*\*256 - 1) happens here.
Counterexample:
x = 1, y = 115792089237316195423570985008687907853269984665640564039457584007913129639935
 = 0
Transaction trace:
Overflow.constructor(1, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
State: x = 1, y = 115792089237316195423570985008687907853269984665640564039457584007913129639935
Overflow.stateAdd()
 Overflow.add(1, 115792089237316195423570985008687907853269984665640564039457584007913129639935) -- internal call
 --> o.sol:9:20:
 |
9 | return x\_ + y\_;
 | ^^^^^^^
If we add `require` statements that filter out overflow cases, the SMTChecker proves that no overflow is reachable (by not reporting warnings):
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBPdmVyZmxvdyB7CiAgICB1aW50IGltbXV0YWJsZSB4OwogICAgdWludCBpbW11dGFibGUgeTsKCiAgICBmdW5jdGlvbiBhZGQodWludCB4XywgdWludCB5XykgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIHhfICsgeV87CiAgICB9CgogICAgY29uc3RydWN0b3IodWludCB4XywgdWludCB5XykgewogICAgICAgICh4LCB5KSA9ICh4XywgeV8pOwogICAgfQoKICAgIGZ1bmN0aW9uIHN0YXRlQWRkKCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJlcXVpcmUoeCA8IHR5cGUodWludDEyOCkubWF4KTsKICAgICAgICByZXF1aXJlKHkgPCB0eXBlKHVpbnQxMjgpLm1heCk7CiAgICAgICAgcmV0dXJuIGFkZCh4LCB5KTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Overflow {
 uint immutable x;
 uint immutable y;
 function add(uint x\_, uint y\_) internal pure returns (uint) {
 return x\_ + y\_;
 }
 constructor(uint x\_, uint y\_) {
 (x, y) \= (x\_, y\_);
 }
 function stateAdd() public view returns (uint) {
 require(x < type(uint128).max);
 require(y < type(uint128).max);
 return add(x, y);
 }
}
### Assert[](#assert "Link to this heading")
An assertion represents an invariant in your code: a property that must be true _for all transactions, including all input and storage values_, otherwise there is a bug.
The code below defines a function `f` that guarantees no overflow. Function `inv` defines the specification that `f` is monotonically increasing: for every possible pair `(a, b)`, if `b > a` then `f(b) > f(a)`. Since `f` is indeed monotonically increasing, the SMTChecker proves that our property is correct. You are encouraged to play with the property and the function definition to see what results come out!
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBNb25vdG9uaWMgewogICAgZnVuY3Rpb24gZih1aW50IHgpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJlcXVpcmUoeCA8IHR5cGUodWludDEyOCkubWF4KTsKICAgICAgICByZXR1cm4geCAqIDQyOwogICAgfQoKICAgIGZ1bmN0aW9uIGludih1aW50IGEsIHVpbnQgYikgcHVibGljIHB1cmUgewogICAgICAgIHJlcXVpcmUoYiA+IGEpOwogICAgICAgIGFzc2VydChmKGIpID4gZihhKSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Monotonic {
 function f(uint x) internal pure returns (uint) {
 require(x < type(uint128).max);
 return x \* 42;
 }
 function inv(uint a, uint b) public pure {
 require(b \> a);
 assert(f(b) \> f(a));
 }
}
We can also add assertions inside loops to verify more complicated properties. The following code searches for the maximum element of an unrestricted array of numbers, and asserts the property that the found element must be greater or equal every element in the array.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBNYXggewogICAgZnVuY3Rpb24gbWF4KHVpbnRbXSBtZW1vcnkgYSkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHVpbnQgbSA9IDA7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkKICAgICAgICAgICAgaWYgKGFbaV0gPiBtKQogICAgICAgICAgICAgICAgbSA9IGFbaV07CgogICAgICAgIGZvciAodWludCBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpCiAgICAgICAgICAgIGFzc2VydChtID49IGFbaV0pOwoKICAgICAgICByZXR1cm4gbTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Max {
 function max(uint\[\] memory a) public pure returns (uint) {
 uint m \= 0;
 for (uint i \= 0; i < a.length; ++i)
 if (a\[i\] \> m)
 m \= a\[i\];
 for (uint i \= 0; i < a.length; ++i)
 assert(m \>= a\[i\]);
 return m;
 }
}
Note that in this example the SMTChecker will automatically try to prove three properties:
1. `++i` in the first loop does not overflow.
 
2. `++i` in the second loop does not overflow.
 
3. The assertion is always true.
 
Note
The properties involve loops, which makes it _much much_ harder than the previous examples, so beware of loops!
All the properties are correctly proven safe. Feel free to change the properties and/or add restrictions on the array to see different results. For example, changing the code to
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBNYXggewogICAgZnVuY3Rpb24gbWF4KHVpbnRbXSBtZW1vcnkgYSkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJlcXVpcmUoYS5sZW5ndGggPj0gNSk7CiAgICAgICAgdWludCBtID0gMDsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKQogICAgICAgICAgICBpZiAoYVtpXSA+IG0pCiAgICAgICAgICAgICAgICBtID0gYVtpXTsKCiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkKICAgICAgICAgICAgYXNzZXJ0KG0gPiBhW2ldKTsKCiAgICAgICAgcmV0dXJuIG07CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Max {
 function max(uint\[\] memory a) public pure returns (uint) {
 require(a.length \>= 5);
 uint m \= 0;
 for (uint i \= 0; i < a.length; ++i)
 if (a\[i\] \> m)
 m \= a\[i\];
 for (uint i \= 0; i < a.length; ++i)
 assert(m \> a\[i\]);
 return m;
 }
}
gives us:
Warning: CHC: Assertion violation happens here.
Counterexample:
a = \[0, 0, 0, 0, 0\]
 = 0
Transaction trace:
Test.constructor()
Test.max(\[0, 0, 0, 0, 0\])
 --> max.sol:14:4:
 |
14 | assert(m > a\[i\]);
### State Properties[](#state-properties "Link to this heading")
So far the examples only demonstrated the use of the SMTChecker over pure code, proving properties about specific operations or algorithms. A common type of properties in smart contracts are properties that involve the state of the contract. Multiple transactions might be needed to make an assertion fail for such a property.
As an example, consider a 2D grid where both axis have coordinates in the range (-2^128, 2^128 - 1). Let us place a robot at position (0, 0). The robot can only move diagonally, one step at a time, and cannot move outside the grid. The robot’s state machine can be represented by the smart contract below.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBSb2JvdCB7CiAgICBpbnQgeCA9IDA7CiAgICBpbnQgeSA9IDA7CgogICAgbW9kaWZpZXIgd2FsbCB7CiAgICAgICAgcmVxdWlyZSh4ID4gdHlwZShpbnQxMjgpLm1pbiAmJiB4IDwgdHlwZShpbnQxMjgpLm1heCk7CiAgICAgICAgcmVxdWlyZSh5ID4gdHlwZShpbnQxMjgpLm1pbiAmJiB5IDwgdHlwZShpbnQxMjgpLm1heCk7CiAgICAgICAgXzsKICAgIH0KCiAgICBmdW5jdGlvbiBtb3ZlTGVmdFVwKCkgd2FsbCBwdWJsaWMgewogICAgICAgIC0teDsKICAgICAgICArK3k7CiAgICB9CgogICAgZnVuY3Rpb24gbW92ZUxlZnREb3duKCkgd2FsbCBwdWJsaWMgewogICAgICAgIC0teDsKICAgICAgICAtLXk7CiAgICB9CgogICAgZnVuY3Rpb24gbW92ZVJpZ2h0VXAoKSB3YWxsIHB1YmxpYyB7CiAgICAgICAgKyt4OwogICAgICAgICsreTsKICAgIH0KCiAgICBmdW5jdGlvbiBtb3ZlUmlnaHREb3duKCkgd2FsbCBwdWJsaWMgewogICAgICAgICsreDsKICAgICAgICAtLXk7CiAgICB9CgogICAgZnVuY3Rpb24gaW52KCkgcHVibGljIHZpZXcgewogICAgICAgIGFzc2VydCgoeCArIHkpICUgMiA9PSAwKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Robot {
 int x \= 0;
 int y \= 0;
 modifier wall {
 require(x \> type(int128).min && x < type(int128).max);
 require(y \> type(int128).min && y < type(int128).max);
 \_;
 }
 function moveLeftUp() wall public {
 \--x;
 ++y;
 }
 function moveLeftDown() wall public {
 \--x;
 \--y;
 }
 function moveRightUp() wall public {
 ++x;
 ++y;
 }
 function moveRightDown() wall public {
 ++x;
 \--y;
 }
 function inv() public view {
 assert((x + y) % 2 \== 0);
 }
}
Function `inv` represents an invariant of the state machine that `x + y` must be even. The SMTChecker manages to prove that regardless how many commands we give the robot, even if infinitely many, the invariant can _never_ fail. The interested reader may want to prove that fact manually as well. Hint: this invariant is inductive.
We can also trick the SMTChecker into giving us a path to a certain position we think might be reachable. We can add the property that (2, 4) is _not_ reachable, by adding the following function.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=ZnVuY3Rpb24gcmVhY2hfMl80KCkgcHVibGljIHZpZXcgewogICAgYXNzZXJ0KCEoeCA9PSAyICYmIHkgPT0gNCkpOwp9)
function reach\_2\_4() public view {
 assert(!(x \== 2 && y \== 4));
}
This property is false, and while proving that the property is false, the SMTChecker tells us exactly _how_ to reach (2, 4):
Warning: CHC: Assertion violation happens here.
Counterexample:
x = 2, y = 4
Transaction trace:
Robot.constructor()
State: x = 0, y = 0
Robot.moveLeftUp()
State: x = (- 1), y = 1
Robot.moveRightUp()
State: x = 0, y = 2
Robot.moveRightUp()
State: x = 1, y = 3
Robot.moveRightUp()
State: x = 2, y = 4
Robot.reach\_2\_4()
 --> r.sol:35:4:
 |
35 | assert(!(x == 2 && y == 4));
 | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
Note that the path above is not necessarily deterministic, as there are other paths that could reach (2, 4). The choice of which path is shown might change depending on the used solver, its version, or just randomly.
### External Calls and Reentrancy[](#external-calls-and-reentrancy "Link to this heading")
Every external call is treated as a call to unknown code by the SMTChecker. The reasoning behind that is that even if the code of the called contract is available at compile time, there is no guarantee that the deployed contract will indeed be the same as the contract where the interface came from at compile time.
In some cases, it is possible to automatically infer properties over state variables that are still true even if the externally called code can do anything, including reenter the caller contract.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7CgppbnRlcmZhY2UgVW5rbm93biB7CiAgICBmdW5jdGlvbiBydW4oKSBleHRlcm5hbDsKfQoKY29udHJhY3QgTXV0ZXggewogICAgdWludCB4OwogICAgYm9vbCBsb2NrOwoKICAgIFVua25vd24gaW1tdXRhYmxlIHVua25vd247CgogICAgY29uc3RydWN0b3IoVW5rbm93biB1KSB7CiAgICAgICAgcmVxdWlyZShhZGRyZXNzKHUpICE9IGFkZHJlc3MoMCkpOwogICAgICAgIHVua25vd24gPSB1OwogICAgfQoKICAgIG1vZGlmaWVyIG11dGV4IHsKICAgICAgICByZXF1aXJlKCFsb2NrKTsKICAgICAgICBsb2NrID0gdHJ1ZTsKICAgICAgICBfOwogICAgICAgIGxvY2sgPSBmYWxzZTsKICAgIH0KCiAgICBmdW5jdGlvbiBzZXQodWludCB4XykgbXV0ZXggcHVibGljIHsKICAgICAgICB4ID0geF87CiAgICB9CgogICAgZnVuY3Rpb24gcnVuKCkgbXV0ZXggcHVibGljIHsKICAgICAgICB1aW50IHhQcmUgPSB4OwogICAgICAgIHVua25vd24ucnVuKCk7CiAgICAgICAgYXNzZXJ0KHhQcmUgPT0geCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
interface Unknown {
 function run() external;
}
contract Mutex {
 uint x;
 bool lock;
 Unknown immutable unknown;
 constructor(Unknown u) {
 require(address(u) != address(0));
 unknown \= u;
 }
 modifier mutex {
 require(!lock);
 lock \= true;
 \_;
 lock \= false;
 }
 function set(uint x\_) mutex public {
 x \= x\_;
 }
 function run() mutex public {
 uint xPre \= x;
 unknown.run();
 assert(xPre \== x);
 }
}
The example above shows a contract that uses a mutex flag to forbid reentrancy. The solver is able to infer that when `unknown.run()` is called, the contract is already “locked”, so it would not be possible to change the value of `x`, regardless of what the unknown called code does.
If we “forget” to use the `mutex` modifier on function `set`, the SMTChecker is able to synthesize the behavior of the externally called code so that the assertion fails:
Warning: CHC: Assertion violation happens here.
Counterexample:
x = 1, lock = true, unknown = 1
Transaction trace:
Mutex.constructor(1)
State: x = 0, lock = false, unknown = 1
Mutex.run()
 unknown.run() -- untrusted external call, synthesized as:
 Mutex.set(1) -- reentrant call
 --> m.sol:32:3:
 |
32 | assert(xPre == x);
 | ^^^^^^^^^^^^^^^^^
## SMTChecker Options and Tuning[](#smtchecker-options-and-tuning "Link to this heading")
### Timeout[](#timeout "Link to this heading")
The SMTChecker uses a hardcoded resource limit (`rlimit`) chosen per solver, which is not precisely related to time. We chose the `rlimit` option as the default because it gives more determinism guarantees than time inside the solver.
This options translates roughly to “a few seconds timeout” per query. Of course many properties are very complex and need a lot of time to be solved, where determinism does not matter. If the SMTChecker does not manage to solve the contract properties with the default `rlimit`, a timeout can be given in milliseconds via the CLI option `--model-checker-timeout <time>` or the JSON option `settings.modelChecker.timeout=<time>`, where 0 means no timeout.
### Verification Targets[](#verification-targets "Link to this heading")
The types of verification targets created by the SMTChecker can also be customized via the CLI option `--model-checker-target <targets>` or the JSON option `settings.modelChecker.targets=<targets>`. In the CLI case, `<targets>` is a no-space-comma-separated list of one or more verification targets, and an array of one or more targets as strings in the JSON input. The keywords that represent the targets are:
* Assertions: `assert`.
 
* Arithmetic underflow: `underflow`.
 
* Arithmetic overflow: `overflow`.
 
* Division by zero: `divByZero`.
 
* Trivial conditions and unreachable code: `constantCondition`.
 
* Popping an empty array: `popEmptyArray`.
 
* Out of bounds array/fixed bytes index access: `outOfBounds`.
 
* Insufficient funds for a transfer: `balance`.
 
* All of the above: `default` (CLI only).
 
A common subset of targets might be, for example: `--model-checker-targets assert,overflow`.
All targets are checked by default, except underflow and overflow for Solidity >=0.8.7.
There is no precise heuristic on how and when to split verification targets, but it can be useful especially when dealing with large contracts.
### Proved Targets[](#proved-targets "Link to this heading")
If there are any proved targets, the SMTChecker issues one warning per engine stating how many targets were proved. If the user wishes to see all the specific proved targets, the CLI option `--model-checker-show-proved-safe` and the JSON option `settings.modelChecker.showProvedSafe = true` can be used.
### Unproved Targets[](#unproved-targets "Link to this heading")
If there are any unproved targets, the SMTChecker issues one warning stating how many unproved targets there are. If the user wishes to see all the specific unproved targets, the CLI option `--model-checker-show-unproved` and the JSON option `settings.modelChecker.showUnproved = true` can be used.
### Unsupported Language Features[](#unsupported-language-features "Link to this heading")
Certain Solidity language features are not completely supported by the SMT encoding that the SMTChecker applies, for example assembly blocks. The unsupported construct is abstracted via overapproximation to preserve soundness, meaning any properties reported safe are safe even though this feature is unsupported. However such abstraction may cause false positives when the target properties depend on the precise behavior of the unsupported feature. If the encoder encounters such cases it will by default report a generic warning stating how many unsupported features it has seen. If the user wishes to see all the specific unsupported features, the CLI option `--model-checker-show-unsupported` and the JSON option `settings.modelChecker.showUnsupported = true` can be used, where their default value is `false`.
### Verified Contracts[](#verified-contracts "Link to this heading")
By default all the deployable contracts in the given sources are analyzed separately as the one that will be deployed. This means that if a contract has many direct and indirect inheritance parents, all of them will be analyzed on their own, even though only the most derived will be accessed directly on the blockchain. This causes an unnecessary burden on the SMTChecker and the solver. To aid cases like this, users can specify which contracts should be analyzed as the deployed one. The parent contracts are of course still analyzed, but only in the context of the most derived contract, reducing the complexity of the encoding and generated queries. Note that abstract contracts are by default not analyzed as the most derived by the SMTChecker.
The chosen contracts can be given via a comma-separated list (whitespace is not allowed) of <source>:<contract> pairs in the CLI: `--model-checker-contracts "<source1.sol:contract1>,<source2.sol:contract2>,<source2.sol:contract3>"`, and via the object `settings.modelChecker.contracts` in the [JSON input](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#compiler-api), which has the following form:
"contracts": {
 "source1.sol": \["contract1"\],
 "source2.sol": \["contract2", "contract3"\]
}
### Trusted External Calls[](#trusted-external-calls "Link to this heading")
By default, the SMTChecker does not assume that compile-time available code is the same as the runtime code for external calls. Take the following contracts as an example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBFeHQgewogICAgdWludCBwdWJsaWMgeDsKICAgIGZ1bmN0aW9uIHNldFgodWludCBfeCkgcHVibGljIHsgeCA9IF94OyB9Cn0KY29udHJhY3QgTXlDb250cmFjdCB7CiAgICBmdW5jdGlvbiBjYWxsRXh0KEV4dCBfZSkgcHVibGljIHsKICAgICAgICBfZS5zZXRYKDQyKTsKICAgICAgICBhc3NlcnQoX2UueCgpID09IDQyKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Ext {
 uint public x;
 function setX(uint \_x) public { x \= \_x; }
}
contract MyContract {
 function callExt(Ext \_e) public {
 \_e.setX(42);
 assert(\_e.x() \== 42);
 }
}
When `MyContract.callExt` is called, an address is given as the argument. At deployment time, we cannot know for sure that address `_e` actually contains a deployment of contract `Ext`. Therefore, the SMTChecker will warn that the assertion above can be violated, which is true, if `_e` contains another contract than `Ext`.
However, it can be useful to treat these external calls as trusted, for example, to test that different implementations of an interface conform to the same property. This means assuming that address `_e` indeed was deployed as contract `Ext`. This mode can be enabled via the CLI option `--model-checker-ext-calls=trusted` or the JSON field `settings.modelChecker.extCalls: "trusted"`.
Please be aware that enabling this mode can make the SMTChecker analysis much more computationally costly.
An important part of this mode is that it is applied to contract types and high level external calls to contracts, and not low level calls such as `call` and `delegatecall`. The storage of an address is stored per contract type, and the SMTChecker assumes that an externally called contract has the type of the caller expression. Therefore, casting an `address` or a contract to different contract types will yield different storage values and can give unsound results if the assumptions are inconsistent, such as the example below:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBEIHsKICAgIGNvbnN0cnVjdG9yKHVpbnQgX3gpIHsgeCA9IF94OyB9CiAgICB1aW50IHB1YmxpYyB4OwogICAgZnVuY3Rpb24gc2V0WCh1aW50IF94KSBwdWJsaWMgeyB4ID0gX3g7IH0KfQoKY29udHJhY3QgRSB7CiAgICBjb25zdHJ1Y3RvcigpIHsgeCA9IDI7IH0KICAgIHVpbnQgcHVibGljIHg7CiAgICBmdW5jdGlvbiBzZXRYKHVpbnQgX3gpIHB1YmxpYyB7IHggPSBfeDsgfQp9Cgpjb250cmFjdCBDIHsKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIGFkZHJlc3MgZCA9IGFkZHJlc3MobmV3IEQoNDIpKTsKCiAgICAgICAgLy8gYGRgIHdhcyBkZXBsb3llZCBhcyBgRGAsIHNvIGl0cyBgeGAgc2hvdWxkIGJlIDQyIG5vdy4KICAgICAgICBhc3NlcnQoRChkKS54KCkgPT0gNDIpOyAvLyBzaG91bGQgaG9sZAogICAgICAgIGFzc2VydChEKGQpLngoKSA9PSA0Myk7IC8vIHNob3VsZCBmYWlsCgogICAgICAgIC8vIEUgYW5kIEQgaGF2ZSB0aGUgc2FtZSBpbnRlcmZhY2UsIHNvIHRoZSBmb2xsb3dpbmcKICAgICAgICAvLyBjYWxsIHdvdWxkIGFsc28gd29yayBhdCBydW50aW1lLgogICAgICAgIC8vIEhvd2V2ZXIsIHRoZSBjaGFuZ2UgdG8gYEUoZClgIGlzIG5vdCByZWZsZWN0ZWQgaW4gYEQoZClgLgogICAgICAgIEUoZCkuc2V0WCgxMDI0KTsKCiAgICAgICAgLy8gUmVhZGluZyBmcm9tIGBEKGQpYCBub3cgd2lsbCBzaG93IG9sZCB2YWx1ZXMuCiAgICAgICAgLy8gVGhlIGFzc2VydGlvbiBiZWxvdyBzaG91bGQgZmFpbCBhdCBydW50aW1lLAogICAgICAgIC8vIGJ1dCBzdWNjZWVkcyBpbiB0aGlzIG1vZGUncyBhbmFseXNpcyAodW5zb3VuZCkuCiAgICAgICAgYXNzZXJ0KEQoZCkueCgpID09IDQyKTsKICAgICAgICAvLyBUaGUgYXNzZXJ0aW9uIGJlbG93IHNob3VsZCBzdWNjZWVkIGF0IHJ1bnRpbWUsCiAgICAgICAgLy8gYnV0IGZhaWxzIGluIHRoaXMgbW9kZSdzIGFuYWx5c2lzIChmYWxzZSBwb3NpdGl2ZSkuCiAgICAgICAgYXNzZXJ0KEQoZCkueCgpID09IDEwMjQpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract D {
 constructor(uint \_x) { x \= \_x; }
 uint public x;
 function setX(uint \_x) public { x \= \_x; }
}
contract E {
 constructor() { x \= 2; }
 uint public x;
 function setX(uint \_x) public { x \= \_x; }
}
contract C {
 function f() public {
 address d \= address(new D(42));
 // \`d\` was deployed as \`D\`, so its \`x\` should be 42 now.
 assert(D(d).x() \== 42); // should hold
 assert(D(d).x() \== 43); // should fail
 // E and D have the same interface, so the following
 // call would also work at runtime.
 // However, the change to \`E(d)\` is not reflected in \`D(d)\`.
 E(d).setX(1024);
 // Reading from \`D(d)\` now will show old values.
 // The assertion below should fail at runtime,
 // but succeeds in this mode's analysis (unsound).
 assert(D(d).x() \== 42);
 // The assertion below should succeed at runtime,
 // but fails in this mode's analysis (false positive).
 assert(D(d).x() \== 1024);
 }
}
Due to the above, make sure that the trusted external calls to a certain variable of `address` or `contract` type always have the same caller expression type.
It is also helpful to cast the called contract’s variable as the type of the most derived type in case of inheritance.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7CgppbnRlcmZhY2UgVG9rZW4gewogICAgZnVuY3Rpb24gYmFsYW5jZU9mKGFkZHJlc3MgX2EpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAodWludCk7CiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIF90bywgdWludCBfYW10KSBleHRlcm5hbDsKfQoKY29udHJhY3QgVG9rZW5Db3JyZWN0IGlzIFRva2VuIHsKICAgIG1hcHBpbmcgKGFkZHJlc3MgPT4gdWludCkgYmFsYW5jZTsKICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MgX2EsIHVpbnQgX2IpIHsKICAgICAgICBiYWxhbmNlW19hXSA9IF9iOwogICAgfQogICAgZnVuY3Rpb24gYmFsYW5jZU9mKGFkZHJlc3MgX2EpIHB1YmxpYyB2aWV3IG92ZXJyaWRlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4gYmFsYW5jZVtfYV07CiAgICB9CiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIF90bywgdWludCBfYW10KSBwdWJsaWMgb3ZlcnJpZGUgewogICAgICAgIHJlcXVpcmUoYmFsYW5jZVttc2cuc2VuZGVyXSA+PSBfYW10KTsKICAgICAgICBiYWxhbmNlW21zZy5zZW5kZXJdIC09IF9hbXQ7CiAgICAgICAgYmFsYW5jZVtfdG9dICs9IF9hbXQ7CiAgICB9Cn0KCmNvbnRyYWN0IFRlc3QgewogICAgZnVuY3Rpb24gcHJvcGVydHlfdHJhbnNmZXIoYWRkcmVzcyBfdG9rZW4sIGFkZHJlc3MgX3RvLCB1aW50IF9hbXQpIHB1YmxpYyB7CiAgICAgICAgcmVxdWlyZShfdG8gIT0gYWRkcmVzcyh0aGlzKSk7CgogICAgICAgIFRva2VuQ29ycmVjdCB0ID0gVG9rZW5Db3JyZWN0KF90b2tlbik7CgogICAgICAgIHVpbnQgeFByZSA9IHQuYmFsYW5jZU9mKGFkZHJlc3ModGhpcykpOwogICAgICAgIHJlcXVpcmUoeFByZSA+PSBfYW10KTsKICAgICAgICB1aW50IHlQcmUgPSB0LmJhbGFuY2VPZihfdG8pOwoKICAgICAgICB0LnRyYW5zZmVyKF90bywgX2FtdCk7CiAgICAgICAgdWludCB4UG9zdCA9IHQuYmFsYW5jZU9mKGFkZHJlc3ModGhpcykpOwogICAgICAgIHVpbnQgeVBvc3QgPSB0LmJhbGFuY2VPZihfdG8pOwoKICAgICAgICBhc3NlcnQoeFBvc3QgPT0geFByZSAtIF9hbXQpOwogICAgICAgIGFzc2VydCh5UG9zdCA9PSB5UHJlICsgX2FtdCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
interface Token {
 function balanceOf(address \_a) external view returns (uint);
 function transfer(address \_to, uint \_amt) external;
}
contract TokenCorrect is Token {
 mapping (address \=> uint) balance;
 constructor(address \_a, uint \_b) {
 balance\[\_a\] \= \_b;
 }
 function balanceOf(address \_a) public view override returns (uint) {
 return balance\[\_a\];
 }
 function transfer(address \_to, uint \_amt) public override {
 require(balance\[msg.sender\] \>= \_amt);
 balance\[msg.sender\] \-= \_amt;
 balance\[\_to\] += \_amt;
 }
}
contract Test {
 function property\_transfer(address \_token, address \_to, uint \_amt) public {
 require(\_to != address(this));
 TokenCorrect t \= TokenCorrect(\_token);
 uint xPre \= t.balanceOf(address(this));
 require(xPre \>= \_amt);
 uint yPre \= t.balanceOf(\_to);
 t.transfer(\_to, \_amt);
 uint xPost \= t.balanceOf(address(this));
 uint yPost \= t.balanceOf(\_to);
 assert(xPost \== xPre \- \_amt);
 assert(yPost \== yPre + \_amt);
 }
}
Note that in function `property_transfer`, the external calls are performed on variable `t`.
Another caveat of this mode are calls to state variables of contract type outside the analyzed contract. In the code below, even though `B` deploys `A`, it is also possible for the address stored in `B.a` to be called by anyone outside of `B` in between transactions to `B` itself. To reflect the possible changes to `B.a`, the encoding allows an unbounded number of calls to be made to `B.a` externally. The encoding will keep track of `B.a`’s storage, therefore assertion (2) should hold. However, currently the encoding allows such calls to be made from `B` conceptually, therefore assertion (3) fails. Making the encoding stronger logically is an extension of the trusted mode and is under development. Note that the encoding does not keep track of storage for `address` variables, therefore if `B.a` had type `address` the encoding would assume that its storage does not change in between transactions to `B`.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBBIHsKICAgIHVpbnQgcHVibGljIHg7CiAgICBhZGRyZXNzIGltbXV0YWJsZSBwdWJsaWMgb3duZXI7CiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgICBvd25lciA9IG1zZy5zZW5kZXI7CiAgICB9CiAgICBmdW5jdGlvbiBzZXRYKHVpbnQgX3gpIHB1YmxpYyB7CiAgICAgICAgcmVxdWlyZShtc2cuc2VuZGVyID09IG93bmVyKTsKICAgICAgICB4ID0gX3g7CiAgICB9Cn0KCmNvbnRyYWN0IEIgewogICAgQSBhOwogICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgYSA9IG5ldyBBKCk7CiAgICAgICAgYXNzZXJ0KGEueCgpID09IDApOyAvLyAoMSkgc2hvdWxkIGhvbGQKICAgIH0KICAgIGZ1bmN0aW9uIGcoKSBwdWJsaWMgdmlldyB7CiAgICAgICAgYXNzZXJ0KGEub3duZXIoKSA9PSBhZGRyZXNzKHRoaXMpKTsgLy8gKDIpIHNob3VsZCBob2xkCiAgICAgICAgYXNzZXJ0KGEueCgpID09IDApOyAvLyAoMykgc2hvdWxkIGhvbGQsIGJ1dCBmYWlscyBkdWUgdG8gYSBmYWxzZSBwb3NpdGl2ZQogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract A {
 uint public x;
 address immutable public owner;
 constructor() {
 owner \= msg.sender;
 }
 function setX(uint \_x) public {
 require(msg.sender \== owner);
 x \= \_x;
 }
}
contract B {
 A a;
 constructor() {
 a \= new A();
 assert(a.x() \== 0); // (1) should hold
 }
 function g() public view {
 assert(a.owner() \== address(this)); // (2) should hold
 assert(a.x() \== 0); // (3) should hold, but fails due to a false positive
 }
}
### Reported Inferred Inductive Invariants[](#reported-inferred-inductive-invariants "Link to this heading")
For properties that were proved safe with the CHC engine, the SMTChecker can retrieve inductive invariants that were inferred by the Horn solver as part of the proof. Currently only two types of invariants can be reported to the user:
* Contract Invariants: these are properties over the contract’s state variables that are true before and after every possible transaction that the contract may ever run. For example, `x >= y`, where `x` and `y` are a contract’s state variables.
 
* Reentrancy Properties: they represent the behavior of the contract in the presence of external calls to unknown code. These properties can express a relation between the value of the state variables before and after the external call, where the external call is free to do anything, including making reentrant calls to the analyzed contract. Primed variables represent the state variables’ values after said external call. Example: `lock -> x = x'`.
 
The user can choose the type of invariants to be reported using the CLI option `--model-checker-invariants "contract,reentrancy"` or as an array in the field `settings.modelChecker.invariants` in the [JSON input](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#compiler-api). By default the SMTChecker does not report invariants.
### Division and Modulo With Slack Variables[](#division-and-modulo-with-slack-variables "Link to this heading")
Spacer, the default Horn solver used by the SMTChecker, often dislikes division and modulo operations inside Horn rules. Because of that, by default the Solidity division and modulo operations are encoded using the constraint `a = b * d + m` where `d = a / b` and `m = a % b`. However, other solvers, such as Eldarica, prefer the syntactically precise operations. The command-line flag `--model-checker-div-mod-no-slacks` and the JSON option `settings.modelChecker.divModNoSlacks` can be used to toggle the encoding depending on the used solver preferences.
### Natspec Function Abstraction[](#natspec-function-abstraction "Link to this heading")
Certain functions including common math methods such as `pow` and `sqrt` may be too complex to be analyzed in a fully automated way. These functions can be annotated with Natspec tags that indicate to the SMTChecker that these functions should be abstracted. This means that the body of the function is not used, and when called, the function will:
* Return a nondeterministic value, and either keep the state variables unchanged if the abstracted function is view/pure, or also set the state variables to nondeterministic values otherwise. This can be used via the annotation `/// @custom:smtchecker abstract-function-nondet`.
 
* Act as an uninterpreted function. This means that the semantics of the function (given by the body) are ignored, and the only property this function has is that given the same input it guarantees the same output. This is currently under development and will be available via the annotation `/// @custom:smtchecker abstract-function-uf`.
 
### Model Checking Engines[](#model-checking-engines "Link to this heading")
The SMTChecker module implements two different reasoning engines, a Bounded Model Checker (BMC) and a system of Constrained Horn Clauses (CHC). Both engines are currently under development, and have different characteristics. The engines are independent and every property warning states from which engine it came. Note that all the examples above with counterexamples were reported by CHC, the more powerful engine.
By default both engines are used, where CHC runs first, and every property that was not proven is passed over to BMC. You can choose a specific engine via the CLI option `--model-checker-engine {all,bmc,chc,none}` or the JSON option `settings.modelChecker.engine={all,bmc,chc,none}`.
#### Bounded Model Checker (BMC)[](#bounded-model-checker-bmc "Link to this heading")
The BMC engine analyzes functions in isolation, that is, it does not take the overall behavior of the contract over multiple transactions into account when analyzing each function. Loops are also ignored in this engine at the moment. Internal function calls are inlined as long as they are not recursive, directly or indirectly. External function calls are inlined if possible. Knowledge that is potentially affected by reentrancy is erased.
The characteristics above make BMC prone to reporting false positives, but it is also lightweight and should be able to quickly find small local bugs.
#### Constrained Horn Clauses (CHC)[](#constrained-horn-clauses-chc "Link to this heading")
A contract’s Control Flow Graph (CFG) is modelled as a system of Horn clauses, where the life cycle of the contract is represented by a loop that can visit every public/external function non-deterministically. This way, the behavior of the entire contract over an unbounded number of transactions is taken into account when analyzing any function. Loops are fully supported by this engine. Internal function calls are supported, and external function calls assume the called code is unknown and can do anything.
The CHC engine is much more powerful than BMC in terms of what it can prove, and might require more computing resources.
### SMT and Horn solvers[](#smt-and-horn-solvers "Link to this heading")
The two engines detailed above use automated theorem provers as their logical backends. BMC uses an SMT solver, whereas CHC uses a Horn solver. Often the same tool can act as both, as seen in [z3](https://github.com/Z3Prover/z3), which is primarily an SMT solver and makes [Spacer](https://spacer.bitbucket.io/) available as a Horn solver, and [Eldarica](https://github.com/uuverifiers/eldarica) which does both.
The user can choose which solvers should be used, if available, via the CLI option `--model-checker-solvers {all,cvc5,eld,smtlib2,z3}` or the JSON option `settings.modelChecker.solvers=[smtlib2,z3]`, where:
* `cvc5` is used via its binary which must be installed in the system. Only BMC uses `cvc5`.
 
* `eld` is used via its binary which must be installed in the system. Only CHC uses `eld`, and only if `z3` is not enabled.
 
* `smtlib2` outputs SMT/Horn queries in the [smtlib2](http://smtlib.cs.uiowa.edu/) format. These can be used together with the compiler’s [callback mechanism](https://github.com/ethereum/solc-js) so that any solver binary from the system can be employed to synchronously return the results of the queries to the compiler. This can be used by both BMC and CHC depending on which solvers are called.
 
* `z3` is available statically in `soljson.js` (from Solidity 0.6.9), that is, the JavaScript binary of the compiler. Otherwise it is used via its binary which must be installed in the system.
 
Note
z3 version 4.8.16 broke ABI compatibility with previous versions and cannot be used with solc <=0.8.13. If you are using z3 >=4.8.16 please use solc >=0.8.14, and conversely, only use older z3 with older solc releases. We also recommend using the latest z3 release which is what SMTChecker also does.
Since both BMC and CHC use `z3`, and `z3` is available in a greater variety of environments, including in the browser, most users will almost never need to be concerned about this option. More advanced users might apply this option to try alternative solvers on more complex problems.
Please note that certain combinations of chosen engine and solver will lead to the SMTChecker doing nothing, for example choosing CHC and `cvc5`.
## Abstraction and False Positives[](#abstraction-and-false-positives "Link to this heading")
The SMTChecker implements abstractions in an incomplete and sound way: If a bug is reported, it might be a false positive introduced by abstractions (due to erasing knowledge or using a non-precise type). If it determines that a verification target is safe, it is indeed safe, that is, there are no false negatives (unless there is a bug in the SMTChecker).
If a target cannot be proven you can try to help the solver by using the tuning options in the previous section. If you are sure of a false positive, adding `require` statements in the code with more information may also give some more power to the solver.
### SMT Encoding and Types[](#smt-encoding-and-types "Link to this heading")
The SMTChecker encoding tries to be as precise as possible, mapping Solidity types and expressions to their closest [SMT-LIB](http://smtlib.cs.uiowa.edu/) representation, as shown in the table below.
Solidity type
SMT sort
Theories
Boolean
Bool
Bool
intN, uintN, address, bytesN, enum, contract
Integer
LIA, NIA
array, mapping, bytes, string
Tuple (Array elements, Integer length)
Datatypes, Arrays, LIA
struct
Tuple
Datatypes
other types
Integer
LIA
Types that are not yet supported are abstracted by a single 256-bit unsigned integer, where their unsupported operations are ignored.
For more details on how the SMT encoding works internally, see the paper [SMT-based Verification of Solidity Smart Contracts](https://github.com/chriseth/solidity_isola/blob/master/main.pdf).
### Function Calls[](#function-calls "Link to this heading")
In the BMC engine, function calls to the same contract (or base contracts) are inlined when possible, that is, when their implementation is available. Calls to functions in other contracts are not inlined even if their code is available, since we cannot guarantee that the actual deployed code is the same.
The CHC engine creates nonlinear Horn clauses that use summaries of the called functions to support internal function calls. External function calls are treated as calls to unknown code, including potential reentrant calls.
Complex pure functions are abstracted by an uninterpreted function (UF) over the arguments.
Functions
BMC/CHC behavior
`assert`
Verification target.
`require`
Assumption.
internal call
BMC: Inline function call. CHC: Function summaries.
external call to known code
BMC: Inline function call or erase knowledge about state variables and local storage references. CHC: Assume called code is unknown. Try to infer invariants that hold after the call returns.
Storage array push/pop
Supported precisely. Checks whether it is popping an empty array.
ABI functions
Abstracted with UF.
`addmod`, `mulmod`
Supported precisely.
`gasleft`, `blobhash`, `blockhash`, `keccak256`, `ecrecover`, `ripemd160`
Abstracted with UF.
pure functions without implementation (external or complex)
Abstracted with UF
external functions without implementation
BMC: Erase state knowledge and assume result is nondeterministic. CHC: Nondeterministic summary. Try to infer invariants that hold after the call returns.
transfer
BMC: Checks whether the contract’s balance is sufficient. CHC: does not yet perform the check.
others
Currently unsupported
Using abstraction means loss of precise knowledge, but in many cases it does not mean loss of proving power.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBSZWNvdmVyCnsKICAgIGZ1bmN0aW9uIGYoCiAgICAgICAgYnl0ZXMzMiBoYXNoLAogICAgICAgIHVpbnQ4IHYxLCB1aW50OCB2MiwKICAgICAgICBieXRlczMyIHIxLCBieXRlczMyIHIyLAogICAgICAgIGJ5dGVzMzIgczEsIGJ5dGVzMzIgczIKICAgICkgcHVibGljIHB1cmUgcmV0dXJucyAoYWRkcmVzcykgewogICAgICAgIGFkZHJlc3MgYTEgPSBlY3JlY292ZXIoaGFzaCwgdjEsIHIxLCBzMSk7CiAgICAgICAgcmVxdWlyZSh2MSA9PSB2Mik7CiAgICAgICAgcmVxdWlyZShyMSA9PSByMik7CiAgICAgICAgcmVxdWlyZShzMSA9PSBzMik7CiAgICAgICAgYWRkcmVzcyBhMiA9IGVjcmVjb3ZlcihoYXNoLCB2MiwgcjIsIHMyKTsKICAgICAgICBhc3NlcnQoYTEgPT0gYTIpOwogICAgICAgIHJldHVybiBhMTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Recover
{
 function f(
 bytes32 hash,
 uint8 v1, uint8 v2,
 bytes32 r1, bytes32 r2,
 bytes32 s1, bytes32 s2
 ) public pure returns (address) {
 address a1 \= ecrecover(hash, v1, r1, s1);
 require(v1 \== v2);
 require(r1 \== r2);
 require(s1 \== s2);
 address a2 \= ecrecover(hash, v2, r2, s2);
 assert(a1 \== a2);
 return a1;
 }
}
In the example above, the SMTChecker is not expressive enough to actually compute `ecrecover`, but by modelling the function calls as uninterpreted functions we know that the return value is the same when called on equivalent parameters. This is enough to prove that the assertion above is always true.
Abstracting a function call with an UF can be done for functions known to be deterministic, and can be easily done for pure functions. It is however difficult to do this with general external functions, since they might depend on state variables.
### Reference Types and Aliasing[](#reference-types-and-aliasing "Link to this heading")
Solidity implements aliasing for reference types with the same [data location](https://docs.soliditylang.org/en/v0.8.30/types.html#data-location). That means one variable may be modified through a reference to the same data area. The SMTChecker does not keep track of which references refer to the same data. This implies that whenever a local reference or state variable of reference type is assigned, all knowledge regarding variables of the same type and data location is erased. If the type is nested, the knowledge removal also includes all the prefix base types.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBBbGlhc2luZwp7CiAgICB1aW50W10gYXJyYXkxOwogICAgdWludFtdW10gYXJyYXkyOwogICAgZnVuY3Rpb24gZigKICAgICAgICB1aW50W10gbWVtb3J5IGEsCiAgICAgICAgdWludFtdIG1lbW9yeSBiLAogICAgICAgIHVpbnRbXVtdIG1lbW9yeSBjLAogICAgICAgIHVpbnRbXSBzdG9yYWdlIGQKICAgICkgaW50ZXJuYWwgewogICAgICAgIGFycmF5MVswXSA9IDQyOwogICAgICAgIGFbMF0gPSAyOwogICAgICAgIGNbMF1bMF0gPSAyOwogICAgICAgIGJbMF0gPSAxOwogICAgICAgIC8vIEVyYXNpbmcga25vd2xlZGdlIGFib3V0IG1lbW9yeSByZWZlcmVuY2VzIHNob3VsZCBub3QKICAgICAgICAvLyBlcmFzZSBrbm93bGVkZ2UgYWJvdXQgc3RhdGUgdmFyaWFibGVzLgogICAgICAgIGFzc2VydChhcnJheTFbMF0gPT0gNDIpOwogICAgICAgIC8vIEhvd2V2ZXIsIGFuIGFzc2lnbm1lbnQgdG8gYSBzdG9yYWdlIHJlZmVyZW5jZSB3aWxsIGVyYXNlCiAgICAgICAgLy8gc3RvcmFnZSBrbm93bGVkZ2UgYWNjb3JkaW5nbHkuCiAgICAgICAgZFswXSA9IDI7CiAgICAgICAgLy8gRmFpbHMgYXMgZmFsc2UgcG9zaXRpdmUgYmVjYXVzZSBvZiB0aGUgYXNzaWdubWVudCBhYm92ZS4KICAgICAgICBhc3NlcnQoYXJyYXkxWzBdID09IDQyKTsKICAgICAgICAvLyBGYWlscyBiZWNhdXNlIGBhID09IGJgIGlzIHBvc3NpYmxlLgogICAgICAgIGFzc2VydChhWzBdID09IDIpOwogICAgICAgIC8vIEZhaWxzIGJlY2F1c2UgYGNbaV0gPT0gYmAgaXMgcG9zc2libGUuCiAgICAgICAgYXNzZXJ0KGNbMF1bMF0gPT0gMik7CiAgICAgICAgYXNzZXJ0KGRbMF0gPT0gMik7CiAgICAgICAgYXNzZXJ0KGJbMF0gPT0gMSk7CiAgICB9CiAgICBmdW5jdGlvbiBnKAogICAgICAgIHVpbnRbXSBtZW1vcnkgYSwKICAgICAgICB1aW50W10gbWVtb3J5IGIsCiAgICAgICAgdWludFtdW10gbWVtb3J5IGMsCiAgICAgICAgdWludCB4CiAgICApIHB1YmxpYyB7CiAgICAgICAgZihhLCBiLCBjLCBhcnJheTJbeF0pOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Aliasing
{
 uint\[\] array1;
 uint\[\]\[\] array2;
 function f(
 uint\[\] memory a,
 uint\[\] memory b,
 uint\[\]\[\] memory c,
 uint\[\] storage d
 ) internal {
 array1\[0\] \= 42;
 a\[0\] \= 2;
 c\[0\]\[0\] \= 2;
 b\[0\] \= 1;
 // Erasing knowledge about memory references should not
 // erase knowledge about state variables.
 assert(array1\[0\] \== 42);
 // However, an assignment to a storage reference will erase
 // storage knowledge accordingly.
 d\[0\] \= 2;
 // Fails as false positive because of the assignment above.
 assert(array1\[0\] \== 42);
 // Fails because \`a == b\` is possible.
 assert(a\[0\] \== 2);
 // Fails because \`c\[i\] == b\` is possible.
 assert(c\[0\]\[0\] \== 2);
 assert(d\[0\] \== 2);
 assert(b\[0\] \== 1);
 }
 function g(
 uint\[\] memory a,
 uint\[\] memory b,
 uint\[\]\[\] memory c,
 uint x
 ) public {
 f(a, b, c, array2\[x\]);
 }
}
After the assignment to `b[0]`, we need to clear knowledge about `a` since it has the same type (`uint[]`) and data location (memory). We also need to clear knowledge about `c`, since its base type is also a `uint[]` located in memory. This implies that some `c[i]` could refer to the same data as `b` or `a`.
Notice that we do not clear knowledge about `array` and `d` because they are located in storage, even though they also have type `uint[]`. However, if `d` was assigned, we would need to clear knowledge about `array` and vice-versa.
### Contract Balance[](#contract-balance "Link to this heading")
A contract may be deployed with funds sent to it, if `msg.value` > 0 in the deployment transaction. However, the contract’s address may already have funds before deployment, which are kept by the contract. Therefore, the SMTChecker assumes that `address(this).balance >= msg.value` in the constructor in order to be consistent with the EVM rules. The contract’s balance may also increase without triggering any calls to the contract, if
* `selfdestruct` is executed by another contract with the analyzed contract as the target of the remaining funds,
 
* the contract is the coinbase (i.e., `block.coinbase`) of some block.
 
To model this properly, the SMTChecker assumes that at every new transaction the contract’s balance may grow by at least `msg.value`.
## Real World Assumptions[](#real-world-assumptions "Link to this heading")
Some scenarios can be expressed in Solidity and the EVM, but are expected to never occur in practice. One of such cases is the length of a dynamic storage array overflowing during a push: If the `push` operation is applied to an array of length 2^256 - 1, its length silently overflows. However, this is unlikely to happen in practice, since the operations required to grow the array to that point would take billions of years to execute. Another similar assumption taken by the SMTChecker is that an address’ balance can never overflow.
A similar idea was presented in [EIP-1985](https://eips.ethereum.org/EIPS/eip-1985).

# [Assemblage en ligne — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/assembly.html) 
 _https://docs.soliditylang.org/fr/latest/assembly.html_

Vous pouvez intercaler des instructions Solidity avec de l’assemblage en ligne dans un langage proche de celui de la machine virtuelle Ethereum. de celui de la machine virtuelle Ethereum. Cela vous donne un contrôle plus fin, ce qui est particulièrement utile lorsque vous améliorez le langage en écrivant des bibliothèques.
Le langage utilisé pour l’assemblage en ligne dans Solidity est appelé [Yul](https://docs.soliditylang.org/fr/latest/yul.html#yul). et il est documenté dans sa propre section. Cette section couvrira uniquement comment le code d’assemblage en ligne peut s’interfacer avec le code Solidity environnant.
Avertissement
L’assemblage en ligne est un moyen d’accéder à la machine virtuelle d’Ethereum à un faible niveau. Cela contourne plusieurs fonctions importantes de sécurité et de vérification de Solidity. Vous ne devez l’utiliser que pour des tâches qui en ont besoin, et seulement si vous avez confiance en son utilisation.
Un bloc d’assemblage en ligne est marqué par `assembly { .... }`, où le code à l’intérieur des les accolades est du code dans le langage [Yul](https://docs.soliditylang.org/fr/latest/yul.html#yul).
Le code d’assemblage en ligne peut accéder aux variables locales de Solidity comme expliqué ci-dessous.
Les différents blocs d’assemblage en ligne ne partagent aucun espace de nom, c’est-à-dire qu’il n’est pas possible d’appeler une fonction Yul ou d’accéder à des variables Solidity.
## Exemple[](#exemple "Lien permanent vers cette rubrique")
L’exemple suivant fournit du code de bibliothèque pour accéder au code d’un autre contrat et le et de le charger dans une variable `bytes`. Ceci est également possible avec « plain Solidity », en utilisant `<adresse>.code`. Mais le point important ici est que les bibliothèques d’assemblage réutilisables peuvent améliorer le langage Solidity sans changer le compilateur. langage Solidity sans changer de compilateur.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmxpYnJhcnkgR2V0Q29kZSB7CiAgICBmdW5jdGlvbiBhdChhZGRyZXNzIF9hZGRyKSBwdWJsaWMgdmlldyByZXR1cm5zIChieXRlcyBtZW1vcnkgb19jb2RlKSB7CiAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICAvLyByZXRyaWV2ZSB0aGUgc2l6ZSBvZiB0aGUgY29kZSwgdGhpcyBuZWVkcyBhc3NlbWJseQogICAgICAgICAgICBsZXQgc2l6ZSA6PSBleHRjb2Rlc2l6ZShfYWRkcikKICAgICAgICAgICAgLy8gYWxsb2NhdGUgb3V0cHV0IGJ5dGUgYXJyYXkgLSB0aGlzIGNvdWxkIGFsc28gYmUgZG9uZSB3aXRob3V0IGFzc2VtYmx5CiAgICAgICAgICAgIC8vIGJ5IHVzaW5nIG9fY29kZSA9IG5ldyBieXRlcyhzaXplKQogICAgICAgICAgICBvX2NvZGUgOj0gbWxvYWQoMHg0MCkKICAgICAgICAgICAgLy8gbmV3ICJtZW1vcnkgZW5kIiBpbmNsdWRpbmcgcGFkZGluZwogICAgICAgICAgICBtc3RvcmUoMHg0MCwgYWRkKG9fY29kZSwgYW5kKGFkZChhZGQoc2l6ZSwgMHgyMCksIDB4MWYpLCBub3QoMHgxZikpKSkKICAgICAgICAgICAgLy8gc3RvcmUgbGVuZ3RoIGluIG1lbW9yeQogICAgICAgICAgICBtc3RvcmUob19jb2RlLCBzaXplKQogICAgICAgICAgICAvLyBhY3R1YWxseSByZXRyaWV2ZSB0aGUgY29kZSwgdGhpcyBuZWVkcyBhc3NlbWJseQogICAgICAgICAgICBleHRjb2RlY29weShfYWRkciwgYWRkKG9fY29kZSwgMHgyMCksIDAsIHNpemUpCiAgICAgICAgfQogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
library GetCode {
 function at(address \_addr) public view returns (bytes memory o\_code) {
 assembly {
 // retrieve the size of the code, this needs assembly
 let size :\= extcodesize(\_addr)
 // allocate output byte array - this could also be done without assembly
 // by using o\_code = new bytes(size)
 o\_code :\= mload(0x40)
 // new "memory end" including padding
 mstore(0x40, add(o\_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))
 // store length in memory
 mstore(o\_code, size)
 // actually retrieve the code, this needs assembly
 extcodecopy(\_addr, add(o\_code, 0x20), 0, size)
 }
 }
}
L’assemblage en ligne est également bénéfique dans les cas où l’optimiseur ne parvient pas à produire code efficace, par exemple :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCgpsaWJyYXJ5IFZlY3RvclN1bSB7CiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGxlc3MgZWZmaWNpZW50IGJlY2F1c2UgdGhlIG9wdGltaXplciBjdXJyZW50bHkgZmFpbHMgdG8KICAgIC8vIHJlbW92ZSB0aGUgYm91bmRzIGNoZWNrcyBpbiBhcnJheSBhY2Nlc3MuCiAgICBmdW5jdGlvbiBzdW1Tb2xpZGl0eSh1aW50W10gbWVtb3J5IF9kYXRhKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IHN1bSkgewogICAgICAgIGZvciAodWludCBpID0gMDsgaSA8IF9kYXRhLmxlbmd0aDsgKytpKQogICAgICAgICAgICBzdW0gKz0gX2RhdGFbaV07CiAgICB9CgogICAgLy8gV2Uga25vdyB0aGF0IHdlIG9ubHkgYWNjZXNzIHRoZSBhcnJheSBpbiBib3VuZHMsIHNvIHdlIGNhbiBhdm9pZCB0aGUgY2hlY2suCiAgICAvLyAweDIwIG5lZWRzIHRvIGJlIGFkZGVkIHRvIGFuIGFycmF5IGJlY2F1c2UgdGhlIGZpcnN0IHNsb3QgY29udGFpbnMgdGhlCiAgICAvLyBhcnJheSBsZW5ndGguCiAgICBmdW5jdGlvbiBzdW1Bc20odWludFtdIG1lbW9yeSBfZGF0YSkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCBzdW0pIHsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCBfZGF0YS5sZW5ndGg7ICsraSkgewogICAgICAgICAgICBhc3NlbWJseSB7CiAgICAgICAgICAgICAgICBzdW0gOj0gYWRkKHN1bSwgbWxvYWQoYWRkKGFkZChfZGF0YSwgMHgyMCksIG11bChpLCAweDIwKSkpKQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQoKICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2NvbXBsaXNoIHRoZSBlbnRpcmUgY29kZSB3aXRoaW4gaW5saW5lIGFzc2VtYmx5LgogICAgZnVuY3Rpb24gc3VtUHVyZUFzbSh1aW50W10gbWVtb3J5IF9kYXRhKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IHN1bSkgewogICAgICAgIGFzc2VtYmx5IHsKICAgICAgICAgICAgLy8gTG9hZCB0aGUgbGVuZ3RoIChmaXJzdCAzMiBieXRlcykKICAgICAgICAgICAgbGV0IGxlbiA6PSBtbG9hZChfZGF0YSkKCiAgICAgICAgICAgIC8vIFNraXAgb3ZlciB0aGUgbGVuZ3RoIGZpZWxkLgogICAgICAgICAgICAvLwogICAgICAgICAgICAvLyBLZWVwIHRlbXBvcmFyeSB2YXJpYWJsZSBzbyBpdCBjYW4gYmUgaW5jcmVtZW50ZWQgaW4gcGxhY2UuCiAgICAgICAgICAgIC8vCiAgICAgICAgICAgIC8vIE5PVEU6IGluY3JlbWVudGluZyBfZGF0YSB3b3VsZCByZXN1bHQgaW4gYW4gdW51c2FibGUKICAgICAgICAgICAgLy8gICAgICAgX2RhdGEgdmFyaWFibGUgYWZ0ZXIgdGhpcyBhc3NlbWJseSBibG9jawogICAgICAgICAgICBsZXQgZGF0YSA6PSBhZGQoX2RhdGEsIDB4MjApCgogICAgICAgICAgICAvLyBJdGVyYXRlIHVudGlsIHRoZSBib3VuZCBpcyBub3QgbWV0LgogICAgICAgICAgICBmb3IKICAgICAgICAgICAgICAgIHsgbGV0IGVuZCA6PSBhZGQoZGF0YSwgbXVsKGxlbiwgMHgyMCkpIH0KICAgICAgICAgICAgICAgIGx0KGRhdGEsIGVuZCkKICAgICAgICAgICAgICAgIHsgZGF0YSA6PSBhZGQoZGF0YSwgMHgyMCkgfQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBzdW0gOj0gYWRkKHN1bSwgbWxvYWQoZGF0YSkpCiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
library VectorSum {
 // This function is less efficient because the optimizer currently fails to
 // remove the bounds checks in array access.
 function sumSolidity(uint\[\] memory \_data) public pure returns (uint sum) {
 for (uint i \= 0; i < \_data.length; ++i)
 sum += \_data\[i\];
 }
 // We know that we only access the array in bounds, so we can avoid the check.
 // 0x20 needs to be added to an array because the first slot contains the
 // array length.
 function sumAsm(uint\[\] memory \_data) public pure returns (uint sum) {
 for (uint i \= 0; i < \_data.length; ++i) {
 assembly {
 sum :\= add(sum, mload(add(add(\_data, 0x20), mul(i, 0x20))))
 }
 }
 }
 // Same as above, but accomplish the entire code within inline assembly.
 function sumPureAsm(uint\[\] memory \_data) public pure returns (uint sum) {
 assembly {
 // Load the length (first 32 bytes)
 let len :\= mload(\_data)
 // Skip over the length field.
 //
 // Keep temporary variable so it can be incremented in place.
 //
 // NOTE: incrementing \_data would result in an unusable
 // \_data variable after this assembly block
 let data :\= add(\_data, 0x20)
 // Iterate until the bound is not met.
 for
 { let end :\= add(data, mul(len, 0x20)) }
 lt(data, end)
 { data :\= add(data, 0x20) }
 {
 sum :\= add(sum, mload(data))
 }
 }
 }
}
## Accès aux variables, fonctions et bibliothèques externes[](#acces-aux-variables-fonctions-et-bibliotheques-externes "Lien permanent vers cette rubrique")
Vous pouvez accéder aux variables Solidity et autres identifiants en utilisant leur nom.
Les variables locales de type valeur sont directement utilisables dans l’assemblage en ligne. Elles peuvent à la fois être lues et assignées.
Les variables locales qui font référence à la mémoire sont évaluées à l’adresse de la variable en mémoire et non à la valeur elle-même. Ces variables peuvent également être assignées, mais notez qu’une assignation ne modifie que le pointeur et non les données. et qu’il est de votre responsabilité de respecter la gestion de la mémoire de Solidity. Voir [Conventions dans Solidity](#conventions-in-solidity).
De même, les variables locales qui font référence à des tableaux de calldonnées ou à des structures de calldonnées de taille statique sont évaluées à l’adresse de la variable dans calldata, et non à la valeur elle-même. La variable peut également être assignée à un nouveau décalage, mais notez qu’aucune validation pour assurer que que la variable ne pointera pas au-delà de `calldatasize()` n’est effectuée.
Pour les pointeurs de fonctions externes, l’adresse et le sélecteur de fonction peuvent être accessible en utilisant `x.address` et `x.selector`. Le sélecteur est constitué de quatre octets alignés à droite. Les deux valeurs peuvent être assignées. Par exemple :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjEwIDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgLy8gQXNzaWducyBhIG5ldyBzZWxlY3RvciBhbmQgYWRkcmVzcyB0byB0aGUgcmV0dXJuIHZhcmlhYmxlIEBmdW4KICAgIGZ1bmN0aW9uIGNvbWJpbmVUb0Z1bmN0aW9uUG9pbnRlcihhZGRyZXNzIG5ld0FkZHJlc3MsIHVpbnQgbmV3U2VsZWN0b3IpIHB1YmxpYyBwdXJlIHJldHVybnMgKGZ1bmN0aW9uKCkgZXh0ZXJuYWwgZnVuKSB7CiAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICBmdW4uc2VsZWN0b3IgOj0gbmV3U2VsZWN0b3IKICAgICAgICAgICAgZnVuLmFkZHJlc3MgIDo9IG5ld0FkZHJlc3MKICAgICAgICB9CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.10 <0.9.0;
contract C {
 // Assigns a new selector and address to the return variable @fun
 function combineToFunctionPointer(address newAddress, uint newSelector) public pure returns (function() external fun) {
 assembly {
 fun.selector :\= newSelector
 fun.address :\= newAddress
 }
 }
}
Pour les tableaux de calldonnées dynamiques, vous pouvez accéder à leur offset (en octets) et leur longueur (nombre d’éléments) en utilisant `x.offset` et `x.length`. Les deux expressions peuvent également être assignées à, mais comme pour le cas statique, aucune validation ne sera effectuée pour s’assurer que la zone de données résultante est dans les limites de `calldatasize()`.
Pour les variables de stockage local ou les variables d’état, un seul identifiant Yul n’est pas suffisant, car elles n’occupent pas nécessairement un seul emplacement de stockage complet. Par conséquent, leur « adresse » est composée d’un slot et d’un byte-offset à l’intérieur de cet emplacement. Pour récupérer le slot pointé par la variable `x`, on utilise vous utilisez `x.slot`, et pour récupérer le byte-offset vous utilisez `x.offset`. L’utilisation de la variable `x` elle-même entraînera une erreur.
Vous pouvez également assigner à la partie `.slot` d’un pointeur de variable de stockage local. Pour celles-ci (structs, arrays ou mappings), la partie `.offset` est toujours zéro. Il n’est pas possible d’assigner à la partie `.slot` ou [\`\`](#id1).offset\`”” d’une variable d’état, cependant.
Les variables locales de Solidity sont disponibles pour les affectations, par exemple :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50IGI7CiAgICBmdW5jdGlvbiBmKHVpbnQgeCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCByKSB7CiAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICAvLyBXZSBpZ25vcmUgdGhlIHN0b3JhZ2Ugc2xvdCBvZmZzZXQsIHdlIGtub3cgaXQgaXMgemVybwogICAgICAgICAgICAvLyBpbiB0aGlzIHNwZWNpYWwgY2FzZS4KICAgICAgICAgICAgciA6PSBtdWwoeCwgc2xvYWQoYi5zbG90KSkKICAgICAgICB9CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract C {
 uint b;
 function f(uint x) public view returns (uint r) {
 assembly {
 // We ignore the storage slot offset, we know it is zero
 // in this special case.
 r :\= mul(x, sload(b.slot))
 }
 }
}
Avertissement
Si vous accédez à des variables d’un type qui s’étend sur moins de 256 bits (par exemple `uint64`, `adresse`, ou `bytes16`), vous ne pouvez pas faire d’hypothèses sur les bits qui ne font pas partie du codage du type. En particulier, ne supposez pas qu’ils soient nuls. Pour être sûr, effacez toujours les données correctement avant de les utiliser dans un contexte où cela est important : `uint32 x = f() ; assembly { x := and(x, 0xffffffff) /* maintenant utiliser x */ }` Pour nettoyer les types signés, vous pouvez utiliser l’opcode `signextend` : `assembly { signextend(<nombre_bytes_de_x_moins_un>, x) }`
Depuis Solidity 0.6.0, le nom d’une variable d’assemblage en ligne ne peut pas suivre aucune déclaration visible dans la portée du bloc d’assemblage en ligne (y compris les déclarations de variables, de contrats et de fonctions).
Depuis la version 0.7.0 de Solidity, les variables et les fonctions déclarées à l’intérieur du bloc d’assemblage en ligne ne peuvent pas contenir `.`, mais l’utilisation de `.` est valide valide pour accéder aux variables Solidity depuis l’extérieur du bloc d’assemblage en ligne.
## Choses à éviter[](#choses-a-eviter "Lien permanent vers cette rubrique")
L’assemblage en ligne peut avoir une apparence de haut niveau, mais il est en fait extrêmement bas niveau. Les appels de fonction, les boucles, les ifs et les switchs sont convertis par de simples règles de réécriture. règles de réécriture et après cela, la seule chose que l’assembleur fait pour vous est de réarranger opcodes de style fonctionnel, le comptage de la hauteur de la pile pour pour l’accès aux variables et la suppression des emplacements de pile pour les variables locales à l’assemblage lorsque la fin de leur bloc est atteinte.
## Conventions dans Solidity[](#conventions-dans-solidity "Lien permanent vers cette rubrique")
Contrairement à l’assemblage EVM, Solidity possède des types dont la taille est inférieure à 256 bits, par exemple uint24. Pour des raisons d’efficacité, la plupart des opérations arithmétiques ignorent le fait que les types peuvent être plus courts que 256 bits, et les bits d’ordre supérieur sont nettoyés lorsque cela est nécessaire, c’est-à-dire peu de temps avant qu’ils ne soient écrits en mémoire ou avant que les comparaisons ne soient effectuées. Cela signifie que si vous accédez à une telle variable à partir d’un assemblage en ligne, vous devrez peut-être d’abord nettoyer manuellement les bits d’ordre supérieur.
Solidity gère la mémoire de la manière suivante. Il existe un  » pointeur de mémoire libre  » à la position 0x40 dans la mémoire. Si vous voulez allouer de la mémoire, utilisez la mémoire à partir de l’endroit où pointe ce pointeur et mettez-la à jour. Il n’y a aucune garantie que la mémoire n’a pas été utilisée auparavant et vous ne pouvez donc pas supposer que son contenu est de zéro octet. Il n’existe pas de mécanisme intégré pour libérer la mémoire allouée. Voici un extrait d’assemblage que vous pouvez utiliser pour allouer de la mémoire qui suit le processus décrit ci-dessus.
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.12&code=ZnVuY3Rpb24gYWxsb2NhdGUobGVuZ3RoKSAtPiBwb3MgewogIHBvcyA6PSBtbG9hZCgweDQwKQogIG1zdG9yZSgweDQwLCBhZGQocG9zLCBsZW5ndGgpKQp9)
function allocate(length) \-> pos {
 pos := mload(0x40)
 mstore(0x40, add(pos, length))
}
Les 64 premiers octets de la mémoire peuvent être utilisés comme « espace de grattage » pour l’allocation à court terme. Les 32 octets après le pointeur de mémoire libre (c’est-à-dire, à partir de `0x60`) sont censés être zéro de manière permanente et sont utilisés comme valeur initiale pour les tableaux de mémoire dynamique vides. Cela signifie que la mémoire allouable commence à 0x80, qui est la valeur initiale du pointeur de mémoire libre.
Les éléments des tableaux de mémoire dans Solidity occupent toujours des multiples de 32 octets (c’est même vrai pour les « octets »). Même vrai pour `bytes1[]`, mais pas pour `bytes` et `string`). Les tableaux de mémoire multidimensionnels sont des pointeurs vers des tableaux de mémoire. La longueur d’un tableau dynamique est stockée dans le premier emplacement du tableau et suivie par les éléments du tableau.
Avertissement
Les tableaux de mémoire de taille statique n’ont pas de champ de longueur, mais celui-ci pourrait être ajouté ultérieurement pour permettre une meilleure convertibilité entre les tableaux de taille statique et dynamique. Pour permettre une meilleure convertibilité entre les tableaux de taille statique et dynamique. Donc ne vous y fiez pas.

# [Analyse de la sortie du compilateur — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/analysing-compilation-output.html) 
 _https://docs.soliditylang.org/fr/latest/analysing-compilation-output.html_

Il est souvent utile d’examiner le code d’assemblage généré par le compilateur. Le binaire généré, c’est-à-dire la sortie de `solc --bin contract.sol`, est généralement difficile à lire. Il est recommandé d’utiliser l’indicateur `--asm` pour analyser la sortie de l’assemblage. Même pour les gros contrats, regarder une visuel de l’assemblage avant et après un changement est souvent très instructif.
Considérons le contrat suivant (nommé, disons `contract.sol`) :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwpjb250cmFjdCBDIHsKICAgIGZ1bmN0aW9uIG9uZSgpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4gMTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
contract C {
 function one() public pure returns (uint) {
 return 1;
 }
}
Voici le résultat de l’opération « solc –asm contract.sol ».
\======= contract.sol:C =======
EVM assembly:
 /\* "contract.sol":0:86 contract C {... \*/
 mstore(0x40, 0x80)
 callvalue
 dup1
 iszero
 tag\_1
 jumpi
 0x00
 dup1
 revert
tag\_1:
 pop
 dataSize(sub\_0)
 dup1
 dataOffset(sub\_0)
 0x00
 codecopy
 0x00
 return
stop
sub\_0: assembly {
 /\* "contract.sol":0:86 contract C {... \*/
 mstore(0x40, 0x80)
 callvalue
 dup1
 iszero
 tag\_1
 jumpi
 0x00
 dup1
 revert
 tag\_1:
 pop
 jumpi(tag\_2, lt(calldatasize, 0x04))
 shr(0xe0, calldataload(0x00))
 dup1
 0x901717d1
 eq
 tag\_3
 jumpi
 tag\_2:
 0x00
 dup1
 revert
 /\* "contract.sol":17:84 function one() public pure returns (uint) {... \*/
 tag\_3:
 tag\_4
 tag\_5
 jump // in
 tag\_4:
 mload(0x40)
 tag\_6
 swap2
 swap1
 tag\_7
 jump // in
 tag\_6:
 mload(0x40)
 dup1
 swap2
 sub
 swap1
 return
 tag\_5:
 /\* "contract.sol":53:57 uint \*/
 0x00
 /\* "contract.sol":76:77 1 \*/
 0x01
 /\* "contract.sol":69:77 return 1 \*/
 swap1
 pop
 /\* "contract.sol":17:84 function one() public pure returns (uint) {... \*/
 swap1
 jump // out
 /\* "#utility.yul":7:125 \*/
 tag\_10:
 /\* "#utility.yul":94:118 \*/
 tag\_12
 /\* "#utility.yul":112:117 \*/
 dup2
 /\* "#utility.yul":94:118 \*/
 tag\_13
 jump // in
 tag\_12:
 /\* "#utility.yul":89:92 \*/
 dup3
 /\* "#utility.yul":82:119 \*/
 mstore
 /\* "#utility.yul":72:125 \*/
 pop
 pop
 jump // out
 /\* "#utility.yul":131:353 \*/
 tag\_7:
 0x00
 /\* "#utility.yul":262:264 \*/
 0x20
 /\* "#utility.yul":251:260 \*/
 dup3
 /\* "#utility.yul":247:265 \*/
 add
 /\* "#utility.yul":239:265 \*/
 swap1
 pop
 /\* "#utility.yul":275:346 \*/
 tag\_15
 /\* "#utility.yul":343:344 \*/
 0x00
 /\* "#utility.yul":332:341 \*/
 dup4
 /\* "#utility.yul":328:345 \*/
 add
 /\* "#utility.yul":319:325 \*/
 dup5
 /\* "#utility.yul":275:346 \*/
 tag\_10
 jump // in
 tag\_15:
 /\* "#utility.yul":229:353 \*/
 swap3
 swap2
 pop
 pop
 jump // out
 /\* "#utility.yul":359:436 \*/
 tag\_13:
 0x00
 /\* "#utility.yul":425:430 \*/
 dup2
 /\* "#utility.yul":414:430 \*/
 swap1
 pop
 /\* "#utility.yul":404:436 \*/
 swap2
 swap1
 pop
 jump // out
 auxdata: 0xa2646970667358221220a5874f19737ddd4c5d77ace1619e5160c67b3d4bedac75fce908fed32d98899864736f6c637827302e382e342d646576656c6f702e323032312e332e33302b636f6d6d69742e65613065363933380058
}
Alternativement, la sortie ci-dessus peut également être obtenue à partir de [Remix](https://remix.ethereum.org/), sous l’option « Compilation Details » après avoir compilé un contrat.
Remarquez que la sortie `asm` commence par le code de création / constructeur. Le code de déploiement est fourni comme partie du sous-objet (dans l’exemple ci-dessus, il fait partie du sous-objet `sub_0`). Le champ ```auxdata`'' correspond au contrat :ref:`metadata <encodage des métadonnées dans le bytecode>`. Les commentaires dans la sortie de l'assemblage pointent vers la emplacement de la source. Notez que ``#utility.yul``` est un fichier généré en interne de fonctions utilitaires qui peut être obtenu en utilisant les drapeaux `--combined-json generated-sources,generated-sources-runtime`.
De même, l’assemblage optimisé peut être obtenu avec la commande : `solc --optimize --asm contract.sol`. Souvent, il est intéressant de voir si deux sources différentes dans Solidity aboutissent au même code optimisé. le même code optimisé. Par exemple, pour voir si les expressions `(a * b) / c`, `a * b / c` génèrent le même bytecode. Cela peut être facilement fait en prenant un `diff` de la sortie assembleur correspondante, après avoir éventuellement supprimé les commentaires. d’assemblage correspondant, après avoir éventuellement supprimé les commentaires qui font référence aux emplacements des sources.
Note
La sortie `--asm` n’est pas conçue pour être lisible par une machine. Par conséquent, il peut y avoir des des changements de rupture sur la sortie entre les versions mineures de solc.

# [Recherche — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/search.html) 
 _https://docs.soliditylang.org/fr/latest/search.html_

* [](https://docs.soliditylang.org/fr/latest/index.html)
* Recherche
* * *

# [Contract Metadata — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/metadata.html) 
 _https://docs.soliditylang.org/en/v0.8.30/metadata.html_

The Solidity compiler automatically generates a JSON file. The file contains two kinds of information about the compiled contract:
* How to interact with the contract: ABI, and NatSpec documentation.
 
* How to reproduce the compilation and verify a deployed contract: compiler version, compiler settings, and source files used.
 
The compiler appends by default the IPFS hash of the metadata file to the end of the runtime bytecode (not necessarily the creation bytecode) of each contract, so that, if published, you can retrieve the file in an authenticated way without having to resort to a centralized data provider. The other available options are the Swarm hash and not appending the metadata hash to the bytecode. These can be configured via the [Standard JSON Interface](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#compiler-api).
You have to publish the metadata file to IPFS, Swarm, or another service so that others can access it. You create the file by using the `solc --metadata` command together with the `--output-dir` parameter. Without the parameter, the metadata will be written to standard output. The metadata contains IPFS and Swarm references to the source code, so you have to upload all source files in addition to the metadata file. For IPFS, the hash contained in the CID returned by `ipfs add` (not the direct sha2-256 hash of the file) shall match with the one contained in the bytecode.
The metadata file has the following format. The example below is presented in a human-readable way. Properly formatted metadata should use quotes correctly, reduce whitespace to a minimum, and sort the keys of all objects in alphabetical order to arrive at a canonical formatting. Comments are not permitted and are used here only for explanatory purposes.
{
 // Required: Details about the compiler, contents are specific
 // to the language.
 "compiler": {
 // Optional: Hash of the compiler binary which produced this output
 "keccak256": "0x123...",
 // Required for Solidity: Version of the compiler
 "version": "0.8.2+commit.661d1103"
 },
 // Required: Source code language, basically selects a "sub-version"
 // of the specification
 "language": "Solidity",
 // Required: Generated information about the contract.
 "output": {
 // Required: ABI definition of the contract. See "Contract ABI Specification"
 "abi": \[/\* ... \*/\],
 // Required: NatSpec developer documentation of the contract. See https://docs.soliditylang.org/en/latest/natspec-format.html for details.
 "devdoc": {
 // Contents of the @author NatSpec field of the contract
 "author": "John Doe",
 // Contents of the @dev NatSpec field of the contract
 "details": "Interface of the ERC20 standard as defined in the EIP. See https://eips.ethereum.org/EIPS/eip-20 for details",
 "errors": {
 "MintToZeroAddress()" : {
 "details": "Cannot mint to zero address"
 }
 },
 "events": {
 "Transfer(address,address,uint256)": {
 "details": "Emitted when \`value\` tokens are moved from one account (\`from\`) toanother (\`to\`).",
 "params": {
 "from": "The sender address",
 "to": "The receiver address",
 "value": "The token amount"
 }
 }
 },
 "kind": "dev",
 "methods": {
 "transfer(address,uint256)": {
 // Contents of the @dev NatSpec field of the method
 "details": "Returns a boolean value indicating whether the operation succeeded. Must be called by the token holder address",
 // Contents of the @param NatSpec fields of the method
 "params": {
 "\_value": "The amount tokens to be transferred",
 "\_to": "The receiver address"
 },
 // Contents of the @return NatSpec field.
 "returns": {
 // Return var name (here "success") if exists. "\_0" as key if return var is unnamed
 "success": "a boolean value indicating whether the operation succeeded"
 }
 }
 },
 "stateVariables": {
 "owner": {
 // Contents of the @dev NatSpec field of the state variable
 "details": "Must be set during contract creation. Can then only be changed by the owner"
 }
 },
 // Contents of the @title NatSpec field of the contract
 "title": "MyERC20: an example ERC20",
 "version": 1 // NatSpec version
 },
 // Required: NatSpec user documentation of the contract. See "NatSpec Format"
 "userdoc": {
 "errors": {
 "ApprovalCallerNotOwnerNorApproved()": \[
 {
 "notice": "The caller must own the token or be an approved operator."
 }
 \]
 },
 "events": {
 "Transfer(address,address,uint256)": {
 "notice": "\`\_value\` tokens have been moved from \`from\` to \`to\`"
 }
 },
 "kind": "user",
 "methods": {
 "transfer(address,uint256)": {
 "notice": "Transfers \`\_value\` tokens to address \`\_to\`"
 }
 },
 "version": 1 // NatSpec version
 }
 },
 // Required: Compiler settings.
 // Reflects the settings in the JSON input during compilation, except:
 // - Different format: "libraries" field
 // - Added field in metadata.settings: "compilationTarget"
 // - Not in metadata.settings: "stopAfter", "debug.debugInfo", "outputSelection"
 // See the standard JSON input's "settings" field docs for the rest.
 "settings": {
 // Required for Solidity: File path and the name of the contract or library this
 // metadata is created for. This field is not present in the standard JSON input settings.
 "compilationTarget": {
 "myDirectory/myFile.sol": "MyContract"
 },
 // Required for Solidity: Addresses for libraries used.
 // Note that metadata has a different format for "libraries" field than the standard JSON input.
 // metadata format = { "MyLib.sol:MyLib": "0x123123..." }
 // standard JSON input format = { "MyLib.sol": { "MyLib": "0x123123..." } }
 "libraries": {
 "MyLib.sol:MyLib": "0x123123..."
 },
 // ...
 // ...
 // ...
 // The rest of the fields and their defaults same as in std JSON input.
 },
 // Required: Compilation source files/source units, keys are file paths
 "sources": {
 "settable": {
 // Required (unless "url" is used): literal contents of the source file
 "content": "contract settable is owned { uint256 private x = 0; function set(uint256 \_x) public { if (msg.sender == owner) x = \_x; } }",
 // Required: keccak256 hash of the source file
 "keccak256": "0x234..."
 },
 "myDirectory/myFile.sol": {
 // Required: keccak256 hash of the source file
 "keccak256": "0x123...",
 // Optional: SPDX license identifier as given in the source file
 "license": "MIT",
 // Required (unless "content" is used, see above): Sorted URL(s)
 // to the source file, protocol is more or less arbitrary, but an
 // IPFS URL is recommended
 "urls": \[ "bzz-raw://7d7a...", "dweb:/ipfs/QmN..." \]
 }
 },
 // Required: The version of the metadata format
 "version": 1
}
Warning
Since the bytecode of the resulting contract contains the metadata hash by default, any change to the metadata might result in a change of the bytecode. This includes changes to a filename or path, and since the metadata includes a hash of all the sources used, a single whitespace change results in different metadata, and different bytecode.
Note
The ABI definition above has no fixed order. It can change with compiler versions. Starting from Solidity version 0.5.12, though, the array maintains a certain order.
## Encoding of the Metadata Hash in the Bytecode[](#encoding-of-the-metadata-hash-in-the-bytecode "Link to this heading")
The compiler currently by default appends the [IPFS hash (in CID v0)](https://docs.ipfs.tech/concepts/content-addressing/#version-0-v0) of the canonical metadata file and the compiler version to the end of the bytecode. Optionally, a Swarm hash instead of the IPFS, or an experimental flag is used. Below are all the possible fields:
{
 "ipfs": "<metadata hash>",
 // If "bytecodeHash" was "bzzr1" in compiler settings not "ipfs" but "bzzr1"
 "bzzr1": "<metadata hash>",
 // Previous versions were using "bzzr0" instead of "bzzr1"
 "bzzr0": "<metadata hash>",
 // If any experimental features that affect code generation are used
 "experimental": true,
 "solc": "<compiler version>"
}
Because we might support other ways to retrieve the metadata file in the future, this information is stored [CBOR](https://tools.ietf.org/html/rfc7049)\-encoded. The last two bytes in the bytecode indicate the length of the CBOR encoded information. By looking at this length, the relevant part of the bytecode can be decoded with a CBOR decoder.
Check the [Metadata Playground](https://playground.sourcify.dev/) to see it in action.
Whereas release builds of solc use a 3 byte encoding of the version as shown above (one byte each for major, minor and patch version number), pre-release builds will instead use a complete version string including commit hash and build date.
The commandline flag `--no-cbor-metadata` can be used to skip metadata from getting appended at the end of the deployed bytecode. Equivalently, the boolean field `settings.metadata.appendCBOR` in Standard JSON input can be set to false.
Note
The CBOR mapping can also contain other keys, so it is better to fully decode the data by looking at the end of the bytecode for the CBOR length, and to use a proper CBOR parser. Do not rely on it starting with `0xa264` or `0xa2 0x64 'i' 'p' 'f' 's'`.
## Usage for Automatic Interface Generation and NatSpec[](#usage-for-automatic-interface-generation-and-natspec "Link to this heading")
The metadata is used in the following way: A component that wants to interact with a contract (e.g. a wallet) retrieves the code of the contract. It decodes the CBOR encoded section containing the IPFS/Swarm hash of the metadata file. With that hash, the metadata file is retrieved. That file is JSON-decoded into a structure like above.
The component can then use the ABI to automatically generate a rudimentary user interface for the contract.
Furthermore, the wallet can use the NatSpec user documentation to display a human-readable confirmation message to the user whenever they interact with the contract, together with requesting authorization for the transaction signature.
For additional information, read [Ethereum Natural Language Specification (NatSpec) format](https://docs.soliditylang.org/en/v0.8.30/natspec-format.html).
## Usage for Source Code Verification[](#usage-for-source-code-verification "Link to this heading")
If pinned/published, it is possible to retrieve the metadata of the contract from IPFS/Swarm. The metadata file also contains the URLs or the IPFS hashes of the source files, as well as the compilation settings, i.e. everything needed to reproduce a compilation.
With this information it is then possible to verify the source code of a contract by reproducing the compilation, and comparing the bytecode from the compilation with the bytecode of the deployed contract.
This automatically verifies the metadata since its hash is part of the bytecode, as well as the source codes, because their hashes are part of the metadata. Any change in the files or settings would result in a different metadata hash. The metadata here serves as a fingerprint of the whole compilation.
[Sourcify](https://sourcify.dev/) makes use of this feature for “full/perfect verification”, as well as pinning the files publicly on IPFS to be accessed with the metadata hash.

# [Contrats — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/contracts.html) 
 _https://docs.soliditylang.org/fr/latest/contracts.html_

Les contrats dans Solidity sont similaires aux classes dans les langages orientés objet. Ils contiennent des données persistantes dans des variables d’état, et des fonctions qui peuvent modifier ces variables. L’appel d’une fonction sur un contrat (instance) différent va effectuer un appel de fonction EVM et donc un changement de contexte de telle sorte que les variables d’état dans le contrat appelant sont inaccessibles. Un contrat et ses fonctions doivent être appelés pour que quelque chose se produise. Il n’y a pas de concept de « cron » dans Ethereum pour appeler une fonction à un événement particulier automatiquement.
## Création de contrats[](#creation-de-contrats "Lien permanent vers cette rubrique")
Les contrats peuvent être créés « de l’extérieur » via des transactions Ethereum ou à partir de contrats Solidity.
Des IDE, tels que [Remix](https://remix.ethereum.org/), rendent le processus de création transparent à l’aide d’éléments d’interface utilisateur.
Une façon de créer des contrats de façon programmatique sur Ethereum est via l’API JavaScript [web3.js](https://github.com/ethereum/web3.js). Elle dispose d’une fonction appelée [web3.eth.Contract](https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract) pour faciliter la création de contrats.
Lorsqu’un contrat est créé, son [constructeur](#constructor) (une fonction déclarée avec la fonction le mot-clé `constructor`) est exécutée une fois.
Un constructeur est facultatif. Un seul constructeur est autorisé, ce qui signifie que la surcharge n’est pas supportée.
Après l’exécution du constructeur, le code final du contrat est stocké sur la blockchain. Ce code comprend toutes les fonctions publiques et externes ainsi que toutes les fonctions qui sont accessibles à partir de là par des appels de fonction. Le code déployé n’inclut pas le code du constructeur ou les fonctions internes appelées uniquement depuis le constructeur.
En interne, les arguments des constructeurs sont passés [ABI encodé](https://docs.soliditylang.org/fr/latest/abi-spec.html#abi) après le code du contrat lui-même, mais vous n’avez pas à vous en soucier si vous utilisez `web3.js`.
Si un contrat souhaite créer un autre contrat, le code source (et le binaire) du contrat créé doit être connu du créateur. Cela signifie que les dépendances cycliques de création sont impossibles.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCgpjb250cmFjdCBPd25lZFRva2VuIHsKICAgIC8vIGBUb2tlbkNyZWF0b3JgIGVzdCB1biB0eXBlIGRlIGNvbnRyYXQgcXVpIGVzdCBkw6lmaW5pIGNpLWRlc3NvdXMuCiAgICAvLyBJbCBlc3QgcG9zc2libGUgZCd5IGZhaXJlIHLDqWbDqXJlbmNlIHRhbnQgcXUnaWwgbidlc3QgcGFzIHV0aWxpc8OpCiAgICAvLyBwb3VyIGNyw6llciB1biBub3V2ZWF1IGNvbnRyYXQuCiAgICBUb2tlbkNyZWF0b3IgY3JlYXRvcjsKICAgIGFkZHJlc3Mgb3duZXI7CiAgICBieXRlczMyIG5hbWU7CgogICAgLy8gSWwgcydhZ2l0IGR1IGNvbnN0cnVjdGV1ciBxdWkgZW5yZWdpc3RyZSBsZQogICAgLy8gY3LDqWF0ZXVyIGV0IGxlIG5vbSBhdHRyaWJ1w6kuCiAgICBjb25zdHJ1Y3RvcihieXRlczMyIF9uYW1lKSB7CiAgICAgICAgLy8gTGVzIHZhcmlhYmxlcyBkJ8OpdGF0IHNvbnQgYWNjZXNzaWJsZXMgdmlhIGxldXIgbm9tCiAgICAgICAgLy8gZXQgbm9uIHBhcyB2aWEsIHBhciBleGVtcGxlLCBgdGhpcy5vd25lcmAuIExlcyBmb25jdGlvbnMgcGV1dmVudAogICAgICAgIC8vIMOqdHJlIGFjY8OpZMOpZXMgZGlyZWN0ZW1lbnQgb3UgdmlhIGB0aGlzLmZgLAogICAgICAgIC8vIG1haXMgY2UgZGVybmllciBmb3Vybml0IHVuZSB2dWUgZXh0ZXJuZQogICAgICAgIC8vIMOgIGxhIGZvbmN0aW9uLiBFbiBwYXJ0aWN1bGllciBkYW5zIGxlIGNvbnN0cnVjdGV1ciwKICAgICAgICAvLyB2b3VzIG5lIGRldnJpZXogcGFzIGFjY8OpZGVyIGF1eCBmb25jdGlvbnMgZGUgbWFuacOocmUgZXh0ZXJuZSwKICAgICAgICAvLyBjYXIgbGEgZm9uY3Rpb24gbidleGlzdGUgcGFzIGVuY29yZS4KICAgICAgICAvLyBWb2lyIGxhIHNlY3Rpb24gc3VpdmFudGUgcG91ciBwbHVzIGRlIGTDqXRhaWxzLgogICAgICAgIG93bmVyID0gbXNnLnNlbmRlcjsKCiAgICAgICAgLy8gTm91cyBlZmZlY3R1b25zIHVuZSBjb252ZXJzaW9uIGRlIHR5cGUgZXhwbGljaXRlIGRlIGBhZGRyZXNzYAogICAgICAgIC8vIHZlcnMgYFRva2VuQ3JlYXRvcmAgZXQgbm91cyBzdXBwb3NvbnMgcXVlIGxlIHR5cGUgZGUKICAgICAgICAvLyBjb250cmF0IGFwcGVsYW50IGVzdCBgVG9rZW5DcmVhdG9yYCwgbWFpcyBpbCBuJ2V4aXN0ZQogICAgICAgIC8vIGF1Y3VuIG1veWVuIHLDqWVsIGRlIGxlIHbDqXJpZmllci4KICAgICAgICAvLyBDZXR0ZSBvcMOpcmF0aW9uIG5lIGNyw6llIHBhcyBkZSBub3V2ZWF1IGNvbnRyYXQuCiAgICAgICAgY3JlYXRvciA9IFRva2VuQ3JlYXRvcihtc2cuc2VuZGVyKTsKICAgICAgICBuYW1lID0gX25hbWU7CiAgICB9CgogICAgZnVuY3Rpb24gY2hhbmdlTmFtZShieXRlczMyIG5ld05hbWUpIHB1YmxpYyB7CiAgICAgICAgLy8gU2V1bCBsZSBjcsOpYXRldXIgcGV1dCBtb2RpZmllciBsZSBub20uCiAgICAgICAgLy8gTm91cyBjb21wYXJvbnMgbGUgY29udHJhdCBlbiBmb25jdGlvbiBkZSBzb24KICAgICAgICAvLyBhZHJlc3NlIHF1aSBwZXV0IMOqdHJlIHLDqWN1cMOpcsOpZSBwYXIKICAgICAgICAvLyBjb252ZXJzaW9uIGV4cGxpY2l0ZSBlbiBhZHJlc3NlLgogICAgICAgIGlmIChtc2cuc2VuZGVyID09IGFkZHJlc3MoY3JlYXRvcikpCiAgICAgICAgICAgIG5hbWUgPSBuZXdOYW1lOwogICAgfQoKICAgIGZ1bmN0aW9uIHRyYW5zZmVyKGFkZHJlc3MgbmV3T3duZXIpIHB1YmxpYyB7CiAgICAgICAgLy8gU2V1bCBsZSBwcm9wcmnDqXRhaXJlIGFjdHVlbCBwZXV0IHRyYW5zZsOpcmVyIGxlIGpldG9uLgogICAgICAgIGlmIChtc2cuc2VuZGVyICE9IG93bmVyKSByZXR1cm47CgogICAgICAgIC8vIE5vdXMgZGVtYW5kb25zIGF1IGNvbnRyYXQgZGUgY3LDqWF0aW9uIHNpIGxlIHRyYW5zZmVydAogICAgICAgIC8vIGRvaXQgYXZvaXIgbGlldSBlbiB1dGlsaXNhbnQgdW5lIGZvbmN0aW9uIGR1CiAgICAgICAgLy8gY29udHJhdCBgVG9rZW5DcmVhdG9yYCBkw6lmaW5pIGNpLWRlc3NvdXMuIFNpCiAgICAgICAgLy8gbCdhcHBlbCDDqWNob3VlIChwYXIgZXhlbXBsZSDDoCBjYXVzZSBkJ3VuZSBwYW5uZSBzw6hjaGUpLAogICAgICAgIC8vIGwnZXjDqWN1dGlvbiDDqWNob3VlIMOpZ2FsZW1lbnQgaWNpLgogICAgICAgIGlmIChjcmVhdG9yLmlzVG9rZW5UcmFuc2Zlck9LKG93bmVyLCBuZXdPd25lcikpCiAgICAgICAgICAgIG93bmVyID0gbmV3T3duZXI7CiAgICB9Cn0KCgpjb250cmFjdCBUb2tlbkNyZWF0b3IgewogICAgZnVuY3Rpb24gY3JlYXRlVG9rZW4oYnl0ZXMzMiBuYW1lKQogICAgICAgIHB1YmxpYwogICAgICAgIHJldHVybnMgKE93bmVkVG9rZW4gdG9rZW5BZGRyZXNzKQogICAgewogICAgICAgIC8vIENyw6llIHVuIG5vdXZlYXUgY29udHJhdCBgVG9rZW5gIGV0IHJldG91cm5lIHNvbiBhZHJlc3NlLgogICAgICAgIC8vIER1IGPDtHTDqSBkZSBKYXZhU2NyaXB0LCBsZSB0eXBlIGRlIHJldG91cgogICAgICAgIC8vIGRlIGNldHRlIGZvbmN0aW9uIGVzdCBgYWRkcmVzc2AsIHB1aXNxdWUgYydlc3QKICAgICAgICAvLyBsZSB0eXBlIGxlIHBsdXMgcHJvY2hlIGRpc3BvbmlibGUgZGFucyBsJ0FCSS4KICAgICAgICByZXR1cm4gbmV3IE93bmVkVG9rZW4obmFtZSk7CiAgICB9CgogICAgZnVuY3Rpb24gY2hhbmdlTmFtZShPd25lZFRva2VuIHRva2VuQWRkcmVzcywgYnl0ZXMzMiBuYW1lKSBwdWJsaWMgewogICAgICAgIC8vIEVuY29yZSB1bmUgZm9pcywgbGUgdHlwZSBleHRlcm5lIGRlIGB0b2tlbkFkZHJlc3NgIGVzdAogICAgICAgIC8vIHNpbXBsZW1lbnQgYGFkZHJlc3NgLgogICAgICAgIHRva2VuQWRkcmVzcy5jaGFuZ2VOYW1lKG5hbWUpOwogICAgfQoKICAgIC8vIEVmZmVjdHVlciBkZXMgdsOpcmlmaWNhdGlvbnMgcG91ciBkw6l0ZXJtaW5lciBzaSBsZSB0cmFuc2ZlcnQgZCd1biBqZXRvbiB2ZXJzCiAgICAvLyBsZSBjb250cmF0IGBPd25lZFRva2VuYCBkb2l0IMOqdHJlIGVmZmVjdHXDqS4KICAgIGZ1bmN0aW9uIGlzVG9rZW5UcmFuc2Zlck9LKGFkZHJlc3MgY3VycmVudE93bmVyLCBhZGRyZXNzIG5ld093bmVyKQogICAgICAgIHB1YmxpYwogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zIChib29sIG9rKQogICAgewogICAgICAgIC8vIFbDqXJpZmllciB1bmUgY29uZGl0aW9uIGFyYml0cmFpcmUgcG91ciB2b2lyIHNpIGxlIHRyYW5zZmVydCBkb2l0IGF2b2lyIGxpZXUuCiAgICAgICAgcmV0dXJuIGtlY2NhazI1NihhYmkuZW5jb2RlUGFja2VkKGN1cnJlbnRPd25lciwgbmV3T3duZXIpKVswXSA9PSAweDdmOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.22 <0.9.0;
contract OwnedToken {
 // \`TokenCreator\` est un type de contrat qui est défini ci-dessous.
 // Il est possible d'y faire référence tant qu'il n'est pas utilisé
 // pour créer un nouveau contrat.
 TokenCreator creator;
 address owner;
 bytes32 name;
 // Il s'agit du constructeur qui enregistre le
 // créateur et le nom attribué.
 constructor(bytes32 \_name) {
 // Les variables d'état sont accessibles via leur nom
 // et non pas via, par exemple, \`this.owner\`. Les fonctions peuvent
 // être accédées directement ou via \`this.f\`,
 // mais ce dernier fournit une vue externe
 // à la fonction. En particulier dans le constructeur,
 // vous ne devriez pas accéder aux fonctions de manière externe,
 // car la fonction n'existe pas encore.
 // Voir la section suivante pour plus de détails.
 owner \= msg.sender;
 // Nous effectuons une conversion de type explicite de \`address\`
 // vers \`TokenCreator\` et nous supposons que le type de
 // contrat appelant est \`TokenCreator\`, mais il n'existe
 // aucun moyen réel de le vérifier.
 // Cette opération ne crée pas de nouveau contrat.
 creator \= TokenCreator(msg.sender);
 name \= \_name;
 }
 function changeName(bytes32 newName) public {
 // Seul le créateur peut modifier le nom.
 // Nous comparons le contrat en fonction de son
 // adresse qui peut être récupérée par
 // conversion explicite en adresse.
 if (msg.sender \== address(creator))
 name \= newName;
 }
 function transfer(address newOwner) public {
 // Seul le propriétaire actuel peut transférer le jeton.
 if (msg.sender != owner) return;
 // Nous demandons au contrat de création si le transfert
 // doit avoir lieu en utilisant une fonction du
 // contrat \`TokenCreator\` défini ci-dessous. Si
 // l'appel échoue (par exemple à cause d'une panne sèche),
 // l'exécution échoue également ici.
 if (creator.isTokenTransferOK(owner, newOwner))
 owner \= newOwner;
 }
}
contract TokenCreator {
 function createToken(bytes32 name)
 public
 returns (OwnedToken tokenAddress)
 {
 // Crée un nouveau contrat \`Token\` et retourne son adresse.
 // Du côté de JavaScript, le type de retour
 // de cette fonction est \`address\`, puisque c'est
 // le type le plus proche disponible dans l'ABI.
 return new OwnedToken(name);
 }
 function changeName(OwnedToken tokenAddress, bytes32 name) public {
 // Encore une fois, le type externe de \`tokenAddress\` est
 // simplement \`address\`.
 tokenAddress.changeName(name);
 }
 // Effectuer des vérifications pour déterminer si le transfert d'un jeton vers
 // le contrat \`OwnedToken\` doit être effectué.
 function isTokenTransferOK(address currentOwner, address newOwner)
 public
 pure
 returns (bool ok)
 {
 // Vérifier une condition arbitraire pour voir si le transfert doit avoir lieu.
 return keccak256(abi.encodePacked(currentOwner, newOwner))\[0\] \== 0x7f;
 }
}
## Visibilité et Getters[](#visibilite-et-getters "Lien permanent vers cette rubrique")
Solidity connaît deux types d’appels de fonction : internes qui ne créent pas d’appel EVM réel (également appelé « appel de message ») et les externes qui le font. Pour cette raison, il existe quatre types de visibilité pour les fonctions et les variables d’état.
Les fonctions doivent être spécifiées comme étant `external`, `public`, `internal` ou `private`. Pour les variables d’état, `external` n’est pas possible.
`external`
Les fonctions externes font partie de l’interface du contrat, ce qui signifie qu’elles peuvent être appelées depuis d’autres contrats et via des transactions. Une fonction externe `f` ne peut pas être appelée en interne (c’est-à-dire que `f()` ne fonctionne pas, mais `this.f()` fonctionne).
`public`
Les fonctions publiques font partie de l’interface du contrat et peuvent être appelées soit en interne, soit via des messages. Pour les variables d’état publiques, une fonction getter automatique (voir ci-dessous) est générée.
`internal`
Ces fonctions et variables d’état ne peuvent être accessibles qu’en interne (c’est à dire depuis le contrat en cours ou des contrats qui en dérivent), sans utiliser `this`. C’est le niveau de visibilité par défaut des variables d’état.
`private`
Les fonctions privées et les variables d’état ne sont visibles que pour le contrat dans lequel elles sont définies et non dans des contrats dérivés.
Note
Tout ce qui est à l’intérieur d’un contrat est visible pour tous les observateurs externes à la blockchain. Rendre quelque chose `private` empêche seulement les autres contrats de lire ou de modifier l’information, mais elle sera toujours visible pour le monde entier en dehors de la blockchain.
Le spécificateur de visibilité est donné après le type pour les variables d’état et entre la liste des paramètres et la liste de paramètres de retour pour les fonctions.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50IGEpIHByaXZhdGUgcHVyZSByZXR1cm5zICh1aW50IGIpIHsgcmV0dXJuIGEgKyAxOyB9CiAgICBmdW5jdGlvbiBzZXREYXRhKHVpbnQgYSkgaW50ZXJuYWwgeyBkYXRhID0gYTsgfQogICAgdWludCBwdWJsaWMgZGF0YTsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 function f(uint a) private pure returns (uint b) { return a + 1; }
 function setData(uint a) internal { data \= a; }
 uint public data;
}
Dans l’exemple suivant, `D`, peut appeler `c.setData()` pour récupérer la valeur de `data` dans le stockage d’état, mais ne peut pas appeler `f`. Le contrat `E` est dérivé du contrat `C` et peut donc appeler `compute`.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludCBwcml2YXRlIGRhdGE7CgogICAgZnVuY3Rpb24gZih1aW50IGEpIHByaXZhdGUgcHVyZSByZXR1cm5zKHVpbnQgYikgeyByZXR1cm4gYSArIDE7IH0KICAgIGZ1bmN0aW9uIHNldERhdGEodWludCBhKSBwdWJsaWMgeyBkYXRhID0gYTsgfQogICAgZnVuY3Rpb24gZ2V0RGF0YSgpIHB1YmxpYyB2aWV3IHJldHVybnModWludCkgeyByZXR1cm4gZGF0YTsgfQogICAgZnVuY3Rpb24gY29tcHV0ZSh1aW50IGEsIHVpbnQgYikgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7IHJldHVybiBhICsgYjsgfQp9CgovLyBDZWxhIG5lIGNvbXBpbGVyYSBwYXMKY29udHJhY3QgRCB7CiAgICBmdW5jdGlvbiByZWFkRGF0YSgpIHB1YmxpYyB7CiAgICAgICAgQyBjID0gbmV3IEMoKTsKICAgICAgICB1aW50IGxvY2FsID0gYy5mKDcpOyAvLyBlcnJldXIgOiBsZSBtZW1icmUgYGZgIG4nZXN0IHBhcyB2aXNpYmxlCiAgICAgICAgYy5zZXREYXRhKDMpOwogICAgICAgIGxvY2FsID0gYy5nZXREYXRhKCk7CiAgICAgICAgbG9jYWwgPSBjLmNvbXB1dGUoMywgNSk7IC8vIGVycmV1ciA6IGxlIG1lbWJyZSBgY29tcHV0ZWAgbidlc3QgcGFzIHZpc2libGUKICAgIH0KfQoKY29udHJhY3QgRSBpcyBDIHsKICAgIGZ1bmN0aW9uIGcoKSBwdWJsaWMgewogICAgICAgIEMgYyA9IG5ldyBDKCk7CiAgICAgICAgdWludCB2YWwgPSBjb21wdXRlKDMsIDUpOyAvLyBhY2PDqHMgYXUgbWVtYnJlIGludGVybmUgKGR1IGNvbnRyYXQgZMOpcml2w6kgYXUgY29udHJhdCBwYXJlbnQpCiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 uint private data;
 function f(uint a) private pure returns(uint b) { return a + 1; }
 function setData(uint a) public { data \= a; }
 function getData() public view returns(uint) { return data; }
 function compute(uint a, uint b) internal pure returns (uint) { return a + b; }
}
// Cela ne compilera pas
contract D {
 function readData() public {
 C c \= new C();
 uint local \= c.f(7); // erreur : le membre \`f\` n'est pas visible
 c.setData(3);
 local \= c.getData();
 local \= c.compute(3, 5); // erreur : le membre \`compute\` n'est pas visible
 }
}
contract E is C {
 function g() public {
 C c \= new C();
 uint val \= compute(3, 5); // accès au membre interne (du contrat dérivé au contrat parent)
 }
}
### Fonctions Getter[](#fonctions-getter "Lien permanent vers cette rubrique")
Le compilateur crée automatiquement des fonctions getter pour toutes les variables d’état **publiques**. Pour le contrat donné ci-dessous, le compilateur générera une fonction appelée `data` qui ne prend aucun arguments et retourne un `uint`, la valeur de la variable d’état `data`. Les variables d’état peuvent être initialisées lorsqu’elles sont déclarées.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludCBwdWJsaWMgZGF0YSA9IDQyOwp9Cgpjb250cmFjdCBDYWxsZXIgewogICAgQyBjID0gbmV3IEMoKTsKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGMuZGF0YSgpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 uint public data \= 42;
}
contract Caller {
 C c \= new C();
 function f() public view returns (uint) {
 return c.data();
 }
}
Les fonctions getter ont une visibilité externe. Si le symbole est accédé en interne (c’est-à-dire sans `this.`), il est évalué comme une variable d’état. S’il est accédé en externe (c’est-à-dire avec `this.`), il est évalué comme une fonction.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50IHB1YmxpYyBkYXRhOwogICAgZnVuY3Rpb24geCgpIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgZGF0YSA9IDM7IC8vIGFjY8OocyBpbnRlcm5lCiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgpOyAvLyBhY2PDqHMgZXh0ZXJuZQogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract C {
 uint public data;
 function x() public returns (uint) {
 data \= 3; // accès interne
 return this.data(); // accès externe
 }
}
Si vous avez une variable d’état `public` de type tableau, alors vous pouvez seulement récupérer les éléments uniques du tableau via la fonction getter générée. Ce mécanisme existe pour éviter des coûts de gaz élevés lors du retour d’un tableau entier. Vous pouvez utiliser pour spécifier l’élément individuel à retourner, par exemple `myArray(0)`. Si vous voulez retourner un tableau entier en un seul appel, vous devez alors écrire une fonction, par exemple :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IGFycmF5RXhhbXBsZSB7CiAgICAvLyB2YXJpYWJsZSBkJ8OpdGF0IHB1YmxpcXVlCiAgICB1aW50W10gcHVibGljIG15QXJyYXk7CgogICAgLy8gRm9uY3Rpb24gR2V0dGVyIGfDqW7DqXLDqWUgcGFyIGxlIGNvbXBpbGF0ZXVyCiAgICAvKgogICAgZnVuY3Rpb24gbXlBcnJheSh1aW50IGkpIHB1YmxpYyB2aWV3IHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4gbXlBcnJheVtpXTsKICAgIH0KICAgICovCgogICAgLy8gZm9uY3Rpb24gcXVpIHJldG91cm5lIGxlIHRhYmxlYXUgZW50aWVyCiAgICBmdW5jdGlvbiBnZXRBcnJheSgpIHB1YmxpYyB2aWV3IHJldHVybnMgKHVpbnRbXSBtZW1vcnkpIHsKICAgICAgICByZXR1cm4gbXlBcnJheTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract arrayExample {
 // variable d'état publique
 uint\[\] public myArray;
 // Fonction Getter générée par le compilateur
 /\*
 function myArray(uint i) public view returns (uint) {
 return myArray\[i\];
 }
 \*/
 // fonction qui retourne le tableau entier
 function getArray() public view returns (uint\[\] memory) {
 return myArray;
 }
}
Maintenant vous pouvez utiliser `getArray()` pour récupérer le tableau entier, au lieu de `myArray(i)`, qui retourne un seul élément par appel.
L’exemple suivant est plus complexe :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQ29tcGxleCB7CiAgICBzdHJ1Y3QgRGF0YSB7CiAgICAgICAgdWludCBhOwogICAgICAgIGJ5dGVzMyBiOwogICAgICAgIG1hcHBpbmcgKHVpbnQgPT4gdWludCkgbWFwOwogICAgICAgIHVpbnRbM10gYzsKICAgICAgICB1aW50W10gZDsKICAgICAgICBieXRlcyBlOwogICAgfQogICAgbWFwcGluZyAodWludCA9PiBtYXBwaW5nKGJvb2wgPT4gRGF0YVtdKSkgcHVibGljIGRhdGE7Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract Complex {
 struct Data {
 uint a;
 bytes3 b;
 mapping (uint \=> uint) map;
 uint\[3\] c;
 uint\[\] d;
 bytes e;
 }
 mapping (uint \=> mapping(bool \=> Data\[\])) public data;
}
Il génère une fonction de la forme suivante. Le mappage et les tableaux (à l’exception des tableaux d’octets) dans la structure sont omis parce qu’il n’y a pas de bonne façon de sélectionner les membres individuels de la structure ou de fournir une clé pour le mappage :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZnVuY3Rpb24gZGF0YSh1aW50IGFyZzEsIGJvb2wgYXJnMiwgdWludCBhcmczKQogICAgcHVibGljCiAgICByZXR1cm5zICh1aW50IGEsIGJ5dGVzMyBiLCBieXRlcyBtZW1vcnkgZSkKewogICAgYSA9IGRhdGFbYXJnMV1bYXJnMl1bYXJnM10uYTsKICAgIGIgPSBkYXRhW2FyZzFdW2FyZzJdW2FyZzNdLmI7CiAgICBlID0gZGF0YVthcmcxXVthcmcyXVthcmczXS5lOwp9)
function data(uint arg1, bool arg2, uint arg3)
 public
 returns (uint a, bytes3 b, bytes memory e)
{
 a \= data\[arg1\]\[arg2\]\[arg3\].a;
 b \= data\[arg1\]\[arg2\]\[arg3\].b;
 e \= data\[arg1\]\[arg2\]\[arg3\].e;
}
## Modificateurs de fonction[](#modificateurs-de-fonction "Lien permanent vers cette rubrique")
Les modificateurs peuvent être utilisés pour changer le comportement des fonctions de manière déclarative. Par exemple, vous pouvez utiliser un modificateur pour vérifier automatiquement une condition avant d’exécuter la fonction.
Les modificateurs sont des propriétés héritables des contrats et peuvent être remplacées par des contrats dérivés, mais uniquement s’ils sont marqués `virtual`. Pour plus de détails, veuillez consulter [Modifier Overriding](#modifier-overriding).
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwoKICAgIC8vIENlIGNvbnRyYXQgZMOpZmluaXQgdW5pcXVlbWVudCB1biBtb2RpZmljYXRldXIgbWFpcyBuZSBsJ3V0aWxpc2UgcGFzLgogICAgLy8gbWFpcyBuZSBsJ3V0aWxpc2UgcGFzIDogaWwgc2VyYSB1dGlsaXPDqSBkYW5zIGxlcyBjb250cmF0cyBkw6lyaXbDqXMuCiAgICAvLyBMZSBjb3JwcyBkZSBsYSBmb25jdGlvbiBlc3QgaW5zw6lyw6kgbMOgIG/DuSBhcHBhcmHDrnQgbGUgc3ltYm9sZSBzcMOpY2lhbAogICAgLy8gYF87YCBkYW5zIGxhIGTDqWZpbml0aW9uIGQndW4gbW9kaWZpY2F0ZXVyLgogICAgLy8gQ2VsYSBzaWduaWZpZSBxdWUgc2kgbGUgcHJvcHJpw6l0YWlyZSBhcHBlbGxlIGNldHRlIGZvbmN0aW9uLAogICAgLy8gbGEgZm9uY3Rpb24gZXN0IGV4w6ljdXTDqWUgZXQgc2lub24sIHVuZSBleGNlcHRpb24gZXN0CiAgICAvLyBsZXbDqWUuCiAgICBtb2RpZmllciBvbmx5T3duZXIgewogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgIG1zZy5zZW5kZXIgPT0gb3duZXIsCiAgICAgICAgICAgICJTZXVsIGxlIHByb3ByacOpdGFpcmUgcGV1dCBhcHBlbGVyIGNldHRlIGZvbmN0aW9uLiIKICAgICAgICApOwogICAgICAgIF87CiAgICB9Cn0KCmNvbnRyYWN0IGRlc3RydWN0aWJsZSBpcyBvd25lZCB7CiAgICAvLyBDZSBjb250cmF0IGjDqXJpdGUgZHUgbW9kaWZpY2F0ZXVyIGBvbmx5T3duZXJgIGRlIGxhIGZvbmN0aW9uCiAgICAvLyBgb3duZWRgIGV0IGwnYXBwbGlxdWUgw6AgbGEgZm9uY3Rpb24gYGRlc3Ryb3lgLCBxdWkKICAgIC8vIGZhaXQgcXVlIGxlcyBhcHBlbHMgw6AgYGRlc3Ryb3lgIG4nb250IGQnZWZmZXQgcXVlIHNpCiAgICAvLyBpbHMgc29udCBlZmZlY3R1w6lzIHBhciBsZSBwcm9wcmnDqXRhaXJlIHN0b2Nrw6kuCiAgICBmdW5jdGlvbiBkZXN0cm95KCkgcHVibGljIG9ubHlPd25lciB7CiAgICAgICAgc2VsZmRlc3RydWN0KG93bmVyKTsKICAgIH0KfQoKY29udHJhY3QgcHJpY2VkIHsKICAgIC8vIExlcyBtb2RpZmljYXRldXJzIHBldXZlbnQgcmVjZXZvaXIgZGVzIGFyZ3VtZW50cyA6CiAgICBtb2RpZmllciBjb3N0cyh1aW50IHByaWNlKSB7CiAgICAgICAgaWYgKG1zZy52YWx1ZSA+PSBwcmljZSkgewogICAgICAgICAgICBfOwogICAgICAgIH0KICAgIH0KfQoKY29udHJhY3QgUmVnaXN0ZXIgaXMgcHJpY2VkLCBkZXN0cnVjdGlibGUgewogICAgbWFwcGluZyAoYWRkcmVzcyA9PiBib29sKSByZWdpc3RlcmVkQWRkcmVzc2VzOwogICAgdWludCBwcmljZTsKCiAgICBjb25zdHJ1Y3Rvcih1aW50IGluaXRpYWxQcmljZSkgeyBwcmljZSA9IGluaXRpYWxQcmljZTsgfQoKICAgIC8vIElsIGVzdCBpbXBvcnRhbnQgZGUgZm91cm5pciDDqWdhbGVtZW50CiAgICAvLyBsZSBtb3QtY2zDqSBgcGF5YWJsZWAgaWNpLCBzaW5vbiBsYSBmb25jdGlvbgogICAgLy8gcmVqZXRlcmEgYXV0b21hdGlxdWVtZW50IHRvdXQgbCdFdGhlciBxdWkgbHVpIHNlcmEgZW52b3nDqS4KICAgIGZ1bmN0aW9uIHJlZ2lzdGVyKCkgcHVibGljIHBheWFibGUgY29zdHMocHJpY2UpIHsKICAgICAgICByZWdpc3RlcmVkQWRkcmVzc2VzW21zZy5zZW5kZXJdID0gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGFuZ2VQcmljZSh1aW50IF9wcmljZSkgcHVibGljIG9ubHlPd25lciB7CiAgICAgICAgcHJpY2UgPSBfcHJpY2U7CiAgICB9Cn0KCmNvbnRyYWN0IE11dGV4IHsKICAgIGJvb2wgbG9ja2VkOwogICAgbW9kaWZpZXIgbm9SZWVudHJhbmN5KCkgewogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgICFsb2NrZWQsCiAgICAgICAgICAgICJSZWVudHJhbnQgY2FsbC4iCiAgICAgICAgKTsKICAgICAgICBsb2NrZWQgPSB0cnVlOwogICAgICAgIF87CiAgICAgICAgbG9ja2VkID0gZmFsc2U7CiAgICB9CgogICAgLy8vIENldHRlIGZvbmN0aW9uIGVzdCBwcm90w6lnw6llIHBhciB1biBtdXRleCwgY2UgcXVpIHNpZ25pZmllIHF1ZQogICAgLy8vIGxlcyBhcHBlbHMgcsOpZW50cmFudHMgcHJvdmVuYW50IGRlIGBtc2cuc2VuZGVyLmNhbGxgIG5lIHBldXZlbnQgcGFzIGFwcGVsZXIgYGZgIMOgIG5vdXZlYXUuCiAgICAvLy8gTCdpbnN0cnVjdGlvbiBgcmV0dXJuIDdgIGF0dHJpYnVlIDcgw6AgbGEgdmFsZXVyIGRlIHJldG91ciBtYWlzCiAgICAvLy8gZXjDqWN1dGUgbCdpbnN0cnVjdGlvbiBgbG9ja2VkID0gZmFsc2VgIGRhbnMgbGUgbW9kaWZpY2F0ZXVyLgogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBub1JlZW50cmFuY3kgcmV0dXJucyAodWludCkgewogICAgICAgIChib29sIHN1Y2Nlc3MsKSA9IG1zZy5zZW5kZXIuY2FsbCgiIik7CiAgICAgICAgcmVxdWlyZShzdWNjZXNzKTsKICAgICAgICByZXR1cm4gNzsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.1 <0.9.0;
contract owned {
 constructor() { owner \= payable(msg.sender); }
 address payable owner;
 // Ce contrat définit uniquement un modificateur mais ne l'utilise pas.
 // mais ne l'utilise pas : il sera utilisé dans les contrats dérivés.
 // Le corps de la fonction est inséré là où apparaît le symbole spécial
 // \`\_;\` dans la définition d'un modificateur.
 // Cela signifie que si le propriétaire appelle cette fonction,
 // la fonction est exécutée et sinon, une exception est
 // levée.
 modifier onlyOwner {
 require(
 msg.sender \== owner,
 "Seul le propriétaire peut appeler cette fonction."
 );
 \_;
 }
}
contract destructible is owned {
 // Ce contrat hérite du modificateur \`onlyOwner\` de la fonction
 // \`owned\` et l'applique à la fonction \`destroy\`, qui
 // fait que les appels à \`destroy\` n'ont d'effet que si
 // ils sont effectués par le propriétaire stocké.
 function destroy() public onlyOwner {
 selfdestruct(owner);
 }
}
contract priced {
 // Les modificateurs peuvent recevoir des arguments :
 modifier costs(uint price) {
 if (msg.value \>= price) {
 \_;
 }
 }
}
contract Register is priced, destructible {
 mapping (address \=> bool) registeredAddresses;
 uint price;
 constructor(uint initialPrice) { price \= initialPrice; }
 // Il est important de fournir également
 // le mot-clé \`payable\` ici, sinon la fonction
 // rejetera automatiquement tout l'Ether qui lui sera envoyé.
 function register() public payable costs(price) {
 registeredAddresses\[msg.sender\] \= true;
 }
 function changePrice(uint \_price) public onlyOwner {
 price \= \_price;
 }
}
contract Mutex {
 bool locked;
 modifier noReentrancy() {
 require(
 !locked,
 "Reentrant call."
 );
 locked \= true;
 \_;
 locked \= false;
 }
 /// Cette fonction est protégée par un mutex, ce qui signifie que
 /// les appels réentrants provenant de \`msg.sender.call\` ne peuvent pas appeler \`f\` à nouveau.
 /// L'instruction \`return 7\` attribue 7 à la valeur de retour mais
 /// exécute l'instruction \`locked = false\` dans le modificateur.
 function f() public noReentrancy returns (uint) {
 (bool success,) \= msg.sender.call("");
 require(success);
 return 7;
 }
}
Si vous voulez accéder à un modificateur `m` défini dans un contrat `C`, vous pouvez utiliser `C.m` pour le le référencer sans recherche virtuelle. Il est seulement possible d’utiliser les modificateurs définis dans le contrat actuel ou ses contrats de base. Les modificateurs peuvent aussi être définis dans des bibliothèques, mais leur utilisation est limitée aux fonctions de la même bibliothèque.
Plusieurs modificateurs sont appliqués à une fonction en les spécifiant dans une séparée par des espaces et sont évaluées dans l’ordre présenté.
Les modificateurs ne peuvent pas accéder ou modifier implicitement les arguments et les valeurs de retour des fonctions qu’ils modifient. Leurs valeurs ne peuvent leur être transmises que de manière explicite au moment de l’invocation.
Les retours explicites d’un modificateur ou d’un corps de fonction ne quittent que le modificateur ou du corps de la fonction actuelle. Les variables de retour sont assignées et le flux de contrôle continue après le `_` du modificateur précédent.
Avertissement
Dans une version antérieure de Solidity, les instructions `return` dans les fonctions ayant des modificateurs se comportaient différemment.
Un retour explicite d’un modificateur avec `return;` n’affecte pas les valeurs retournées par la fonction. Le modificateur peut toutefois choisir de ne pas exécuter du tout le corps de la fonction et, dans ce cas, les variables `return` sont placées à leur valeur par défaut comme si la fonction avait un corps vide.
Le symbole `_` peut apparaître plusieurs fois dans le modificateur. Chaque occurrence est remplacée par le corps de la fonction.
Les expressions arbitraires sont autorisées pour les arguments du modificateur et dans ce contexte, tous les symboles visibles de la fonction sont visibles dans le modificateur. Les symboles introduits dans le modificateur ne sont pas visibles dans la fonction (car ils pourraient être modifiés par la surcharge).
## Variables d’état constantes et immuables[](#variables-d-etat-constantes-et-immuables "Lien permanent vers cette rubrique")
Les variables d’état peuvent être déclarées comme `constant` ou `immutable`. Dans les deux cas, les variables ne peuvent pas être modifiées après la construction du contrat. Pour les variables `constant`, la valeur doit être fixée à la compilation, alors que pour les variables `immutables`, elle peut encore être assignée au moment de la construction.
Il est également possible de définir des variables `constant` au niveau du fichier.
Le compilateur ne réserve pas d’emplacement pour ces variables, et chaque occurrence est remplacée par la valeur correspondante.
Comparé aux variables d’état régulières, les coûts de gaz des variables constantes et immuables sont beaucoup plus faibles. Pour une variable constante, l’expression qui lui est assignée est copiée à tous les endroits où elle est accédée et est également réévaluée à chaque fois. Cela permet des optimisations locales. Les variables immuables sont évaluées une seule fois au moment de la construction et leur valeur est copiée à tous les endroits du code où elles sont accédées. Pour ces valeurs, 32 octets sont réservés, même si elles pourraient tenir dans moins d’octets. Pour cette raison, les valeurs constantes peuvent parfois être moins chères que les valeurs immuables.
Tous les types de constantes et d’immuables ne sont pas encore implémentés. Les seuls types supportés sont [strings](https://docs.soliditylang.org/fr/latest/types.html#strings) (uniquement pour les constantes) et [value types](https://docs.soliditylang.org/fr/latest/types.html#value-types).
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjQ7Cgp1aW50IGNvbnN0YW50IFggPSAzMioqMjIgKyA4OwoKY29udHJhY3QgQyB7CiAgICBzdHJpbmcgY29uc3RhbnQgVEVYVCA9ICJhYmMiOwogICAgYnl0ZXMzMiBjb25zdGFudCBNWV9IQVNIID0ga2VjY2FrMjU2KCJhYmMiKTsKICAgIHVpbnQgaW1tdXRhYmxlIGRlY2ltYWxzOwogICAgdWludCBpbW11dGFibGUgbWF4QmFsYW5jZTsKICAgIGFkZHJlc3MgaW1tdXRhYmxlIG93bmVyID0gbXNnLnNlbmRlcjsKCiAgICBjb25zdHJ1Y3Rvcih1aW50IF9kZWNpbWFscywgYWRkcmVzcyBfcmVmZXJlbmNlKSB7CiAgICAgICAgZGVjaW1hbHMgPSBfZGVjaW1hbHM7CiAgICAgICAgLy8gTGVzIGFmZmVjdGF0aW9ucyBhdXggaW1tdWFibGVzIHBldXZlbnQgbcOqbWUgYWNjw6lkZXIgw6AgbCdlbnZpcm9ubmVtZW50LgogICAgICAgIG1heEJhbGFuY2UgPSBfcmVmZXJlbmNlLmJhbGFuY2U7CiAgICB9CgogICAgZnVuY3Rpb24gaXNCYWxhbmNlVG9vSGlnaChhZGRyZXNzIF9vdGhlcikgcHVibGljIHZpZXcgcmV0dXJucyAoYm9vbCkgewogICAgICAgIHJldHVybiBfb3RoZXIuYmFsYW5jZSA+IG1heEJhbGFuY2U7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.4;
uint constant X \= 32\*\*22 + 8;
contract C {
 string constant TEXT \= "abc";
 bytes32 constant MY\_HASH \= keccak256("abc");
 uint immutable decimals;
 uint immutable maxBalance;
 address immutable owner \= msg.sender;
 constructor(uint \_decimals, address \_reference) {
 decimals \= \_decimals;
 // Les affectations aux immuables peuvent même accéder à l'environnement.
 maxBalance \= \_reference.balance;
 }
 function isBalanceTooHigh(address \_other) public view returns (bool) {
 return \_other.balance \> maxBalance;
 }
}
### Constant[](#constant "Lien permanent vers cette rubrique")
Pour les variables `constant`, la valeur doit être une constante au moment de la compilation et elle doit être assignée à l’endroit où la variable est déclarée. Toute expression qui accède au stockage, aux données de la blockchain (par exemple, `block.timestamp`, `address(this).balance` ou `block.number`) ou aux données d’exécution (`msg.value` ou `gasleft()`) ou fait des appels à des contrats externes est interdit. Les expressions qui pourraient avoir un effet secondaire sur l’allocation de mémoire sont autorisées, mais celles qui pourraient avoir un effet secondaire sur d’autres objets mémoire ne le sont pas. Les fonctions intégrées `keccak256`, `sha256`, `ripemd160`, `ecrecover`, ```addmod`' et ``mulmod```. sont autorisées (même si, à l’exception de `keccak256`, ils appellent des contrats externes).
La raison pour laquelle les effets secondaires sur l’allocateur de mémoire sont autorisés est qu’il devrait être possible de construire des objets complexes comme par exemple des tables de consultation. Cette fonctionnalité n’est pas encore totalement utilisable.
### Immutable[](#immutable "Lien permanent vers cette rubrique")
Les variables déclarées comme `immutables` sont un peu moins restreintes que celles déclarées comme `constant` : Les variables immuables peuvent se voir attribuer une valeur arbitraire dans le constructeur du contrat ou au moment de leur déclaration. Elles ne peuvent être assignées qu’une seule fois et peuvent, à partir de ce moment, être lues même pendant la construction.
Le code de création du contrat généré par le compilateur modifiera le code d’exécution du contrat avant qu’il ne soit retourné en remplaçant toutes les références aux immutables par les valeurs qui leur sont attribuées. Ceci est important si vous comparez le code d’exécution généré par le compilateur avec celui réellement stocké dans la blockchain.
Note
Les immutables qui sont affectés lors de leur déclaration ne sont considérés comme initialisés que lorsque le constructeur du contrat s’exécute. Cela signifie que vous ne pouvez pas initialiser les immutables en ligne avec une valeur qui dépend d’un autre immuable. Vous pouvez cependant le faire à l’intérieur du constructeur du contrat.
Il s’agit d’une protection contre les différentes interprétations concernant l’ordre de l’initialisation des variables d’état et de l’exécution du constructeur, en particulier en ce qui concerne l’héritage.
## Fonctions[](#fonctions "Lien permanent vers cette rubrique")
Les fonctions peuvent être définies à l’intérieur et à l’extérieur des contrats.
Les fonctions hors contrat, aussi appelées « fonctions libres », ont toujours une valeur implicite `internal`. [visibilité](#visibility-and-getters) implicite. Leur code est inclus dans tous les contrats qui les appellent, comme pour les fonctions internes des bibliothèques.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKZnVuY3Rpb24gc3VtKHVpbnRbXSBtZW1vcnkgX2FycikgcHVyZSByZXR1cm5zICh1aW50IHMpIHsKICAgIGZvciAodWludCBpID0gMDsgaSA8IF9hcnIubGVuZ3RoOyBpKyspCiAgICAgICAgcyArPSBfYXJyW2ldOwp9Cgpjb250cmFjdCBBcnJheUV4YW1wbGUgewogICAgYm9vbCBmb3VuZDsKICAgIGZ1bmN0aW9uIGYodWludFtdIG1lbW9yeSBfYXJyKSBwdWJsaWMgewogICAgICAgIC8vIENlbGEgYXBwZWxsZSBsYSBmb25jdGlvbiBmcmVlIGVuIGludGVybmUuCiAgICAgICAgLy8gTGUgY29tcGlsYXRldXIgYWpvdXRlcmEgc29uIGNvZGUgYXUgY29udHJhdC4KICAgICAgICB1aW50IHMgPSBzdW0oX2Fycik7CiAgICAgICAgcmVxdWlyZShzID49IDEwKTsKICAgICAgICBmb3VuZCA9IHRydWU7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.1 <0.9.0;
function sum(uint\[\] memory \_arr) pure returns (uint s) {
 for (uint i \= 0; i < \_arr.length; i++)
 s += \_arr\[i\];
}
contract ArrayExample {
 bool found;
 function f(uint\[\] memory \_arr) public {
 // Cela appelle la fonction free en interne.
 // Le compilateur ajoutera son code au contrat.
 uint s \= sum(\_arr);
 require(s \>= 10);
 found \= true;
 }
}
Note
Les fonctions définies en dehors d’un contrat sont toujours exécutées dans le contexte d’un contrat. Elles ont toujours accès à la variable `this`, peuvent appeler d’autres contrats, leur envoyer de l’Ether et détruire le contrat qui les a appelées, entre autres choses. La principale différence avec les fonctions définies à l’intérieur d’un contrat est que les fonctions libres n’ont pas d’accès direct aux variables de stockage et aux fonctions qui ne sont pas dans leur portée.
### Paramètres des fonctions et variables de retour[](#parametres-des-fonctions-et-variables-de-retour "Lien permanent vers cette rubrique")
Les fonctions prennent des paramètres typés en entrée et peuvent, contrairement à beaucoup d’autres langages, renvoyer un nombre arbitraire de valeurs en sortie.
#### Paramètres des fonctions[](#parametres-des-fonctions "Lien permanent vers cette rubrique")
Les paramètres de fonction sont déclarés de la même manière que les variables, et le nom des paramètres non utilisés peuvent être omis.
Par exemple, si vous voulez que votre contrat accepte un type d’appel externe avec deux entiers, vous utiliserez quelque chose comme ce qui suit :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICB1aW50IHN1bTsKICAgIGZ1bmN0aW9uIHRha2VyKHVpbnQgX2EsIHVpbnQgX2IpIHB1YmxpYyB7CiAgICAgICAgc3VtID0gX2EgKyBfYjsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract Simple {
 uint sum;
 function taker(uint \_a, uint \_b) public {
 sum \= \_a + \_b;
 }
}
Les paramètres de fonction peuvent être utilisés comme n’importe quelle autre variable locale et ils peuvent également être affectés.
Note
Une [fonction externe](https://docs.soliditylang.org/fr/latest/control-structures.html#external-function-calls) ne peut pas accepter un tableau multidimensionnel comme paramètre d’entrée. Cette fonctionnalité est possible si vous activez le codeur ABI v2 en ajoutant `pragma abicoder v2;` à votre fichier source.
Une [fonction interne](https://docs.soliditylang.org/fr/latest/control-structures.html#external-function-calls) peut accepter un tableau multidimensionnel sans activer la fonction.
#### Variables de retour[](#variables-de-retour "Lien permanent vers cette rubrique")
Les variables de retour de fonction sont déclarées avec la même syntaxe après le mot-clé `returns`.
Par exemple, supposons que vous vouliez renvoyer deux résultats : la somme et le produit de deux entiers passés comme paramètres de la fonction, vous utiliserez quelque chose comme :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICBmdW5jdGlvbiBhcml0aG1ldGljKHVpbnQgX2EsIHVpbnQgX2IpCiAgICAgICAgcHVibGljCiAgICAgICAgcHVyZQogICAgICAgIHJldHVybnMgKHVpbnQgb19zdW0sIHVpbnQgb19wcm9kdWN0KQogICAgewogICAgICAgIG9fc3VtID0gX2EgKyBfYjsKICAgICAgICBvX3Byb2R1Y3QgPSBfYSAqIF9iOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract Simple {
 function arithmetic(uint \_a, uint \_b)
 public
 pure
 returns (uint o\_sum, uint o\_product)
 {
 o\_sum \= \_a + \_b;
 o\_product \= \_a \* \_b;
 }
}
Les noms des variables de retour peuvent être omis. Les variables de retour peuvent être utilisées comme toute autre variable locales et sont initialisées avec leur [valeur par défaut](https://docs.soliditylang.org/fr/latest/control-structures.html#default-value) et ont cette valeur jusqu’à ce qu’elles soient (ré)assignées.
Vous pouvez soit assigner explicitement aux variables de retour et ensuite laisser la fonction comme ci-dessus, ou vous pouvez fournir des valeurs de retour (soit une seule, soit [multiple ones](#multi-return)) directement avec l’instruction `return`.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICBmdW5jdGlvbiBhcml0aG1ldGljKHVpbnQgX2EsIHVpbnQgX2IpCiAgICAgICAgcHVibGljCiAgICAgICAgcHVyZQogICAgICAgIHJldHVybnMgKHVpbnQgb19zdW0sIHVpbnQgb19wcm9kdWN0KQogICAgewogICAgICAgIHJldHVybiAoX2EgKyBfYiwgX2EgKiBfYik7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract Simple {
 function arithmetic(uint \_a, uint \_b)
 public
 pure
 returns (uint o\_sum, uint o\_product)
 {
 return (\_a + \_b, \_a \* \_b);
 }
}
Si vous utilisez un `return` précoce pour quitter une fonction qui a des variables de retour, vous devez fournir des valeurs de retour avec l’instruction return.
Note
Vous ne pouvez pas retourner certains types à partir de fonctions non internes, notamment les tableaux dynamiques multidimensionnels et les structs. Si vous activez le ABI coder v2 en ajoutant `pragma abicoder v2;` à votre fichier source, alors plus de types sont disponibles, mais les types `mapping` sont toujours limités à l’intérieur d’un seul contrat et vous ne pouvez pas les transférer.
#### Renvoi de valeurs multiples[](#renvoi-de-valeurs-multiples "Lien permanent vers cette rubrique")
Lorsqu’une fonction possède plusieurs types de retour, l’instruction `return (v0, v1, ..., vn)` peut être utilisée pour retourner plusieurs valeurs. Le nombre de composants doit être le même que le nombre de variables de retour et leurs types doivent correspondre, éventuellement après une conversion [implicite](https://docs.soliditylang.org/fr/latest/types.html#types-conversion-elementary-types).
### Mutabilité de l’État[](#mutabilite-de-l-etat "Lien permanent vers cette rubrique")
#### Voir les fonctions[](#voir-les-fonctions "Lien permanent vers cette rubrique")
Les fonctions peuvent être déclarées `vues`, auquel cas elles promettent de ne pas modifier l’état.
Note
Si la cible EVM du compilateur est Byzantium ou plus récente (par défaut), l’opcode `STATICCALL` est utilisé lorsque les fonctions `view` sont appelées, ce qui impose à l’état de rester non modifié dans le cadre de l’exécution de l’EVM. Pour les fonctions de bibliothèque `view`, `DELEGATECALL` est utilisé, car il n’existe pas de combinaison de `DELEGATECALL` et de `STATICCALL`. Cela signifie que les fonctions de la bibliothèque `view` n’ont pas de contrôles d’exécution qui empêchent les états. Ceci ne devrait pas avoir d’impact négatif sur la sécurité car le code de la bibliothèque est généralement connu au moment de la compilation et le vérificateur statique effectue des vérifications au moment de la compilation.
Les instructions suivantes sont considérées comme modifiant l’état :
1. Écriture dans les variables d’état
 
2. [Émettre des événements](#events)
 
3. [Créer d’autres contrats](https://docs.soliditylang.org/fr/latest/control-structures.html#creating-contracts)
 
4. Utiliser `selfdestruct`
 
5. Envoyer de l’Ether via des appels
 
6. Appeler une fonction qui n’est pas marquée `view` ou `pure`
 
7. Utiliser des appels de bas niveau
 
8. Utilisation d’un assemblage en ligne contenant certains opcodes
 
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgKiAoYiArIDQyKSArIGJsb2NrLnRpbWVzdGFtcDsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
contract C {
 function f(uint a, uint b) public view returns (uint) {
 return a \* (b + 42) + block.timestamp;
 }
}
Note
`constant` sur les fonctions était un alias de `view`, mais cela a été abandonné dans la version 0.5.0.
Note
Les méthodes Getter sont automatiquement marquées `view`.
Note
Avant la version 0.5.0, le compilateur n’utilisait pas l’opcode `STATICCALL` pour les fonctions `view`. Cela permettait des modifications d’état dans les fonctions `view` par l’utilisation de conversions de types explicites invalides. En utilisant `STATICCALL` pour les fonctions `view`, les modifications de l’état sont empêchées au niveau de l’EVM.
#### Fonctions pures[](#fonctions-pures "Lien permanent vers cette rubrique")
Les fonctions peuvent être déclarées `pure`, auquel cas elles promettent de ne pas lire ou modifier l’état. En particulier, il devrait être possible d’évaluer une fonction `pure` à la compilation seulement ses entrées et `msg.data`, mais sans aucune connaissance de l’état actuel de la blockchain. Cela signifie que la lecture de variables `immutable` peut être une opération non pure.
Note
Si la cible EVM du compilateur est Byzantium ou plus récente (par défaut), l’opcode `STATICCALL` est utilisé, ce qui ne garantit pas que l’état ne soit pas lu, mais au moins qu’il ne soit pas modifié.
En plus de la liste des instructions modifiant l’état expliquée ci-dessus, les suivantes sont considérées comme lisant l’état :
1. Lecture des variables d’état
 
2. Accès à `adresse(this).balance` ou `<adresse>.balance`
 
3. Accéder à l’un des membres de `block`, `tx`, `msg` (à l’exception de `msg.sig` et `msg.data`)
 
4. L’appel de toute fonction non marquée `pure`
 
5. L’utilisation d’un assemblage en ligne qui contient certains opcodes
 
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgKiAoYiArIDQyKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
contract C {
 function f(uint a, uint b) public pure returns (uint) {
 return a \* (b + 42);
 }
}
Les fonctions pures sont en mesure d’utiliser les fonctions `revert()` et `require()` pour revenir sur des changements d’état potentiels lorsqu’une [erreur se produit](https://docs.soliditylang.org/fr/latest/control-structures.html#assert-and-require).
Revenir en arrière sur un changement d’état n’est pas considéré comme une « modification d’état », car seuls les changements d’état effectuées précédemment dans du code qui n’avait pas la restriction `view` ou `pure` sont inversées et ce code a la possibilité d’attraper le `revert` et de ne pas le transmettre.
Ce comportement est également en accord avec l’opcode `STATICCALL`.
Avertissement
Il est impossible d’empêcher les fonctions de lire l’état au niveau de l’EVM, il est seulement possible de les empêcher d’écrire dans l’état (c’est-à-dire que seul `view` peut être imposé au niveau de l’EVM, `pure` ne peut pas).
Note
Avant la version 0.5.0, le compilateur n’utilisait pas l’opcode `STATICCALL` pour les programmes `pure`. Ceci permettait des modifications d’état dans les fonctions `pures` par l’utilisation de conversions de types explicites invalides. En utilisant `STATICCALL` pour les fonctions `pures`, les modifications de l’état sont empêchées au niveau de l’EVM.
Note
Avant la version 0.4.17, le compilateur n’imposait pas que `pure` ne lise pas l’état. C’est un contrôle de type à la compilation, qui peut être contourné en faisant des conversions explicites invalides entre les types de contrat, car le compilateur peut vérifier que le type du contrat ne fait pas d’opérations de changement d’état, mais il ne peut pas vérifier que le contrat qui sera appelé au moment de l’exécution est effectivement de ce type.
### Fonctions spéciales[](#fonctions-speciales "Lien permanent vers cette rubrique")
#### Fonction de réception d’Ether[](#fonction-de-reception-d-ether "Lien permanent vers cette rubrique")
Un contrat peut avoir au maximum une fonction `receive`, déclarée à l’aide des éléments suivants `receive() external payable { ... }` (sans le mot-clé `function`). Cette fonction ne peut pas avoir d’arguments, ne peut rien retourner et doit avoir une une visibilité `external` et une mutabilité de l’état `payable`. Elle peut être virtuelle, peut être surchargée et peut avoir des modificateurs.
La fonction de réception est exécutée lors d’un appel au contrat avec des données d’appel vides. C’est la fonction qui est exécutée lors des transferts d’Ether (par exemple via `.send()` ou `.transfer()`). Si cette fonction n’existe pas, mais qu’une fonction payable [de repli](#fallback-function) existe, la fonction de repli sera appelée lors d’un transfert d’Ether simple. Si aucune fonction de réception d’Ether ni aucune fonction de repli payable n’est présente, le contrat ne peut pas recevoir d’Ether par le biais de transactions normales et lance une exception.
Dans le pire des cas, la fonction `receive` ne peut compter que sur le fait que 2300 gaz soient disponible (par exemple lorsque `send` ou `transfer` est utilisé), ce qui laisse peu de place pour effectuer d’autres opérations que la journalisation de base. Les opérations suivantes consommeront plus de gaz que l’allocation de 2300 gaz :
* Écriture dans le stockage
 
* Création d’un contrat
 
* Appeler une fonction externe qui consomme une grande quantité de gaz
 
* Envoi d’éther
 
Avertissement
Les contrats qui reçoivent de l’Ether directement (sans appel de fonction, c’est-à-dire en utilisant `send` ou `transfer`) mais qui ne définissent pas de fonction de réception d’Ether ou de fonction de repli payable, lancer une exception en renvoyant l’Ether (ceci était différent avant Solidity v0.4.0). Donc si vous voulez que votre contrat reçoive de l’Ether, vous devez implémenter une fonction de réception d’Ether (l’utilisation de fonctions de repli payantes pour recevoir de l’éther n’est pas recommandée, car elle n’échouerait pas en cas de confusion d’interface).
Avertissement
Un contrat sans fonction de réception d’Ether peut recevoir de l’Ether en tant que destinataire d’une transaction _coinbase_ (c.à.d _récompense de bloc miner_) ou en tant que destination d’une `selfdestruct`.
Un contrat ne peut pas réagir à de tels transferts d’Ether et ne peut donc pas les rejeter. Il s’agit d’un choix de conception de l’EVM, Solidity ne peut pas le contourner.
Cela signifie également que `address(this).balance` peut être plus élevé que la somme d’une comptabilité manuelle implémentée dans un contrat (par exemple, en ayant un compteur mis à jour dans la fonction de réception d’Ether).
Ci-dessous vous pouvez voir un exemple d’un contrat Sink qui utilise la fonction `receive`.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKLy8gQ2UgY29udHJhdCBnYXJkZSB0b3V0IGwnRXRoZXIgcXVpIGx1aSBlc3QgZW52b3nDqSBzYW5zIGF1Y3VuIG1veWVuCi8vIGRlIGxlIHLDqWN1cMOpcmVyLgpjb250cmFjdCBTaW5rIHsKICAgIGV2ZW50IFJlY2VpdmVkKGFkZHJlc3MsIHVpbnQpOwogICAgcmVjZWl2ZSgpIGV4dGVybmFsIHBheWFibGUgewogICAgICAgIGVtaXQgUmVjZWl2ZWQobXNnLnNlbmRlciwgbXNnLnZhbHVlKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
// Ce contrat garde tout l'Ether qui lui est envoyé sans aucun moyen
// de le récupérer.
contract Sink {
 event Received(address, uint);
 receive() external payable {
 emit Received(msg.sender, msg.value);
 }
}
#### Fonction de repli[](#fonction-de-repli "Lien permanent vers cette rubrique")
Un contrat peut avoir au maximum une fonction `fallback`, déclarée en utilisant soit `fallback () external [payable]`, soit `fallback (bytes calldata _input) external [payable] returns (bytes memory _output)` (dans les deux cas sans le mot-clé `function`). Cette fonction doit avoir une visibilité `external`. Une fonction de repli peut être virtuelle, peut remplacer et peut avoir des modificateurs.
La fonction de repli est exécutée lors d’un appel au contrat si aucune des autres fonction ne correspond à la signature de la fonction donnée, ou si aucune donnée n’est fournie et qu’il n’existe pas de [fonction de réception d’éther](#receive-ether-function). La fonction de repli reçoit toujours des données, mais pour recevoir également de l’Ether elle doit être marquée `payable`.
Si la version avec paramètres est utilisée, `_input` contiendra les données complètes envoyées au contrat (égal à `msg.data`) et peut retourner des données dans `_output`. Les données retournées ne seront pas codées par l’ABI. Au lieu de cela, elles seront retournées sans modifications (même pas de remplissage).
Dans le pire des cas, si une fonction de repli payable est également utilisée à la place d’une fonction de réception, elle ne peut compter que sur le gaz 2300 disponible (voir [fonction de réception d’éther](#receive-ether-function) pour une brève description des implications de ceci).
Comme toute fonction, la fonction de repli peut exécuter des opérations complexes tant qu’il y a suffisamment de gaz qui lui est transmis.
Avertissement
Une fonction de repli `payable` est également exécutée pour les transferts d’Ether simples, si aucune fonction de réception d’Ether n’est présente. Il est recommandé de toujours définir une fonction de réception Ether de réception, si vous définissez une fonction de repli payable afin de distinguer les transferts Ether des confusions d’interface.
Note
Si vous voulez décoder les données d’entrée, vous pouvez vérifier les quatre premiers octets pour le sélecteur de fonction et ensuite vous pouvez utiliser `abi.decode` avec la syntaxe array slice pour décoder les données codées par ABI : `(c, d) = abi.decode(_input[4 :], (uint256, uint256));` Notez que cette méthode ne doit être utilisée qu’en dernier recours, et que les fonctions appropriées doivent être utilisées à la place.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKY29udHJhY3QgVGVzdCB7CiAgICB1aW50IHg7CiAgICAvLyBDZXR0ZSBmb25jdGlvbiBlc3QgYXBwZWzDqWUgcG91ciB0b3VzIGxlcyBtZXNzYWdlcyBlbnZvecOpcyDDoAogICAgLy8gY2UgY29udHJhdCAoaWwgbid5IGEgcGFzIGQnYXV0cmUgZm9uY3Rpb24pLgogICAgLy8gTCdlbnZvaSBkJ0V0aGVyIMOgIGNlIGNvbnRyYXQgcHJvdm9xdWVyYSB1bmUgZXhjZXB0aW9uLAogICAgLy8gY2FyIGxhIGZvbmN0aW9uIGRlIHJlcGxpIG4nYSBwYXMgbGUgbW9kaWZpY2F0ZXVyIGBwYXlhYmxlYC4KICAgIGZhbGxiYWNrKCkgZXh0ZXJuYWwgeyB4ID0gMTsgfQp9Cgpjb250cmFjdCBUZXN0UGF5YWJsZSB7CiAgICB1aW50IHg7CiAgICB1aW50IHk7CiAgICAvLyBDZXR0ZSBmb25jdGlvbiBlc3QgYXBwZWzDqWUgcG91ciB0b3VzIGxlcyBtZXNzYWdlcyBlbnZvecOpcyDDoAogICAgLy8gY2UgY29udHJhdCwgc2F1ZiBsZXMgdHJhbnNmZXJ0cyBFdGhlciBzaW1wbGVzCiAgICAvLyAoaWwgbid5IGEgcGFzIGQnYXV0cmUgZm9uY3Rpb24gcXVlIGxhIGZvbmN0aW9uIGRlIHLDqWNlcHRpb24pLgogICAgLy8gVG91dCBhcHBlbCDDoCBjZSBjb250cmF0IGF2ZWMgZGVzIGNhbGxkYXRhIG5vbiB2aWRlcyBleMOpY3V0ZXJhCiAgICAvLyBsYSBmb25jdGlvbiBkZSByZXBsaSAobcOqbWUgc2kgRXRoZXIgZXN0IGVudm95w6kgYXZlYyBsJ2FwcGVsKS4KICAgIGZhbGxiYWNrKCkgZXh0ZXJuYWwgcGF5YWJsZSB7IHggPSAxOyB5ID0gbXNnLnZhbHVlOyB9CgogICAgLy8gQ2V0dGUgZm9uY3Rpb24gZXN0IGFwcGVsw6llIHBvdXIgbGVzIHRyYW5zZmVydHMgRXRoZXIgc2ltcGxlcywgYydlc3Qgw6AgZGlyZQogICAgLy8gcG91ciBjaGFxdWUgYXBwZWwgYXZlYyBkZXMgZG9ubsOpZXMgZCdhcHBlbCB2aWRlcy4KICAgIHJlY2VpdmUoKSBleHRlcm5hbCBwYXlhYmxlIHsgeCA9IDI7IHkgPSBtc2cudmFsdWU7IH0KfQoKY29udHJhY3QgQ2FsbGVyIHsKICAgIGZ1bmN0aW9uIGNhbGxUZXN0KFRlc3QgdGVzdCkgcHVibGljIHJldHVybnMgKGJvb2wpIHsKICAgICAgICAoYm9vbCBzdWNjZXNzLCkgPSBhZGRyZXNzKHRlc3QpLmNhbGwoYWJpLmVuY29kZVdpdGhTaWduYXR1cmUoIm5vbkV4aXN0aW5nRnVuY3Rpb24oKSIpKTsKICAgICAgICByZXF1aXJlKHN1Y2Nlc3MpOwogICAgICAgIC8vIGlsIGVuIHLDqXN1bHRlIHF1ZSB0ZXN0LnggZGV2aWVudCA9PSAxLgoKICAgICAgICAvLyBhZGRyZXNzKHRlc3QpIG5lIHBlcm1ldHRyYSBwYXMgZCdhcHBlbGVyIGRpcmVjdGVtZW50IGBgc2VuZGBgLCBwdWlzcXVlIGBgdGVzdGBgIG4nYSBwYXMgZGUgcGF5YWJsZQogICAgICAgIC8vIGZvbmN0aW9uIGRlIHJlcGxpLgogICAgICAgIC8vIElsIGRvaXQgw6p0cmUgY29udmVydGkgZW4gYWRyZXNzZSBwYXlhYmxlIHBvdXIgcG91dm9pciBhcHBlbGVyIGBgc2VuZGBgLgogICAgICAgIGFkZHJlc3MgcGF5YWJsZSB0ZXN0UGF5YWJsZSA9IHBheWFibGUoYWRkcmVzcyh0ZXN0KSk7CgogICAgICAgIC8vIFNpIHF1ZWxxdSd1biBlbnZvaWUgZGUgbCdFdGhlciDDoCBjZSBjb250cmF0LAogICAgICAgIC8vIGxlIHRyYW5zZmVydCDDqWNob3VlcmEsIGMnZXN0IMOgIGRpcmUgcXVlIGNlbGEgcmVudm9pZSBmYWxzZSBpY2kuCiAgICAgICAgcmV0dXJuIHRlc3RQYXlhYmxlLnNlbmQoMiBldGhlcik7CiAgICB9CgogICAgZnVuY3Rpb24gY2FsbFRlc3RQYXlhYmxlKFRlc3RQYXlhYmxlIHRlc3QpIHB1YmxpYyByZXR1cm5zIChib29sKSB7CiAgICAgICAgKGJvb2wgc3VjY2VzcywpID0gYWRkcmVzcyh0ZXN0KS5jYWxsKGFiaS5lbmNvZGVXaXRoU2lnbmF0dXJlKCJub25FeGlzdGluZ0Z1bmN0aW9uKCkiKSk7CiAgICAgICAgcmVxdWlyZShzdWNjZXNzKTsKICAgICAgICAvLyBsZSByw6lzdWx0YXQgZXN0IHF1ZSB0ZXN0LnggZGV2aWVudCA9PSAxIGV0IHRlc3QueSBkZXZpZW50IDAuCiAgICAgICAgKHN1Y2Nlc3MsKSA9IGFkZHJlc3ModGVzdCkuY2FsbHt2YWx1ZTogMX0oYWJpLmVuY29kZVdpdGhTaWduYXR1cmUoIm5vbkV4aXN0aW5nRnVuY3Rpb24oKSIpKTsKICAgICAgICByZXF1aXJlKHN1Y2Nlc3MpOwogICAgICAgIC8vIGxlIHLDqXN1bHRhdCBlc3QgcXVlIHRlc3QueCBkZXZpZW50ID09IDEgZXQgdGVzdC55IGRldmllbnQgMS4KCiAgICAgICAgLy8gU2kgcXVlbHF1J3VuIGVudm9pZSBkZSBsJ0V0aGVyIMOgIGNlIGNvbnRyYXQsIGxhIGZvbmN0aW9uIGRlIHLDqWNlcHRpb24gZGUgVGVzdFBheWFibGUgc2VyYSBhcHBlbMOpZS4KICAgICAgICAvLyBDb21tZSBjZXR0ZSBmb25jdGlvbiDDqWNyaXQgZGFucyBsZSBzdG9ja2FnZSwgZWxsZSBwcmVuZCBwbHVzIGQnw6l0aGVyIHF1ZSBjZSBxdWkgZXN0IGRpc3BvbmlibGUgYXZlYyB1bgogICAgICAgIC8vIHNpbXBsZSBgYHNlbmRgYCBvdSBgYHRyYW5zZmVyYGAuIFBvdXIgY2V0dGUgcmFpc29uLCBub3VzIGRldm9ucyB1dGlsaXNlciB1biBhcHBlbCBkZSBiYXMgbml2ZWF1LgogICAgICAgIChzdWNjZXNzLCkgPSBhZGRyZXNzKHRlc3QpLmNhbGx7dmFsdWU6IDIgZXRoZXJ9KCIiKTsKICAgICAgICByZXF1aXJlKHN1Y2Nlc3MpOwogICAgICAgIC8vIGxlIHLDqXN1bHRhdCBlc3QgcXVlIHRlc3QueCBkZXZpZW50ID09IDIgZXQgdGVzdC55IGRldmllbnQgMiBldGhlci4KCiAgICAgICAgcmV0dXJuIHRydWU7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.2 <0.9.0;
contract Test {
 uint x;
 // Cette fonction est appelée pour tous les messages envoyés à
 // ce contrat (il n'y a pas d'autre fonction).
 // L'envoi d'Ether à ce contrat provoquera une exception,
 // car la fonction de repli n'a pas le modificateur \`payable\`.
 fallback() external { x \= 1; }
}
contract TestPayable {
 uint x;
 uint y;
 // Cette fonction est appelée pour tous les messages envoyés à
 // ce contrat, sauf les transferts Ether simples
 // (il n'y a pas d'autre fonction que la fonction de réception).
 // Tout appel à ce contrat avec des calldata non vides exécutera
 // la fonction de repli (même si Ether est envoyé avec l'appel).
 fallback() external payable { x \= 1; y \= msg.value; }
 // Cette fonction est appelée pour les transferts Ether simples, c'est à dire
 // pour chaque appel avec des données d'appel vides.
 receive() external payable { x \= 2; y \= msg.value; }
}
contract Caller {
 function callTest(Test test) public returns (bool) {
 (bool success,) \= address(test).call(abi.encodeWithSignature("nonExistingFunction()"));
 require(success);
 // il en résulte que test.x devient == 1.
 // address(test) ne permettra pas d'appeler directement \`\`send\`\`, puisque \`\`test\`\` n'a pas de payable
 // fonction de repli.
 // Il doit être converti en adresse payable pour pouvoir appeler \`\`send\`\`.
 address payable testPayable \= payable(address(test));
 // Si quelqu'un envoie de l'Ether à ce contrat,
 // le transfert échouera, c'est à dire que cela renvoie false ici.
 return testPayable.send(2 ether);
 }
 function callTestPayable(TestPayable test) public returns (bool) {
 (bool success,) \= address(test).call(abi.encodeWithSignature("nonExistingFunction()"));
 require(success);
 // le résultat est que test.x devient == 1 et test.y devient 0.
 (success,) \= address(test).call{value: 1}(abi.encodeWithSignature("nonExistingFunction()"));
 require(success);
 // le résultat est que test.x devient == 1 et test.y devient 1.
 // Si quelqu'un envoie de l'Ether à ce contrat, la fonction de réception de TestPayable sera appelée.
 // Comme cette fonction écrit dans le stockage, elle prend plus d'éther que ce qui est disponible avec un
 // simple \`\`send\`\` ou \`\`transfer\`\`. Pour cette raison, nous devons utiliser un appel de bas niveau.
 (success,) \= address(test).call{value: 2 ether}("");
 require(success);
 // le résultat est que test.x devient == 2 et test.y devient 2 ether.
 return true;
 }
}
### Surcharge des fonctions[](#surcharge-des-fonctions "Lien permanent vers cette rubrique")
Un contrat peut avoir plusieurs fonctions du même nom mais avec des types de paramètres différents. Ce processus est appelé « surcharge » et s’applique également aux fonctions héritées. L’exemple suivant montre la surcharge de la fonction `f` dans la portée du contrat `A`.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEEgewogICAgZnVuY3Rpb24gZih1aW50IF9pbikgcHVibGljIHB1cmUgcmV0dXJucyAodWludCBvdXQpIHsKICAgICAgICBvdXQgPSBfaW47CiAgICB9CgogICAgZnVuY3Rpb24gZih1aW50IF9pbiwgYm9vbCBfcmVhbGx5KSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IG91dCkgewogICAgICAgIGlmIChfcmVhbGx5KQogICAgICAgICAgICBvdXQgPSBfaW47CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract A {
 function f(uint \_in) public pure returns (uint out) {
 out \= \_in;
 }
 function f(uint \_in, bool \_really) public pure returns (uint out) {
 if (\_really)
 out \= \_in;
 }
}
Les fonctions surchargées sont également présentes dans l’interface externe. C’est une erreur si deux fonctions visibles de l’extérieur diffèrent par leurs types Solidity mais pas par leurs types externes.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCi8vIFRoaXMgd2lsbCBub3QgY29tcGlsZQpjb250cmFjdCBBIHsKICAgIGZ1bmN0aW9uIGYoQiBfaW4pIHB1YmxpYyBwdXJlIHJldHVybnMgKEIgb3V0KSB7CiAgICAgICAgb3V0ID0gX2luOwogICAgfQoKICAgIGZ1bmN0aW9uIGYoYWRkcmVzcyBfaW4pIHB1YmxpYyBwdXJlIHJldHVybnMgKGFkZHJlc3Mgb3V0KSB7CiAgICAgICAgb3V0ID0gX2luOwogICAgfQp9Cgpjb250cmFjdCBCIHsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
// This will not compile
contract A {
 function f(B \_in) public pure returns (B out) {
 out \= \_in;
 }
 function f(address \_in) public pure returns (address out) {
 out \= \_in;
 }
}
contract B {
}
Les deux surcharges de fonction `f` ci-dessus finissent par accepter le type d’adresse pour l’ABI bien qu’ils ils sont considérés comme différents dans Solidity.
#### Résolution des surcharges et correspondance des arguments[](#resolution-des-surcharges-et-correspondance-des-arguments "Lien permanent vers cette rubrique")
Les fonctions surchargées sont sélectionnées en faisant correspondre les déclarations de fonction dans la portée actuelle aux arguments fournis dans l’appel de fonction. Les fonctions sont sélectionnées comme candidates à la surcharge si tous les arguments peuvent être implicitement convertis dans les types attendus. S’il n’y a pas exactement un candidat, la résolution échoue.
Note
Les paramètres de retour ne sont pas pris en compte pour la résolution des surcharges.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEEgewogICAgZnVuY3Rpb24gZih1aW50OCBfaW4pIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQ4IG91dCkgewogICAgICAgIG91dCA9IF9pbjsKICAgIH0KCiAgICBmdW5jdGlvbiBmKHVpbnQyNTYgX2luKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50MjU2IG91dCkgewogICAgICAgIG91dCA9IF9pbjsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract A {
 function f(uint8 \_in) public pure returns (uint8 out) {
 out \= \_in;
 }
 function f(uint256 \_in) public pure returns (uint256 out) {
 out \= \_in;
 }
}
Appeler `f(50)` créerait une erreur de type puisque `50` peut être implicitement converti à la fois en types `uint8` et `uint256`. D’un autre côté, `f(256)` se résoudrait en une surcharge `f(uint256)` puisque `256` ne peut pas être implicitement converti en `uint8`.
## Événements[](#evenements "Lien permanent vers cette rubrique")
Les événements Solidity offrent une abstraction au-dessus de la fonctionnalité de journalisation de l’EVM. Les applications peuvent s’abonner et écouter ces événements via l’interface RPC d’un client Ethereum.
Les événements sont des membres héritables des contrats. Lorsque vous les appelez, ils font en sorte que les arguments dans le journal de la transaction, une structure de données spéciale dans la blockchain. Ces journaux sont associés à l’adresse du contrat, sont incorporés dans la blockchain, et y restent aussi longtemps qu’un bloc est accessible (pour toujours à partir de maintenant, mais cela pourrait changer avec Serenity). Le journal et ses données d’événement ne sont pas accessibles à partir des contrats (même pas depuis le contrat qui les a créés).
Il est possible de demander une preuve Merkle pour les journaux. Si une entité externe fournit une telle preuve à un contrat, celui-ci peut vérifier que le journal existe réellement dans la blockchain. Vous devez fournir des en-têtes de bloc car le contrat ne peut voir que les 256 derniers hachages de blocs.
Vous pouvez ajouter l’attribut `indexed` à un maximum de trois paramètres qui les ajoutent à une structure de données spéciale appelée [« topics »](https://docs.soliditylang.org/fr/latest/abi-spec.html#abi-events) au lieu de la partie données du journal. Un topic ne peut contenir qu’un seul mot (32 octets), donc si vous utilisez un [type de référence](https://docs.soliditylang.org/fr/latest/types.html#reference-types) pour un argument indexé, le hachage Keccak-256 de la valeur est stocké comme un sujet à la place.
Tous les paramètres sans l’attribut `indexed` sont [ABI-encodés](https://docs.soliditylang.org/fr/latest/abi-spec.html#abi) dans la partie données du journal.
Les sujets vous permettent de rechercher des événements, par exemple en filtrant une séquence de blocs pour certains événements. Vous pouvez également filtrer les événements en fonction de l’adresse du contrat qui a émis l’événement.
Par exemple, le code ci-dessous utilise le contrat web3.js `subscribe("logs")`. La [méthode](https://web3js.readthedocs.io/en/1.0/web3-eth-subscribe.html#subscribe-logs) pour filtrer les journaux qui correspondent à un sujet avec une certaine valeur d’adresse :
var options \= {
 fromBlock: 0,
 address: web3.eth.defaultAccount,
 topics: \["0x0000000000000000000000000000000000000000000000000000000000000000", null, null\]
};
web3.eth.subscribe('logs', options, function (error, result) {
 if (!error)
 console.log(result);
})
 .on("data", function (log) {
 console.log(log);
 })
 .on("changed", function (log) {
});
Le hachage de la signature de l’événement est l’un des sujets, sauf si vous avez déclaré l’événement avec le spécificateur `anonymous`. Cela signifie qu’il n’est pas possible de filtrer les événements anonymes spécifiques par nom, vous pouvez seulement filtrer par l’adresse du contrat. L’avantage des événements anonymes est qu’ils sont moins chers à déployer et à appeler. Ils vous permettent également de déclarer quatre arguments indexés au lieu de trois.
Note
Comme le journal des transactions ne stocke que les données de l’événement et non le type, vous devez connaître le type de l’événement, y compris le paramètre qui est indexé et si l’événement est anonyme afin d’interpréter correctement les données. En particulier, il est possible de « falsifier » la signature d’un autre événement en utilisant un événement anonyme.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIxIDwwLjkuMDsKCmNvbnRyYWN0IENsaWVudFJlY2VpcHQgewogICAgZXZlbnQgRGVwb3NpdCgKICAgICAgICBhZGRyZXNzIGluZGV4ZWQgX2Zyb20sCiAgICAgICAgYnl0ZXMzMiBpbmRleGVkIF9pZCwKICAgICAgICB1aW50IF92YWx1ZQogICAgKTsKCiAgICBmdW5jdGlvbiBkZXBvc2l0KGJ5dGVzMzIgX2lkKSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgLy8gTGVzIMOpdsOpbmVtZW50cyBzb250IMOpbWlzIGVuIHV0aWxpc2FudCBgZW1pdGAsIHN1aXZpIHBhcgogICAgICAgIC8vIGxlIG5vbSBkZSBsJ8OpdsOpbmVtZW50IGV0IGxlcyBhcmd1bWVudHMKICAgICAgICAvLyAobGUgY2FzIMOpY2jDqWFudCkgZW50cmUgcGFyZW50aMOoc2VzLiBUb3V0ZSBpbnZvY2F0aW9uIGRlIGNlIHR5cGUKICAgICAgICAvLyAobcOqbWUgcHJvZm9uZMOpbWVudCBpbWJyaXF1w6llKSBwZXV0IMOqdHJlIGTDqXRlY3TDqWUgw6AgcGFydGlyIGRlCiAgICAgICAgLy8gbCdBUEkgSmF2YVNjcmlwdCBlbiBmaWx0cmFudCBwb3VyIGBEZXBvc2l0YC4KICAgICAgICBlbWl0IERlcG9zaXQobXNnLnNlbmRlciwgX2lkLCBtc2cudmFsdWUpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.21 <0.9.0;
contract ClientReceipt {
 event Deposit(
 address indexed \_from,
 bytes32 indexed \_id,
 uint \_value
 );
 function deposit(bytes32 \_id) public payable {
 // Les événements sont émis en utilisant \`emit\`, suivi par
 // le nom de l'événement et les arguments
 // (le cas échéant) entre parenthèses. Toute invocation de ce type
 // (même profondément imbriquée) peut être détectée à partir de
 // l'API JavaScript en filtrant pour \`Deposit\`.
 emit Deposit(msg.sender, \_id, msg.value);
 }
}
L’utilisation dans l’API JavaScript est la suivante :
var abi \= /\* abi tel que généré par le compilateur \*/;
var ClientReceipt \= web3.eth.contract(abi);
var clientReceipt \= ClientReceipt.at("0x1234...ab67" /\* address \*/);
var depositEvent \= clientReceipt.Deposit();
// surveiller les changements
depositEvent.watch(function(error, result){
 // le résultat contient des arguments non indexés et des sujets
 // donnés à l'appel \`Deposit\`.
 if (!error)
 console.log(result);
});
// Ou passez un callback pour commencer à regarder immédiatement.
var depositEvent \= clientReceipt.Deposit(function(error, result) {
 if (!error)
 console.log(result);
});
Le résultat de l’opération ci-dessus ressemble à ce qui suit (découpé) :
{
 "returnValues": {
 "\_from": "0x1111…FFFFCCCC",
 "\_id": "0x50…sd5adb20",
 "\_value": "0x420042"
 },
 "raw": {
 "data": "0x7f…91385",
 "topics": \["0xfd4…b4ead7", "0x7f…1a91385"\]
 }
}
### Ressources supplémentaires pour comprendre les événements[](#ressources-supplementaires-pour-comprendre-les-evenements "Lien permanent vers cette rubrique")
* [Documentation Javascript](https://github.com/ethereum/web3.js/blob/1.x/docs/web3-eth-contract.rst#events)
 
* [Exemple d’utilisation des événements](https://github.com/ethchange/smart-exchange/blob/master/lib/contracts/SmartExchange.sol)
 
* [Comment y accéder en js](https://github.com/ethchange/smart-exchange/blob/master/lib/exchange_transactions.js)
 
## Les erreurs et la déclaration de retour en arrière[](#les-erreurs-et-la-declaration-de-retour-en-arriere "Lien permanent vers cette rubrique")
Les erreurs dans Solidity fournissent un moyen pratique et efficace d’expliquer à l’utilisateur pourquoi une opération a échoué. Elles peuvent être définies à l’intérieur et à l’extérieur des contrats (y compris les interfaces et les bibliothèques).
Elles doivent être utilisées conjointement avec l’instruction [revert](https://docs.soliditylang.org/fr/latest/control-structures.html#revert-statement) qui provoque toutes les modifications de l’appel en cours et renvoie les données d’erreur à l’appelant.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCi8vLyBTb2xkZSBpbnN1ZmZpc2FudCBwb3VyIGxlIHRyYW5zZmVydC4gTsOpY2Vzc2FpcmUgYHJlcXVpcmVkYCBtYWlzIHNldWxlbWVudAovLy8gYGF2YWlsYWJsZWAgZGlzcG9uaWJsZS4KLy8vIEBwYXJhbSBhdmFpbGFibGUgZGlzcG9uaWJsZSBkaXNwb25pYmxlLgovLy8gQHBhcmFtIHJlcXVpcmVkIG1vbnRhbnQgZGVtYW5kw6kgcG91ciBsZSB0cmFuc2ZlcnQuCmVycm9yIEluc3VmZmljaWVudEJhbGFuY2UodWludDI1NiBhdmFpbGFibGUsIHVpbnQyNTYgcmVxdWlyZWQpOwoKY29udHJhY3QgVGVzdFRva2VuIHsKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50KSBiYWxhbmNlOwogICAgZnVuY3Rpb24gdHJhbnNmZXIoYWRkcmVzcyB0bywgdWludDI1NiBhbW91bnQpIHB1YmxpYyB7CiAgICAgICAgaWYgKGFtb3VudCA+IGJhbGFuY2VbbXNnLnNlbmRlcl0pCiAgICAgICAgICAgIHJldmVydCBJbnN1ZmZpY2llbnRCYWxhbmNlKHsKICAgICAgICAgICAgICAgIGF2YWlsYWJsZTogYmFsYW5jZVttc2cuc2VuZGVyXSwKICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBhbW91bnQKICAgICAgICAgICAgfSk7CiAgICAgICAgYmFsYW5jZVttc2cuc2VuZGVyXSAtPSBhbW91bnQ7CiAgICAgICAgYmFsYW5jZVt0b10gKz0gYW1vdW50OwogICAgfQogICAgLy8gLi4uCn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
/// Solde insuffisant pour le transfert. Nécessaire \`required\` mais seulement
/// \`available\` disponible.
/// @param available disponible disponible.
/// @param required montant demandé pour le transfert.
error InsufficientBalance(uint256 available, uint256 required);
contract TestToken {
 mapping(address \=> uint) balance;
 function transfer(address to, uint256 amount) public {
 if (amount \> balance\[msg.sender\])
 revert InsufficientBalance({
 available: balance\[msg.sender\],
 required: amount
 });
 balance\[msg.sender\] \-= amount;
 balance\[to\] += amount;
 }
 // ...
}
Les erreurs ne peuvent pas être surchargées ou remplacées mais sont héritées. La même erreur peut être définie à plusieurs endroits, à condition que les champs d’application soient distincts. Les instances d’erreurs ne peuvent être créées qu’en utilisant les instructions `revert`.
L’erreur crée des données qui sont ensuite transmises à l’appelant avec l’opération `revert`, afin de retourner au composant hors chaîne ou de l’attraper dans une instruction [try/catch](https://docs.soliditylang.org/fr/latest/control-structures.html#try-catch). Notez qu’une erreur ne peut être attrapée que si elle provient d’un appel externe, les retours se produisant dans des appels internes ou à l’intérieur de la même fonction ne peuvent pas être attrapés.
Si vous ne fournissez pas de paramètres, l’erreur ne nécessite que quatre octets de données et vous pouvez utiliser [NatSpec](https://docs.soliditylang.org/fr/latest/natspec-format.html#natspec) comme ci-dessus pour expliquer plus en détail les raisons de l’erreur, qui ne sont pas stockées dans la chaîne. Cela en fait une fonctionnalité de signalement d’erreur très bon marché et pratique à la fois.
Plus précisément, une instance d’erreur est codée par ABI de la même manière que un appel à une fonction du même nom et du même type le serait et est ensuite utilisé comme données de retour dans l’opcode `revert`. Cela signifie que les données consistent en un sélecteur de 4 octets suivi de données [ABI-encodées](https://docs.soliditylang.org/fr/latest/abi-spec.html#abi). Le sélecteur est constitué des quatre premiers octets du keccak256-hash de la signature du type d’erreur.
Note
Il est possible qu’un contrat soit révoqué avec des erreurs différentes du même nom ou même avec des erreurs définies à des endroits différents qui sont indiscernables par l’appelant. Pour l’extérieur, c’est-à-dire l’ABI, seul le nom de l’erreur est pertinent, pas le contrat ou le fichier où elle est définie.
L’instruction `require(condition, "description");` serait équivalente à `if (!condition) revert Error("description")` si vous pouviez définir `error Error(string)`. Notez cependant que `Error` est un type intégré et ne peut être défini dans un code fourni par l’utilisateur.
De même, un échec de `assert` ou des conditions similaires se retourneront avec une erreur du type intégré `Panic(uint256)`.
Note
Les données d’erreur ne doivent être utilisées que pour donner une indication de l’échec, mais pas comme un moyen pour le flux de contrôle. La raison en est que les données de retour des appels internes sont propagées en retour dans la chaîne des appels externes par défaut. Cela signifie qu’un appel interne peut « forger » des données de retour qui semblent pouvoir provenir du contrat qui l’a appelé.
## Héritage[](#heritage "Lien permanent vers cette rubrique")
Solidity prend en charge l’héritage multiple, y compris le polymorphisme.
Le polymorphisme signifie qu’un appel de fonction (interne et externe) exécute toujours la fonction du même nom (et des types de paramètres) dans le contrat le plus dérivé de la hiérarchie d’héritage. Ceci doit être explicitement activé sur chaque fonction de la hiérarchie en utilisant les mots-clés `virtual` et `override`. Voir [Remplacement de fonctions](#function-overriding) pour plus de détails.
Il est possible d’appeler des fonctions plus haut dans la hiérarchie d’héritage en interne, en spécifiant explicitement le contrat en utilisant `ContractName.functionName()` ou en utilisant `super.functionName()` si vous souhaitez appeler la fonction à un niveau supérieur dans la hiérarchie d’héritage aplatie (voir ci-dessous).
Lorsqu’un contrat hérite d’autres contrats, un seul contrat unique est créé sur la blockchain, et le code de tous les contrats de base est compilé dans le contrat créé. Cela signifie que tous les appels internes aux fonctions des contrats de base utilisent également des appels de fonctions internes (`super.f(..)` utilisera JUMP et non un appel de message).
Le shadowing de variables d’état est considéré comme une erreur. Un contrat dérivé peut seulement déclarer une variable d’état `x`, s’il n’y a pas de variable d’état visible avec le même nom dans l’une de ses bases.
Le système d’héritage général est très similaire à celui de Python <[https://docs.python.org/3/tutorial/classes.html#inheritance](https://docs.python.org/3/tutorial/classes.html#inheritance)\>\`\_, surtout en ce qui concerne l’héritage multiple, mais il y a aussi quelques [différences](#multi-inheritance).
Les détails sont donnés dans l’exemple suivant.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKCmNvbnRyYWN0IE93bmVkIHsKICAgIGNvbnN0cnVjdG9yKCkgeyBvd25lciA9IHBheWFibGUobXNnLnNlbmRlcik7IH0KICAgIGFkZHJlc3MgcGF5YWJsZSBvd25lcjsKfQoKCi8vIFV0aWxpc2V6IGBzYCBwb3VyIGTDqXJpdmVyIGQndW4gYXV0cmUgY29udHJhdC4KLy8gTGVzIGNvbnRyYXRzIGTDqXJpdsOpcyBwZXV2ZW50IGFjY8OpZGVyIMOgIHRvdXMgbGVzIG1lbWJyZXMgbm9uIHByaXbDqXMsIHkgY29tcHJpcwovLyBsZXMgZm9uY3Rpb25zIGludGVybmVzIGV0IGxlcyB2YXJpYWJsZXMgZCfDqXRhdC4gQ2V1eC1jaSBuZSBwZXV2ZW50IHBhcyDDqnRyZQovLyBhY2Nlc3NpYmxlcyBlbiBleHRlcm5lIHZpYSBgdGhpc2AuCmNvbnRyYWN0IERlc3RydWN0aWJsZSBpcyBPd25lZCB7CiAgICAvLyBMZSBtb3QgY2zDqSBgdmlydHVhbGAgc2lnbmlmaWUgcXVlIGxhIGZvbmN0aW9uIHBldXQgbW9kaWZpZXIKICAgIC8vIHNvbiBjb21wb3J0ZW1lbnQgZGFucyBsZXMgY2xhc3NlcyBkw6lyaXbDqWVzICgib3ZlcnJpZGluZyIpLgogICAgZnVuY3Rpb24gZGVzdHJveSgpIHZpcnR1YWwgcHVibGljIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgc2VsZmRlc3RydWN0KG93bmVyKTsKICAgIH0KfQoKCi8vIENlcyBjb250cmF0cyBhYnN0cmFpdHMgbmUgc29udCBmb3VybmlzIHF1ZSBwb3VyIGZhaXJlIGNvbm5hw650cmUKLy8gbCdpbnRlcmZhY2UgYXUgY29tcGlsYXRldXIuIE5vdGV6IGxhIGZvbmN0aW9uCi8vIHNhbnMgY29ycHMuIFNpIHVuIGNvbnRyYXQgbidpbXBsw6ltZW50ZSBwYXMgdG91dGVzIGxlcwovLyBmb25jdGlvbnMsIGlsIG5lIHBldXQgw6p0cmUgdXRpbGlzw6kgcXVlIGNvbW1lIHVuZSBpbnRlcmZhY2UuCmFic3RyYWN0IGNvbnRyYWN0IENvbmZpZyB7CiAgICBmdW5jdGlvbiBsb29rdXAodWludCBpZCkgcHVibGljIHZpcnR1YWwgcmV0dXJucyAoYWRkcmVzcyBhZHIpOwp9CgoKYWJzdHJhY3QgY29udHJhY3QgTmFtZVJlZyB7CiAgICBmdW5jdGlvbiByZWdpc3RlcihieXRlczMyIG5hbWUpIHB1YmxpYyB2aXJ0dWFsOwogICAgZnVuY3Rpb24gdW5yZWdpc3RlcigpIHB1YmxpYyB2aXJ0dWFsOwp9CgoKLy8gTCdow6lyaXRhZ2UgbXVsdGlwbGUgZXN0IHBvc3NpYmxlLiBOb3RleiBxdWUgYG93bmVkYAovLyBlc3QgYXVzc2kgdW5lIGNsYXNzZSBkZSBiYXNlIGRlIGBEZXN0cnVjdGlibGVgLCBtYWlzIGlsIG4neSBhIHF1J3VuZSBzZXVsZSBpbnN0YW5jZSBkZSBgb3duZWRgLgovLyBQb3VydGFudCwgaWwgbidleGlzdGUgcXUndW5lIHNldWxlIGluc3RhbmNlIGRlIGBvd25lZGAgKGNvbW1lIHBvdXIgbCdow6lyaXRhZ2UgdmlydHVlbCBlbiBDKyspLgpjb250cmFjdCBOYW1lZCBpcyBPd25lZCwgRGVzdHJ1Y3RpYmxlIHsKICAgIGNvbnN0cnVjdG9yKGJ5dGVzMzIgbmFtZSkgewogICAgICAgIENvbmZpZyBjb25maWcgPSBDb25maWcoMHhENWY5RDhEOTQ4ODZFNzBiMDZFNDc0YzNmQjE0RmQ0M0UyZjIzOTcwKTsKICAgICAgICBOYW1lUmVnKGNvbmZpZy5sb29rdXAoMSkpLnJlZ2lzdGVyKG5hbWUpOwogICAgfQoKICAgIC8vIExlcyBmb25jdGlvbnMgcGV1dmVudCDDqnRyZSByZW1wbGFjw6llcyBwYXIgdW5lIGF1dHJlIGZvbmN0aW9uIGF5YW50IGxlIG3Dqm1lIG5vbSBldAogICAgLy8gbGUgbcOqbWUgbm9tYnJlL3R5cGVzIGQnZW50csOpZXMuIFNpIGxhIGZvbmN0aW9uIGRlIHJlbXBsYWNlbWVudCBhIGRpZmbDqXJlbnRzCiAgICAvLyB0eXBlcyBkZSBwYXJhbcOodHJlcyBkZSBzb3J0aWUgZGlmZsOpcmVudHMsIGNlbGEgZW50cmHDrm5lIHVuZSBlcnJldXIuCiAgICAvLyBMZXMgYXBwZWxzIGRlIGZvbmN0aW9uIGxvY2F1eCBldCBwYXIgbWVzc2FnZSB0aWVubmVudCBjb21wdGUgZGUgY2VzIHN1cmNoYXJnZXMuCiAgICAvLyBTaSB2b3VzIHZvdWxleiBxdWUgbGEgZm9uY3Rpb24gc29pdCBwcmlvcml0YWlyZSwgdm91cyBkZXZleiB1dGlsaXNlciBsZQogICAgLy8gbW90LWNsw6kgYG92ZXJyaWRlYC4gVm91cyBkZXZleiDDoCBub3V2ZWF1IHNww6ljaWZpZXIgbGUgbW90LWNsw6kgYHZpcnR1YWxgCiAgICAvLyBzaSB2b3VzIHZvdWxleiBxdWUgY2V0dGUgZm9uY3Rpb24gc29pdCDDoCBub3V2ZWF1IHN1cmNoYXJnw6llLgogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyB2aXJ0dWFsIG92ZXJyaWRlIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgewogICAgICAgICAgICBDb25maWcgY29uZmlnID0gQ29uZmlnKDB4RDVmOUQ4RDk0ODg2RTcwYjA2RTQ3NGMzZkIxNEZkNDNFMmYyMzk3MCk7CiAgICAgICAgICAgIE5hbWVSZWcoY29uZmlnLmxvb2t1cCgxKSkudW5yZWdpc3RlcigpOwogICAgICAgICAgICAvLyBJbCBlc3QgdG91am91cnMgcG9zc2libGUgZCdhcHBlbGVyIHVuZQogICAgICAgICAgICAvLyBmb25jdGlvbiBzcMOpY2lmaXF1ZSBzdXJjaGFyZ8OpZS4KICAgICAgICAgICAgRGVzdHJ1Y3RpYmxlLmRlc3Ryb3koKTsKICAgICAgICB9CiAgICB9Cn0KCgovLyBTaSB1biBjb25zdHJ1Y3RldXIgcHJlbmQgdW4gYXJndW1lbnQsIGlsIGRvaXQgw6p0cmUKLy8gZm91cm5pIGRhbnMgbCdlbi10w6p0ZSBvdSBsZSBtb2RpZmljYXRldXItaW52b2NhdGlvbi1zdHlsZSDDoAovLyBsZSBjb25zdHJ1Y3RldXIgZHUgY29udHJhdCBkw6lyaXbDqSAodm9pciBjaS1kZXNzb3VzKS4KY29udHJhY3QgUHJpY2VGZWVkIGlzIE93bmVkLCBEZXN0cnVjdGlibGUsIE5hbWVkKCJHb2xkRmVlZCIpIHsKICAgIGZ1bmN0aW9uIHVwZGF0ZUluZm8odWludCBuZXdJbmZvKSBwdWJsaWMgewogICAgICAgIGlmIChtc2cuc2VuZGVyID09IG93bmVyKSBpbmZvID0gbmV3SW5mbzsKICAgIH0KCiAgICAvLyBJY2ksIG5vdXMgbmUgc3DDqWNpZmlvbnMgcXVlIGBvdmVycmlkZWAgZXQgbm9uIGB2aXJ0dWFsYC4KICAgIC8vIENlbGEgc2lnbmlmaWUgcXVlIGxlcyBjb250cmF0cyBkw6lyaXZhbnQgZGUgYFByaWNlRmVlZGAKICAgIC8vIG5lIHBldXZlbnQgcGx1cyBtb2RpZmllciBsZSBjb21wb3J0ZW1lbnQgZGUgYGRlc3Ryb3lgLgogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyBvdmVycmlkZShEZXN0cnVjdGlibGUsIE5hbWVkKSB7IE5hbWVkLmRlc3Ryb3koKTsgfQogICAgZnVuY3Rpb24gZ2V0KCkgcHVibGljIHZpZXcgcmV0dXJucyh1aW50IHIpIHsgcmV0dXJuIGluZm87IH0KCiAgICB1aW50IGluZm87Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Owned {
 constructor() { owner \= payable(msg.sender); }
 address payable owner;
}
// Utilisez \`s\` pour dériver d'un autre contrat.
// Les contrats dérivés peuvent accéder à tous les membres non privés, y compris
// les fonctions internes et les variables d'état. Ceux-ci ne peuvent pas être
// accessibles en externe via \`this\`.
contract Destructible is Owned {
 // Le mot clé \`virtual\` signifie que la fonction peut modifier
 // son comportement dans les classes dérivées ("overriding").
 function destroy() virtual public {
 if (msg.sender \== owner) selfdestruct(owner);
 }
}
// Ces contrats abstraits ne sont fournis que pour faire connaître
// l'interface au compilateur. Notez la fonction
// sans corps. Si un contrat n'implémente pas toutes les
// fonctions, il ne peut être utilisé que comme une interface.
abstract contract Config {
 function lookup(uint id) public virtual returns (address adr);
}
abstract contract NameReg {
 function register(bytes32 name) public virtual;
 function unregister() public virtual;
}
// L'héritage multiple est possible. Notez que \`owned\`
// est aussi une classe de base de \`Destructible\`, mais il n'y a qu'une seule instance de \`owned\`.
// Pourtant, il n'existe qu'une seule instance de \`owned\` (comme pour l'héritage virtuel en C++).
contract Named is Owned, Destructible {
 constructor(bytes32 name) {
 Config config \= Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
 NameReg(config.lookup(1)).register(name);
 }
 // Les fonctions peuvent être remplacées par une autre fonction ayant le même nom et
 // le même nombre/types d'entrées. Si la fonction de remplacement a différents
 // types de paramètres de sortie différents, cela entraîne une erreur.
 // Les appels de fonction locaux et par message tiennent compte de ces surcharges.
 // Si vous voulez que la fonction soit prioritaire, vous devez utiliser le
 // mot-clé \`override\`. Vous devez à nouveau spécifier le mot-clé \`virtual\`
 // si vous voulez que cette fonction soit à nouveau surchargée.
 function destroy() public virtual override {
 if (msg.sender \== owner) {
 Config config \= Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
 NameReg(config.lookup(1)).unregister();
 // Il est toujours possible d'appeler une
 // fonction spécifique surchargée.
 Destructible.destroy();
 }
 }
}
// Si un constructeur prend un argument, il doit être
// fourni dans l'en-tête ou le modificateur-invocation-style à
// le constructeur du contrat dérivé (voir ci-dessous).
contract PriceFeed is Owned, Destructible, Named("GoldFeed") {
 function updateInfo(uint newInfo) public {
 if (msg.sender \== owner) info \= newInfo;
 }
 // Ici, nous ne spécifions que \`override\` et non \`virtual\`.
 // Cela signifie que les contrats dérivant de \`PriceFeed\`
 // ne peuvent plus modifier le comportement de \`destroy\`.
 function destroy() public override(Destructible, Named) { Named.destroy(); }
 function get() public view returns(uint r) { return info; }
 uint info;
}
Notez que ci-dessus, nous appelons `Destructible.destroy()` pour « faire suivre » la demande de destruction. La manière dont cela est fait est problématique, comme le montre l’exemple suivant :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwp9Cgpjb250cmFjdCBEZXN0cnVjdGlibGUgaXMgb3duZWQgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyB2aXJ0dWFsIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgc2VsZmRlc3RydWN0KG93bmVyKTsKICAgIH0KfQoKY29udHJhY3QgQmFzZTEgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIGRvIGNsZWFudXAgMSAqLyBEZXN0cnVjdGlibGUuZGVzdHJveSgpOyB9Cn0KCmNvbnRyYWN0IEJhc2UyIGlzIERlc3RydWN0aWJsZSB7CiAgICBmdW5jdGlvbiBkZXN0cm95KCkgcHVibGljIHZpcnR1YWwgb3ZlcnJpZGUgeyAvKiBkbyBjbGVhbnVwIDIgKi8gRGVzdHJ1Y3RpYmxlLmRlc3Ryb3koKTsgfQp9Cgpjb250cmFjdCBGaW5hbCBpcyBCYXNlMSwgQmFzZTIgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyBvdmVycmlkZShCYXNlMSwgQmFzZTIpIHsgQmFzZTIuZGVzdHJveSgpOyB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract owned {
 constructor() { owner \= payable(msg.sender); }
 address payable owner;
}
contract Destructible is owned {
 function destroy() public virtual {
 if (msg.sender \== owner) selfdestruct(owner);
 }
}
contract Base1 is Destructible {
 function destroy() public virtual override { /\* do cleanup 1 \*/ Destructible.destroy(); }
}
contract Base2 is Destructible {
 function destroy() public virtual override { /\* do cleanup 2 \*/ Destructible.destroy(); }
}
contract Final is Base1, Base2 {
 function destroy() public override(Base1, Base2) { Base2.destroy(); }
}
Un appel à `Final.destroy()` fera appel à `Base2.destroy` parce que nous le spécifions explicitement dans la surcharge finale, mais cette fonction contournera `Base1.destroy`. Le moyen de contourner ce problème est d’utiliser `super` :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwp9Cgpjb250cmFjdCBEZXN0cnVjdGlibGUgaXMgb3duZWQgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHZpcnR1YWwgcHVibGljIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgc2VsZmRlc3RydWN0KG93bmVyKTsKICAgIH0KfQoKY29udHJhY3QgQmFzZTEgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIGRvIGNsZWFudXAgMSAqLyBzdXBlci5kZXN0cm95KCk7IH0KfQoKCmNvbnRyYWN0IEJhc2UyIGlzIERlc3RydWN0aWJsZSB7CiAgICBmdW5jdGlvbiBkZXN0cm95KCkgcHVibGljIHZpcnR1YWwgb3ZlcnJpZGUgeyAvKiBkbyBjbGVhbnVwIDIgKi8gc3VwZXIuZGVzdHJveSgpOyB9Cn0KCmNvbnRyYWN0IEZpbmFsIGlzIEJhc2UxLCBCYXNlMiB7CiAgICBmdW5jdGlvbiBkZXN0cm95KCkgcHVibGljIG92ZXJyaWRlKEJhc2UxLCBCYXNlMikgeyBzdXBlci5kZXN0cm95KCk7IH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract owned {
 constructor() { owner \= payable(msg.sender); }
 address payable owner;
}
contract Destructible is owned {
 function destroy() virtual public {
 if (msg.sender \== owner) selfdestruct(owner);
 }
}
contract Base1 is Destructible {
 function destroy() public virtual override { /\* do cleanup 1 \*/ super.destroy(); }
}
contract Base2 is Destructible {
 function destroy() public virtual override { /\* do cleanup 2 \*/ super.destroy(); }
}
contract Final is Base1, Base2 {
 function destroy() public override(Base1, Base2) { super.destroy(); }
}
Si `Base2` appelle une fonction de `super`, elle n’appelle pas simplement cette fonction sur l’un de ses contrats de base. Au contraire, elle appelle plutôt cette fonction sur le contrat de base suivant dans le d’héritage final, il appellera donc `Base1.destroy()` (notez que la séquence d’héritage finale est – en commençant par le contrat le plus contrat le plus dérivé : Final, Base2, Base1, Destructible, owned). La fonction réelle qui est appelée lors de l’utilisation de super est pas connue dans le contexte de la classe où elle est utilisée, bien que son type soit connu. Il en va de même pour la recherche ordinaire de recherche de méthode virtuelle ordinaire.
### Remplacement des fonctions[](#remplacement-des-fonctions "Lien permanent vers cette rubrique")
Les fonctions de base peuvent être surchargées par les contrats hérités pour changer leur comportement si elles sont marquées comme `virtual`. La fonction de remplacement doit alors utiliser le mot-clé `override` dans l’en-tête de la fonction. La fonction de remplacement ne peut que changer la visibilité de la fonction de remplacement de `externe` à `public`. La mutabilité peut être changée en une mutabilité plus stricte en suivant l’ordre : `nonpayable` peut être remplacé par `view` et `pure`. `view` peut être remplacé par `pure`. `payable` est une exception et ne peut pas être changé en une autre mutabilité.
L’exemple suivant démontre la modification de la mutabilité et de la visibilité :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZQp7CiAgICBmdW5jdGlvbiBmb28oKSB2aXJ0dWFsIGV4dGVybmFsIHZpZXcge30KfQoKY29udHJhY3QgTWlkZGxlIGlzIEJhc2Uge30KCmNvbnRyYWN0IEluaGVyaXRlZCBpcyBNaWRkbGUKewogICAgZnVuY3Rpb24gZm9vKCkgb3ZlcnJpZGUgcHVibGljIHB1cmUge30KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Base
{
 function foo() virtual external view {}
}
contract Middle is Base {}
contract Inherited is Middle
{
 function foo() override public pure {}
}
Pour l’héritage multiple, les contrats de base les plus dérivés qui définissent la même doivent être spécifiés explicitement après le mot-clé `override`. En d’autres termes, vous devez spécifier tous les contrats de base qui définissent la même fonction et qui n’ont pas encore été remplacés par un autre contrat de base (sur un chemin quelconque du graphe d’héritage). De plus, si un contrat hérite de la même fonction à partir de plusieurs bases (sans lien), il doit explicitement la remplacer :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEKewogICAgZnVuY3Rpb24gZm9vKCkgdmlydHVhbCBwdWJsaWMge30KfQoKY29udHJhY3QgQmFzZTIKewogICAgZnVuY3Rpb24gZm9vKCkgdmlydHVhbCBwdWJsaWMge30KfQoKY29udHJhY3QgSW5oZXJpdGVkIGlzIEJhc2UxLCBCYXNlMgp7CiAgICAvLyBEw6lyaXZlIGRlIHBsdXNpZXVycyBiYXNlcyBkw6lmaW5pc3NhbnQgZm9vKCksIG5vdXMgZGV2b25zIGRvbmMgZXhwbGljaXRlbWVudAogICAgLy8gbGUgc3VyY2hhcmdlcgogICAgZnVuY3Rpb24gZm9vKCkgcHVibGljIG92ZXJyaWRlKEJhc2UxLCBCYXNlMikge30KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract Base1
{
 function foo() virtual public {}
}
contract Base2
{
 function foo() virtual public {}
}
contract Inherited is Base1, Base2
{
 // Dérive de plusieurs bases définissant foo(), nous devons donc explicitement
 // le surcharger
 function foo() public override(Base1, Base2) {}
}
Un spécificateur de surcharge explicite n’est pas nécessaire si la fonction est définie dans un contrat de base commun ou s’il existe une fonction unique dans un contrat de base commun qui prévaut déjà sur toutes les autres fonctions.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQSB7IGZ1bmN0aW9uIGYoKSBwdWJsaWMgcHVyZXt9IH0KY29udHJhY3QgQiBpcyBBIHt9CmNvbnRyYWN0IEMgaXMgQSB7fQovLyBBdWN1bmUgc3VyY2hhcmdlIGV4cGxpY2l0ZSBuJ2VzdCByZXF1aXNlCmNvbnRyYWN0IEQgaXMgQiwgQyB7fQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract A { function f() public pure{} }
contract B is A {}
contract C is A {}
// Aucune surcharge explicite n'est requise
contract D is B, C {}
Plus formellement, il n’est pas nécessaire de surcharger une fonction (directement ou indirectement) héritée de bases multiples s’il existe un contrat de base qui fait partie de tous les chemins de surcharge pour la signature, et (1) cette base implémente la fonction et qu’aucun chemin depuis le contrat actuel vers la base ne mentionne une fonction avec cette signature ou (2) cette base n’implémente pas la fonction et il y a au plus une mention de la fonction dans tous les chemins allant du contrat actuel à cette base.
Dans ce sens, un chemin de surcharge pour une signature est un chemin à travers le graphe d’héritage qui commence au contrat considéré et se termine par un contrat mentionnant une fonction avec cette signature qui n’est pas surchargée.
Si vous n’indiquez pas qu’une fonction qui surcharge est `virtual`, les contrats dérivés ne peuvent plus modifier le comportement de cette fonction.
Note
Les fonctions ayant la visibilité `private` ne peuvent pas être `virtual`.
Note
Les fonctions sans implémentation doivent être marquées `virtual` en dehors des interfaces. Dans les interfaces, toutes les fonctions sont automatiquement considérées comme `virtual`.
Note
A partir de Solidity 0.8.8, le mot-clé `override` n’est pas nécessaire pour remplacer une fonction, au cas où la fonction est définie dans plusieurs bases.
Les variables d’état publiques peuvent remplacer les fonctions externes si les types de paramètres et de retour de la fonction correspondent à la fonction getter de la variable :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQQp7CiAgICBmdW5jdGlvbiBmKCkgZXh0ZXJuYWwgdmlldyB2aXJ0dWFsIHJldHVybnModWludCkgeyByZXR1cm4gNTsgfQp9Cgpjb250cmFjdCBCIGlzIEEKewogICAgdWludCBwdWJsaWMgb3ZlcnJpZGUgZjsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract A
{
 function f() external view virtual returns(uint) { return 5; }
}
contract B is A
{
 uint public override f;
}
Note
Si les variables d’état publiques peuvent remplacer les fonctions externes, elles ne peuvent pas elles-mêmes être surchargées.
### Remplacement d’un modificateur[](#remplacement-d-un-modificateur "Lien permanent vers cette rubrique")
Les modificateurs de fonction peuvent se substituer les uns aux autres. Cela fonctionne de la même manière que la [superposition de fonctions](#function-overriding) (sauf qu’il n’y a pas de surcharge pour les modificateurs). Le mot-clé `virtual` doit être utilisé sur le modificateur surchargé et le mot-clé `override` doit être utilisé dans le modificateur de surcharge :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZQp7CiAgICBtb2RpZmllciBmb28oKSB2aXJ0dWFsIHtfO30KfQoKY29udHJhY3QgSW5oZXJpdGVkIGlzIEJhc2UKewogICAgbW9kaWZpZXIgZm9vKCkgb3ZlcnJpZGUge187fQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract Base
{
 modifier foo() virtual {\_;}
}
contract Inherited is Base
{
 modifier foo() override {\_;}
}
En cas d’héritage multiple, tous les contrats de base directs doivent être spécifiés explicitement :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEKewogICAgbW9kaWZpZXIgZm9vKCkgdmlydHVhbCB7Xzt9Cn0KCmNvbnRyYWN0IEJhc2UyCnsKICAgIG1vZGlmaWVyIGZvbygpIHZpcnR1YWwge187fQp9Cgpjb250cmFjdCBJbmhlcml0ZWQgaXMgQmFzZTEsIEJhc2UyCnsKICAgIG1vZGlmaWVyIGZvbygpIG92ZXJyaWRlKEJhc2UxLCBCYXNlMikge187fQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract Base1
{
 modifier foo() virtual {\_;}
}
contract Base2
{
 modifier foo() virtual {\_;}
}
contract Inherited is Base1, Base2
{
 modifier foo() override(Base1, Base2) {\_;}
}
### Constructeurs[](#constructeurs "Lien permanent vers cette rubrique")
Un constructeur est une fonction facultative déclarée avec le mot-clé `constructor` qui est exécutée lors de la création du contrat, et dans laquelle vous pouvez exécuter le code d’initialisation du contrat.
Avant que le code du constructeur ne soit exécuté, les variables d’état sont initialisées à leur valeur spécifiée si vous les initialisez en ligne, ou leur [valeur par défaut](https://docs.soliditylang.org/fr/latest/control-structures.html#default-value) si vous ne le faites pas.
Après l’exécution du constructeur, le code définitif du contrat est déployé sur la blockchain. Le déploiement du code coûte un gaz supplémentaire linéaire à la longueur du code. Ce code comprend toutes les fonctions qui font partie de l’interface publique et toutes les fonctions qui sont accessibles à partir de celle-ci par des appels de fonction. Il ne comprend pas le code du constructeur ni les fonctions internes qui ne sont appelées uniquement depuis le constructeur.
S’il n’y a pas de constructeur, le contrat prendra en charge le constructeur par défaut, qui est équivalent à `constructor() {}`. Par exemple :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgQSB7CiAgICB1aW50IHB1YmxpYyBhOwoKICAgIGNvbnN0cnVjdG9yKHVpbnQgX2EpIHsKICAgICAgICBhID0gX2E7CiAgICB9Cn0KCmNvbnRyYWN0IEIgaXMgQSgxKSB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
abstract contract A {
 uint public a;
 constructor(uint \_a) {
 a \= \_a;
 }
}
contract B is A(1) {
 constructor() {}
}
Vous pouvez utiliser des paramètres internes dans un constructeur (par exemple des pointeurs de stockage). Dans ce cas, le contrat doit être marqué [abstract](#abstract-contract), parce que ces paramètres ne peuvent pas se voir attribuer de valeurs valides de l’extérieur, mais uniquement par le biais des constructeurs des contrats dérivés.
Avertissement
Avant la version 0.4.22, les constructeurs étaient définis comme des fonctions portant le même nom que le contrat. Cette syntaxe a été dépréciée et n’est plus autorisée dans la version 0.5.0.
Avertissement
Avant la version 0.7.0, vous deviez spécifier la visibilité des constructeurs comme étant soit `internal` ou `public`.
### Arguments pour les constructeurs de base[](#arguments-pour-les-constructeurs-de-base "Lien permanent vers cette rubrique")
Les constructeurs de tous les contrats de base seront appelés en suivant les règles de linéarisation expliquées ci-dessous. Si les constructeurs de base ont des arguments, les contrats dérivés doivent tous les spécifier. Ceci peut être fait de deux manières :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZSB7CiAgICB1aW50IHg7CiAgICBjb25zdHJ1Y3Rvcih1aW50IF94KSB7IHggPSBfeDsgfQp9CgovLyBTb2l0IHNww6ljaWZpZXIgZGlyZWN0ZW1lbnQgZGFucyBsYSBsaXN0ZSBkJ2jDqXJpdGFnZS4uLgpjb250cmFjdCBEZXJpdmVkMSBpcyBCYXNlKDcpIHsKICAgIGNvbnN0cnVjdG9yKCkge30KfQoKLy8gb3UgcGFyIHVuICJtb2RpZmljYXRldXIiIGR1IGNvbnN0cnVjdGV1ciBkw6lyaXbDqS4KY29udHJhY3QgRGVyaXZlZDIgaXMgQmFzZSB7CiAgICBjb25zdHJ1Y3Rvcih1aW50IF95KSBCYXNlKF95ICogX3kpIHt9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Base {
 uint x;
 constructor(uint \_x) { x \= \_x; }
}
// Soit spécifier directement dans la liste d'héritage...
contract Derived1 is Base(7) {
 constructor() {}
}
// ou par un "modificateur" du constructeur dérivé.
contract Derived2 is Base {
 constructor(uint \_y) Base(\_y \* \_y) {}
}
L’une des façons est directement dans la liste d’héritage (`est Base(7)`). L’autre est dans la façon dont un modificateur est invoqué dans le cadre du constructeur dérivé (`Base(_y * _y)`). La première façon est plus pratique si l’argument du constructeur est une constante et définit le comportement du contrat ou le le décrit. La deuxième façon doit être utilisée si les arguments du constructeur de la base dépendent de ceux du contrat dérivé. Les arguments doivent être donnés soit dans la liste d’héritage ou dans le style modificateur dans le constructeur dérivé. Spécifier les arguments aux deux endroits est une erreur.
Si un contrat dérivé ne spécifie pas les arguments de tous les constructeurs de ses contrats de base, il sera considéré comme un contrat abstrait.
### Héritage multiple et linéarisation[](#heritage-multiple-et-linearisation "Lien permanent vers cette rubrique")
Les langages qui autorisent l’héritage multiple doivent faire face à plusieurs problèmes. L’un d’entre eux est le [problème du diamant](https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem). Solidity est similaire à Python en ce qu’il utilise la « [C3 Linearization](https://en.wikipedia.org/wiki/C3_linearization) » pour forcer un ordre spécifique dans le graphe acyclique dirigé (DAG) des classes de base. Cette propriété souhaitable de la monotonicité, mais désapprouve certains graphes d’héritage. En particulier, l’ordre dans lequel dans lequel les classes de base sont données dans la directive `s` est important : Vous devez lister les contrats de base directs dans l’ordre de « le plus similaire à la base » à « le plus dérivé ». Notez que cet ordre est l’inverse de celui utilisé en Python.
Une autre façon simplifiée d’expliquer ceci est que lorsqu’une fonction est appelée qui est définie plusieurs fois dans différents contrats, les bases données sont recherchées de droite à gauche (de gauche à droite en Python) de manière approfondie, s’arrêtant à la première correspondance. Si un contrat de base a déjà été recherché, il est ignoré.
Dans le code suivant, Solidity donnera l’erreur suivante erreur « Linearization of inheritance graph impossible » (« Linéarisation du graphe d’héritage impossible »).
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgWCB7fQpjb250cmFjdCBBIGlzIFgge30KLy8gQ2VsYSBuZSBjb21waWxlcmEgcGFzCmNvbnRyYWN0IEMgaXMgQSwgWCB7fQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract X {}
contract A is X {}
// Cela ne compilera pas
contract C is A, X {}
La raison en est que `C` demande à `X` de supplanter `A` (en spécifiant `A, X` dans cet ordre), mais `A` lui-même demande d’outrepasser `X`, ce qui est une contradiction qui ne peut être résolue.
En raison du fait que vous devez explicitement surcharger une fonction qui est héritée de plusieurs bases sans une surcharge unique, la linéarisation de C3 n’est pas trop importante en pratique.
Un domaine où la linéarisation de l’héritage est particulièrement importante et peut-être pas aussi claire est lorsqu’il y a plusieurs constructeurs dans la hiérarchie de l’héritage. Les constructeurs seront toujours exécutés dans l’ordre linéarisé, quel que soit l’ordre dans lequel leurs arguments sont fournis dans le constructeur du contrat hérité. Par exemple :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEgewogICAgY29uc3RydWN0b3IoKSB7fQp9Cgpjb250cmFjdCBCYXNlMiB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0KCi8vIExlcyBjb25zdHJ1Y3RldXJzIHNvbnQgZXjDqWN1dMOpcyBkYW5zIGwnb3JkcmUgc3VpdmFudCA6Ci8vICAxIC0gQmFzZTEKLy8gIDIgLSBCYXNlMgovLyAgMyAtIERlcml2ZWQxCmNvbnRyYWN0IERlcml2ZWQxIGlzIEJhc2UxLCBCYXNlMiB7CiAgICBjb25zdHJ1Y3RvcigpIEJhc2UxKCkgQmFzZTIoKSB7fQp9CgovLyBMZXMgY29uc3RydWN0ZXVycyBzb250IGV4w6ljdXTDqXMgZGFucyBsJ29yZHJlIHN1aXZhbnQgOgovLyAgMSAtIEJhc2UyCi8vICAyIC0gQmFzZTEKLy8gIDMgLSBEZXJpdmVkMgpjb250cmFjdCBEZXJpdmVkMiBpcyBCYXNlMiwgQmFzZTEgewogICAgY29uc3RydWN0b3IoKSBCYXNlMigpIEJhc2UxKCkge30KfQoKLy8gTGVzIGNvbnN0cnVjdGV1cnMgc29udCB0b3Vqb3VycyBleMOpY3V0w6lzIGRhbnMgbCdvcmRyZSBzdWl2YW50IDoKLy8gIDEgLSBCYXNlMgovLyAgMiAtIEJhc2UxCi8vICAzIC0gRGVyaXZlZDMKY29udHJhY3QgRGVyaXZlZDMgaXMgQmFzZTIsIEJhc2UxIHsKICAgIGNvbnN0cnVjdG9yKCkgQmFzZTEoKSBCYXNlMigpIHt9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Base1 {
 constructor() {}
}
contract Base2 {
 constructor() {}
}
// Les constructeurs sont exécutés dans l'ordre suivant :
// 1 - Base1
// 2 - Base2
// 3 - Derived1
contract Derived1 is Base1, Base2 {
 constructor() Base1() Base2() {}
}
// Les constructeurs sont exécutés dans l'ordre suivant :
// 1 - Base2
// 2 - Base1
// 3 - Derived2
contract Derived2 is Base2, Base1 {
 constructor() Base2() Base1() {}
}
// Les constructeurs sont toujours exécutés dans l'ordre suivant :
// 1 - Base2
// 2 - Base1
// 3 - Derived3
contract Derived3 is Base2, Base1 {
 constructor() Base1() Base2() {}
}
### Hériter de différents types de membres portant le même nom[](#heriter-de-differents-types-de-membres-portant-le-meme-nom "Lien permanent vers cette rubrique")
C’est une erreur lorsque l’une des paires suivantes dans un contrat porte le même nom en raison de l’héritage :
* une fonction et un modificateur
 
* une fonction et un événement
 
* un événement et un modificateur
 
À titre d’exception, un getter de variable d’état peut remplacer une fonction externe.
## Contrats abstraits[](#contrats-abstraits "Lien permanent vers cette rubrique")
Les contrats doivent être marqués comme abstraits lorsqu’au moins une de leurs fonctions n’est pas implémentée. Les contrats peuvent être marqués comme abstraits même si toutes les fonctions sont implémentées.
Cela peut être fait en utilisant le mot-clé `abstract` comme le montre l’exemple suivant. Notez que ce contrat doit être défini comme abstrait, car la fonction `utterance()` a été définie, mais aucune implémentation n’a été fournie (aucun corps d’implémentation `{ }` n’a été donné).
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgRmVsaW5lIHsKICAgIGZ1bmN0aW9uIHV0dGVyYW5jZSgpIHB1YmxpYyB2aXJ0dWFsIHJldHVybnMgKGJ5dGVzMzIpOwp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
abstract contract Feline {
 function utterance() public virtual returns (bytes32);
}
Ces contrats abstraits ne peuvent pas être instanciés directement. Cela est également vrai si un contrat abstrait met en œuvre toutes les fonctions définies. L’utilisation d’un contrat abstrait comme classe de base est illustrée dans l’exemple suivant :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgRmVsaW5lIHsKICAgIGZ1bmN0aW9uIHV0dGVyYW5jZSgpIHB1YmxpYyBwdXJlIHZpcnR1YWwgcmV0dXJucyAoYnl0ZXMzMik7Cn0KCmNvbnRyYWN0IENhdCBpcyBGZWxpbmUgewogICAgZnVuY3Rpb24gdXR0ZXJhbmNlKCkgcHVibGljIHB1cmUgb3ZlcnJpZGUgcmV0dXJucyAoYnl0ZXMzMikgeyByZXR1cm4gIm1pYW93IjsgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
abstract contract Feline {
 function utterance() public pure virtual returns (bytes32);
}
contract Cat is Feline {
 function utterance() public pure override returns (bytes32) { return "miaow"; }
}
Si un contrat hérite d’un contrat abstrait et qu’il n’implémente pas toutes les fonctions non implémentées en les surchargeant, il doit également être marqué comme abstrait.
Notez qu’une fonction sans implémentation est différente d’une [Fonction Type](https://docs.soliditylang.org/fr/latest/types.html#function-types), même si leur syntaxe est très similaire.
Exemple de fonction sans implémentation (une déclaration de fonction) :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZnVuY3Rpb24gZm9vKGFkZHJlc3MpIGV4dGVybmFsIHJldHVybnMgKGFkZHJlc3MpOw==)
function foo(address) external returns (address);
Exemple de déclaration d’une variable dont le type est un type de fonction :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ZnVuY3Rpb24oYWRkcmVzcykgZXh0ZXJuYWwgcmV0dXJucyAoYWRkcmVzcykgZm9vOw==)
function(address) external returns (address) foo;
Les contrats abstraits découplent la définition d’un contrat de son implémentation fournissant une meilleure extensibilité et auto-documentation et facilitant les modèles comme la méthode [Template](https://en.wikipedia.org/wiki/Template_method_pattern) et supprimant la duplication du code. Les contrats abstraits sont utiles de la même façon que définir des méthodes dans une interface est utile. C’est un moyen pour le concepteur du contrat abstrait de dire « tout enfant de moi doit implémenter cette méthode ».
Note
Les contrats abstraits ne peuvent pas remplacer une fonction virtuelle implémentée par une fonction virtuelle non implémentée.
## Interfaces[](#interfaces "Lien permanent vers cette rubrique")
Les interfaces sont similaires aux contrats abstraits, mais aucune fonction ne peut y être implémentée. Il existe d’autres restrictions :
* Elles ne peuvent pas hériter d’autres contrats, mais elles peuvent hériter d’autres interfaces.
 
* Toutes les fonctions déclarées doivent être externes.
 
* Elles ne peuvent pas déclarer de constructeur.
 
* Elles ne peuvent pas déclarer de variables d’état.
 
* Elles ne peuvent pas déclarer de modificateurs.
 
Certaines de ces restrictions peuvent être levées à l’avenir.
Les interfaces sont fondamentalement limitées à ce que l’ABI du contrat peut représenter, et la conversion entre l’ABI et une interface devrait être possible sans aucune perte d’information.
Les interfaces sont désignées par leur propre mot-clé :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKaW50ZXJmYWNlIFRva2VuIHsKICAgIGVudW0gVG9rZW5UeXBlIHsgRnVuZ2libGUsIE5vbkZ1bmdpYmxlIH0KICAgIHN0cnVjdCBDb2luIHsgc3RyaW5nIG9idmVyc2U7IHN0cmluZyByZXZlcnNlOyB9CiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIHJlY2lwaWVudCwgdWludCBhbW91bnQpIGV4dGVybmFsOwp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.2 <0.9.0;
interface Token {
 enum TokenType { Fungible, NonFungible }
 struct Coin { string obverse; string reverse; }
 function transfer(address recipient, uint amount) external;
}
Les contrats peuvent hériter d’interfaces comme ils le feraient pour d’autres contrats.
Toutes les fonctions déclarées dans les interfaces sont implicitement `virtual`, les fonctions qui les surchargent n’ont pas besoin du mot-clé `override`. Cela ne signifie pas automatiquement qu’une fonction surchargée peut être à nouveau surchargée. Cela n’est possible que si la fonction qui la surcharge est marquée `virtual`.
Les interfaces peuvent hériter d’autres interfaces. Les règles sont les mêmes que pour l’héritage normal.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKaW50ZXJmYWNlIFBhcmVudEEgewogICAgZnVuY3Rpb24gdGVzdCgpIGV4dGVybmFsIHJldHVybnMgKHVpbnQyNTYpOwp9CgppbnRlcmZhY2UgUGFyZW50QiB7CiAgICBmdW5jdGlvbiB0ZXN0KCkgZXh0ZXJuYWwgcmV0dXJucyAodWludDI1Nik7Cn0KCmludGVyZmFjZSBTdWJJbnRlcmZhY2UgaXMgUGFyZW50QSwgUGFyZW50QiB7CiAgICAvLyBEb2l0IHJlZMOpZmluaXIgdGVzdCBhZmluIGQnYWZmaXJtZXIgcXVlIGxlcyBwYXJlbnRzCiAgICAvLyBzb250IGNvbXBhdGlibGVzLgogICAgZnVuY3Rpb24gdGVzdCgpIGV4dGVybmFsIG92ZXJyaWRlKFBhcmVudEEsIFBhcmVudEIpIHJldHVybnMgKHVpbnQyNTYpOwp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.2 <0.9.0;
interface ParentA {
 function test() external returns (uint256);
}
interface ParentB {
 function test() external returns (uint256);
}
interface SubInterface is ParentA, ParentB {
 // Doit redéfinir test afin d'affirmer que les parents
 // sont compatibles.
 function test() external override(ParentA, ParentB) returns (uint256);
}
Les types définis dans les interfaces et autres structures de type contrat sont accessibles à partir d’autres contrats : `Token.TokenType` ou `Token.Coin`.
Avertissement
Les interfaces supportent les types `enum` depuis [Solidity version 0.5.0](https://docs.soliditylang.org/fr/latest/050-breaking-changes.html), soyez sûr que le pragma version spécifie cette version au minimum.
## Bibliothèques[](#bibliotheques "Lien permanent vers cette rubrique")
Les bibliothèques sont similaires aux contrats, mais leur but est d’être déployées une seule fois à une adresse spécifique et leur code est réutilisé en utilisant le `DELEGATECALL` (`CALLCODE` jusqu’à Homestead) de l’EVM. Cela signifie que si des fonctions de bibliothèque sont appelées, leur code est exécuté dans le contexte du contrat d’appel, c’est-à-dire que `this` pointe vers le contrat appelant, et surtout le stockage du contrat appelant est accessible. Comme une bibliothèque est un morceau de code source isolé, elle ne peut accéder aux variables d’état du contrat d’appel que si elles sont explicitement fournies (elle n’aurait aucun moyen de les nommer, sinon). Les fonctions des bibliothèques ne peuvent être appelées directement (c’est-à-dire sans l’utilisation de `DELEGATECALL`) que si elles ne modifient pas l’état (c’est-à-dire si ce sont des fonctions `view` ou `pure`), parce que les bibliothèques sont supposées être sans état. En particulier, il n’est possible de détruire une bibliothèque.
Note
Jusqu’à la version 0.4.20, il était possible de détruire des bibliothèques en contournant le système de types de Solidity. A partir de cette version, les librairies contiennent un [mécanisme](#call-protection) qui empêche les fonctions modifiant l’état d’être appelées directement (c’est-à-dire sans `DELEGATECALL`).
Les bibliothèques peuvent être vues comme des contrats de base implicites des contrats qui les utilisent. Elles ne seront pas explicitement visibles dans la hiérarchie de l’héritage, mais les appels aux fonctions des bibliothèques ressemblent aux appels aux fonctions des contrats de base explicites (en utilisant un accès qualifié comme `L.f()`). Bien sûr, les appels aux fonctions internes utilisent la convention d’appel interne, ce qui signifie que tous les types internes peuvent être passés et les types [stockés en mémoire](https://docs.soliditylang.org/fr/latest/types.html#data-location) seront passés par référence et non copiés. Pour réaliser cela dans l’EVM, le code des fonctions de bibliothèques internes qui sont appelées à partir d’un contrat ainsi que toutes les fonctions appelées à partir de celui-ci seront incluses dans le contrat et un appel régulier `JUMP` sera utilisé au lieu d’un `DELEGATECALL`.
Note
L’analogie avec l’héritage s’effondre lorsqu’il s’agit de fonctions publiques. L’appel d’une fonction de bibliothèque publique avec `L.f()` entraîne un appel externe (`DELEGATECALL` pour être précis). En revanche, `A.f()` est un appel interne lorsque `A` est un contrat de base du contrat actuel.
L’exemple suivant illustre comment utiliser les bibliothèques (mais en utilisant une méthode manuelle, ne manquez pas de consulter [utiliser for](#using-for) pour un exemple plus avancé pour implémenter un ensemble).
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKCi8vIE5vdXMgZMOpZmluaXNzb25zIHVuIG5vdXZlYXUgdHlwZSBkZSBkb25uw6llcyBzdHJ1Y3QgcXVpIHNlcmEgdXRpbGlzw6kgcG91cgovLyBjb250ZW5pciBzZXMgZG9ubsOpZXMgZGFucyBsZSBjb250cmF0IGQnYXBwZWwuCnN0cnVjdCBEYXRhIHsKICAgIG1hcHBpbmcodWludCA9PiBib29sKSBmbGFnczsKfQoKbGlicmFyeSBTZXQgewogICAgLy8gTm90ZXogcXVlIGxlIHByZW1pZXIgcGFyYW3DqHRyZSBlc3QgZGUgdHlwZQogICAgLy8gInLDqWbDqXJlbmNlIGRlIHN0b2NrYWdlIiBldCBkb25jIHNldWxlbWVudCBzb24gYWRyZXNzZSBkZSBzdG9ja2FnZSBldCBwYXMKICAgIC8vIHNvbiBjb250ZW51IGVzdCB0cmFuc21pcyBkYW5zIGxlIGNhZHJlIGRlIGwnYXBwZWwuIElsIHMnYWdpdCBkJ3VuZQogICAgLy8gcGFydGljdWxhcml0w6kgZGVzIGZvbmN0aW9ucyBkZSBiaWJsaW90aMOocXVlLiBJbCBlc3QgaWRpb21hdGlxdWUKICAgIC8vIGQnYXBwZWxlciBsZSBwcmVtaWVyIHBhcmFtw6h0cmUgYHNlbGZgIHNpIGxhIGZvbmN0aW9uIHBldXQKICAgIC8vIMOqdHJlIHZ1ZSBjb21tZSB1bmUgbcOpdGhvZGUgZGUgY2V0IG9iamV0LgogICAgZnVuY3Rpb24gaW5zZXJ0KERhdGEgc3RvcmFnZSBzZWxmLCB1aW50IHZhbHVlKQogICAgICAgIHB1YmxpYwogICAgICAgIHJldHVybnMgKGJvb2wpCiAgICB7CiAgICAgICAgaWYgKHNlbGYuZmxhZ3NbdmFsdWVdKQogICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGTDqWrDoCBsw6AKICAgICAgICBzZWxmLmZsYWdzW3ZhbHVlXSA9IHRydWU7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICB9CgogICAgZnVuY3Rpb24gcmVtb3ZlKERhdGEgc3RvcmFnZSBzZWxmLCB1aW50IHZhbHVlKQogICAgICAgIHB1YmxpYwogICAgICAgIHJldHVybnMgKGJvb2wpCiAgICB7CiAgICAgICAgaWYgKCFzZWxmLmZsYWdzW3ZhbHVlXSkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBwYXMgbMOgCiAgICAgICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSBmYWxzZTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBjb250YWlucyhEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgICAgICBwdWJsaWMKICAgICAgICB2aWV3CiAgICAgICAgcmV0dXJucyAoYm9vbCkKICAgIHsKICAgICAgICByZXR1cm4gc2VsZi5mbGFnc1t2YWx1ZV07CiAgICB9Cn0KCgpjb250cmFjdCBDIHsKICAgIERhdGEga25vd25WYWx1ZXM7CgogICAgZnVuY3Rpb24gcmVnaXN0ZXIodWludCB2YWx1ZSkgcHVibGljIHsKICAgICAgICAvLyBMZXMgZm9uY3Rpb25zIGRlIGxhIGJpYmxpb3Row6hxdWUgcGV1dmVudCDDqnRyZSBhcHBlbMOpZXMgc2FucyB1bmUKICAgICAgICAvLyBpbnN0YW5jZSBzcMOpY2lmaXF1ZSBkZSBsYSBiaWJsaW90aMOocXVlLCBwdWlzcXVlCiAgICAgICAgLy8gbCciaW5zdGFuY2UiIHNlcmEgbGUgY29udHJhdCBlbiBjb3Vycy4KICAgICAgICByZXF1aXJlKFNldC5pbnNlcnQoa25vd25WYWx1ZXMsIHZhbHVlKSk7CiAgICB9CiAgICAvLyBJbiB0aGlzIGNvbnRyYWN0LCB3ZSBjYW4gYWxzbyBkaXJlY3RseSBhY2Nlc3Mga25vd25WYWx1ZXMuZmxhZ3MsIGlmIHdlIHdhbnQuCn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
// Nous définissons un nouveau type de données struct qui sera utilisé pour
// contenir ses données dans le contrat d'appel.
struct Data {
 mapping(uint \=> bool) flags;
}
library Set {
 // Notez que le premier paramètre est de type
 // "référence de stockage" et donc seulement son adresse de stockage et pas
 // son contenu est transmis dans le cadre de l'appel. Il s'agit d'une
 // particularité des fonctions de bibliothèque. Il est idiomatique
 // d'appeler le premier paramètre \`self\` si la fonction peut
 // être vue comme une méthode de cet objet.
 function insert(Data storage self, uint value)
 public
 returns (bool)
 {
 if (self.flags\[value\])
 return false; // déjà là
 self.flags\[value\] \= true;
 return true;
 }
 function remove(Data storage self, uint value)
 public
 returns (bool)
 {
 if (!self.flags\[value\])
 return false; // pas là
 self.flags\[value\] \= false;
 return true;
 }
 function contains(Data storage self, uint value)
 public
 view
 returns (bool)
 {
 return self.flags\[value\];
 }
}
contract C {
 Data knownValues;
 function register(uint value) public {
 // Les fonctions de la bibliothèque peuvent être appelées sans une
 // instance spécifique de la bibliothèque, puisque
 // l'"instance" sera le contrat en cours.
 require(Set.insert(knownValues, value));
 }
 // In this contract, we can also directly access knownValues.flags, if we want.
}
Bien sûr, vous n’êtes pas obligé de suivre cette voie pour utiliser des bibliothèques : elles peuvent aussi être utilisées sans définir de type de données struct. Les fonctions fonctionnent également sans paramètres de de référence de stockage, et elles peuvent avoir plusieurs paramètres de référence et dans n’importe quelle position.
Les appels à `Set.contains`, `Set.insert` et `Set.remove` sont tous compilés en tant qu’appels (`DELEGATECALL`) à un contrat/librairie externe. Si vous utilisez des bibliothèques, soyez conscient qu’un appel à une fonction externe réelle est effectué. `msg.sender`, `msg.value` et `this` garderont leurs valeurs dans cet appel. (avant Homestead, à cause de l’utilisation de `CALLCODE`, `msg.sender` et `msg.value` changeaient, cependant).
L’exemple suivant montre comment utiliser les [types stockés dans la mémoire](https://docs.soliditylang.org/fr/latest/types.html#data-location) et les fonctions internes des bibliothèques afin d’implémenter des types personnalisés sans la surcharge des appels de fonctions externes :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMDsKCnN0cnVjdCBiaWdpbnQgewogICAgdWludFtdIGxpbWJzOwp9CgpsaWJyYXJ5IEJpZ0ludCB7CiAgICBmdW5jdGlvbiBmcm9tVWludCh1aW50IHgpIGludGVybmFsIHB1cmUgcmV0dXJucyAoYmlnaW50IG1lbW9yeSByKSB7CiAgICAgICAgci5saW1icyA9IG5ldyB1aW50W10oMSk7CiAgICAgICAgci5saW1ic1swXSA9IHg7CiAgICB9CgogICAgZnVuY3Rpb24gYWRkKGJpZ2ludCBtZW1vcnkgX2EsIGJpZ2ludCBtZW1vcnkgX2IpIGludGVybmFsIHB1cmUgcmV0dXJucyAoYmlnaW50IG1lbW9yeSByKSB7CiAgICAgICAgci5saW1icyA9IG5ldyB1aW50W10obWF4KF9hLmxpbWJzLmxlbmd0aCwgX2IubGltYnMubGVuZ3RoKSk7CiAgICAgICAgdWludCBjYXJyeSA9IDA7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgci5saW1icy5sZW5ndGg7ICsraSkgewogICAgICAgICAgICB1aW50IGEgPSBsaW1iKF9hLCBpKTsKICAgICAgICAgICAgdWludCBiID0gbGltYihfYiwgaSk7CiAgICAgICAgICAgIHVuY2hlY2tlZCB7CiAgICAgICAgICAgICAgICByLmxpbWJzW2ldID0gYSArIGIgKyBjYXJyeTsKCiAgICAgICAgICAgICAgICBpZiAoYSArIGIgPCBhIHx8IChhICsgYiA9PSB0eXBlKHVpbnQpLm1heCAmJiBjYXJyeSA+IDApKQogICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gMTsKICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICBjYXJyeSA9IDA7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKGNhcnJ5ID4gMCkgewogICAgICAgICAgICAvLyBkb21tYWdlLCBub3VzIGRldm9ucyBham91dGVyIHVuIG1lbWJyZQogICAgICAgICAgICB1aW50W10gbWVtb3J5IG5ld0xpbWJzID0gbmV3IHVpbnRbXShyLmxpbWJzLmxlbmd0aCArIDEpOwogICAgICAgICAgICB1aW50IGk7CiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByLmxpbWJzLmxlbmd0aDsgKytpKQogICAgICAgICAgICAgICAgbmV3TGltYnNbaV0gPSByLmxpbWJzW2ldOwogICAgICAgICAgICBuZXdMaW1ic1tpXSA9IGNhcnJ5OwogICAgICAgICAgICByLmxpbWJzID0gbmV3TGltYnM7CiAgICAgICAgfQogICAgfQoKICAgIGZ1bmN0aW9uIGxpbWIoYmlnaW50IG1lbW9yeSBfYSwgdWludCBfbGltYikgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIF9saW1iIDwgX2EubGltYnMubGVuZ3RoID8gX2EubGltYnNbX2xpbWJdIDogMDsKICAgIH0KCiAgICBmdW5jdGlvbiBtYXgodWludCBhLCB1aW50IGIpIHByaXZhdGUgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgPiBiID8gYSA6IGI7CiAgICB9Cn0KCmNvbnRyYWN0IEMgewogICAgdXNpbmcgQmlnSW50IGZvciBiaWdpbnQ7CgogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHsKICAgICAgICBiaWdpbnQgbWVtb3J5IHggPSBCaWdJbnQuZnJvbVVpbnQoNyk7CiAgICAgICAgYmlnaW50IG1lbW9yeSB5ID0gQmlnSW50LmZyb21VaW50KHR5cGUodWludCkubWF4KTsKICAgICAgICBiaWdpbnQgbWVtb3J5IHogPSB4LmFkZCh5KTsKICAgICAgICBhc3NlcnQoei5saW1iKDEpID4gMCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;
struct bigint {
 uint\[\] limbs;
}
library BigInt {
 function fromUint(uint x) internal pure returns (bigint memory r) {
 r.limbs \= new uint\[\](1);
 r.limbs\[0\] \= x;
 }
 function add(bigint memory \_a, bigint memory \_b) internal pure returns (bigint memory r) {
 r.limbs \= new uint\[\](max(\_a.limbs.length, \_b.limbs.length));
 uint carry \= 0;
 for (uint i \= 0; i < r.limbs.length; ++i) {
 uint a \= limb(\_a, i);
 uint b \= limb(\_b, i);
 unchecked {
 r.limbs\[i\] \= a + b + carry;
 if (a + b < a || (a + b \== type(uint).max && carry \> 0))
 carry \= 1;
 else
 carry \= 0;
 }
 }
 if (carry \> 0) {
 // dommage, nous devons ajouter un membre
 uint\[\] memory newLimbs \= new uint\[\](r.limbs.length + 1);
 uint i;
 for (i \= 0; i < r.limbs.length; ++i)
 newLimbs\[i\] \= r.limbs\[i\];
 newLimbs\[i\] \= carry;
 r.limbs \= newLimbs;
 }
 }
 function limb(bigint memory \_a, uint \_limb) internal pure returns (uint) {
 return \_limb < \_a.limbs.length ? \_a.limbs\[\_limb\] : 0;
 }
 function max(uint a, uint b) private pure returns (uint) {
 return a \> b ? a : b;
 }
}
contract C {
 using BigInt for bigint;
 function f() public pure {
 bigint memory x \= BigInt.fromUint(7);
 bigint memory y \= BigInt.fromUint(type(uint).max);
 bigint memory z \= x.add(y);
 assert(z.limb(1) \> 0);
 }
}
Il est possible d’obtenir l’adresse d’une bibliothèque en convertissant le type de la bibliothèque en type `adress`, c’est-à-dire en utilisant `address(LibraryName)`.
Comme le compilateur ne connaît pas l’adresse à laquelle la bibliothèque sera déployée, le code hexadécimal compilé contiendra des caractères de remplacement de la forme `__$30bbc0abd4d6364515865950d3e0d10953$__`. Le caractère de remplacement est un préfixe de 34 caractères de l’encodage hexadécimal du hachage keccak256 du nom de bibliothèque pleinement qualifié, qui serait par exemple `libraries/bigint.sol:BigInt` si la bibliothèque était stockée dans un fichier appelé `bigint.sol` dans un répertoire `libraries/`. Un tel bytecode est incomplet et ne devrait pas être déployé. Les placeholders doivent être remplacés par des adresses réelles. Vous pouvez le faire soit en passant au compilateur lors de la compilation de la bibliothèque ou en utilisant l’éditeur de liens pour mettre à jour un binaire déjà compilé. Voir [Liens entre les bibliothèques](https://docs.soliditylang.org/fr/latest/using-the-compiler.html#library-linking) pour des informations sur la façon d’utiliser le compilateur en ligne de commande pour la liaison.
Par rapport aux contrats, les bibliothèques sont limitées de la manière suivante :
* elles ne peuvent pas avoir de variables d’état
 
* elles ne peuvent ni hériter ni être héritées
 
* elles ne peuvent pas recevoir d’éther
 
* elles ne peuvent pas être détruites
 
(Ces restrictions pourraient être levées ultérieurement).
### Signatures de fonction et sélecteurs dans les bibliothèques[](#signatures-de-fonction-et-selecteurs-dans-les-bibliotheques "Lien permanent vers cette rubrique")
Bien que les appels externes à des fonctions de bibliothèques publiques ou externes soient possibles, la convention d’appel pour de tels appels est considérée comme interne à Solidity et n’est pas la même que celle spécifiée pour la fonction ordinaire du [contrat ABI](https://docs.soliditylang.org/fr/latest/abi-spec.html#abi). Les fonctions de bibliothèque externes supportent plus de types d’arguments que les fonctions de contrat externes, par exemple les structs récursifs et les pointeurs de stockage. Pour cette raison, les signatures de fonctions utilisées pour calculer le sélecteur à 4 octets sont calculées selon un schéma de dénomination interne et les arguments de types non pris en charge par l’ABI du contrat utilisent un encodage interne.
Les identifiants suivants sont utilisés pour les types dans les signatures :
* Les types de valeurs, les `string` non stockées et les `bytes` non stockés utilisent les mêmes identifiants que dans l’ABI du contrat.
 
* Les types de tableaux non stockés suivent la même convention que dans l’ABI du contrat, c’est-à-dire `<type>[]` pour les tableaux dynamiques et `<type>[M]` pour les tableaux de taille fixe de `M` éléments.
 
* Les structures non stockées sont désignées par leur nom complet, c’est-à-dire `C.S` pour `contrat C { struct S { ... } }`.
 
* Les mappages de pointeurs de stockage utilisent `mapping(<keyType> => <valueType>) storage` où `<keyType>` et `<valueType>` sont sont les identificateurs des types de clé et de valeur du mappage, respectivement.
 
* Les autres types de pointeurs de stockage utilisent l’identificateur de type de leur type non stocké correspondant, mais ajoutent un espace unique suivi de `storage`.
 
Le codage des arguments est le même que pour l’ABI des contrats ordinaires, sauf pour les pointeurs de stockage, qui sont codés en tant que `uint256` faisant référence à l’emplacement de stockage vers lequel ils pointent.
Comme pour l’ABI du contrat, le sélecteur est constitué des quatre premiers octets du Keccak256-hash de la signature. Sa valeur peut être obtenue à partir de Solidity en utilisant le membre `.selector` comme suit :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjE0IDwwLjkuMDsKCmxpYnJhcnkgTCB7CiAgICBmdW5jdGlvbiBmKHVpbnQyNTYpIGV4dGVybmFsIHt9Cn0KCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZygpIHB1YmxpYyBwdXJlIHJldHVybnMgKGJ5dGVzNCkgewogICAgICAgIHJldHVybiBMLmYuc2VsZWN0b3I7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.14 <0.9.0;
library L {
 function f(uint256) external {}
}
contract C {
 function g() public pure returns (bytes4) {
 return L.f.selector;
 }
}
### Protection d’appel pour les bibliothèques[](#protection-d-appel-pour-les-bibliotheques "Lien permanent vers cette rubrique")
Comme mentionné dans l’introduction, si le code d’une bibliothèque est exécuté en utilisant un `CALL` au lieu d’un `DELEGATECALL` ou `CALLCODE`, il se réverbère sauf si une fonction `view` ou `pure` est appelée.
L’EVM ne fournit pas de moyen direct pour qu’un contrat puisse détecter s’il a été appelé en utilisant `CALL` ou non, mais un contrat mais un contrat peut utiliser l’opcode `ADDRESS` pour savoir « où » il est actuellement en cours d’exécution. Le code généré compare cette adresse à l’adresse utilisée au moment de la construction pour déterminer le mode d’appel.
Plus spécifiquement, le code d’exécution d’une bibliothèque commence toujours par une instruction push, qui est un zéro de 20 octets au moment de la compilation. Lorsque le code déployé s’exécute, cette constante est remplacée en mémoire par l’adresse actuelle et ce code modifié est stocké dans le contrat. Au moment de l’exécution, cela fait en sorte que l’adresse du moment du déploiement soit la première constante à être poussée sur la pile et le code du distributeur compare l’adresse actuelle à cette constante pour toute fonction non-visible et non pure.
Cela signifie que le code réel stocké sur la chaîne pour une bibliothèque est différent du code rapporté par le compilateur en tant que `deployedBytecode`.
## Utiliser For[](#utiliser-for "Lien permanent vers cette rubrique")
La directive `using A for B;` peut être utilisée pour attacher des fonctions (de la bibliothèque `A`) à n’importe quel type (`B`) dans le contexte d’un contrat. Ces fonctions recevront l’objet sur lequel elles sont appelées comme premier paramètre (comme la variable `self` en Python).
L’effet de `using A for *;` est que les fonctions de la bibliothèque `A` sont attachées à _tout_ type.
Dans les deux cas, _toutes_ les fonctions de la bibliothèque sont attachées, même celles pour lesquelles le type du premier paramètre ne correspond pas au type de l’objet. Le type est vérifié au moment où la fonction est appelée et la résolution de surcharge de fonction est effectuée.
La directive `using A pour B;` n’est active que dans le contrat actuel, y compris au sein de toutes ses fonctions, et n’a aucun effet en dehors du contrat dans lequel elle est utilisée. La directive ne peut être utilisée qu’à l’intérieur d’un contrat, et non à l’intérieur de l’une de ses fonctions.
Réécrivons l’exemple de l’ensemble à partir de la directive [Bibliothèques](#libraries) de cette manière :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKCi8vIElsIHMnYWdpdCBkdSBtw6ptZSBjb2RlIHF1ZSBwcsOpY8OpZGVtbWVudCwgbWFpcyBzYW5zIGNvbW1lbnRhaXJlcy4Kc3RydWN0IERhdGEgeyBtYXBwaW5nKHVpbnQgPT4gYm9vbCkgZmxhZ3M7IH0KCmxpYnJhcnkgU2V0IHsKICAgIGZ1bmN0aW9uIGluc2VydChEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgICAgICBwdWJsaWMKICAgICAgICByZXR1cm5zIChib29sKQogICAgewogICAgICAgIGlmIChzZWxmLmZsYWdzW3ZhbHVlXSkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBkw6lqw6AgbMOgCiAgICAgICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSB0cnVlOwogICAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICAgIGZ1bmN0aW9uIHJlbW92ZShEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgICAgICBwdWJsaWMKICAgICAgICByZXR1cm5zIChib29sKQogICAgewogICAgICAgIGlmICghc2VsZi5mbGFnc1t2YWx1ZV0pCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gcGFzIGzDoAogICAgICAgIHNlbGYuZmxhZ3NbdmFsdWVdID0gZmFsc2U7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICB9CgogICAgZnVuY3Rpb24gY29udGFpbnMoRGF0YSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICAgICAgcHVibGljCiAgICAgICAgdmlldwogICAgICAgIHJldHVybnMgKGJvb2wpCiAgICB7CiAgICAgICAgcmV0dXJuIHNlbGYuZmxhZ3NbdmFsdWVdOwogICAgfQp9CgoKY29udHJhY3QgQyB7CiAgICB1c2luZyBTZXQgZm9yIERhdGE7IC8vIGMnZXN0IGxlIGNoYW5nZW1lbnQgY3J1Y2lhbAogICAgRGF0YSBrbm93blZhbHVlczsKCiAgICBmdW5jdGlvbiByZWdpc3Rlcih1aW50IHZhbHVlKSBwdWJsaWMgewogICAgICAgIC8vIEljaSwgdG91dGVzIGxlcyB2YXJpYWJsZXMgZGUgdHlwZSBEYXRhIG9udAogICAgICAgIC8vIGRlcyBmb25jdGlvbnMgbWVtYnJlcyBjb3JyZXNwb25kYW50ZXMuCiAgICAgICAgLy8gTCdhcHBlbCBkZSBmb25jdGlvbiBzdWl2YW50IGVzdCBpZGVudGlxdWUgw6AKICAgICAgICAvLyBgU2V0Lmluc2VydChrbm93blZhbHVlcywgdmFsdWUpYAogICAgICAgIHJlcXVpcmUoa25vd25WYWx1ZXMuaW5zZXJ0KHZhbHVlKSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
// Il s'agit du même code que précédemment, mais sans commentaires.
struct Data { mapping(uint \=> bool) flags; }
library Set {
 function insert(Data storage self, uint value)
 public
 returns (bool)
 {
 if (self.flags\[value\])
 return false; // déjà là
 self.flags\[value\] \= true;
 return true;
 }
 function remove(Data storage self, uint value)
 public
 returns (bool)
 {
 if (!self.flags\[value\])
 return false; // pas là
 self.flags\[value\] \= false;
 return true;
 }
 function contains(Data storage self, uint value)
 public
 view
 returns (bool)
 {
 return self.flags\[value\];
 }
}
contract C {
 using Set for Data; // c'est le changement crucial
 Data knownValues;
 function register(uint value) public {
 // Ici, toutes les variables de type Data ont
 // des fonctions membres correspondantes.
 // L'appel de fonction suivant est identique à
 // \`Set.insert(knownValues, value)\`
 require(knownValues.insert(value));
 }
}
Il est également possible d’étendre les types élémentaires de cette manière :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjggPDAuOS4wOwoKbGlicmFyeSBTZWFyY2ggewogICAgZnVuY3Rpb24gaW5kZXhPZih1aW50W10gc3RvcmFnZSBzZWxmLCB1aW50IHZhbHVlKQogICAgICAgIHB1YmxpYwogICAgICAgIHZpZXcKICAgICAgICByZXR1cm5zICh1aW50KQogICAgewogICAgICAgIGZvciAodWludCBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspCiAgICAgICAgICAgIGlmIChzZWxmW2ldID09IHZhbHVlKSByZXR1cm4gaTsKICAgICAgICByZXR1cm4gdHlwZSh1aW50KS5tYXg7CiAgICB9Cn0KCmNvbnRyYWN0IEMgewogICAgdXNpbmcgU2VhcmNoIGZvciB1aW50W107CiAgICB1aW50W10gZGF0YTsKCiAgICBmdW5jdGlvbiBhcHBlbmQodWludCB2YWx1ZSkgcHVibGljIHsKICAgICAgICBkYXRhLnB1c2godmFsdWUpOwogICAgfQoKICAgIGZ1bmN0aW9uIHJlcGxhY2UodWludCBfb2xkLCB1aW50IF9uZXcpIHB1YmxpYyB7CiAgICAgICAgLy8gQ2V0dGUgb3DDqXJhdGlvbiBlZmZlY3R1ZSBsJ2FwcGVsIGRlIGxhIGZvbmN0aW9uIGRlIGJpYmxpb3Row6hxdWUKICAgICAgICB1aW50IGluZGV4ID0gZGF0YS5pbmRleE9mKF9vbGQpOwogICAgICAgIGlmIChpbmRleCA9PSB0eXBlKHVpbnQpLm1heCkKICAgICAgICAgICAgZGF0YS5wdXNoKF9uZXcpOwogICAgICAgIGVsc2UKICAgICAgICAgICAgZGF0YVtpbmRleF0gPSBfbmV3OwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.8 <0.9.0;
library Search {
 function indexOf(uint\[\] storage self, uint value)
 public
 view
 returns (uint)
 {
 for (uint i \= 0; i < self.length; i++)
 if (self\[i\] \== value) return i;
 return type(uint).max;
 }
}
contract C {
 using Search for uint\[\];
 uint\[\] data;
 function append(uint value) public {
 data.push(value);
 }
 function replace(uint \_old, uint \_new) public {
 // Cette opération effectue l'appel de la fonction de bibliothèque
 uint index \= data.indexOf(\_old);
 if (index \== type(uint).max)
 data.push(\_new);
 else
 data\[index\] \= \_new;
 }
}
Notez que tous les appels de bibliothèque externes sont des appels de fonction EVM réels. Cela signifie que si vous passez des types de mémoire ou de valeur, une copie sera effectuée, même de la variable `self`. La seule situation où aucune copie ne sera effectuée est l’utilisation de variables de référence de stockage ou l’appel de fonctions de bibliothèque internes sont appelées.

# [Translation not found - Read the Docs Community](https://docs.soliditylang.org/zh/latest/) 
 _https://docs.soliditylang.org/zh/latest/_

404 Translation not found
[docs.soliditylang.org](https://docs.soliditylang.org/)
The translation you requested does not exist or may have been removed.

# [Analysing the Compiler Output — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/analysing-compilation-output.html) 
 _https://docs.soliditylang.org/tr/latest/analysing-compilation-output.html_

It is often useful to look at the assembly code generated by the compiler. The generated binary, i.e., the output of `solc --bin contract.sol`, is generally difficult to read. It is recommended to use the flag `--asm` to analyse the assembly output. Even for large contracts, looking at a visual diff of the assembly before and after a change is often very enlightening.
Consider the following contract (named, say `contract.sol`):
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwpjb250cmFjdCBDIHsKICAgIGZ1bmN0aW9uIG9uZSgpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4gMTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
contract C {
 function one() public pure returns (uint) {
 return 1;
 }
}
The following would be the output of `solc --asm contract.sol`
\======= contract.sol:C =======
EVM assembly:
 /\* "contract.sol":0:86 contract C {... \*/
 mstore(0x40, 0x80)
 callvalue
 dup1
 iszero
 tag\_1
 jumpi
 0x00
 dup1
 revert
tag\_1:
 pop
 dataSize(sub\_0)
 dup1
 dataOffset(sub\_0)
 0x00
 codecopy
 0x00
 return
stop
sub\_0: assembly {
 /\* "contract.sol":0:86 contract C {... \*/
 mstore(0x40, 0x80)
 callvalue
 dup1
 iszero
 tag\_1
 jumpi
 0x00
 dup1
 revert
 tag\_1:
 pop
 jumpi(tag\_2, lt(calldatasize, 0x04))
 shr(0xe0, calldataload(0x00))
 dup1
 0x901717d1
 eq
 tag\_3
 jumpi
 tag\_2:
 0x00
 dup1
 revert
 /\* "contract.sol":17:84 function one() public pure returns (uint) {... \*/
 tag\_3:
 tag\_4
 tag\_5
 jump // in
 tag\_4:
 mload(0x40)
 tag\_6
 swap2
 swap1
 tag\_7
 jump // in
 tag\_6:
 mload(0x40)
 dup1
 swap2
 sub
 swap1
 return
 tag\_5:
 /\* "contract.sol":53:57 uint \*/
 0x00
 /\* "contract.sol":76:77 1 \*/
 0x01
 /\* "contract.sol":69:77 return 1 \*/
 swap1
 pop
 /\* "contract.sol":17:84 function one() public pure returns (uint) {... \*/
 swap1
 jump // out
 /\* "#utility.yul":7:125 \*/
 tag\_10:
 /\* "#utility.yul":94:118 \*/
 tag\_12
 /\* "#utility.yul":112:117 \*/
 dup2
 /\* "#utility.yul":94:118 \*/
 tag\_13
 jump // in
 tag\_12:
 /\* "#utility.yul":89:92 \*/
 dup3
 /\* "#utility.yul":82:119 \*/
 mstore
 /\* "#utility.yul":72:125 \*/
 pop
 pop
 jump // out
 /\* "#utility.yul":131:353 \*/
 tag\_7:
 0x00
 /\* "#utility.yul":262:264 \*/
 0x20
 /\* "#utility.yul":251:260 \*/
 dup3
 /\* "#utility.yul":247:265 \*/
 add
 /\* "#utility.yul":239:265 \*/
 swap1
 pop
 /\* "#utility.yul":275:346 \*/
 tag\_15
 /\* "#utility.yul":343:344 \*/
 0x00
 /\* "#utility.yul":332:341 \*/
 dup4
 /\* "#utility.yul":328:345 \*/
 add
 /\* "#utility.yul":319:325 \*/
 dup5
 /\* "#utility.yul":275:346 \*/
 tag\_10
 jump // in
 tag\_15:
 /\* "#utility.yul":229:353 \*/
 swap3
 swap2
 pop
 pop
 jump // out
 /\* "#utility.yul":359:436 \*/
 tag\_13:
 0x00
 /\* "#utility.yul":425:430 \*/
 dup2
 /\* "#utility.yul":414:430 \*/
 swap1
 pop
 /\* "#utility.yul":404:436 \*/
 swap2
 swap1
 pop
 jump // out
 auxdata: 0xa2646970667358221220a5874f19737ddd4c5d77ace1619e5160c67b3d4bedac75fce908fed32d98899864736f6c637827302e382e342d646576656c6f702e323032312e332e33302b636f6d6d69742e65613065363933380058
}
Alternatively, the above output can also be obtained from [Remix](https://remix.ethereum.org/), under the option “Compilation Details” after compiling a contract.
Notice that the `asm` output starts with the creation / constructor code. The deploy code is provided as part of the sub object (in the above example, it is part of the sub-object `sub_0`). The `auxdata` field corresponds to the contract [metadata](https://docs.soliditylang.org/tr/latest/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode). The comments in the assembly output point to the source location. Note that ＃utility.yul is an internally generated file of utility functions that can be obtained using the flags `--combined-json generated-sources,generated-sources-runtime`.
Similarly, the optimized assembly can be obtained with the command: `solc --optimize --asm contract.sol`. Often times, it is interesting to see if two different sources in Solidity result in the same optimized code. For example, to see if the expressions `(a * b) / c`, `a * b / c` generates the same bytecode. This can be easily done by taking a `diff` of the corresponding assembly output, after potentially stripping comments that reference the source locations.
Not
The `--asm` output is not designed to be machine readable. Therefore, there may be breaking changes on the output between minor versions of solc.

# [SMTChecker and Formal Verification — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/smtchecker.html) 
 _https://docs.soliditylang.org/tr/latest/smtchecker.html_

Using formal verification it is possible to perform an automated mathematical proof that your source code fulfills a certain formal specification. The specification is still formal (just as the source code), but usually much simpler.
Note that formal verification itself can only help you understand the difference between what you did (the specification) and how you did it (the actual implementation). You still need to check whether the specification is what you wanted and that you did not miss any unintended effects of it.
Solidity implements a formal verification approach based on [SMT (Satisfiability Modulo Theories)](https://en.wikipedia.org/wiki/Satisfiability_modulo_theories) and [Horn](https://en.wikipedia.org/wiki/Horn-satisfiability) solving. The SMTChecker module automatically tries to prove that the code satisfies the specification given by `require` and `assert` statements. That is, it considers `require` statements as assumptions and tries to prove that the conditions inside `assert` statements are always true. If an assertion failure is found, a counterexample may be given to the user showing how the assertion can be violated. If no warning is given by the SMTChecker for a property, it means that the property is safe.
The other verification targets that the SMTChecker checks at compile time are:
* Arithmetic underflow and overflow.
 
* Division by zero.
 
* Trivial conditions and unreachable code.
 
* Popping an empty array.
 
* Out of bounds index access.
 
* Insufficient funds for a transfer.
 
All the targets above are automatically checked by default if all engines are enabled, except underflow and overflow for Solidity >=0.8.7.
The potential warnings that the SMTChecker reports are:
* `<failing  property> happens here.`. This means that the SMTChecker proved that a certain property fails. A counterexample may be given, however in complex situations it may also not show a counterexample. This result may also be a false positive in certain cases, when the SMT encoding adds abstractions for Solidity code that is either hard or impossible to express.
 
* `<failing property> might happen here`. This means that the solver could not prove either case within the given timeout. Since the result is unknown, the SMTChecker reports the potential failure for soundness. This may be solved by increasing the query timeout, but the problem might also simply be too hard for the engine to solve.
 
To enable the SMTChecker, you must select [which engine should run](#smtchecker-engines), where the default is no engine. Selecting the engine enables the SMTChecker on all files.
Not
Prior to Solidity 0.8.4, the default way to enable the SMTChecker was via `pragma experimental SMTChecker;` and only the contracts containing the pragma would be analyzed. That pragma has been deprecated, and although it still enables the SMTChecker for backwards compatibility, it will be removed in Solidity 0.9.0. Note also that now using the pragma even in a single file enables the SMTChecker for all files.
Not
The lack of warnings for a verification target represents an undisputed mathematical proof of correctness, assuming no bugs in the SMTChecker and the underlying solver. Keep in mind that these problems are _very hard_ and sometimes _impossible_ to solve automatically in the general case. Therefore, several properties might not be solved or might lead to false positives for large contracts. Every proven property should be seen as an important achievement. For advanced users, see [SMTChecker Tuning](#smtchecker-options) to learn a few options that might help proving more complex properties.
## Tutorial[](#tutorial "Permalink to this heading")
### Overflow[](#overflow "Permalink to this heading")
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBPdmVyZmxvdyB7CiAgICB1aW50IGltbXV0YWJsZSB4OwogICAgdWludCBpbW11dGFibGUgeTsKCiAgICBmdW5jdGlvbiBhZGQodWludCB4XywgdWludCB5XykgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIHhfICsgeV87CiAgICB9CgogICAgY29uc3RydWN0b3IodWludCB4XywgdWludCB5XykgewogICAgICAgICh4LCB5KSA9ICh4XywgeV8pOwogICAgfQoKICAgIGZ1bmN0aW9uIHN0YXRlQWRkKCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBhZGQoeCwgeSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Overflow {
 uint immutable x;
 uint immutable y;
 function add(uint x\_, uint y\_) internal pure returns (uint) {
 return x\_ + y\_;
 }
 constructor(uint x\_, uint y\_) {
 (x, y) \= (x\_, y\_);
 }
 function stateAdd() public view returns (uint) {
 return add(x, y);
 }
}
The contract above shows an overflow check example. The SMTChecker does not check underflow and overflow by default for Solidity >=0.8.7, so we need to use the command line option `--model-checker-targets "underflow,overflow"` or the JSON option `settings.modelChecker.targets = ["underflow", "overflow"]`. See [this section for targets configuration](#smtchecker-targets). Here, it reports the following:
Warning: CHC: Overflow (resulting value larger than 2\*\*256 - 1) happens here.
Counterexample:
x = 1, y = 115792089237316195423570985008687907853269984665640564039457584007913129639935
 = 0
Transaction trace:
Overflow.constructor(1, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
State: x = 1, y = 115792089237316195423570985008687907853269984665640564039457584007913129639935
Overflow.stateAdd()
 Overflow.add(1, 115792089237316195423570985008687907853269984665640564039457584007913129639935) -- internal call
 --> o.sol:9:20:
 |
9 | return x\_ + y\_;
 | ^^^^^^^
If we add `require` statements that filter out overflow cases, the SMTChecker proves that no overflow is reachable (by not reporting warnings):
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBPdmVyZmxvdyB7CiAgICB1aW50IGltbXV0YWJsZSB4OwogICAgdWludCBpbW11dGFibGUgeTsKCiAgICBmdW5jdGlvbiBhZGQodWludCB4XywgdWludCB5XykgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIHhfICsgeV87CiAgICB9CgogICAgY29uc3RydWN0b3IodWludCB4XywgdWludCB5XykgewogICAgICAgICh4LCB5KSA9ICh4XywgeV8pOwogICAgfQoKICAgIGZ1bmN0aW9uIHN0YXRlQWRkKCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJlcXVpcmUoeCA8IHR5cGUodWludDEyOCkubWF4KTsKICAgICAgICByZXF1aXJlKHkgPCB0eXBlKHVpbnQxMjgpLm1heCk7CiAgICAgICAgcmV0dXJuIGFkZCh4LCB5KTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Overflow {
 uint immutable x;
 uint immutable y;
 function add(uint x\_, uint y\_) internal pure returns (uint) {
 return x\_ + y\_;
 }
 constructor(uint x\_, uint y\_) {
 (x, y) \= (x\_, y\_);
 }
 function stateAdd() public view returns (uint) {
 require(x < type(uint128).max);
 require(y < type(uint128).max);
 return add(x, y);
 }
}
### Assert[](#assert "Permalink to this heading")
An assertion represents an invariant in your code: a property that must be true _for all transactions, including all input and storage values_, otherwise there is a bug.
The code below defines a function `f` that guarantees no overflow. Function `inv` defines the specification that `f` is monotonically increasing: for every possible pair `(a, b)`, if `b > a` then `f(b) > f(a)`. Since `f` is indeed monotonically increasing, the SMTChecker proves that our property is correct. You are encouraged to play with the property and the function definition to see what results come out!
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBNb25vdG9uaWMgewogICAgZnVuY3Rpb24gZih1aW50IHgpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJlcXVpcmUoeCA8IHR5cGUodWludDEyOCkubWF4KTsKICAgICAgICByZXR1cm4geCAqIDQyOwogICAgfQoKICAgIGZ1bmN0aW9uIGludih1aW50IGEsIHVpbnQgYikgcHVibGljIHB1cmUgewogICAgICAgIHJlcXVpcmUoYiA+IGEpOwogICAgICAgIGFzc2VydChmKGIpID4gZihhKSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Monotonic {
 function f(uint x) internal pure returns (uint) {
 require(x < type(uint128).max);
 return x \* 42;
 }
 function inv(uint a, uint b) public pure {
 require(b \> a);
 assert(f(b) \> f(a));
 }
}
We can also add assertions inside loops to verify more complicated properties. The following code searches for the maximum element of an unrestricted array of numbers, and asserts the property that the found element must be greater or equal every element in the array.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBNYXggewogICAgZnVuY3Rpb24gbWF4KHVpbnRbXSBtZW1vcnkgYSkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHVpbnQgbSA9IDA7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkKICAgICAgICAgICAgaWYgKGFbaV0gPiBtKQogICAgICAgICAgICAgICAgbSA9IGFbaV07CgogICAgICAgIGZvciAodWludCBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpCiAgICAgICAgICAgIGFzc2VydChtID49IGFbaV0pOwoKICAgICAgICByZXR1cm4gbTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Max {
 function max(uint\[\] memory a) public pure returns (uint) {
 uint m \= 0;
 for (uint i \= 0; i < a.length; ++i)
 if (a\[i\] \> m)
 m \= a\[i\];
 for (uint i \= 0; i < a.length; ++i)
 assert(m \>= a\[i\]);
 return m;
 }
}
Note that in this example the SMTChecker will automatically try to prove three properties:
1. `++i` in the first loop does not overflow.
 
2. `++i` in the second loop does not overflow.
 
3. The assertion is always true.
 
Not
The properties involve loops, which makes it _much much_ harder than the previous examples, so beware of loops!
All the properties are correctly proven safe. Feel free to change the properties and/or add restrictions on the array to see different results. For example, changing the code to
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBNYXggewogICAgZnVuY3Rpb24gbWF4KHVpbnRbXSBtZW1vcnkgYSkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJlcXVpcmUoYS5sZW5ndGggPj0gNSk7CiAgICAgICAgdWludCBtID0gMDsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKQogICAgICAgICAgICBpZiAoYVtpXSA+IG0pCiAgICAgICAgICAgICAgICBtID0gYVtpXTsKCiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkKICAgICAgICAgICAgYXNzZXJ0KG0gPiBhW2ldKTsKCiAgICAgICAgcmV0dXJuIG07CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Max {
 function max(uint\[\] memory a) public pure returns (uint) {
 require(a.length \>= 5);
 uint m \= 0;
 for (uint i \= 0; i < a.length; ++i)
 if (a\[i\] \> m)
 m \= a\[i\];
 for (uint i \= 0; i < a.length; ++i)
 assert(m \> a\[i\]);
 return m;
 }
}
gives us:
Warning: CHC: Assertion violation happens here.
Counterexample:
a = \[0, 0, 0, 0, 0\]
 = 0
Transaction trace:
Test.constructor()
Test.max(\[0, 0, 0, 0, 0\])
 --> max.sol:14:4:
 |
14 | assert(m > a\[i\]);
### State Properties[](#state-properties "Permalink to this heading")
So far the examples only demonstrated the use of the SMTChecker over pure code, proving properties about specific operations or algorithms. A common type of properties in smart contracts are properties that involve the state of the contract. Multiple transactions might be needed to make an assertion fail for such a property.
As an example, consider a 2D grid where both axis have coordinates in the range (-2^128, 2^128 - 1). Let us place a robot at position (0, 0). The robot can only move diagonally, one step at a time, and cannot move outside the grid. The robot’s state machine can be represented by the smart contract below.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBSb2JvdCB7CiAgICBpbnQgeCA9IDA7CiAgICBpbnQgeSA9IDA7CgogICAgbW9kaWZpZXIgd2FsbCB7CiAgICAgICAgcmVxdWlyZSh4ID4gdHlwZShpbnQxMjgpLm1pbiAmJiB4IDwgdHlwZShpbnQxMjgpLm1heCk7CiAgICAgICAgcmVxdWlyZSh5ID4gdHlwZShpbnQxMjgpLm1pbiAmJiB5IDwgdHlwZShpbnQxMjgpLm1heCk7CiAgICAgICAgXzsKICAgIH0KCiAgICBmdW5jdGlvbiBtb3ZlTGVmdFVwKCkgd2FsbCBwdWJsaWMgewogICAgICAgIC0teDsKICAgICAgICArK3k7CiAgICB9CgogICAgZnVuY3Rpb24gbW92ZUxlZnREb3duKCkgd2FsbCBwdWJsaWMgewogICAgICAgIC0teDsKICAgICAgICAtLXk7CiAgICB9CgogICAgZnVuY3Rpb24gbW92ZVJpZ2h0VXAoKSB3YWxsIHB1YmxpYyB7CiAgICAgICAgKyt4OwogICAgICAgICsreTsKICAgIH0KCiAgICBmdW5jdGlvbiBtb3ZlUmlnaHREb3duKCkgd2FsbCBwdWJsaWMgewogICAgICAgICsreDsKICAgICAgICAtLXk7CiAgICB9CgogICAgZnVuY3Rpb24gaW52KCkgcHVibGljIHZpZXcgewogICAgICAgIGFzc2VydCgoeCArIHkpICUgMiA9PSAwKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Robot {
 int x \= 0;
 int y \= 0;
 modifier wall {
 require(x \> type(int128).min && x < type(int128).max);
 require(y > type(int128).min && y < type(int128).max);
 \_;
 }
 function moveLeftUp() wall public {
 \--x;
 ++y;
 }
 function moveLeftDown() wall public {
 \--x;
 \--y;
 }
 function moveRightUp() wall public {
 ++x;
 ++y;
 }
 function moveRightDown() wall public {
 ++x;
 \--y;
 }
 function inv() public view {
 assert((x + y) % 2 \== 0);
 }
}
Function `inv` represents an invariant of the state machine that `x + y` must be even. The SMTChecker manages to prove that regardless how many commands we give the robot, even if infinitely many, the invariant can _never_ fail. The interested reader may want to prove that fact manually as well. Hint: this invariant is inductive.
We can also trick the SMTChecker into giving us a path to a certain position we think might be reachable. We can add the property that (2, 4) is _not_ reachable, by adding the following function.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=ZnVuY3Rpb24gcmVhY2hfMl80KCkgcHVibGljIHZpZXcgewogICAgYXNzZXJ0KCEoeCA9PSAyICYmIHkgPT0gNCkpOwp9)
function reach\_2\_4() public view {
 assert(!(x \== 2 && y \== 4));
}
This property is false, and while proving that the property is false, the SMTChecker tells us exactly _how_ to reach (2, 4):
Warning: CHC: Assertion violation happens here.
Counterexample:
x = 2, y = 4
Transaction trace:
Robot.constructor()
State: x = 0, y = 0
Robot.moveLeftUp()
State: x = (- 1), y = 1
Robot.moveRightUp()
State: x = 0, y = 2
Robot.moveRightUp()
State: x = 1, y = 3
Robot.moveRightUp()
State: x = 2, y = 4
Robot.reach\_2\_4()
 --> r.sol:35:4:
 |
35 | assert(!(x == 2 && y == 4));
 | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
Note that the path above is not necessarily deterministic, as there are other paths that could reach (2, 4). The choice of which path is shown might change depending on the used solver, its version, or just randomly.
### External Calls and Reentrancy[](#external-calls-and-reentrancy "Permalink to this heading")
Every external call is treated as a call to unknown code by the SMTChecker. The reasoning behind that is that even if the code of the called contract is available at compile time, there is no guarantee that the deployed contract will indeed be the same as the contract where the interface came from at compile time.
In some cases, it is possible to automatically infer properties over state variables that are still true even if the externally called code can do anything, including reenter the caller contract.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7CgppbnRlcmZhY2UgVW5rbm93biB7CiAgICBmdW5jdGlvbiBydW4oKSBleHRlcm5hbDsKfQoKY29udHJhY3QgTXV0ZXggewogICAgdWludCB4OwogICAgYm9vbCBsb2NrOwoKICAgIFVua25vd24gaW1tdXRhYmxlIHVua25vd247CgogICAgY29uc3RydWN0b3IoVW5rbm93biB1KSB7CiAgICAgICAgcmVxdWlyZShhZGRyZXNzKHUpICE9IGFkZHJlc3MoMCkpOwogICAgICAgIHVua25vd24gPSB1OwogICAgfQoKICAgIG1vZGlmaWVyIG11dGV4IHsKICAgICAgICByZXF1aXJlKCFsb2NrKTsKICAgICAgICBsb2NrID0gdHJ1ZTsKICAgICAgICBfOwogICAgICAgIGxvY2sgPSBmYWxzZTsKICAgIH0KCiAgICBmdW5jdGlvbiBzZXQodWludCB4XykgbXV0ZXggcHVibGljIHsKICAgICAgICB4ID0geF87CiAgICB9CgogICAgZnVuY3Rpb24gcnVuKCkgbXV0ZXggcHVibGljIHsKICAgICAgICB1aW50IHhQcmUgPSB4OwogICAgICAgIHVua25vd24ucnVuKCk7CiAgICAgICAgYXNzZXJ0KHhQcmUgPT0geCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
interface Unknown {
 function run() external;
}
contract Mutex {
 uint x;
 bool lock;
 Unknown immutable unknown;
 constructor(Unknown u) {
 require(address(u) != address(0));
 unknown \= u;
 }
 modifier mutex {
 require(!lock);
 lock \= true;
 \_;
 lock \= false;
 }
 function set(uint x\_) mutex public {
 x \= x\_;
 }
 function run() mutex public {
 uint xPre \= x;
 unknown.run();
 assert(xPre \== x);
 }
}
The example above shows a contract that uses a mutex flag to forbid reentrancy. The solver is able to infer that when `unknown.run()` is called, the contract is already “locked”, so it would not be possible to change the value of `x`, regardless of what the unknown called code does.
If we “forget” to use the `mutex` modifier on function `set`, the SMTChecker is able to synthesize the behaviour of the externally called code so that the assertion fails:
Warning: CHC: Assertion violation happens here.
Counterexample:
x = 1, lock = true, unknown = 1
Transaction trace:
Mutex.constructor(1)
State: x = 0, lock = false, unknown = 1
Mutex.run()
 unknown.run() -- untrusted external call, synthesized as:
 Mutex.set(1) -- reentrant call
 --> m.sol:32:3:
 |
32 | assert(xPre == x);
 | ^^^^^^^^^^^^^^^^^
## SMTChecker Options and Tuning[](#smtchecker-options-and-tuning "Permalink to this heading")
### Timeout[](#timeout "Permalink to this heading")
The SMTChecker uses a hardcoded resource limit (`rlimit`) chosen per solver, which is not precisely related to time. We chose the `rlimit` option as the default because it gives more determinism guarantees than time inside the solver.
This options translates roughly to “a few seconds timeout” per query. Of course many properties are very complex and need a lot of time to be solved, where determinism does not matter. If the SMTChecker does not manage to solve the contract properties with the default `rlimit`, a timeout can be given in milliseconds via the CLI option `--model-checker-timeout <time>` or the JSON option `settings.modelChecker.timeout=<time>`, where 0 means no timeout.
### Verification Targets[](#verification-targets "Permalink to this heading")
The types of verification targets created by the SMTChecker can also be customized via the CLI option `--model-checker-target <targets>` or the JSON option `settings.modelChecker.targets=<targets>`. In the CLI case, `<targets>` is a no-space-comma-separated list of one or more verification targets, and an array of one or more targets as strings in the JSON input. The keywords that represent the targets are:
* Assertions: `assert`.
 
* Arithmetic underflow: `underflow`.
 
* Arithmetic overflow: `overflow`.
 
* Division by zero: `divByZero`.
 
* Trivial conditions and unreachable code: `constantCondition`.
 
* Popping an empty array: `popEmptyArray`.
 
* Out of bounds array/fixed bytes index access: `outOfBounds`.
 
* Insufficient funds for a transfer: `balance`.
 
* All of the above: `default` (CLI only).
 
A common subset of targets might be, for example: `--model-checker-targets assert,overflow`.
All targets are checked by default, except underflow and overflow for Solidity >=0.8.7.
There is no precise heuristic on how and when to split verification targets, but it can be useful especially when dealing with large contracts.
### Unproved Targets[](#unproved-targets "Permalink to this heading")
If there are any unproved targets, the SMTChecker issues one warning stating how many unproved targets there are. If the user wishes to see all the specific unproved targets, the CLI option `--model-checker-show-unproved` and the JSON option `settings.modelChecker.showUnproved = true` can be used.
### Verified Contracts[](#verified-contracts "Permalink to this heading")
By default all the deployable contracts in the given sources are analyzed separately as the one that will be deployed. This means that if a contract has many direct and indirect inheritance parents, all of them will be analyzed on their own, even though only the most derived will be accessed directly on the blockchain. This causes an unnecessary burden on the SMTChecker and the solver. To aid cases like this, users can specify which contracts should be analyzed as the deployed one. The parent contracts are of course still analyzed, but only in the context of the most derived contract, reducing the complexity of the encoding and generated queries. Note that abstract contracts are by default not analyzed as the most derived by the SMTChecker.
The chosen contracts can be given via a comma-separated list (whitespace is not allowed) of <source>:<contract> pairs in the CLI: `--model-checker-contracts "<source1.sol:contract1>,<source2.sol:contract2>,<source2.sol:contract3>"`, and via the object `settings.modelChecker.contracts` in the [JSON input](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#compiler-api), which has the following form:
"contracts": {
 "source1.sol": \["contract1"\],
 "source2.sol": \["contract2", "contract3"\]
}
### Reported Inferred Inductive Invariants[](#reported-inferred-inductive-invariants "Permalink to this heading")
For properties that were proved safe with the CHC engine, the SMTChecker can retrieve inductive invariants that were inferred by the Horn solver as part of the proof. Currently two types of invariants can be reported to the user:
* Contract Invariants: these are properties over the contract’s state variables that are true before and after every possible transaction that the contract may ever run. For example, `x >= y`, where `x` and `y` are a contract’s state variables.
 
* Reentrancy Properties: they represent the behavior of the contract in the presence of external calls to unknown code. These properties can express a relation between the value of the state variables before and after the external call, where the external call is free to do anything, including making reentrant calls to the analyzed contract. Primed variables represent the state variables’ values after said external call. Example: `lock -> x = x'`.
 
The user can choose the type of invariants to be reported using the CLI option `--model-checker-invariants "contract,reentrancy"` or as an array in the field `settings.modelChecker.invariants` in the [JSON input](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#compiler-api). By default the SMTChecker does not report invariants.
### Division and Modulo With Slack Variables[](#division-and-modulo-with-slack-variables "Permalink to this heading")
Spacer, the default Horn solver used by the SMTChecker, often dislikes division and modulo operations inside Horn rules. Because of that, by default the Solidity division and modulo operations are encoded using the constraint `a = b * d + m` where `d = a / b` and `m = a % b`. However, other solvers, such as Eldarica, prefer the syntactically precise operations. The command line flag `--model-checker-div-mod-no-slacks` and the JSON option `settings.modelChecker.divModNoSlacks` can be used to toggle the encoding depending on the used solver preferences.
### Natspec Function Abstraction[](#natspec-function-abstraction "Permalink to this heading")
Certain functions including common math methods such as `pow` and `sqrt` may be too complex to be analyzed in a fully automated way. These functions can be annotated with Natspec tags that indicate to the SMTChecker that these functions should be abstracted. This means that the body of the function is not used, and when called, the function will:
* Return a nondeterministic value, and either keep the state variables unchanged if the abstracted function is view/pure, or also set the state variables to nondeterministic values otherwise. This can be used via the annotation `/// @custom:smtchecker abstract-function-nondet`.
 
* Act as an uninterpreted function. This means that the semantics of the function (given by the body) are ignored, and the only property this function has is that given the same input it guarantees the same output. This is currently under development and will be available via the annotation `/// @custom:smtchecker abstract-function-uf`.
 
### Model Checking Engines[](#model-checking-engines "Permalink to this heading")
The SMTChecker module implements two different reasoning engines, a Bounded Model Checker (BMC) and a system of Constrained Horn Clauses (CHC). Both engines are currently under development, and have different characteristics. The engines are independent and every property warning states from which engine it came. Note that all the examples above with counterexamples were reported by CHC, the more powerful engine.
By default both engines are used, where CHC runs first, and every property that was not proven is passed over to BMC. You can choose a specific engine via the CLI option `--model-checker-engine {all,bmc,chc,none}` or the JSON option `settings.modelChecker.engine={all,bmc,chc,none}`.
#### Bounded Model Checker (BMC)[](#bounded-model-checker-bmc "Permalink to this heading")
The BMC engine analyzes functions in isolation, that is, it does not take the overall behavior of the contract over multiple transactions into account when analyzing each function. Loops are also ignored in this engine at the moment. Internal function calls are inlined as long as they are not recursive, directly or indirectly. External function calls are inlined if possible. Knowledge that is potentially affected by reentrancy is erased.
The characteristics above make BMC prone to reporting false positives, but it is also lightweight and should be able to quickly find small local bugs.
#### Constrained Horn Clauses (CHC)[](#constrained-horn-clauses-chc "Permalink to this heading")
A contract’s Control Flow Graph (CFG) is modelled as a system of Horn clauses, where the life cycle of the contract is represented by a loop that can visit every public/external function non-deterministically. This way, the behavior of the entire contract over an unbounded number of transactions is taken into account when analyzing any function. Loops are fully supported by this engine. Internal function calls are supported, and external function calls assume the called code is unknown and can do anything.
The CHC engine is much more powerful than BMC in terms of what it can prove, and might require more computing resources.
### SMT and Horn solvers[](#smt-and-horn-solvers "Permalink to this heading")
The two engines detailed above use automated theorem provers as their logical backends. BMC uses an SMT solver, whereas CHC uses a Horn solver. Often the same tool can act as both, as seen in [z3](https://github.com/Z3Prover/z3), which is primarily an SMT solver and makes [Spacer](https://spacer.bitbucket.io/) available as a Horn solver, and [Eldarica](https://github.com/uuverifiers/eldarica) which does both.
The user can choose which solvers should be used, if available, via the CLI option `--model-checker-solvers {all,cvc4,smtlib2,z3}` or the JSON option `settings.modelChecker.solvers=[smtlib2,z3]`, where:
* `cvc4` is only available if the `solc` binary is compiled with it. Only BMC uses `cvc4`.
 
* `smtlib2` outputs SMT/Horn queries in the [smtlib2](http://smtlib.cs.uiowa.edu/) format. These can be used together with the compiler’s [callback mechanism](https://github.com/ethereum/solc-js) so that any solver binary from the system can be employed to synchronously return the results of the queries to the compiler. This is currently the only way to use Eldarica, for example, since it does not have a C++ API. This can be used by both BMC and CHC depending on which solvers are called.
 
* `z3` is available
 
 * if `solc` is compiled with it;
 
 * if a dynamic `z3` library of version 4.8.x is installed in a Linux system (from Solidity 0.7.6);
 
 * statically in `soljson.js` (from Solidity 0.6.9), that is, the Javascript binary of the compiler.
 
Not
z3 version 4.8.16 broke ABI compatibility with previous versions and cannot be used with solc <=0.8.13. If you are using z3 >=4.8.16 please use solc >=0.8.14.
Since both BMC and CHC use `z3`, and `z3` is available in a greater variety of environments, including in the browser, most users will almost never need to be concerned about this option. More advanced users might apply this option to try alternative solvers on more complex problems.
Please note that certain combinations of chosen engine and solver will lead to the SMTChecker doing nothing, for example choosing CHC and `cvc4`.
## Abstraction and False Positives[](#abstraction-and-false-positives "Permalink to this heading")
The SMTChecker implements abstractions in an incomplete and sound way: If a bug is reported, it might be a false positive introduced by abstractions (due to erasing knowledge or using a non-precise type). If it determines that a verification target is safe, it is indeed safe, that is, there are no false negatives (unless there is a bug in the SMTChecker).
If a target cannot be proven you can try to help the solver by using the tuning options in the previous section. If you are sure of a false positive, adding `require` statements in the code with more information may also give some more power to the solver.
### SMT Encoding and Types[](#smt-encoding-and-types "Permalink to this heading")
The SMTChecker encoding tries to be as precise as possible, mapping Solidity types and expressions to their closest [SMT-LIB](http://smtlib.cs.uiowa.edu/) representation, as shown in the table below.
Solidity type
SMT sort
Theories
Boolean
Bool
Bool
intN, uintN, address, bytesN, enum, contract
Integer
LIA, NIA
array, mapping, bytes, string
Tuple (Array elements, Integer length)
Datatypes, Arrays, LIA
struct
Tuple
Datatypes
other types
Integer
LIA
Types that are not yet supported are abstracted by a single 256-bit unsigned integer, where their unsupported operations are ignored.
For more details on how the SMT encoding works internally, see the paper [SMT-based Verification of Solidity Smart Contracts](https://github.com/leonardoalt/text/blob/master/solidity_isola_2018/main.pdf).
### Function Calls[](#function-calls "Permalink to this heading")
In the BMC engine, function calls to the same contract (or base contracts) are inlined when possible, that is, when their implementation is available. Calls to functions in other contracts are not inlined even if their code is available, since we cannot guarantee that the actual deployed code is the same.
The CHC engine creates nonlinear Horn clauses that use summaries of the called functions to support internal function calls. External function calls are treated as calls to unknown code, including potential reentrant calls.
Complex pure functions are abstracted by an uninterpreted function (UF) over the arguments.
Functions
BMC/CHC behavior
`assert`
Verification target.
`require`
Assumption.
internal call
BMC: Inline function call. CHC: Function summaries.
external call to known code
BMC: Inline function call or erase knowledge about state variables and local storage references. CHC: Assume called code is unknown. Try to infer invariants that hold after the call returns.
Storage array push/pop
Supported precisely. Checks whether it is popping an empty array.
ABI functions
Abstracted with UF.
`addmod`, `mulmod`
Supported precisely.
`gasleft`, `blockhash`, `keccak256`, `ecrecover` `ripemd160`
Abstracted with UF.
pure functions without implementation (external or complex)
Abstracted with UF
external functions without implementation
BMC: Erase state knowledge and assume result is nondeterminisc. CHC: Nondeterministic summary. Try to infer invariants that hold after the call returns.
transfer
BMC: Checks whether the contract’s balance is sufficient. CHC: does not yet perform the check.
others
Currently unsupported
Using abstraction means loss of precise knowledge, but in many cases it does not mean loss of proving power.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBSZWNvdmVyCnsKICAgIGZ1bmN0aW9uIGYoCiAgICAgICAgYnl0ZXMzMiBoYXNoLAogICAgICAgIHVpbnQ4IHYxLCB1aW50OCB2MiwKICAgICAgICBieXRlczMyIHIxLCBieXRlczMyIHIyLAogICAgICAgIGJ5dGVzMzIgczEsIGJ5dGVzMzIgczIKICAgICkgcHVibGljIHB1cmUgcmV0dXJucyAoYWRkcmVzcykgewogICAgICAgIGFkZHJlc3MgYTEgPSBlY3JlY292ZXIoaGFzaCwgdjEsIHIxLCBzMSk7CiAgICAgICAgcmVxdWlyZSh2MSA9PSB2Mik7CiAgICAgICAgcmVxdWlyZShyMSA9PSByMik7CiAgICAgICAgcmVxdWlyZShzMSA9PSBzMik7CiAgICAgICAgYWRkcmVzcyBhMiA9IGVjcmVjb3ZlcihoYXNoLCB2MiwgcjIsIHMyKTsKICAgICAgICBhc3NlcnQoYTEgPT0gYTIpOwogICAgICAgIHJldHVybiBhMTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Recover
{
 function f(
 bytes32 hash,
 uint8 v1, uint8 v2,
 bytes32 r1, bytes32 r2,
 bytes32 s1, bytes32 s2
 ) public pure returns (address) {
 address a1 \= ecrecover(hash, v1, r1, s1);
 require(v1 \== v2);
 require(r1 \== r2);
 require(s1 \== s2);
 address a2 \= ecrecover(hash, v2, r2, s2);
 assert(a1 \== a2);
 return a1;
 }
}
In the example above, the SMTChecker is not expressive enough to actually compute `ecrecover`, but by modelling the function calls as uninterpreted functions we know that the return value is the same when called on equivalent parameters. This is enough to prove that the assertion above is always true.
Abstracting a function call with an UF can be done for functions known to be deterministic, and can be easily done for pure functions. It is however difficult to do this with general external functions, since they might depend on state variables.
### Reference Types and Aliasing[](#reference-types-and-aliasing "Permalink to this heading")
Solidity implements aliasing for reference types with the same [data location](https://docs.soliditylang.org/tr/latest/types.html#data-location). That means one variable may be modified through a reference to the same data area. The SMTChecker does not keep track of which references refer to the same data. This implies that whenever a local reference or state variable of reference type is assigned, all knowledge regarding variables of the same type and data location is erased. If the type is nested, the knowledge removal also includes all the prefix base types.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBBbGlhc2luZwp7CiAgICB1aW50W10gYXJyYXkxOwogICAgdWludFtdW10gYXJyYXkyOwogICAgZnVuY3Rpb24gZigKICAgICAgICB1aW50W10gbWVtb3J5IGEsCiAgICAgICAgdWludFtdIG1lbW9yeSBiLAogICAgICAgIHVpbnRbXVtdIG1lbW9yeSBjLAogICAgICAgIHVpbnRbXSBzdG9yYWdlIGQKICAgICkgaW50ZXJuYWwgewogICAgICAgIGFycmF5MVswXSA9IDQyOwogICAgICAgIGFbMF0gPSAyOwogICAgICAgIGNbMF1bMF0gPSAyOwogICAgICAgIGJbMF0gPSAxOwogICAgICAgIC8vIEVyYXNpbmcga25vd2xlZGdlIGFib3V0IG1lbW9yeSByZWZlcmVuY2VzIHNob3VsZCBub3QKICAgICAgICAvLyBlcmFzZSBrbm93bGVkZ2UgYWJvdXQgc3RhdGUgdmFyaWFibGVzLgogICAgICAgIGFzc2VydChhcnJheTFbMF0gPT0gNDIpOwogICAgICAgIC8vIEhvd2V2ZXIsIGFuIGFzc2lnbm1lbnQgdG8gYSBzdG9yYWdlIHJlZmVyZW5jZSB3aWxsIGVyYXNlCiAgICAgICAgLy8gc3RvcmFnZSBrbm93bGVkZ2UgYWNjb3JkaW5nbHkuCiAgICAgICAgZFswXSA9IDI7CiAgICAgICAgLy8gRmFpbHMgYXMgZmFsc2UgcG9zaXRpdmUgYmVjYXVzZSBvZiB0aGUgYXNzaWdubWVudCBhYm92ZS4KICAgICAgICBhc3NlcnQoYXJyYXkxWzBdID09IDQyKTsKICAgICAgICAvLyBGYWlscyBiZWNhdXNlIGBhID09IGJgIGlzIHBvc3NpYmxlLgogICAgICAgIGFzc2VydChhWzBdID09IDIpOwogICAgICAgIC8vIEZhaWxzIGJlY2F1c2UgYGNbaV0gPT0gYmAgaXMgcG9zc2libGUuCiAgICAgICAgYXNzZXJ0KGNbMF1bMF0gPT0gMik7CiAgICAgICAgYXNzZXJ0KGRbMF0gPT0gMik7CiAgICAgICAgYXNzZXJ0KGJbMF0gPT0gMSk7CiAgICB9CiAgICBmdW5jdGlvbiBnKAogICAgICAgIHVpbnRbXSBtZW1vcnkgYSwKICAgICAgICB1aW50W10gbWVtb3J5IGIsCiAgICAgICAgdWludFtdW10gbWVtb3J5IGMsCiAgICAgICAgdWludCB4CiAgICApIHB1YmxpYyB7CiAgICAgICAgZihhLCBiLCBjLCBhcnJheTJbeF0pOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Aliasing
{
 uint\[\] array1;
 uint\[\]\[\] array2;
 function f(
 uint\[\] memory a,
 uint\[\] memory b,
 uint\[\]\[\] memory c,
 uint\[\] storage d
 ) internal {
 array1\[0\] \= 42;
 a\[0\] \= 2;
 c\[0\]\[0\] \= 2;
 b\[0\] \= 1;
 // Erasing knowledge about memory references should not
 // erase knowledge about state variables.
 assert(array1\[0\] \== 42);
 // However, an assignment to a storage reference will erase
 // storage knowledge accordingly.
 d\[0\] \= 2;
 // Fails as false positive because of the assignment above.
 assert(array1\[0\] \== 42);
 // Fails because \`a == b\` is possible.
 assert(a\[0\] \== 2);
 // Fails because \`c\[i\] == b\` is possible.
 assert(c\[0\]\[0\] \== 2);
 assert(d\[0\] \== 2);
 assert(b\[0\] \== 1);
 }
 function g(
 uint\[\] memory a,
 uint\[\] memory b,
 uint\[\]\[\] memory c,
 uint x
 ) public {
 f(a, b, c, array2\[x\]);
 }
}
After the assignment to `b[0]`, we need to clear knowledge about `a` since it has the same type (`uint[]`) and data location (memory). We also need to clear knowledge about `c`, since its base type is also a `uint[]` located in memory. This implies that some `c[i]` could refer to the same data as `b` or `a`.
Notice that we do not clear knowledge about `array` and `d` because they are located in storage, even though they also have type `uint[]`. However, if `d` was assigned, we would need to clear knowledge about `array` and vice-versa.
### Contract Balance[](#contract-balance "Permalink to this heading")
A contract may be deployed with funds sent to it, if `msg.value` > 0 in the deployment transaction. However, the contract’s address may already have funds before deployment, which are kept by the contract. Therefore, the SMTChecker assumes that `address(this).balance >= msg.value` in the constructor in order to be consistent with the EVM rules. The contract’s balance may also increase without triggering any calls to the contract, if
* `selfdestruct` is executed by another contract with the analyzed contract as the target of the remaining funds,
 
* the contract is the coinbase (i.e., `block.coinbase`) of some block.
 
To model this properly, the SMTChecker assumes that at every new transaction the contract’s balance may grow by at least `msg.value`.
## Real World Assumptions[](#real-world-assumptions "Permalink to this heading")
Some scenarios can be expressed in Solidity and the EVM, but are expected to never occur in practice. One of such cases is the length of a dynamic storage array overflowing during a push: If the `push` operation is applied to an array of length 2^256 - 1, its length silently overflows. However, this is unlikely to happen in practice, since the operations required to grow the array to that point would take billions of years to execute. Another similar assumption taken by the SMTChecker is that an address’ balance can never overflow.
A similar idea was presented in [EIP-1985](https://eips.ethereum.org/EIPS/eip-1985).

# [undefined](undefined) 
 _undefined_

undefined

# [Türler — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/types.html) 
 _https://docs.soliditylang.org/tr/latest/types.html_

Solidity statik olarak yazılmış bir dildir, bu, her bir değişkenin türünün (durum ve yerel) belirtilmesi gerektiği anlamına gelir. Solidity, karmaşık türler oluşturmak için bir araya getirilen birkaç temel tür sağlar.
Ayrıca, operatör içeren ifadelerde türler birbirleriyle etkileşime girebilirler. Çeşitli operatörlere göz atmak için, [Operatörlerin Öncelik Sırası](#order).
Solidity’de “tanımsız” veya “boş” değerler kavramı yoktur, yeni bildirilen değişkenlerin türüne bağlı olarak her zaman [varsayılan bir değeri](https://docs.soliditylang.org/tr/latest/control-structures.html#default-value) vardır. Beklenmeyen değerler ile uğraşırken, tüm işlemi geri almak için bir [geri alma fonksiyonu](https://docs.soliditylang.org/tr/latest/control-structures.html#assert-and-require) kullanmalı ya da sonucu işaret eden ikinci bir `bool` değerine sahip bir veri demeti döndürmelisiniz.
## Değer Türleri[](#deger-turleri "Permalink to this heading")
Aşağıdaki türlere de değer türleri denir, çünkü bu türlerin değişkenleri her zaman değere göre iletilir, yani fonksiyon argümanları olarak veya atamalarda kullanıldıklarında her zaman kopyalanırlar.
### Booleans[](#booleans "Permalink to this heading")
`bool`: Olası değerler `true` ve `false` sabitleridir.
Operatörler:
* `!` (Mantıksal olumsuzlama)
 
* `&&` (Mantıksal bağlaç, “ve”)
 
* `||` (Mantıksal ayrılma, “veya”)
 
* `==` (Eşitlik)
 
* `!=` (Eşitsizlik)
 
`||` ve `&&` operatörleri ortak kısa devre kurallarını uygular. Bunun anlamı `f(x) || g(y)`, eğer `f(x)` `true` (doğru) olarak değerlendirilirse, `g(y)` yan etkileri olsa bile değerlendirilmeyecektir.
### Tamsayılar[](#tamsayilar "Permalink to this heading")
`int` / `uint`: Çeşitli boyutlarda işaretli ve işaretsiz tam sayılar. `8` (8’den 256 bit’e kadar işaretsiz) ve `uint8` ila `uint256` adımlarında `uint8` ile `uint256` arasındaki anahtar kelimeler. `uint` ve `int` sırasıyla `uint256` ve `int256` için takma adlardır.
Operatörler:
* Karşılaştırmalar: `<=`, `<`, `==`, `!=`, `>=`, `>` (`bool` olarak değerlendir)
 
* Bit operatörleri: `&`, `|`, `^` (bit düzeyinde özel veya), `~` (bitsel olumsuzlama)
 
* Değiştirme (Shift) operatörleri: `<<` (sol shift), `>>` (sağ shift)
 
* Aritmetik operatörler: `+`, `-`, tekli `-` (sadece imzalı tamsayılar için), `*`, `/`, `%` (mod alma operatörü), `**` (ül alma operatörü)
 
Bir tamsayı türü olan `X` için, tür tarafından gösterilebilen minimum ve maksimum değere erişmek için `type(X).min` ve `type(X).max` ı kullanabilirsiniz.
Uyarı
Solidity’deki tamsayılar belirli bir aralıkla sınırlıdır. Örneğin, `uint32` ile bu ```0``dan ``2**32 - 1``e kadardır. Bu türlerde aritmetiğin gerçekleştirildiği iki mod vardır: "wrapping" veya "unchecked" mod ve "checked" mod. Varsayılan olarak, aritmetik her zaman "checked" durumundadır, yani bir işlemin sonucu türün değer aralığının dışına çıkarsa, çağrı bir :ref:`başarısız onaylama<asset-and-require>` aracılığıyla geri döndürülür. ``unchecked { ... }``` kullanarak “unchecked” moda geçebilirsiniz. Daha fazla ayrıntı [unchecked](https://docs.soliditylang.org/tr/latest/control-structures.html#unchecked) ile ilgili bölümde bulunabilir.
#### Karşılaştırmalar[](#karsilastirmalar "Permalink to this heading")
Bir karşılaştırmanın değeri, tamsayı değeri karşılaştırılarak elde edilen değerdir.
#### Bit işlemleri[](#bit-islemleri "Permalink to this heading")
Bit işlemleri, sayının ikisinin tümleyen gösterimi üzerinde gerçekleştirilir. Bu, örneğin `~int256(0) == int256(-1)` anlamına gelir.
#### Shifts[](#shifts "Permalink to this heading")
Bir kaydırma işleminin sonucu, sol işlenenin türüne sahiptir ve sonucu türle eşleşecek şekilde kısaltır. Doğru işlenen imzasız türde olmalıdır, imzalı bir türle kaydırmaya çalışmak derleme hatası üretecektir.
Vardiyalar, aşağıdaki şekilde ikinin kuvvetleriyle çarpma kullanılarak “simüle edilebilir”. Sol işlenenin türünün kesilmesinin her zaman sonunda gerçekleştirildiğini, ancak açıkça belirtilmediğini unutmayın.
* `x << y`, `x * 2**y` matematiksel ifadesine eşdeğerdir.
 
* `x >> y`, `x / 2**y` matematiksel ifadesine eşdeğerdir, negatif sonsuza yuvarlanır.
 
Uyarı
`0.5.0` sürümünden önce, negatif `x` için bir sağa kaydırma `x >> y` sıfıra yuvarlanmış `x / 2**y` matematiksel ifadesine eşdeğerdi, yani sağa kaydırmalar, aşağı yuvarlama (negatif sonsuza doğru) yerine yukarı (sıfıra doğru) yuvarlama olarak kullanılır.
Not
Aritmetik işlemlerde olduğu gibi kaydırma işlemleri için de taşma kontrolleri yapılmaz. Bunun yerine, sonuç her zaman kesilir.
#### Toplama, Çıkarma ve Çarpma[](#toplama-cikarma-ve-carpma "Permalink to this heading")
Toplama, çıkarma ve çarpma, taşma ve alttan akışa ilişkin iki farklı mod ile olağan semantiklere sahiptir:
Varsayılan olarak, tüm aritmetik yetersiz veya taşma açısından kontrol edilir, ancak bu, [unchecked blok](https://docs.soliditylang.org/tr/latest/control-structures.html#unchecked) kullanılarak devre dışı bırakılabilir, bu da sarma aritmetiğiyle sonuçlanır. Daha fazla ayrıntı o bölümde bulunabilir.
`-x` ifadesi, `(T(0) - x)` ile eşdeğerdir; burada `T`, `x``in türüdür. Yalnızca imzalı türlere uygulanabilir. ``x` negatifse `-x` in değeri pozitif olabilir. İkisinin tamamlayıcı temsilinden kaynaklanan başka bir uyarı daha var:
`int x = type(int).min;` varsa, `-x` pozitif aralığa uymaz. `unchecked { assert(-x == x); }` çalışır ve işaretli modda kullanıldığında `-x` ifadesi başarısız bir onaylamaya neden olur.
#### Bölme[](#bolme "Permalink to this heading")
Bir işlemin sonucunun türü her zaman işlenenlerden birinin türü olduğundan, tamsayılarda bölme her zaman bir tamsayı ile sonuçlanır. Solidity’de bölme sıfıra doğru yuvarlanır. Bu, `int256(-5) / int256(2) == int256(-2)` anlamına gelir.
Buna karşılık, [değişmezler (literals)](#rational-literals) üzerinde bölmenin keyfi kesinliğin kesirli değerleriyle sonuçlandığını unutmayın.
Not
Sıfıra bölme bir [panik hatasına](https://docs.soliditylang.org/tr/latest/control-structures.html#assert-and-require) neden olur. Bu kontrol, `unckecked { ... }` ile devre dışı **bırakılamaz**.
Not
`type(int).min / (-1)` ifadesi, bölmenin taşmaya neden olduğu tek durumdur. Kontrollü aritmetik modda, bu başarısız bir onaylamaya neden olurken, sarma modunda değer `type(int).min` olacaktır.
#### Mod Alma[](#mod-alma "Permalink to this heading")
Mod alma işlemi `a % n`, `a` işleneninin `n` işlenenine bölünmesinden sonra kalan `r``yi verir, burada ``q = int(a / n)` ve `r = a - (n * q)`. Bu, mod alma işleminin sol işleneni (veya sıfır) ile aynı işaretle sonuçlandığı ve `a % n == -(-a % n)``nin negatif ``a` için geçerli olduğu anlamına gelir:
* `int256(5) % int256(2) == int256(1)`
 
* `int256(5) % int256(-2) == int256(1)`
 
* `int256(-5) % int256(2) == int256(-1)`
 
* `int256(-5) % int256(-2) == int256(-1)`
 
Not
Sıfırlı mod alma işlemi [Panik hatasına](https://docs.soliditylang.org/tr/latest/control-structures.html#assert-and-require) neden oluyor. Bu kontrol, `unckecked { ... }` ile devre dışı **bırakılamaz**.
#### Üs Alma[](#us-alma "Permalink to this heading")
Üs, yalnızca üsteki işaretsiz türler için kullanılabilir. Elde edilen bir üs türü her zaman tabanın türüne eşittir. Lütfen sonucu tutacak ve olası onaylama hatalarına veya sarma davranışına hazırlanacak kadar büyük olmasına dikkat edin.
Not
İşaretli (checked) modda, üs alma yalnızca küçük tabanlar için nispeten ucuz `exp` işlem kodunu kullanır.
`x**3` durumları için `x*x*x` ifadesi daha ucuz olabilir. Her durumda, gaz maliyeti testleri ve optimize edicinin kullanılması tavsiye edilir.
Not
`0**0``ın EVM tarafından ``1` olarak tanımlandığını unutmayın.
### Sabit Nokta Sayıları[](#sabit-nokta-sayilari "Permalink to this heading")
Uyarı
Sabit nokta sayıları henüz Solidity tarafından tam olarak desteklenmemektedir. Bildirilebilirler, ancak atanamazlar veya atanamazlar.
`fixed` / `ufixed`: Çeşitli boyutlarda imzalı ve imzasız sabit nokta sayısı. Anahtar sözcükler `ufixedMxN` ve `fixedMxN`, burada `M` türün aldığı bit sayısını ve `N` kaç ondalık noktanın mevcut olduğunu gösterir. `M` 8’e bölünebilir olmalı ve 8’den 256 bit’e kadar gider. `N` 0 ile 80 arasında olmalıdır. `ufixed` ve `fixed` sırasıyla `ufixed128x18` ve `fixed128x18` için takma adlardır.
Operatörler:
* Karşılaştırma: `<=`, `<`, `==`, `!=`, `>=`, `>` (`bool` olarak değerlendir)
 
* Aritmetik operatörler: `+`, `-`, tekil `-`, `*`, `/`, `%` (mod alma)
 
Not
Kayan nokta (birçok dilde `float` ve `double`, daha doğrusu IEEE 754 sayıları) ile sabit nokta sayıları arasındaki temel fark, tamsayı ve kesirli kısım için kullanılan bit sayısının (birçok dilde ondalık nokta) birincisinde esnektir, ikincisinde ise kesin olarak tanımlanmıştır. Genel olarak, kayan noktada neredeyse tüm alan sayıyı temsil etmek için kullanılırken, ondalık noktanın nerede olduğunu yalnızca az sayıda bit tanımlar.
### Adresler[](#adresler "Permalink to this heading")
Adres türü, büyük ölçüde aynı olan iki şekilde gelir:
* `address`: 20 baytlık bir değer tutar (bir Ethereum adresinin boyutu).
 
* `address payable`: `address` ile aynıdır, ek olarak `transfer` ve `send` bulundurur.
 
Bu ayrımın arkasındaki fikir, `address payable` in, Ether gönderebileceğiniz bir adres olduğu, ancak Ether’i düz bir `address` e göndermemeniz gerektiğidir, örneğin akıllı bir sözleşme olabileceği için. Ether’i kabul etmek için oluşturulmamıştır.
Tür dönüşümleri:
`address payable``den ``address``e örtülü dönüşümlere izin verilirken, ``address``den ``address payable``a dönüşümler ``payable(<address>)` üzerinden açık olmalıdır.
`uint160`, tamsayı değişmezleri, `bytes20` ve sözleşme türleri için `address` e ve adresten açık dönüşümlere izin verilir.
Yalnızca `address` ve sözleşme türündeki ifadeler, açık dönüştürme `payable(...)` aracılığıyla `address payable` türüne dönüştürülebilir. Sözleşme türü için, bu dönüştürmeye yalnızca sözleşme Ether alabiliyorsa, yani sözleşmenin bir [alma](https://docs.soliditylang.org/tr/latest/contracts.html#receive-ether-function) veya ödenebilir yedek fonksiyonu varsa izin verilir. `payable(0)` ın geçerli olduğunu ve bu kuralın bir istisnası olduğunu unutmayın.
Not
`address` türünde bir değişkene ihtiyacınız varsa ve buna Ether göndermeyi planlıyorsanız, bu gereksinimi görünür kılmak için türünü `address payable` olarak bildirin. Ayrıca, bu ayrımı veya dönüşümü mümkün olduğunca erken yapmaya çalışın.
Operatörler:
* `<=`, `<`, `==`, `!=`, `>=` ve `>`
 
Uyarı
Daha büyük bir bayt boyutu kullanan bir türü bir `address``e, örneğin ``bytes32``ye dönüştürürseniz, ``address` kısaltılır. Dönüştürme belirsizliğini azaltmak için sürüm 0.4.24 ve derleyici kuvvetinin daha yüksek sürümü, dönüştürmede kesmeyi açık hale getirirsiniz.
Örneğin, `0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCC` 32 bayt değerini alın.
`address(uint160(bytes20(b)))` kullanabilirsiniz, bu da `0x111122223333444455556666777788889999aAaa` ile sonuçlanır,
veya `0x777788889999AaAAbBbbCccccddDdeeeEfFFfCcCc` ile sonuçlanan `address(uint160(uint256(b)))` i kullanabilirsiniz.
Not
`address` ve `address payable` arasındaki ayrım, 0.5.0 sürümüyle tanıtıldı. Ayrıca bu versiyondan başlayarak, sözleşmeler adres türünden türetilmez, ancak yine de bir alma veya ödeme geri dönüş fonksiyonu varsa, açıkça `address` e veya `address payable` a dönüştürülebilir.
#### Adres Üyeleri[](#adres-uyeleri "Permalink to this heading")
Adreslerin tüm üyelerine hızlıca göz atmak için, bkz.:ref:address\_related.
* `balance` and `transfer`
 
Bir adresin bakiyesini `balance` özelliğini kullanarak sorgulamak ve `transfer` fonksiyonunu kullanarak Ether’i (wei birimi cinsinden) bir ödenecek adrese göndermek mümkündür:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=YWRkcmVzcyBwYXlhYmxlIHggPSBwYXlhYmxlKDB4MTIzKTsKYWRkcmVzcyBteUFkZHJlc3MgPSBhZGRyZXNzKHRoaXMpOwppZiAoeC5iYWxhbmNlIDwgMTAgJiYgbXlBZGRyZXNzLmJhbGFuY2UgPj0gMTApIHgudHJhbnNmZXIoMTApOw==)
address payable x \= payable(0x123);
address myAddress \= address(this);
if (x.balance < 10 && myAddress.balance \>= 10) x.transfer(10);
Mevcut sözleşmenin bakiyesi yeterince büyük değilse veya Ether transferi alıcı hesap tarafından reddedilirse `transfer` fonksiyonu başarısız olur. `transfer` fonksiyonu başarısızlık üzerine geri döner.
Not
`x` bir sözleşme (kontrat) adresiyse, kodu (daha spesifik olarak: varsa [Receive Ether Fonksiyonu](https://docs.soliditylang.org/tr/latest/contracts.html#receive-ether-function) veya varsa [Fallback Fonksiyonu](https://docs.soliditylang.org/tr/latest/contracts.html#fallback-function) yürütülür. `transfer` çağrısı ile birlikte (bu, EVM’nin bir özelliğidir ve engellenemez). Bu yürütmenin gazı biterse veya herhangi bir şekilde başarısız olursa, Ether transferi geri alınacak ve mevcut sözleşme bir istisna dışında durdurulacaktır.
* `send`
 
Gönder, `transfer``in alt düzey karşılığıdır. Yürütme (execution) başarısız olursa, mevcut sözleşme bir istisna dışında durmaz, ancak ``send`, `false` döndürür.
Send is the low-level counterpart of `transfer`. If the execution fails, the current contract will not stop with an exception, but `send` will return `false`.
Uyarı
`send` kullanmanın bazı tehlikeleri vardır:
Çağrı yığını derinliği 1024 ise aktarım başarısız olur (bu her zaman arayan tarafından zorlanabilir) ve ayrıca alıcının gazı biterse de başarısız olur. Bu nedenle, güvenli Ether transferleri yapmak için her zaman `send` in dönüş değerini kontrol edin, `transfer` i kullanın veya daha iyisi: alıcının parayı çektiği bir kalıp kullanın.
* `call`, `delegatecall` ve `staticcall`
 
ABI’ye uymayan sözleşmelerle arayüz oluşturmak veya kodlama üzerinde daha doğrudan kontrol sağlamak için `call`, `delegatecall` ve `staticcall` fonksiyonları sağlanmıştır. Hepsi tek bir `bytes memory` parametresi alır ve başarı koşulunu (`bool` olarak) ve döndürülen verileri (`bytes memory`) döndürür. Yapılandırılmış verileri kodlamak için `abi.encode`, `abi.encodePacked`, `abi.encodeWithSelector` ve `abi.encodeWithSignature` fonksiyonları kullanılabilir.
Örnek:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ynl0ZXMgbWVtb3J5IHBheWxvYWQgPSBhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgicmVnaXN0ZXIoc3RyaW5nKSIsICJNeU5hbWUiKTsKKGJvb2wgc3VjY2VzcywgYnl0ZXMgbWVtb3J5IHJldHVybkRhdGEpID0gYWRkcmVzcyhuYW1lUmVnKS5jYWxsKHBheWxvYWQpOwpyZXF1aXJlKHN1Y2Nlc3MpOw==)
bytes memory payload \= abi.encodeWithSignature("register(string)", "MyName");
(bool success, bytes memory returnData) \= address(nameReg).call(payload);
require(success);
Uyarı
Tüm bu fonksiyonlar alt düzey fonksiyonlarıdır ve dikkatli kullanılmalıdır. Spesifik olarak, bilinmeyen herhangi bir sözleşme kötü niyetli olabilir ve onu çağırırsanız, kontrolü o sözleşmeye devredersiniz ve bu da sözleşmenize geri çağrı yapabilir, bu nedenle arama geri döndüğünde durum değişkenlerinizdeki değişikliklere hazır olun. Diğer sözleşmelerle etkileşime girmenin normal yolu, bir sözleşme nesnesi (`x.f()`) üzerindeki bir fonksiyonu çağırmaktır.
Not
Solidity’nin önceki sürümleri, bu fonksiyonların rastgele argümanlar almasına izin veriyordu ve ayrıca `bytes4` türündeki ilk argümanı farklı şekilde ele alıyorlardı. Bu uç durumlar 0.5.0 sürümünde kaldırılmıştır.
Verilen gazı `gas` değiştiricisi ile ayarlamak mümkündür:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse2dhczogMTAwMDAwMH0oYWJpLmVuY29kZVdpdGhTaWduYXR1cmUoInJlZ2lzdGVyKHN0cmluZykiLCAiTXlOYW1lIikpOw==)
address(nameReg).call{gas: 1000000}(abi.encodeWithSignature("register(string)", "MyName"));
Benzer şekilde, sağlanan Ether değeri de kontrol edilebilir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse3ZhbHVlOiAxIGV0aGVyfShhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgicmVnaXN0ZXIoc3RyaW5nKSIsICJNeU5hbWUiKSk7)
address(nameReg).call{value: 1 ether}(abi.encodeWithSignature("register(string)", "MyName"));
Son olarak, bu değiştiriciler birleştirilebilir. Onların sırası önemli değil:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse2dhczogMTAwMDAwMCwgdmFsdWU6IDEgZXRoZXJ9KGFiaS5lbmNvZGVXaXRoU2lnbmF0dXJlKCJyZWdpc3RlcihzdHJpbmcpIiwgIk15TmFtZSIpKTs=)
address(nameReg).call{gas: 1000000, value: 1 ether}(abi.encodeWithSignature("register(string)", "MyName"));
Benzer şekilde, `delegatecall` fonksiyonu kullanılabilir: fark, yalnızca verilen adresin kodunun kullanılması, diğer tüm yönlerin (depolama, bakiye, …) mevcut sözleşmeden alınmasıdır. `delegatecall` un amacı, başka bir sözleşmede saklanan kütüphane kodunu kullanmaktır. Kullanıcı, her iki sözleşmedeki depolama düzeninin, kullanılacak temsilci çağrısı için uygun olduğundan emin olmalıdır.
Not
Homestead’den önce, orijinal `msg.sender` ve `msg.value` değerlerine erişim sağlamayan `callcode` adlı yalnızca sınırlı bir değişken mevcuttu. Bu fonksiyon 0.5.0 sürümünde kaldırılmıştır.
Bizans’tan (Byzantium) beri `staticcall` da kullanılabilir. Bu temelde `call` ile aynıdır, ancak çağrılan fonksiyon durumu herhangi bir şekilde değiştirirse geri döner.
Her üç fonksiyon, `call`, `delegatecall` ve `staticcall` çok düşük düzeyli fonksiyonlardır ve Solidity’nin tür güvenliğini bozdukları için yalnızca _son çare_ olarak kullanılmalıdır.
`Gas` seçeneği her üç yöntemde de mevcuttur, `value` seçeneği ise yalnızca `call` da mevcuttur.
Not
Durumun okunması veya yazılmasından bağımsız olarak akıllı sözleşme kodunuzdaki sabit kodlanmış gaz değerlerine güvenmekten kaçınmak en iyisidir, çünkü bunun birçok tuzağı olabilir. Ayrıca, gelecekte gaza erişim değişebilir.
* `code` and `codehash`
 
Herhangi bir akıllı sözleşme için dağıtılan kodu sorgulayabilirsiniz. EVM bayt kodunu boş olabilecek bir `bytes memory` olarak almak için `.code` kullanın. `.codehash` kullanın, bu kodun Keccak-256 karmasını alın (`bytes32` olarak). `addr.codehash``in ``keccak256(addr.code)` kullanmaktan daha ucuz olduğunu unutmayın.
Not
Tüm sözleşmeler `address` türüne dönüştürülebilir, bu nedenle `address(this).balance` kullanılarak mevcut sözleşmenin bakiyesini sorgulamak mümkündür.
### Sözleşme Türleri[](#sozlesme-turleri "Permalink to this heading")
Her [sözleşme](https://docs.soliditylang.org/tr/latest/contracts.html#contracts) kendi türünü tanımlar. Sözleşmeleri dolaylı olarak miras aldıkları sözleşmelere dönüştürebilirsiniz. Sözleşmeler açıkça `address` türüne dönüştürülebilir.
`address payable` türüne ve `address payable` türünden açık dönüştürme, yalnızca sözleşme türünün bir alacak veya ödenebilir yedek fonksiyonu varsa mümkündür. Dönüştürme hala `address(x)` kullanılarak gerçekleştirilir. Sözleşme türünün bir alma veya ödenebilir yedek fonksiyonu yoksa, `address payable``a dönüştürme ``payable(address(x))` kullanılarak yapılabilir.
[Adres türü](#address) ile ilgili bölümde daha fazla bilgi bulabilirsiniz.
Not
0.5.0 sürümünden önce, sözleşmeler doğrudan adres türünden türetilir, ve `address` ve `address payable` arasında bir ayrım yoktu.
Sözleşme tipinde (`MyContract c`) yerel bir değişken bildirirseniz, o sözleşmedeki fonksiyonları çağırabilirsiniz. Aynı sözleşme türünden bir yerden atamaya özen gösterin.
Ayrıca sözleşmeleri somutlaştırabilirsiniz (bu, sözleşmelerin yeni oluşturuldukları anlamına gelir). Daha fazla ayrıntıyı [‘Contracts via new’](https://docs.soliditylang.org/tr/latest/control-structures.html#creating-contracts) bölümünde bulabilirsiniz.
Bir sözleşmenin veri temsili, `address` türününkiyle aynıdır ve bu tür aynı zamanda [ABI](https://docs.soliditylang.org/tr/latest/abi-spec.html#abi) içinde kullanılır.
Sözleşmeler hiçbir operatörü desteklemez.
Sözleşme türlerinin üyeleri, `public` olarak işaretlenen tüm durum değişkenleri dahil olmak üzere sözleşmenin harici fonksiyonlarıdır.
Bir `C` sözleşmesi için, sözleşmeyle ilgili [tür bilgisine](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#meta-type) erişmek için `type(C)` yi kullanabilirsiniz.
### Sabit Boyutlu Bayt Dizileri[](#sabit-boyutlu-bayt-dizileri "Permalink to this heading")
`bytes1`, `bytes2`, `bytes3`, …, `bytes32` değer türleri 1’den 32’ye kadar bir bayt dizisini tutar.
Operatörler:
* Karşılaştırmalar: `<=`, `<`, `==`, `!=`, `>=`, `>` (`bool` olarak değerlendir)
 
* Bit operatörleri: `&`, `|`, `^` (bit düzeyinde özel veya), `~` (bitsel olumsuzlama)
 
* Shift operatörleri: `<<` (sol shift), `>>` (sağ shift)
 
* Dizin erişimi: `x`, `bytesI` türündeyse, `0 <= k < I` için `x[k]`, `k` ıncı baytı (salt okunur) döndürür.
 
Kaydırma operatörü, sağ işlenen olarak işaretsiz tamsayı türüyle çalışır (ancak sol işlenenin türünü döndürür), bu, kaydırılacak bit sayısını belirtir. İmzalı bir türe göre kaydırma, bir derleme hatası üretecektir.
Üyeler:
* `.length`, bayt dizisinin sabit uzunluğunu verir (salt okunur).
 
Not
`bytes1[]` türü bir bayt dizisidir, ancak doldurma kuralları nedeniyle her öğe için (depolama dışında) 31 baytlık alan harcar. Bunun yerine `bytes` türünü kullanmak daha iyidir.
Not
0.8.0 sürümünden önce, `byte`, `bytes1` için bir takma addı.
### Dinamik Olarak Boyutlandırılmış Bayt Dizisi[](#dinamik-olarak-boyutlandirilmis-bayt-dizisi "Permalink to this heading")
`bytes`:
Dinamik olarak boyutlandırılmış bayt dizisi, bkz. [Diziler](#arrays). Bir değer türü değil!
`string`:
Dinamik olarak boyutlandırılmış UTF-8 kodlu dize, bkz.:ref:arrays. Bir değer türü değil!
### Adres Değişmezleri[](#adres-degismezleri "Permalink to this heading")
Adres sağlama toplamı (checksum) testini geçen onaltılık sabit değerler, örneğin `0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF`, `address` türündedir.
39 ila 41 basamak uzunluğunda olan ve sağlama toplamı (checksum) testini geçmeyen onaltılık değişmez değerler bir hata üretir. Hatayı kaldırmak için başa (tamsayı türleri için) veya sona(bytesNN türleri için) sıfırlar ekleyebilirsiniz.
Not
Karışık büyük/küçük harfli adres sağlama toplamı biçimi, [EIP-55](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md) içinde tanımlanır.
### Rasyonel ve Tamsayı Değişmezleri[](#rasyonel-ve-tamsayi-degismezleri "Permalink to this heading")
Tamsayı değişmezleri, 0-9 aralığında bir basamak dizisinden oluşturulur. Ondalık sayılar olarak yorumlanırlar. Örneğin, `69` altmış dokuz anlamına gelir. Solidity’de sekizlik değişmez değerler yoktur ve baştaki sıfırlar geçersizdir.
Ondalık kesirli değişmezler, `.`’nın ardından en az bir sayı yerleştirilmesi ile oluşturulur. Örnekler arasında `.1` ve `1.3` bulunur (`1.` geçersizdir).
Mantisin kesirli olabileceği ancak üssün bir tamsayı olması gereken `2e10` şeklindeki bilimsel gösterim de desteklenmektedir. `MeE` değişmez değeri, `M * 10**E` ile eşdeğerdir. Örnekler arasında `2e10`, `-2e10`, `2e-10`, `2.5e1` yer alır.
Okunabilirliğe yardımcı olmak için sayısal bir hazır bilginin basamaklarını ayırmak için alt çizgiler kullanılabilir. Örneğin, ondalık (decimal) `123_000`, onaltılık (hexadecimal) `0x2eff_abde`, bilimsel ondalık gösterim `1_2e345_678` hepsi geçerlidir. Alt çizgiye yalnızca iki basamak arasında izin verilir ve yalnızca bir ardışık alt çizgiye izin verilir. Alt çizgi içeren bir sayı değişmezine ek bir anlamsal anlam eklenmez, alt çizgiler yoksayılır.
Sayı değişmezi ifadeleri, sabit olmayan bir türe dönüştürülene kadar (yani, bunları bir sayı değişmezi ifadesi (boolean değişmezleri gibi) dışında herhangi bir şeyle birlikte kullanarak veya açık dönüştürme yoluyla) isteğe bağlı kesinliği korur. Bu, hesaplamaların taşmadığı ve bölmelerin sayı değişmez ifadelerinde kesilmediği anlamına gelir.
Örneğin, `(2**800 + 1) - 2**800`, ara sonuçlar makine kelime boyutuna bile sığmasa da `1` sabitiyle sonuçlanır (`uint8` türünden). Ayrıca, `.5 * 8`, `4` tamsayısıyla sonuçlanır (arada tamsayı olmayanlar kullanılmasına rağmen).
Uyarı
Çoğu operatör, değişmez değerlere uygulandığında değişmez bir ifade üretirken, bu kalıbı takip etmeyen bazı operatörler vardır:
* Üçlü operatör (`... ? ... : ...`),
 
* Dizi alt simgesi (subscript) (`<array>[<index>]`).
 
`255 + (true ? 1 : 0)` veya `255 + [1, 2, 3][0]` gibi ifadelerin doğrudan 256 değişmezini kullanmaya eşdeğer olmasını bekleyebilirsiniz, ancak aslında bunlar `uint8` türünde hesaplanır ve taşabilir.
Tamsayılara uygulanabilen herhangi bir operatör, işlenenler tamsayı olduğu sürece sayı değişmez ifadelerine de uygulanabilir. İkisinden herhangi biri kesirliyse, bit işlemlerine izin verilmez ve üs kesirliyse üs almaya izin verilmez (çünkü bu rasyonel olmayan bir sayıya neden olabilir).
Sol (veya taban) işlenen olarak değişmez sayılar ve sağ (üs) işlenen olarak tamsayı türleri ile kaydırmalar ve üs alma, her zaman “uint256” (negatif olmayan değişmezler için) veya sağ (üs) işlenenin türünden bağımsız olarak “int256” (negatif değişmezler için) içinde gerçekleştirilir.
Uyarı
0.4.0 sürümünden önce Solidity’de tamsayı değişmezleri üzerinde bölme kullanılırdı, ancak şimdi rasyonel bir sayıya dönüştürülür, yani `5 / 2`, `2` ye eşit değil, `2.5` e eşittir .
Not
Solidity, her rasyonel sayı için bir sayı değişmez (literal) tipine sahiptir. Tamsayı değişmezleri ve rasyonel sayı değişmezleri, sayı değişmez türlerine aittir. Ayrıca, tüm sayı değişmez ifadeleri (yani yalnızca sayı değişmezlerini ve işleçlerini içeren ifadeler) sayı değişmez türlerine aittir. Dolayısıyla, `1 + 2` ve `2 + 1` sayı değişmez ifadelerinin her ikisi de üç rasyonel sayı için aynı sayı değişmez türüne aittir.
Not
Sayı değişmez ifadeleri, değişmez olmayan ifadelerle birlikte kullanılır kullanılmaz, değişmez bir türe dönüştürülür. Türlerden bağımsız olarak, aşağıdaki `b``ye atanan ifadenin değeri bir tamsayı olarak değerlendirilir. "a", "uint128" türünde olduğundan, "2.5 + a" ifadesinin uygun bir türe sahip olması gerekir. ``2.5` ve `uint128` tipi için ortak bir tip olmadığı için Solidity derleyicisi bu kodu kabul etmez.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=dWludDEyOCBhID0gMTsKdWludDEyOCBiID0gMi41ICsgYSArIDAuNTs=)
uint128 a \= 1;
uint128 b \= 2.5 + a + 0.5;
### Dize Değişmezleri ve Türleri[](#dize-degismezleri-ve-turleri "Permalink to this heading")
Dize değişmezleri ya çift ya da tek tırnak (`"foo"` veya `'bar'`) ile yazılır ve ayrıca uzun dizelerle uğraşırken yardımcı olabilecek şekilde birden çok ardışık parçaya bölünebilirler (`"foo" "bar"`, `"foobar"` ile eşdeğerdir). C’deki gibi sondaki sıfırları ima etmezler; `"foo"` dört değil, üç baytı temsil eder. Tamsayı değişmezlerinde olduğu gibi, türleri değişebilir, ancak sığarlarsa “bytes1”, …, “bytes32”ye örtük olarak “bytes” ve “string”e dönüştürülebilirler.
Örneğin, `bytes32 samevar = "stringliteral"` ile dize değişmezi, bir `bytes32` türüne atandığında ham bayt biçiminde yorumlanır.
Dize değişmezleri yalnızca yazdırılabilir ASCII karakterleri içerebilir; bu, 0x20 .. 0x7E arasındaki ve dahil olan karakterler anlamına gelir.
Ayrıca, dize değişmezleri aşağıdaki kaçış karakterlerini de destekler:
* `\<newline>` (gerçek bir yeni satırdan kaçar)
 
* `\\` (ters eğik çizgi)
 
* `\'` (tek alıntı)
 
* `\"` (çift alıntı)
 
* `\n` (Yeni satır)
 
* `\r` (satırbaşı)
 
* `\t` (etiket)
 
* `\xNN` (hex kaçış, aşağıya bakınız)
 
* `\uNNNN` (unicode kaçış, aşağıya bakınız)
 
`\xNN` bir onaltılık değer alıp uygun baytı eklerken, `\uNNNN` bir Unicode kod noktası alır ve bir UTF-8 dizisi ekler.
Not
0.8.0 sürümüne kadar üç ek kaçış dizisi vardı: `\b`, `\f` ve `\v`. Diğer dillerde yaygın olarak bulunurlar, ancak pratikte nadiren ihtiyaç duyulur. Bunlara ihtiyacınız varsa, yine de diğer ASCII karakterleri gibi, sırasıyla `\x08`, `\x0c` ve `\x0b` gibi onaltılık çıkışlar yoluyla eklenebilirler.
Aşağıdaki örnekteki dizenin uzunluğu on bayttır. Yeni satır baytı ile başlar, ardından çift tırnak, tek tırnak, ters eğik çizgi ve ardından (ayırıcı olmadan) `abcdef` karakter dizisi gelir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=IlxuXCJcJ1xcYWJjXApkZWYi)
Yeni satır olmayan herhangi bir Unicode satır sonlandırıcı (yani LF, VF, FF, CR, NEL, LS, PS) dize değişmezini sonlandırdığı kabul edilir. Yeni satır, yalnızca önünde bir `\` yoksa dize değişmezini sonlandırır.
### Unicode Değişmezler[](#unicode-degismezler "Permalink to this heading")
Normal dize değişmezleri yalnızca ASCII içerebilirken, Unicode değişmezleri `unicode` – anahtar kelimesiyle önek – herhangi bir geçerli UTF-8 dizisi içerebilir. Ayrıca, normal dize değişmezleri ile aynı kaçış dizilerini de desteklerler.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=c3RyaW5nIG1lbW9yeSBhID0gdW5pY29kZSJIZWxsbyDwn5iDIjs=)
string memory a \= unicode"Hello 😃";
### Onaltılık (Hexadecimal) Değişmezler[](#onaltilik-hexadecimal-degismezler "Permalink to this heading")
Onaltılık değişmezlerin önüne `hex` anahtar kelimesi getirilir ve çift veya tek tırnak içine alınır (`hex"001122FF"` , `hex'0011_22_FF'` ). İçerikleri, isteğe bağlı olarak bayt sınırları arasında ayırıcı olarak tek bir alt çizgi kullanabilen onaltılık basamaklar olmalıdır. Değişmez değerin değeri, onaltılık dizinin ikili gösterimi olacaktır.
Boşlukla ayrılmış birden çok onaltılık sabit değer, tek bir sabit değerde birleştirilir: `hex"00112233" hex"44556677"` , `hex"0011223344556677"` ye eşittir
Onaltılık değişmez değerler [string değişmezleri](#string-literals) gibi davranır ve aynı dönüştürülebilirlik kısıtlamalarına sahiptir.
### Numaralandırmalar (Enums)[](#numaralandirmalar-enums "Permalink to this heading")
Numaralandırmalar, Solidity’de kullanıcı tanımlı bir tür oluşturmanın bir yoludur. Tüm tamsayı türlerine açıkça dönüştürülebilirler, ancak örtük dönüştürmeye izin verilmez. Tamsayıdan yapılan açık dönüştürme, çalışma zamanında değerin numaralandırma aralığı içinde olup olmadığını kontrol eder ve aksi takdirde bir [Panik hatası](https://docs.soliditylang.org/tr/latest/control-structures.html#assert-and-require) oluşmasına neden olur. Numaralandırmalar en az bir üye gerektirir ve bildirildiğinde varsayılan değeri ilk üyedir. Numaralandırmaların 256’dan fazla üyesi olamaz.
Veri gösterimi, C’deki numaralandırmalarla aynıdır: Seçenekler, `0` dan başlayan müteakip işaretsiz tamsayı değerleriyle temsil edilir.
`type(NameOfEnum).min` ve `type(NameOfEnum).max` kullanarak verilen numaralandırmanın en küçük ve sırasıyla en büyük değerini alabilirsiniz.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguODsKCmNvbnRyYWN0IHRlc3QgewogICAgZW51bSBBY3Rpb25DaG9pY2VzIHsgR29MZWZ0LCBHb1JpZ2h0LCBHb1N0cmFpZ2h0LCBTaXRTdGlsbCB9CiAgICBBY3Rpb25DaG9pY2VzIGNob2ljZTsKICAgIEFjdGlvbkNob2ljZXMgY29uc3RhbnQgZGVmYXVsdENob2ljZSA9IEFjdGlvbkNob2ljZXMuR29TdHJhaWdodDsKCiAgICBmdW5jdGlvbiBzZXRHb1N0cmFpZ2h0KCkgcHVibGljIHsKICAgICAgICBjaG9pY2UgPSBBY3Rpb25DaG9pY2VzLkdvU3RyYWlnaHQ7CiAgICB9CgogICAgLy8gRW51bSB0w7xybGVyaSBBQkknbmluIGJpciBwYXLDp2FzxLEgb2xtYWTEscSfxLFuZGFuLCBTb2xpZGl0eSduaW4gZMSxxZ/EsW5kYWtpIHTDvG0ga29udWxhciBpw6dpbiAiZ2V0Q2hvaWNlIiBpbXphc8SxIG90b21hdGlrIG9sYXJhayAiZ2V0Q2hvaWNlKCkgcmV0dXJucyAodWludDgpIiBvbGFyYWsgZGXEn2nFn3RpcmlsZWNla3Rpci4KICAgIGZ1bmN0aW9uIGdldENob2ljZSgpIHB1YmxpYyB2aWV3IHJldHVybnMgKEFjdGlvbkNob2ljZXMpIHsKICAgICAgICByZXR1cm4gY2hvaWNlOwogICAgfQoKICAgIGZ1bmN0aW9uIGdldERlZmF1bHRDaG9pY2UoKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIHVpbnQoZGVmYXVsdENob2ljZSk7CiAgICB9CgogICAgZnVuY3Rpb24gZ2V0TGFyZ2VzdFZhbHVlKCkgcHVibGljIHB1cmUgcmV0dXJucyAoQWN0aW9uQ2hvaWNlcykgewogICAgICAgIHJldHVybiB0eXBlKEFjdGlvbkNob2ljZXMpLm1heDsKICAgIH0KCiAgICBmdW5jdGlvbiBnZXRTbWFsbGVzdFZhbHVlKCkgcHVibGljIHB1cmUgcmV0dXJucyAoQWN0aW9uQ2hvaWNlcykgewogICAgICAgIHJldHVybiB0eXBlKEFjdGlvbkNob2ljZXMpLm1pbjsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.8;
contract test {
 enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }
 ActionChoices choice;
 ActionChoices constant defaultChoice \= ActionChoices.GoStraight;
 function setGoStraight() public {
 choice \= ActionChoices.GoStraight;
 }
 // Enum türleri ABI'nin bir parçası olmadığından, Solidity'nin dışındaki tüm konular için "getChoice" imzası otomatik olarak "getChoice() returns (uint8)" olarak değiştirilecektir.
 function getChoice() public view returns (ActionChoices) {
 return choice;
 }
 function getDefaultChoice() public pure returns (uint) {
 return uint(defaultChoice);
 }
 function getLargestValue() public pure returns (ActionChoices) {
 return type(ActionChoices).max;
 }
 function getSmallestValue() public pure returns (ActionChoices) {
 return type(ActionChoices).min;
 }
}
Not
Numaralandırmalar, sözleşme veya kitaplık tanımlarının dışında dosya düzeyinde de bildirilebilir.
### Kullanıcı Tanımlı Değer Türleri[](#kullanici-tanimli-deger-turleri "Permalink to this heading")
Kullanıcı tanımlı bir değer türü, bir temel değer türü üzerinde sıfır maliyetli bir soyutlama oluşturmaya izin verir. Bu, takma ada benzer, ancak daha katı tür gereksinimleri vardır.
Kullanıcı tanımlı bir değer türü, `type C is V` kullanılarak tanımlanır; burada `C` yeni tanıtılan türün adıdır ve `V` yerleşik bir değer türü olmalıdır (“altta yatan tip”/ “underlying type”). `C.wrap` fonksiyonu, temeldeki türden özel türe dönüştürmek için kullanılır. Benzer şekilde, özel türden temel türe dönüştürmek için `C.unwrap` fonksiyonu kullanılır.
`C` türünün herhangi bir işleci veya bağlı üye fonksiyonu yoktur. Özellikle, `==` operatörü bile tanımlanmamıştır. Diğer türlere ve diğer türlerden açık ve örtük dönüştürmelere izin verilmez.
Bu türlerin değerlerinin veri temsili, temeldeki türden devralınır ve temel alınan tür de ABI’da kullanılır.
Aşağıdaki örnek, 18 ondalık basamaklı bir ondalık sabit nokta türünü ve tür üzerinde aritmetik işlemler yapmak için bir minimum kitaplığı temsil eden özel bir `UFixed256x18` türünü gösterir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguODsKCi8vIEt1bGxhbsSxY8SxIHRhbsSxbWzEsSBiaXIgZGXEn2VyIHTDvHLDvCBrdWxsYW5hcmFrIDE4IG9uZGFsxLFrLCAyNTYgYml0IGdlbmnFn2xpxJ9pbmRlIHNhYml0IG5va3RhIHTDvHLDvG7DvCB0ZW1zaWwgZWRlci4KdHlwZSBVRml4ZWQyNTZ4MTggaXMgdWludDI1NjsKCi8vLyBVRml4ZWQyNTZ4MTggw7x6ZXJpbmRlIHNhYml0IG5va3RhIGnFn2xlbWxlcmkgeWFwbWFrIGnDp2luIG1pbmltYWwgYmlyIGvDvHTDvHBoYW5lLgpsaWJyYXJ5IEZpeGVkTWF0aCB7CiAgICB1aW50IGNvbnN0YW50IG11bHRpcGxpZXIgPSAxMCoqMTg7CgogICAgLy8vxLBraSBVRml4ZWQyNTZ4MTggc2F5xLFzxLEgZWtsZXIuIHVpbnQyNTYnZGEga29udHJvbCBlZGlsZW4gYXJpdG1ldGnEn2kgdGVtZWwgYWxhcmFrIHRhxZ9tYSBkdXJ1bXVuZGEgZ2VyaSBkw7ZuZXIuCiAgICBmdW5jdGlvbiBhZGQoVUZpeGVkMjU2eDE4IGEsIFVGaXhlZDI1NngxOCBiKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKFVGaXhlZDI1NngxOCkgewogICAgICAgIHJldHVybiBVRml4ZWQyNTZ4MTgud3JhcChVRml4ZWQyNTZ4MTgudW53cmFwKGEpICsgVUZpeGVkMjU2eDE4LnVud3JhcChiKSk7CiAgICB9CiAgICAvLy8gVUZpeGVkMjU2eDE4IHZlIHVpbnQyNTYnecSxIMOnYXJwYXIuIHVpbnQyNTYnZGEga29udHJvbCBlZGlsZW4gYXJpdG1ldGnEn2kgdGVtZWwgYWxhcmFrIHRhxZ9tYSBkdXJ1bXVuZGEgZ2VyaSBkw7ZuZXIuCiAgICBmdW5jdGlvbiBtdWwoVUZpeGVkMjU2eDE4IGEsIHVpbnQyNTYgYikgaW50ZXJuYWwgcHVyZSByZXR1cm5zIChVRml4ZWQyNTZ4MTgpIHsKICAgICAgICByZXR1cm4gVUZpeGVkMjU2eDE4LndyYXAoVUZpeGVkMjU2eDE4LnVud3JhcChhKSAqIGIpOwogICAgfQogICAgLy8vIFVGaXhlZDI1NngxOCBudW1hcmFzxLFuxLFuIHplbWluaW5pIGFsxLFuLgogICAgLy8vICJhInnEsSBnZcOnbWV5ZW4gZW4gYsO8ecO8ayB0YW1zYXnEsXnEsSBkw7ZuZMO8csO8ci4KICAgIGZ1bmN0aW9uIGZsb29yKFVGaXhlZDI1NngxOCBhKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnQyNTYpIHsKICAgICAgICByZXR1cm4gVUZpeGVkMjU2eDE4LnVud3JhcChhKSAvIG11bHRpcGxpZXI7CiAgICB9CiAgICAvLy8gQmlyIHVpbnQyNTYnecSxIGF5bsSxIGRlxJ9lcmRlIGJpciBVRml4ZWQyNTZ4MTgnZSBkw7Zuw7zFn3TDvHLDvHIuCiAgICAvLy8gVGFtc2F5xLEgw6dvayBiw7x5w7xrc2UgZ2VyaSBkw7ZuZXIuCiAgICBmdW5jdGlvbiB0b1VGaXhlZDI1NngxOCh1aW50MjU2IGEpIGludGVybmFsIHB1cmUgcmV0dXJucyAoVUZpeGVkMjU2eDE4KSB7CiAgICAgICAgcmV0dXJuIFVGaXhlZDI1NngxOC53cmFwKGEgKiBtdWx0aXBsaWVyKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.8;
// Kullanıcı tanımlı bir değer türü kullanarak 18 ondalık, 256 bit genişliğinde sabit nokta türünü temsil eder.
type UFixed256x18 is uint256;
/// UFixed256x18 üzerinde sabit nokta işlemleri yapmak için minimal bir kütüphane.
library FixedMath {
 uint constant multiplier \= 10\*\*18;
 ///İki UFixed256x18 sayısı ekler. uint256'da kontrol edilen aritmetiği temel alarak taşma durumunda geri döner.
 function add(UFixed256x18 a, UFixed256x18 b) internal pure returns (UFixed256x18) {
 return UFixed256x18.wrap(UFixed256x18.unwrap(a) + UFixed256x18.unwrap(b));
 }
 /// UFixed256x18 ve uint256'yı çarpar. uint256'da kontrol edilen aritmetiği temel alarak taşma durumunda geri döner.
 function mul(UFixed256x18 a, uint256 b) internal pure returns (UFixed256x18) {
 return UFixed256x18.wrap(UFixed256x18.unwrap(a) \* b);
 }
 /// UFixed256x18 numarasının zeminini alın.
 /// "a"yı geçmeyen en büyük tamsayıyı döndürür.
 function floor(UFixed256x18 a) internal pure returns (uint256) {
 return UFixed256x18.unwrap(a) / multiplier;
 }
 /// Bir uint256'yı aynı değerde bir UFixed256x18'e dönüştürür.
 /// Tamsayı çok büyükse geri döner.
 function toUFixed256x18(uint256 a) internal pure returns (UFixed256x18) {
 return UFixed256x18.wrap(a \* multiplier);
 }
}
`UFixed256x18.wrap` ve `FixedMath.toUFixed256x18` öğelerinin nasıl aynı imzaya sahip olduğuna, ancak çok farklı iki işlem gerçekleştirdiğine dikkat edin: `UFixed256x18.wrap` işlevi, girişle aynı veri temsiline sahip bir `UFixed256x18` döndürürken, `toUFixed256x18`, aynı sayısal değere sahip bir `UFixed256x18` döndürür.
### Fonksiyon Tipleri[](#fonksiyon-tipleri "Permalink to this heading")
Fonksiyon türleri, kullanulan fonksiyonların türleridir. Fonksiyon tipinin değişkenleri fonksiyonlardan atanabilir ve fonksiyon tipinin fonksiyon parametreleri fonksiyon çağrılarına fonksiyon geçirmek ve fonksiyon çağrılarından fonksiyon döndürmek için kullanılabilir. Fonksiyon türleri iki şekilde gelir - _dahili_ ve _harici_ fonksiyonlar:
Dahili fonksiyonlar, yalnızca geçerli sözleşmenin içinde (daha spesifik olarak, dahili kitaplık fonksiyonları ve devralınan fonksiyonları da içeren geçerli kod biriminin içinde) çağrılabilir çünkü bunlar geçerli sözleşmenin bağlamı dışında yürütülemezler. Dahili bir fonkaiyonu çağırmak, tıpkı mevcut sözleşmenin bir fonksiyonunu dahili olarak çağırırken olduğu gibi, giriş etiketine atlanarak gerçekleştirilir.
Harici fonksiyonlar bir adres ve bir işlev imzasından oluşur ve bunlar iletilebilir ve harici fonksiyon çağrılarından döndürülebilir.
Fonksiyon türleri aşağıdaki gibi not edilir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=ZnVuY3Rpb24gKDxwYXJhbWV0ZXIgdHlwZXM+KSB7aW50ZXJuYWx8ZXh0ZXJuYWx9IFtwdXJlfHZpZXd8cGF5YWJsZV0gW3JldHVybnMgKDxyZXR1cm4gdHlwZXM+KV0=)
function (<parameter types\>) {internal|external} \[pure|view|payable\] \[returns (<return types\>)\]
Parametre türlerinin aksine, dönüş türleri boş olamaz - fonksiyonun türünün hiçbir şey döndürmemesi gerekiyorsa, `returns (<return types>)` bölümünün tamamı atlanmalıdır.
Varsayılan olarak, fonksiyon türleri dahilidir, bu nedenle `internal` anahtar sözcüğü atlanabilir. Bunun yalnızca fonksiyon türleri için geçerli olduğunu unutmayın. Sözleşmelerde tanımlanan fonksiyonlar için görünürlük açıkça belirtilmelidir, varsayılan değer yoktur.
Dönüşümler:
`A` fonksiyon türü, yalnızca ve yalnızca parametre türleri aynıysa, dönüş türleri aynıysa, dahili/harici özellikleri aynıysa ve `A` öğesinin durum değişkenliği aynıysa, dolaylı olarak `B` işlev türüne dönüştürülebilir. `A`, `B` durum değişkenliğinden daha kısıtlayıcıdır. Özellikle:
* `pure` fonksiyonlar, `view` ve `non-payable` fonksiyonlara dönüştürülebilir
 
* `view` fonksiyonları `non-payable` fonksiyonlara dönüştürülebilir
 
* `payable` fonksiyonlar `non-payable` fonksiyonlara dönüştürülebilir
 
Fonksiyon türleri arasında başka hiçbir dönüşüm mümkün değildir.
`payable` ve `non-payable` fonksiyonlarla alakalı kural biraz kafa karıştırıcı olabilir, ancak özünde, bir fonksiyon `payable` ise, bu aynı zamanda sıfır Ether ödemesini de kabul ettiği anlamına gelir, yani bu fonksiyon atrıca `non-payable``dır. Öte yandan, bir ``non-payable` fonksiyon kendisine gönderilen Ether’i reddedecektir, bu nedenle `non-payable` fonksiyonlar `payable` fonksiyonlara dönüştürülemez.
Bir fonksiyon türü değişkeni başlatılmazsa, onu çağırmak bir [Panik hatası](https://docs.soliditylang.org/tr/latest/control-structures.html#assert-and-require) ile sonuçlanır. Aynısı, bir fonksiyon üzerinde `delete` kullandıktan sonra çağırırsanız da olur.
Harici fonksiyon türleri, Solidity bağlamı dışında kullanılırsa, adres ve ardından fonksiyon tanımlayıcısını birlikte tek bir `bytes24` türünde kodlayan `function` türü olarak kabul edilirler.
Mevcut sözleşmenin genel (public) fonksiyonlarının hem dahili hem de harici (external) bir fonksiyon olarak kullanılabileceğini unutmayın. `f` yi dahili bir fonksiyon olarak kullanmak için `f` yi kullanın, harici biçimini kullanmak istiyorsanız `this.f` yi kullanın.
Dahili tipte bir fonksiyon, nerede tanımlandığına bakılmaksızın dahili fonksiyon tipindeki bir değişkene atanabilir. Bu, hem sözleşmelerin hem de kütüphanelerin özel, dahili ve genel fonksiyonlarını ve ayrıca ücretsiz fonksiyonlarını içerir. harici fonksiyon türleri ise yalnızca genel (public) ve harici (external) sözleşme fonksiyonlarıyla uyumludur. Kitaplıklar, bir `delegatecall` gerektirdikleri ve [seçicileri için farklı bir ABI kuralı](https://docs.soliditylang.org/tr/latest/contracts.html#library-selectors) kullandıkları için hariç tutulur. Arayüzlerde bildirilen fonksiyonların tanımları yoktur, bu nedenle onlara işaret etmek de bir anlam ifade etmez.
Üyeler:
Harici (veya genel) fonksiyonlar aşağıdaki üyelere sahiptir:
* `.address` fonksiyonun sözleşmesinin adresini döndürür.
 
* `.selector`, [BI işlev seçicisini](https://docs.soliditylang.org/tr/latest/abi-spec.html#abi-function-selector) döndürür
 
Not
Harici (veya genel) fonksiyonlar, `.gas(uint)` ve `.value(uint)` ek üyelerine sahiptiler. Bunlar Solidity 0.6.2’de tartışmaya açıldı ve Solidity 0.7.0’da kaldırıldı. Bunun yerine, bir fonksiyona gönderilen gaz miktarını veya wei miktarını belirtmek için sırasıyla `{gas: ...}` ve `{value: ...}` kullanın. Daha fazla bilgi için bkz. [External Function Calls](https://docs.soliditylang.org/tr/latest/control-structures.html#external-function-calls) .
Üyelerin nasıl kullanılacağını gösteren örnek:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjQgPDAuOS4wOwoKY29udHJhY3QgRXhhbXBsZSB7CiAgICBmdW5jdGlvbiBmKCkgcHVibGljIHBheWFibGUgcmV0dXJucyAoYnl0ZXM0KSB7CiAgICAgICAgYXNzZXJ0KHRoaXMuZi5hZGRyZXNzID09IGFkZHJlc3ModGhpcykpOwogICAgICAgIHJldHVybiB0aGlzLmYuc2VsZWN0b3I7CiAgICB9CgogICAgZnVuY3Rpb24gZygpIHB1YmxpYyB7CiAgICAgICAgdGhpcy5me2dhczogMTAsIHZhbHVlOiA4MDB9KCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.4 <0.9.0;
contract Example {
 function f() public payable returns (bytes4) {
 assert(this.f.address \== address(this));
 return this.f.selector;
 }
 function g() public {
 this.f{gas: 10, value: 800}();
 }
}
Dahili fonksiyon türlerinin nasıl kullanılacağını gösteren örnek:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmxpYnJhcnkgQXJyYXlVdGlscyB7CiAgICAvLyBheW7EsSBrb2QgYmHEn2xhbcSxbsSxbiBwYXLDp2FzxLEgb2xhY2FrbGFyxLEgacOnaW4gZGFoaWxpIGZvbmtzaXlvbmxhciBkYWhpbGkga8O8dMO8cGhhbmUgZm9ua3NpeW9ubGFyxLFuZGEga3VsbGFuxLFsYWJpbGlyCiAgICBmdW5jdGlvbiBtYXAodWludFtdIG1lbW9yeSBzZWxmLCBmdW5jdGlvbiAodWludCkgcHVyZSByZXR1cm5zICh1aW50KSBmKQogICAgICAgIGludGVybmFsCiAgICAgICAgcHVyZQogICAgICAgIHJldHVybnMgKHVpbnRbXSBtZW1vcnkgcikKICAgIHsKICAgICAgICByID0gbmV3IHVpbnRbXShzZWxmLmxlbmd0aCk7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykgewogICAgICAgICAgICByW2ldID0gZihzZWxmW2ldKTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gcmVkdWNlKAogICAgICAgIHVpbnRbXSBtZW1vcnkgc2VsZiwKICAgICAgICBmdW5jdGlvbiAodWludCwgdWludCkgcHVyZSByZXR1cm5zICh1aW50KSBmCiAgICApCiAgICAgICAgaW50ZXJuYWwKICAgICAgICBwdXJlCiAgICAgICAgcmV0dXJucyAodWludCByKQogICAgewogICAgICAgIHIgPSBzZWxmWzBdOwogICAgICAgIGZvciAodWludCBpID0gMTsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgciA9IGYociwgc2VsZltpXSk7CiAgICAgICAgfQogICAgfQoKICAgIGZ1bmN0aW9uIHJhbmdlKHVpbnQgbGVuZ3RoKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnRbXSBtZW1vcnkgcikgewogICAgICAgIHIgPSBuZXcgdWludFtdKGxlbmd0aCk7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgci5sZW5ndGg7IGkrKykgewogICAgICAgICAgICByW2ldID0gaTsKICAgICAgICB9CiAgICB9Cn0KCgpjb250cmFjdCBQeXJhbWlkIHsKICAgIHVzaW5nIEFycmF5VXRpbHMgZm9yICo7CgogICAgZnVuY3Rpb24gcHlyYW1pZCh1aW50IGwpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4gQXJyYXlVdGlscy5yYW5nZShsKS5tYXAoc3F1YXJlKS5yZWR1Y2Uoc3VtKTsKICAgIH0KCiAgICBmdW5jdGlvbiBzcXVhcmUodWludCB4KSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4geCAqIHg7CiAgICB9CgogICAgZnVuY3Rpb24gc3VtKHVpbnQgeCwgdWludCB5KSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4geCArIHk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
library ArrayUtils {
 // aynı kod bağlamının parçası olacakları için dahili fonksiyonlar dahili kütüphane fonksiyonlarında kullanılabilir
 function map(uint\[\] memory self, function (uint) pure returns (uint) f)
 internal
 pure
 returns (uint\[\] memory r)
 {
 r \= new uint\[\](self.length);
 for (uint i \= 0; i < self.length; i++) {
 r\[i\] \= f(self\[i\]);
 }
 }
 function reduce(
 uint\[\] memory self,
 function (uint, uint) pure returns (uint) f
 )
 internal
 pure
 returns (uint r)
 {
 r \= self\[0\];
 for (uint i \= 1; i < self.length; i++) {
 r \= f(r, self\[i\]);
 }
 }
 function range(uint length) internal pure returns (uint\[\] memory r) {
 r \= new uint\[\](length);
 for (uint i \= 0; i < r.length; i++) {
 r\[i\] \= i;
 }
 }
}
contract Pyramid {
 using ArrayUtils for \*;
 function pyramid(uint l) public pure returns (uint) {
 return ArrayUtils.range(l).map(square).reduce(sum);
 }
 function square(uint x) internal pure returns (uint) {
 return x \* x;
 }
 function sum(uint x, uint y) internal pure returns (uint) {
 return x + y;
 }
}
Harici işlev türlerini kullanan başka bir örnek:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCgpjb250cmFjdCBPcmFjbGUgewogICAgc3RydWN0IFJlcXVlc3QgewogICAgICAgIGJ5dGVzIGRhdGE7CiAgICAgICAgZnVuY3Rpb24odWludCkgZXh0ZXJuYWwgY2FsbGJhY2s7CiAgICB9CgogICAgUmVxdWVzdFtdIHByaXZhdGUgcmVxdWVzdHM7CiAgICBldmVudCBOZXdSZXF1ZXN0KHVpbnQpOwoKICAgIGZ1bmN0aW9uIHF1ZXJ5KGJ5dGVzIG1lbW9yeSBkYXRhLCBmdW5jdGlvbih1aW50KSBleHRlcm5hbCBjYWxsYmFjaykgcHVibGljIHsKICAgICAgICByZXF1ZXN0cy5wdXNoKFJlcXVlc3QoZGF0YSwgY2FsbGJhY2spKTsKICAgICAgICBlbWl0IE5ld1JlcXVlc3QocmVxdWVzdHMubGVuZ3RoIC0gMSk7CiAgICB9CgogICAgZnVuY3Rpb24gcmVwbHkodWludCByZXF1ZXN0SUQsIHVpbnQgcmVzcG9uc2UpIHB1YmxpYyB7CiAgICAgICAgLy8gQ2V2YWLEsW4gZ8O8dmVuaWxpciBiaXIga2F5bmFrdGFuIGdlbGlwIGdlbG1lZGnEn2kga29udHJvbCBlZGlsaXIKICAgICAgICByZXF1ZXN0c1tyZXF1ZXN0SURdLmNhbGxiYWNrKHJlc3BvbnNlKTsKICAgIH0KfQoKCmNvbnRyYWN0IE9yYWNsZVVzZXIgewogICAgT3JhY2xlIGNvbnN0YW50IHByaXZhdGUgT1JBQ0xFX0NPTlNUID0gT3JhY2xlKGFkZHJlc3MoMHgwMDAwMDAwMDIxOWFiNTQwMzU2Y0JCODM5Q2JlMDUzMDNkNzcwNUZhKSk7IC8vIGtub3duIGNvbnRyYWN0CiAgICB1aW50IHByaXZhdGUgZXhjaGFuZ2VSYXRlOwoKICAgIGZ1bmN0aW9uIGJ1eVNvbWV0aGluZygpIHB1YmxpYyB7CiAgICAgICAgT1JBQ0xFX0NPTlNULnF1ZXJ5KCJVU0QiLCB0aGlzLm9yYWNsZVJlc3BvbnNlKTsKICAgIH0KCiAgICBmdW5jdGlvbiBvcmFjbGVSZXNwb25zZSh1aW50IHJlc3BvbnNlKSBwdWJsaWMgewogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgIG1zZy5zZW5kZXIgPT0gYWRkcmVzcyhPUkFDTEVfQ09OU1QpLAogICAgICAgICAgICAiT25seSBvcmFjbGUgY2FuIGNhbGwgdGhpcy4iCiAgICAgICAgKTsKICAgICAgICBleGNoYW5nZVJhdGUgPSByZXNwb25zZTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.22 <0.9.0;
contract Oracle {
 struct Request {
 bytes data;
 function(uint) external callback;
 }
 Request\[\] private requests;
 event NewRequest(uint);
 function query(bytes memory data, function(uint) external callback) public {
 requests.push(Request(data, callback));
 emit NewRequest(requests.length \- 1);
 }
 function reply(uint requestID, uint response) public {
 // Cevabın güvenilir bir kaynaktan gelip gelmediği kontrol edilir
 requests\[requestID\].callback(response);
 }
}
contract OracleUser {
 Oracle constant private ORACLE\_CONST \= Oracle(address(0x00000000219ab540356cBB839Cbe05303d7705Fa)); // known contract
 uint private exchangeRate;
 function buySomething() public {
 ORACLE\_CONST.query("USD", this.oracleResponse);
 }
 function oracleResponse(uint response) public {
 require(
 msg.sender \== address(ORACLE\_CONST),
 "Only oracle can call this."
 );
 exchangeRate \= response;
 }
}
Not
Lambda veya satır içi işlevler planlanmıştır ancak henüz desteklenmemektedir.
## Referans Türleri[](#referans-turleri "Permalink to this heading")
Referans türünün değerleri, birden çok farklı adla değiştirilebilir. Bunu, bir değer türü değişkeni kullanıldığında bağımsız bir kopya aldığınız değer türleriyle karşılaştırın. Bu nedenle referans türleri, değer türlerinden daha dikkatli ele alınmalıdır. Şu anda referans türleri yapılar, diziler ve eşlemelerden oluşmaktadır. Bir referans türü kullanıyorsanız, her zaman türün depolandığı veri alanını açıkça sağlamanız gerekir: `memory` (ömrü, harici bir fonksiyon çağrısıyla sınırlıdır), `storage` (durum değişkenlerinin ömrünün, bir sözleşmenin ömrüyle sınırlı olduğu durumlarda saklanır) veya `calldata` (fonksiyon argümanlarını içeren özel veri konumu).
Veri konumunu değiştiren bir atama veya tür dönüştürme işlemi her zaman otomatik bir kopyalama işlemine neden olurken, aynı veri konumu içindeki atamalar yalnızca bazı durumlarda depolama türleri için kopyalanır.
### Veri Konumu[](#veri-konumu "Permalink to this heading")
Her referans türünün, nerede depolandığı hakkında “veri konumu” olan ek bir açıklaması vardır. Üç veri konumu vardır: `memory`, `storage` ve `calldata`. Çağrı verileri (calldata), fonksiyon bağımsız değişkenlerinin depolandığı ve çoğunlukla bellek gibi davrandığı, değiştirilemeyen, kalıcı olmayan bir alandır.
Not
Yapabiliyorsanız, veri konumu olarak `calldata` kullanmayı deneyin, çünkü bu kopyaları önler ve ayrıca verilerin değiştirilememesini sağlar. “calldata” veri konumuna sahip diziler ve yapılar da fonksiyonlarla döndürülebilir, ancak bu türlerin atanması mümkün değildir.
Not
0.6.9 sürümünden önce, referans türü argümanlar için veri konumu, harici fonksiyonlarda `calldata` , genel fonksiyonlarda `memory` ve dahili ve özel fonksiyonlarda `memory` veya `storage` ile sınırlıydı. . Artık `memory` e ve `calldata` ya, görünürlüklerinden bağımsız olarak tüm fonksiyonlarda izin verilir.
Not
0.5.0 sürümünden önce, veri konumu atlanabilir ve değişkenin türüne, fonksiyon türüne vb. bağlı olarak varsayılan olarak farklı konumlara atanırdı, ancak tüm karmaşık türler şimdi açık bir veri konumu vermelidir.
#### Veri Konumu ve Atama Davranışı[](#veri-konumu-ve-atama-davranisi "Permalink to this heading")
Veri konumları yalnızca verilerin kalıcılığı için değil, aynı zamanda atamaların anlamı için de önemlidir:
Data locations are not only relevant for persistency of data, but also for the semantics of assignments:
* `storage` ve `memory` (veya `calldata`) arasındaki atamalar her zaman bağımsız bir kopya oluşturur.
 
* `memory``den ``memory``ye (bellekten belleğe) yapılan atamalar yalnızca referans oluşturur. Bu, bir bellek değişkeninde (``memory`) yapılan değişikliklerin aynı verilere atıfta bulunan diğer tüm bellek değişkenlerinde de görülebileceği anlamına gelir.
 
* `storage` dan (depolamadan), **local** (yerel) depolama değişkenine yapılan atamalar da yalnızca bir referans atar.
 
* Diğer tüm atamalar `storage` a her zaman kopyalanır. Bu duruma örnek olarak, yerel değişkenin kendisi yalnızca bir başvuru olsa bile, durum değişkenlerine veya depolama yapısı türünün yerel değişkenlerinin üyelerine atamalar verilebilir.
 
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICAvLyB4J2luIHZlcmkga29udW11IGRlcG9sYW1hZMSxci4KICAgIC8vIEJ1LCB2ZXJpIGtvbnVtdW51biBhdGxhbmFiaWxlY2XEn2kgdGVrIHllcmRpci4KICAgIHVpbnRbXSB4OwoKICAgIC8vIG1lbW9yeUFycmF5IMO2xJ9lc2luaW4gdmVyaSBrb251bXUgYmVsbGVrdGlyLgogICAgZnVuY3Rpb24gZih1aW50W10gbWVtb3J5IG1lbW9yeUFycmF5KSBwdWJsaWMgewogICAgICAgIHggPSBtZW1vcnlBcnJheTsgLy8gw6dhbMSxxZ/EsXIgdmUgdMO8bSBkaXppeWkgZGVwb3lhIGtvcHlhbGFyCiAgICAgICAgdWludFtdIHN0b3JhZ2UgeSA9IHg7IC8vIMOnYWzEscWfxLFyIHZlIGJpciBpxZ9hcmV0w6dpIGF0YXIuIHknbmluIHZlcmkga29udW11IGRlcG9sYW1hZMSxcgogICAgICAgIHlbN107IC8vIDguIMO2xJ9leWkgZMO2bmTDvHLDvHIKICAgICAgICB5LnBvcCgpOyAvLyB4J2kgeSBpbGUgZGXEn2nFn3RpcmlyCiAgICAgICAgZGVsZXRlIHg7IC8vIGRpeml5aSB0ZW1pemxlciwgYXlyxLFjYSB5J3lpIGRlxJ9pxZ90aXJpcgogICAgICAgIC8vIEHFn2HEn8SxZGFraWxlciDDp2FsxLHFn23EsXlvcjsgZGVwb2xhbWFkYSB5ZW5pIGJpciBnZcOnaWNpIGFkc8SxeiBkaXppIG9sdcWfdHVybWFzxLEgZ2VyZWtpciwgYW5jYWsgZGVwb2xhbWEgInN0YXRpayBvbGFyYWsiIHRhaHNpcyBlZGlsaXI6IC8KICAgICAgICAvLyB5ID0gbWVtb3J5QXJyYXk7CiAgICAgICAgLy8gxLDFn2FyZXTDp2l5aSAic8SxZsSxcmxheWFjYcSfxLEiIGnDp2luIGJ1IGRhIGnFn2UgeWFyYW1heiwgYW5jYWsgacWfYXJldCBlZGViaWxlY2XEn2kgbWFudMSxa2zEsSBiaXIga29udW0geW9rdHVyLgogICAgICAgIC8vIGRlbGV0ZSB5OwogICAgICAgIGcoeCk7IC8vIGcneWkgw6dhxJ/EsXLEsXIsIHgnZSBiaXIgcmVmZXJhbnMgdmVyaXIKICAgICAgICBoKHgpOyAvLyBoJ3lpIMOnYcSfxLFyxLFyIHZlIGJlbGxla3RlIGJhxJ/EsW1zxLF6LCBnZcOnaWNpIGJpciBrb3B5YSBvbHXFn3R1cnVyCiAgICB9CgogICAgZnVuY3Rpb24gZyh1aW50W10gc3RvcmFnZSkgaW50ZXJuYWwgcHVyZSB7fQogICAgZnVuY3Rpb24gaCh1aW50W10gbWVtb3J5KSBwdWJsaWMgcHVyZSB7fQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
contract C {
 // x'in veri konumu depolamadır.
 // Bu, veri konumunun atlanabileceği tek yerdir.
 uint\[\] x;
 // memoryArray öğesinin veri konumu bellektir.
 function f(uint\[\] memory memoryArray) public {
 x \= memoryArray; // çalışır ve tüm diziyi depoya kopyalar
 uint\[\] storage y \= x; // çalışır ve bir işaretçi atar. y'nin veri konumu depolamadır
 y\[7\]; // 8. öğeyi döndürür
 y.pop(); // x'i y ile değiştirir
 delete x; // diziyi temizler, ayrıca y'yi değiştirir
 // Aşağıdakiler çalışmıyor; depolamada yeni bir geçici adsız dizi oluşturması gerekir, ancak depolama "statik olarak" tahsis edilir: /
 // y = memoryArray;
 // İşaretçiyi "sıfırlayacağı" için bu da işe yaramaz, ancak işaret edebileceği mantıklı bir konum yoktur.
 // delete y;
 g(x); // g'yi çağırır, x'e bir referans verir
 h(x); // h'yi çağırır ve bellekte bağımsız, geçici bir kopya oluşturur
 }
 function g(uint\[\] storage) internal pure {}
 function h(uint\[\] memory) public pure {}
}
### Diziler[](#diziler "Permalink to this heading")
Diziler, derleme zamanında sabit bir boyuta sahip olabilir veya dinamik bir boyuta sahip olabilir.
Sabit boyutlu bir dizinin türü `k` ve öğe türü `T`, `T[k]` olarak yazılır ve dinamik boyut dizisi `T[]` olarak yazılır.
Örneğin, `uint` in 5 dinamik dizisinden oluşan bir dizi `uint[][5]` olarak yazılır. Notasyon, diğer bazı dillere kıyasla tersine çevrilir. Solidity’de, `X[3]` her zaman `X` türünde üç öğe içeren bir dizidir, `X` in kendisi bir dizi olsa bile. C gibi diğer dillerde durum böyle değildir.
Endeksler sıfır tabanlıdır ve erişim bildirimin tersi yönündedir.
Örneğin, bir `uint[][5] memory x` değişkeniniz varsa, `x[2][6]` kullanarak üçüncü dinamik dizi içerisindeki yedinci `uint`’e erişirsiniz ve üçüncü dinamik diziye erişmek için `x[2]` kullanırsınız. Yine, aynı zamanda bir dizi de olabilen bir `T` türü için bir `T[5] a` diziniz varsa, o zaman `a[2]` her zaman `T` tipine sahiptir.
Dizi öğeleri, eşleme veya yapı dahil olmak üzere herhangi bir türde olabilir. Türler için genel kısıtlamalar geçerlidir, çünkü eşlemeler yalnızca “depolama” veri konumunda depolanabilir ve genel olarak görülebilen fonksiyonlar [ABI types](https://docs.soliditylang.org/tr/latest/abi-spec.html#abi) olan parametrelere ihtiyaç duyar.
Durum değişkeni dizilerini `public` olarak işaretlemek ve Solidity’nin bir [alıcı](https://docs.soliditylang.org/tr/latest/contracts.html#visibility-and-getters) oluşturmasını sağlamak mümkündür. Sayısal dizin, alıcı için gerekli bir parametre haline gelir.
Sonunu aşan bir diziye erişmek, başarısız bir onaylamaya neden olur. `.push()` ve `.push(value)` yöntemleri dizinin sonuna yeni bir öğe eklemek için kullanılabilir; burada `.push()` sıfır başlatılmış bir öğe ekler ve ona bir referans döndürür.
#### Diziler olarak `bytes` ve `string`[](#diziler-olarak-bytes-ve-string "Permalink to this heading")
`bytes` ve `string` türündeki değişkenler özel dizilerdir. `bytes` türü `bytes1[]` ile benzerdir, ancak çağrı verileri ve bellekte sıkıca paketlenmiştir. `string`, `bytes` değerine eşittir ancak uzunluk veya dizin erişimine izin vermez.
Solidity’nin string işleme fonksiyonları yoktur, ancak üçüncü taraf string kitaplıkları vardır. Ayrıca, `keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))` kullanarak iki dizgiyi keccak256-hash ile karşılaştırabilir ve `string.concat(s1, s2)` kullanarak iki dizgiyi birleştirebilirsiniz.
`bytes1[]` yerine `bytes` kullanmalısınız çünkü daha ucuzdur, çünkü `memory``de ``bytes1[]` kullanmak, öğeler arasında 31 dolgu bayt ekler. `storage`”da, sıkı paketleme nedeniyle dolgu bulunmadığına dikkat edin, bkz. [bayt ve string](https://docs.soliditylang.org/tr/latest/internals/layout_in_storage.html#bytes-and-string). Genel bir kural olarak, rastgele uzunluktaki ham bayt verileri için `bytes` ve rastgele uzunluktaki string (UTF-8) verileri için `string` kullanın. Uzunluğu belirli bir bayt sayısıyla sınırlayabiliyorsanız, her zaman `bytes1` ile `bytes32` arasındaki değer türlerinden birini kullanın çünkü bunlar çok daha ucuzdur.
Not
`s` stringinin bayt temsiline erişmek istiyorsanız, `bytes(s).length` / `bytes(s)[7] = 'x';` yapısını kullanın. Tek tek karakterlere değil, UTF-8 temsilinin düşük seviyeli baytlarına eriştiğinizi unutmayın.
#### `bytes.concat` ve `string.concat` Fonksiyonları[](#bytes-concat-ve-string-concat-fonksiyonlari "Permalink to this heading")
`string.concat` kullanarak rastgele sayıda `string` değerini birleştirebilirsiniz. Fonksiyon, bağımsız değişkenlerin içeriğini doldurmadan içeren tek bir `string memory` dizisi döndürür. Örtülü olarak `string` e dönüştürülemeyen diğer türlerin parametrelerini kullanmak istiyorsanız, önce bunları `string` e dönüştürmeniz gerekir.
Benzer şekilde, `bytes.concat` fonksiyonu, rastgele sayıda `bytes` veya `bytes1 ... bytes32` değerlerini birleştirebilir. Fonksiyon, bağımsız değişkenlerin içeriğini doldurmadan içeren tek bir `bytes memory` dizisi döndürür. String parametreleri veya örtük olarak `bytes` a dönüştürülemeyen diğer türleri kullanmak istiyorsanız, önce bunları `bytes` veya `bytes1` /…/ `bytes32` ye dönüştürmeniz gerekir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTI7Cgpjb250cmFjdCBDIHsKICAgIHN0cmluZyBzID0gIlN0b3JhZ2UiOwogICAgZnVuY3Rpb24gZihieXRlcyBjYWxsZGF0YSBiYywgc3RyaW5nIG1lbW9yeSBzbSwgYnl0ZXMxNiBiKSBwdWJsaWMgdmlldyB7CiAgICAgICAgc3RyaW5nIG1lbW9yeSBjb25jYXRTdHJpbmcgPSBzdHJpbmcuY29uY2F0KHMsIHN0cmluZyhiYyksICJMaXRlcmFsIiwgc20pOwogICAgICAgIGFzc2VydCgoYnl0ZXMocykubGVuZ3RoICsgYmMubGVuZ3RoICsgNyArIGJ5dGVzKHNtKS5sZW5ndGgpID09IGJ5dGVzKGNvbmNhdFN0cmluZykubGVuZ3RoKTsKCiAgICAgICAgYnl0ZXMgbWVtb3J5IGNvbmNhdEJ5dGVzID0gYnl0ZXMuY29uY2F0KGJ5dGVzKHMpLCBiYywgYmNbOjJdLCAiTGl0ZXJhbCIsIGJ5dGVzKHNtKSwgYik7CiAgICAgICAgYXNzZXJ0KChieXRlcyhzKS5sZW5ndGggKyBiYy5sZW5ndGggKyAyICsgNyArIGJ5dGVzKHNtKS5sZW5ndGggKyBiLmxlbmd0aCkgPT0gY29uY2F0Qnl0ZXMubGVuZ3RoKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.12;
contract C {
 string s \= "Storage";
 function f(bytes calldata bc, string memory sm, bytes16 b) public view {
 string memory concatString \= string.concat(s, string(bc), "Literal", sm);
 assert((bytes(s).length + bc.length + 7 + bytes(sm).length) \== bytes(concatString).length);
 bytes memory concatBytes \= bytes.concat(bytes(s), bc, bc\[:2\], "Literal", bytes(sm), b);
 assert((bytes(s).length + bc.length + 2 + 7 + bytes(sm).length + b.length) \== concatBytes.length);
 }
}
`string.concat` ı veya `bytes.concat` ı, argüman olmadan çağırırsanız, boş bir dizi döndürürler.
#### Bellek Dizilerini Ayırma[](#bellek-dizilerini-ayirma "Permalink to this heading")
Dinamik uzunluktaki bellek dizileri `new` operatörü kullanılarak oluşturulabilir. Depolama dizilerinin aksine, bellek dizilerini yeniden boyutlandırmak **değildir** (ör. `.push` üye fonksiyonları kullanılamaz). Gereken boyutu önceden hesaplamanız veya yeni bir bellek dizisi oluşturmanız ve her öğeyi kopyalamanız gerekir.
Solidity’deki tüm değişkenler gibi, yeni tahsis edilen dizilerin öğeleri her zaman [varsayılan değer](https://docs.soliditylang.org/tr/latest/control-structures.html#default-value) ile başlatılır.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50IGxlbikgcHVibGljIHB1cmUgewogICAgICAgIHVpbnRbXSBtZW1vcnkgYSA9IG5ldyB1aW50W10oNyk7CiAgICAgICAgYnl0ZXMgbWVtb3J5IGIgPSBuZXcgYnl0ZXMobGVuKTsKICAgICAgICBhc3NlcnQoYS5sZW5ndGggPT0gNyk7CiAgICAgICAgYXNzZXJ0KGIubGVuZ3RoID09IGxlbik7CiAgICAgICAgYVs2XSA9IDg7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 function f(uint len) public pure {
 uint\[\] memory a \= new uint\[\](7);
 bytes memory b \= new bytes(len);
 assert(a.length \== 7);
 assert(b.length \== len);
 a\[6\] \= 8;
 }
}
#### Dizi İfadeleri[](#dizi-ifadeleri "Permalink to this heading")
Bir dizi ifadesi, köşeli parantezler (`[...]`) içine alınmış bir veya daha fazla ifadenin virgülle ayrılmış bir listesidir. Örneğin `[1, a, f(3)]`. Dizi ifadesinin türü şu şekilde belirlenir:
Her zaman uzunluğu ifade sayısı olan statik olarak boyutlandırılmış bir bellek dizisidir.
Dizinin temel türü, diğer tüm ifadelerin dolaylı olarak kendisine dönüştürülebileceği şekilde listedeki ilk ifadenin türüdür. Bu mümkün değilse bir tür hatasıdır.
Tüm öğelerin dönüştürülebileceği bir türün olması yeterli değildir. Öğelerden birinin bu türden olması gerekir.
Aşağıdaki örnekte, `[1, 2, 3]` türü `uint8[3] memory` dir, çünkü bu sabitlerin her birinin türü `uint8` dir. Sonucun `uint[3] memory` türünde olmasını istiyorsanız, ilk öğeyi `uint` e dönüştürmeniz gerekir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHsKICAgICAgICBnKFt1aW50KDEpLCAyLCAzXSk7CiAgICB9CiAgICBmdW5jdGlvbiBnKHVpbnRbM10gbWVtb3J5KSBwdWJsaWMgcHVyZSB7CiAgICAgICAgLy8gLi4uCiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 function f() public pure {
 g(\[uint(1), 2, 3\]);
 }
 function g(uint\[3\] memory) public pure {
 // ...
 }
}
Birinci ifadenin türü `uint8` iken ikincinin türü `int8` olduğundan ve bunlar örtük olarak birbirine dönüştürülemediğinden `[1, -1]` dizisi ifadesi geçersizdir. Çalışması için örneğin `[int8(1), -1]` kullanabilirsiniz.
Farklı türdeki sabit boyutlu bellek dizileri birbirine dönüştürülemediğinden (temel türler yapabilse bile), iki boyutlu dizi ifadelerini kullanmak istiyorsanız, her zaman ortak bir temel türü açıkça belirtmeniz gerekir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQyNFsyXVs0XSBtZW1vcnkpIHsKICAgICAgICB1aW50MjRbMl1bNF0gbWVtb3J5IHggPSBbW3VpbnQyNCgweDEpLCAxXSwgWzB4ZmZmZmZmLCAyXSwgW3VpbnQyNCgweGZmKSwgM10sIFt1aW50MjQoMHhmZmZmKSwgNF1dOwogICAgICAgIC8vIEHFn2HEn8SxZGFraWxlciDDp2FsxLHFn21heiwgw6fDvG5rw7wgYmF6xLEgacOnIGRpemlsZXIgZG/En3J1IHRpcHRlIGRlxJ9pbGRpci4KICAgICAgICAvLyB1aW50WzJdWzRdIG1lbW9yeSB4ID0gW1sweDEsIDFdLCBbMHhmZmZmZmYsIDJdLCBbMHhmZiwgM10sIFsweGZmZmYsIDRdXTsKICAgICAgICByZXR1cm4geDsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 function f() public pure returns (uint24\[2\]\[4\] memory) {
 uint24\[2\]\[4\] memory x \= \[\[uint24(0x1), 1\], \[0xffffff, 2\], \[uint24(0xff), 3\], \[uint24(0xffff), 4\]\];
 // Aşağıdakiler çalışmaz, çünkü bazı iç diziler doğru tipte değildir.
 // uint\[2\]\[4\] memory x = \[\[0x1, 1\], \[0xffffff, 2\], \[0xff, 3\], \[0xffff, 4\]\];
 return x;
 }
}
Sabit boyutlu bellek dizileri, dinamik olarak boyutlandırılmış bellek dizilerine atanamaz, yani aşağıdakiler mümkün değildir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKLy8gQnUgZGVybGVtZSBnZXLDp2VrbGXFn21leWVjZWsuCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyB7CiAgICAgICAgLy8gU29ucmFraSBzYXTEsXIgYmlyIHTDvHIgaGF0YXPEsSBvbHXFn3R1cnVyIMOnw7xua8O8IHVpbnRbM10gYmVsbGXEn2ksIHVpbnRbXSBiZWxsZcSfaW5lIGTDtm7DvMWfdMO8csO8bGVtZXouCiAgICAgICAgdWludFtdIG1lbW9yeSB4ID0gW3VpbnQoMSksIDMsIDRdOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
// Bu derleme gerçekleşmeyecek.
contract C {
 function f() public {
 // Sonraki satır bir tür hatası oluşturur çünkü uint\[3\] belleği, uint\[\] belleğine dönüştürülemez.
 uint\[\] memory x \= \[uint(1), 3, 4\];
 }
}
İleride bu kısıtlamanın kaldırılması planlanıyor ancak dizilerin ABI’dan geçirilme şekli nedeniyle bazı komplikasyonlar yaratıyor.
Dinamik olarak boyutlandırılmış dizileri başlatmak istiyorsanız, tek tek öğeleri atamanız gerekir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHsKICAgICAgICB1aW50W10gbWVtb3J5IHggPSBuZXcgdWludFtdKDMpOwogICAgICAgIHhbMF0gPSAxOwogICAgICAgIHhbMV0gPSAzOwogICAgICAgIHhbMl0gPSA0OwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 function f() public pure {
 uint\[\] memory x \= new uint\[\](3);
 x\[0\] \= 1;
 x\[1\] \= 3;
 x\[2\] \= 4;
 }
}
#### Dizi Üyeleri[](#dizi-uyeleri "Permalink to this heading")
**length**:
Diziler, eleman sayısını içeren bir `length` (uzunluk) üyesine sahiptir.Bellek dizilerinin uzunluğu, oluşturulduktan sonra sabittir (ancak dinamiktir, yani çalışma zamanı parametrelerine bağlı olabilir).
**push()**:
Dinamik depolama dizileri ve `bytes` (`string` değil), dizinin sonuna sıfır başlatılmış bir öğe eklemek için kullanabileceğiniz `push()` adlı üye fonksiyonuna sahiptir. Öğeye bir başvuru döndürür, böylece `x.push().t = 2` veya `x.push() = b` gibi kullanılabilir.
**push(x)**:
Dinamik depolama dizileri ve `bytes` (`string` değil), dizinin sonuna belirli bir öğeyi eklemek için kullanabileceğiniz `push(x)` adlı bir üye fonksiyonuna sahiptir. Fonksiyon hiçbir şey döndürmez.
**pop()**:
Dinamik depolama dizileri ve `bytes` (`string` değil), dizinin sonundan bir öğeyi kaldırmak için kullanabileceğiniz `pop()` adlı bir üye fonksiyonuna sahiptir. Bu ayrıca kaldırılan öğede örtük olarak [delete](#delete) öğesini çağırır. Fonksiyon hiçbir şey döndürmez.
Not
`pop()` kullanarak uzunluk azaltılırken kaldırılan öğenin “boyutuna” bağlı olarak bir ücreti varken, bir depolama dizisinin uzunluğunu `push()` çağırarak artırmanın sabit gaz maliyetleri vardır çünkü başlarken depolama sıfırdır. Kaldırılan öğe bir diziyse, çok maliyetli olabilir, çünkü [delete](#delete) çağrılmasına benzer şekilde kaldırılan öğelerin açıkça temizlenmesini içerir.
Not
Dizi dizilerini harici (genel yerine) fonksiyonlarda kullanmak için ABI kodlayıcı v2’yi etkinleştirmeniz gerekir.
Not
“Byzantium” öncesi EVM sürümlerinde fonksiyon çağrılarından dönen dinamik dizilere erişim mümkün değildi. Dinamik diziler döndüren fonksiyonları çağırırsanız, Byzantium moduna ayarlanmış bir EVM kullandığınızdan emin olun.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQXJyYXlDb250cmFjdCB7CiAgICB1aW50WzIqKjIwXSBhTG90T2ZJbnRlZ2VyczsKICAgIC8vIEHFn2HEn8SxZGFraWxlcmluIGJpciDDp2lmdCBkaW5hbWlrIGRpemkgZGXEn2lsLCBkaW5hbWlrIGJpciDDp2lmdCBkaXppc2kgKHlhbmksIGlraSB1enVubHVrdGFraSBzYWJpdCBib3l1dGx1IGRpemlsZXIpIG9sZHXEn3VuYSBkaWtrYXQgZWRpbi4KICAgIC8vIEJ1IG5lZGVubGUsIFRbXSwgVCduaW4ga2VuZGlzaSBiaXIgZGl6aSBvbHNhIGJpbGUsIGhlciB6YW1hbiBkaW5hbWlrIGJpciBUIGRpemlzaWRpci4KICAgIC8vIFTDvG0gZHVydW0gZGXEn2nFn2tlbmxlcmkgacOnaW4gdmVyaSBrb251bXUgZGVwb2xhbWFkxLFyLgogICAgYm9vbFsyXVtdIHBhaXJzT2ZGbGFnczsKCiAgICAvLyBuZXdQYWlycyBiZWxsZWt0ZSBzYWtsYW7EsXIgLSB0ZWsgb2xhc8SxbMSxawogICAgLy8gYcOnxLFrIChwdWJsaWMpIHPDtnpsZcWfbWUgZm9ua3NpeW9ubGFyxLEgYXJnw7xtYW5sYXLEsSBpw6dpbgogICAgZnVuY3Rpb24gc2V0QWxsRmxhZ1BhaXJzKGJvb2xbMl1bXSBtZW1vcnkgbmV3UGFpcnMpIHB1YmxpYyB7CiAgICAgICAgLy8gYmlyIGRlcG9sYW1hIGRpemlzaW5lIGF0YW1hLCAiYGBuZXdQYWlyc2BgaW4gYmlyIGtvcHlhc8SxbsSxIGdlcsOnZWtsZcWfdGlyaXIgdmUgYGBwYWlyc09mRmxhZ3NgYCBkaXppc2luaW4gdGFtYW3EsW7EsW4geWVyaW5pIGFsxLFyLgogICAgICAgIHBhaXJzT2ZGbGFncyA9IG5ld1BhaXJzOwogICAgfQoKICAgIHN0cnVjdCBTdHJ1Y3RUeXBlIHsKICAgICAgICB1aW50W10gY29udGVudHM7CiAgICAgICAgdWludCBtb3JlSW5mbzsKICAgIH0KICAgIFN0cnVjdFR5cGUgczsKCiAgICBmdW5jdGlvbiBmKHVpbnRbXSBtZW1vcnkgYykgcHVibGljIHsKICAgICAgICAvLyBgYGdgYCBpw6dpbmRla2kgYGBzYGAgcmVmZXJhbnPEsW7EsSBzYWtsYXIKICAgICAgICBTdHJ1Y3RUeXBlIHN0b3JhZ2UgZyA9IHM7CiAgICAgICAgLy8gYXlyxLFjYSBgYHMubW9yZUluZm9gYHl1IGRhIGRlxJ9pxZ90aXJpci4KICAgICAgICBnLm1vcmVJbmZvID0gMjsKICAgICAgICAvLyBgYGcuY29udGVudHNgYCB5ZXJlbCBiaXIgZGXEn2nFn2tlbiBkZcSfaWwsIHllcmVsIGJpciBkZcSfacWfa2VuaW4gw7x5ZXNpIG9sZHXEn3UgacOnaW4gYmlyIGtvcHlhIGF0YXIuCiAgICAgICAgZy5jb250ZW50cyA9IGM7CiAgICB9CgogICAgZnVuY3Rpb24gc2V0RmxhZ1BhaXIodWludCBpbmRleCwgYm9vbCBmbGFnQSwgYm9vbCBmbGFnQikgcHVibGljIHsKICAgICAgICAvLyB2YXIgb2xtYXlhbiBiaXIgZGl6aW5lIGVyacWfaW0gYmlyIGlzdGlzbmEgYXRhcgogICAgICAgIHBhaXJzT2ZGbGFnc1tpbmRleF1bMF0gPSBmbGFnQTsKICAgICAgICBwYWlyc09mRmxhZ3NbaW5kZXhdWzFdID0gZmxhZ0I7CiAgICB9CgogICAgZnVuY3Rpb24gY2hhbmdlRmxhZ0FycmF5U2l6ZSh1aW50IG5ld1NpemUpIHB1YmxpYyB7CiAgICAgICAgLy8gYmlyIGRpemluaW4gdXp1bmx1xJ91bnUgZGXEn2nFn3Rpcm1lbmluIHRlayB5b2x1IHB1c2ggdmUgcG9wIGt1bGxhbm1ha3TEsXIKICAgICAgICBpZiAobmV3U2l6ZSA8IHBhaXJzT2ZGbGFncy5sZW5ndGgpIHsKICAgICAgICAgICAgd2hpbGUgKHBhaXJzT2ZGbGFncy5sZW5ndGggPiBuZXdTaXplKQogICAgICAgICAgICAgICAgcGFpcnNPZkZsYWdzLnBvcCgpOwogICAgICAgIH0gZWxzZSBpZiAobmV3U2l6ZSA+IHBhaXJzT2ZGbGFncy5sZW5ndGgpIHsKICAgICAgICAgICAgd2hpbGUgKHBhaXJzT2ZGbGFncy5sZW5ndGggPCBuZXdTaXplKQogICAgICAgICAgICAgICAgcGFpcnNPZkZsYWdzLnB1c2goKTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gY2xlYXIoKSBwdWJsaWMgewogICAgICAgIC8vIGJ1bmxhciBkaXppbGVyaSB0YW1hbWVuIHRlbWl6bGVyCiAgICAgICAgZGVsZXRlIHBhaXJzT2ZGbGFnczsKICAgICAgICBkZWxldGUgYUxvdE9mSW50ZWdlcnM7CiAgICAgICAgLy8gaWRlbnRpY2FsIGVmZmVjdCBoZXJlCiAgICAgICAgcGFpcnNPZkZsYWdzID0gbmV3IGJvb2xbMl1bXSgwKTsKICAgIH0KCiAgICBieXRlcyBieXRlRGF0YTsKCiAgICBmdW5jdGlvbiBieXRlQXJyYXlzKGJ5dGVzIG1lbW9yeSBkYXRhKSBwdWJsaWMgewogICAgICAgIC8vIGJheXQgZGl6aWxlcmkgKCJiYXl0cyIpLCBkb2xndSBvbG1hZGFuIGRlcG9sYW5kxLFrbGFyxLEgacOnaW4gZmFya2zEsWTEsXIsIGFuY2FrICJ1aW50OFtdIiBpbGUgYXluxLEgxZ9la2lsZGUgZWxlIGFsxLFuYWJpbGlybGVyLgogICAgICAgIGJ5dGVEYXRhID0gZGF0YTsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCA3OyBpKyspCiAgICAgICAgICAgIGJ5dGVEYXRhLnB1c2goKTsKICAgICAgICBieXRlRGF0YVszXSA9IDB4MDg7CiAgICAgICAgZGVsZXRlIGJ5dGVEYXRhWzJdOwogICAgfQoKICAgIGZ1bmN0aW9uIGFkZEZsYWcoYm9vbFsyXSBtZW1vcnkgZmxhZykgcHVibGljIHJldHVybnMgKHVpbnQpIHsKICAgICAgICBwYWlyc09mRmxhZ3MucHVzaChmbGFnKTsKICAgICAgICByZXR1cm4gcGFpcnNPZkZsYWdzLmxlbmd0aDsKICAgIH0KCiAgICBmdW5jdGlvbiBjcmVhdGVNZW1vcnlBcnJheSh1aW50IHNpemUpIHB1YmxpYyBwdXJlIHJldHVybnMgKGJ5dGVzIG1lbW9yeSkgewogICAgICAgIC8vIERpbmFtaWsgYmVsbGVrIGRpemlsZXJpIGBuZXdgIGt1bGxhbsSxbGFyYWsgb2x1xZ90dXJ1bHVyOgogICAgICAgIHVpbnRbMl1bXSBtZW1vcnkgYXJyYXlPZlBhaXJzID0gbmV3IHVpbnRbMl1bXShzaXplKTsKCiAgICAgICAgLy8gU2F0xLFyIGnDp2kgZGl6aWxlciBoZXIgemFtYW4gc3RhdGlrIG9sYXJhayBib3l1dGxhbmTEsXLEsWxtxLHFn3TEsXIgdmUgeWFsbsSxemNhIGRlxJ9pxZ9tZXogZGXEn2VybGVyIGt1bGxhbsSxeW9yc2FuxLF6LCBlbiBheiBiaXIgdMO8ciBzYcSfbGFtYW7EsXogZ2VyZWtpci4KICAgICAgICBhcnJheU9mUGFpcnNbMF0gPSBbdWludCgxKSwgMl07CgogICAgICAgIC8vIERpbmFtaWsgYmlyIGJheXQgZGl6aXNpIG9sdcWfdHVydW46CiAgICAgICAgYnl0ZXMgbWVtb3J5IGIgPSBuZXcgYnl0ZXMoMjAwKTsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKQogICAgICAgICAgICBiW2ldID0gYnl0ZXMxKHVpbnQ4KGkpKTsKICAgICAgICByZXR1cm4gYjsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract ArrayContract {
 uint\[2\*\*20\] aLotOfIntegers;
 // Aşağıdakilerin bir çift dinamik dizi değil, dinamik bir çift dizisi (yani, iki uzunluktaki sabit boyutlu diziler) olduğuna dikkat edin.
 // Bu nedenle, T\[\], T'nin kendisi bir dizi olsa bile, her zaman dinamik bir T dizisidir.
 // Tüm durum değişkenleri için veri konumu depolamadır.
 bool\[2\]\[\] pairsOfFlags;
 // newPairs bellekte saklanır - tek olasılık
 // açık (public) sözleşme fonksiyonları argümanları için
 function setAllFlagPairs(bool\[2\]\[\] memory newPairs) public {
 // bir depolama dizisine atama, "\`\`newPairs\`\`in bir kopyasını gerçekleştirir ve \`\`pairsOfFlags\`\` dizisinin tamamının yerini alır.
 pairsOfFlags \= newPairs;
 }
 struct StructType {
 uint\[\] contents;
 uint moreInfo;
 }
 StructType s;
 function f(uint\[\] memory c) public {
 // \`\`g\`\` içindeki \`\`s\`\` referansını saklar
 StructType storage g \= s;
 // ayrıca \`\`s.moreInfo\`\`yu da değiştirir.
 g.moreInfo \= 2;
 // \`\`g.contents\`\` yerel bir değişken değil, yerel bir değişkenin üyesi olduğu için bir kopya atar.
 g.contents \= c;
 }
 function setFlagPair(uint index, bool flagA, bool flagB) public {
 // var olmayan bir dizine erişim bir istisna atar
 pairsOfFlags\[index\]\[0\] \= flagA;
 pairsOfFlags\[index\]\[1\] \= flagB;
 }
 function changeFlagArraySize(uint newSize) public {
 // bir dizinin uzunluğunu değiştirmenin tek yolu push ve pop kullanmaktır
 if (newSize < pairsOfFlags.length) {
 while (pairsOfFlags.length \> newSize)
 pairsOfFlags.pop();
 } else if (newSize \> pairsOfFlags.length) {
 while (pairsOfFlags.length < newSize)
 pairsOfFlags.push();
 }
 }
 function clear() public {
 // bunlar dizileri tamamen temizler
 delete pairsOfFlags;
 delete aLotOfIntegers;
 // identical effect here
 pairsOfFlags \= new bool\[2\]\[\](0);
 }
 bytes byteData;
 function byteArrays(bytes memory data) public {
 // bayt dizileri ("bayts"), dolgu olmadan depolandıkları için farklıdır, ancak "uint8\[\]" ile aynı şekilde ele alınabilirler.
 byteData \= data;
 for (uint i \= 0; i < 7; i++)
 byteData.push();
 byteData\[3\] \= 0x08;
 delete byteData\[2\];
 }
 function addFlag(bool\[2\] memory flag) public returns (uint) {
 pairsOfFlags.push(flag);
 return pairsOfFlags.length;
 }
 function createMemoryArray(uint size) public pure returns (bytes memory) {
 // Dinamik bellek dizileri \`new\` kullanılarak oluşturulur:
 uint\[2\]\[\] memory arrayOfPairs \= new uint\[2\]\[\](size);
 // Satır içi diziler her zaman statik olarak boyutlandırılmıştır ve yalnızca değişmez değerler kullanıyorsanız, en az bir tür sağlamanız gerekir.
 arrayOfPairs\[0\] \= \[uint(1), 2\];
 // Dinamik bir bayt dizisi oluşturun:
 bytes memory b \= new bytes(200);
 for (uint i \= 0; i < b.length; i++)
 b\[i\] \= bytes1(uint8(i));
 return b;
 }
}
#### Depolama Dizisi Öğelerine Sarkan Referanslar[](#depolama-dizisi-ogelerine-sarkan-referanslar "Permalink to this heading")
Depolama dizileriyle çalışırken, sarkan referanslardan kaçınmaya özen göstermeniz gerekir. Sarkan referans, artık var olmayan veya referans güncellenmeden taşınmış bir şeye işaret eden bir referanstır. Örneğin, bir dizi öğesine bir başvuruyu yerel bir değişkende saklarsanız ve ardından içeren diziden `.pop()` depolarsanız, sarkan bir başvuru oluşabilir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50W11bXSBzOwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIC8vIHMgw7bEn2VzaW5pbiBzb24gZGl6aSDDtsSfZXNpbmUgYmlyIGnFn2FyZXTDp2kgZGVwb2xhci4KICAgICAgICB1aW50W10gc3RvcmFnZSBwdHIgPSBzW3MubGVuZ3RoIC0gMV07CiAgICAgICAgLy8gcyDDtsSfZXNpbmluIHNvbiBkaXppIMO2xJ9lc2luaSBrYWxkxLFyxLFyLgogICAgICAgIHMucG9wKCk7CiAgICAgICAgLy8gQXJ0xLFrIGRpemkgacOnaW5kZSBvbG1heWFuIGRpemkgw7bEn2VzaW5lIHlhemFyLgogICAgICAgIHB0ci5wdXNoKDB4NDIpOwogICAgICAgIC8vIMWeaW1kaSBgYHNgYCDDtsSfZXNpbmUgeWVuaSBiaXIgw7bEn2UgZWtsZW1layBib8WfIGJpciBkaXppIGVrbGVtZXosIGFuY2FrIMO2xJ9lIG9sYXJhayBgYDB4NDJgYCBvbGFuIDEgdXp1bmx1xJ91bmRhIGJpciBkaXppeWxlIHNvbnXDp2xhbsSxci4KICAgICAgICBzLnB1c2goKTsKICAgICAgICBhc3NlcnQoc1tzLmxlbmd0aCAtIDFdWzBdID09IDB4NDIpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0 <0.9.0;
contract C {
 uint\[\]\[\] s;
 function f() public {
 // s öğesinin son dizi öğesine bir işaretçi depolar.
 uint\[\] storage ptr \= s\[s.length \- 1\];
 // s öğesinin son dizi öğesini kaldırır.
 s.pop();
 // Artık dizi içinde olmayan dizi öğesine yazar.
 ptr.push(0x42);
 // Şimdi \`\`s\`\` öğesine yeni bir öğe eklemek boş bir dizi eklemez, ancak öğe olarak \`\`0x42\`\` olan 1 uzunluğunda bir diziyle sonuçlanır.
 s.push();
 assert(s\[s.length \- 1\]\[0\] \== 0x42);
 }
}
`ptr.push(0x42)` içindeki yazma, `ptr``nin artık geçerli bir ``s` öğesini ifade etmemesine rağmen **dönmeyecek**. Derleyici kullanılmayan depolamanın her zaman sıfırlandığını varsaydığından, sonraki bir `s.push()`, depolamaya açıkça sıfır yazmaz, bu nedenle `push()``dan sonraki ``s``nin son öğesi ``1` uzunluğa sahip ve ilk öğesi olarak `0x42` içeriyor.
Solidity’nin, depolamadaki değer türlerine referansların bildirilmesine izin vermediğini unutmayın. Bu tür açık sarkan başvurular, iç içe geçmiş başvuru türleriyle sınırlıdır. Ancak, tanımlama grubu atamalarında karmaşık ifadeler kullanılırken geçici olarak sarkan referanslar da oluşabilir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50W10gczsKICAgIHVpbnRbXSB0OwogICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgLy8gQmF6xLEgYmHFn2xhbmfEscOnIGRlxJ9lcmxlcmluaSBkZXBvbGFtYSBkaXppbGVyaW5lIGFrdGFyxLFuLgogICAgICAgIHMucHVzaCgweDA3KTsKICAgICAgICB0LnB1c2goMHgwMyk7CiAgICB9CgogICAgZnVuY3Rpb24gZygpIGludGVybmFsIHJldHVybnMgKHVpbnRbXSBzdG9yYWdlKSB7CiAgICAgICAgcy5wb3AoKTsKICAgICAgICByZXR1cm4gdDsKICAgIH0KCiAgICBmdW5jdGlvbiBmKCkgcHVibGljIHJldHVybnMgKHVpbnRbXSBtZW1vcnkpIHsKICAgICAgICAvLyBBxZ9hxJ/EsWRha2lsZXIgaWxrIMO2bmNlIGBgcy5wdXNoKClgYCDDtsSfZXNpbmkgZGl6aW4gMSdkZWtpIHllbmkgYmlyIMO2xJ9leWUgeWFwxLFsYW4gYmlyIGJhxZ92dXJ1eWEgZ8O2cmUgZGXEn2VybGVuZGlyZWNla3Rpci4KICAgICAgICAvLyBEYWhhIHNvbnJhLCBgYGdgYCDDp2HEn3LEsXPEsSBidSB5ZW5pIMO2xJ9leWkgYcOnYXIgdmUgZW4gc29sZGFraSBkZW1ldCDDtsSfZXNpbmluIHNhcmthbiBiaXIgcmVmZXJhbnMgaGFsaW5lIGdlbG1lc2luZSBuZWRlbiBvbHVyLgogICAgICAgIC8vIEF0YW1hIGhhbGEgZGV2YW0gZWRpeW9yIHZlIGBgc2BgIHZlcmkgYWxhbsSxbsSxbiBkxLHFn8SxbmEgeWF6YWNhay4KICAgICAgICAocy5wdXNoKCksIGcoKVswXSkgPSAoMHg0MiwgMHgxNyk7CiAgICAgICAgLy8gRGFoYSBzb25yYSBgYHNgYHllIGJhc8SxbG1hc8SxIChwdXNoIGVkaWxtZXNpL3B1c2hsYW5tYXPEsSksIMO2bmNla2kgaWZhZGUgdGFyYWbEsW5kYW4geWF6xLFsYW4gZGXEn2VyaSBvcnRheWEgw6fEsWthcmFjYWt0xLFyLCB5YW5pIGJ1IGZvbmtzaXlvbnVuIHNvbnVuZGEgInMibmluIHNvbiBlbGVtYW7EsSAiMHg0MiIgZGXEn2VyaW5lIHNhaGlwIG9sYWNha3TEsXIuCiAgICAgICAgcy5wdXNoKCk7CiAgICAgICAgcmV0dXJuIHM7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0 <0.9.0;
contract C {
 uint\[\] s;
 uint\[\] t;
 constructor() {
 // Bazı başlangıç değerlerini depolama dizilerine aktarın.
 s.push(0x07);
 t.push(0x03);
 }
 function g() internal returns (uint\[\] storage) {
 s.pop();
 return t;
 }
 function f() public returns (uint\[\] memory) {
 // Aşağıdakiler ilk önce \`\`s.push()\`\` öğesini dizin 1'deki yeni bir öğeye yapılan bir başvuruya göre değerlendirecektir.
 // Daha sonra, \`\`g\`\` çağrısı bu yeni öğeyi açar ve en soldaki demet öğesinin sarkan bir referans haline gelmesine neden olur.
 // Atama hala devam ediyor ve \`\`s\`\` veri alanının dışına yazacak.
 (s.push(), g()\[0\]) \= (0x42, 0x17);
 // Daha sonra \`\`s\`\`ye basılması (push edilmesi/pushlanması), önceki ifade tarafından yazılan değeri ortaya çıkaracaktır, yani bu fonksiyonun sonunda "s"nin son elemanı "0x42" değerine sahip olacaktır.
 s.push();
 return s;
 }
}
Her ifade için depolamaya yalnızca bir kez atama yapmak ve atamanın sol tarafında karmaşık ifadelerden kaçınmak her zaman daha güvenlidir.
Bir bayt dizisindeki bir `.push()`, [depolamada kısa düzenden uzun düzene](https://docs.soliditylang.org/tr/latest/internals/layout_in_storage.html#bytes-and-string) geçebileceğinden, `bytes` dizilerinin öğelerine yapılan başvurularla uğraşırken özellikle dikkatli olmanız gerekir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjAgPDAuOS4wOwoKLy8gQnUgYmlyIHV5YXLEsSBiaWxkaXJpcgpjb250cmFjdCBDIHsKICAgIGJ5dGVzIHggPSAiMDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5IjsKCiAgICBmdW5jdGlvbiB0ZXN0KCkgZXh0ZXJuYWwgcmV0dXJucyh1aW50KSB7CiAgICAgICAgKHgucHVzaCgpLCB4LnB1c2goKSkgPSAoMHgwMSwgMHgwMik7CiAgICAgICAgcmV0dXJuIHgubGVuZ3RoOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0 <0.9.0;
// Bu bir uyarı bildirir
contract C {
 bytes x \= "012345678901234567890123456789";
 function test() external returns(uint) {
 (x.push(), x.push()) \= (0x01, 0x02);
 return x.length;
 }
}
Burada, ilk `x.push()` değerlendirildiğinde, `x` hala kısa düzende saklanır, bu nedenle `x.push()`, `x``in ilk depolama yuvasındaki bir öğeye bir referans döndürür. Ancak, ikinci ``x.push()` bayt dizisini büyük düzene geçirir. Şimdi `x.push()` öğesinin atıfta bulunduğu öğe dizinin veri alanındayken, başvuru hala uzunluk alanının bir parçası olan orijinal konumunu işaret eder ve atama, `x` dizisinin uzunluğunu etkin bir şekilde bozar.
Güvende olmak için, tek bir atama sırasında bayt dizilerini yalnızca en fazla bir öğeyle büyütün ve aynı ifadede diziye aynı anda dizin erişimi yapmayın.
Yukarıda, derleyicinin geçerli sürümündeki sarkan depolama referanslarının davranışı açıklanırken, sarkan referanslara sahip herhangi bir kodun _tanımsız davranışa_ sahip olduğu düşünülmelidir. Özellikle bu, derleyicinin gelecekteki herhangi bir sürümünün, sarkan referanslar içeren kodun davranışını değiştirebileceği anlamına gelir.
Kodunuzda sarkan referanslardan kaçındığınızdan emin olun!
### Dizi Dilimleri[](#dizi-dilimleri "Permalink to this heading")
Dizi dilimleri, bir dizinin bitişik kısmındaki bir görünümdür. `x[start:end]` olarak yazılırlar, burada `start` ve `end` , uint256 türüyle sonuçlanan (veya dolaylı olarak ona dönüştürülebilir) ifadelerdir. Dilimin ilk öğesi `x[start]` ve son öğesi `x[end - 1]` dir.
`start`, `end``den büyükse veya ``end`, dizinin uzunluğundan büyükse, bir istisna atılır.
Hem `start` hem de `end` isteğe bağlıdır: `start` varsayılanları `0` ve `end` varsayılanları dizinin uzunluğudur.
Dizi dilimlerinin herhangi bir üyesi yoktur. Altta yatan türdeki dizilere örtük olarak dönüştürülebilirler ve dizin erişimini desteklerler. Dizin erişimi, temel alınan dizide mutlak değil, dilimin başlangıcına göredir.
Dizi dilimlerinin bir tür adı yoktur, yani hiçbir değişken tür olarak dizi dilimlerine sahip olamaz, yalnızca ara ifadelerde bulunurlar.
Not
Şu anda dizi dilimleri yalnızca çağrı verisi dizileri için uygulanmaktadır.
Dizi dilimleri, fonksiyon parametrelerinde iletilen ikincil verilerin ABI kodunu çözmek için kullanışlıdır:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjUgPDAuOS4wOwpjb250cmFjdCBQcm94eSB7CiAgICAvLy8gQGRldiwgcHJveHkgKHZla2lsKSB0YXJhZsSxbmRhbiB5w7ZuZXRpbGVuIGFsxLFjxLEgKGNsaWVudCkgc8O2emxlxZ9tZXNpbmluIGFkcmVzaSwgeWFuaSBidSBzw7Z6bGXFn21lCiAgICBhZGRyZXNzIGNsaWVudDsKCiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzIGNsaWVudF8pIHsKICAgICAgICBjbGllbnQgPSBjbGllbnRfOwogICAgfQoKICAgIC8vLyBBZHJlcyBiYcSfxLFtc8SxeiBkZcSfacWfa2VuaW5kZSB0ZW1lbCBkb8SfcnVsYW1hIHlhcHTEsWt0YW4gc29ucmEgaXN0ZW1jaSB0YXJhZsSxbmRhbiB1eWd1bGFuYW4gInNldE93bmVyKGFkZHJlc3MpIiDDp2HEn3LEsXPEsW7EsSB5w7ZubGVuZGlyaW4uCiAgICBmdW5jdGlvbiBmb3J3YXJkKGJ5dGVzIGNhbGxkYXRhIHBheWxvYWQpIGV4dGVybmFsIHsKICAgICAgICBieXRlczQgc2lnID0gYnl0ZXM0KHBheWxvYWRbOjRdKTsKICAgICAgICAvLyBLZXNtZSBkYXZyYW7EscWfxLEgbmVkZW5peWxlLCBieXRlczQocGF5bG9hZCkgYXluxLEgxZ9la2lsZGUgw6dhbMSxxZ/EsXIuCiAgICAgICAgLy8gYnl0ZXM0IHNpZyA9IGJ5dGVzNChwYXlsb2FkKTsKICAgICAgICBpZiAoc2lnID09IGJ5dGVzNChrZWNjYWsyNTYoInNldE93bmVyKGFkZHJlc3MpIikpKSB7CiAgICAgICAgICAgIGFkZHJlc3Mgb3duZXIgPSBhYmkuZGVjb2RlKHBheWxvYWRbNDpdLCAoYWRkcmVzcykpOwogICAgICAgICAgICByZXF1aXJlKG93bmVyICE9IGFkZHJlc3MoMCksICJBZGRyZXNzIG9mIG93bmVyIGNhbm5vdCBiZSB6ZXJvLiIpOwogICAgICAgIH0KICAgICAgICAoYm9vbCBzdGF0dXMsKSA9IGNsaWVudC5kZWxlZ2F0ZWNhbGwocGF5bG9hZCk7CiAgICAgICAgcmVxdWlyZShzdGF0dXMsICJGb3J3YXJkZWQgY2FsbCBmYWlsZWQuIik7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.5 <0.9.0;
contract Proxy {
 /// @dev, proxy (vekil) tarafından yönetilen alıcı (client) sözleşmesinin adresi, yani bu sözleşme
 address client;
 constructor(address client\_) {
 client \= client\_;
 }
 /// Adres bağımsız değişkeninde temel doğrulama yaptıktan sonra istemci tarafından uygulanan "setOwner(address)" çağrısını yönlendirin.
 function forward(bytes calldata payload) external {
 bytes4 sig \= bytes4(payload\[:4\]);
 // Kesme davranışı nedeniyle, bytes4(payload) aynı şekilde çalışır.
 // bytes4 sig = bytes4(payload);
 if (sig \== bytes4(keccak256("setOwner(address)"))) {
 address owner \= abi.decode(payload\[4:\], (address));
 require(owner != address(0), "Address of owner cannot be zero.");
 }
 (bool status,) \= client.delegatecall(payload);
 require(status, "Forwarded call failed.");
 }
}
### Yapılar[](#yapilar "Permalink to this heading")
Solidity, aşağıdaki örnekte gösterildiği gibi, yapılar biçiminde yeni türleri tanımlamanın bir yolunu sağlar:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKLy8gxLBraSBhbGFubMSxIHllbmkgYmlyIHTDvHIgdGFuxLFtbGFyLgovLyBCaXIgc8O2emxlxZ9tZW5pbiBkxLHFn8SxbmRhIGJpciB5YXDEsSBiaWxkaXJtZWssIGJpcmRlbiBmYXpsYSBzw7Z6bGXFn21lIHRhcmFmxLFuZGFuIHBheWxhxZ/EsWxtYXPEsW5hIGl6aW4gdmVyaXIuCi8vIEJ1cmFkYSwgYnUgZ2Vyw6dla3RlbiBnZXJla2xpIGRlxJ9pbC4Kc3RydWN0IEZ1bmRlciB7CiAgICBhZGRyZXNzIGFkZHI7CiAgICB1aW50IGFtb3VudDsKfQoKY29udHJhY3QgQ3Jvd2RGdW5kaW5nIHsKICAgIC8vIFlhcMSxbGFyLCBzw7Z6bGXFn21lbGVyaW4gacOnaW5kZSBkZSB0YW7EsW1sYW5hYmlsaXIsIGJ1IGRhIG9ubGFyxLEgeWFsbsSxemNhIG9yYWRhIHZlIHTDvHJldGlsbWnFnyBzw7Z6bGXFn21lbGVyZGUgZ8O2csO8bsO8ciBrxLFsYXIuCiAgICBzdHJ1Y3QgQ2FtcGFpZ24gewogICAgICAgIGFkZHJlc3MgcGF5YWJsZSBiZW5lZmljaWFyeTsKICAgICAgICB1aW50IGZ1bmRpbmdHb2FsOwogICAgICAgIHVpbnQgbnVtRnVuZGVyczsKICAgICAgICB1aW50IGFtb3VudDsKICAgICAgICBtYXBwaW5nICh1aW50ID0+IEZ1bmRlcikgZnVuZGVyczsKICAgIH0KCiAgICB1aW50IG51bUNhbXBhaWduczsKICAgIG1hcHBpbmcgKHVpbnQgPT4gQ2FtcGFpZ24pIGNhbXBhaWduczsKCiAgICBmdW5jdGlvbiBuZXdDYW1wYWlnbihhZGRyZXNzIHBheWFibGUgYmVuZWZpY2lhcnksIHVpbnQgZ29hbCkgcHVibGljIHJldHVybnMgKHVpbnQgY2FtcGFpZ25JRCkgewogICAgICAgIGNhbXBhaWduSUQgPSBudW1DYW1wYWlnbnMrKzsgLy8gY2FtcGFpZ25JRCBpcyByZXR1cm4gdmFyaWFibGUKICAgICAgICAvLyAiY2FtcGFpZ25zW2NhbXBhaWduSURdID0gQ2FtcGFpZ24oYmVuZWZpY2lhcnksIGdvYWwsIDAsIDApIiBrdWxsYW5hbWF5xLF6IMOnw7xua8O8IHNhxJ8gdGFyYWYgYmlyIGXFn2xlbWUgacOnZXJlbiBiaXIgYmVsbGVrIHlhcMSxc8SxICJDYW1wYWlnbiIgb2x1xZ90dXJ1ci4KICAgICAgICBDYW1wYWlnbiBzdG9yYWdlIGMgPSBjYW1wYWlnbnNbY2FtcGFpZ25JRF07CiAgICAgICAgYy5iZW5lZmljaWFyeSA9IGJlbmVmaWNpYXJ5OwogICAgICAgIGMuZnVuZGluZ0dvYWwgPSBnb2FsOwogICAgfQoKICAgIGZ1bmN0aW9uIGNvbnRyaWJ1dGUodWludCBjYW1wYWlnbklEKSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgQ2FtcGFpZ24gc3RvcmFnZSBjID0gY2FtcGFpZ25zW2NhbXBhaWduSURdOwogICAgICAgIC8vIFZlcmlsZW4gZGXEn2VybGVybGUgYmHFn2xhdMSxbGFuIHllbmkgYmlyIGdlw6dpY2kgYmVsbGVrIHlhcMSxc8SxIG9sdcWfdHVydXIgdmUgYnVudSBkZXBveWEga29weWFsYXIuCiAgICAgICAgLy8gQmHFn2xhdG1hayBpw6dpbiBGdW5kZXIobXNnLnNlbmRlciwgbXNnLnZhbHVlKSDDtsSfZXNpbmkgZGUga3VsbGFuYWJpbGVjZcSfaW5pemkgdW51dG1hecSxbi4KICAgICAgICBjLmZ1bmRlcnNbYy5udW1GdW5kZXJzKytdID0gRnVuZGVyKHthZGRyOiBtc2cuc2VuZGVyLCBhbW91bnQ6IG1zZy52YWx1ZX0pOwogICAgICAgIGMuYW1vdW50ICs9IG1zZy52YWx1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGVja0dvYWxSZWFjaGVkKHVpbnQgY2FtcGFpZ25JRCkgcHVibGljIHJldHVybnMgKGJvb2wgcmVhY2hlZCkgewogICAgICAgIENhbXBhaWduIHN0b3JhZ2UgYyA9IGNhbXBhaWduc1tjYW1wYWlnbklEXTsKICAgICAgICBpZiAoYy5hbW91bnQgPCBjLmZ1bmRpbmdHb2FsKQogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgdWludCBhbW91bnQgPSBjLmFtb3VudDsKICAgICAgICBjLmFtb3VudCA9IDA7CiAgICAgICAgYy5iZW5lZmljaWFyeS50cmFuc2ZlcihhbW91bnQpOwogICAgICAgIHJldHVybiB0cnVlOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
// İki alanlı yeni bir tür tanımlar.
// Bir sözleşmenin dışında bir yapı bildirmek, birden fazla sözleşme tarafından paylaşılmasına izin verir.
// Burada, bu gerçekten gerekli değil.
struct Funder {
 address addr;
 uint amount;
}
contract CrowdFunding {
 // Yapılar, sözleşmelerin içinde de tanımlanabilir, bu da onları yalnızca orada ve türetilmiş sözleşmelerde görünür kılar.
 struct Campaign {
 address payable beneficiary;
 uint fundingGoal;
 uint numFunders;
 uint amount;
 mapping (uint \=> Funder) funders;
 }
 uint numCampaigns;
 mapping (uint \=> Campaign) campaigns;
 function newCampaign(address payable beneficiary, uint goal) public returns (uint campaignID) {
 campaignID \= numCampaigns++; // campaignID is return variable
 // "campaigns\[campaignID\] = Campaign(beneficiary, goal, 0, 0)" kullanamayız çünkü sağ taraf bir eşleme içeren bir bellek yapısı "Campaign" oluşturur.
 Campaign storage c \= campaigns\[campaignID\];
 c.beneficiary \= beneficiary;
 c.fundingGoal \= goal;
 }
 function contribute(uint campaignID) public payable {
 Campaign storage c \= campaigns\[campaignID\];
 // Verilen değerlerle başlatılan yeni bir geçici bellek yapısı oluşturur ve bunu depoya kopyalar.
 // Başlatmak için Funder(msg.sender, msg.value) öğesini de kullanabileceğinizi unutmayın.
 c.funders\[c.numFunders++\] \= Funder({addr: msg.sender, amount: msg.value});
 c.amount += msg.value;
 }
 function checkGoalReached(uint campaignID) public returns (bool reached) {
 Campaign storage c \= campaigns\[campaignID\];
 if (c.amount < c.fundingGoal)
 return false;
 uint amount \= c.amount;
 c.amount \= 0;
 c.beneficiary.transfer(amount);
 return true;
 }
}
Sözleşme, bir kitle fonlaması sözleşmesinin tam işlevselliğini sağlamaz, ancak yapıları anlamak için gerekli temel kavramları içerir. Yapı türleri eşlemeler ve diziler içinde kullanılabilir ve kendileri eşlemeler ve diziler içerebilir.
Bir yapının kendi türünden bir üye içermesi mümkün değildir, ancak yapının kendisi bir eşleme üyesinin değer türü olabilir veya kendi türünde dinamik olarak boyutlandırılmış bir dizi içerebilir. Yapının boyutunun sonlu olması gerektiğinden bu kısıtlama gereklidir.
Tüm fonksiyonlarda, veri konumu `storage` olan yerel bir değişkene bir yapı türünün nasıl atandığına dikkat edin. Bu, yapıyı kopyalamaz, ancak yalnızca bir referansı saklar, böylece yerel değişkenin üyelerine yapılan atamalar aslında duruma yazılır.
Not
Solidity 0.7.0’a kadar, yalnızca depolama türlerinin üyelerini (ör. eşlemeler) içeren bellek yapılarına izin veriliyordu ve `campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0)` gibi atamalar işe yarıyordu ve bunları sessizce atlıyordu.
## Eşleme Türleri[](#esleme-turleri "Permalink to this heading")
Eşleme türleri `mapping(KeyType => ValueType)` sözdizimi yapısını kullanır ve eşleme türünün değişlenleri, `mapping(KeyType => ValueType) VariableName` sözdizimi kullanılarak bildirilir.
`KeyType`, herhangi bir yerleşik değer türü, `bytes`, `string`, herhangi bir sözleşme ya da numaralandırma türü olabilir. Eşlemeler, yapılar veya dizi türleri gibi diğer kullanıcı tanımlı veya karmaşık türlere izin verilmez. `ValueType`, eşlemeleri, dizileri ve yapıları içeren herhangi bir tür olabilir.
Eşlemeleri, olası her anahtarın var olduğu ve bir türün [varsayılan değeri](https://docs.soliditylang.org/tr/latest/control-structures.html#default-value) olan bayt temsilinin tamamı sıfır olan bir değere eşlendiği şekilde sanal olarak başlatılan [karma tablolar](https://en.wikipedia.org/wiki/Hash_table) olarak düşünebilirsiniz. Benzerlik burada sona eriyor, anahtar veriler bir eşlemede saklanmıyor, değeri aramak için yalnızca `keccak256` karma değeri kullanılıyor.
Bu nedenle, eşlemelerin bir uzunluğu veya ayarlanan bir anahtar veya değer kavramı yoktur ve bu nedenle atanan anahtarlarla ilgili ek bilgi olmadan silinemezler (bkz. [Mappingleri Temizleme](https://docs.soliditylang.org/tr/latest/security-considerations.html#clearing-mappings)).
Eşlemeler yalnızca `storage` veri konumuna sahip olabilir ve bu nedenle, fonksiyonlardaki depolama referans türleri olarak veya kitaplık fonksiyonları için parametreler olarak durum değişkenleri için izin verilir. Bunlar, genel olarak görülebilen sözleşme fonksiyonlarının parametreleri veya dönüş parametreleri olarak kullanılamazlar. Bu kısıtlamalar, eşlemeler içeren diziler ve yapılar için de geçerlidir.
Eşleme türündeki durum değişkenlerini `public` olarak işaretleyebilirsiniz ve Solidity sizin için bir [alıcı](https://docs.soliditylang.org/tr/latest/contracts.html#visibility-and-getters) oluşturur. `KeyType`, alıcı için bir parametre olur. `ValueType` bir değer türü veya yapıysa, alıcı `ValueType` değerini döndürür. `ValueType` bir dizi veya eşleme ise, alıcının her bir `KeyType` için yinelemeli olarak bir parametresi vardır.
Aşağıdaki örnekte, `MappingExample` sözleşmesi, anahtar türü bir `address` olan genel bir `balances` eşlemesini ve bir Ethereum adresini işaretsiz bir tamsayı değerine eşleyen bir `uint` değer türünü tanımlar. `uint` bir değer türü olduğundan, alıcı, belirtilen adreste değeri döndüren `MappingUser` sözleşmesinde görebileceğiniz türle eşleşen bir değer döndürür.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgTWFwcGluZ0V4YW1wbGUgewogICAgbWFwcGluZyhhZGRyZXNzID0+IHVpbnQpIHB1YmxpYyBiYWxhbmNlczsKCiAgICBmdW5jdGlvbiB1cGRhdGUodWludCBuZXdCYWxhbmNlKSBwdWJsaWMgewogICAgICAgIGJhbGFuY2VzW21zZy5zZW5kZXJdID0gbmV3QmFsYW5jZTsKICAgIH0KfQoKY29udHJhY3QgTWFwcGluZ1VzZXIgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgTWFwcGluZ0V4YW1wbGUgbSA9IG5ldyBNYXBwaW5nRXhhbXBsZSgpOwogICAgICAgIG0udXBkYXRlKDEwMCk7CiAgICAgICAgcmV0dXJuIG0uYmFsYW5jZXMoYWRkcmVzcyh0aGlzKSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract MappingExample {
 mapping(address \=> uint) public balances;
 function update(uint newBalance) public {
 balances\[msg.sender\] \= newBalance;
 }
}
contract MappingUser {
 function f() public returns (uint) {
 MappingExample m \= new MappingExample();
 m.update(100);
 return m.balances(address(this));
 }
}
Aşağıdaki örnek, bir [ERC20 tokenin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol) basitleştirilmiş bir versiyonudur. `_allowances`, başka bir eşleme türü içindeki eşleme türüne bir örnektir.
Aşağıdaki örnekte, başka birinin hesabınızdan çekmesine izin verilen tutarı kaydetmek için `_allowances` kullanılmıştır.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCmNvbnRyYWN0IE1hcHBpbmdFeGFtcGxlIHsKCiAgICBtYXBwaW5nIChhZGRyZXNzID0+IHVpbnQyNTYpIHByaXZhdGUgX2JhbGFuY2VzOwogICAgbWFwcGluZyAoYWRkcmVzcyA9PiBtYXBwaW5nIChhZGRyZXNzID0+IHVpbnQyNTYpKSBwcml2YXRlIF9hbGxvd2FuY2VzOwoKICAgIGV2ZW50IFRyYW5zZmVyKGFkZHJlc3MgaW5kZXhlZCBmcm9tLCBhZGRyZXNzIGluZGV4ZWQgdG8sIHVpbnQyNTYgdmFsdWUpOwogICAgZXZlbnQgQXBwcm92YWwoYWRkcmVzcyBpbmRleGVkIG93bmVyLCBhZGRyZXNzIGluZGV4ZWQgc3BlbmRlciwgdWludDI1NiB2YWx1ZSk7CgogICAgZnVuY3Rpb24gYWxsb3dhbmNlKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3Mgc3BlbmRlcikgcHVibGljIHZpZXcgcmV0dXJucyAodWludDI1NikgewogICAgICAgIHJldHVybiBfYWxsb3dhbmNlc1tvd25lcl1bc3BlbmRlcl07CiAgICB9CgogICAgZnVuY3Rpb24gdHJhbnNmZXJGcm9tKGFkZHJlc3Mgc2VuZGVyLCBhZGRyZXNzIHJlY2lwaWVudCwgdWludDI1NiBhbW91bnQpIHB1YmxpYyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmVxdWlyZShfYWxsb3dhbmNlc1tzZW5kZXJdW21zZy5zZW5kZXJdID49IGFtb3VudCwgIkVSQzIwOiBBbGxvd2FuY2Ugbm90IGhpZ2ggZW5vdWdoLiIpOwogICAgICAgIF9hbGxvd2FuY2VzW3NlbmRlcl1bbXNnLnNlbmRlcl0gLT0gYW1vdW50OwogICAgICAgIF90cmFuc2ZlcihzZW5kZXIsIHJlY2lwaWVudCwgYW1vdW50KTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBhcHByb3ZlKGFkZHJlc3Mgc3BlbmRlciwgdWludDI1NiBhbW91bnQpIHB1YmxpYyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmVxdWlyZShzcGVuZGVyICE9IGFkZHJlc3MoMCksICJFUkMyMDogYXBwcm92ZSB0byB0aGUgemVybyBhZGRyZXNzIik7CgogICAgICAgIF9hbGxvd2FuY2VzW21zZy5zZW5kZXJdW3NwZW5kZXJdID0gYW1vdW50OwogICAgICAgIGVtaXQgQXBwcm92YWwobXNnLnNlbmRlciwgc3BlbmRlciwgYW1vdW50KTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBfdHJhbnNmZXIoYWRkcmVzcyBzZW5kZXIsIGFkZHJlc3MgcmVjaXBpZW50LCB1aW50MjU2IGFtb3VudCkgaW50ZXJuYWwgewogICAgICAgIHJlcXVpcmUoc2VuZGVyICE9IGFkZHJlc3MoMCksICJFUkMyMDogdHJhbnNmZXIgZnJvbSB0aGUgemVybyBhZGRyZXNzIik7CiAgICAgICAgcmVxdWlyZShyZWNpcGllbnQgIT0gYWRkcmVzcygwKSwgIkVSQzIwOiB0cmFuc2ZlciB0byB0aGUgemVybyBhZGRyZXNzIik7CiAgICAgICAgcmVxdWlyZShfYmFsYW5jZXNbc2VuZGVyXSA+PSBhbW91bnQsICJFUkMyMDogTm90IGVub3VnaCBmdW5kcy4iKTsKCiAgICAgICAgX2JhbGFuY2VzW3NlbmRlcl0gLT0gYW1vdW50OwogICAgICAgIF9iYWxhbmNlc1tyZWNpcGllbnRdICs9IGFtb3VudDsKICAgICAgICBlbWl0IFRyYW5zZmVyKHNlbmRlciwgcmVjaXBpZW50LCBhbW91bnQpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.22 <0.9.0;
contract MappingExample {
 mapping (address \=> uint256) private \_balances;
 mapping (address \=> mapping (address \=> uint256)) private \_allowances;
 event Transfer(address indexed from, address indexed to, uint256 value);
 event Approval(address indexed owner, address indexed spender, uint256 value);
 function allowance(address owner, address spender) public view returns (uint256) {
 return \_allowances\[owner\]\[spender\];
 }
 function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
 require(\_allowances\[sender\]\[msg.sender\] \>= amount, "ERC20: Allowance not high enough.");
 \_allowances\[sender\]\[msg.sender\] \-= amount;
 \_transfer(sender, recipient, amount);
 return true;
 }
 function approve(address spender, uint256 amount) public returns (bool) {
 require(spender != address(0), "ERC20: approve to the zero address");
 \_allowances\[msg.sender\]\[spender\] \= amount;
 emit Approval(msg.sender, spender, amount);
 return true;
 }
 function \_transfer(address sender, address recipient, uint256 amount) internal {
 require(sender != address(0), "ERC20: transfer from the zero address");
 require(recipient != address(0), "ERC20: transfer to the zero address");
 require(\_balances\[sender\] \>= amount, "ERC20: Not enough funds.");
 \_balances\[sender\] \-= amount;
 \_balances\[recipient\] += amount;
 emit Transfer(sender, recipient, amount);
 }
}
### Yinelenebilir Eşlemeler[](#yinelenebilir-eslemeler "Permalink to this heading")
Eşlemeleri yineleyemezsiniz, yani anahtarlarını numaralandıramazsınız. Yine de bunların üzerine bir veri yapısı uygulamak ve bunun üzerinde yineleme yapmak mümkündür. Örneğin, aşağıdaki kod, `User` sözleşmesinin daha sonra veri eklediği bir `IterableMapping` kitaplığı uygular ve `sum` fonksiyonu tüm değerleri toplamak için yinelenir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguODsKCnN0cnVjdCBJbmRleFZhbHVlIHsgdWludCBrZXlJbmRleDsgdWludCB2YWx1ZTsgfQpzdHJ1Y3QgS2V5RmxhZyB7IHVpbnQga2V5OyBib29sIGRlbGV0ZWQ7IH0KCnN0cnVjdCBpdG1hcCB7CiAgICBtYXBwaW5nKHVpbnQgPT4gSW5kZXhWYWx1ZSkgZGF0YTsKICAgIEtleUZsYWdbXSBrZXlzOwogICAgdWludCBzaXplOwp9Cgp0eXBlIEl0ZXJhdG9yIGlzIHVpbnQ7CgpsaWJyYXJ5IEl0ZXJhYmxlTWFwcGluZyB7CiAgICBmdW5jdGlvbiBpbnNlcnQoaXRtYXAgc3RvcmFnZSBzZWxmLCB1aW50IGtleSwgdWludCB2YWx1ZSkgaW50ZXJuYWwgcmV0dXJucyAoYm9vbCByZXBsYWNlZCkgewogICAgICAgIHVpbnQga2V5SW5kZXggPSBzZWxmLmRhdGFba2V5XS5rZXlJbmRleDsKICAgICAgICBzZWxmLmRhdGFba2V5XS52YWx1ZSA9IHZhbHVlOwogICAgICAgIGlmIChrZXlJbmRleCA+IDApCiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIGVsc2UgewogICAgICAgICAgICBrZXlJbmRleCA9IHNlbGYua2V5cy5sZW5ndGg7CiAgICAgICAgICAgIHNlbGYua2V5cy5wdXNoKCk7CiAgICAgICAgICAgIHNlbGYuZGF0YVtrZXldLmtleUluZGV4ID0ga2V5SW5kZXggKyAxOwogICAgICAgICAgICBzZWxmLmtleXNba2V5SW5kZXhdLmtleSA9IGtleTsKICAgICAgICAgICAgc2VsZi5zaXplKys7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gcmVtb3ZlKGl0bWFwIHN0b3JhZ2Ugc2VsZiwgdWludCBrZXkpIGludGVybmFsIHJldHVybnMgKGJvb2wgc3VjY2VzcykgewogICAgICAgIHVpbnQga2V5SW5kZXggPSBzZWxmLmRhdGFba2V5XS5rZXlJbmRleDsKICAgICAgICBpZiAoa2V5SW5kZXggPT0gMCkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIGRlbGV0ZSBzZWxmLmRhdGFba2V5XTsKICAgICAgICBzZWxmLmtleXNba2V5SW5kZXggLSAxXS5kZWxldGVkID0gdHJ1ZTsKICAgICAgICBzZWxmLnNpemUgLS07CiAgICB9CgogICAgZnVuY3Rpb24gY29udGFpbnMoaXRtYXAgc3RvcmFnZSBzZWxmLCB1aW50IGtleSkgaW50ZXJuYWwgdmlldyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmV0dXJuIHNlbGYuZGF0YVtrZXldLmtleUluZGV4ID4gMDsKICAgIH0KCiAgICBmdW5jdGlvbiBpdGVyYXRlU3RhcnQoaXRtYXAgc3RvcmFnZSBzZWxmKSBpbnRlcm5hbCB2aWV3IHJldHVybnMgKEl0ZXJhdG9yKSB7CiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yU2tpcERlbGV0ZWQoc2VsZiwgMCk7CiAgICB9CgogICAgZnVuY3Rpb24gaXRlcmF0ZVZhbGlkKGl0bWFwIHN0b3JhZ2Ugc2VsZiwgSXRlcmF0b3IgaXRlcmF0b3IpIGludGVybmFsIHZpZXcgcmV0dXJucyAoYm9vbCkgewogICAgICAgIHJldHVybiBJdGVyYXRvci51bndyYXAoaXRlcmF0b3IpIDwgc2VsZi5rZXlzLmxlbmd0aDsKICAgIH0KCiAgICBmdW5jdGlvbiBpdGVyYXRlTmV4dChpdG1hcCBzdG9yYWdlIHNlbGYsIEl0ZXJhdG9yIGl0ZXJhdG9yKSBpbnRlcm5hbCB2aWV3IHJldHVybnMgKEl0ZXJhdG9yKSB7CiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yU2tpcERlbGV0ZWQoc2VsZiwgSXRlcmF0b3IudW53cmFwKGl0ZXJhdG9yKSArIDEpOwogICAgfQoKICAgIGZ1bmN0aW9uIGl0ZXJhdGVHZXQoaXRtYXAgc3RvcmFnZSBzZWxmLCBJdGVyYXRvciBpdGVyYXRvcikgaW50ZXJuYWwgdmlldyByZXR1cm5zICh1aW50IGtleSwgdWludCB2YWx1ZSkgewogICAgICAgIHVpbnQga2V5SW5kZXggPSBJdGVyYXRvci51bndyYXAoaXRlcmF0b3IpOwogICAgICAgIGtleSA9IHNlbGYua2V5c1trZXlJbmRleF0ua2V5OwogICAgICAgIHZhbHVlID0gc2VsZi5kYXRhW2tleV0udmFsdWU7CiAgICB9CgogICAgZnVuY3Rpb24gaXRlcmF0b3JTa2lwRGVsZXRlZChpdG1hcCBzdG9yYWdlIHNlbGYsIHVpbnQga2V5SW5kZXgpIHByaXZhdGUgdmlldyByZXR1cm5zIChJdGVyYXRvcikgewogICAgICAgIHdoaWxlIChrZXlJbmRleCA8IHNlbGYua2V5cy5sZW5ndGggJiYgc2VsZi5rZXlzW2tleUluZGV4XS5kZWxldGVkKQogICAgICAgICAgICBrZXlJbmRleCsrOwogICAgICAgIHJldHVybiBJdGVyYXRvci53cmFwKGtleUluZGV4KTsKICAgIH0KfQoKLy8gTmFzxLFsIGt1bGxhbsSxbMSxcgpjb250cmFjdCBVc2VyIHsKICAgIC8vIFNhZGVjZSB2ZXJpbGVyaW1pemkgdHV0YW4gYmlyIHlhcMSxLgogICAgaXRtYXAgZGF0YTsKICAgIC8vIFZlcmkgdMO8csO8bmUga2l0YXBsxLFrIGZvbmtzaXlvbmxhcsSxbsSxIHV5Z3VsYXnEsW4uCiAgICB1c2luZyBJdGVyYWJsZU1hcHBpbmcgZm9yIGl0bWFwOwoKICAgIC8vIEJpciDFn2V5bGVyaSBla2xlCiAgICBmdW5jdGlvbiBpbnNlcnQodWludCBrLCB1aW50IHYpIHB1YmxpYyByZXR1cm5zICh1aW50IHNpemUpIHsKICAgICAgICAvLyBCdSwgSXRlcmFibGVNYXBwaW5nLmluc2VydChkYXRhLCBrLCB2KSd5aSDDp2HEn8SxcsSxci4KICAgICAgICBkYXRhLmluc2VydChrLCB2KTsKICAgICAgICAvLyBZYXDEsW7EsW4gw7x5ZWxlcmluZSBoYWxhIGVyacWfZWJpbGlyaXosCiAgICAgICAgLy8gYW1hIGJ1bmxhcmxhIHXEn3JhxZ9tYW1heWEgw7Z6ZW4gZ8O2c3Rlcm1lbGl5aXouCiAgICAgICAgcmV0dXJuIGRhdGEuc2l6ZTsKICAgIH0KCiAgICAvLyBEZXBvbGFuYW4gdMO8bSB2ZXJpbGVyaW4gdG9wbGFtxLFuxLEgaGVzYXBsYXIuCiAgICBmdW5jdGlvbiBzdW0oKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50IHMpIHsKICAgICAgICBmb3IgKAogICAgICAgICAgICBJdGVyYXRvciBpID0gZGF0YS5pdGVyYXRlU3RhcnQoKTsKICAgICAgICAgICAgZGF0YS5pdGVyYXRlVmFsaWQoaSk7CiAgICAgICAgICAgIGkgPSBkYXRhLml0ZXJhdGVOZXh0KGkpCiAgICAgICAgKSB7CiAgICAgICAgICAgICgsIHVpbnQgdmFsdWUpID0gZGF0YS5pdGVyYXRlR2V0KGkpOwogICAgICAgICAgICBzICs9IHZhbHVlOwogICAgICAgIH0KICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.8;
struct IndexValue { uint keyIndex; uint value; }
struct KeyFlag { uint key; bool deleted; }
struct itmap {
 mapping(uint \=> IndexValue) data;
 KeyFlag\[\] keys;
 uint size;
}
type Iterator is uint;
library IterableMapping {
 function insert(itmap storage self, uint key, uint value) internal returns (bool replaced) {
 uint keyIndex \= self.data\[key\].keyIndex;
 self.data\[key\].value \= value;
 if (keyIndex \> 0)
 return true;
 else {
 keyIndex \= self.keys.length;
 self.keys.push();
 self.data\[key\].keyIndex \= keyIndex + 1;
 self.keys\[keyIndex\].key \= key;
 self.size++;
 return false;
 }
 }
 function remove(itmap storage self, uint key) internal returns (bool success) {
 uint keyIndex \= self.data\[key\].keyIndex;
 if (keyIndex \== 0)
 return false;
 delete self.data\[key\];
 self.keys\[keyIndex \- 1\].deleted \= true;
 self.size \--;
 }
 function contains(itmap storage self, uint key) internal view returns (bool) {
 return self.data\[key\].keyIndex \> 0;
 }
 function iterateStart(itmap storage self) internal view returns (Iterator) {
 return iteratorSkipDeleted(self, 0);
 }
 function iterateValid(itmap storage self, Iterator iterator) internal view returns (bool) {
 return Iterator.unwrap(iterator) < self.keys.length;
 }
 function iterateNext(itmap storage self, Iterator iterator) internal view returns (Iterator) {
 return iteratorSkipDeleted(self, Iterator.unwrap(iterator) + 1);
 }
 function iterateGet(itmap storage self, Iterator iterator) internal view returns (uint key, uint value) {
 uint keyIndex \= Iterator.unwrap(iterator);
 key \= self.keys\[keyIndex\].key;
 value \= self.data\[key\].value;
 }
 function iteratorSkipDeleted(itmap storage self, uint keyIndex) private view returns (Iterator) {
 while (keyIndex < self.keys.length && self.keys\[keyIndex\].deleted)
 keyIndex++;
 return Iterator.wrap(keyIndex);
 }
}
// Nasıl kullanılır
contract User {
 // Sadece verilerimizi tutan bir yapı.
 itmap data;
 // Veri türüne kitaplık fonksiyonlarını uygulayın.
 using IterableMapping for itmap;
 // Bir şeyleri ekle
 function insert(uint k, uint v) public returns (uint size) {
 // Bu, IterableMapping.insert(data, k, v)'yi çağırır.
 data.insert(k, v);
 // Yapının üyelerine hala erişebiliriz,
 // ama bunlarla uğraşmamaya özen göstermeliyiz.
 return data.size;
 }
 // Depolanan tüm verilerin toplamını hesaplar.
 function sum() public view returns (uint s) {
 for (
 Iterator i \= data.iterateStart();
 data.iterateValid(i);
 i \= data.iterateNext(i)
 ) {
 (, uint value) \= data.iterateGet(i);
 s += value;
 }
 }
}
## Operatörler[](#operatorler "Permalink to this heading")
Aritmetik operatörler ve bit operatörleri, iki işlenen aynı türe sahip olmasa bile uygulanabilir. Örneğin, `y = x + z` yi hesaplayabilirsiniz, burada `x` bir `uint8` dir ve `z` nin türü `uint32` dir. Bu durumlarda, işlemin hesaplandığı türü (taşma durumunda bu önemlidir) ve operatörün sonucunun türünü belirlemek için aşağıdaki mekanizma kullanılacaktır:
1. Sağ işlenenin türü dolaylı olarak sol işlenenin türüne dönüştürülebiliyorsa,
 
 sol işlenenin türünü kullanın.
 
2. Sol işlenenin türü dolaylı olarak sağ işlenenin türüne dönüştürülebiliyorsa,
 
 sağ işlenenin türünü kullanın,
 
3. İki seçenek de uygulanamıyorsa işleme izin verilmez.
 
İşlenenlerden birinin [gerçek sayı](#rational-literals) olması durumunda, ilk önce değeri tutabilen en küçük tür olan “mobil türe” dönüştürülür (aynı bit genişliğindeki işaretsiz türler, işaretli türlerden “daha küçük” olarak kabul edilir) .
Her ikisi de gerçek sayıysa, işlem keyfi bir kesinlikle hesaplanır.
Operatörün sonuç türü, sonucun her zaman `bool` olduğu karşılaştırma operatörleri dışında, işlemin gerçekleştirildiği türle aynıdır.
`**` (üs alma), `<<` ve `>>` operatörleri, işlem ve sonuç için sol işlenenin türünü kullanır.
### Üçlü Operatör[](#uclu-operator "Permalink to this heading")
Üçlü operatör, `<expression> ? <trueExpression> : <falseExpression>` formunda bulunan ifadelerin açıklanmasında kullanılır. Ana `<expression>` değerlendirmesinin sonucuna bağlı olarak verilen son iki ifadeden birini değerlendirir. `<expression>` “doğru” olarak değerlendirilirse, `<trueExpression>` olarak sayılır, aksi takdirde `<falseExpression>` olarak sayılır.
Üçlü operatörün sonucu, tüm işlenenleri rasyonel sayı değişmezleri olsa bile, bir rasyonel sayı türüne sahip değildir. Sonuç türü, iki işlenenin türlerinden yukarıdakiyle aynı şekilde belirlenir, gerekirse ilk önce mobil türlerine dönüştürülür.
Sonuç olarak, `255 + (true ? 1 : 0)` işlemi, aritmetik taşma nedeniyle geri döndürülecektir (revert edilecektir). Bunun nedeni, `(true ? 1 : 0)` ifadesinin `uint8` türünde olmasıdır.Bu, eklemenin `uint8` içinde gerçekleştirilmesini zorunlu kılıyor ve 256’nın bu tür için izin verilen aralığı aşıyor.
Diğer bir sonuç da, `1.5 + 1.5` gibi bir ifadenin geçerli olduğu, ancak `1.5 + (true ? 1.5 : 2.5)` olmadığıdır. Bunun nedeni, birincisinin sınırsız kesinlikle değerlendirilen rasyonel bir ifade olması ve yalnızca nihai değerinin önemli olmasıdır. İkincisi, şu anda izin verilmeyen bir kesirli rasyonel sayının bir tam sayıya dönüştürülmesini içerir.
### Bileşik Operatörler ve Artırma/Azaltma Operatörleri[](#bilesik-operatorler-ve-artirma-azaltma-operatorleri "Permalink to this heading")
`a` bir LValue ise (yani bir değişken veya atanabilecek bir şey), aşağıdaki operatörler kısayol olarak kullanılabilir:
`a += e`, `a = a + e` ile eşdeğerdir. `-=`, `*=`, `/=`, `%=`, `|=`, `&=`, `^=`, `<<=` ve `>>=` buna göre tanımlanır. `a++` ve `a--`, `a += 1` / `a -= 1` ile eşdeğerdir, ancak ifadenin kendisi hala önceki `a` değerine sahiptir. Buna karşılık, `--a` ve `++a`, `a` üzerinde aynı etkiye sahiptir ancak değişiklikten sonra değeri döndürür.
### silmek[](#silmek "Permalink to this heading")
`delete a`, türün başlangıç değerini `a``ya atar. Yani, tamsayılar için ``a = 0` ile eşdeğerdir, ancak sıfır uzunlukta dinamik bir dizi veya tüm öğeleri başlangıç değerlerine ayarlanmış aynı uzunlukta statik bir dizi atadığı dizilerde de kullanılabilir.
`delete a[x]`, dizinin `x` dizinindeki öğeyi siler ve diğer tüm öğelere ve dizinin uzunluğuna dokunmadan bırakır. Bu özellikle dizide bir boşluk bırakıldığı anlamına gelir. Öğeleri kaldırmayı planlıyorsanız, [eşleme](#mapping-types) yapmak muhtemelen daha iyi bir seçimdir.
Yapılar (structs) için, tüm üyelerin sıfırlandığı bir yapı atar. Başka bir deyişle, `a` nın `delete a` dan sonraki değeri, `a` nın atama olmadan bildirilmesiyle aynıdır:
`delete` fonksiyonunun eşlemeler üzerinde hiçbir etkisi yoktur (çünkü eşlemelerin anahtarları rastgele olabilir ve genellikle bilinmez). Bu nedenle, bir yapıyı silerseniz, eşleme olmayan tüm üyeleri sıfırlar ve eşleme olmadıkça üyelere geri döner. Ancak, bireysel anahtarlar ve eşledikleri şey silinebilir: `a` bir eşleme ise, `delete a[x]` , `x` de depolanan değeri siler.
`delete a` nın gerçekten `a` ya atanmış gibi davrandığını, yani `a` da yeni bir nesne depoladığını unutmamak önemlidir. Bu ayrım, `a` referans değişkeni olduğunda görünür: Daha önce atıfta bulunduğu değeri değil, yalnızca `a` nın kendisini sıfırlayacaktır.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgRGVsZXRlRXhhbXBsZSB7CiAgICB1aW50IGRhdGE7CiAgICB1aW50W10gZGF0YUFycmF5OwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIHVpbnQgeCA9IGRhdGE7CiAgICAgICAgZGVsZXRlIHg7IC8vIHgnaSAwJ2EgYXlhcmxhciwgdmVyaWxlcmkgZXRraWxlbWV6CiAgICAgICAgZGVsZXRlIGRhdGE7IC8vIHZlcmlsZXJpIDAnYSBheWFybGFyLCB4J2kgZXRraWxlbWV6CiAgICAgICAgdWludFtdIHN0b3JhZ2UgeSA9IGRhdGFBcnJheTsKICAgICAgICBkZWxldGUgZGF0YUFycmF5OyAvLyBidSwgZGF0YUFycmF5Lmxlbmd0aCBkZcSfZXJpbmkgc8SxZsSxcmEgYXlhcmxhciwgYW5jYWsgdWludFtdIGthcm1hxZ/EsWsgYmlyIG5lc25lIG9sZHXEn3VuZGFuLAogICAgICAgIC8vIGRlcG9sYW1hIG5lc25lc2luaW4gZGnEn2VyIGFkxLEgb2xhbiB5IGRhIGV0a2lsZW5pci4KICAgICAgICAvLyDDlnRlIHlhbmRhbjogImRlbGV0ZSB5IiBnZcOnZXJsaSBkZcSfaWxkaXIsIMOnw7xua8O8IGRlcG9sYW1hIG5lc25lbGVyaW5lIGJhxZ92dXJhbiB5ZXJlbCBkZcSfacWfa2VubGVyZSBhdGFtYWxhciB5YWxuxLF6Y2EgbWV2Y3V0IGRlcG9sYW1hIG5lc25lbGVyaW5kZW4geWFwxLFsYWJpbGlyLgogICAgICAgIGFzc2VydCh5Lmxlbmd0aCA9PSAwKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract DeleteExample {
 uint data;
 uint\[\] dataArray;
 function f() public {
 uint x \= data;
 delete x; // x'i 0'a ayarlar, verileri etkilemez
 delete data; // verileri 0'a ayarlar, x'i etkilemez
 uint\[\] storage y \= dataArray;
 delete dataArray; // bu, dataArray.length değerini sıfıra ayarlar, ancak uint\[\] karmaşık bir nesne olduğundan,
 // depolama nesnesinin diğer adı olan y da etkilenir.
 // Öte yandan: "delete y" geçerli değildir, çünkü depolama nesnelerine başvuran yerel değişkenlere atamalar yalnızca mevcut depolama nesnelerinden yapılabilir.
 assert(y.length \== 0);
 }
}
### Operatörlerin Öncelik Sırası[](#operatorlerin-oncelik-sirasi "Permalink to this heading")
Aşağıdaki tablo, değerlendirme sırasına göre listelenen operatörler için öncelik sırasını belirtir.
Öncelik
Tanım
Operatör
_1_
Son ek ile tırma ve azaltma
`++`, `--`
Yeni ifade
`new <typename>`
Dizi elamanı görüntüleme
`<array>[<index>]`
Üye erişimi
`<object>.<member>`
Fonksiyon çağırımı
`<func>(<args...>)`
Parantezler
`(<statement>)`
_2_
Ön ek ile artırma ve azaltma
`++`, `--`
Tekli çıkarma
`-`
Tekli işlemler
`delete`
Mantıksal ‘DEĞİL’
`!`
Bitsel ‘DEĞİL’
`~`
_3_
Üs alma
`**`
_4_
Çarpma, bölme ve mod alma
`*`, `/`, `%`
_5_
Ekleme ve çıkarma
`+`, `-`
_6_
Bitsel değiştirme operatörleri
`<<`, `>>`
_7_
Bitsel ‘VE’
`&`
_8_
Bitsel ‘Özel veya’
`^`
_9_
Bitsel ‘YA DA’
`|`
_10_
Eşitsizlik operatörleri
`<`, `>`, `<=`, `>=`
_11_
Eşitlik operatörleri
`==`, `!=`
_12_
Mantıksal ‘VE’
`&&`
_13_
Mantıksal ‘YA DA’
`||`
_14_
Üçlü operatör
`<conditional> ? <if-true> : <if-false>`
Atama operatörleri
`=`, `|=`, `^=`, `&=`, `<<=`, `>>=`, `+=`, `-=`, `*=`, `/=`, `%=`
_15_
Virgül operatörü
`,`
## Temel Türler Arası Dönüşümler[](#temel-turler-arasi-donusumler "Permalink to this heading")
### Örtülü Dönüşümler[](#ortulu-donusumler "Permalink to this heading")
Örtülü tür dönüşümü, argümanları fonksiyonlara iletme ya da operatör atamaları sırasında, derleyici tarafından otomatik olarak uygulanır. Genel olarak, bilgi kaybı yoksa ve anlamsal açıdan bir sorun yoksa, değer türleri arasında örtülü bir dönüşüm mümkündür.
Örneğin, `uint8` türü, `uint16` türüne ve `int128` türü, `int256` türüne dönüştürülebilirken, `int8` türü `uint256` türüne dönüştürülemez çünkü `uint256`, `-1` gibi değerleri tutamaz.
Bir operatör birbirinden farklı türlere uygulanırsa, derleyici işlenenlerden birini örtük olarak diğerinin türüne dönüştürmeye çalışır (aynısı atamalar için de geçerlidir). Bu, işlemlerin her zaman işlenenlerden birinin türünde gerçekleştirildiği anlamına gelir.
Hangi örtük dönüşümlerin mümkün olduğu hakkında daha fazla ayrıntı için, lütfen türlerle ilgili bölümlere bakın.
Aşağıdaki örnekte, toplamanın işlenenleri olarak `y` ve `z`, aynı türe sahip değildir, fakat `uint8` örtük olarak `uint16` türüne dönüştürülebilirken bunun tersi mümkün değildir. Bu sebeple, `uint16` türünde bir dönüştürme yapılmadan önce `y` türü, `z` türüne dönüştürülür. `y + z` ifadesinden elde edilen tür, `uint16` dır. Toplama işleminin sonucu `uint32` türünde bir değişkene atandığı için, toplama işleminden sonra yeniden örtük dönüştürme gerçekleşir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=dWludDggeTsKdWludDE2IHo7CnVpbnQzMiB4ID0geSArIHo7)
uint8 y;
uint16 z;
uint32 x \= y + z;
### Açık Dönüşümler[](#acik-donusumler "Permalink to this heading")
Derleyici örtük dönüştürmeye izin vermiyorsa ancak bir dönüştürmenin işe yarayacağından eminseniz, bazen açık bir tür dönüştürme mümkündür. Bu, beklenmeyen davranışlara neden olabilir ve derleyicinin bazı güvenlik özelliklerini atlamanıza izin verir, bu nedenle sonucun istediğiniz ve beklediğiniz gibi olduğunu test ettiğinizden emin olun!
Negatif değere sahip bir `int` değişkenini, `uint` değişkenine dönüştüren aşağıdaki örneği ele alalım:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=aW50ICB5ID0gLTM7CnVpbnQgeCA9IHVpbnQoeSk7)
int y \= \-3;
uint x \= uint(y);
Bu kod bloğunun sonunda `x`, `0xfffff..fd` (64 adet onaltılık karaker) değerine sahip olacaktır, bu, iki’nin 256 bitlik tümleyen (two’s complement) temsili olan -3’tür.
Bir tam sayı, kendisinden daha küçük bir türe açık şekilde dönüştürülürse, daha yüksek dereceli bitler kesilir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=dWludDMyIGEgPSAweDEyMzQ1Njc4Owp1aW50MTYgYiA9IHVpbnQxNihhKTsgLy8gYiwgMHg1Njc4IG9sYWNha3TEsXI=)
uint32 a \= 0x12345678;
uint16 b \= uint16(a); // b, 0x5678 olacaktır
Bir tam sayı, kendisinden daha büyük bir türe açık şekilde dönüştürülürse, elde edilen ortak tümleyenin solu yani daha yüksek dereceli ucu doldurulur. Dönüşümün sonucu orijinal tam sayıya eşit olacaktır:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=dWludDE2IGEgPSAweDEyMzQ7CnVpbnQzMiBiID0gdWludDMyKGEpOyAvLyBiLCAweDAwMDAxMjM0IG9sYWNha3TEsXIKYXNzZXJ0KGEgPT0gYik7)
uint16 a \= 0x1234;
uint32 b \= uint32(a); // b, 0x00001234 olacaktır
assert(a \== b);
Sabit boyutlu bayt dizisi türleri, dönüşümler sırasında farklı davranır. Bireysel bayt dizileri olarak düşünülebilirler ve daha küçük bir türe dönüştürmek diziyi kesecektir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ynl0ZXMyIGEgPSAweDEyMzQ7CmJ5dGVzMSBiID0gYnl0ZXMxKGEpOyAvLyBiLCAweDEyIG9sYWNha3TEsXI=)
bytes2 a \= 0x1234;
bytes1 b \= bytes1(a); // b, 0x12 olacaktır
Sabit boyutlu bir bayt dizisi türü, daha büyük bir türe açıkça dönüştürülürse, elde edilen ortak tümleyen sağ tarafta doldurulur. Sabit bir dizindeki bayt dizisine erişmek, dönüştürmeden önce ve sonra aynı değerle sonuçlanır (dizin hala aralıktaysa):
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ynl0ZXMyIGEgPSAweDEyMzQ7CmJ5dGVzNCBiID0gYnl0ZXM0KGEpOyAvLyBiLCAweDEyMzQwMDAwIG9sYWNha3TEsXIKYXNzZXJ0KGFbMF0gPT0gYlswXSk7CmFzc2VydChhWzFdID09IGJbMV0pOw==)
bytes2 a \= 0x1234;
bytes4 b \= bytes4(a); // b, 0x12340000 olacaktır
assert(a\[0\] \== b\[0\]);
assert(a\[1\] \== b\[1\]);
Tamsayılar ve sabit boyutlu bayt dizileri, kesme veya doldurma sırasında farklı davrandığından, tamsayılar ve sabit boyutlu bayt dizileri arasındaki açık dönüştürmelere yalnızca, her ikisi de aynı boyuta sahipse izin verilir. Farklı boyuttaki tamsayılar ve sabit boyutlu bayt dizileri arasında dönüştürmek istiyorsanız, istenen kesme ve doldurma kurallarını açık hale getiren ara dönüşümleri kullanmanız gerekir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ynl0ZXMyIGEgPSAweDEyMzQ7CnVpbnQzMiBiID0gdWludDE2KGEpOyAvLyBiLCAweDAwMDAxMjM0IG9sYWNha3TEsXIKdWludDMyIGMgPSB1aW50MzIoYnl0ZXM0KGEpKTsgLy8gYywgMHgxMjM0MDAwMCBvbGFjYWt0xLFyCnVpbnQ4IGQgPSB1aW50OCh1aW50MTYoYSkpOyAvLyBkLCAweDM0IG9sYWNha3TEsXIKdWludDggZSA9IHVpbnQ4KGJ5dGVzMShhKSk7IC8vIGUsIDB4MTIgb2xhY2FrdMSxcg==)
bytes2 a \= 0x1234;
uint32 b \= uint16(a); // b, 0x00001234 olacaktır
uint32 c \= uint32(bytes4(a)); // c, 0x12340000 olacaktır
uint8 d \= uint8(uint16(a)); // d, 0x34 olacaktır
uint8 e \= uint8(bytes1(a)); // e, 0x12 olacaktır
`bytes` dizileri ve `bytes` çağrı verisi (calldata) dilimleri, sabit bayt türlerine(`bytes1`/…/`bytes32`) açıkça dönüştürülebilir. Dizinin hedef sabit bayt türünden daha uzun olması durumunda, sonunda kesme gerçekleşir. Dizi hedef türden daha kısaysa, sonunda sıfırlarla doldurulur.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNTsKCmNvbnRyYWN0IEMgewogICAgYnl0ZXMgcyA9ICJhYmNkZWZnaCI7CiAgICBmdW5jdGlvbiBmKGJ5dGVzIGNhbGxkYXRhIGMsIGJ5dGVzIG1lbW9yeSBtKSBwdWJsaWMgdmlldyByZXR1cm5zIChieXRlczE2LCBieXRlczMpIHsKICAgICAgICByZXF1aXJlKGMubGVuZ3RoID09IDE2LCAiIik7CiAgICAgICAgYnl0ZXMxNiBiID0gYnl0ZXMxNihtKTsgIC8vICdtJ2luIHV6dW5sdcSfdSAxNidkYW4gYsO8ecO8a3NlLCBrZXNtZSBnZXLDp2VrbGXFn2VjZWt0aXIKICAgICAgICBiID0gYnl0ZXMxNihzKTsgIC8vIHNhxJ9hIGdlbmnFn2xldGlsaXIsIHNvbnXDpyAiYWJjZGVmZ2hcMFwwXDBcMFwwXDBcMFwwIiBvbGFjYWt0xLFyCiAgICAgICAgYnl0ZXMzIGIxID0gYnl0ZXMzKHMpOyAvLyBrZXNpbGlyLCBiMSwgImFiYyJ5ZSBlxZ9pdHRpcgogICAgICAgIGIgPSBieXRlczE2KGNbOjhdKTsgIC8vIHPEsWbEsXJsYXIgaWxlIGdlbmnFn2xldGlsaXIKICAgICAgICByZXR1cm4gKGIsIGIxKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.5;
contract C {
 bytes s \= "abcdefgh";
 function f(bytes calldata c, bytes memory m) public view returns (bytes16, bytes3) {
 require(c.length \== 16, "");
 bytes16 b \= bytes16(m); // 'm'in uzunluğu 16'dan büyükse, kesme gerçekleşecektir
 b \= bytes16(s); // sağa genişletilir, sonuç "abcdefgh\\0\\0\\0\\0\\0\\0\\0\\0" olacaktır
 bytes3 b1 \= bytes3(s); // kesilir, b1, "abc"ye eşittir
 b \= bytes16(c\[:8\]); // sıfırlar ile genişletilir
 return (b, b1);
 }
}
## İfadeler (Literals) ve Temel Türler Arasındaki Dönüşümler[](#ifadeler-literals-ve-temel-turler-arasindaki-donusumler "Permalink to this heading")
### Tamsayı Türleri[](#tamsayi-turleri "Permalink to this heading")
Ondalık ve onaltılık sayı ifadeleri, onu kesmeden temsil edecek kadar büyük herhangi bir tamsayı türüne örtük olarak dönüştürülebilir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=dWludDggYSA9IDEyOyAvLyB1eWd1bgp1aW50MzIgYiA9IDEyMzQ7IC8vIHV5Z3VuCnVpbnQxNiBjID0gMHgxMjM0NTY7IC8vIGhhdGFsxLEsIMOnw7xua8O8IDB4MzQ1NiBvbGFjYWsgxZ9la2lsZGUga2VzaWxtZWsgem9ydW5kYWTEsXI=)
uint8 a \= 12; // uygun
uint32 b \= 1234; // uygun
uint16 c \= 0x123456; // hatalı, çünkü 0x3456 olacak şekilde kesilmek zorundadır
Not
0.8.0 sürümünden önce, herhangi bir ondalık veya onaltılık sayı ifadeleri bir tamsayı türüne açıkça dönüştürülebilirdi. 0.8.0’dan itibaren, bu tür açık dönüştürmeler, örtülü dönüştürmeler kadar katıdır, yani, yalnızca ifade elde edilen aralığa uyuyorsa bunlara izin verilir.
### Sabit Boyutlu Bayt Dizileri[](#id1 "Permalink to this heading")
Ondalık sayı ifadeleri örtük olarak sabit boyutlu bayt dizilerine dönüştürülemez. Onaltılık sayı ifadeleri olabilir, ancak yalnızca onaltılık basamak sayısı bayt türünün boyutuna tam olarak uyuyorsa. Bir istisna olarak, sıfır değerine sahip hem ondalık hem de onaltılık ifadeler herhangi bir sabit boyutlu bayt türüne dönüştürülebilir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ynl0ZXMyIGEgPSA1NDMyMTsgLy8gaXppbiB2ZXJpbG1legpieXRlczIgYiA9IDB4MTI7IC8vICBpemluIHZlcmlsbWV6CmJ5dGVzMiBjID0gMHgxMjM7IC8vIGl6aW4gdmVyaWxtZXoKYnl0ZXMyIGQgPSAweDEyMzQ7IC8vIHV5Z3VuCmJ5dGVzMiBlID0gMHgwMDEyOyAvLyB1eWd1bgpieXRlczQgZiA9IDA7IC8vIHV5Z3VuCmJ5dGVzNCBnID0gMHgwOyAvLyB1eWd1bg==)
bytes2 a \= 54321; // izin verilmez
bytes2 b \= 0x12; // izin verilmez
bytes2 c \= 0x123; // izin verilmez
bytes2 d \= 0x1234; // uygun
bytes2 e \= 0x0012; // uygun
bytes4 f \= 0; // uygun
bytes4 g \= 0x0; // uygun
String ifadeleri ve onaltılı string ifadeleri, karakter sayıları bayt türünün boyutuyla eşleşiyorsa, örtük olarak sabit boyutlu bayt dizilerine dönüştürülebilir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ynl0ZXMyIGEgPSBoZXgiMTIzNCI7IC8vIHV5Z3VuCmJ5dGVzMiBiID0gInh5IjsgLy8gdXlndW4KYnl0ZXMyIGMgPSBoZXgiMTIiOyAvLyBpemluIHZlcmlsbWV6CmJ5dGVzMiBkID0gaGV4IjEyMyI7IC8vIGl6aW4gdmVyaWxtZXoKYnl0ZXMyIGUgPSAieCI7IC8vIGl6aW4gdmVyaWxtZXoKYnl0ZXMyIGYgPSAieHl6IjsgLy8gaXppbiB2ZXJpbG1leg==)
bytes2 a \= hex"1234"; // uygun
bytes2 b \= "xy"; // uygun
bytes2 c \= hex"12"; // izin verilmez
bytes2 d \= hex"123"; // izin verilmez
bytes2 e \= "x"; // izin verilmez
bytes2 f \= "xyz"; // izin verilmez
### Adresler[](#id2 "Permalink to this heading")
> [Adres Değişmezleri](#address-literals) bölümünde açıklandığı gibi, sağlama toplamı (checksum) testini geçen doğru boyuttaki onaltılık ifadeler `address` türündedir. Başka hiçbir ifade `address` türüne örtük olarak dönüştürülemez.
Not
0.8.0 sürümünden önce `address` veya `address payable`’a herhangi bir tamsayı türünden (herhangi bir boyutta, imzalı veya imzasız) açıkça dönüştürülebilmekteydi. 0.8.0 ile birlikte yalnızce `uint160`’dan dönüştürmeye izin verilmektedir.

# [Solidity — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/) 
 _https://docs.soliditylang.org/fr/latest/_

Avertissement
You are reading a community translation of the Solidity documentation. The Solidity team can give no guarantees on the quality and accuracy of the translations provided. The English reference version is and will remain the only officially supported version by the Solidity team and will always be the most accurate and most up-to-date one. When in doubt, please always refer to the [English (original) documentation](https://docs.soliditylang.org/en/latest/).
Solidity est un langage orienté objet et de haut niveau pour la mise en œuvre de contrats intelligents. Les contrats intelligents sont des programmes qui régissent le comportement des comptes dans l’état Ethereum.
Solidity est un [langage d’accolades](https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Curly-bracket_languages). Il est influencé par le C++, le Python et le JavaScript, et est conçu pour cibler la machine virtuelle Ethereum (EVM). Vous pouvez trouver plus de détails sur les langages dont Solidity s’est inspiré dans la section sur les [influences linguistiques](https://docs.soliditylang.org/fr/latest/language-influences.html).
Solidity est typée statiquement, supporte l’héritage, les bibliothèques et les types complexes définis par l’utilisateur, entre autres caractéristiques.
Avec Solidity, vous pouvez créer des contrats pour des utilisations telles que le vote, le crowdfunding, les enchères à l’aveugle et les portefeuilles à signatures multiples.
Lorsque vous déployez des contrats, vous devez utiliser la dernière version publiée de Solidity. Sauf cas exceptionnel, seule la dernière version reçoit des [correctifs de sécurité](https://github.com/ethereum/solidity/security/policy#supported-versions). En outre, les changements de rupture ainsi que les nouvelles fonctionnalités sont introduites régulièrement. Nous utilisons actuellement un numéro de version 0.y.z [pour indiquer ce rythme rapide de changement](https://semver.org/#spec-item-4).
Avertissement
Solidity a récemment publié la version 0.8.x qui a introduit de nombreux changements. Assurez-vous de lire [la liste complète](https://docs.soliditylang.org/fr/latest/080-breaking-changes.html).
Les idées pour améliorer Solidity ou cette documentation sont toujours les bienvenues, lisez notre [guide des contributeurs](https://docs.soliditylang.org/fr/latest/contributing.html) pour plus de détails.
Astuce
Vous pouvez télécharger cette documentation au format PDF, HTML ou Epub en cliquant sur le menu déroulant des versions dans le coin inférieur gauche et en sélectionnant le format de téléchargement préféré.
## Pour commencer[](#pour-commencer "Lien permanent vers cette rubrique")
**1\. Comprendre les bases des contrats intelligents**
Si le concept des contrats intelligents est nouveau pour vous, nous vous recommandons de commencer par vous plonger dans la section « Introduction aux contrats intelligents ». dans la section « Introduction aux contrats intelligents », qui couvre :
* [Un exemple simple de smart contract](https://docs.soliditylang.org/fr/latest/introduction-to-smart-contracts.html#simple-smart-contract) écrit sous Solidity.
 
* [Les bases de la blockchain](https://docs.soliditylang.org/fr/latest/introduction-to-smart-contracts.html#blockchain-basics).
 
* [La Ethereum Virtual Machine](https://docs.soliditylang.org/fr/latest/introduction-to-smart-contracts.html#the-ethereum-virtual-machine).
 
**2\. Apprenez à connaître Solidity**
Une fois que vous êtes habitué aux bases, nous vous recommandons de lire les sections [« Solidity by Example »](https://docs.soliditylang.org/fr/latest/solidity-by-example.html) et « Description du langage » pour comprendre les concepts fondamentaux du langage.
**3\. Installer le compilateur Solidity**
Il existe plusieurs façons d’installer le compilateur Solidity. Il vous suffit de choisir votre option préférée et de suivre les étapes décrites sur la [installation page](https://docs.soliditylang.org/fr/latest/installing-solidity.html#installing-solidity).
Indication
Vous pouvez essayer des exemples de code directement dans votre navigateur grâce à la fonction [Remix IDE](https://remix.ethereum.org/). Remix est un IDE basé sur un navigateur web qui vous permet d’écrire, de déployer et d’administrer les smart contracts Solidity, sans avoir à sans avoir besoin d’installer Solidity localement.
Avertissement
Comme les humains écrivent des logiciels, ceux-ci peuvent comporter des bugs. Vous devez suivre les meilleures pratiques établies en matière de développement de logiciels lorsque vous écrivez vos contrats intelligents. Cela inclut la révision du code, les tests, les audits et les preuves de correction. Les utilisateurs de contrats intelligents sont parfois plus confiants dans le code que ses auteurs, et les blockchains et les contrats intelligents ont leurs propres problèmes à surveiller. Avant de travailler sur le code de production, assurez-vous de lire la section [Considérations de sécurité](https://docs.soliditylang.org/fr/latest/security-considerations.html#security-considerations).
**4\. En savoir plus**
Si vous souhaitez en savoir plus sur la création d’applications décentralisées sur Ethereum, le programme [Ethereum Developer Resources](https://ethereum.org/en/developers/) peut vous aider à trouver de la documentation générale sur Ethereum, ainsi qu’une large sélection de tutoriels, d’outils et de cadres de développement.
Si vous avez des questions, vous pouvez essayer de chercher des réponses ou de les poser sur [Ethereum StackExchange](https://ethereum.stackexchange.com/), ou sur notre [salon Gitter](https://gitter.im/ethereum/solidity/).
## Traductions[](#traductions "Lien permanent vers cette rubrique")
Des bénévoles de la communauté aident à traduire cette documentation en plusieurs langues. Leur degré d’exhaustivité et de mise à jour varie. La version anglaise est une référence.
Note
Nous avons récemment mis en place une nouvelle organisation GitHub et un nouveau flux de traduction pour aider à rationaliser les efforts de la communauté. Veuillez vous référer au [guide de traduction](https://github.com/solidity-docs/translation-guide) pour obtenir des informations sur la manière de contribuer aux traductions communautaires en cours.
* [Français](https://docs.soliditylang.org/fr/latest/)
 
* [Italien](https://github.com/damianoazzolini/solidity) (en cours)
 
* [Japonais](https://solidity-jp.readthedocs.io/)
 
* [Coréen](https://solidity-kr.readthedocs.io/) (en cours)
 
* [Russe](https://github.com/ethereum/wiki/wiki/%5BRussian%5D-%D0%A0%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE-%D0%BF%D0%BE-Solidity) (rather outdated)
 
* [Chinois simplifié](https://learnblockchain.cn/docs/solidity/) (en cours)
 
* [Espagnol](https://solidity-es.readthedocs.io/)
 
* [Turc](https://github.com/denizozzgur/Solidity_TR/blob/master/README.md) (partiel)

# [Layout of a Solidity Source File — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html) 
 _https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html_

Source files can contain an arbitrary number of [contract definitions](https://docs.soliditylang.org/en/v0.8.30/structure-of-a-contract.html#contract-structure), [import](#import) , [pragma](#pragma) and [using for](https://docs.soliditylang.org/en/v0.8.30/contracts.html#using-for) directives and [struct](https://docs.soliditylang.org/en/v0.8.30/types.html#structs), [enum](https://docs.soliditylang.org/en/v0.8.30/types.html#enums), [function](https://docs.soliditylang.org/en/v0.8.30/contracts.html#functions), [error](https://docs.soliditylang.org/en/v0.8.30/contracts.html#errors) and [constant variable](https://docs.soliditylang.org/en/v0.8.30/contracts.html#constants) definitions.
## SPDX License Identifier[](#spdx-license-identifier "Link to this heading")
Trust in smart contracts can be better established if their source code is available. Since making source code available always touches on legal problems with regards to copyright, the Solidity compiler encourages the use of machine-readable [SPDX license identifiers](https://spdx.org/). Every source file should start with a comment indicating its license:
`// SPDX-License-Identifier: MIT`
The compiler does not validate that the license is part of the [list allowed by SPDX](https://spdx.org/licenses/), but it does include the supplied string in the [bytecode metadata](https://docs.soliditylang.org/en/v0.8.30/metadata.html#metadata).
If you do not want to specify a license or if the source code is not open-source, please use the special value `UNLICENSED`. Note that `UNLICENSED` (no usage allowed, not present in SPDX license list) is different from `UNLICENSE` (grants all rights to everyone). Solidity follows [the npm recommendation](https://docs.npmjs.com/cli/v7/configuring-npm/package-json#license).
Supplying this comment of course does not free you from other obligations related to licensing like having to mention a specific license header in each source file or the original copyright holder.
The comment is recognized by the compiler anywhere in the file at the file level, but it is recommended to put it at the top of the file.
More information about how to use SPDX license identifiers can be found at the [SPDX website](https://spdx.dev/learn/handling-license-info/#how).
## Pragmas[](#pragmas "Link to this heading")
The `pragma` keyword is used to enable certain compiler features or checks. A pragma directive is always local to a source file, so you have to add the pragma to all your files if you want to enable it in your whole project. If you [import](#import) another file, the pragma from that file does _not_ automatically apply to the importing file.
### Version Pragma[](#version-pragma "Link to this heading")
Source files can (and should) be annotated with a version pragma to reject compilation with future compiler versions that might introduce incompatible changes. We try to keep these to an absolute minimum and introduce them in a way that changes in semantics also require changes in the syntax, but this is not always possible. Because of this, it is always a good idea to read through the changelog at least for releases that contain breaking changes. These releases always have versions of the form `0.x.0` or `x.0.0`.
The version pragma is used as follows: `pragma solidity ^0.5.2;`
A source file with the line above does not compile with a compiler earlier than version 0.5.2, and it also does not work on a compiler starting from version 0.6.0 (this second condition is added by using `^`). Because there will be no breaking changes until version `0.6.0`, you can be sure that your code compiles the way you intended. The exact version of the compiler is not fixed, so that bugfix releases are still possible.
It is possible to specify more complex rules for the compiler version, these follow the same syntax used by [npm](https://docs.npmjs.com/cli/v6/using-npm/semver).
Note
Using the version pragma _does not_ change the version of the compiler. It also _does not_ enable or disable features of the compiler. It just instructs the compiler to check whether its version matches the one required by the pragma. If it does not match, the compiler issues an error.
### ABI Coder Pragma[](#abi-coder-pragma "Link to this heading")
By using `pragma abicoder v1` or `pragma abicoder v2` you can select between the two implementations of the ABI encoder and decoder.
The new ABI coder (v2) is able to encode and decode arbitrarily nested arrays and structs. Apart from supporting more types, it involves more extensive validation and safety checks, which may result in higher gas costs, but also heightened security. It is considered non-experimental as of Solidity 0.6.0 and it is enabled by default starting with Solidity 0.8.0. The old ABI coder can still be selected using `pragma abicoder v1;`.
The set of types supported by the new encoder is a strict superset of the ones supported by the old one. Contracts that use it can interact with ones that do not without limitations. The reverse is possible only as long as the non-`abicoder v2` contract does not try to make calls that would require decoding types only supported by the new encoder. The compiler can detect this and will issue an error. Simply enabling `abicoder v2` for your contract is enough to make the error go away.
Note
This pragma applies to all the code defined in the file where it is activated, regardless of where that code ends up eventually. This means that a contract whose source file is selected to compile with ABI coder v1 can still contain code that uses the new encoder by inheriting it from another contract. This is allowed if the new types are only used internally and not in external function signatures.
Note
Up to Solidity 0.7.4, it was possible to select the ABI coder v2 by using `pragma experimental ABIEncoderV2`, but it was not possible to explicitly select coder v1 because it was the default.
### Experimental Pragma[](#experimental-pragma "Link to this heading")
The second pragma is the experimental pragma. It can be used to enable features of the compiler or language that are not yet enabled by default. The following experimental pragmas are currently supported:
#### ABIEncoderV2[](#abiencoderv2 "Link to this heading")
Because the ABI coder v2 is not considered experimental anymore, it can be selected via `pragma abicoder v2` (please see above) since Solidity 0.7.4.
#### SMTChecker[](#smtchecker "Link to this heading")
This component has to be enabled when the Solidity compiler is built and therefore it is not available in all Solidity binaries. The [build instructions](https://docs.soliditylang.org/en/v0.8.30/installing-solidity.html#smt-solvers-build) explain how to activate this option. It is activated for the Ubuntu PPA releases in most versions, but not for the Docker images, Windows binaries or the statically-built Linux binaries. It can be activated for solc-js via the [smtCallback](https://github.com/ethereum/solc-js#example-usage-with-smtsolver-callback) if you have an SMT solver installed locally and run solc-js via node (not via the browser).
If you use `pragma experimental SMTChecker;`, then you get additional [safety warnings](https://docs.soliditylang.org/en/v0.8.30/smtchecker.html#formal-verification) which are obtained by querying an SMT solver. The component does not yet support all features of the Solidity language and likely outputs many warnings. In case it reports unsupported features, the analysis may not be fully sound.
## Importing other Source Files[](#importing-other-source-files "Link to this heading")
### Syntax and Semantics[](#syntax-and-semantics "Link to this heading")
Solidity supports import statements to help modularise your code that are similar to those available in JavaScript (from ES6 on). However, Solidity does not support the concept of a [default export](https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export#description).
At a global level, you can use import statements of the following form:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=aW1wb3J0ICJmaWxlbmFtZSI7)
The `filename` part is called an _import path_. This statement imports all global symbols from “filename” (and symbols imported there) into the current global scope (different than in ES6 but backwards-compatible for Solidity). This form is not recommended for use, because it unpredictably pollutes the namespace. If you add new top-level items inside “filename”, they automatically appear in all files that import like this from “filename”. It is better to import specific symbols explicitly.
The following example creates a new global symbol `symbolName` whose members are all the global symbols from `"filename"`:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=aW1wb3J0ICogYXMgc3ltYm9sTmFtZSBmcm9tICJmaWxlbmFtZSI7)
import \* as symbolName from "filename";
which results in all global symbols being available in the format `symbolName.symbol`.
A variant of this syntax that is not part of ES6, but possibly useful is:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=aW1wb3J0ICJmaWxlbmFtZSIgYXMgc3ltYm9sTmFtZTs=)
import "filename" as symbolName;
which is equivalent to `import * as symbolName from "filename";`.
If there is a naming collision, you can rename symbols while importing. For example, the code below creates new global symbols `alias` and `symbol2` which reference `symbol1` and `symbol2` from inside `"filename"`, respectively.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=aW1wb3J0IHtzeW1ib2wxIGFzIGFsaWFzLCBzeW1ib2wyfSBmcm9tICJmaWxlbmFtZSI7)
import {symbol1 as alias, symbol2} from "filename";
### Import Paths[](#import-paths "Link to this heading")
In order to be able to support reproducible builds on all platforms, the Solidity compiler has to abstract away the details of the filesystem where source files are stored. For this reason import paths do not refer directly to files in the host filesystem. Instead the compiler maintains an internal database (_virtual filesystem_ or _VFS_ for short) where each source unit is assigned a unique _source unit name_ which is an opaque and unstructured identifier. The import path specified in an import statement is translated into a source unit name and used to find the corresponding source unit in this database.
Using the [Standard JSON](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#compiler-api) API it is possible to directly provide the names and content of all the source files as a part of the compiler input. In this case source unit names are truly arbitrary. If, however, you want the compiler to automatically find and load source code into the VFS, your source unit names need to be structured in a way that makes it possible for an [import callback](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#import-callback) to locate them. When using the command-line compiler the default import callback supports only loading source code from the host filesystem, which means that your source unit names must be paths. Some environments provide custom callbacks that are more versatile. For example the [Remix IDE](https://remix.ethereum.org/) provides one that lets you [import files from HTTP, IPFS and Swarm URLs or refer directly to packages in NPM registry](https://remix-ide.readthedocs.io/en/latest/import.html).
For a complete description of the virtual filesystem and the path resolution logic used by the compiler see [Path Resolution](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#path-resolution).

# [Expressions and Control Structures — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/control-structures.html) 
 _https://docs.soliditylang.org/en/v0.8.30/control-structures.html_

## Control Structures[](#control-structures "Link to this heading")
Most of the control structures known from curly-braces languages are available in Solidity:
There is: `if`, `else`, `while`, `do`, `for`, `break`, `continue`, `return`, with the usual semantics known from C or JavaScript.
Solidity also supports exception handling in the form of `try`/`catch`\-statements, but only for [external function calls](#external-function-calls) and contract creation calls. Errors can be created using the [revert statement](#revert-statement).
Parentheses can _not_ be omitted for conditionals, but curly braces can be omitted around single-statement bodies.
Note that there is no type conversion from non-boolean to boolean types as there is in C and JavaScript, so `if (1) { ... }` is _not_ valid Solidity.
## Function Calls[](#function-calls "Link to this heading")
### Internal Function Calls[](#internal-function-calls "Link to this heading")
Functions of the current contract can be called directly (“internally”), also recursively, as seen in this nonsensical example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCi8vIFRoaXMgd2lsbCByZXBvcnQgYSB3YXJuaW5nCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZyh1aW50IGEpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQgcmV0KSB7IHJldHVybiBhICsgZigpOyB9CiAgICBmdW5jdGlvbiBmKCkgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50IHJldCkgeyByZXR1cm4gZyg3KSArIGYoKTsgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.22 <0.9.0;
// This will report a warning
contract C {
 function g(uint a) public pure returns (uint ret) { return a + f(); }
 function f() internal pure returns (uint ret) { return g(7) + f(); }
}
These function calls are translated into simple jumps inside the EVM. This has the effect that the current memory is not cleared, i.e. passing memory references to internally-called functions is very efficient. Only functions of the same contract instance can be called internally.
You should still avoid excessive recursion, as every internal function call uses up at least one stack slot and there are only 1024 slots available.
### External Function Calls[](#external-function-calls "Link to this heading")
Functions can also be called using the `this.g(8);` and `c.g(2);` notation, where `c` is a contract instance and `g` is a function belonging to `c`. Calling the function `g` via either way results in it being called “externally”, using a message call and not directly via jumps. Please note that function calls on `this` cannot be used in the constructor, as the actual contract has not been created yet.
Functions of other contracts have to be called externally. For an external call, all function arguments have to be copied to memory.
Note
A function call from one contract to another does not create its own transaction, it is a message call as part of the overall transaction.
When calling functions of other contracts, you can specify the amount of Wei or gas sent with the call with the special options `{value: 10, gas: 10000}`. Note that it is discouraged to specify gas values explicitly, since the gas costs of opcodes can change in the future. Any Wei you send to the contract is added to the total balance of that contract:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKY29udHJhY3QgSW5mb0ZlZWQgewogICAgZnVuY3Rpb24gaW5mbygpIHB1YmxpYyBwYXlhYmxlIHJldHVybnMgKHVpbnQgcmV0KSB7IHJldHVybiA0MjsgfQp9Cgpjb250cmFjdCBDb25zdW1lciB7CiAgICBJbmZvRmVlZCBmZWVkOwogICAgZnVuY3Rpb24gc2V0RmVlZChJbmZvRmVlZCBhZGRyKSBwdWJsaWMgeyBmZWVkID0gYWRkcjsgfQogICAgZnVuY3Rpb24gY2FsbEZlZWQoKSBwdWJsaWMgeyBmZWVkLmluZm97dmFsdWU6IDEwLCBnYXM6IDgwMH0oKTsgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.2 <0.9.0;
contract InfoFeed {
 function info() public payable returns (uint ret) { return 42; }
}
contract Consumer {
 InfoFeed feed;
 function setFeed(InfoFeed addr) public { feed \= addr; }
 function callFeed() public { feed.info{value: 10, gas: 800}(); }
}
You need to use the modifier `payable` with the `info` function because otherwise, the `value` option would not be available.
Warning
Be careful that `feed.info{value: 10, gas: 800}` only locally sets the `value` and amount of `gas` sent with the function call, and the parentheses at the end perform the actual call. So `feed.info{value: 10, gas: 800}` does not call the function and the `value` and `gas` settings are lost, only `feed.info{value: 10, gas: 800}()` performs the function call.
Warning
Due to the fact that the EVM considers a call to a non-existing contract to always succeed, Solidity uses the `extcodesize` opcode to check that the contract that is about to be called actually exists (it contains code) and causes an exception if it does not. This check is skipped if the return data will be decoded after the call and thus the ABI decoder will catch the case of a non-existing contract.
This check is not performed in case of [low-level calls](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#address-related) which operate on addresses rather than contract instances.
Warning
Be careful when using high-level calls to [precompiled contracts](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#precompiledcontracts), since the compiler considers them non-existing according to the above logic even though they execute code and can return data.
Note
Since the version 0.8.10, the compiler does not check `extcodesize` on high-level external calls if return data is expected, because an empty code will be unable to return data, and the ABI decoder will revert. As a consequence, this allows high-level external calls to precompiled contracts, since they can return data despite having no code associated with their addresses.
Read about [precompiled contracts](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#precompiledcontracts) and [low-level calls](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#address-related) for more information.
Function calls also cause exceptions if the called contract itself throws an exception or goes out of gas.
Warning
Any interaction with another contract imposes a potential danger, especially if the source code of the contract is not known in advance. The current contract hands over control to the called contract and that may potentially do just about anything. Even if the called contract inherits from a known parent contract, the inheriting contract is only required to have a correct interface. The implementation of the contract, however, can be completely arbitrary and thus, pose a danger. In addition, be prepared in case it calls into other contracts of your system or even back into the calling contract before the first call returns. This means that the called contract can change state variables of the calling contract via its functions. Write your functions in a way that, for example, calls to external functions happen after any changes to state variables in your contract so your contract is not vulnerable to a reentrancy exploit.
Note
Before Solidity 0.6.2, the recommended way to specify the value and gas was to use `f.value(x).gas(g)()`. This was deprecated in Solidity 0.6.2 and is no longer possible since Solidity 0.7.0.
### Function Calls with Named Parameters[](#function-calls-with-named-parameters "Link to this heading")
Function call arguments can be given by name, in any order, if they are enclosed in `{ }` as can be seen in the following example. The argument list has to coincide by name with the list of parameters from the function declaration, but can be in arbitrary order.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBtYXBwaW5nKHVpbnQgPT4gdWludCkgZGF0YTsKCiAgICBmdW5jdGlvbiBmKCkgcHVibGljIHsKICAgICAgICBzZXQoe3ZhbHVlOiAyLCBrZXk6IDN9KTsKICAgIH0KCiAgICBmdW5jdGlvbiBzZXQodWludCBrZXksIHVpbnQgdmFsdWUpIHB1YmxpYyB7CiAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract C {
 mapping(uint \=> uint) data;
 function f() public {
 set({value: 2, key: 3});
 }
 function set(uint key, uint value) public {
 data\[key\] \= value;
 }
}
### Omitted Names in Function Definitions[](#omitted-names-in-function-definitions "Link to this heading")
The names of parameters and return values in the function declaration can be omitted. Those items with omitted names will still be present on the stack, but they are inaccessible by name. An omitted return value name can still return a value to the caller by use of the `return` statement.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgLy8gb21pdHRlZCBuYW1lIGZvciBwYXJhbWV0ZXIKICAgIGZ1bmN0aW9uIGZ1bmModWludCBrLCB1aW50KSBwdWJsaWMgcHVyZSByZXR1cm5zKHVpbnQpIHsKICAgICAgICByZXR1cm4gazsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.22 <0.9.0;
contract C {
 // omitted name for parameter
 function func(uint k, uint) public pure returns(uint) {
 return k;
 }
}
## Creating Contracts via `new`[](#creating-contracts-via-new "Link to this heading")
A contract can create other contracts using the `new` keyword. The full code of the contract being created has to be known when the creating contract is compiled so recursive creation-dependencies are not possible.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwpjb250cmFjdCBEIHsKICAgIHVpbnQgcHVibGljIHg7CiAgICBjb25zdHJ1Y3Rvcih1aW50IGEpIHBheWFibGUgewogICAgICAgIHggPSBhOwogICAgfQp9Cgpjb250cmFjdCBDIHsKICAgIEQgZCA9IG5ldyBEKDQpOyAvLyB3aWxsIGJlIGV4ZWN1dGVkIGFzIHBhcnQgb2YgQydzIGNvbnN0cnVjdG9yCgogICAgZnVuY3Rpb24gY3JlYXRlRCh1aW50IGFyZykgcHVibGljIHsKICAgICAgICBEIG5ld0QgPSBuZXcgRChhcmcpOwogICAgICAgIG5ld0QueCgpOwogICAgfQoKICAgIGZ1bmN0aW9uIGNyZWF0ZUFuZEVuZG93RCh1aW50IGFyZywgdWludCBhbW91bnQpIHB1YmxpYyBwYXlhYmxlIHsKICAgICAgICAvLyBTZW5kIGV0aGVyIGFsb25nIHdpdGggdGhlIGNyZWF0aW9uCiAgICAgICAgRCBuZXdEID0gbmV3IER7dmFsdWU6IGFtb3VudH0oYXJnKTsKICAgICAgICBuZXdELngoKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract D {
 uint public x;
 constructor(uint a) payable {
 x \= a;
 }
}
contract C {
 D d \= new D(4); // will be executed as part of C's constructor
 function createD(uint arg) public {
 D newD \= new D(arg);
 newD.x();
 }
 function createAndEndowD(uint arg, uint amount) public payable {
 // Send ether along with the creation
 D newD \= new D{value: amount}(arg);
 newD.x();
 }
}
As seen in the example, it is possible to send Ether while creating an instance of `D` using the `value` option, but it is not possible to limit the amount of gas. If the creation fails (due to out-of-stack, not enough balance or other problems), an exception is thrown.
### Salted contract creations / create2[](#salted-contract-creations-create2 "Link to this heading")
When creating a contract, the address of the contract is computed from the address of the creating contract and a counter that is increased with each contract creation.
If you specify the option `salt` (a bytes32 value), then contract creation will use a different mechanism to come up with the address of the new contract:
It will compute the address from the address of the creating contract, the given salt value, the (creation) bytecode of the created contract and the constructor arguments.
In particular, the counter (“nonce”) is not used. This allows for more flexibility in creating contracts: You are able to derive the address of the new contract before it is created. Furthermore, you can rely on this address also in case the creating contracts creates other contracts in the meantime.
The main use-case here is contracts that act as judges for off-chain interactions, which only need to be created if there is a dispute.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwpjb250cmFjdCBEIHsKICAgIHVpbnQgcHVibGljIHg7CiAgICBjb25zdHJ1Y3Rvcih1aW50IGEpIHsKICAgICAgICB4ID0gYTsKICAgIH0KfQoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBjcmVhdGVEU2FsdGVkKGJ5dGVzMzIgc2FsdCwgdWludCBhcmcpIHB1YmxpYyB7CiAgICAgICAgLy8gVGhpcyBjb21wbGljYXRlZCBleHByZXNzaW9uIGp1c3QgdGVsbHMgeW91IGhvdyB0aGUgYWRkcmVzcwogICAgICAgIC8vIGNhbiBiZSBwcmUtY29tcHV0ZWQuIEl0IGlzIGp1c3QgdGhlcmUgZm9yIGlsbHVzdHJhdGlvbi4KICAgICAgICAvLyBZb3UgYWN0dWFsbHkgb25seSBuZWVkIGBgbmV3IER7c2FsdDogc2FsdH0oYXJnKWBgLgogICAgICAgIGFkZHJlc3MgcHJlZGljdGVkQWRkcmVzcyA9IGFkZHJlc3ModWludDE2MCh1aW50KGtlY2NhazI1NihhYmkuZW5jb2RlUGFja2VkKAogICAgICAgICAgICBieXRlczEoMHhmZiksCiAgICAgICAgICAgIGFkZHJlc3ModGhpcyksCiAgICAgICAgICAgIHNhbHQsCiAgICAgICAgICAgIGtlY2NhazI1NihhYmkuZW5jb2RlUGFja2VkKAogICAgICAgICAgICAgICAgdHlwZShEKS5jcmVhdGlvbkNvZGUsCiAgICAgICAgICAgICAgICBhYmkuZW5jb2RlKGFyZykKICAgICAgICAgICAgKSkKICAgICAgICApKSkpKTsKCiAgICAgICAgRCBkID0gbmV3IER7c2FsdDogc2FsdH0oYXJnKTsKICAgICAgICByZXF1aXJlKGFkZHJlc3MoZCkgPT0gcHJlZGljdGVkQWRkcmVzcyk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract D {
 uint public x;
 constructor(uint a) {
 x \= a;
 }
}
contract C {
 function createDSalted(bytes32 salt, uint arg) public {
 // This complicated expression just tells you how the address
 // can be pre-computed. It is just there for illustration.
 // You actually only need \`\`new D{salt: salt}(arg)\`\`.
 address predictedAddress \= address(uint160(uint(keccak256(abi.encodePacked(
 bytes1(0xff),
 address(this),
 salt,
 keccak256(abi.encodePacked(
 type(D).creationCode,
 abi.encode(arg)
 ))
 )))));
 D d \= new D{salt: salt}(arg);
 require(address(d) \== predictedAddress);
 }
}
Warning
There are some peculiarities in relation to salted creation. A contract can be re-created at the same address after having been destroyed. Yet, it is possible for that newly created contract to have a different deployed bytecode even though the creation bytecode has been the same (which is a requirement because otherwise the address would change). This is due to the fact that the constructor can query external state that might have changed between the two creations and incorporate that into the deployed bytecode before it is stored.
## Order of Evaluation of Expressions[](#order-of-evaluation-of-expressions "Link to this heading")
The evaluation order of expressions is not specified (more formally, the order in which the children of one node in the expression tree are evaluated is not specified, but they are of course evaluated before the node itself). It is only guaranteed that statements are executed in order and short-circuiting for boolean expressions is done.
## Assignment[](#assignment "Link to this heading")
### Destructuring Assignments and Returning Multiple Values[](#destructuring-assignments-and-returning-multiple-values "Link to this heading")
Solidity internally allows tuple types, i.e. a list of objects of potentially different types whose number is a constant at compile-time. Those tuples can be used to return multiple values at the same time. These can then either be assigned to newly declared variables or to pre-existing variables (or LValues in general).
Tuples are not proper types in Solidity, they can only be used to form syntactic groupings of expressions.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50IGluZGV4OwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50LCBib29sLCB1aW50KSB7CiAgICAgICAgcmV0dXJuICg3LCB0cnVlLCAyKTsKICAgIH0KCiAgICBmdW5jdGlvbiBnKCkgcHVibGljIHsKICAgICAgICAvLyBWYXJpYWJsZXMgZGVjbGFyZWQgd2l0aCB0eXBlIGFuZCBhc3NpZ25lZCBmcm9tIHRoZSByZXR1cm5lZCB0dXBsZSwKICAgICAgICAvLyBub3QgYWxsIGVsZW1lbnRzIGhhdmUgdG8gYmUgc3BlY2lmaWVkIChidXQgdGhlIG51bWJlciBtdXN0IG1hdGNoKS4KICAgICAgICAodWludCB4LCAsIHVpbnQgeSkgPSBmKCk7CiAgICAgICAgLy8gQ29tbW9uIHRyaWNrIHRvIHN3YXAgdmFsdWVzIC0tIGRvZXMgbm90IHdvcmsgZm9yIG5vbi12YWx1ZSBzdG9yYWdlIHR5cGVzLgogICAgICAgICh4LCB5KSA9ICh5LCB4KTsKICAgICAgICAvLyBDb21wb25lbnRzIGNhbiBiZSBsZWZ0IG91dCAoYWxzbyBmb3IgdmFyaWFibGUgZGVjbGFyYXRpb25zKS4KICAgICAgICAoaW5kZXgsICwgKSA9IGYoKTsgLy8gU2V0cyB0aGUgaW5kZXggdG8gNwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
contract C {
 uint index;
 function f() public pure returns (uint, bool, uint) {
 return (7, true, 2);
 }
 function g() public {
 // Variables declared with type and assigned from the returned tuple,
 // not all elements have to be specified (but the number must match).
 (uint x, , uint y) \= f();
 // Common trick to swap values -- does not work for non-value storage types.
 (x, y) \= (y, x);
 // Components can be left out (also for variable declarations).
 (index, , ) \= f(); // Sets the index to 7
 }
}
It is not possible to mix variable declarations and non-declaration assignments, i.e. the following is not valid: `(x, uint y) = (1, 2);`
Note
Prior to version 0.5.0 it was possible to assign to tuples of smaller size, either filling up on the left or on the right side (which ever was empty). This is now disallowed, so both sides have to have the same number of components.
Warning
Be careful when assigning to multiple variables at the same time when reference types are involved, because it could lead to unexpected copying behavior.
### Complications for Arrays and Structs[](#complications-for-arrays-and-structs "Link to this heading")
The semantics of assignments are more complicated for non-value types like arrays and structs, including `bytes` and `string`, see [Data location and assignment behavior](https://docs.soliditylang.org/en/v0.8.30/types.html#data-location-assignment) for details.
In the example below the call to `g(x)` has no effect on `x` because it creates an independent copy of the storage value in memory. However, `h(x)` successfully modifies `x` because only a reference and not a copy is passed.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludFsyMF0geDsKCiAgICBmdW5jdGlvbiBmKCkgcHVibGljIHsKICAgICAgICBnKHgpOwogICAgICAgIGgoeCk7CiAgICB9CgogICAgZnVuY3Rpb24gZyh1aW50WzIwXSBtZW1vcnkgeSkgaW50ZXJuYWwgcHVyZSB7CiAgICAgICAgeVsyXSA9IDM7CiAgICB9CgogICAgZnVuY3Rpb24gaCh1aW50WzIwXSBzdG9yYWdlIHkpIGludGVybmFsIHsKICAgICAgICB5WzNdID0gNDsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.22 <0.9.0;
contract C {
 uint\[20\] x;
 function f() public {
 g(x);
 h(x);
 }
 function g(uint\[20\] memory y) internal pure {
 y\[2\] \= 3;
 }
 function h(uint\[20\] storage y) internal {
 y\[3\] \= 4;
 }
}
## Scoping and Declarations[](#scoping-and-declarations "Link to this heading")
A variable which is declared will have an initial default value whose byte-representation is all zeros. The “default values” of variables are the typical “zero-state” of whatever the type is. For example, the default value for a `bool` is `false`. The default value for the `uint` or `int` types is `0`. For statically-sized arrays and `bytes1` to `bytes32`, each individual element will be initialized to the default value corresponding to its type. For dynamically-sized arrays, `bytes` and `string`, the default value is an empty array or string. For the `enum` type, the default value is its first member.
Scoping in Solidity follows the widespread scoping rules of C99 (and many other languages): Variables are visible from the point right after their declaration until the end of the smallest `{ }`\-block that contains the declaration. As an exception to this rule, variables declared in the initialization part of a for-loop are only visible until the end of the for-loop.
Variables that are parameter-like (function parameters, modifier parameters, catch parameters, …) are visible inside the code block that follows - the body of the function/modifier for a function and modifier parameter and the catch block for a catch parameter.
Variables and other items declared outside of a code block, for example functions, contracts, user-defined types, etc., are visible even before they were declared. This means you can use state variables before they are declared and call functions recursively.
As a consequence, the following examples will compile without warnings, since the two variables have the same name but disjoint scopes.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwpjb250cmFjdCBDIHsKICAgIGZ1bmN0aW9uIG1pbmltYWxTY29waW5nKCkgcHVyZSBwdWJsaWMgewogICAgICAgIHsKICAgICAgICAgICAgdWludCBzYW1lOwogICAgICAgICAgICBzYW1lID0gMTsKICAgICAgICB9CgogICAgICAgIHsKICAgICAgICAgICAgdWludCBzYW1lOwogICAgICAgICAgICBzYW1lID0gMzsKICAgICAgICB9CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
contract C {
 function minimalScoping() pure public {
 {
 uint same;
 same \= 1;
 }
 {
 uint same;
 same \= 3;
 }
 }
}
As a special example of the C99 scoping rules, note that in the following, the first assignment to `x` will actually assign the outer and not the inner variable. In any case, you will get a warning about the outer variable being shadowed.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwovLyBUaGlzIHdpbGwgcmVwb3J0IGEgd2FybmluZwpjb250cmFjdCBDIHsKICAgIGZ1bmN0aW9uIGYoKSBwdXJlIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgdWludCB4ID0gMTsKICAgICAgICB7CiAgICAgICAgICAgIHggPSAyOyAvLyB0aGlzIHdpbGwgYXNzaWduIHRvIHRoZSBvdXRlciB2YXJpYWJsZQogICAgICAgICAgICB1aW50IHg7CiAgICAgICAgfQogICAgICAgIHJldHVybiB4OyAvLyB4IGhhcyB2YWx1ZSAyCiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
// This will report a warning
contract C {
 function f() pure public returns (uint) {
 uint x \= 1;
 {
 x \= 2; // this will assign to the outer variable
 uint x;
 }
 return x; // x has value 2
 }
}
Warning
Before version 0.5.0 Solidity followed the same scoping rules as JavaScript, that is, a variable declared anywhere within a function would be in scope for the entire function, regardless where it was declared. The following example shows a code snippet that used to compile but leads to an error starting from version 0.5.0.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwovLyBUaGlzIHdpbGwgbm90IGNvbXBpbGUKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKCkgcHVyZSBwdWJsaWMgcmV0dXJucyAodWludCkgewogICAgICAgIHggPSAyOwogICAgICAgIHVpbnQgeDsKICAgICAgICByZXR1cm4geDsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
// This will not compile
contract C {
 function f() pure public returns (uint) {
 x \= 2;
 uint x;
 return x;
 }
}
## Checked or Unchecked Arithmetic[](#checked-or-unchecked-arithmetic "Link to this heading")
An overflow or underflow is the situation where the resulting value of an arithmetic operation, when executed on an unrestricted integer, falls outside the range of the result type.
Prior to Solidity 0.8.0, arithmetic operations would always wrap in case of under- or overflow leading to widespread use of libraries that introduce additional checks.
Since Solidity 0.8.0, all arithmetic operations revert on over- and underflow by default, thus making the use of these libraries unnecessary.
To obtain the previous behavior, an `unchecked` block can be used:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMDsKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdXJlIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgLy8gVGhpcyBzdWJ0cmFjdGlvbiB3aWxsIHdyYXAgb24gdW5kZXJmbG93LgogICAgICAgIHVuY2hlY2tlZCB7IHJldHVybiBhIC0gYjsgfQogICAgfQogICAgZnVuY3Rpb24gZyh1aW50IGEsIHVpbnQgYikgcHVyZSBwdWJsaWMgcmV0dXJucyAodWludCkgewogICAgICAgIC8vIFRoaXMgc3VidHJhY3Rpb24gd2lsbCByZXZlcnQgb24gdW5kZXJmbG93LgogICAgICAgIHJldHVybiBhIC0gYjsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;
contract C {
 function f(uint a, uint b) pure public returns (uint) {
 // This subtraction will wrap on underflow.
 unchecked { return a \- b; }
 }
 function g(uint a, uint b) pure public returns (uint) {
 // This subtraction will revert on underflow.
 return a \- b;
 }
}
The call to `f(2, 3)` will return `2**256-1`, while `g(2, 3)` will cause a failing assertion.
The `unchecked` block can be used everywhere inside a block, but not as a replacement for a block. It also cannot be nested.
The setting only affects the statements that are syntactically inside the block. Functions called from within an `unchecked` block do not inherit the property.
Note
To avoid ambiguity, you cannot use `_;` inside an `unchecked` block.
The following operators will cause a failing assertion on overflow or underflow and will wrap without an error if used inside an unchecked block:
`++`, `--`, `+`, binary `-`, unary `-`, `*`, `/`, `%`, `**`
`+=`, `-=`, `*=`, `/=`, `%=`
Warning
It is not possible to disable the check for division by zero or modulo by zero using the `unchecked` block.
Note
Bitwise operators do not perform overflow or underflow checks. This is particularly visible when using bitwise shifts (`<<`, `>>`, `<<=`, `>>=`) in place of integer division and multiplication by a power of 2. For example `type(uint256).max << 3` does not revert even though `type(uint256).max * 8` would.
Note
The second statement in `int x = type(int).min; -x;` will result in an overflow because the negative range can hold one more value than the positive range.
Explicit type conversions will always truncate and never cause a failing assertion with the exception of a conversion from an integer to an enum type.
## Error handling: Assert, Require, Revert and Exceptions[](#error-handling-assert-require-revert-and-exceptions "Link to this heading")
Solidity uses state-reverting exceptions to handle errors. Such an exception undoes all changes made to the state in the current call (and all its sub-calls) and flags an error to the caller.
When exceptions happen in a sub-call, they “bubble up” (i.e., exceptions are rethrown) automatically unless they are caught in a `try/catch` statement. Exceptions to this rule are `send` and the low-level functions `call`, `delegatecall` and `staticcall`: they return `false` as their first return value in case of an exception instead of “bubbling up”.
Warning
The low-level functions `call`, `delegatecall` and `staticcall` return `true` as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.
Exceptions can contain error data that is passed back to the caller in the form of [error instances](https://docs.soliditylang.org/en/v0.8.30/contracts.html#errors). The built-in errors `Error(string)` and `Panic(uint256)` are used by special functions, as explained below. `Error` is used for “regular” error conditions while `Panic` is used for errors that should not be present in bug-free code.
### Panic via `assert` and Error via `require`[](#panic-via-assert-and-error-via-require "Link to this heading")
The convenience functions `assert` and `require` can be used to check for conditions and throw an exception if the condition is not met.
The `assert` function creates an error of type `Panic(uint256)`. The same error is created by the compiler in certain situations as listed below.
Assert should only be used to test for internal errors, and to check invariants. Properly functioning code should never create a Panic, not even on invalid external input. If this happens, then there is a bug in your contract which you should fix. Language analysis tools can evaluate your contract to identify the conditions and function calls which will cause a Panic.
A Panic exception is generated in the following situations. The error code supplied with the error data indicates the kind of panic.
1. 0x00: Used for generic compiler inserted panics.
 
2. 0x01: If you call `assert` with an argument that evaluates to false.
 
3. 0x11: If an arithmetic operation results in underflow or overflow outside of an `unchecked { ... }` block.
 
4. 0x12; If you divide or modulo by zero (e.g. `5 / 0` or `23 % 0`).
 
5. 0x21: If you convert a value that is too big or negative into an enum type.
 
6. 0x22: If you access a storage byte array that is incorrectly encoded.
 
7. 0x31: If you call `.pop()` on an empty array.
 
8. 0x32: If you access an array, `bytesN` or an array slice at an out-of-bounds or negative index (i.e. `x[i]` where `i >= x.length` or `i < 0`).
 
9. 0x41: If you allocate too much memory or create an array that is too large.
 
10. 0x51: If you call a zero-initialized variable of internal function type.
 
The `require` function provides three overloads:
1. `require(bool)` which will revert without any data (not even an error selector).
 
2. `require(bool, string)` which will revert with an `Error(string)`.
 
3. `require(bool, error)` which will revert with the custom, user supplied error provided as the second argument.
 
Note
`require` arguments are evaluated unconditionally, so take special care to make sure that they are not expressions with unexpected side-effects. For example, in `require(condition, CustomError(f()));` and `require(condition, f());`, function `f()` will be called regardless of whether the supplied condition is `true` or `false`.
An `Error(string)` exception (or an exception without data) is generated by the compiler in the following situations:
1. Calling `require(x)` where `x` evaluates to `false`.
 
2. If you use `revert()` or `revert("description")`.
 
3. If you perform an external function call targeting a contract that contains no code.
 
4. If your contract receives Ether via a public function without `payable` modifier (including the constructor and the fallback function).
 
5. If your contract receives Ether via a public getter function.
 
For the following cases, the error data from the external call (if provided) is forwarded. This means that it can either cause an `Error` or a `Panic` (or whatever else was given):
1. If a `.transfer()` fails.
 
2. If you call a function via a message call but it does not finish properly (i.e., it runs out of gas, has no matching function, or throws an exception itself), except when a low level operation `call`, `send`, `delegatecall`, `callcode` or `staticcall` is used. The low level operations never throw exceptions but indicate failures by returning `false`.
 
3. If you create a contract using the `new` keyword but the contract creation [does not finish properly](#creating-contracts).
 
You can optionally provide a message string or a custom error to `require`, but not to `assert`.
Note
If you do not provide a string or custom error argument to `require`, it will revert with empty error data, not even including the error selector.
The following example shows how you can use `require` to check conditions on inputs and `assert` for internal error checking.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgU2hhcmVyIHsKICAgIGZ1bmN0aW9uIHNlbmRIYWxmKGFkZHJlc3MgcGF5YWJsZSBhZGRyKSBwdWJsaWMgcGF5YWJsZSByZXR1cm5zICh1aW50IGJhbGFuY2UpIHsKICAgICAgICByZXF1aXJlKG1zZy52YWx1ZSAlIDIgPT0gMCwgIkV2ZW4gdmFsdWUgcmVxdWlyZWQuIik7CiAgICAgICAgdWludCBiYWxhbmNlQmVmb3JlVHJhbnNmZXIgPSBhZGRyZXNzKHRoaXMpLmJhbGFuY2U7CiAgICAgICAgYWRkci50cmFuc2Zlcihtc2cudmFsdWUgLyAyKTsKICAgICAgICAvLyBTaW5jZSB0cmFuc2ZlciB0aHJvd3MgYW4gZXhjZXB0aW9uIG9uIGZhaWx1cmUgYW5kCiAgICAgICAgLy8gY2Fubm90IGNhbGwgYmFjayBoZXJlLCB0aGVyZSBzaG91bGQgYmUgbm8gd2F5IGZvciB1cyB0bwogICAgICAgIC8vIHN0aWxsIGhhdmUgaGFsZiBvZiB0aGUgRXRoZXIuCiAgICAgICAgYXNzZXJ0KGFkZHJlc3ModGhpcykuYmFsYW5jZSA9PSBiYWxhbmNlQmVmb3JlVHJhbnNmZXIgLSBtc2cudmFsdWUgLyAyKTsKICAgICAgICByZXR1cm4gYWRkcmVzcyh0aGlzKS5iYWxhbmNlOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
contract Sharer {
 function sendHalf(address payable addr) public payable returns (uint balance) {
 require(msg.value % 2 \== 0, "Even value required.");
 uint balanceBeforeTransfer \= address(this).balance;
 addr.transfer(msg.value / 2);
 // Since transfer throws an exception on failure and
 // cannot call back here, there should be no way for us to
 // still have half of the Ether.
 assert(address(this).balance \== balanceBeforeTransfer \- msg.value / 2);
 return address(this).balance;
 }
}
Internally, Solidity performs a revert operation (instruction `0xfd`). This causes the EVM to revert all changes made to the state. The reason for reverting is that there is no safe way to continue execution, because an expected effect did not occur. Because we want to keep the atomicity of transactions, the safest action is to revert all changes and make the whole transaction (or at least call) without effect.
In both cases, the caller can react on such failures using `try`/`catch`, but the changes in the callee will always be reverted.
Note
Panic exceptions used to use the `invalid` opcode before Solidity 0.8.0, which consumed all gas available to the call. Exceptions that use `require` used to consume all gas until before the Metropolis release.
### `revert`[](#revert "Link to this heading")
A direct revert can be triggered using the `revert` statement and the `revert` function.
The `revert` statement takes a custom error as direct argument without parentheses:
> revert CustomError(arg1, arg2);
For backward-compatibility reasons, there is also the `revert()` function, which uses parentheses and accepts a string:
> revert(); revert(“description”);
The error data will be passed back to the caller and can be caught there. Using `revert()` causes a revert without any error data while `revert("description")` will create an `Error(string)` error.
Using a custom error instance will usually be much cheaper than a string description, because you can use the name of the error to describe it, which is encoded in only four bytes. A longer description can be supplied via NatSpec which does not incur any costs.
The following example shows how to use an error string and a custom error instance together with `revert` and the equivalent `require`:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IFZlbmRpbmdNYWNoaW5lIHsKICAgIGFkZHJlc3Mgb3duZXI7CiAgICBlcnJvciBVbmF1dGhvcml6ZWQoKTsKICAgIGZ1bmN0aW9uIGJ1eSh1aW50IGFtb3VudCkgcHVibGljIHBheWFibGUgewogICAgICAgIGlmIChhbW91bnQgPiBtc2cudmFsdWUgLyAyIGV0aGVyKQogICAgICAgICAgICByZXZlcnQoIk5vdCBlbm91Z2ggRXRoZXIgcHJvdmlkZWQuIik7CiAgICAgICAgLy8gQWx0ZXJuYXRpdmUgd2F5IHRvIGRvIGl0OgogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgIGFtb3VudCA8PSBtc2cudmFsdWUgLyAyIGV0aGVyLAogICAgICAgICAgICAiTm90IGVub3VnaCBFdGhlciBwcm92aWRlZC4iCiAgICAgICAgKTsKICAgICAgICAvLyBQZXJmb3JtIHRoZSBwdXJjaGFzZS4KICAgIH0KICAgIGZ1bmN0aW9uIHdpdGhkcmF3KCkgcHVibGljIHsKICAgICAgICBpZiAobXNnLnNlbmRlciAhPSBvd25lcikKICAgICAgICAgICAgcmV2ZXJ0IFVuYXV0aG9yaXplZCgpOwoKICAgICAgICBwYXlhYmxlKG1zZy5zZW5kZXIpLnRyYW5zZmVyKGFkZHJlc3ModGhpcykuYmFsYW5jZSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract VendingMachine {
 address owner;
 error Unauthorized();
 function buy(uint amount) public payable {
 if (amount \> msg.value / 2 ether)
 revert("Not enough Ether provided.");
 // Alternative way to do it:
 require(
 amount <= msg.value / 2 ether,
 "Not enough Ether provided."
 );
 // Perform the purchase.
 }
 function withdraw() public {
 if (msg.sender != owner)
 revert Unauthorized();
 payable(msg.sender).transfer(address(this).balance);
 }
}
The two ways `if (!condition) revert(...);` and `require(condition, ...);` are equivalent as long as the arguments to `revert` and `require` do not have side-effects, for example if they are just strings.
Note
The `require` function is evaluated just as any other function. This means that all arguments are evaluated before the function itself is executed. In particular, in `require(condition, f())` the function `f` is executed even if `condition` is true.
The provided string is [abi-encoded](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#abi) as if it were a call to a function `Error(string)`. In the above example, `revert("Not enough Ether provided.");` returns the following hexadecimal as error return data:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=MHgwOGMzNzlhMCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZ1bmN0aW9uIHNlbGVjdG9yIGZvciBFcnJvcihzdHJpbmcpCjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMCAvLyBEYXRhIG9mZnNldAoweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMWEgLy8gU3RyaW5nIGxlbmd0aAoweDRlNmY3NDIwNjU2ZTZmNzU2NzY4MjA0NTc0Njg2NTcyMjA3MDcyNmY3NjY5NjQ2NTY0MmUwMDAwMDAwMDAwMDAgLy8gU3RyaW5nIGRhdGE=)
0x08c379a0 // Function selector for Error(string)
0x0000000000000000000000000000000000000000000000000000000000000020 // Data offset
0x000000000000000000000000000000000000000000000000000000000000001a // String length
0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000 // String data
The provided message can be retrieved by the caller using `try`/`catch` as shown below.
Note
There used to be a keyword called `throw` with the same semantics as `revert()` which was deprecated in version 0.4.13 and removed in version 0.5.0.
### `try`/`catch`[](#try-catch "Link to this heading")
A failure in an external call can be caught using a try/catch statement, as follows:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjE7CgppbnRlcmZhY2UgRGF0YUZlZWQgeyBmdW5jdGlvbiBnZXREYXRhKGFkZHJlc3MgdG9rZW4pIGV4dGVybmFsIHJldHVybnMgKHVpbnQgdmFsdWUpOyB9Cgpjb250cmFjdCBGZWVkQ29uc3VtZXIgewogICAgRGF0YUZlZWQgZmVlZDsKICAgIHVpbnQgZXJyb3JDb3VudDsKICAgIGZ1bmN0aW9uIHJhdGUoYWRkcmVzcyB0b2tlbikgcHVibGljIHJldHVybnMgKHVpbnQgdmFsdWUsIGJvb2wgc3VjY2VzcykgewogICAgICAgIC8vIFBlcm1hbmVudGx5IGRpc2FibGUgdGhlIG1lY2hhbmlzbSBpZiB0aGVyZSBhcmUKICAgICAgICAvLyBtb3JlIHRoYW4gMTAgZXJyb3JzLgogICAgICAgIHJlcXVpcmUoZXJyb3JDb3VudCA8IDEwKTsKICAgICAgICB0cnkgZmVlZC5nZXREYXRhKHRva2VuKSByZXR1cm5zICh1aW50IHYpIHsKICAgICAgICAgICAgcmV0dXJuICh2LCB0cnVlKTsKICAgICAgICB9IGNhdGNoIEVycm9yKHN0cmluZyBtZW1vcnkgLypyZWFzb24qLykgewogICAgICAgICAgICAvLyBUaGlzIGlzIGV4ZWN1dGVkIGluIGNhc2UKICAgICAgICAgICAgLy8gcmV2ZXJ0IHdhcyBjYWxsZWQgaW5zaWRlIGdldERhdGEKICAgICAgICAgICAgLy8gYW5kIGEgcmVhc29uIHN0cmluZyB3YXMgcHJvdmlkZWQuCiAgICAgICAgICAgIGVycm9yQ291bnQrKzsKICAgICAgICAgICAgcmV0dXJuICgwLCBmYWxzZSk7CiAgICAgICAgfSBjYXRjaCBQYW5pYyh1aW50IC8qZXJyb3JDb2RlKi8pIHsKICAgICAgICAgICAgLy8gVGhpcyBpcyBleGVjdXRlZCBpbiBjYXNlIG9mIGEgcGFuaWMsCiAgICAgICAgICAgIC8vIGkuZS4gYSBzZXJpb3VzIGVycm9yIGxpa2UgZGl2aXNpb24gYnkgemVybwogICAgICAgICAgICAvLyBvciBvdmVyZmxvdy4gVGhlIGVycm9yIGNvZGUgY2FuIGJlIHVzZWQKICAgICAgICAgICAgLy8gdG8gZGV0ZXJtaW5lIHRoZSBraW5kIG9mIGVycm9yLgogICAgICAgICAgICBlcnJvckNvdW50Kys7CiAgICAgICAgICAgIHJldHVybiAoMCwgZmFsc2UpOwogICAgICAgIH0gY2F0Y2ggKGJ5dGVzIG1lbW9yeSAvKmxvd0xldmVsRGF0YSovKSB7CiAgICAgICAgICAgIC8vIFRoaXMgaXMgZXhlY3V0ZWQgaW4gY2FzZSByZXZlcnQoKSB3YXMgdXNlZC4KICAgICAgICAgICAgZXJyb3JDb3VudCsrOwogICAgICAgICAgICByZXR1cm4gKDAsIGZhbHNlKTsKICAgICAgICB9CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.1;
interface DataFeed { function getData(address token) external returns (uint value); }
contract FeedConsumer {
 DataFeed feed;
 uint errorCount;
 function rate(address token) public returns (uint value, bool success) {
 // Permanently disable the mechanism if there are
 // more than 10 errors.
 require(errorCount < 10);
 try feed.getData(token) returns (uint v) {
 return (v, true);
 } catch Error(string memory /\*reason\*/) {
 // This is executed in case
 // revert was called inside getData
 // and a reason string was provided.
 errorCount++;
 return (0, false);
 } catch Panic(uint /\*errorCode\*/) {
 // This is executed in case of a panic,
 // i.e. a serious error like division by zero
 // or overflow. The error code can be used
 // to determine the kind of error.
 errorCount++;
 return (0, false);
 } catch (bytes memory /\*lowLevelData\*/) {
 // This is executed in case revert() was used.
 errorCount++;
 return (0, false);
 }
 }
}
The `try` keyword has to be followed by an expression representing an external function call or a contract creation (`new ContractName()`). Errors inside the expression are not caught (for example if it is a complex expression that also involves internal function calls), only a revert happening inside the external call itself. The `returns` part (which is optional) that follows declares return variables matching the types returned by the external call. In case there was no error, these variables are assigned and the contract’s execution continues inside the first success block. If the end of the success block is reached, execution continues after the `catch` blocks.
Solidity supports different kinds of catch blocks depending on the type of error:
* `catch Error(string memory reason) { ... }`: This catch clause is executed if the error was caused by `revert("reasonString")` or `require(false, "reasonString")` (or an internal error that causes such an exception).
 
* `catch Panic(uint errorCode) { ... }`: If the error was caused by a panic, i.e. by a failing `assert`, division by zero, invalid array access, arithmetic overflow and others, this catch clause will be run.
 
* `catch (bytes memory lowLevelData) { ... }`: This clause is executed if the error signature does not match any other clause, if there was an error while decoding the error message, or if no error data was provided with the exception. The declared variable provides access to the low-level error data in that case.
 
* `catch { ... }`: If you are not interested in the error data, you can just use `catch { ... }` (even as the only catch clause) instead of the previous clause.
 
It is planned to support other types of error data in the future. The strings `Error` and `Panic` are currently parsed as is and are not treated as identifiers.
In order to catch all error cases, you have to have at least the clause `catch { ...}` or the clause `catch (bytes memory lowLevelData) { ... }`.
The variables declared in the `returns` and the `catch` clause are only in scope in the block that follows.
Note
If an error happens during the decoding of the return data inside a try/catch-statement, this causes an exception in the currently executing contract and because of that, it is not caught in the catch clause. If there is an error during decoding of `catch Error(string memory reason)` and there is a low-level catch clause, this error is caught there.
Note
If execution reaches a catch-block, then the state-changing effects of the external call have been reverted. If execution reaches the success block, the effects were not reverted. If the effects have been reverted, then execution either continues in a catch block or the execution of the try/catch statement itself reverts (for example due to decoding failures as noted above or due to not providing a low-level catch clause).
Note
The reason behind a failed call can be manifold. Do not assume that the error message is coming directly from the called contract: The error might have happened deeper down in the call chain and the called contract just forwarded it. Also, it could be due to an out-of-gas situation and not a deliberate error condition: The caller always retains at least 1/64th of the gas in a call and thus even if the called contract goes out of gas, the caller still has some gas left.

# [Spécification ABI pour les contrats — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/abi-spec.html) 
 _https://docs.soliditylang.org/fr/latest/abi-spec.html_

## Conception de base[](#conception-de-base "Lien permanent vers cette rubrique")
L’interface binaire d’application de contrat (ABI) est le moyen standard d’interagir avec les contrats dans l’écosystème Ethereum, à la fois depuis l’extérieur de la blockchain et pour l’interaction entre les contrats. de l’extérieur de la blockchain que pour l’interaction entre contrats. Les données sont codées en fonction de leur type, comme décrit dans cette spécification. L’encodage n’est pas autodécrit et nécessite donc un schéma pour être décodé.
Nous supposons que les fonctions d’interface d’un contrat sont fortement typées, connues au moment de la compilation et statiques. Nous supposons que tous les contrats auront les définitions d’interface de tous les contrats qu’ils appellent disponibles au moment de la compilation.
Cette spécification ne concerne pas les contrats dont l’interface est dynamique ou connue uniquement au moment de l’exécution.
## Sélecteur de fonctions[](#selecteur-de-fonctions "Lien permanent vers cette rubrique")
Les quatre premiers octets des données d’appel d’une fonction spécifient la fonction à appeler. Il s’agit des premiers (gauche, ordre supérieur en big-endian) quatre octets du hachage Keccak-256 de la signature de la fonction. la fonction. La signature est définie comme l’expression canonique du prototype de base sans spécificateur d’emplacement de données, c’est-à-dire qu’il s’agit de l’expression canonique de la fonction. spécificateur d’emplacement de données, c’est-à-dire le nom de la fonction avec la liste des types de paramètres entre parenthèses. Les types de paramètres sont séparés par une simple virgule - aucun espace n’est utilisé.
Note
Le type de retour d’une fonction ne fait pas partie de cette signature. Dans [Solidity’s function overloading](https://docs.soliditylang.org/fr/latest/contracts.html#overload-function) les types de retour ne sont pas pris en compte. La raison est de garder la résolution d’appel de fonction indépendante du contexte. La description [JSON de l’ABI](#abi-json) contient cependant des entrées et des sorties.
## Codage des arguments[](#codage-des-arguments "Lien permanent vers cette rubrique")
À partir du cinquième octet, les arguments codés suivent. Ce codage est également utilisé à d’autres d’autres endroits, par exemple les valeurs de retour et les arguments d’événements sont codés de la même manière, sans les quatre octets spécifiant la fonction.
## Types[](#types "Lien permanent vers cette rubrique")
Les types élémentaires suivants existent :
* `uint<M>` : type de nombre entier non signé de `M` bits, `0 < M <= 256`, `M % 8 == 0`. Par exemple, `uint32`, `uint8`, `uint256`.
 
* `int<M>` : type d’entier signé en complément à deux de `M` bits, `0 < M <= 256`, `M % 8 == 0`.
 
* `address` : équivalent à `uint160`, sauf pour l’interprétation supposée et le typage du langage. Pour calculer le sélecteur de fonction, on utilise `address`.
 
* `uint`, `int` : synonymes de `uint256`, `int256` respectivement. Pour calculer le sélecteur de fonction sélecteur de fonction, `uint256` et `int256` doivent être utilisés.
 
* `bool` : équivalent à `uint8` restreint aux valeurs 0 et 1. Pour le calcul du sélecteur de fonction, `bool` est utilisé.
 
* `fixed<M>x<N>` : nombre décimal signé en virgule fixe de `M` bits, `8 <= M <= 256`, `M % 8 == 0`, et `0 < N <= 80`, qui désigne la valeur v\` comme `v / (10 ** N)`.
 
* `ufixed<M>x<N>` : variante non signée de `fixed<M>x<N>`.
 
* `fixed`, `ufixed` : synonymes de `fixed128x18`, `ufixed128x18` respectivement. Pour calculer le sélecteur de fonction, il faut utiliser fixed128x18\` et ufixed128x18\`.
 
* `bytes<M>` : type binaire de `M` octets, `0 < M <= 32`.
 
* `fonction` : une adresse (20 octets) suivie d’un sélecteur de fonction (4 octets). Encodé de manière identique à `bytes24`.
 
Le type de tableau (de taille fixe) suivant existe :
* `<type>[M]` : un tableau de longueur fixe de `M` éléments, `M >= 0`, du type donné.
 
Les types de taille non fixe suivants existent :
* `bytes` : séquence d’octets de taille dynamique.
 
* `string` : chaîne unicode de taille dynamique supposée être encodée en UTF-8.
 
* `<type>[]` : un tableau de longueur variable d’éléments du type donné.
 
Les types peuvent être combinés en un tuple en les mettant entre parenthèses, séparés par des virgules :
* `(T1,T2,...,Tn)` : tuple constitué des types `T1`, …, `Tn`, `n >= 0`
 
Il est possible de former des tuples de tuples, des tableaux de tuples et ainsi de suite. Il est également possible de former des n-uplets zéro (où `n == 0`).
### Correspondance entre Solidity et les types ABI[](#correspondance-entre-solidity-et-les-types-abi "Lien permanent vers cette rubrique")
Solidity supporte tous les types présentés ci-dessus avec les mêmes noms, à l’exception des tuples. l’exception des tuples. Par contre, certains types Solidity ne sont pas supportés par l’ABI par l’ABI. Le tableau suivant montre sur la colonne de gauche les types Solidity qui qui ne font pas partie de l’ABI et, dans la colonne de droite, les types ABI qui les représentent. qui les représentent.
Avertissement
Avant la version `0.8.0` les enums pouvaient avoir plus de 256 membres et étaient représentés par le plus petit type de plus petit type d’entier juste assez grand pour contenir la valeur de n’importe quel membre.
## Critères de conception pour l’encodage[](#criteres-de-conception-pour-l-encodage "Lien permanent vers cette rubrique")
Le codage est conçu pour avoir les propriétés suivantes, qui sont particulièrement utiles si certains arguments sont des tableaux imbriqués :
1. Le nombre de lectures nécessaires pour accéder à une valeur est au plus égal à la profondeur de la valeur dans la structure du tableau d’arguments. dans la structure du tableau d’arguments, c’est-à-dire que quatre lectures sont nécessaires pour récupérer `a_i[k][l][r]`. Dans une version version précédente de l’ABI, le nombre de lectures était linéairement proportionnel au nombre total de paramètres dynamiques dans le pire des cas. dynamiques dans le pire des cas.
 
2. Les données d’une variable ou d’un élément de tableau ne sont pas entrelacées avec d’autres données et elles sont relocalisables, c’est-à-dire qu’elles n’utilisent que des « adresses » relatives.
 
## Spécification formelle de l’encodage[](#specification-formelle-de-l-encodage "Lien permanent vers cette rubrique")
Nous distinguons les types statiques et dynamiques. Les types statiques sont codés sur place et les types dynamiques sont dynamiques sont codés à un emplacement alloué séparément après le bloc actuel.
**Définition:** Les types suivants sont appelés « dynamiques » :
* `bytes`
 
* Chaîne de caractères
 
* `T[]` pour tout `T`
 
* `T[k]` pour tout `T` dynamique et tout `k >= 0`
 
* `(T1,...,Tk)` si `Ti` est dynamique pour tout `1 <= i <= k`
 
Tous les autres types sont dits « statiques ».
**Définition:** `len(a)` est le nombre d’octets dans une chaîne binaire `a`. Le type de `len(a)` est supposé être `uint256`.
Nous définissons `enc`, le codage réel, comme une correspondance entre les valeurs des types ABI et les chaînes binaires telles que que `len(enc(X))` dépend de la valeur de `X` si et seulement si le type de `X` est dynamique.
**Définition:** Pour toute valeur ABI `X`, on définit récursivement `enc(X)`, en fonction du type de `X`. du type de `X` qui est
* `(T1,...,Tk)` pour `k >= 0` et tout type `T1`, …, `Tk`
 
 `enc(X) = head(X(1)) ... head(X(k)) tail(X(1)) ... tail(X(k))`
 
 où `X = (X(1), ..., X(k))` et tête  » et  » queue  » sont définies comme suit pour  » Ti  » :
 
 si `Ti` est statique :
 
 > `head(X(i)) = enc(X(i))` et `tail(X(i)) = ""` (la chaîne vide)
 
 sinon, c’est-à-dire si Ti\` est dynamique :
 
 > `head(X(i)) = enc(len( head(X(1)) ... head(X(k)) tail(X(1)) ... tail(X(i-1)) ))` `tail(X(i)) = enc(X(i))`
 
 Notez que dans le cas dynamique, `head(X(i))` est bien défini car les longueurs des parties de tête parties de la tête ne dépendent que des types et non des valeurs. La valeur de `head(X(i))` est le décalage du début de `tail(X(i))`. du début de `tail(X(i))` par rapport au début de `enc(X)`.
 
* `T[k]` pour tout `T` et `k` :
 
 `enc(X) = enc((X[0], ..., X[k-1]))`
 
 c’est-à-dire qu’il est codé comme s’il s’agissait d’un tuple avec `k` éléments du même type.
 
* `T[]` où `X` a k\` éléments (`k` est supposé être de type `uint256`) :
 
 `enc(X) = enc(k) enc([X[0], ..., X[k-1]])`
 
 c’est-à-dire qu’il est encodé comme s’il s’agissait d’un tableau de taille statique `k`, préfixé par le le nombre d’éléments.
 
* `bytes`, de longueur `k` (qui est supposé être de type `uint256`) :
 
 `enc(X) = enc(k) pad_right(X)`, c’est-à-dire que le nombre d’octets est codé sous forme de `uint256` suivi de la valeur réelle de `X` en tant que séquence d’octets, suivie par le nombre minimal d’octets zéro pour que `len(enc(X))` soit un multiple de 32.
 
* `Chaîne de caractères` :
 
 `enc(X) = enc(enc_utf8(X))`, c’est-à-dire que `X` est codé en UTF-8 et que cette valeur est interprétée comme étant du type `bytes` et encodée plus loin. Notez que la longueur utilisée dans ce codage est le nombre d’octets de la chaîne encodée en UTF-8, et non son nombre de caractères.
 
* `uint<M>` : `enc(X)` est le codage big-endian de `X`, complété du côté gauche par des octets zéro. d’ordre supérieur (gauche) avec des octets zéro de sorte que la longueur soit de 32 octets.
 
* Adresse : comme dans le cas de `uint160`.
 
* `int<M>` : `enc(X)` est le code de complément à deux big-endian de `X`, complété sur le côté supérieur (gauche) par des octets `0xff` pour les `X` négatifs et par des octets zéro pour les `X` non négatifs, de sorte que la longueur soit de 32 octets.
 
* `bool` : comme dans le cas de `uint8`, où `1` est utilisé pour `vrai` et `0` pour `false`.
 
* ```fixed<M>x<N>` : ``enc(X)``` est `enc(X * 10**N)` où `X * 10**N` est interprété comme un `int256`.
 
* `fixed` : comme dans le cas `fixed128x18`
 
* ```ufixed<M>x<N>` : ``enc(X)``` est `enc(X * 10**N)` où `X * 10**N` est interprété comme un `uint256`.
 
* `ufixed` : comme dans le cas `ufixed128x18`
 
* `bytes<M>` : `enc(X)` est la séquence d’octets dans `X` remplie de zéros de queue jusqu’à une longueur de 32 octets.
 
Notez que pour tout `X`, `len(enc(X))` est un multiple de 32.
## Sélecteur de fonctions et codage des arguments[](#selecteur-de-fonctions-et-codage-des-arguments "Lien permanent vers cette rubrique")
En somme, un appel à la fonction `f` avec les paramètres `a_1, ..., a_n` est encodé comme suit
> `fonction_selector(f) enc((a_1, ..., a_n))`
et les valeurs de retour `v_1, ..., v_k` de `f` sont codées en tant que
> `enc((v_1, ..., v_k))`
c’est-à-dire que les valeurs sont combinées en un tuple et codées.
## Exemples[](#exemples "Lien permanent vers cette rubrique")
Étant donné le contrat :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEZvbyB7CiAgICBmdW5jdGlvbiBiYXIoYnl0ZXMzWzJdIG1lbW9yeSkgcHVibGljIHB1cmUge30KICAgIGZ1bmN0aW9uIGJheih1aW50MzIgeCwgYm9vbCB5KSBwdWJsaWMgcHVyZSByZXR1cm5zIChib29sIHIpIHsgciA9IHggPiAzMiB8fCB5OyB9CiAgICBmdW5jdGlvbiBzYW0oYnl0ZXMgbWVtb3J5LCBib29sLCB1aW50W10gbWVtb3J5KSBwdWJsaWMgcHVyZSB7fQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract Foo {
 function bar(bytes3\[2\] memory) public pure {}
 function baz(uint32 x, bool y) public pure returns (bool r) { r \= x \> 32 || y; }
 function sam(bytes memory, bool, uint\[\] memory) public pure {}
}
Ainsi, pour notre exemple `Foo`, si nous voulions appeler `baz` avec les paramètres `69` et `true`, nous passerions 68 octets au total, qui peuvent être décomposés en :
* `0xcdcd77c0` : l’ID de la méthode. Il s’agit des 4 premiers octets du hachage de Keccak de la forme la forme ASCII de la signature `baz(uint32,bool)`.
 
* `0x0000000000000000000000000000000000000000000000000000000000000045` : le premier paramètre, une valeur uint32 `69` remplie de 32 octets
 
* `0x0000000000000000000000000000000000000000000000000000000000000001` : le deuxième paramètre, un booléen `vrai`, padded to 32 bytes
 
Au total :
0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001
Elle renvoie un seul `bool`. Si, par exemple, elle devait retourner `false`, sa sortie serait le tableau d’octets unique `0x000000000000000000000000000000000000000000000000`, un seul bool.
Si nous voulions appeler `bar` avec l’argument `["abc", "def"]`, nous passerions 68 octets au total, répartis en :
* `0xfce353f6` : l’identifiant de la méthode. Celui-ci est dérivé de la signature `bar(bytes3[2])`.
 
* `0x6162630000000000000000000000000000000000000000000000000000000000` : la première partie du premier paramètre, une valeur `bytes3` « abc »\`\` (alignée à gauche).
 
* `0x6465660000000000000000000000000000000000000000000000000000000000` : la deuxième partie du premier paramètre, une valeur `bytes3` (alignée à gauche). paramètre, un `bytes3` de valeur `"def"` (aligné à gauche).
 
Au total :
0xfce353f661626300000000000000000000000000000000000000000000000000000000006465660000000000000000000000000000000000000000000000000000000000
Si nous voulions appeler `sam` avec les arguments `"dave"`, `true` et `[1,2,3]`, nous devrions passerait 292 octets au total, répartis comme suit :
* `0xa5643bf2` : l’identifiant de la méthode. Celui-ci est dérivé de la signature `sam(bytes,bool,uint256[])`. Notez que `uint` est remplacé par sa représentation canonique `uint256`.
 
* `0x0000000000000000000000000000000000000000000000000000000000000060` : l’emplacement de la partie données du premier paramètre (type dynamique), mesuré en octets à partir du début du bloc d’arguments. Dans ce cas, `0x60`.
 
* `0x0000000000000000000000000000000000000000000000000000000000000001` : le deuxième paramètre : booléen vrai.
 
* `0x00000000000000000000000000000000000000000000000000000000000000a0` : l’emplacement de la partie données du troisième paramètre (type dynamique), mesuré en octets. Dans ce cas, `0xa0`.
 
* `0x0000000000000000000000000000000000000000000000000000000000000004` : la partie données du premier argument, elle commence par la longueur du tableau d’octets en éléments, dans ce cas, 4.
 
* `0x6461766500000000000000000000000000000000000000000000000000000000` : le contenu du premier argument : l’encodage UTF-8 (équivalent à l’ASCII dans ce cas) de `"dave"`, padded sur la droite à 32 octets.
 
* `0x0000000000000000000000000000000000000000000000000000000000000003` : la partie données du troisième argument, elle commence par la longueur du tableau en éléments, dans ce cas, 3.
 
* `0x0000000000000000000000000000000000000000000000000000000000000001` : la première entrée du troisième paramètre.
 
* `0x0000000000000000000000000000000000000000000000000000000000000002` : la deuxième entrée du troisième paramètre.
 
* `0x0000000000000000000000000000000000000000000000000000000000000003` : la troisième entrée du troisième paramètre.
 
Au total :
0xa5643bf20000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003
## Utilisation des types dynamiques[](#utilisation-des-types-dynamiques "Lien permanent vers cette rubrique")
Un appel à une fonction dont la signature est `f(uint,uint32[],bytes10,bytes)` avec les valeurs suivantes `(0x123, [0x456, 0x789], "1234567890", "Hello, world !")` est codé de la manière suivante :
Nous prenons les quatre premiers octets de `sha3("f(uint256,uint32[],bytes10,bytes)")`, c’est-à-dire `0x8be65246`. Ensuite, nous encodons les parties de tête des quatre arguments. Pour les types statiques `uint256` et `bytes10`, ce sont directement les valeurs que nous voulons passer, alors que pour les types dynamiques `uint32[]` et `bytes`, nous utilisons le décalage en octets par rapport au début de leur zone de données, mesuré à partir du début de l’encodage de la valeur (c’est-à-dire pas de l’encodage de la valeur). (c’est-à-dire sans compter les quatre premiers octets contenant le hachage de la signature de la fonction). Ces valeurs sont les suivantes
* `0x0000000000000000000000000000000000000000000000000000000000000123` (`0x123` padded to 32 bytes)
 
* `0x0000000000000000000000000000000000000000000000000000000000000080` (décalage du début de la partie données du second paramètre, 4\*32 octets, exactement la taille de la partie tête)
 
* `0x3132333435363738393000000000000000000000000000000000000000000000` (`"1234567890"` padded to 32 bytes on the right)
 
* `0x00000000000000000000000000000000000000000000000000000000000000e0` (décalage du début de la partie données du quatrième paramètre = décalage du début de la partie données du premier paramètre dynamique + taille de la partie données du premier paramètre dynamique = 4\*32 + 3\*32 (voir ci-dessous))
 
Ensuite, la partie données du premier argument dynamique, `[0x456, 0x789]`, est la suivante :
* `0x0000000000000000000000000000000000000000000000000000000000000002` (nombre d’éléments du tableau, 2)
 
* `0x0000000000000000000000000000000000000000000000000000000000000456` (premier élément)
 
* `0x0000000000000000000000000000000000000000000000000000000000000789` (deuxième élément)
 
Enfin, nous encodons la partie données du second argument dynamique, « Hello, world ! »:
* `0x000000000000000000000000000000000000000000000000000000000000000d` (nombre d’éléments (octets dans ce cas) : 13)
 
* `0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000` (`"Hello, world !"` padded to 32 bytes on the right)
 
Au total, le codage est le suivant (nouvelle ligne après le sélecteur de fonction et chaque 32 octets pour plus de clarté) :
0x8be65246
 0000000000000000000000000000000000000000000000000000000000000123
 0000000000000000000000000000000000000000000000000000000000000080
 3132333435363738393000000000000000000000000000000000000000000000
 00000000000000000000000000000000000000000000000000000000000000e0
 0000000000000000000000000000000000000000000000000000000000000002
 0000000000000000000000000000000000000000000000000000000000000456
 0000000000000000000000000000000000000000000000000000000000000789
 000000000000000000000000000000000000000000000000000000000000000d
 48656c6c6f2c20776f726c642100000000000000000000000000000000000000
Appliquons le même principe pour encoder les données d’une fonction de signature `g(uint[][],string[])` avec les valeurs `([1, 2], [3]], ["un", "deux", "trois"])` mais commençons par les parties les plus atomiques de l’encodage :
D’abord, nous encodons la longueur et les données du premier tableau dynamique intégré `[1, 2]` du premier tableau racine `[[1, 2], [3]]` :
* `0x0000000000000000000000000000000000000000000000000000000000000002` (nombre d’éléments du premier tableau, 2 ; les éléments eux-mêmes sont `1` et `2`)
 
* `0x0000000000000000000000000000000000000000000000000000000000000001` (premier élément)
 
* `0x0000000000000000000000000000000000000000000000000000000000000002` (deuxième élément)
 
Ensuite, nous codons la longueur et les données du deuxième tableau dynamique intégré `[3]` du premier tableau racine `[[1, 2], [3]]` :
* `0x0000000000000000000000000000000000000000000000000000000000000001` (nombre d’éléments dans le second tableau, 1 ; l’élément est `3`)
 
* `0x0000000000000000000000000000000000000000000000000000000000000003` (premier élément)
 
Nous devons ensuite trouver les décalages a\` et b\` pour leurs tableaux dynamiques respectifs `[1, 2]` et `[3]`. Pour calculer les décalages, nous pouvons examiner les données codées du premier tableau racine `[[1, 2], [3]]`. en énumérant chaque ligne du codage :
0 - a - décalage de \[1, 2\]
1 - b - décalage de \[3\]
2 - 0000000000000000000000000000000000000000000000000000000000000002 - compte pour \[1, 2\]
3 - 0000000000000000000000000000000000000000000000000000000000000001 - codage de 1
4 - 0000000000000000000000000000000000000000000000000000000000000002 - codage de 2
5 - 0000000000000000000000000000000000000000000000000000000000000001 - compte pour \[3\]
6 - 0000000000000000000000000000000000000000000000000000000000000003 - codage de 3
Le décalage `a` pointe vers le début du contenu du tableau `[1, 2]` qui est la ligne 2 (64 octets). 2 (64 octets) ; ainsi `a = 0x0000000000000000000000000000000000000000000000000000000000000040`.
Le décalage `b` pointe vers le début du contenu du tableau `[3]` qui est la ligne 5 (160 octets) ; donc `b = 0x00000000000000000000000000000000000000000000000000000000000000a0`.
Ensuite, nous encodons les chaînes intégrées du deuxième tableau racine :
* `0x0000000000000000000000000000000000000000000000000000000000000003` (nombre de caractères dans le mot `"one"`)
 
* `0x6f6e650000000000000000000000000000000000000000000000000000000000` (représentation utf8 du mot `"one"`)
 
* `0x0000000000000000000000000000000000000000000000000000000000000003` (nombre de caractères dans le mot `"two"`)
 
* `0x74776f0000000000000000000000000000000000000000000000000000000000` (représentation utf8 du mot `"two"`)
 
* `0x0000000000000000000000000000000000000000000000000000000000000005` (nombre de caractères dans le mot `"three"`)
 
* `0x7468726565000000000000000000000000000000000000000000000000000000` (représentation utf8 du mot `"three"`)
 
Parallèlement au premier tableau racine, puisque les chaînes sont des éléments dynamiques, nous devons trouver leurs décalages `c`, `d` et `e` :
0 - c - décalage pour "un"
1 - d - décalage pour "deux"
2 - e - décalage pour "trois"
3 - 0000000000000000000000000000000000000000000000000000000000000003 - compte pour "un"
4 - 6f6e650000000000000000000000000000000000000000000000000000000000 - codage pour "un"
5 - 0000000000000000000000000000000000000000000000000000000000000003 - compte pour "deux"
6 - 74776f0000000000000000000000000000000000000000000000000000000000 - codage pour "deux"
7 - 0000000000000000000000000000000000000000000000000000000000000005 - compte pour "trois"
8 - 7468726565000000000000000000000000000000000000000000000000000000 - codage pour "trois"
L’offset `c` pointe vers le début du contenu de la chaîne `"one"` qui est la ligne 3 (96 octets) ; donc `c = 0x0000000000000000000000000000000000000000000000000000000000000060`.
Le décalage `d` pointe vers le début du contenu de la chaîne `"two"` qui est la ligne 5 (160 octets) ; donc `d = 0x00000000000000000000000000000000000000000000000000000000000000a0`.
Le décalage `e` pointe vers le début du contenu de la chaîne `"trois"` qui est la ligne 7 (224 octets) ; donc `e = 0x00000000000000000000000000000000000000000000000000000000000000e0`.
Notez que les encodages des éléments intégrés des tableaux racines ne sont pas dépendants les uns des autres et ont les mêmes encodages pour une fonction avec une signature `g(string[],uint[][])`.
Ensuite, nous encodons la longueur du premier tableau racine :
* `0x0000000000000000000000000000000000000000000000000000000000000002` (nombre d’éléments dans le premier tableau racine, 2 ; les éléments eux-mêmes sont `[1, 2]` et `[3]`)
 
Ensuite, nous codons la longueur du deuxième tableau racine :
* `0x0000000000000000000000000000000000000000000000000000000000000003` (nombre de chaînes dans le deuxième tableau racine, 3 ; les chaînes elles-mêmes sont `"un"`, `"deux"` et `"trois"`)
 
Enfin, nous trouvons les décalages f\` et `g` pour leurs tableaux dynamiques racines respectifs `[[1, 2], [3]]` et `["un", "deux", "trois"]`, et assemblons les pièces dans le bon ordre :
0x2289b18c - signature de la fonction
 0 - f - décalage de \[\[1, 2\], \[3\]\]
 1 - g - décalage de \["un", "deux", "trois"\]
 2 - 0000000000000000000000000000000000000000000000000000000000000002 - compte pour \[\[1, 2\], \[3\]\]
 3 - 0000000000000000000000000000000000000000000000000000000000000040 - décalage de \[1, 2\]
 4 - 00000000000000000000000000000000000000000000000000000000000000a0 - décalage de \[3\]
 5 - 0000000000000000000000000000000000000000000000000000000000000002 - compte pour \[1, 2\]
 6 - 0000000000000000000000000000000000000000000000000000000000000001 - codage de 1
 7 - 0000000000000000000000000000000000000000000000000000000000000002 - codage de 2
 8 - 0000000000000000000000000000000000000000000000000000000000000001 - compte pour \[3\]
 9 - 0000000000000000000000000000000000000000000000000000000000000003 - codage de 3
10 - 0000000000000000000000000000000000000000000000000000000000000003 - compte pour \["un", "deux", "trois"\]
11 - 0000000000000000000000000000000000000000000000000000000000000060 - décalage pour "un"
12 - 00000000000000000000000000000000000000000000000000000000000000a0 - décalage pour "deux"
13 - 00000000000000000000000000000000000000000000000000000000000000e0 - décalage pour "trois"
14 - 0000000000000000000000000000000000000000000000000000000000000003 - compte pour "un"
15 - 6f6e650000000000000000000000000000000000000000000000000000000000 - codage de "un"
16 - 0000000000000000000000000000000000000000000000000000000000000003 - compte pour "deux"
17 - 74776f0000000000000000000000000000000000000000000000000000000000 - codage de "deux"
18 - 0000000000000000000000000000000000000000000000000000000000000005 - compte pour "trois"
19 - 7468726565000000000000000000000000000000000000000000000000000000 - codage de "trois"
Le décalage `f` pointe vers le début du contenu du tableau `[[1, 2], [3]]` qui est la ligne 2 (64 octets) ; donc `f = 0x0000000000000000000000000000000000000000000000000000000000000040`.
Le décalage `g` pointe vers le début du contenu du tableau `["one", "two", "three"]` qui est la ligne 10 (320 octets) ; donc `g = 0x0000000000000000000000000000000000000000000000000000000000000140`.
## Événements[](#evenements "Lien permanent vers cette rubrique")
Les événements sont une abstraction du protocole de journalisation et de surveillance des événements d’Ethereum. Les entrées de journal fournissent l’adresse du contrat du contrat, une série de quatre sujets maximum et des données binaires de longueur arbitraire. Les événements exploitent la fonction existante ABI existante afin d’interpréter ceci (avec une spécification d’interface) comme une structure correctement typée.
Étant donné un nom d’événement et une série de paramètres d’événement, nous les divisons en deux sous-séries : celles qui sont indexées et celles qui ne le sont pas. ceux qui ne le sont pas. Ceux qui sont indexés, dont le nombre peut aller jusqu’à 3 (pour les événements non anonymes) ou 4 (pour les événements anonymes), sont utilisés avec le hachage Keccak de la signature de l’événement pour former les sujets de l’entrée du journal. Ceux qui ne sont pas indexés forment le tableau d’octets de l’événement.
En fait, une entrée de journal utilisant cette ABI est décrite comme suit :
* `address` : l’adresse du contrat (intrinsèquement fournie par Ethereum) ;
 
* `topics[0]` : `keccak(EVENT_NAME+ "("+EVENT_ARGS.map(canonical_type_of).join(",")+")")` (`canonical_type_of` est une fonction qui renvoie simplement le nom du contrat. est une fonction qui renvoie simplement le type canonique d’un argument donné, par exemple, pour `uint indexé foo`, elle renverrait retournerait `uint256`). Cette valeur n’est présente dans `topics[0]` que si l’événement n’est pas déclaré comme `anonyme` ;
 
* `topics[n]` : `abi_encode(EVENT_INDEXED_ARGS[n - 1])` si l’événement n’est pas déclaré comme étant `anonyme`. ou `abi_encode(EVENT_INDEXED_ARGS[n])` s’il l’est (`EVENT_INDEXED_ARGS` est la série des `EVENT_ARGS` qui sont sont indexées) ;
 
* `data` : qui ne sont pas indexés, `abi_encode` est la fonction d’encodage ABI utilisée pour retourner une série de valeurs typées d’une fonction, comme décrit ci-dessus).
 
Pour tous les types d’une longueur maximale de 32 octets, le tableau `EVENT_INDEXED_ARGS` contient la valeur directement, avec un padding ou une extension de signe (pour les entiers signés) à 32 octets, comme pour le codage ABI normal. Cependant, pour tous les types « complexes » ou de longueur dynamique, y compris tous les tableaux, `string`, `bytes` et structs, `EVENT_INDEXED_ARGS` contiendra le hachage _Keccak_ d’une valeur spéciale encodée sur place (voir [Codage des paramètres d’événements indexés](#indexed-event-encoding)), plutôt que la valeur encodée directement. Cela permet aux applications d’interroger efficacement les valeurs de types de longueur dynamique dynamiques (en définissant le hachage de la valeur encodée comme sujet), mais les applications ne peuvent pas de décoder les valeurs indexées qu’elles n’ont pas demandées. Pour les types de longueur dynamique, les développeurs d’applications doivent faire un compromis entre la recherche rapide de valeurs prédéterminées prédéterminées (si l’argument est indexé) et la lisibilité de valeurs arbitraires (ce qui exige que les arguments ne soient pas indexés). que les arguments ne soient pas indexés). Les développeurs peuvent surmonter ce compromis et atteindre à la fois recherche efficace et la lisibilité arbitraire en définissant des événements avec deux arguments - un indexés, l’autre non - destinés à contenir la même valeur.
## Erreurs[](#erreurs "Lien permanent vers cette rubrique")
En cas d’échec à l’intérieur d’un contrat, celui-ci peut utiliser un opcode spécial pour interrompre l’exécution et annuler tous les changements d’état. tous les changements d’état. En plus de ces effets, des données descriptives peuvent être retournées à l’appelant. Ces données descriptives sont le codage d’une erreur et de ses arguments de la même manière que les données d’un appel de fonction. d’une fonction.
A titre d’exemple, considérons le contrat suivant dont la fonction `transfer` se retourne toujours se retourne avec une erreur personnalisée de « solde insuffisant » :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IFRlc3RUb2tlbiB7CiAgICBlcnJvciBJbnN1ZmZpY2llbnRCYWxhbmNlKHVpbnQyNTYgYXZhaWxhYmxlLCB1aW50MjU2IHJlcXVpcmVkKTsKICAgIGZ1bmN0aW9uIHRyYW5zZmVyKGFkZHJlc3MgLyp0byovLCB1aW50IGFtb3VudCkgcHVibGljIHB1cmUgewogICAgICAgIHJldmVydCBJbnN1ZmZpY2llbnRCYWxhbmNlKDAsIGFtb3VudCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract TestToken {
 error InsufficientBalance(uint256 available, uint256 required);
 function transfer(address /\*to\*/, uint amount) public pure {
 revert InsufficientBalance(0, amount);
 }
}
Les données de retour seraient codées de la même manière que l’appel de fonction `InsufficientBalance(0, amount)` à la fonction `InsufficientBalance(uint256,uint256)`, c’est-à-dire `0xcf479181`, `uint256(0)`, `uint256(montant)`.
Les sélecteurs d’erreur `0x00000000` et `0xffffff` sont réservés pour une utilisation future.
Avertissement
Ne faites jamais confiance aux données d’erreur. Par défaut, les données d’erreur remontent à travers la chaîne d’appels externes, ce qui signifie que ce qui signifie qu’un contrat peut recevoir une erreur qui n’est définie dans aucun des contrats qu’il appelle directement. De plus, tout contrat peut simuler n’importe quelle erreur en renvoyant des données qui correspondent à une signature d’erreur, même si l’erreur n’est définie nulle part.
## JSON[](#json "Lien permanent vers cette rubrique")
Le format JSON de l’interface d’un contrat est donné par un tableau de descriptions de fonctions, d’événements et d’erreurs. Une description de fonction est un objet JSON avec les champs :
* `type` : `fonction"`, `constructeur"`, `receive"` (la fonction [« receive Ether »](https://docs.soliditylang.org/fr/latest/contracts.html#receive-ether-function)) ou `"fallback"` (la fonction [« default »](https://docs.soliditylang.org/fr/latest/contracts.html#fallback-function)) ;
 
* `name` : le nom de la fonction ;
 
* `inputs` : un tableau d’objets, chacun d’entre eux contenant :
 
 * `name` : le nom du paramètre.
 
 * `type` : le type canonique du paramètre (plus bas).
 
 * `components` : utilisé pour les types de tuple (plus bas).
 
* `outputs` : un tableau d’objets similaires aux [\`\`](#id1)inputs\`”.
 
* `stateMutability` : une chaîne avec l’une des valeurs suivantes : `pure` (spécifié pour ne pas lire l” état de la blockchain), `view` ([spécifié pour ne pas modifier l’état de la blockchain state](https://docs.soliditylang.org/fr/latest/contracts.html#view-functions)), nonpayable\` (la fonction n’accepte pas les Ether - la valeur par défaut) et `payable` (la fonction accepte les Ether).
 
Le constructeur et la fonction de repli n’ont jamais de `name` ou de [\`\`](#id3)outputs\`”. La fonction de repli n’a pas non plus de [\`\`](#id5)inputs\`”.
Note
Envoyer un Ether non nul à une fonction non payante inversera la transaction.
Note
L’état de mutabilité « non-payable » est reflété dans Solidity en ne spécifiant pas de modificateur d’état du tout. un modificateur d’état mutable.
Une description d’événement est un objet JSON avec des champs assez similaires :
* `type` : toujours « événement ».
 
* `name` : le nom de l’événement.
 
* `inputs` : un tableau d’objets, chacun d’entre eux contenant :
 
 * `name` : le nom du paramètre.
 
 * `type` : le type canonique du paramètre (plus bas).
 
 * `components` : utilisé pour les types de tuple (plus bas).
 
 * `indexed` : `true` si le champ fait partie des sujets du journal, `false` s’il fait partie du segment de données du journal.
 
* `anonymous` : `true` si l’événement a été déclaré comme [\`\`](#id7)anonymous\`””.
 
Les erreurs se présentent comme suit :
* `type` : toujours `"erreur"`.
 
* `name` : le nom de l’erreur.
 
* `inputs` : un tableau d’objets, chacun d’entre eux contenant :
 
 * `name` : le nom du paramètre.
 
 * `type` : le type canonique du paramètre (plus bas).
 
 * `components` : utilisé pour les types de tuple (plus bas).
 
Note
Il peut y avoir plusieurs erreurs avec le même nom et même avec une signature identique signature identique dans le tableau JSON, par exemple si les erreurs proviennent de différents fichiers différents dans le contrat intelligent ou sont référencées à partir d’un autre contrat intelligent. Pour l’ABI, seul le nom de l’erreur elle-même est pertinent et non l’endroit où elle est définie.
Par exemple,
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCgpjb250cmFjdCBUZXN0IHsKICAgIGNvbnN0cnVjdG9yKCkgeyBiID0gaGV4IjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyIjsgfQogICAgZXZlbnQgRXZlbnQodWludCBpbmRleGVkIGEsIGJ5dGVzMzIgYik7CiAgICBldmVudCBFdmVudDIodWludCBpbmRleGVkIGEsIGJ5dGVzMzIgYik7CiAgICBlcnJvciBJbnN1ZmZpY2llbnRCYWxhbmNlKHVpbnQyNTYgYXZhaWxhYmxlLCB1aW50MjU2IHJlcXVpcmVkKTsKICAgIGZ1bmN0aW9uIGZvbyh1aW50IGEpIHB1YmxpYyB7IGVtaXQgRXZlbnQoYSwgYik7IH0KICAgIGJ5dGVzMzIgYjsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract Test {
 constructor() { b \= hex"12345678901234567890123456789012"; }
 event Event(uint indexed a, bytes32 b);
 event Event2(uint indexed a, bytes32 b);
 error InsufficientBalance(uint256 available, uint256 required);
 function foo(uint a) public { emit Event(a, b); }
 bytes32 b;
}
donnerait le JSON :
\[{
"type":"error",
"inputs": \[{"name":"available","type":"uint256"},{"name":"required","type":"uint256"}\],
"name":"InsufficientBalance"
}, {
"type":"event",
"inputs": \[{"name":"a","type":"uint256","indexed":true},{"name":"b","type":"bytes32","indexed":false}\],
"name":"Event"
}, {
"type":"event",
"inputs": \[{"name":"a","type":"uint256","indexed":true},{"name":"b","type":"bytes32","indexed":false}\],
"name":"Event2"
}, {
"type":"function",
"inputs": \[{"name":"a","type":"uint256"}\],
"name":"foo",
"outputs": \[\]
}\]
### Handling tuple types[](#handling-tuple-types "Lien permanent vers cette rubrique")
Bien que les noms ne fassent intentionnellement pas partie de l’encodage ABI, il est tout à fait logique de les inclure dans le JSON pour pouvoir l’afficher à l’utilisateur final. La structure est imbriquée de la manière suivante :
Un objet avec des membres `name`, ```type`' et potentiellement ``components`' décrit une variable typée. Le type canonique est déterminé jusqu'à ce qu'un type de tuple soit atteint et la description de la chaîne de caractères jusqu'à ce point est stockée dans ``l'objet''. jusqu'à ce point est stockée dans le préfixe ``type``` avec le mot `tuple`, c’est-à-dire que ce sera `tuple` suivi par une séquence de `[]` et de `[k]` avec des entiers `k`. Les composants du tuple sont ensuite stockés dans le membre `components`, qui est de type tableau et a la même structure que l’objet de niveau supérieur, sauf que `indexed` n’y est pas autorisé.
A titre d’exemple, le code
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjUgPDAuOS4wOwpwcmFnbWEgYWJpY29kZXIgdjI7Cgpjb250cmFjdCBUZXN0IHsKICAgIHN0cnVjdCBTIHsgdWludCBhOyB1aW50W10gYjsgVFtdIGM7IH0KICAgIHN0cnVjdCBUIHsgdWludCB4OyB1aW50IHk7IH0KICAgIGZ1bmN0aW9uIGYoUyBtZW1vcnksIFQgbWVtb3J5LCB1aW50KSBwdWJsaWMgcHVyZSB7fQogICAgZnVuY3Rpb24gZygpIHB1YmxpYyBwdXJlIHJldHVybnMgKFMgbWVtb3J5LCBUIG1lbW9yeSwgdWludCkge30KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.5 <0.9.0;
pragma abicoder v2;
contract Test {
 struct S { uint a; uint\[\] b; T\[\] c; }
 struct T { uint x; uint y; }
 function f(S memory, T memory, uint) public pure {}
 function g() public pure returns (S memory, T memory, uint) {}
}
donnerait le JSON :
\[
 {
 "name": "f",
 "type": "function",
 "inputs": \[
 {
 "name": "s",
 "type": "tuple",
 "components": \[
 {
 "name": "a",
 "type": "uint256"
 },
 {
 "name": "b",
 "type": "uint256\[\]"
 },
 {
 "name": "c",
 "type": "tuple\[\]",
 "components": \[
 {
 "name": "x",
 "type": "uint256"
 },
 {
 "name": "y",
 "type": "uint256"
 }
 \]
 }
 \]
 },
 {
 "name": "t",
 "type": "tuple",
 "components": \[
 {
 "name": "x",
 "type": "uint256"
 },
 {
 "name": "y",
 "type": "uint256"
 }
 \]
 },
 {
 "name": "a",
 "type": "uint256"
 }
 \],
 "outputs": \[\]
 }
\]
## Mode de codage strict[](#mode-de-codage-strict "Lien permanent vers cette rubrique")
Le mode d’encodage strict est le mode qui conduit exactement au même encodage que celui défini dans la spécification formelle ci-dessus. Cela signifie que les décalages doivent être aussi petits que possible tout en ne créant pas de chevauchements dans les zones de données. autorisés.
Habituellement, les décodeurs ABI sont écrits de manière simple en suivant simplement les pointeurs de décalage, mais certains décodeurs peuvent appliquer un mode strict. Le décodeur Solidity ABI n’applique pas actuellement le mode strict, mais l’encodeur crée toujours des données en mode strict. crée toujours les données en mode strict.
## Mode Packed non standard[](#mode-packed-non-standard "Lien permanent vers cette rubrique")
Grâce à `abi.encodePacked()`, Solidity prend en charge un mode packed non standard dans lequel :
* les types plus courts que 32 octets sont concaténés directement, sans remplissage ni extension de signe
 
* les types dynamiques sont encodés in-place et sans la longueur.
 
* les éléments de tableaux sont rembourrés, mais toujours encodés in-place.
 
De plus, les structs ainsi que les tableaux imbriqués ne sont pas supportés.
A titre d’exemple, l’encodage de `int16(-1), bytes1(0x42), uint16(0x03), string("Hello, world !")` donne le résultat suivant :
0xffff42000348656c6c6f2c20776f726c6421
 ^^^^ int16(-1)
 ^^ bytes1(0x42)
 ^^^^ uint16(0x03)
 ^^^^^^^^^^^^^^^^^^^^^^^^^^ string("Hello, world!") sans champ de longueur
Plus précisément :
* Pendant l’encodage, tout est encodé sur place. Cela signifie qu’il n’y a pas de distinction entre la tête et la queue, comme dans l’encodage ABI, et la longueur d’un tableau n’est pas encodée.
 
* Les arguments directs de `abi.encodePacked` sont encodés sans padding, tant qu’ils ne sont pas des tableaux (ou des `string` ou des `bytes`).
 
* L’encodage d’un tableau est la concaténation de l’encodage de ses éléments **avec\*\*\***. codage de ses éléments **avec** remplissage.
 
* Les types de taille dynamique comme `string`, `bytes` ou `uint[]` sont encodés sans leur champ de longueur.
 
* L’encodage de `string` ou `bytes` n’applique pas de remplissage à la fin sauf s’il s’agit d’une partie d’un tableau ou d’une structure (dans ce cas, il s’agit d’un multiple de 32 octets). 32 octets).
 
En général, l’encodage est ambigu dès qu’il y a deux éléments de taille dynamique, à cause du champ de longueur manquant.
Si le remplissage est nécessaire, des conversions de type explicites peuvent être utilisées : `abi.encodePacked(uint16(0x12)) == hex "0012"`.
Puisque le codage empaqueté n’est pas utilisé lors de l’appel de fonctions, il n’y a pas de prise en charge particulière pour faire précéder un sélecteur de fonction. Comme l’encodage est ambigu, il n’y a pas de fonction de décodage.
Avertissement
Si vous utilisez `keccak256(abi.encodePacked(a, b))` et que `a` et `b` sont tous deux des types dynamiques, il est facile de créer des collisions dans la valeur de hachage en déplaçant des parties de `a` dans `b` et et vice-versa. Plus précisément, `abi.encodePacked("a", "bc") == abi.encodePacked("ab", "c")`. Si vous utilisez `abi.encodePacked` pour des signatures, l’authentification ou l’intégrité de données d’utiliser toujours les mêmes types et de vérifier qu’au plus l’un d’entre eux est dynamique. À moins qu’il n’y ait une raison impérative, `abi.encode` devrait être préféré.
## Codage des paramètres d’événements indexés[](#codage-des-parametres-d-evenements-indexes "Lien permanent vers cette rubrique")
Les paramètres d’événements indexés qui ne sont pas des types de valeur, c’est-à-dire les tableaux et les stockés directement, mais un keccak256-hash d’un encodage est stocké. Ce codage est défini comme suit :
* l’encodage d’une valeur de type `bytes` et [\`\`](#id9)chaîne\`”” est juste le contenu de la chaîne de caractères sans aucun padding ou préfixe de longueur.
 
* l’encodage d’une structure est la concaténation de l’encodage de ses membres, toujours complétés par un multiple de 32 octets (même `bytes` et `string`).
 
* Le codage d’un tableau (de taille dynamique ou statique) est le suivant concaténation des encodages de ses éléments, toujours complétés par un multiple de 32 de 32 octets (même `bytes` et `string`) et sans préfixe de longueur.
 
Dans l’exemple ci-dessus, comme d’habitude, un nombre négatif est paddé par extension de signe et non paddé à zéro. Les types `bytesNN` sont paddés à droite tandis que les types `uintNN` / `intNN` sont paddés à gauche.
Avertissement
Le codage d’une structure est ambigu s’il contient plus d’un tableau de taille dynamique. dynamique. Pour cette raison, vérifiez toujours à nouveau les données de l’événement et ne vous fiez pas au résultat de la recherche basé uniquement sur les paramètres indexés.

# [清理变量 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/internals/variable_cleanup.html) 
 _https://docs.soliditylang.org/zh-cn/latest/internals/variable_cleanup.html_

## 清理变量[](#id1 "此标题的永久链接")
最终，EVM中的所有数值都被存储在256位的字中。 因此，在某些情况下，当一个值的类型少于256比特时， 有必要清理剩余的比特位。 Solidity 编译器被设计为在任何可能受到剩余位中潜在垃圾的不利影响的操作之前执行这样的清理。 例如，在将一个值写入内存之前，剩余的位需要被清除， 因为内存的内容可以被用来计算哈希值或作为消息调用的数据发送。 同样地，在将一个值存储到存储器中之前，剩余的位需要被清理， 否则就会看到被混淆的数值。
注意，通过内联汇编的访问不被认为是这种操作。 如果您使用内联汇编来访问短于256位的Solidity变量，编译器不保证该值被正确清理。
此外，如果接下来的操作不受影响，我们就不清理这些位。 例如，由于任何非零值都被 `JUMPI` 指令认为是 `true`， 所以在布尔值被用作 `JUMPI` 的条件之前，我们不对它们进行清理。
除了上面的设计原则外，Solidity编译器在输入数据被加载到堆栈时也会对其进行清理。
下表描述了适用于不同类型的清理规则，其中 `高位` 指的是在类型少于256位的情况下的剩余位。
类型
有效的值
清理无效值
n 个成员的枚举
0，直到n - 1
抛出异常
布尔
0 或 1
结果为1
有符号整数
高位设置为符号位
目前默许符号化扩展到一个有效值 即所有高位被设置为符号位； 将来可能会抛出一个异常。
无符号整数
高位被清零
目前默许为有效值， 即所有高位被设置为零； 将来可能会抛出一个异常。
请注意，有效和无效的值取决于其类型大小。 假设类型为 `uint8`，即无符号的8位类型，它有以下有效值：
0000...0000 0000 0000
0000...0000 0000 0001
0000...0000 0000 0010
....
0000...0000 1111 1111
任何无效的值都将把高位设置为零：
0101...1101 0010 1010 无效的值
0000...0000 0010 1010 清理过的值
对于 `int8`，即有符号的8位类型，有效值是：
负数
1111...1111 1111 1111
1111...1111 1111 1110
....
1111...1111 1000 0000
正数
0000...0000 0000 0000
0000...0000 0000 0001
0000...0000 0000 0010
....
0000...0000 1111 1111
编译器将 `符号化扩展（signextend）` 符号位，即负值为1，正值为0，覆盖高位：
负数
0010...1010 1111 1111 无效的值
1111...1111 1111 1111 清理过的值
正数
1101...0101 0000 0100 无效的值
0000...0000 0000 0100 清理过的值

# [Resources — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/resources.html) 
 _https://docs.soliditylang.org/en/latest/resources.html_

## General Resources[](#general-resources "Link to this heading")
* [Ethereum.org Developers page](https://ethereum.org/en/developers/)
 
* [Ethereum StackExchange](https://ethereum.stackexchange.com/)
 
* [Solidity website](https://soliditylang.org/)
 
* [Solidity changelog](https://github.com/ethereum/solidity/blob/develop/Changelog.md)
 
* [Solidity codebase on GitHub](https://github.com/ethereum/solidity/)
 
* [Solidity language users chat](https://matrix.to/#/#ethereum_solidity:gitter.im)
 
* [Solidity compiler developers chat](https://matrix.to/#/#ethereum_solidity-dev:gitter.im)
 
* [awesome-solidity](https://github.com/bkrem/awesome-solidity)
 
* [Solidity by Example](https://solidity-by-example.org/)
 
* [Solidity documentation community translations](https://github.com/solidity-docs)
 
## Integrated (Ethereum) Development Environments[](#integrated-ethereum-development-environments "Link to this heading")
* [Ape](https://docs.apeworx.io/ape)
 
 A Python-based web3 development tool for compiling, testing, and interacting with smart contracts.
 
* [Brownie](https://eth-brownie.readthedocs.io/en/stable/)
 
 A Python-based development and testing framework for smart contracts targeting the Ethereum Virtual Machine. 💡 Note: As per the official docs, Brownie is no longer actively maintained. Future releases may come sporadically - or never at all. Check out Ape Framework (first in list) for all your python Ethereum development needs.
 
* [Dapp](https://dapp.tools/)
 
 Tool for building, testing and deploying smart contracts from the command-line.
 
* [Foundry](https://github.com/foundry-rs/foundry)
 
 Fast, portable and modular toolkit for Ethereum application development written in Rust.
 
* [Hardhat](https://hardhat.org/)
 
 Ethereum development environment with local Ethereum network, debugging features and plugin ecosystem.
 
* [Remix](https://remix.ethereum.org/)
 
 Browser-based IDE with integrated compiler and Solidity runtime environment without server-side components.
 
* [Truffle](https://trufflesuite.com/truffle/)
 
 Ethereum development framework. 💡 Note: Consensys announced the sunset of Truffle on September 21, 2023. Current users may check out the migration path and available product support [here.](https://consensys.io/blog/consensys-announces-the-sunset-of-truffle-and-ganache-and-new-hardhat)
 
## Editor Integrations[](#editor-integrations "Link to this heading")
* Emacs
 
 > * [Emacs Solidity](https://github.com/ethereum/emacs-solidity/)
 > 
 > Plugin for the Emacs editor providing syntax highlighting and compilation error reporting.
 > 
 
* IntelliJ
 
 > * [IntelliJ IDEA plugin](https://plugins.jetbrains.com/plugin/9475-solidity/)
 > 
 > Solidity plugin for IntelliJ IDEA (and all other JetBrains IDEs).
 > 
 
* Sublime Text
 
 > * [Package for SublimeText - Solidity language syntax](https://packagecontrol.io/packages/Ethereum/)
 > 
 > Solidity syntax highlighting for SublimeText editor.
 > 
 
* Vim
 
 > * [Vim Solidity by Thesis](https://github.com/thesis/vim-solidity/)
 > 
 > Syntax highlighting for Solidity in Vim.
 > 
 > * [Vim Solidity by TovarishFin](https://github.com/TovarishFin/vim-solidity)
 > 
 > Vim syntax file for Solidity.
 > 
 > * [Vim Syntastic](https://github.com/vim-syntastic/syntastic)
 > 
 > Plugin for the Vim editor providing compile checking.
 > 
 
* Visual Studio Code (VS Code)
 
 > * [Ethereum Remix Visual Studio Code extension](https://github.com/ethereum/remix-vscode)
 > 
 > Ethereum Remix extension pack for VS Code 💡 Note: As per the official repository, this extension has been removed from the VSCODE marketplace and will be replaced by a dedicated stand-alone desktop application.
 > 
 > * [Solidity Visual Studio Code extension, by Juan Blanco](https://juan.blanco.ws/solidity-contracts-in-visual-studio-code/)
 > 
 > Solidity plugin for Microsoft Visual Studio Code that includes syntax highlighting and the Solidity compiler.
 > 
 > * [Solidity Visual Studio Code extension, by Nomic Foundation](https://marketplace.visualstudio.com/items?itemName=NomicFoundation.hardhat-solidity)
 > 
 > Solidity and Hardhat support by the Hardhat team, including: syntax highlighting, jump to definition, renames, quick fixes and inline solc warnings and errors.
 > 
 > * [Solidity Visual Auditor extension](https://marketplace.visualstudio.com/items?itemName=tintinweb.solidity-visual-auditor)
 > 
 > Adds security centric syntax and semantic highlighting to Visual Studio Code.
 > 
 > * [Truffle for VS Code](https://marketplace.visualstudio.com/items?itemName=trufflesuite-csi.truffle-vscode)
 > 
 > Build, debug and deploy smart contracts on Ethereum and EVM-compatible blockchains. 💡 Note: This extension has built-in support for the Truffle Suite which is being sunset. For information on ongoing support, migration options and FAQs, visit the [Consensys blog.](https://consensys.io/blog/consensys-announces-the-sunset-of-truffle-and-ganache-and-new-hardhat)
 > 
 
## Solidity Tools[](#solidity-tools "Link to this heading")
* [ABI to Solidity interface converter](https://gist.github.com/chriseth/8f533d133fa0c15b0d6eaf3ec502c82b)
 
 A script for generating contract interfaces from the ABI of a smart contract.
 
* [abi-to-sol](https://github.com/gnidan/abi-to-sol)
 
 Tool to generate Solidity interface source from a given ABI JSON.
 
* [Aderyn](https://github.com/Cyfrin/aderyn)
 
 Rust-based solidity smart contract static analyzer designed to help find vulnerabilities in Solidity code bases.
 
* [Doxity](https://github.com/DigixGlobal/doxity)
 
 Documentation Generator for Solidity.
 
* [ethdebug](https://github.com/ethdebug/format)
 
 A standard debugging data format for smart contracts on Ethereum-compatible networks.
 
* [Ethlint](https://github.com/duaraghav8/Ethlint)
 
 Linter to identify and fix style and security issues in Solidity.
 
* [evmdis](https://github.com/Arachnid/evmdis)
 
 EVM Disassembler that performs static analysis on the bytecode to provide a higher level of abstraction than raw EVM operations.
 
* [EVM Lab](https://github.com/ethereum/evmlab/)
 
 A collection of tools to interact with the EVM. The package includes a VM, Etherchain API, and a trace-viewer with gas cost display.
 
* [hevm](https://github.com/dapphub/dapptools/tree/master/src/hevm#readme)
 
 EVM debugger and symbolic execution engine.
 
* [leafleth](https://github.com/clemlak/leafleth)
 
 A documentation generator for Solidity smart-contracts.
 
* [Scaffold-ETH 2](https://github.com/scaffold-eth/scaffold-eth-2)
 
 Forkable Ethereum development stack focused on fast product iterations.
 
* [sol2uml](https://www.npmjs.com/package/sol2uml)
 
 Unified Modeling Language (UML) class diagram generator for Solidity contracts.
 
* [solc-select](https://github.com/crytic/solc-select)
 
 A script to quickly switch between Solidity compiler versions.
 
* [Solidity prettier plugin](https://github.com/prettier-solidity/prettier-plugin-solidity)
 
 A Prettier Plugin for Solidity.
 
* [Solidity REPL](https://github.com/raineorshine/solidity-repl)
 
 Try Solidity instantly with a command-line Solidity console.
 
* [solgraph](https://github.com/raineorshine/solgraph)
 
 Visualize Solidity control flow and highlight potential security vulnerabilities.
 
* [Solhint](https://github.com/protofire/solhint)
 
 Solidity linter that provides security, style guide and best practice rules for smart contract validation.
 
* [Sourcify](https://sourcify.dev/)
 
 Decentralized automated contract verification service and public repository of contract metadata.
 
* [Sūrya](https://github.com/ConsenSys/surya/)
 
 Utility tool for smart contract systems, offering a number of visual outputs and information about the contracts’ structure. Also supports querying the function call graph.
 
* [Universal Mutator](https://github.com/agroce/universalmutator)
 
 A tool for mutation generation, with configurable rules and support for Solidity and Vyper.
 
* [Wake](https://github.com/Ackee-Blockchain/wake)
 
 A Python-based Solidity development and testing framework with built-in vulnerability detectors.
 
## Third-Party Solidity Parsers and Grammars[](#third-party-solidity-parsers-and-grammars "Link to this heading")
* [Solidity Parser for JavaScript](https://github.com/solidity-parser/parser)
 
 A Solidity parser for JS built on top of a robust ANTLR4 grammar.

# [分析编译器的输出结果 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/analysing-compilation-output.html) 
 _https://docs.soliditylang.org/zh-cn/latest/analysing-compilation-output.html_

## 分析编译器的输出结果[](#index-0 "此标题的永久链接")
看一下编译器生成的汇编代码往往是有用的。生成的二进制文件， 即 `solc --bin contract.sol` 的输出，通常很难阅读。 建议使用标志 `--asm` 来分析汇编输出。 即使是很大的合约，看一下改变前后的汇编结果的差异，往往是很有启发的。
以下合约（命名为 `contract.sol` ）为例：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwpjb250cmFjdCBDIHsKICAgIGZ1bmN0aW9uIG9uZSgpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4gMTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
contract C {
 function one() public pure returns (uint) {
 return 1;
 }
}
以下是 `solc --asm contract.sol` 的输出
\======= contract.sol:C =======
EVM assembly:
 /\* "contract.sol":0:86 contract C {... \*/
 mstore(0x40, 0x80)
 callvalue
 dup1
 iszero
 tag\_1
 jumpi
 0x00
 dup1
 revert
tag\_1:
 pop
 dataSize(sub\_0)
 dup1
 dataOffset(sub\_0)
 0x00
 codecopy
 0x00
 return
stop
sub\_0: assembly {
 /\* "contract.sol":0:86 contract C {... \*/
 mstore(0x40, 0x80)
 callvalue
 dup1
 iszero
 tag\_1
 jumpi
 0x00
 dup1
 revert
 tag\_1:
 pop
 jumpi(tag\_2, lt(calldatasize, 0x04))
 shr(0xe0, calldataload(0x00))
 dup1
 0x901717d1
 eq
 tag\_3
 jumpi
 tag\_2:
 0x00
 dup1
 revert
 /\* "contract.sol":17:84 function one() public pure returns (uint) {... \*/
 tag\_3:
 tag\_4
 tag\_5
 jump // in
 tag\_4:
 mload(0x40)
 tag\_6
 swap2
 swap1
 tag\_7
 jump // in
 tag\_6:
 mload(0x40)
 dup1
 swap2
 sub
 swap1
 return
 tag\_5:
 /\* "contract.sol":53:57 uint \*/
 0x00
 /\* "contract.sol":76:77 1 \*/
 0x01
 /\* "contract.sol":69:77 return 1 \*/
 swap1
 pop
 /\* "contract.sol":17:84 function one() public pure returns (uint) {... \*/
 swap1
 jump // out
 /\* "#utility.yul":7:125 \*/
 tag\_10:
 /\* "#utility.yul":94:118 \*/
 tag\_12
 /\* "#utility.yul":112:117 \*/
 dup2
 /\* "#utility.yul":94:118 \*/
 tag\_13
 jump // in
 tag\_12:
 /\* "#utility.yul":89:92 \*/
 dup3
 /\* "#utility.yul":82:119 \*/
 mstore
 /\* "#utility.yul":72:125 \*/
 pop
 pop
 jump // out
 /\* "#utility.yul":131:353 \*/
 tag\_7:
 0x00
 /\* "#utility.yul":262:264 \*/
 0x20
 /\* "#utility.yul":251:260 \*/
 dup3
 /\* "#utility.yul":247:265 \*/
 add
 /\* "#utility.yul":239:265 \*/
 swap1
 pop
 /\* "#utility.yul":275:346 \*/
 tag\_15
 /\* "#utility.yul":343:344 \*/
 0x00
 /\* "#utility.yul":332:341 \*/
 dup4
 /\* "#utility.yul":328:345 \*/
 add
 /\* "#utility.yul":319:325 \*/
 dup5
 /\* "#utility.yul":275:346 \*/
 tag\_10
 jump // in
 tag\_15:
 /\* "#utility.yul":229:353 \*/
 swap3
 swap2
 pop
 pop
 jump // out
 /\* "#utility.yul":359:436 \*/
 tag\_13:
 0x00
 /\* "#utility.yul":425:430 \*/
 dup2
 /\* "#utility.yul":414:430 \*/
 swap1
 pop
 /\* "#utility.yul":404:436 \*/
 swap2
 swap1
 pop
 jump // out
 auxdata: 0xa2646970667358221220a5874f19737ddd4c5d77ace1619e5160c67b3d4bedac75fce908fed32d98899864736f6c637827302e382e342d646576656c6f702e323032312e332e33302b636f6d6d69742e65613065363933380058
}
另外，上述输出也可以从 [Remix](https://remix.ethereum.org/) ， 在编译合约后的 “编译细节” 选项下获得。
请注意， `asm` 输出以创建/构造器代码开始。 部署代码是作为子对象的一部分提供的（在上面的例子中，它是子对象 `sub_0` 的一部分）。 `auxdata` 字段对应于合约 [元数据](https://docs.soliditylang.org/zh-cn/latest/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode) 。 汇编输出中的注释指向源文件的位置。注意 ＃utility.yul 是一个内部生成的实用函数文件， 可以使用标志 `--combined-json generated-sources,generated-sources-runtime` 获得。
类似地，可以通过 `solc --optimize --asm contract.sol` 命令获得优化后的程序集。 通常情况下，观察两个不同的Solidity源是否会产生相同的优化代码是很有趣的。 例如，查看表达式 `(a * b) / c`， `a * b / c` 是否生成相同的字节码。 在可能的话，在剥离引用源位置的注释之后，通过获取相应程序集输出的 `diff` 很容易做到这一点。
备注
`--asm` 的输出不是设计成机器可读的。因此，在solc的各个小版本之间，输出可能会有重大的变化。

# [Guide de la marque Solidity — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/brand-guide.html) 
 _https://docs.soliditylang.org/fr/latest/brand-guide.html_

Ce guide de la marque contient des informations sur la politique de la marque Solidity et les directives d’utilisation du logo.
## La marque Solidity[](#la-marque-solidity "Lien permanent vers cette rubrique")
Le langage de programmation Solidity est un projet communautaire à code source ouvert dirigé par une équipe centrale. L’équipe centrale est parrainée par la [Ethereum Foundation](https://ethereum.foundation/).
Ce document a pour objectif de fournir des informations sur la meilleure façon d’utiliser la marque et le logo Solidity.
Nous vous encourageons à lire attentivement ce document avant d’utiliser la marque ou le logo. Votre coopération est très appréciée !
## Nom de marque Solidity[](#nom-de-marque-solidity "Lien permanent vers cette rubrique")
Le terme « Solidity » doit être utilisé pour faire référence au langage de programmation Solidity uniquement.
Veuillez ne pas utiliser « Solidity » :
* Pour faire référence à tout autre langage de programmation.
 
* D’une manière qui pourrait induire en erreur ou impliquer l’association de modules, d’outils, de documentation ou d’autres ressources sans rapport avec le langage Solidity.
 
* D’une manière qui sème la confusion dans la communauté quant à savoir si le langage de programmation Solidity est open-source et libre d’utilisation.
 
## Licence du logo Solidity[](#licence-du-logo-solidity "Lien permanent vers cette rubrique")
Le logo Solidity est distribué et mis sous licence [Creative Commons”. Attribution 4.0 International License](https://creativecommons.org/licenses/by/4.0/).
Il s’agit de la licence Creative Commons la plus permissive, qui autorise la réutilisation et les modifications à toutes fins. et les modifications dans n’importe quel but.
Vous êtes libre de :
* **Partager** - Copier et redistribuer le matériel sur tout support ou format.
 
* **Adapter** - Remixer, transformer et construire à partir de ce matériel dans n’importe quel but, même commercial. dans n’importe quel but, même commercial.
 
Aux conditions suivantes :
* **Attribution** - Vous devez donner le crédit approprié, fournir un lien à la la licence, et indiquer si des modifications ont été apportées. Vous pouvez le faire de toute manière raisonnable, mais pas d’une manière qui suggère que l’équipe centrale de Solidity vous approuve ou approuve votre utilisation.
 
Lorsque vous utilisez le logo Solidity, veuillez respecter les directives relatives au logo Solidity.
## Directives relatives au logo Solidity[](#directives-relatives-au-logo-solidity "Lien permanent vers cette rubrique")
_(Cliquez avec le bouton droit de la souris sur le logo pour le télécharger.)_
Veuillez ne pas :
* Modifier le ratio du logo (ne pas l’étirer ou le couper).
 
* Modifier les couleurs du logo, sauf si cela est absolument nécessaire.
 
## Crédits[](#credits "Lien permanent vers cette rubrique")
Ce document a été, en partie, dérivé de la [Python Software Foundation sur l’utilisation des marques déposées](https://www.python.org/psf/trademarks/) et du [Guide des médias de Rust](https://www.rust-lang.org/policies/media-guide).

# [Utilisation du compilateur — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/using-the-compiler.html) 
 _https://docs.soliditylang.org/fr/latest/using-the-compiler.html_

## Utilisation du compilateur en ligne de commande[](#utilisation-du-compilateur-en-ligne-de-commande "Lien permanent vers cette rubrique")
Note
Cette section ne s’applique pas à [solcjs](https://docs.soliditylang.org/fr/latest/installing-solidity.html#solcjs), même s’il est utilisé en mode ligne de commande.
### Utilisation de base[](#utilisation-de-base "Lien permanent vers cette rubrique")
L’une des cibles de construction du référentiel Solidity est `solc`, le compilateur en ligne de commande de Solidity. L’utilisation de `solc --help` vous fournit une explication de toutes les options. Le compilateur peut produire diverses sorties, allant de simples binaires et assemblages sur un arbre syntaxique abstrait (parse tree) à des estimations de l’utilisation du gaz. Si vous voulez seulement compiler un seul fichier, vous le lancez comme `solc --bin sourceFile.sol` et il imprimera le binaire. Si vous voulez obtenir certaines des variantes de sortie plus avancées de `solc`, il est probablement préférable de lui dire de tout sortir dans des fichiers séparés en utilisant `solc -o outputDirectory --bin --ast-compact-json --asm sourceFile.sol`.
### Options de l’optimiseur[](#options-de-l-optimiseur "Lien permanent vers cette rubrique")
Avant de déployer votre contrat, activez l’optimiseur lors de la compilation en utilisant `solc --optimize --bin sourceFile.sol`. Par défaut, l’optimiseur optimisera le contrat en supposant qu’il est appelé 200 fois au cours de sa durée de vie (plus précisément, il suppose que chaque opcode est exécuté environ 200 fois). Si vous voulez que le déploiement initial du contrat soit moins cher et que les exécutions de fonctions ultérieures soient plus coûteuses, définissez-le à `--optimize-runs=1`. Si vous vous attendez à de nombreuses transactions et que vous ne vous souciez pas des coûts de la taille de la sortie, définissez `--optimize-runs` à un nombre élevé. Ce paramètre a des effets sur les éléments suivants (cela pourrait changer dans le futur) :
* la taille de la recherche binaire dans la routine d’envoi des fonctions
 
* la façon dont les constantes comme les grands nombres ou les chaînes de caractères sont stockées.
 
### Chemin de base et remappage des importations[](#chemin-de-base-et-remappage-des-importations "Lien permanent vers cette rubrique")
Le compilateur en ligne de commande lira automatiquement les fichiers importés depuis le système de fichiers, mais il est également possible de fournir des redirections [path](https://docs.soliditylang.org/fr/latest/path-resolution.html#import-remapping) en utilisant `prefix=path` de la manière suivante :
solc github.com/ethereum/dapp-bin/\=/usr/local/lib/dapp-bin/ file.sol
Ceci indique essentiellement au compilateur de rechercher tout ce qui commence par `github.com/ethereum/dapp-bin/` sous `/usr/local/lib/dapp-bin`.
Lorsque vous accédez au système de fichiers pour rechercher des importations, les [chemins qui ne commencent pas par ./ ou ../](https://docs.soliditylang.org/fr/latest/path-resolution.html#direct-imports) sont traités comme relatifs aux répertoires spécifiés en utilisant les options `--base-path` et `-include-path` (ou le répertoire de travail actuel si le chemin de base n’est pas spécifié). De plus, la partie du chemin ajoutée via ces options n’apparaîtra pas dans les métadonnées du contrat.
Pour des raisons de sécurité, le compilateur a des [restrictions sur les répertoires auxquels il peut accéder](https://docs.soliditylang.org/fr/latest/path-resolution.html#allowed-paths). Les répertoires des fichiers sources spécifiés sur la ligne de commande et les chemins cibles des remappings sont automatiquement autorisés à être accédés par le lecteur de fichiers, mais tout le reste est rejeté par défaut. Des chemins supplémentaires (et leurs sous-répertoires) peuvent être autorisés via la commande `--allow-paths /sample/path,/another/sample/path`. Tout ce qui se trouve à l’intérieur du chemin spécifié par `--base-path` est toujours autorisé.
Ce qui précède n’est qu’une simplification de la façon dont le compilateur gère les chemins d’importation. Pour une explication détaillée avec des exemples et une discussion des cas de coin, veuillez vous référer à la section sur [résolution de chemin](https://docs.soliditylang.org/fr/latest/path-resolution.html#path-resolution).
### Liens entre les bibliothèques[](#liens-entre-les-bibliotheques "Lien permanent vers cette rubrique")
Si vos contrats utilisent [libraries](https://docs.soliditylang.org/fr/latest/contracts.html#libraries), vous remarquerez que le bytecode contient des sous-chaînes de la forme `__$53aea86b7d70b31448b230b20ae141a537$__`. Il s’agit de caractères de remplacement pour les adresses réelles des bibliothèques. Le placeholder est un préfixe de 34 caractères de l’encodage hexadécimal du hachage keccak256 du nom de bibliothèque entièrement qualifié. Le fichier de bytecode contiendra également des lignes de la forme `// <placeholder> -> <fq library name>` à la fin pour aider à identifier les bibliothèques que les placeholders représentent. Notez que le nom de bibliothèque pleinement qualifié est le chemin de son fichier source et le nom de la bibliothèque séparés par `:`. Vous pouvez utiliser `solc` comme linker, ce qui signifie qu’il insérera les adresses des bibliothèques pour vous à ces endroits :
Soit vous ajoutez `--libraries "file.sol:Math=0x1234567890123456789012345678901234567890 file.sol:Heap=0xabCD5678901234567890123458901234567890"` à votre commande pour fournir une adresse pour chaque bibliothèque (utilisez des virgules ou des espaces comme séparateurs) ou stockez la chaîne dans un fichier (une bibliothèque par ligne) et lancez `solc` en utilisant –libraries fileName\`.
Note
À partir de la version 0.8.1 de Solidity, on accepte `=` comme séparateur entre bibliothèque et adresse, et `:` comme séparateur est déprécié. Il sera supprimé à l’avenir. Actuellement, `--libraries "file.sol:Math:0x123456789012345678901234567890123458901234567890 file.sol:Heap:0xabCD567890123456789012345890123234567890"` fonctionnera également.
Si `solc` est appelé avec l’option `--standard-json`, il attendra une entrée JSON (comme expliqué ci-dessous) sur l’entrée standard, et retournera une sortie JSON sur la sortie standard. C’est l’interface recommandée pour des utilisations plus complexes et particulièrement automatisées. Le processus se terminera toujours dans un état « success » et rapportera toute erreur via la sortie JSON. L’option `--base-path` est également traitée en mode standard-json.
Si `solc` est appelé avec l’option `--link`, tous les fichiers d’entrée sont interprétés comme des binaires non liés (encodés en hexadécimal) dans le format `__$53aea86b7d70b31448b230b20ae141a537$__` donné ci-dessus et sont liés in-place (si l’entrée est lue depuis stdin, elle est écrite sur stdout). Toutes les options sauf `--libraries` sont ignorées (y compris `-o`) dans ce cas.
Avertissement
La liaison manuelle des bibliothèques sur le bytecode généré est déconseillée car elle ne permet pas de mettre à jour les métadonnées du contrat. Puisque les métadonnées contiennent une liste de bibliothèques spécifiées au moment de la compilation et le bytecode contient un hash de métadonnées, vous obtiendrez des binaires différents, selon du moment où la liaison est effectuée.
Vous devez demander au compilateur de lier les bibliothèques au moment où un contrat est compilé, soit en en utilisant l’option `--libraries` de `solc` ou la clé `libraries` si vous utilisez l’interface standard-JSON au compilateur.
Note
L’espace réservé à la bibliothèque était auparavant le nom pleinement qualifié de la bibliothèque elle-même au lieu du hash de celui-ci. Ce format est toujours pris en charge par `solc --link` mais mais le compilateur ne l’affichera plus. Ce changement a été fait pour réduire la probabilité de collision entre les bibliothèques, puisque seuls les 36 premiers caractères du nom de du nom complet de la bibliothèque pouvaient être utilisés.
## Réglage de la version de l’EVM sur la cible[](#reglage-de-la-version-de-l-evm-sur-la-cible "Lien permanent vers cette rubrique")
Lorsque vous compilez le code de votre contrat, vous pouvez spécifier la version de la machine virtuelle d’Ethereum pour laquelle compiler afin d’éviter des caractéristiques ou des comportements particuliers.
Avertissement
La compilation pour la mauvaise version EVM peut entraîner un comportement erroné, étrange et défaillant. Veuillez vous assurer, en particulier si vous exécutez une chaîne privée, que vous utilisez les versions EVM correspondantes.
Sur la ligne de commande, vous pouvez sélectionner la version EVM comme suit :
solc --evm-version <VERSION> contract.sol
Dans l’interface [standard JSON](#compiler-api), utilisez la clé `"evmVersion"` dans le champ `"settings"` :
{
 "sources": {/\* ... \*/},
 "settings": {
 "optimizer": {/\* ... \*/},
 "evmVersion": "<VERSION>"
 }
}
### Options de la cible[](#options-de-la-cible "Lien permanent vers cette rubrique")
Vous trouverez ci-dessous une liste des versions EVM cibles et des modifications relatives au compilateur introduites à chaque version. La rétrocompatibilité n’est pas garantie entre chaque version.
* `homestead`
 
 * (version la plus ancienne)
 
 
* `tangerineWhistle`
 
 * Le coût du gaz pour l’accès à d’autres comptes a augmenté, ce qui est pertinent pour l’estimation du gaz et l’optimiseur.
 
 * Tout le gaz est envoyé par défaut pour les appels externes, auparavant une certaine quantité devait être conservée.
 
 
* `spuriousDragon`
 
 * Le coût du gaz pour l’opcode `exp` a augmenté, ce qui est important pour l’estimation du gaz et l’optimiseur.
 
 
* `byzantium`
 
 * Les opcodes `returndatacopy`, `returndatasize` et `staticcall` sont disponibles en assembly.
 
 * L’opcode `staticcall` est utilisé lors de l’appel de fonctions de vue ou de fonctions pures non libérées, ce qui empêche les fonctions de modifier l’état au niveau de l’EVM, c’est-à-dire qu’il s’applique même lorsque vous utilisez des conversions de type invalides.
 
 * Il est possible d’accéder aux données dynamiques renvoyées par les appels de fonctions.
 
 * Introduction de l’opcode `revert`, ce qui signifie que `revert()` ne gaspillera pas de gaz.
 
 
* `constantinople`
 
 * Les opcodes `create2`, `extcodehash'', ``shl`, `shr` et `sar` sont disponibles en assembleur.
 
 * Les opérateurs de décalage utilisent des opcodes de décalage et nécessitent donc moins de gaz.
 
 
* `petersburg`
 
 * Le compilateur se comporte de la même manière qu’avec constantinople.
 
 
* `istanbul`
 
 * Les opcodes `chainid` et [\`\`](#id1)selfbalance\`” sont disponibles en assemblage.
 
 
* `berlin`
 
 * Les coûts du gaz pour `LOAD`, `*CALL`, `BALANCE`, `EXT` et `SELFDESTRUCT` ont augmenté. Le compilateur suppose des coûts de gaz froid pour de telles opérations. Ceci est pertinent pour l’estimation des gaz et l’optimiseur.
 
 
* `london` (**default**)
 
 * Le tarif de base du bloc ([EIP-3198](https://eips.ethereum.org/EIPS/eip-3198) et [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559)) est accessible via le global `block.basefee` ou `basefee()` en assemblage inline.
 
 
## Description JSON des entrées et sorties du compilateur[](#description-json-des-entrees-et-sorties-du-compilateur "Lien permanent vers cette rubrique")
La manière recommandée de s’interfacer avec le compilateur Solidity, surtout pour les configurations plus complexes et automatisées est l’interface dite d’entrée-sortie JSON. La même interface est fournie par toutes les distributions du compilateur.
Les champs sont généralement susceptibles d’être modifiés, certains sont optionnels (comme indiqué), mais nous essayons de ne faire que des changements compatibles avec le passé.
L’API du compilateur attend une entrée au format JSON et produit le résultat de la compilation dans une sortie au format JSON. La sortie d’erreur standard n’est pas utilisée et le processus se terminera toujours dans un état de « succès », même s’il y a eu des erreurs. Les erreurs sont toujours signalées dans le cadre de la sortie JSON.
Les sous-sections suivantes décrivent le format à travers un exemple. Les commentaires ne sont bien sûr pas autorisés et sont utilisés ici uniquement à des fins explicatives.
### Description de l’entrée[](#description-de-l-entree "Lien permanent vers cette rubrique")
{
 // Requis : Langue du code source. Les langages actuellement pris en charge sont "Solidity" et "Yul".
 "language": "Solidity",
 // Requis
 "sources":
 {
 // Les clés ici sont les noms "globaux" des fichiers sources,
 // les importations peuvent utiliser d'autres fichiers via les remappings (voir ci-dessous).
 "myFile.sol":
 {
 // Facultatif : hachage keccak256 du fichier source.
 // Il est utilisé pour vérifier le contenu récupéré s'il est importé via des URL.
 "keccak256": "0x123...",
 // Obligatoire (sauf si "content" est utilisé, voir ci-dessous) : URL(s) vers le fichier source.
 // Les URL doivent être importées dans cet ordre et le résultat doit être vérifié par rapport à l'empreinte
 // le hachage keccak256 (si disponible). Si le hachage ne correspond pas ou si aucune des
 // URL n'aboutit à un succès, une erreur doit être signalée.
 // En utilisant l'interface en ligne de commande, seuls les chemins de systèmes de fichiers sont pris en charge.
 // Avec l'interface JavaScript, l'URL sera transmise au callback de lecture fourni par l'utilisateur.
 // Ainsi, toute URL prise en charge par le callback peut être utilisée.
 "urls":
 \[
 "bzzr://56ab...",
 "ipfs://Qma...",
 "/tmp/path/to/file.sol"
 // Si des fichiers sont utilisés, leurs répertoires doivent être ajoutés à la ligne de commande via
 // \`--allow-paths <path>\`.
 \]
 },
 "destructible":
 {
 // Facultatif : keccak256 hash du fichier source
 "keccak256": "0x234...",
 // Obligatoire (sauf si "urls" est utilisé) : contenu littéral du fichier source
 "content": "contract destructible is owned { function shutdown() { if (msg.sender == owner) selfdestruct(owner); } }"
 }
 },
 // Optionnel
 "settings":
 {
 // Facultatif : Arrête la compilation après l'étape donnée. Actuellement, seul "parsing" est valide ici
 "stopAfter": "parsing",
 // Facultatif : Liste triée de réaffectations
 "remappings": \[ ":g=/dir" \],
 // Facultatif : Paramètres de l'optimiseur
 "optimizer": {
 // Désactivé par défaut.
 // NOTE : enabled=false laisse toujours certaines optimisations activées. Voir les commentaires ci-dessous.
 // ATTENTION : Avant la version 0.8.6, l'omission de la clé 'enabled' n'était pas équivalente à la mise en place de la clé 'enabled'.
 // l'activer à false et désactiverait en fait toutes les optimisations.
 "enabled": true,
 // Optimisez en fonction du nombre de fois que vous avez l'intention d'exécuter le code.
 // Les valeurs les plus basses optimisent davantage le coût de déploiement initial, les valeurs les plus élevées optimisent davantage les utilisations à haute fréquence.
 // Plus les valeurs sont faibles, plus l'optimisation est axée sur le coût du déploiement initial.
 // Plus les valeurs sont élevées, plus l'optimisation est axée sur un usage fréquent.
 "runs": 200,
 // Activez ou désactivez les composants de l'optimiseur en détail.
 // L'interrupteur "enabled" ci-dessus fournit deux valeurs par défaut qui peuvent être
 // modifiables ici. Si "details" est donné, "enabled" peut être omis.
 "details": {
 // L'optimiseur de trou d'homme est toujours activé si aucun détail n'est donné,
 // utilisez les détails pour le désactiver.
 "peephole": true,
 // L'inliner est toujours activé si aucun détail n'est donné,
 // utilisez les détails pour le désactiver.
 "inliner": true,
 // L'enlèvement du jumpdest inutilisé est toujours activé si aucun détail n'est donné,
 // utilisez les détails pour le désactiver.
 "jumpdestRemover": true,
 // Réorganise parfois les littéraux dans les opérations commutatives.
 "orderLiterals": false,
 // Supprime les blocs de code dupliqués
 "deduplicate": false,
 // L'élimination des sous-expressions communes, c'est l'étape la plus compliquée mais
 // peut également fournir le gain le plus important.
 "cse": false,
 // Optimiser la représentation des nombres littéraux et des chaînes de caractères dans le code.
 "constantOptimizer": false,
 // Le nouvel optimiseur Yul. Opère principalement sur le code du codeur ABI v2
 // et de l'assemblage en ligne.
 // Il est activé en même temps que le réglage de l'optimiseur global
 // et peut être désactivé ici.
 // Avant Solidity 0.6.0, il devait être activé par ce commutateur.
 "yul": false,
 // Tuning options for the Yul optimizer.
 "yulDetails": {
 // Améliore l'allocation des emplacements de pile pour les variables, peut libérer les emplacements de pile plus tôt.
 // Activé par défaut si l'optimiseur Yul est activé.
 "stackAllocation": true,
 // Sélectionnez les étapes d'optimisation à appliquer.
 // Facultatif, l'optimiseur utilisera la séquence par défaut si elle est omise.
 "optimizerSteps": "dhfoDgvulfnTUtnIf..."
 }
 }
 },
 // Version de l'EVM pour laquelle il faut compiler.
 // Affecte la vérification de type et la génération de code. Peut être homestead,
 // tangerineWhistle, spuriousDragon, byzantium, constantinople, petersburg, istanbul ou berlin.
 "evmVersion": "byzantium",
 // Facultatif : Modifier le pipeline de compilation pour passer par la représentation intermédiaire de Yul.
 // Il s'agit d'une fonctionnalité hautement EXPERIMENTALE, à ne pas utiliser en production. Elle est désactivée par défaut.
 "viaIR": true,
 // Facultatif : Paramètres de débogage
 "debug": {
 // Comment traiter les chaînes de motifs de retour (et d'exigence). Les paramètres sont
 // "default", "strip", "debug" et "verboseDebug".
 // "default" n'injecte pas les chaînes revert générées par le compilateur et conserve celles fournies par l'utilisateur.
 // "strip" supprime toutes les chaînes revert (si possible, c'est-à-dire si des littéraux sont utilisés) en conservant les effets secondaires.
 // "debug" injecte des chaînes pour les revert internes générés par le compilateur, implémenté pour les encodeurs ABI V1 et V2 pour le moment.
 // "verboseDebug" ajoute même des informations supplémentaires aux chaînes de revert fournies par l'utilisateur (pas encore implémenté).
 "revertStrings": "default",
 // Facultatif : quantité d'informations de débogage supplémentaires à inclure dans les commentaires de l'EVM
 // produit et dans le code Yul. Les composants disponibles sont :
 // - \`location\` : Annotations de la forme \`@src <index>:<start>:<end>\` indiquant
 // l'emplacement de l'élément correspondant dans le fichier Solidity original, où :
 // - \`<index>\` est l'index du fichier correspondant à l'annotation \`@use-src\`,
 // - \`<start>\` est l'indice du premier octet à cet emplacement,
 // - \`<end>\` est l'indice du premier octet après cet emplacement.
 // - \`snippet\` : Un extrait de code d'une seule ligne provenant de l'emplacement indiqué par \`@src\`.
 // L'extrait est cité et suit l'annotation \`@src\` correspondante.
 // - \`\*\` : Valeur joker qui peut être utilisée pour tout demander.
 "debugInfo": \["location", "snippet"\]
 },
 // Paramètres des métadonnées (facultatif)
 "metadata": {
 // Utiliser uniquement le contenu littéral et non les URL (faux par défaut)
 "useLiteralContent": true,
 // Utilisez la méthode de hachage donnée pour le hachage des métadonnées qui est ajouté au bytecode.
 // Le hachage des métadonnées peut être supprimé du bytecode via l'option "none".
 // Les autres options sont "ipfs" et "bzzr1".
 // Si l'option est omise, "ipfs" est utilisé par défaut.
 "bytecodeHash": "ipfs"
 },
 // Adresses des bibliothèques. Si toutes les bibliothèques ne sont pas données ici,
 // il peut en résulter des objets non liés dont les données de sortie sont différentes.
 "libraries": {
 // La clé de premier niveau est le nom du fichier source dans lequel la bibliothèque est utilisée.
 // Si des remappages sont utilisés, ce fichier source doit correspondre au chemin global
 // après que les remappages aient été appliqués.
 // Si cette clé est une chaîne vide, cela fait référence à un niveau global.
 "myFile.sol": {
 "MyLib": "0x123123..."
 }
 },
 // Ce qui suit peut être utilisé pour sélectionner les sorties souhaitées en se basant
 // sur les noms de fichiers et de contrats.
 // Si ce champ est omis, alors le compilateur charge et effectue une vérification de type,
 // mais ne générera aucune sortie en dehors des erreurs.
 // La clé de premier niveau est le nom du fichier et la clé de second niveau est le nom du contrat.
 // Un nom de contrat vide est utilisé pour les sorties qui ne sont pas liées à un contrat
 // mais à l'ensemble du fichier source, comme l'AST.
 // Une étoile comme nom de contrat fait référence à tous les contrats du fichier.
 // De même, une étoile comme nom de fichier correspond à tous les fichiers.
 // Pour sélectionner toutes les sorties que le compilateur peut éventuellement générer, utilisez
 // "outputSelection : { "\*" : { "\*" : \[ "\*" \], "" : \[ "\*" \] } }"
 // mais notez que cela pourrait ralentir inutilement le processus de compilation.
 //
 // Les types de sortie disponibles sont les suivants :
 //
 // Niveau fichier (nécessite une chaîne vide comme nom de contrat) :
 // ast - AST de tous les fichiers sources
 //
 // Niveau du contrat (nécessite le nom du contrat ou "\*") :
 // abi - ABI
 // devdoc - Documentation du développeur (natspec)
 // userdoc - Documentation utilisateur (natspec)
 // metadata - Métadonnées
 // ir - Représentation intermédiaire Yul du code avant optimisation
 // irOptimized - Représentation intermédiaire après optimisation
 // storageLayout - Emplacements, décalages et types des variables d'état du contrat.
 // evm.assembly - Nouveau format d'assemblage
 // evm.legacyAssembly - Ancien format d'assemblage en JSON
 // evm.bytecode.functionDebugData - Informations de débogage au niveau des fonctions.
 // evm.bytecode.object - Objet bytecode
 // evm.bytecode.opcodes - Liste d'opcodes
 // evm.bytecode.sourceMap - Cartographie de la source (utile pour le débogage)
 // evm.bytecode.linkReferences - Références de liens (si objet non lié)
 // evm.bytecode.generatedSources - Sources générées par le compilateur.
 // evm.deployedBytecode\* - Bytecode déployé (a toutes les options que evm.bytecode a)
 // evm.deployedBytecode.immutableReferences - Correspondance entre les identifiants AST et les plages de bytecode qui font référence aux immutables.
 // evm.methodIdentifiers - La liste des hachages de fonctions
 // evm.gasEstimates - Estimations des gaz de fonction
 // ewasm.wast - Ewasm au format S-expressions de WebAssembly
 // ewasm.wasm - Ewasm au format binaire WebAssembly
 //
 // Notez que l'utilisation d'un \`evm\`, \`evm.bytecode\`, \`ewasm\`, etc. sélectionnera chaque
 // partie cible de cette sortie. De plus, \`\*\` peut être utilisé comme un joker pour tout demander.
 //
 "outputSelection": {
 "\*": {
 "\*": \[
 "metadata", "evm.bytecode" // Activez les sorties de métadonnées et de bytecode de chaque contrat.
 , "evm.bytecode.sourceMap" // Activez la sortie de la carte des sources pour chaque contrat.
 \],
 "": \[
 "ast" // Active la sortie AST de chaque fichier.
 \]
 },
 // Active la sortie de l'abi et des opcodes de MonContrat définis dans le fichier def.
 "def": {
 "MyContract": \[ "abi", "evm.bytecode.opcodes" \]
 }
 },
 // L'objet modelChecker est expérimental et sujet à des modifications.
 "modelChecker":
 {
 // Choisir les contrats qui doivent être analysés comme ceux qui sont déployés.
 "contracts":
 {
 "source1.sol": \["contract1"\],
 "source2.sol": \["contract2", "contract3"\]
 },
 // Choisir si les opérations de division et de modulo doivent être remplacées par
 // multiplication avec des variables de type slack. La valeur par défaut est \`true\`.
 // L'utilisation de \`false\` ici est recommandée si vous utilisez le moteur CHC
 // et que vous n'utilisez pas Spacer comme solveur de Horn (en utilisant Eldarica, par exemple).
 // Voir la section Vérification formelle pour une explication plus détaillée de cette option.
 "divModWithSlacks": true,
 // Choisissez le moteur de vérification de modèle à utiliser : all (par défaut), bmc, chc, none.
 "engine": "chc",
 // Choisissez quels types d'invariants doivent être signalés à l'utilisateur : contrat, réentrance.
 "invariants": \["contract", "reentrancy"\],
 // Choisissez si vous souhaitez afficher toutes les cibles non prouvées. La valeur par défaut est \`false\`.
 "showUnproved": true,
 // Choisissez les solveurs à utiliser, s'ils sont disponibles.
 // Voir la section Vérification formelle pour la description des solveurs.
 "solvers": \["cvc4", "smtlib2", "z3"\],
 // Choisissez les cibles à vérifier : constantCondition,
 // underflow, overflow, divByZero, balance, assert, popEmptyArray, outOfBounds.
 // Si l'option n'est pas donnée, toutes les cibles sont vérifiées par défaut,
 // sauf underflow/overflow pour Solidity >=0.8.7.
 // Voir la section Vérification formelle pour la description des cibles.
 "targets": \["underflow", "overflow", "assert"\],
 // Délai d'attente pour chaque requête SMT en millisecondes.
 // Si cette option n'est pas donnée, le SMTChecker utilisera une limite de ressources déterministe
 // par défaut.
 // Un délai d'attente de 0 signifie qu'il n'y a aucune restriction de ressources ou de temps pour les requêtes.
 "timeout": 20000
 }
 }
}
### Description de la sortie[](#description-de-la-sortie "Lien permanent vers cette rubrique")
{
 // Facultatif : non présent si aucune erreur/avis/infos n'a été rencontrée.
 "errors": \[
 {
 // Facultatif : Emplacement dans le fichier source.
 "sourceLocation": {
 "file": "sourceFile.sol",
 "start": 0,
 "end": 100
 },
 // Facultatif : Autres lieux (par exemple, lieux de déclarations conflictuelles)
 "secondarySourceLocations": \[
 {
 "file": "sourceFile.sol",
 "start": 64,
 "end": 92,
 "message": "L'autre déclaration est ici :"
 }
 \],
 // Obligatoire : Type d'erreur, tel que "TypeError", "InternalCompilerError", "Exception", etc.
 // Voir ci-dessous pour la liste complète des types.
 "type": "TypeError",
 // Obligatoire : Composant d'où provient l'erreur, tel que "general", "ewasm", etc.
 "component": "general",
 // Obligatoire ("error", "warning" ou "info", mais veuillez noter que cela pourrait être étendu à l'avenir)
 "severity": "error",
 // Facultatif : code unique pour la cause de l'erreur.
 "errorCode": "3141",
 // Obligatoire
 "message": "Mot clé invalide",
 // Facultatif : le message formaté avec l'emplacement de la source
 "formattedMessage": "sourceFile.sol:100: Invalid keyword"
 }
 \],
 // Il contient les sorties au niveau du fichier.
 // Il peut être limité/filtré par les paramètres outputSelection.
 "sources": {
 "sourceFile.sol": {
 // Identifiant de la source (utilisé dans les cartes de sources)
 "id": 1,
 // L'objet AST
 "ast": {}
 }
 },
 // Il contient les sorties au niveau du contrat.
 // Il peut être limité/filtré par les paramètres outputSelection.
 "contracts": {
 "sourceFile.sol": {
 // Si la langue utilisée ne comporte pas de noms de contrat, ce champ doit être égal à une chaîne vide.
 "ContractName": {
 // L'ABI du contrat Ethereum. S'il est vide, il est représenté comme un tableau vide.
 // See https://docs.soliditylang.org/en/develop/abi-spec.html
 "abi": \[\],
 // Voir la documentation sur la sortie des métadonnées (chaîne JSON sérialisée).
 "metadata": "{/\* ... \*/}",
 // Documentation utilisateur (natspec)
 "userdoc": {},
 // Documentation pour les développeurs (natspec)
 "devdoc": {},
 // Représentation intermédiaire (chaîne de caractères)
 "ir": "",
 // Voir la documentation sur l'agencement du stockage.
 "storageLayout": {"storage": \[/\* ... \*/\], "types": {/\* ... \*/} },
 // Sorties liées à l'EVM
 "evm": {
 // Assemblée (chaîne de caractères)
 "assembly": "",
 // Assemblage à l'ancienne (objet)
 "legacyAssembly": {},
 // Bytecode et détails connexes.
 "bytecode": {
 // Débogage des données au niveau des fonctions.
 "functionDebugData": {
 // Suit maintenant un ensemble de fonctions incluant des fonctions définies par l'utilisateur.
 // L'ensemble ne doit pas nécessairement être complet.
 "@mint\_13": { // Nom interne de la fonction
 "entryPoint": 128, // Décalage d'octet dans le bytecode où la fonction commence (facultatif)
 "id": 13, // AST ID de la définition de la fonction ou null pour les fonctions internes au compilateur (facultatif)
 "parameterSlots": 2, // Nombre d'emplacements de pile EVM pour les paramètres de fonction (facultatif)
 "returnSlots": 1 // Nombre d'emplacements de pile EVM pour les valeurs de retour (facultatif)
 }
 },
 // Le bytecode sous forme de chaîne hexagonale.
 "object": "00fe",
 // Liste des opcodes (chaîne de caractères)
 "opcodes": "",
 // Le mappage de la source sous forme de chaîne. Voir la définition du mappage de la source.
 "sourceMap": "",
 // Tableau des sources générées par le compilateur. Actuellement, il ne
 // contient qu'un seul fichier Yul.
 "generatedSources": \[{
 // Yul AST
 "ast": {/\* ... \*/},
 // Fichier source sous sa forme texte (peut contenir des commentaires)
 "contents":"{ function abi\_decode(start, end) -> data { data := calldataload(start) } }",
 // ID du fichier source, utilisé pour les références aux sources, même "namespace" que les fichiers sources de Solidity.
 "id": 2,
 "language": "Yul",
 "name": "#utility.yul"
 }\],
 // S'il est donné, il s'agit d'un objet non lié.
 "linkReferences": {
 "libraryFile.sol": {
 // Décalage des octets dans le bytecode.
 // La liaison remplace les 20 octets qui s'y trouvent.
 "Library1": \[
 { "start": 0, "length": 20 },
 { "start": 200, "length": 20 }
 \]
 }
 }
 },
 "deployedBytecode": {
 /\* ..., \*/ // La même disposition que ci-dessus.
 "immutableReferences": {
 // Il existe deux références à l'immuable avec l'ID AST 3, toutes deux d'une longueur de 32 octets. L'une se trouve
 // à l'offset 42 du bytecode, l'autre à l'offset 80 du bytecode.
 "3": \[{ "start": 42, "length": 32 }, { "start": 80, "length": 32 }\]
 }
 },
 // La liste des hachages de fonctions
 "methodIdentifiers": {
 "delegate(address)": "5c19a95c"
 },
 // Estimation des gaz de fonction
 "gasEstimates": {
 "creation": {
 "codeDepositCost": "420000",
 "executionCost": "infinite",
 "totalCost": "infinite"
 },
 "external": {
 "delegate(address)": "25000"
 },
 "internal": {
 "heavyLifting()": "infinite"
 }
 }
 },
 // Sorties liées à l'Ewasm
 "ewasm": {
 // Format des expressions S
 "wast": "",
 // Format binaire (chaîne hexagonale)
 "wasm": ""
 }
 }
 }
 }
}
#### Types d’erreurs[](#types-d-erreurs "Lien permanent vers cette rubrique")
1. `JSONError` : L’entrée JSON n’est pas conforme au format requis, par exemple, l’entrée n’est pas un objet JSON, la langue n’est pas supportée, etc.
 
2. `IOError` : Erreurs de traitement des entrées/sorties et des importations, telles qu’une URL non résoluble ou une erreur de hachage dans les sources fournies.
 
3. `ParserError` : Le code source n’est pas conforme aux règles du langage.
 
4. `DocstringParsingError` : Les balises NatSpec du bloc de commentaires ne peuvent pas être analysées.
 
5. `SyntaxError` : Erreur de syntaxe, comme l’utilisation de « continue » en dehors d’une boucle « for ».
 
6. `DeclarationError` : Noms d’identifiants invalides, impossibles à résoudre ou contradictoires. Par exemple, « Identifiant non trouvé ».
 
7. `TypeError` : Erreur dans le système de types, comme des conversions de types invalides, des affectations invalides, etc.
 
8. `UnimplementedFeatureError` : La fonctionnalité n’est pas supportée par le compilateur, mais devrait l’être dans les futures versions.
 
9. `InternalCompilerError` : Bogue interne déclenché dans le compilateur - il doit être signalé comme un problème.
 
10. `Exception` : Echec inconnu lors de la compilation - ceci devrait être signalé comme un problème.
 
11. `CompilerError` : Utilisation non valide de la pile du compilateur - ceci devrait être signalé comme un problème.
 
12. `FatalError` : Une erreur fatale n’a pas été traitée correctement - ceci devrait être signalé comme un problème.
 
13. `Warning` : Un avertissement, qui n’a pas arrêté la compilation, mais qui devrait être traité si possible.
 
14. `Info` : Une information que le compilateur pense que l’utilisateur pourrait trouver utile, mais qui n’est pas dangereuse et ne doit pas nécessairement être traitée.
 
## Outils de compilation[](#outils-de-compilation "Lien permanent vers cette rubrique")
### solidity-upgrade[](#solidity-upgrade "Lien permanent vers cette rubrique")
`solidity-upgrade` peut vous aider à mettre à jour semi-automatiquement vos contrats en fonction des changements de langue. Bien qu’il n’implémente pas et ne puisse pas implémenter tous changements requis pour chaque version de rupture, il prend en charge ceux qui, autrement, nécessiteraient de nombreux ajustements manuels répétitifs.
Note
`solidity-upgrade` effectue une grande partie du travail, mais vos contrats nécessiteront très probablement d’autres ajustements manuels. Nous vous recommandons d’utiliser un système de contrôle de version pour vos fichiers. Cela permet de réviser et éventuellement de revenir en arrière sur les modifications apportées.
Avertissement
`solidity-upgrade` n’est pas considéré comme complet ou exempt de bogues, donc veuillez l’utiliser avec précaution.
#### Modules de mise à niveau disponibles[](#modules-de-mise-a-niveau-disponibles "Lien permanent vers cette rubrique")
 
Module
Version
Description
`constructor`
0.5.0
Les constructeurs doivent maintenant être définis à l’aide dumot-clé « constructeur ».
`visibility`
0.5.0
La visibilité explicite des fonctions est désormais obligatoire, La valeur par défaut est `public`.
`abstract`
0.6.0
Le mot-clé `abstract` doit être utilisé si le contrat ne met pas en œuvre toutes ses fonctions.
`virtual`
0.6.0
Fonctions sans implémentation en dehors d’un doivent être marquées `virtual`.
`override`
0.6.0
> Lorsque vous remplacez une fonction ou un modificateur, la nouvelle fonction le mot clé
`override` doit être utilisé.
`dotsyntax`
0.7.0
La syntaxe suivante est obsolète : `f.gas(...)()`, `f.value(...)()` et `(new C).value(...)()`. Remplacez ces appels par `f{gas: ..., value: ...}()` et `(new C){value: ...}()`.
`now`
0.7.0
Le mot clé `now` est obsolète. Utilisez `block.timestamp` à la place.
`constructor-visibility`
0.7.0
Supprime la visibilité des constructeurs.
Veuillez lire [0.5.0 notes de mise à jour](https://docs.soliditylang.org/fr/latest/050-breaking-changes.html), [0.6.0 notes de mise à jour](https://docs.soliditylang.org/fr/latest/060-breaking-changes.html), [0.7.0 notes de mise à jour](https://docs.soliditylang.org/fr/latest/070-breaking-changes.html) et [0.8.0 notes de mise à jour](https://docs.soliditylang.org/fr/latest/080-breaking-changes.html) pour plus de détails.
#### Synopsis[](#synopsis "Lien permanent vers cette rubrique")
Usage: solidity-upgrade \[options\] contract.sol
Allowed options:
 --help Show help message and exit.
 --version Show version and exit.
 --allow-paths path(s)
 Allow a given path for imports. A list of paths can be
 supplied by separating them with a comma.
 --ignore-missing Ignore missing files.
 --modules module(s) Only activate a specific upgrade module. A list of
 modules can be supplied by separating them with a comma.
 --dry-run Apply changes in-memory only and don't write to input
 file.
 --verbose Print logs, errors and changes. Shortens output of
 upgrade patches.
 --unsafe Accept \*unsafe\* changes.
#### Rapports de bogue / Demandes de fonctionnalités[](#rapports-de-bogue-demandes-de-fonctionnalites "Lien permanent vers cette rubrique")
Si vous avez trouvé un bogue ou si vous avez une demande de fonctionnalité, veuillez [déposer une question](https://github.com/ethereum/solidity/issues/new/choose) sur Github.
#### Exemple[](#exemple "Lien permanent vers cette rubrique")
Supposons que vous ayez le contrat suivant dans `Source.sol` :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=cHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuNi40OwovLyBDZWNpIG5lIGNvbXBpbGVyYSBwYXMgYXByw6hzIGxhIHZlcnNpb24gMC43LjAuCi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBHUEwtMy4wCmNvbnRyYWN0IEMgewogICAgLy8gRklYTUUgOiBzdXBwcmltZXIgbGEgdmlzaWJpbGl0w6kgZHUgY29uc3RydWN0ZXVyIGV0IHJlbmRyZSBsZSBjb250cmF0IGFic3RyYWl0LgogICAgY29uc3RydWN0b3IoKSBpbnRlcm5hbCB7fQp9Cgpjb250cmFjdCBEIHsKICAgIHVpbnQgdGltZTsKCiAgICBmdW5jdGlvbiBmKCkgcHVibGljIHBheWFibGUgewogICAgICAgIC8vIEZJWE1FIDogcmVtcGxhY2VyIG1haW50ZW5hbnQgcGFyIGJsb2NrLnRpbWVzdGFtcAogICAgICAgIHRpbWUgPSBub3c7CiAgICB9Cn0KCmNvbnRyYWN0IEUgewogICAgRCBkOwoKICAgIC8vIEZJWE1FIDogc3VwcHJpbWVyIGxhIHZpc2liaWxpdMOpIGR1IGNvbnN0cnVjdGV1cgogICAgY29uc3RydWN0b3IoKSBwdWJsaWMge30KCiAgICBmdW5jdGlvbiBnKCkgcHVibGljIHsKICAgICAgICAvLyBGSVhNRSA6IGNoYW5nZSAudmFsdWUoNSkgPT4ge3ZhbHVlIDogNX0KICAgICAgICBkLmYudmFsdWUoNSkoKTsKICAgIH0KfQ==)
pragma solidity \>=0.6.0 <0.6.4;
// Ceci ne compilera pas après la version 0.7.0.
// SPDX-License-Identifier: GPL-3.0
contract C {
 // FIXME : supprimer la visibilité du constructeur et rendre le contrat abstrait.
 constructor() internal {}
}
contract D {
 uint time;
 function f() public payable {
 // FIXME : remplacer maintenant par block.timestamp
 time \= now;
 }
}
contract E {
 D d;
 // FIXME : supprimer la visibilité du constructeur
 constructor() public {}
 function g() public {
 // FIXME : change .value(5) => {value : 5}
 d.f.value(5)();
 }
}
##### Changements requis[](#changements-requis "Lien permanent vers cette rubrique")
Le contrat ci-dessus ne sera pas compilé à partir de la version 0.7.0. Pour mettre le contrat à jour avec la version actuelle de Solidity, les modules de mise à jour suivants doivent être exécutés : `constructor-visibility`, `now` et `dotsyntax`. Veuillez lire la documentation sur [modules disponibles](#upgrade-modules) pour plus de détails.
##### Exécution de la mise à niveau[](#execution-de-la-mise-a-niveau "Lien permanent vers cette rubrique")
Il est recommandé de spécifier explicitement les modules de mise à niveau en utilisant l’argument `--modules`.
solidity-upgrade --modules constructor-visibility,now,dotsyntax Source.sol
The command above applies all changes as shown below. Please review them carefully (the pragmas will have to be updated manually.)
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwphYnN0cmFjdCBjb250cmFjdCBDIHsKICAgIC8vIEZJWE1FIDogc3VwcHJpbWVyIGxhIHZpc2liaWxpdMOpIGR1IGNvbnN0cnVjdGV1ciBldCByZW5kcmUgbGUgY29udHJhdCBhYnN0cmFpdC4KICAgIGNvbnN0cnVjdG9yKCkge30KfQoKY29udHJhY3QgRCB7CiAgICB1aW50IHRpbWU7CgogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwYXlhYmxlIHsKICAgICAgICAvLyBGSVhNRSA6IHJlbXBsYWNlciBtYWludGVuYW50IHBhciBibG9jay50aW1lc3RhbXAKICAgICAgICB0aW1lID0gYmxvY2sudGltZXN0YW1wOwogICAgfQp9Cgpjb250cmFjdCBFIHsKICAgIEQgZDsKCiAgICAvLyBGSVhNRSA6IHN1cHByaW1lciBsYSB2aXNpYmlsaXTDqSBkdSBjb25zdHJ1Y3RldXIKICAgIGNvbnN0cnVjdG9yKCkge30KCiAgICBmdW5jdGlvbiBnKCkgcHVibGljIHsKICAgICAgICAvLyBGSVhNRSA6IGNoYW5nZSAudmFsdWUoNSkgPT4ge3ZhbHVlIDogNX0KICAgICAgICBkLmZ7dmFsdWU6IDV9KCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
abstract contract C {
 // FIXME : supprimer la visibilité du constructeur et rendre le contrat abstrait.
 constructor() {}
}
contract D {
 uint time;
 function f() public payable {
 // FIXME : remplacer maintenant par block.timestamp
 time \= block.timestamp;
 }
}
contract E {
 D d;
 // FIXME : supprimer la visibilité du constructeur
 constructor() {}
 function g() public {
 // FIXME : change .value(5) => {value : 5}
 d.f{value: 5}();
 }
}

# [源代码映射 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/internals/source_mappings.html) 
 _https://docs.soliditylang.org/zh-cn/latest/internals/source_mappings.html_

## 源代码映射[](#index-0 "此标题的永久链接")
作为AST输出的一部分，编译器提供了AST中相应节点所代表的源代码的范围。 这可以用于各种目的，包括基于AST报告错误的静态分析工具和突出局部变量及其用途的调试工具。
此外，编译器还可以生成从字节码到生成该指令的源代码范围的映射。 这对于在字节码层次上操作的静态分析工具和在调试器中显示源代码中的当前位置或断点处理来说， 也是很重要的。这个映射还包含其他信息，如跳转类型和修改器深度（见下文）。
这两种源码映射都使用整数标识符来指代源码文件。源文件的标识符存储在 `output['sources'][sourceName]['id']` 中， 其中 `output` 是标准json编译器接口的输出，被解析成JSON。 对于一些实用程序，编译器会生成 “内部” 源文件， 这些文件不是原始输入的一部分，而是从源映射中引用的。 这些源文件及其标识符可以通过 `output['contracts'][sourceName][contractName]['evm']['bytecode']['generatedSources']` 获得。
备注
如果指令没有与任何特定的源文件相关联，源映射将分配一个整数标识符 `-1`。 这可能发生在编译器生成的内联汇编语句所产生的字节码部分。
AST内部的源映射使用以下符号：
`s:l:f`
其中， `s` 是源代码文件中范围起始处的字节偏移量， `l` 是以字节为单位的源代码范围的长度， `f` 是上述源代码索引。
源码映射中的字节码的编码更为复杂。它是一个由 `s:l:f:j:m` 组成的列表，用 `;` 分隔。 这些元素中的每一个都对应着一条指令，也就是说，您不能使用字节偏移量， 而必须使用指令偏移量（推送指令比单个字节长）。字段 `s` ， `l` 和 `f` 同上。 `j` 可以是 `i`, `o` 或 `-`，表示跳转指令是进入一个函数， 从一个函数返回，还是作为一个循环的一部分的普通跳转。 最后一个字段， `m`，是一个整数，表示 “修改器深度”。 当占位符语句( `_` )进入修改器时，这个深度会增加，当它再次离开时，深度会减少。 这使得调试器可以跟踪一些棘手的情况，如同一个修改器被使用两次，或在一个修改器中使用多个占位符语句。
为了压缩这些源码映射，特别是字节码的源码映射，使用了以下规则：
* 如果一个字段为空，则使用前一个元素的值。
 
* 如果缺少 `:` ，以下所有字段都被认为是空的。
 
这意味着下面的源码映射代表了相同的信息：
`1:2:1;1:9:1;2:1:2;2:1:2;2:1:2`
`1:2:1;:9;2:1:2;;`
需要注意的是，当使用 [逐字（verbatim）](https://docs.soliditylang.org/zh-cn/latest/yul.html#yul-verbatim) 内建程序时， 源码映射将是无效的。内建程序被认为是一条指令，而不是潜在的多条指令。

# [Depolama Alanındaki Durum Değişkenlerinin Düzeni — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/internals/layout_in_storage.html) 
 _https://docs.soliditylang.org/tr/latest/internals/layout_in_storage.html_

Sözleşmelerin durum değişkenleri, birden fazla değerin bazen aynı depolama yuvasını(slot) kullanacağı şekilde kompakt bir şekilde depolanır. Dinamik olarak boyutlandırılmış diziler(arrays) ve mappingler (aşağıya bakınız) hariç olmak üzere, diğer tüm veriler `0` yuvasında saklanan ilk durum değişkeninden başlamak üzere bitişik bir şekilde öğe öğe saklanır. Her değişken için, değişkenin türüne göre bayt cinsinden bir boyut belirlenir. 32 bayttan daha az bir değere ihtiyaç duyan birden fazla bitişik öğe aşağıdaki kurallara uygun olarak eğer mümkünse tek bir depolama yuvasında paketlenir:
* Bir depolama yuvasındaki ilk öğe alt sıraya hizalanmış olarak saklanır.
 
* Değer türleri, depolanmak için yalnızca gerek duydukları kadar bayt kullanır.
 
* Bir değer türü bir depolama yuvasının kalan kısmına sığmazsa, bir sonraki depolama yuvasında saklanır.
 
* Struct’lar ve dizi(array) verileri için her zaman yeni bir yuva başlatılır. Ve öğeler bu kurallara göre sıkıca paketlenir.
 
* Struct veya dizi (array) verilerini izleyen öğeler için her zaman yeni bir depolama yuvası başlatır.
 
Kalıtım kullanan sözleşmeler için durum değişkenlerinin sıralaması, en temeldeki sözleşmeden başlayarak sözleşmelerin C3-doğrusallaştırılmış sırasına göre belirlenir. Eğer yukarıdaki kurallara da uygunsa, farklı sözleşmelerdeki durum değişkenleri aynı depolama yuvasını paylaşabilir.
Structure’ların ve dizilerin(arrays) elemanları, ayrı ayrı değerler şeklinde verilmiş gibi birbirlerinden sonra saklanırlar.
Uyarı
32 bayttan daha küçük değerdeki elemanları kullanırken, sözleşmenizin gas kullanımı daha yüksek olabilir. Bunun nedeni, ESM’nin bir seferde 32 bayt üzerinde çalışmasıdır. Bu nedenle, eleman bundan daha küçükse, ESM’nin elemanın boyutunu 32 bayttan istenen boyuta düşürmek için daha fazla işlem kullanması gerekir.
Depolama değerleriyle uğraşıyorsanız, küçültülmüş boyutlu türleri kullanmak faydalı olabilir, çünkü derleyici birden fazla öğeyi tek bir depolama yuvasına yerleştirecek ve böylece birden fazla okuma veya yazma işlemini tek bir işlemde birleştirecektir. Ancak bir yuvadaki tüm değerleri aynı anda okumuyor veya yazmıyorsanız, bunun ters bir etkisi olabilir: Çok değerli bir depolama yuvasına bir değer yazıldığı zaman, depolama yuvasının önce okunması ve ardından aynı yuvadaki diğer verilerin yok edilmemesi için yeni değerler ile birleştirilmesi gerekir.
Fonksiyon argümanları veya bellek değerleriyle uğraşırken, derleyici bu değerleri paketlemediği için bu durumun herhangi bir faydası yoktur.
Son olarak, ESM’nin bunu optimize etmesine izin vermek için, depolama değişkenlerinizi ve `struct` üyelerinizi sıkıca paketlenebilecekleri şekilde sıralamaya çalıştığınızdan emin olun. Örneğin, saklama değişkenlerinizi `uint128, uint256, uint128` yerine `uint128, uint128, uint256` şeklinde bildirdiğinizde, ilk örnek yalnızca iki saklama alanı kaplarken ikincisi üç saklama alanı kaplayacaktır.
Not
Depolama alanındaki durum değişkenlerinin düzeni, depolama pointer’larının kütüphanelere aktarılabilmesi nedeniyle Solidity’nin harici arayüzünün bir parçası olarak kabul edilir. Bu, bu bölümde özetlenen kurallarda yapılacak herhangi bir değişikliğin dilde işleyişi bozan bir değişiklik olarak kabul edileceği ve kritik yapısı nedeniyle uygulanmadan önce çok dikkatli bir şekilde düşünülmesi gerekeceği anlamına gelir. Böyle bir işleyişi bozan değişiklik durumunda, derleyicinin eski düzeni(layout) destekleyecek bir bytecode üreteceği bir uyumluluk modu yayınlamak isteriz.
## Mapping’ler ve Dinamik Diziler(Arrays)[](#mapping-ler-ve-dinamik-diziler-arrays "Permalink to this heading")
Tahmin edilemeyen boyutları nedeniyle, mapping’ler ve dinamik boyutlu dizi türleri kendilerinden önceki ve sonraki durum değişkenlerinin “arasında” saklanamaz. Bunun yerine, [yukarıdaki](#storage-inplace-encoding) depolama kurallarına göre yalnızca 32 bayt kapladıkları kabul edilir ve içerdikleri öğeler bir Keccak-256 hash’i kullanılarak hesaplanan farklı bir depolama yuvasından başlayarak depolanır.
Mapping veya dizinin depolama konumunun [depolama düzeni kuralları](#storage-inplace-encoding) uygulandıktan sonra `p` yuvası olduğunu varsayalım. Dinamik diziler için, bu yuva dizideki eleman sayısını saklar (bayt dizileri ve stringler bir istisnadır, bkz. [aşağıda](#bytes-and-string)). Mapping’ler için yuva boş kalır, ancak yine de yan yana duran iki mapping olsa bile içeriklerinin farklı depolama konumlarında sonlanmasını sağlamak için gereklidir.
Dizi(array) verileri `keccak256(p)` adresinden başlayarak yerleştirilir ve statik olarak boyutlandırılmış dizi verileriyle aynı biçimde düzenlenir: Elemanlar birbiri ardına sıralanır ve elemanlar 16 bayttan uzun değilse potansiyel olarak depolama yuvalarını paylaşırlar. Dinamik dizilerin dinamik dizileri bu kuralı özyinelemeli(recursive) şekilde uygular. `x` türünün `uint24[][]` olduğu `x[i][j]` öğesinin konumu aşağıdaki gibi hesaplanır (yine `x` öğesinin kendisinin `p` yuvasında saklandığını varsayarak): Yuva `keccak256(keccak256(p) + i) + floor(j / floor(256 / 24))` ve eleman `v` yuva verisinden `(v >> ((j % floor(256 / 24)) * 24)) & type(uint24).max`.
Bir `k` mapping anahtarına karşılık gelen değer `keccak256(h(k) . p)` adresinde bulunur; burada `.` birleştirme, `h` ise türüne bağlı olarak anahtara uygulanan bir fonksiyondur:
* değer türleri için, `h` değeri bellekte depolarken olduğu gibi 32 bayt olarak doldurur.
 
* stringler ve byte dizileri için, `h(k)` sadece doldurulmamış veridir.
 
Mapping değeri değer olmayan bir türse, hesaplanan yuva verinin başlangıcını işaret eder. Örneğin, değer struct türündeyse, üyeye ulaşmak için struct üyesine karşılık gelen bir ofset eklemeniz gerekir.
Örnek olarak, aşağıdaki sözleşmeye bakalım:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKCmNvbnRyYWN0IEMgewogICAgc3RydWN0IFMgeyB1aW50MTYgYTsgdWludDE2IGI7IHVpbnQyNTYgYzsgfQogICAgdWludCB4OwogICAgbWFwcGluZyh1aW50ID0+IG1hcHBpbmcodWludCA9PiBTKSkgZGF0YTsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract C {
 struct S { uint16 a; uint16 b; uint256 c; }
 uint x;
 mapping(uint \=> mapping(uint \=> S)) data;
}
Let us compute the storage location of `data[4][9].c`. The position of the mapping itself is `1` (the variable `x` with 32 bytes precedes it). This means `data[4]` is stored at `keccak256(uint256(4) . uint256(1))`. The type of `data[4]` is again a mapping and the data for `data[4][9]` starts at slot `keccak256(uint256(9) . keccak256(uint256(4) . uint256(1)))`. The slot offset of the member `c` inside the struct `S` is `1` because `a` and `b` are packed in a single slot. This means the slot for `data[4][9].c` is `keccak256(uint256(9) . keccak256(uint256(4) . uint256(1))) + 1`. The type of the value is `uint256`, so it uses a single slot.
### `bytes` ve `string`[](#bytes-ve-string "Permalink to this heading")
`bytes` ve `string` aynı şekilde şifrelenir. Genel olarak, şifreleme `bytes1[]` şifrelemesine benzer; dizinin kendisi için bir yuva ve bu yuvanın konumunun `keccak256` hash\`i kullanılarak hesaplanan bir veri alanı vardır. Ancak, küçük değerler için (32 bayttan daha küçük) dizi elemanları uzunluklarıyla birlikte aynı yuvada saklanır.
Özellikle: veri en fazla `31` bayt uzunluğundaysa, elemanlar yüksek sıralı baytlarda (sola hizalı bir şekilde) saklanır ve en düşük sıralı baytta `uzunluk * 2` değeri saklanır. `32` veya daha fazla bayt uzunluğundaki verileri saklayan bayt dizileri için, `p` ana yuvası `length * 2 + 1` değerini saklar ve veriler her zamanki gibi `keccak256(p)` içinde saklanır. Bu, en düşük bit’in ayarlanıp ayarlanmadığını kontrol ederek kısa bir diziyi uzun bir diziden ayırt edebileceğiniz anlamına gelir: kısa (ayarlanmamış) ve uzun (ayarlanmış).
Not
Geçersiz olarak şifrelenmiş yuvaların işlenmesi şu anda desteklenmemektedir ancak gelecekte bu özellik eklenebilir. IR aracılığıyla derleme yapıyorsanız, geçersiz olarak kodlanmış bir yuvayı okumak `Panic(0x22)` hatasıyla sonuçlanır.
## JSON Çıktısı[](#json-ciktisi "Permalink to this heading")
Bir sözleşmenin depolama düzeni [standart JSON arayüzü](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#compiler-api) aracılığıyla talep edilebilir. Çıktı, `storage` ve `types` olmak üzere iki anahtar içeren bir JSON nesnesidir. `storage` nesnesi, her bir elemanın aşağıdaki forma sahip olduğu bir dizidir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=ewogICAgImFzdElkIjogMiwKICAgICJjb250cmFjdCI6ICJmaWxlQTpBIiwKICAgICJsYWJlbCI6ICJ4IiwKICAgICJvZmZzZXQiOiAwLAogICAgInNsb3QiOiAiMCIsCiAgICAidHlwZSI6ICJ0X3VpbnQyNTYiCn0=)
{
 "astId": 2,
 "contract": "fileA:A",
 "label": "x",
 "offset": 0,
 "slot": "0",
 "type": "t\_uint256"
}
Yukarıdaki örnek, `fileA` kaynak biriminden `contract A { uint x; }` depolama düzenidir ve
* `astId` durum değişkeninin bildiriminin AST node’unun id’sidir
 
* `contract`, ön ek olarak yolunu da içeren sözleşmenin adıdır
 
* `label` durum değişkeninin adıdır
 
* `offset` şifrelemeye göre depolama yuvası içindeki bayt cinsinden ofsettir
 
* `slot` durum değişkeninin bulunduğu veya başladığı depolama yuvasıdır. Bu sayı çok büyük olabilir ve bu nedenle JSON değeri bir dize olarak gösterilir.
 
* `type` değişkenin tip bilgisi için anahtar olarak kullanılan bir tanımlayıcıdır (aşağıda açıklanmıştır)
 
Verilen `typep`, bu durumda `t_uint256`, `types` içinde şu forma sahip bir elemanı temsil eder:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=ewogICAgImVuY29kaW5nIjogImlucGxhY2UiLAogICAgImxhYmVsIjogInVpbnQyNTYiLAogICAgIm51bWJlck9mQnl0ZXMiOiAiMzIiLAp9)
{
 "encoding": "inplace",
 "label": "uint256",
 "numberOfBytes": "32",
}
nerede
* `encoding` verinin depolama alanında nasıl kodlandığı, olası değerler şunlardır:
 
 * `inplace`: veri depolama alanında bitişik olarak yerleştirilir (bkz [above](#storage-inplace-encoding)).
 
 * `mapping`: Keccak-256 hash tabanlı yöntem (bkz [above](#storage-hashed-encoding)).
 
 * `dynamic_array`: Keccak-256 hash tabanlı yöntem (bkz [above](#storage-hashed-encoding)).
 
 * `bytes`: veri boyutuna bağlı olarak tek slot veya Keccak-256 hash tabanlı (bkz [above](#bytes-and-string)).
 
* `label` kanonik tip adıdır.
 
* `numberOfBytes` kullanılan bayt sayısıdır (ondalık bir dize olarak).
 
 Eğer `numberOfBytes > 32` ise bunun birden fazla slot kullanıldığı anlamına geldiğini unutmayın.
 
Bazı türler yukarıdaki dört bilginin yanı sıra ekstra bilgilere de sahiptir. Mappingler `key` ve `value` türlerini içerir (yine bu tür mappingindeki bir girdiye referansta bulunur), diziler `base` türüne sahiptir ve structlar `members` türlerini üst düzey `storage` ile aynı formatta listeler (bkz [above](#storage-layout-top-level)).
Not
Bir sözleşmenin depolama düzeninin JSON çıktısı hala deneysel olarak kabul edilir ve Solidity’nin işleyişi bozmayan sürümlerinde değiştirilebilir.
Aşağıdaki örnekte, değer ve referans türleri, paketlenmiş olarak şifrelenmiş türler ve iç içe geçmiş türler içeren bir sözleşme ve depolama düzeni gösterilmektedir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwpjb250cmFjdCBBIHsKICAgIHN0cnVjdCBTIHsKICAgICAgICB1aW50MTI4IGE7CiAgICAgICAgdWludDEyOCBiOwogICAgICAgIHVpbnRbMl0gc3RhdGljQXJyYXk7CiAgICAgICAgdWludFtdIGR5bkFycmF5OwogICAgfQoKICAgIHVpbnQgeDsKICAgIHVpbnQgeTsKICAgIFMgczsKICAgIGFkZHJlc3MgYWRkcjsKICAgIG1hcHBpbmcgKHVpbnQgPT4gbWFwcGluZyAoYWRkcmVzcyA9PiBib29sKSkgbWFwOwogICAgdWludFtdIGFycmF5OwogICAgc3RyaW5nIHMxOwogICAgYnl0ZXMgYjE7Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract A {
 struct S {
 uint128 a;
 uint128 b;
 uint\[2\] staticArray;
 uint\[\] dynArray;
 }
 uint x;
 uint y;
 S s;
 address addr;
 mapping (uint \=> mapping (address \=> bool)) map;
 uint\[\] array;
 string s1;
 bytes b1;
}
{
 "storage": \[
 {
 "astId": 15,
 "contract": "fileA:A",
 "label": "x",
 "offset": 0,
 "slot": "0",
 "type": "t\_uint256"
 },
 {
 "astId": 17,
 "contract": "fileA:A",
 "label": "y",
 "offset": 0,
 "slot": "1",
 "type": "t\_uint256"
 },
 {
 "astId": 20,
 "contract": "fileA:A",
 "label": "s",
 "offset": 0,
 "slot": "2",
 "type": "t\_struct(S)13\_storage"
 },
 {
 "astId": 22,
 "contract": "fileA:A",
 "label": "addr",
 "offset": 0,
 "slot": "6",
 "type": "t\_address"
 },
 {
 "astId": 28,
 "contract": "fileA:A",
 "label": "map",
 "offset": 0,
 "slot": "7",
 "type": "t\_mapping(t\_uint256,t\_mapping(t\_address,t\_bool))"
 },
 {
 "astId": 31,
 "contract": "fileA:A",
 "label": "array",
 "offset": 0,
 "slot": "8",
 "type": "t\_array(t\_uint256)dyn\_storage"
 },
 {
 "astId": 33,
 "contract": "fileA:A",
 "label": "s1",
 "offset": 0,
 "slot": "9",
 "type": "t\_string\_storage"
 },
 {
 "astId": 35,
 "contract": "fileA:A",
 "label": "b1",
 "offset": 0,
 "slot": "10",
 "type": "t\_bytes\_storage"
 }
 \],
 "types": {
 "t\_address": {
 "encoding": "inplace",
 "label": "address",
 "numberOfBytes": "20"
 },
 "t\_array(t\_uint256)2\_storage": {
 "base": "t\_uint256",
 "encoding": "inplace",
 "label": "uint256\[2\]",
 "numberOfBytes": "64"
 },
 "t\_array(t\_uint256)dyn\_storage": {
 "base": "t\_uint256",
 "encoding": "dynamic\_array",
 "label": "uint256\[\]",
 "numberOfBytes": "32"
 },
 "t\_bool": {
 "encoding": "inplace",
 "label": "bool",
 "numberOfBytes": "1"
 },
 "t\_bytes\_storage": {
 "encoding": "bytes",
 "label": "bytes",
 "numberOfBytes": "32"
 },
 "t\_mapping(t\_address,t\_bool)": {
 "encoding": "mapping",
 "key": "t\_address",
 "label": "mapping(address => bool)",
 "numberOfBytes": "32",
 "value": "t\_bool"
 },
 "t\_mapping(t\_uint256,t\_mapping(t\_address,t\_bool))": {
 "encoding": "mapping",
 "key": "t\_uint256",
 "label": "mapping(uint256 => mapping(address => bool))",
 "numberOfBytes": "32",
 "value": "t\_mapping(t\_address,t\_bool)"
 },
 "t\_string\_storage": {
 "encoding": "bytes",
 "label": "string",
 "numberOfBytes": "32"
 },
 "t\_struct(S)13\_storage": {
 "encoding": "inplace",
 "label": "struct A.S",
 "members": \[
 {
 "astId": 3,
 "contract": "fileA:A",
 "label": "a",
 "offset": 0,
 "slot": "0",
 "type": "t\_uint128"
 },
 {
 "astId": 5,
 "contract": "fileA:A",
 "label": "b",
 "offset": 16,
 "slot": "0",
 "type": "t\_uint128"
 },
 {
 "astId": 9,
 "contract": "fileA:A",
 "label": "staticArray",
 "offset": 0,
 "slot": "1",
 "type": "t\_array(t\_uint256)2\_storage"
 },
 {
 "astId": 12,
 "contract": "fileA:A",
 "label": "dynArray",
 "offset": 0,
 "slot": "3",
 "type": "t\_array(t\_uint256)dyn\_storage"
 }
 \],
 "numberOfBytes": "128"
 },
 "t\_uint128": {
 "encoding": "inplace",
 "label": "uint128",
 "numberOfBytes": "16"
 },
 "t\_uint256": {
 "encoding": "inplace",
 "label": "uint256",
 "numberOfBytes": "32"
 }
 }
}

# [Solidity — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/) 
 _https://docs.soliditylang.org/en/latest/_

Solidity is an object-oriented, high-level language for implementing smart contracts. Smart contracts are programs that govern the behavior of accounts within the Ethereum state.
Solidity is a [curly-bracket language](https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Curly_bracket_languages) designed to target the Ethereum Virtual Machine (EVM). It is influenced by C++, Python, and JavaScript. You can find more details about which languages Solidity has been inspired by in the [language influences](https://docs.soliditylang.org/en/latest/language-influences.html) section.
Solidity is statically typed, supports inheritance, libraries, and complex user-defined types, among other features.
With Solidity, you can create contracts for uses such as voting, crowdfunding, blind auctions, and multi-signature wallets.
When deploying contracts, you should use the latest released version of Solidity. Apart from exceptional cases, only the latest version receives [security fixes](https://github.com/ethereum/solidity/security/policy#supported-versions). Furthermore, breaking changes, as well as new features, are introduced regularly. We currently use a 0.y.z version number [to indicate this fast pace of change](https://semver.org/#spec-item-4).
Warning
Solidity recently released the 0.8.x version that introduced a lot of breaking changes. Make sure you read [the full list](https://docs.soliditylang.org/en/latest/080-breaking-changes.html).
Ideas for improving Solidity or this documentation are always welcome, read our [contributors guide](https://docs.soliditylang.org/en/latest/contributing.html) for more details.
Hint
You can download this documentation as PDF, HTML or Epub by clicking on the versions flyout menu in the bottom-right corner and selecting the preferred download format.
## Getting Started[](#getting-started "Link to this heading")
**1\. Understand the Smart Contract Basics**
If you are new to the concept of smart contracts, we recommend you to get started by digging into the “Introduction to Smart Contracts” section, which covers the following:
* [A simple example smart contract](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#simple-smart-contract) written in Solidity.
 
* [Blockchain Basics](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#blockchain-basics).
 
* [The Ethereum Virtual Machine](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#the-ethereum-virtual-machine).
 
**2\. Get to Know Solidity**
Once you are accustomed to the basics, we recommend you read the [“Solidity by Example”](https://docs.soliditylang.org/en/latest/solidity-by-example.html) and “Language Description” sections to understand the core concepts of the language.
**3\. Install the Solidity Compiler**
There are various ways to install the Solidity compiler, simply choose your preferred option and follow the steps outlined on the [installation page](https://docs.soliditylang.org/en/latest/installing-solidity.html#installing-solidity).
Hint
You can try out code examples directly in your browser with the [Remix IDE](https://remix.ethereum.org/). Remix is a web browser-based IDE that allows you to write, deploy and administer Solidity smart contracts, without the need to install Solidity locally.
Warning
As humans write software, it can have bugs. Therefore, you should follow established software development best practices when writing your smart contracts. This includes code review, testing, audits, and correctness proofs. Smart contract users are sometimes more confident with code than their authors, and blockchains and smart contracts have their own unique issues to watch out for, so before working on production code, make sure you read the [Security Considerations](https://docs.soliditylang.org/en/latest/security-considerations.html#security-considerations) section.
**4\. Learn More**
If you want to learn more about building decentralized applications on Ethereum, the [Ethereum Developer Resources](https://ethereum.org/en/developers/) can help you with further general documentation around Ethereum, and a wide selection of tutorials, tools, and development frameworks.
If you have any questions, you can try searching for answers or asking on the [Ethereum StackExchange](https://ethereum.stackexchange.com/), or our [Gitter channel](https://gitter.im/ethereum/solidity).
## Translations[](#translations "Link to this heading")
Community contributors help translate this documentation into several languages. Note that they have varying degrees of completeness and up-to-dateness. The English version stands as a reference.
You can switch between languages by clicking on the flyout menu in the bottom-right corner and selecting the preferred language.
* [Chinese](https://docs.soliditylang.org/zh-cn/latest/)
 
* [French](https://docs.soliditylang.org/fr/latest/)
 
* [Indonesian](https://github.com/solidity-docs/id-indonesian)
 
* [Japanese](https://github.com/solidity-docs/ja-japanese)
 
* [Korean](https://github.com/solidity-docs/ko-korean)
 
* [Persian](https://github.com/solidity-docs/fa-persian)
 
* [Russian](https://github.com/solidity-docs/ru-russian)
 
* [Spanish](https://github.com/solidity-docs/es-spanish)
 
* [Turkish](https://docs.soliditylang.org/tr/latest/)
 
Note
We set up a GitHub organization and translation workflow to help streamline the community efforts. Please refer to the translation guide in the [solidity-docs org](https://github.com/solidity-docs) for information on how to start a new language or contribute to the community translations.

# [Structure of a Contract — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/structure-of-a-contract.html) 
 _https://docs.soliditylang.org/en/v0.8.30/structure-of-a-contract.html_

Contracts in Solidity are similar to classes in object-oriented languages. Each contract can contain declarations of [State Variables](#structure-state-variables), [Functions](#structure-functions), [Function Modifiers](#structure-function-modifiers), [Events](#structure-events), [Errors](#structure-errors), [Struct Types](#structure-struct-types) and [Enum Types](#structure-enum-types). Furthermore, contracts can inherit from other contracts.
There are also special kinds of contracts called [libraries](https://docs.soliditylang.org/en/v0.8.30/contracts.html#libraries) and [interfaces](https://docs.soliditylang.org/en/v0.8.30/contracts.html#interfaces).
The section about [contracts](https://docs.soliditylang.org/en/v0.8.30/contracts.html#contracts) contains more details than this section, which serves to provide a quick overview.
## State Variables[](#state-variables "Link to this heading")
State variables are variables whose values are either permanently stored in contract storage or, alternatively, temporarily stored in transient storage which is cleaned at the end of each transaction. See [data locations](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#locations) for more details.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgU2ltcGxlU3RvcmFnZSB7CiAgICB1aW50IHN0b3JlZERhdGE7IC8vIFN0YXRlIHZhcmlhYmxlCiAgICAvLyAuLi4KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract SimpleStorage {
 uint storedData; // State variable
 // ...
}
See the [Types](https://docs.soliditylang.org/en/v0.8.30/types.html#types) section for valid state variable types and [Visibility and Getters](https://docs.soliditylang.org/en/v0.8.30/contracts.html#visibility-and-getters) for possible choices for visibility.
## Functions[](#functions "Link to this heading")
Functions are the executable units of code. Functions are usually defined inside a contract, but they can also be defined outside of contracts.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKY29udHJhY3QgU2ltcGxlQXVjdGlvbiB7CiAgICBmdW5jdGlvbiBiaWQoKSBwdWJsaWMgcGF5YWJsZSB7IC8vIEZ1bmN0aW9uCiAgICAgICAgLy8gLi4uCiAgICB9Cn0KCi8vIEhlbHBlciBmdW5jdGlvbiBkZWZpbmVkIG91dHNpZGUgb2YgYSBjb250cmFjdApmdW5jdGlvbiBoZWxwZXIodWludCB4KSBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgIHJldHVybiB4ICogMjsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.1 <0.9.0;
contract SimpleAuction {
 function bid() public payable { // Function
 // ...
 }
}
// Helper function defined outside of a contract
function helper(uint x) pure returns (uint) {
 return x \* 2;
}
[Function Calls](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#function-calls) can happen internally or externally and have different levels of [visibility](https://docs.soliditylang.org/en/v0.8.30/contracts.html#visibility-and-getters) towards other contracts. [Functions](https://docs.soliditylang.org/en/v0.8.30/contracts.html#functions) accept [parameters and return variables](https://docs.soliditylang.org/en/v0.8.30/contracts.html#function-parameters-return-variables) to pass parameters and values between them.
## Function Modifiers[](#function-modifiers "Link to this heading")
Function modifiers can be used to amend the semantics of functions in a declarative way (see [Function Modifiers](https://docs.soliditylang.org/en/v0.8.30/contracts.html#modifiers) in the contracts section).
Overloading, that is, having the same modifier name with different parameters, is not possible.
Like functions, modifiers can be [overridden](https://docs.soliditylang.org/en/v0.8.30/contracts.html#modifier-overriding).
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCmNvbnRyYWN0IFB1cmNoYXNlIHsKICAgIGFkZHJlc3MgcHVibGljIHNlbGxlcjsKCiAgICBtb2RpZmllciBvbmx5U2VsbGVyKCkgeyAvLyBNb2RpZmllcgogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgIG1zZy5zZW5kZXIgPT0gc2VsbGVyLAogICAgICAgICAgICAiT25seSBzZWxsZXIgY2FuIGNhbGwgdGhpcy4iCiAgICAgICAgKTsKICAgICAgICBfOwogICAgfQoKICAgIGZ1bmN0aW9uIGFib3J0KCkgcHVibGljIHZpZXcgb25seVNlbGxlciB7IC8vIE1vZGlmaWVyIHVzYWdlCiAgICAgICAgLy8gLi4uCiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.22 <0.9.0;
contract Purchase {
 address public seller;
 modifier onlySeller() { // Modifier
 require(
 msg.sender \== seller,
 "Only seller can call this."
 );
 \_;
 }
 function abort() public view onlySeller { // Modifier usage
 // ...
 }
}
## Events[](#events "Link to this heading")
Events are convenience interfaces with the EVM logging facilities.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjI7CgpldmVudCBIaWdoZXN0QmlkSW5jcmVhc2VkKGFkZHJlc3MgYmlkZGVyLCB1aW50IGFtb3VudCk7IC8vIEV2ZW50Cgpjb250cmFjdCBTaW1wbGVBdWN0aW9uIHsKICAgIGZ1bmN0aW9uIGJpZCgpIHB1YmxpYyBwYXlhYmxlIHsKICAgICAgICAvLyAuLi4KICAgICAgICBlbWl0IEhpZ2hlc3RCaWRJbmNyZWFzZWQobXNnLnNlbmRlciwgbXNnLnZhbHVlKTsgLy8gVHJpZ2dlcmluZyBldmVudAogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.22;
event HighestBidIncreased(address bidder, uint amount); // Event
contract SimpleAuction {
 function bid() public payable {
 // ...
 emit HighestBidIncreased(msg.sender, msg.value); // Triggering event
 }
}
See [Events](https://docs.soliditylang.org/en/v0.8.30/contracts.html#events) in contracts section for information on how events are declared and can be used from within a dapp.
## Errors[](#errors "Link to this heading")
Errors allow you to define descriptive names and data for failure situations. Errors can be used in [revert statements](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#revert-statement). In comparison to string descriptions, errors are much cheaper and allow you to encode additional data. You can use NatSpec to describe the error to the user.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCi8vLyBOb3QgZW5vdWdoIGZ1bmRzIGZvciB0cmFuc2Zlci4gUmVxdWVzdGVkIGByZXF1ZXN0ZWRgLAovLy8gYnV0IG9ubHkgYGF2YWlsYWJsZWAgYXZhaWxhYmxlLgplcnJvciBOb3RFbm91Z2hGdW5kcyh1aW50IHJlcXVlc3RlZCwgdWludCBhdmFpbGFibGUpOwoKY29udHJhY3QgVG9rZW4gewogICAgbWFwcGluZyhhZGRyZXNzID0+IHVpbnQpIGJhbGFuY2VzOwogICAgZnVuY3Rpb24gdHJhbnNmZXIoYWRkcmVzcyB0bywgdWludCBhbW91bnQpIHB1YmxpYyB7CiAgICAgICAgdWludCBiYWxhbmNlID0gYmFsYW5jZXNbbXNnLnNlbmRlcl07CiAgICAgICAgaWYgKGJhbGFuY2UgPCBhbW91bnQpCiAgICAgICAgICAgIHJldmVydCBOb3RFbm91Z2hGdW5kcyhhbW91bnQsIGJhbGFuY2UpOwogICAgICAgIGJhbGFuY2VzW21zZy5zZW5kZXJdIC09IGFtb3VudDsKICAgICAgICBiYWxhbmNlc1t0b10gKz0gYW1vdW50OwogICAgICAgIC8vIC4uLgogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
/// Not enough funds for transfer. Requested \`requested\`,
/// but only \`available\` available.
error NotEnoughFunds(uint requested, uint available);
contract Token {
 mapping(address \=> uint) balances;
 function transfer(address to, uint amount) public {
 uint balance \= balances\[msg.sender\];
 if (balance < amount)
 revert NotEnoughFunds(amount, balance);
 balances\[msg.sender\] \-= amount;
 balances\[to\] += amount;
 // ...
 }
}
See [Custom Errors](https://docs.soliditylang.org/en/v0.8.30/contracts.html#errors) in the contracts section for more information.
## Struct Types[](#struct-types "Link to this heading")
Structs are custom defined types that can group several variables (see [Structs](https://docs.soliditylang.org/en/v0.8.30/types.html#structs) in types section).
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQmFsbG90IHsKICAgIHN0cnVjdCBWb3RlciB7IC8vIFN0cnVjdAogICAgICAgIHVpbnQgd2VpZ2h0OwogICAgICAgIGJvb2wgdm90ZWQ7CiAgICAgICAgYWRkcmVzcyBkZWxlZ2F0ZTsKICAgICAgICB1aW50IHZvdGU7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract Ballot {
 struct Voter { // Struct
 uint weight;
 bool voted;
 address delegate;
 uint vote;
 }
}
## Enum Types[](#enum-types "Link to this heading")
Enums can be used to create custom types with a finite set of ‘constant values’ (see [Enums](https://docs.soliditylang.org/en/v0.8.30/types.html#enums) in types section).
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgUHVyY2hhc2UgewogICAgZW51bSBTdGF0ZSB7IENyZWF0ZWQsIExvY2tlZCwgSW5hY3RpdmUgfSAvLyBFbnVtCn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract Purchase {
 enum State { Created, Locked, Inactive } // Enum
}

# [Solidity v0.5.0 Breaking Changes — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/050-breaking-changes.html) 
 _https://docs.soliditylang.org/en/v0.8.30/050-breaking-changes.html_

This section highlights the main breaking changes introduced in Solidity version 0.5.0, along with the reasoning behind the changes and how to update affected code. For the full list check [the release changelog](https://github.com/ethereum/solidity/releases/tag/v0.5.0).
Note
Contracts compiled with Solidity v0.5.0 can still interface with contracts and even libraries compiled with older versions without recompiling or redeploying them. Changing the interfaces to include data locations and visibility and mutability specifiers suffices. See the [Interoperability With Older Contracts](#interoperability) section below.
## Semantic Only Changes[](#semantic-only-changes "Link to this heading")
This section lists the changes that are semantic-only, thus potentially hiding new and different behavior in existing code.
* Signed right shift now uses proper arithmetic shift, i.e. rounding towards negative infinity, instead of rounding towards zero. Signed and unsigned shift will have dedicated opcodes in Constantinople, and are emulated by Solidity for the moment.
 
* The `continue` statement in a `do...while` loop now jumps to the condition, which is the common behavior in such cases. It used to jump to the loop body. Thus, if the condition is false, the loop terminates.
 
* The functions `.call()`, `.delegatecall()` and `.staticcall()` do not pad anymore when given a single `bytes` parameter.
 
* Pure and view functions are now called using the opcode `STATICCALL` instead of `CALL` if the EVM version is Byzantium or later. This disallows state changes on the EVM level.
 
* The ABI encoder now properly pads byte arrays and strings from calldata (`msg.data` and external function parameters) when used in external function calls and in `abi.encode`. For unpadded encoding, use `abi.encodePacked`.
 
* The ABI decoder reverts in the beginning of functions and in `abi.decode()` if passed calldata is too short or points out of bounds. Note that dirty higher order bits are still simply ignored.
 
* Forward all available gas with external function calls starting from Tangerine Whistle.
 
## Semantic and Syntactic Changes[](#semantic-and-syntactic-changes "Link to this heading")
This section highlights changes that affect syntax and semantics.
* The functions `.call()`, `.delegatecall()`, `staticcall()`, `keccak256()`, `sha256()` and `ripemd160()` now accept only a single `bytes` argument. Moreover, the argument is not padded. This was changed to make more explicit and clear how the arguments are concatenated. Change every `.call()` (and family) to a `.call("")` and every `.call(signature, a, b, c)` to use `.call(abi.encodeWithSignature(signature, a, b, c))` (the last one only works for value types). Change every `keccak256(a, b, c)` to `keccak256(abi.encodePacked(a, b, c))`. Even though it is not a breaking change, it is suggested that developers change `x.call(bytes4(keccak256("f(uint256)")), a, b)` to `x.call(abi.encodeWithSignature("f(uint256)", a, b))`.
 
* Functions `.call()`, `.delegatecall()` and `.staticcall()` now return `(bool, bytes memory)` to provide access to the return data. Change `bool success = otherContract.call("f")` to `(bool success, bytes memory data) = otherContract.call("f")`.
 
* Solidity now implements C99-style scoping rules for function local variables, that is, variables can only be used after they have been declared and only in the same or nested scopes. Variables declared in the initialization block of a `for` loop are valid at any point inside the loop.
 
## Explicitness Requirements[](#explicitness-requirements "Link to this heading")
This section lists changes where the code now needs to be more explicit. For most of the topics the compiler will provide suggestions.
* Explicit function visibility is now mandatory. Add `public` to every function and constructor, and `external` to every fallback or interface function that does not specify its visibility already.
 
* Explicit data location for all variables of struct, array or mapping types is now mandatory. This is also applied to function parameters and return variables. For example, change `uint[] x = z` to `uint[] storage x = z`, and `function f(uint[][] x)` to `function f(uint[][] memory x)` where `memory` is the data location and might be replaced by `storage` or `calldata` accordingly. Note that `external` functions require parameters with a data location of `calldata`.
 
* Contract types do not include `address` members anymore in order to separate the namespaces. Therefore, it is now necessary to explicitly convert values of contract type to addresses before using an `address` member. Example: if `c` is a contract, change `c.transfer(...)` to `address(c).transfer(...)`, and `c.balance` to `address(c).balance`.
 
* Explicit conversions between unrelated contract types are now disallowed. You can only convert from a contract type to one of its base or ancestor types. If you are sure that a contract is compatible with the contract type you want to convert to, although it does not inherit from it, you can work around this by converting to `address` first. Example: if `A` and `B` are contract types, `B` does not inherit from `A` and `b` is a contract of type `B`, you can still convert `b` to type `A` using `A(address(b))`. Note that you still need to watch out for matching payable fallback functions, as explained below.
 
* The `address` type was split into `address` and `address payable`, where only `address payable` provides the `transfer` function. An `address payable` can be directly converted to an `address`, but the other way around is not allowed. Converting `address` to `address payable` is possible via conversion through `uint160`. If `c` is a contract, `address(c)` results in `address payable` only if `c` has a payable fallback function. If you use the [withdraw pattern](https://docs.soliditylang.org/en/v0.8.30/common-patterns.html#withdrawal-pattern), you most likely do not have to change your code because `transfer` is only used on `msg.sender` instead of stored addresses and `msg.sender` is an `address payable`.
 
* Conversions between `bytesX` and `uintY` of different size are now disallowed due to `bytesX` padding on the right and `uintY` padding on the left which may cause unexpected conversion results. The size must now be adjusted within the type before the conversion. For example, you can convert a `bytes4` (4 bytes) to a `uint64` (8 bytes) by first converting the `bytes4` variable to `bytes8` and then to `uint64`. You get the opposite padding when converting through `uint32`. Before v0.5.0 any conversion between `bytesX` and `uintY` would go through `uint8X`. For example `uint8(bytes3(0x291807))` would be converted to `uint8(uint24(bytes3(0x291807)))` (the result is `0x07`).
 
* Using `msg.value` in non-payable functions (or introducing it via a modifier) is disallowed as a security feature. Turn the function into `payable` or create a new internal function for the program logic that uses `msg.value`.
 
* For clarity reasons, the command-line interface now requires `-` if the standard input is used as source.
 
## Deprecated Elements[](#deprecated-elements "Link to this heading")
This section lists changes that deprecate prior features or syntax. Note that many of these changes were already enabled in the experimental mode `v0.5.0`.
### Command-line and JSON Interfaces[](#command-line-and-json-interfaces "Link to this heading")
* The command-line option `--formal` (used to generate Why3 output for further formal verification) was deprecated and is now removed. A new formal verification module, the SMTChecker, is enabled via `pragma experimental SMTChecker;`.
 
* The command-line option `--julia` was renamed to `--yul` due to the renaming of the intermediate language `Julia` to `Yul`.
 
* The `--clone-bin` and `--combined-json clone-bin` command-line options were removed.
 
* Remappings with empty prefix are disallowed.
 
* The JSON AST fields `constant` and `payable` were removed. The information is now present in the `stateMutability` field.
 
* The JSON AST field `isConstructor` of the `FunctionDefinition` node was replaced by a field called `kind` which can have the value `"constructor"`, `"fallback"` or `"function"`.
 
* In unlinked binary hex files, library address placeholders are now the first 36 hex characters of the keccak256 hash of the fully qualified library name, surrounded by `$...$`. Previously, just the fully qualified library name was used. This reduces the chances of collisions, especially when long paths are used. Binary files now also contain a list of mappings from these placeholders to the fully qualified names.
 
### Constructors[](#constructors "Link to this heading")
* Constructors must now be defined using the `constructor` keyword.
 
* Calling base constructors without parentheses is now disallowed.
 
* Specifying base constructor arguments multiple times in the same inheritance hierarchy is now disallowed.
 
* Calling a constructor with arguments but with wrong argument count is now disallowed. If you only want to specify an inheritance relation without giving arguments, do not provide parentheses at all.
 
### Functions[](#functions "Link to this heading")
* Function `callcode` is now disallowed (in favor of `delegatecall`). It is still possible to use it via inline assembly.
 
* `suicide` is now disallowed (in favor of `selfdestruct`).
 
* `sha3` is now disallowed (in favor of `keccak256`).
 
* `throw` is now disallowed (in favor of `revert`, `require` and `assert`).
 
### Conversions[](#conversions "Link to this heading")
* Explicit and implicit conversions from decimal literals to `bytesXX` types is now disallowed.
 
* Explicit and implicit conversions from hex literals to `bytesXX` types of different size is now disallowed.
 
### Literals and Suffixes[](#literals-and-suffixes "Link to this heading")
* The unit denomination `years` is now disallowed due to complications and confusions about leap years.
 
* Trailing dots that are not followed by a number are now disallowed.
 
* Combining hex numbers with unit denominations (e.g. `0x1e wei`) is now disallowed.
 
* The prefix `0X` for hex numbers is disallowed, only `0x` is possible.
 
### Variables[](#variables "Link to this heading")
* Declaring empty structs is now disallowed for clarity.
 
* The `var` keyword is now disallowed to favor explicitness.
 
* Assignments between tuples with different number of components is now disallowed.
 
* Values for constants that are not compile-time constants are disallowed.
 
* Multi-variable declarations with mismatching number of values are now disallowed.
 
* Uninitialized storage variables are now disallowed.
 
* Empty tuple components are now disallowed.
 
* Detecting cyclic dependencies in variables and structs is limited in recursion to 256.
 
* Fixed-size arrays with a length of zero are now disallowed.
 
### Syntax[](#syntax "Link to this heading")
* Using `constant` as function state mutability modifier is now disallowed.
 
* Boolean expressions cannot use arithmetic operations.
 
* The unary `+` operator is now disallowed.
 
* Literals cannot anymore be used with `abi.encodePacked` without prior conversion to an explicit type.
 
* Empty return statements for functions with one or more return values are now disallowed.
 
* The “loose assembly” syntax is now disallowed entirely, that is, jump labels, jumps and non-functional instructions cannot be used anymore. Use the new `while`, `switch` and `if` constructs instead.
 
* Functions without implementation cannot use modifiers anymore.
 
* Function types with named return values are now disallowed.
 
* Single statement variable declarations inside if/while/for bodies that are not blocks are now disallowed.
 
* New keywords: `calldata` and `constructor`.
 
* New reserved keywords: `alias`, `apply`, `auto`, `copyof`, `define`, `immutable`, `implements`, `macro`, `mutable`, `override`, `partial`, `promise`, `reference`, `sealed`, `sizeof`, `supports`, `typedef` and `unchecked`.
 
## Interoperability With Older Contracts[](#interoperability-with-older-contracts "Link to this heading")
It is still possible to interface with contracts written for Solidity versions prior to v0.5.0 (or the other way around) by defining interfaces for them. Consider you have the following pre-0.5.0 contract already deployed:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjQuMjU7Ci8vIFRoaXMgd2lsbCByZXBvcnQgYSB3YXJuaW5nIHVudGlsIHZlcnNpb24gMC40LjI1IG9mIHRoZSBjb21waWxlcgovLyBUaGlzIHdpbGwgbm90IGNvbXBpbGUgYWZ0ZXIgMC41LjAKY29udHJhY3QgT2xkQ29udHJhY3QgewogICAgZnVuY3Rpb24gc29tZU9sZEZ1bmN0aW9uKHVpbnQ4IGEpIHsKICAgICAgICAvLy4uLgogICAgfQogICAgZnVuY3Rpb24gYW5vdGhlck9sZEZ1bmN0aW9uKCkgY29uc3RhbnQgcmV0dXJucyAoYm9vbCkgewogICAgICAgIC8vLi4uCiAgICB9CiAgICAvLyAuLi4KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.4.25;
// This will report a warning until version 0.4.25 of the compiler
// This will not compile after 0.5.0
contract OldContract {
 function someOldFunction(uint8 a) {
 //...
 }
 function anotherOldFunction() constant returns (bool) {
 //...
 }
 // ...
}
This will no longer compile with Solidity v0.5.0. However, you can define a compatible interface for it:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwppbnRlcmZhY2UgT2xkQ29udHJhY3QgewogICAgZnVuY3Rpb24gc29tZU9sZEZ1bmN0aW9uKHVpbnQ4IGEpIGV4dGVybmFsOwogICAgZnVuY3Rpb24gYW5vdGhlck9sZEZ1bmN0aW9uKCkgZXh0ZXJuYWwgcmV0dXJucyAoYm9vbCk7Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
interface OldContract {
 function someOldFunction(uint8 a) external;
 function anotherOldFunction() external returns (bool);
}
Note that we did not declare `anotherOldFunction` to be `view`, despite it being declared `constant` in the original contract. This is due to the fact that starting with Solidity v0.5.0 `staticcall` is used to call `view` functions. Prior to v0.5.0 the `constant` keyword was not enforced, so calling a function declared `constant` with `staticcall` may still revert, since the `constant` function may still attempt to modify storage. Consequently, when defining an interface for older contracts, you should only use `view` in place of `constant` in case you are absolutely sure that the function will work with `staticcall`.
Given the interface defined above, you can now easily use the already deployed pre-0.5.0 contract:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKaW50ZXJmYWNlIE9sZENvbnRyYWN0IHsKICAgIGZ1bmN0aW9uIHNvbWVPbGRGdW5jdGlvbih1aW50OCBhKSBleHRlcm5hbDsKICAgIGZ1bmN0aW9uIGFub3RoZXJPbGRGdW5jdGlvbigpIGV4dGVybmFsIHJldHVybnMgKGJvb2wpOwp9Cgpjb250cmFjdCBOZXdDb250cmFjdCB7CiAgICBmdW5jdGlvbiBkb1NvbWV0aGluZyhPbGRDb250cmFjdCBhKSBwdWJsaWMgcmV0dXJucyAoYm9vbCkgewogICAgICAgIGEuc29tZU9sZEZ1bmN0aW9uKDB4NDIpOwogICAgICAgIHJldHVybiBhLmFub3RoZXJPbGRGdW5jdGlvbigpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
interface OldContract {
 function someOldFunction(uint8 a) external;
 function anotherOldFunction() external returns (bool);
}
contract NewContract {
 function doSomething(OldContract a) public returns (bool) {
 a.someOldFunction(0x42);
 return a.anotherOldFunction();
 }
}
Similarly, pre-0.5.0 libraries can be used by defining the functions of the library without implementation and supplying the address of the pre-0.5.0 library during linking (see [Using the Commandline Compiler](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#commandline-compiler) for how to use the commandline compiler for linking):
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gVGhpcyB3aWxsIG5vdCBjb21waWxlIGFmdGVyIDAuNi4wCi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBHUEwtMy4wCnByYWdtYSBzb2xpZGl0eSBeMC41LjA7CgpsaWJyYXJ5IE9sZExpYnJhcnkgewogICAgZnVuY3Rpb24gc29tZUZ1bmN0aW9uKHVpbnQ4IGEpIHB1YmxpYyByZXR1cm5zKGJvb2wpOwp9Cgpjb250cmFjdCBOZXdDb250cmFjdCB7CiAgICBmdW5jdGlvbiBmKHVpbnQ4IGEpIHB1YmxpYyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmV0dXJuIE9sZExpYnJhcnkuc29tZUZ1bmN0aW9uKGEpOwogICAgfQp9)
// This will not compile after 0.6.0
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.5.0;
library OldLibrary {
 function someFunction(uint8 a) public returns(bool);
}
contract NewContract {
 function f(uint8 a) public returns (bool) {
 return OldLibrary.someFunction(a);
 }
}
## Example[](#example "Link to this heading")
The following example shows a contract and its updated version for Solidity v0.5.0 with some of the changes listed in this section.
Old version:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjQuMjU7Ci8vIFRoaXMgd2lsbCBub3QgY29tcGlsZSBhZnRlciAwLjUuMAoKY29udHJhY3QgT3RoZXJDb250cmFjdCB7CiAgICB1aW50IHg7CiAgICBmdW5jdGlvbiBmKHVpbnQgeSkgZXh0ZXJuYWwgewogICAgICAgIHggPSB5OwogICAgfQogICAgZnVuY3Rpb24oKSBwYXlhYmxlIGV4dGVybmFsIHt9Cn0KCmNvbnRyYWN0IE9sZCB7CiAgICBPdGhlckNvbnRyYWN0IG90aGVyOwogICAgdWludCBteU51bWJlcjsKCiAgICAvLyBGdW5jdGlvbiBtdXRhYmlsaXR5IG5vdCBwcm92aWRlZCwgbm90IGFuIGVycm9yLgogICAgZnVuY3Rpb24gc29tZUludGVnZXIoKSBpbnRlcm5hbCByZXR1cm5zICh1aW50KSB7IHJldHVybiAyOyB9CgogICAgLy8gRnVuY3Rpb24gdmlzaWJpbGl0eSBub3QgcHJvdmlkZWQsIG5vdCBhbiBlcnJvci4KICAgIC8vIEZ1bmN0aW9uIG11dGFiaWxpdHkgbm90IHByb3ZpZGVkLCBub3QgYW4gZXJyb3IuCiAgICBmdW5jdGlvbiBmKHVpbnQgeCkgcmV0dXJucyAoYnl0ZXMpIHsKICAgICAgICAvLyBWYXIgaXMgZmluZSBpbiB0aGlzIHZlcnNpb24uCiAgICAgICAgdmFyIHogPSBzb21lSW50ZWdlcigpOwogICAgICAgIHggKz0gejsKICAgICAgICAvLyBUaHJvdyBpcyBmaW5lIGluIHRoaXMgdmVyc2lvbi4KICAgICAgICBpZiAoeCA+IDEwMCkKICAgICAgICAgICAgdGhyb3c7CiAgICAgICAgYnl0ZXMgbWVtb3J5IGIgPSBuZXcgYnl0ZXMoeCk7CiAgICAgICAgeSA9IC0zID4+IDE7CiAgICAgICAgLy8geSA9PSAtMSAod3JvbmcsIHNob3VsZCBiZSAtMikKICAgICAgICBkbyB7CiAgICAgICAgICAgIHggKz0gMTsKICAgICAgICAgICAgaWYgKHggPiAxMCkgY29udGludWU7CiAgICAgICAgICAgIC8vICdDb250aW51ZScgY2F1c2VzIGFuIGluZmluaXRlIGxvb3AuCiAgICAgICAgfSB3aGlsZSAoeCA8IDExKTsKICAgICAgICAvLyBDYWxsIHJldHVybnMgb25seSBhIEJvb2wuCiAgICAgICAgYm9vbCBzdWNjZXNzID0gYWRkcmVzcyhvdGhlcikuY2FsbCgiZiIpOwogICAgICAgIGlmICghc3VjY2VzcykKICAgICAgICAgICAgcmV2ZXJ0KCk7CiAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIC8vIExvY2FsIHZhcmlhYmxlcyBjb3VsZCBiZSBkZWNsYXJlZCBhZnRlciB0aGVpciB1c2UuCiAgICAgICAgICAgIGludCB5OwogICAgICAgIH0KICAgICAgICByZXR1cm4gYjsKICAgIH0KCiAgICAvLyBObyBuZWVkIGZvciBhbiBleHBsaWNpdCBkYXRhIGxvY2F0aW9uIGZvciAnYXJyJwogICAgZnVuY3Rpb24gZyh1aW50W10gYXJyLCBieXRlczggeCwgT3RoZXJDb250cmFjdCBvdGhlckNvbnRyYWN0KSBwdWJsaWMgewogICAgICAgIG90aGVyQ29udHJhY3QudHJhbnNmZXIoMSBldGhlcik7CgogICAgICAgIC8vIFNpbmNlIHVpbnQzMiAoNCBieXRlcykgaXMgc21hbGxlciB0aGFuIGJ5dGVzOCAoOCBieXRlcyksCiAgICAgICAgLy8gdGhlIGZpcnN0IDQgYnl0ZXMgb2YgeCB3aWxsIGJlIGxvc3QuIFRoaXMgbWlnaHQgbGVhZCB0bwogICAgICAgIC8vIHVuZXhwZWN0ZWQgYmVoYXZpb3Igc2luY2UgYnl0ZXNYIGFyZSByaWdodCBwYWRkZWQuCiAgICAgICAgdWludDMyIHkgPSB1aW50MzIoeCk7CiAgICAgICAgbXlOdW1iZXIgKz0geSArIG1zZy52YWx1ZTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.4.25;
// This will not compile after 0.5.0
contract OtherContract {
 uint x;
 function f(uint y) external {
 x \= y;
 }
 function() payable external {}
}
contract Old {
 OtherContract other;
 uint myNumber;
 // Function mutability not provided, not an error.
 function someInteger() internal returns (uint) { return 2; }
 // Function visibility not provided, not an error.
 // Function mutability not provided, not an error.
 function f(uint x) returns (bytes) {
 // Var is fine in this version.
 var z \= someInteger();
 x += z;
 // Throw is fine in this version.
 if (x \> 100)
 throw;
 bytes memory b \= new bytes(x);
 y \= \-3 \>> 1;
 // y == -1 (wrong, should be -2)
 do {
 x += 1;
 if (x \> 10) continue;
 // 'Continue' causes an infinite loop.
 } while (x < 11);
 // Call returns only a Bool.
 bool success \= address(other).call("f");
 if (!success)
 revert();
 else {
 // Local variables could be declared after their use.
 int y;
 }
 return b;
 }
 // No need for an explicit data location for 'arr'
 function g(uint\[\] arr, bytes8 x, OtherContract otherContract) public {
 otherContract.transfer(1 ether);
 // Since uint32 (4 bytes) is smaller than bytes8 (8 bytes),
 // the first 4 bytes of x will be lost. This might lead to
 // unexpected behavior since bytesX are right padded.
 uint32 y \= uint32(x);
 myNumber += y + msg.value;
 }
}
New version:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjUuMDsKLy8gVGhpcyB3aWxsIG5vdCBjb21waWxlIGFmdGVyIDAuNi4wCgpjb250cmFjdCBPdGhlckNvbnRyYWN0IHsKICAgIHVpbnQgeDsKICAgIGZ1bmN0aW9uIGYodWludCB5KSBleHRlcm5hbCB7CiAgICAgICAgeCA9IHk7CiAgICB9CiAgICBmdW5jdGlvbigpIHBheWFibGUgZXh0ZXJuYWwge30KfQoKY29udHJhY3QgTmV3IHsKICAgIE90aGVyQ29udHJhY3Qgb3RoZXI7CiAgICB1aW50IG15TnVtYmVyOwoKICAgIC8vIEZ1bmN0aW9uIG11dGFiaWxpdHkgbXVzdCBiZSBzcGVjaWZpZWQuCiAgICBmdW5jdGlvbiBzb21lSW50ZWdlcigpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludCkgeyByZXR1cm4gMjsgfQoKICAgIC8vIEZ1bmN0aW9uIHZpc2liaWxpdHkgbXVzdCBiZSBzcGVjaWZpZWQuCiAgICAvLyBGdW5jdGlvbiBtdXRhYmlsaXR5IG11c3QgYmUgc3BlY2lmaWVkLgogICAgZnVuY3Rpb24gZih1aW50IHgpIHB1YmxpYyByZXR1cm5zIChieXRlcyBtZW1vcnkpIHsKICAgICAgICAvLyBUaGUgdHlwZSBtdXN0IG5vdyBiZSBleHBsaWNpdGx5IGdpdmVuLgogICAgICAgIHVpbnQgeiA9IHNvbWVJbnRlZ2VyKCk7CiAgICAgICAgeCArPSB6OwogICAgICAgIC8vIFRocm93IGlzIG5vdyBkaXNhbGxvd2VkLgogICAgICAgIHJlcXVpcmUoeCA8PSAxMDApOwogICAgICAgIGludCB5ID0gLTMgPj4gMTsKICAgICAgICByZXF1aXJlKHkgPT0gLTIpOwogICAgICAgIGRvIHsKICAgICAgICAgICAgeCArPSAxOwogICAgICAgICAgICBpZiAoeCA+IDEwKSBjb250aW51ZTsKICAgICAgICAgICAgLy8gJ0NvbnRpbnVlJyBqdW1wcyB0byB0aGUgY29uZGl0aW9uIGJlbG93LgogICAgICAgIH0gd2hpbGUgKHggPCAxMSk7CgogICAgICAgIC8vIENhbGwgcmV0dXJucyAoYm9vbCwgYnl0ZXMpLgogICAgICAgIC8vIERhdGEgbG9jYXRpb24gbXVzdCBiZSBzcGVjaWZpZWQuCiAgICAgICAgKGJvb2wgc3VjY2VzcywgYnl0ZXMgbWVtb3J5IGRhdGEpID0gYWRkcmVzcyhvdGhlcikuY2FsbCgiZiIpOwogICAgICAgIGlmICghc3VjY2VzcykKICAgICAgICAgICAgcmV2ZXJ0KCk7CiAgICAgICAgcmV0dXJuIGRhdGE7CiAgICB9CgogICAgdXNpbmcgQWRkcmVzc01ha2VQYXlhYmxlIGZvciBhZGRyZXNzOwogICAgLy8gRGF0YSBsb2NhdGlvbiBmb3IgJ2FycicgbXVzdCBiZSBzcGVjaWZpZWQKICAgIGZ1bmN0aW9uIGcodWludFtdIG1lbW9yeSAvKiBhcnIgKi8sIGJ5dGVzOCB4LCBPdGhlckNvbnRyYWN0IG90aGVyQ29udHJhY3QsIGFkZHJlc3MgdW5rbm93bkNvbnRyYWN0KSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgLy8gJ290aGVyQ29udHJhY3QudHJhbnNmZXInIGlzIG5vdCBwcm92aWRlZC4KICAgICAgICAvLyBTaW5jZSB0aGUgY29kZSBvZiAnT3RoZXJDb250cmFjdCcgaXMga25vd24gYW5kIGhhcyB0aGUgZmFsbGJhY2sKICAgICAgICAvLyBmdW5jdGlvbiwgYWRkcmVzcyhvdGhlckNvbnRyYWN0KSBoYXMgdHlwZSAnYWRkcmVzcyBwYXlhYmxlJy4KICAgICAgICBhZGRyZXNzKG90aGVyQ29udHJhY3QpLnRyYW5zZmVyKDEgZXRoZXIpOwoKICAgICAgICAvLyAndW5rbm93bkNvbnRyYWN0LnRyYW5zZmVyJyBpcyBub3QgcHJvdmlkZWQuCiAgICAgICAgLy8gJ2FkZHJlc3ModW5rbm93bkNvbnRyYWN0KS50cmFuc2ZlcicgaXMgbm90IHByb3ZpZGVkCiAgICAgICAgLy8gc2luY2UgJ2FkZHJlc3ModW5rbm93bkNvbnRyYWN0KScgaXMgbm90ICdhZGRyZXNzIHBheWFibGUnLgogICAgICAgIC8vIElmIHRoZSBmdW5jdGlvbiB0YWtlcyBhbiAnYWRkcmVzcycgd2hpY2ggeW91IHdhbnQgdG8gc2VuZAogICAgICAgIC8vIGZ1bmRzIHRvLCB5b3UgY2FuIGNvbnZlcnQgaXQgdG8gJ2FkZHJlc3MgcGF5YWJsZScgdmlhICd1aW50MTYwJy4KICAgICAgICAvLyBOb3RlOiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZCBhbmQgdGhlIGV4cGxpY2l0IHR5cGUKICAgICAgICAvLyAnYWRkcmVzcyBwYXlhYmxlJyBzaG91bGQgYmUgdXNlZCB3aGVuZXZlciBwb3NzaWJsZS4KICAgICAgICAvLyBUbyBpbmNyZWFzZSBjbGFyaXR5LCB3ZSBzdWdnZXN0IHRoZSB1c2Ugb2YgYSBsaWJyYXJ5IGZvcgogICAgICAgIC8vIHRoZSBjb252ZXJzaW9uIChwcm92aWRlZCBhZnRlciB0aGUgY29udHJhY3QgaW4gdGhpcyBleGFtcGxlKS4KICAgICAgICBhZGRyZXNzIHBheWFibGUgYWRkciA9IHVua25vd25Db250cmFjdC5tYWtlUGF5YWJsZSgpOwogICAgICAgIHJlcXVpcmUoYWRkci5zZW5kKDEgZXRoZXIpKTsKCiAgICAgICAgLy8gU2luY2UgdWludDMyICg0IGJ5dGVzKSBpcyBzbWFsbGVyIHRoYW4gYnl0ZXM4ICg4IGJ5dGVzKSwKICAgICAgICAvLyB0aGUgY29udmVyc2lvbiBpcyBub3QgYWxsb3dlZC4KICAgICAgICAvLyBXZSBuZWVkIHRvIGNvbnZlcnQgdG8gYSBjb21tb24gc2l6ZSBmaXJzdDoKICAgICAgICBieXRlczQgeDQgPSBieXRlczQoeCk7IC8vIFBhZGRpbmcgaGFwcGVucyBvbiB0aGUgcmlnaHQKICAgICAgICB1aW50MzIgeSA9IHVpbnQzMih4NCk7IC8vIENvbnZlcnNpb24gaXMgY29uc2lzdGVudAogICAgICAgIC8vICdtc2cudmFsdWUnIGNhbm5vdCBiZSB1c2VkIGluIGEgJ25vbi1wYXlhYmxlJyBmdW5jdGlvbi4KICAgICAgICAvLyBXZSBuZWVkIHRvIG1ha2UgdGhlIGZ1bmN0aW9uIHBheWFibGUKICAgICAgICBteU51bWJlciArPSB5ICsgbXNnLnZhbHVlOwogICAgfQp9CgovLyBXZSBjYW4gZGVmaW5lIGEgbGlicmFyeSBmb3IgZXhwbGljaXRseSBjb252ZXJ0aW5nIGBgYWRkcmVzc2BgCi8vIHRvIGBgYWRkcmVzcyBwYXlhYmxlYGAgYXMgYSB3b3JrYXJvdW5kLgpsaWJyYXJ5IEFkZHJlc3NNYWtlUGF5YWJsZSB7CiAgICBmdW5jdGlvbiBtYWtlUGF5YWJsZShhZGRyZXNzIHgpIGludGVybmFsIHB1cmUgcmV0dXJucyAoYWRkcmVzcyBwYXlhYmxlKSB7CiAgICAgICAgcmV0dXJuIGFkZHJlc3ModWludDE2MCh4KSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.5.0;
// This will not compile after 0.6.0
contract OtherContract {
 uint x;
 function f(uint y) external {
 x \= y;
 }
 function() payable external {}
}
contract New {
 OtherContract other;
 uint myNumber;
 // Function mutability must be specified.
 function someInteger() internal pure returns (uint) { return 2; }
 // Function visibility must be specified.
 // Function mutability must be specified.
 function f(uint x) public returns (bytes memory) {
 // The type must now be explicitly given.
 uint z \= someInteger();
 x += z;
 // Throw is now disallowed.
 require(x <= 100);
 int y \= \-3 \>> 1;
 require(y \== \-2);
 do {
 x += 1;
 if (x \> 10) continue;
 // 'Continue' jumps to the condition below.
 } while (x < 11);
 // Call returns (bool, bytes).
 // Data location must be specified.
 (bool success, bytes memory data) \= address(other).call("f");
 if (!success)
 revert();
 return data;
 }
 using AddressMakePayable for address;
 // Data location for 'arr' must be specified
 function g(uint\[\] memory /\* arr \*/, bytes8 x, OtherContract otherContract, address unknownContract) public payable {
 // 'otherContract.transfer' is not provided.
 // Since the code of 'OtherContract' is known and has the fallback
 // function, address(otherContract) has type 'address payable'.
 address(otherContract).transfer(1 ether);
 // 'unknownContract.transfer' is not provided.
 // 'address(unknownContract).transfer' is not provided
 // since 'address(unknownContract)' is not 'address payable'.
 // If the function takes an 'address' which you want to send
 // funds to, you can convert it to 'address payable' via 'uint160'.
 // Note: This is not recommended and the explicit type
 // 'address payable' should be used whenever possible.
 // To increase clarity, we suggest the use of a library for
 // the conversion (provided after the contract in this example).
 address payable addr \= unknownContract.makePayable();
 require(addr.send(1 ether));
 // Since uint32 (4 bytes) is smaller than bytes8 (8 bytes),
 // the conversion is not allowed.
 // We need to convert to a common size first:
 bytes4 x4 \= bytes4(x); // Padding happens on the right
 uint32 y \= uint32(x4); // Conversion is consistent
 // 'msg.value' cannot be used in a 'non-payable' function.
 // We need to make the function payable
 myNumber += y + msg.value;
 }
}
// We can define a library for explicitly converting \`\`address\`\`
// to \`\`address payable\`\` as a workaround.
library AddressMakePayable {
 function makePayable(address x) internal pure returns (address payable) {
 return address(uint160(x));
 }
}

# [Inline Assembly — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/assembly.html) 
 _https://docs.soliditylang.org/tr/latest/assembly.html_

Inline assembly ile Solidity ifadelerini Ethereum Sanal Makine’sinin dillerinden birine yakın dile çevirebilirsiniz. Bu size özellikle dili kütüphaneler yazarak geliştiriyorsanız daha detaylı bir kontrol sağlar.
Inline assembly için kullanılan Solidity diline [Yul](https://docs.soliditylang.org/tr/latest/yul.html#yul) deniyor ve dosyalarını kendi bölümünde bulabilirsiniz. BU bölüm sadece inline assembly kodunun etrafındaki Solidity kodları ile nasıl bağlandığını anlatacak.
Uyarı
Inline assembly Ethereum Sanal Makinesi’ne düşük seviyede erişişmin bir yoludur. Bu, Solidity’nin birçok güvenlik özelliklerini ve kontrollerini yok sayar. Yani inline assembly’i sadece gereken yerlerde ve nasıl kullanacağınızdan eminseniz kullanmalısınız.
Bir inline assembly bloğu `assembly { ... }` ile işaretlidir. Süslü parantez içerisindeki kod [Yul](https://docs.soliditylang.org/tr/latest/yul.html#yul) dili içerisinde yer alır.
Bir inline assembly kodu yerel Solidity değişkenlerine aşağıda açıklandığı gibi erişebilir.
Farklı inline assembly blokları aynı yer adlarını paylaşmazlar. Yani farklı bir inline assembly bloğunda tanımlanmış olan bir Yul fonksiyonunu çağırmak ya da bir Yul değişkenine erişmek mümkün değldir.
## Örnek[](#ornek "Permalink to this heading")
Aşağıdaki örnek başka bir kontrat üzerindeki koda erişimi ve bir `bytes` değişkenine atımını sağlayan kütüphane kodunu verir. Bu “düz Solidity” ile de `<address>.code` kullanarak mümkündür ama buradaki amaç tekrar kullanılabilir assembly kütüphanelerinin bir derleyici(compiler) değişimi olmadan Solidity dilini geliştirebildiğini göstermektir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmxpYnJhcnkgR2V0Q29kZSB7CiAgICBmdW5jdGlvbiBhdChhZGRyZXNzIGFkZHIpIHB1YmxpYyB2aWV3IHJldHVybnMgKGJ5dGVzIG1lbW9yeSBjb2RlKSB7CiAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICAvLyBrb2R1biBib3l1dHVudSBkw7ZuZMO8csO8ciwgYnVyYXPEsSBpw6dpbiBhc3NlbWJseSBrdWxsYW7EsWxtYWzEsQogICAgICAgICAgICBsZXQgc2l6ZSA6PSBleHRjb2Rlc2l6ZShhZGRyKQogICAgICAgICAgICAvLyDDp8Sxa8SxxZ8gYml0IGFycmF5J2luaSBhbGxvY2F0ZSgpIGVkZXIKICAgICAgICAgICAgLy8gYnVyYXPEsSBhc3NlbWJseSBrdWxsYW5tYWRhbiwKICAgICAgICAgICAgLy8gY29kZSA9IG5ldyBieXRlcyhzaXplKSBrdWxsYW5hcmFrIGRhIHlhcMSxbGFiaWxpci4KICAgICAgICAgICAgY29kZSA6PSBtbG9hZCgweDQwKQogICAgICAgICAgICAvLyBwYWRkaW5nJ2kgacOnZXJlbiB5ZW5pICJtZW1vcnkgZW5kIgogICAgICAgICAgICBtc3RvcmUoMHg0MCwgYWRkKGNvZGUsIGFuZChhZGQoYWRkKHNpemUsIDB4MjApLCAweDFmKSwgbm90KDB4MWYpKSkpCiAgICAgICAgICAgIC8vIHV6dW5sdcSfdSBoYWbEsXphZGEgc2FrbGF5xLFuCiAgICAgICAgICAgIG1zdG9yZShjb2RlLCBzaXplKQogICAgICAgICAgICAvLyBrb2R1biDFn3UgYW5raSBoYWxpbmkgZMO2bmTDvHLDvHIsIGJ1cmFzxLEgacOnaW4gYXNzZW1ibHkga3VsbGFuxLFsbWFsxLEKICAgICAgICAgICAgZXh0Y29kZWNvcHkoYWRkciwgYWRkKGNvZGUsIDB4MjApLCAwLCBzaXplKQogICAgICAgIH0KICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
library GetCode {
 function at(address addr) public view returns (bytes memory code) {
 assembly {
 // kodun boyutunu döndürür, burası için assembly kullanılmalı
 let size := extcodesize(addr)
 // çıkış bit array'ini allocate() eder
 // burası assembly kullanmadan,
 // code = new bytes(size) kullanarak da yapılabilir.
 code := mload(0x40)
 // padding'i içeren yeni "memory end"
 mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f))))
 // uzunluğu hafızada saklayın
 mstore(code, size)
 // kodun şu anki halini döndürür, burası için assembly kullanılmalı
 extcodecopy(addr, add(code, 0x20), 0, size)
 }
 }
}
Inline assembly optimizer verimli kodlar üretemediği zamanlarda da yararlıdır, örneğin:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCgpsaWJyYXJ5IFZlY3RvclN1bSB7CiAgICAvLyBCdSBmb25rc2l5b24gxZ91IGFuZGEgdmVyaW1saSBkZcSfaWwKICAgIC8vIMOnw7xua8O8IG9wdGltaXplciBhcnJheSBzxLFuxLFyIGVyacWfaW0ga29udHJvbMO8bsO8IHlhcGFya2VuIGhhdGEgdmVyaXlvcgogICAgZnVuY3Rpb24gc3VtU29saWRpdHkodWludFtdIG1lbW9yeSBkYXRhKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IHN1bSkgewogICAgICAgIGZvciAodWludCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpCiAgICAgICAgICAgIHN1bSArPSBkYXRhW2ldOwogICAgfQoKICAgIC8vIEFycmF5J2Ugc2FkZWNlIHPEsW7EsXJsYXLEsSBpw6dlcmlzaW5kZSBlcmnFn2ViaWxlY2XEn2ltaXppIGJpbGl5b3J1eiwgeWFuaSBidSBrb250cm9sw7wgYXRsYXlhYmlsaXJpei4KICAgIC8vIDB4MjAnbmluIGFycmF5J2UgZWtsZW5tZXNpIGdlcmVraXlvciDDp8O8bmvDvCBhcnJheSdpbiBpbGsgc2xvdHUgYXJyYXkgdXp1bmx1xJ91bnUgacOnZXJpci4KICAgIGZ1bmN0aW9uIHN1bUFzbSh1aW50W10gbWVtb3J5IGRhdGEpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQgc3VtKSB7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkgewogICAgICAgICAgICBhc3NlbWJseSB7CiAgICAgICAgICAgICAgICBzdW0gOj0gYWRkKHN1bSwgbWxvYWQoYWRkKGFkZChkYXRhLCAweDIwKSwgbXVsKGksIDB4MjApKSkpCiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9CiAgICAvLyBZdWthcsSxZGFraSBnaWJpIGFtYSB0w7xtIGtvZHUgaW5saW5lIGFzc2VtYmx5IGt1bGxhbmFyYWsgdGFtYW1sYXnEsW4uCiAgICBmdW5jdGlvbiBzdW1QdXJlQXNtKHVpbnRbXSBtZW1vcnkgZGF0YSkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCBzdW0pIHsKICAgICAgICBhc3NlbWJseSB7CiAgICAgICAgICAgIC8vIHV6dW5sdcSfdSB5w7xrbGV5aW4gKMO2bmNlIDMyIGJ5dGUpCiAgICAgICAgICAgIGxldCBsZW4gOj0gbWxvYWQoZGF0YSkKCiAgICAgICAgICAgIC8vIFV6dW5sdWsgYWxhbsSxbsSxIGF0bGF5xLFuLgogICAgICAgICAgICAvLwogICAgICAgICAgICAvLyBHZcOnaWNpIGJpciBkZcSfacWfa2VuIHR1dHVuLCBiw7Z5bGVjZSB5ZXIgZGXEn2nFn3Rpa8OnZSBvbnUgZGEgYXJ0dMSxcmFiaWxpcnNpbml6LgogICAgICAgICAgICAvLwogICAgICAgICAgICAvLyBOT1Q6IEJ1IGFzc2VtYmx5IGJsb2t0YW4gc29ucmEgYXJ0dMSxcsSxbGFuIHZlcmkga3VsbGFuxLFsYW1heWFjYWsgYmlyIGRlxJ9pxZ9rZW5lIGTDtm7DvMWfZWNlawoKICAgICAgICAgICAgbGV0IGRhdGFFbGVtZW50TG9jYXRpb24gOj0gYWRkKGRhdGEsIDB4MjApCgogICAgICAgICAgICAvLyBTxLFuxLFyYSB1bGHFn2FuYSBrYWRhciB0ZWtyYXJsYXnEsW4uCiAgICAgICAgICAgIGZvcgogICAgICAgICAgICAgICAgeyBsZXQgZW5kIDo9IGFkZChkYXRhRWxlbWVudExvY2F0aW9uLCBtdWwobGVuLCAweDIwKSkgfQogICAgICAgICAgICAgICAgbHQoZGF0YUVsZW1lbnRMb2NhdGlvbiwgZW5kKQogICAgICAgICAgICAgICAgeyBkYXRhRWxlbWVudExvY2F0aW9uIDo9IGFkZChkYXRhRWxlbWVudExvY2F0aW9uLCAweDIwKSB9CiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHN1bSA6PSBhZGQoc3VtLCBtbG9hZChkYXRhRWxlbWVudExvY2F0aW9uKSkKICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
library VectorSum {
 // Bu fonksiyon şu anda verimli değil
 // çünkü optimizer array sınır erişim kontrolünü yaparken hata veriyor
 function sumSolidity(uint\[\] memory data) public pure returns (uint sum) {
 for (uint i \= 0; i < data.length; ++i)
 sum += data\[i\];
 }
 // Array'e sadece sınırları içerisinde erişebileceğimizi biliyoruz, yani bu kontrolü atlayabiliriz.
 // 0x20'nin array'e eklenmesi gerekiyor çünkü array'in ilk slotu array uzunluğunu içerir.
 function sumAsm(uint\[\] memory data) public pure returns (uint sum) {
 for (uint i \= 0; i < data.length; ++i) {
 assembly {
 sum := add(sum, mload(add(add(data, 0x20), mul(i, 0x20))))
 }
 }
 }
 // Yukarıdaki gibi ama tüm kodu inline assembly kullanarak tamamlayın.
 function sumPureAsm(uint\[\] memory data) public pure returns (uint sum) {
 assembly {
 // uzunluğu yükleyin (önce 32 byte)
 let len := mload(data)
 // Uzunluk alanını atlayın.
 //
 // Geçici bir değişken tutun, böylece yer değiştikçe onu da arttırabilirsiniz.
 //
 // NOT: Bu assembly bloktan sonra arttırılan veri kullanılamayacak bir değişkene dönüşecek
 let dataElementLocation := add(data, 0x20)
 // Sınıra ulaşana kadar tekrarlayın.
 for
 { let end := add(dataElementLocation, mul(len, 0x20)) }
 lt(dataElementLocation, end)
 { dataElementLocation := add(dataElementLocation, 0x20) }
 {
 sum := add(sum, mload(dataElementLocation))
 }
 }
 }
}
## Dış(External) değişkenlere, fonksiyonlara ve kütüphanelere erişim[](#dis-external-degiskenlere-fonksiyonlara-ve-kutuphanelere-erisim "Permalink to this heading")
Solidity değişkenlerine ve diğer tanımlayıcılara isimlerini kullanarak erişebilirsiniz.
Bir değer tipinin yerel değişkenleri inline assembly içinde kullanılabilir durumdadır. Bu yerel değişkenler okunabilir de atanabilir de.
Belleği kasteden yerel değişkenler değerin kendisini değil, değerin bellekteki adresini işaret eder. Bu değişkenler aynı zamanda değiştirilebilir de ancak bu sadece bir pointer değişimi olur, veri değişimi olmaz. Bu sebeple Solidity’nin hafıza yönetimini yapmak sizin yükümlülüğünüzdedir. Bkz [Solidity’de Konvansiyonlar](#conventions-in-solidity)
Benzer şekilde, statik boyutlandırılmış calldata array’leri ya da struct’ları gösteren yerel değişkenler de değerin adresini işaret eder, değerini değil. Bu değişken yeni bir offset’e de atanabilir fakat değişkenin `calldatasize()` çalıştırılması dışında bir yeri işaret edebileceğinin hiçbir garantisi yoktur.
Dış(External) fonksiyon pointer’ları için adres ve fonksiyon seçiyiye `x.address` ve `x.selector` ile erişilebilir. Seçici dört adet right-aligned bitten oluşur. İki değer de atanbilir. Örneğin:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjEwIDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgLy8gQGZ1biBkZcSfZXJpbmkgZMO2bm1layBpw6dpbiB5ZW5pIGJpciBzZcOnaWNpIGRlIGFkcmVzIGF0YXnEsW4KICAgIGZ1bmN0aW9uIGNvbWJpbmVUb0Z1bmN0aW9uUG9pbnRlcihhZGRyZXNzIG5ld0FkZHJlc3MsIHVpbnQgbmV3U2VsZWN0b3IpIHB1YmxpYyBwdXJlIHJldHVybnMgKGZ1bmN0aW9uKCkgZXh0ZXJuYWwgZnVuKSB7CiAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICBmdW4uc2VsZWN0b3IgOj0gbmV3U2VsZWN0b3IKICAgICAgICAgICAgZnVuLmFkZHJlc3MgIDo9IG5ld0FkZHJlc3MKICAgICAgICB9CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.10 <0.9.0;
contract C {
 // @fun değerini dönmek için yeni bir seçici de adres atayın
 function combineToFunctionPointer(address newAddress, uint newSelector) public pure returns (function() external fun) {
 assembly {
 fun.selector := newSelector
 fun.address := newAddress
 }
 }
}
Dinamik calldata array’leri üzerinde, `x.offset` ve `x.length` kullanarak -bit halinde- calldata offset’ine ve uzunluğuna erişebilirsiniz. Her iki ifade aynı zamanda atanabilir de ama statik bir durum için dönecekleri sonucun `calldatasize()` sınırları içerisinde olacağının bir garantisi yoktur.
Yerel depolama değişkenleri ya da durum değişkenleri için tek bir Yul tanımlayıcısı yeterli değildir. Çünkü bu değişkenler her zaman tam bir depolama alanı kaplamazlar. Bu sebeple onların ‘adresleri’ bir slottan ve o slot içerisindeki bir byte-offset’ten oluşur. `x` değişkeni tarafından işaret edilen slotu çağırmak için `x.slot` , byte-offset’i çağırmak için ise `x.offset` kullanılır. Sadece `x` kullanmak ise hata verecektir.
Bir yerel depolama değişkeninin pointer’ının `.slot` kısmına atama yapılabilir. Bu değişkenler(struct, array, mapping) için `.offset` kısmı ise her zaman sıfırdır. Fakat bir durum değişkeninin `.slot` ve `.offset` kısmına atama yapmak ise mümkün değildir.
Yerel Solidity değişkenleri görevler için hazırdır. Örneğin:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50IGI7CiAgICBmdW5jdGlvbiBmKHVpbnQgeCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCByKSB7CiAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICAvLyBCdSBzZW5hcnlvZGEgZGVwb2xhbWEgc2xvdHVudW4gb2Zmc2V0J2luaSBkZcSfZWxlbmRpcm1peW9ydXouCiAgICAgICAgICAgIC8vIMOHw7xua8O8IHPEsWbEsXIgb2xkdcSfdW51IGJpbGl5b3J1ei4KICAgICAgICAgICAgciA6PSBtdWwoeCwgc2xvYWQoYi5zbG90KSkKICAgICAgICB9CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract C {
 uint b;
 function f(uint x) public view returns (uint r) {
 assembly {
 // Bu senaryoda depolama slotunun offset'ini değelendirmiyoruz.
 // Çünkü sıfır olduğunu biliyoruz.
 r := mul(x, sload(b.slot))
 }
 }
}
Uyarı
Eğer `uint64`, `address` veya `bytes16` gibi 256 bitten daha az yer kaplayan bir değişkene erişmeye çalışıyorsanız bu tipin parçası olmayan bitler hakkında bir varsayımda bulunmayın. Özellikle de o bitleri sıfır kabul etmeyin. Her ihtimale karşı, `uint32 x = f(); assembly { x := and(x, 0xffffffff) /* now use x */ }` parçasının önemli olduğu yerlerde düzgün bir şekilde bu verileri temizleyin. Signed tipleri temizlemek için `signextend` kullanabilirsiniz. opcode: `assembly { signextend(<num_bytes_of_x_minus_one>, x) }`
Solidity 0.6.0’dan beri bir inline assembly değişkeninin ismi inline assembly bloğundaki kullanımını karşılamayabilir. (değişken, kontrat ve fonkisyon kullanımları dahil)
Soldity 0.7.0’dan beri inline assembly bloğunun içinde kullanılan değişken ve fonksiyonlar `.` içermeyebilir. Fakat `.` kullanmak inline assembly bloğu dışındaki Solidity değişkenlerine ulaşmak için etkilidir.
## Kaçınılacak Şeyler[](#kacinilacak-seyler "Permalink to this heading")
Inline assembly high-level gözükebilir fakat aslında aşırı derecede low-level’dır. Fonksiyon çağrıları, döngüler, if’ler ve switch’ler basit tekrar yazım kuralları ile çevrilir ve bundan sonra assembler’ın tek yaptığı iş blok sonuna erişildiğinde functional-style opcode’ları tekar ayarlamak, değişken erişimi için stack boyutunu saymak ve assembly içerisindeki değişkenleri için stack slotlarını kaldırmaktır.
## Solidity kuralları[](#solidity-kurallari "Permalink to this heading")
### Typed Değişkenlerin Değerleri[](#typed-degiskenlerin-degerleri "Permalink to this heading")
EVM assembly’nin aksine, Solidity 256 bitten daha küçük tiplere sahiptir (ör: `uint24`). Verimlilik için çoğu aritmetik işlem bazı tiplerin 256 bitten küçük olabileceğini yok sayar ve higher-order bitler gerekliyse (hafızaya yazılmadan hemen önce ya da herhangi bir karşılaştırma yapılmadan önce) temizlenir. Burası şu yüzden önemlidir: Eğer inline assembly içerisinde böyle bir değişkene erişmek istiyorsanız önce higher-order bitleri kendiniz temizlemeniz gerekebilir.
### Hafıza Yönetimi[](#hafiza-yonetimi "Permalink to this heading")
Solidity Belleği şu şekilde yönetir. Hafızada `0x40` konumunda bir “boş bellek pointer”ı bulunur. Eğer belleğe bir şey atamak isterseniz bu pointer’ın işaret ettiği yerden başlayıp güncelleyin. Bu hafızanın daha önce kullanılmadığına dair herhangi bir kanıt bulunmadığı için tamamen sıfır olduğunu da varsayamazsınız. Belleği boşaltacak ya da rahatlatacak herhangi bir hazır kurulu mekanizma yoktur. Aşağıda belleği yukarıda anlatıldığı şekilde kullanabileceğiniz bir assembly kod parçası bulunuyor:
[open in Remix](https://remix.ethereum.org/?language=yul&version=0.8.15&code=ZnVuY3Rpb24gYWxsb2NhdGUobGVuZ3RoKSAtPiBwb3MgewogIHBvcyA6PSBtbG9hZCgweDQwKQogIG1zdG9yZSgweDQwLCBhZGQocG9zLCBsZW5ndGgpKQp9)
function allocate(length) \-> pos {
 pos := mload(0x40)
 mstore(0x40, add(pos, length))
}
Hafızanın ilk 64 biti kısa dönem hafızası için “geçici alan” olarak kullanılabilir. Boş bellek pointer’ından sonraki 32 bit (yani `0x60` tan başlayan alan) ise kalıcı olarak sıfır olmalıdır ve bu alan boş dinamik bellek array’lerinin temel değeri olarak kullanılır. Bunlar ise demektir ki kullanılabilir hafıza `0x80` den başlar ve bu değer ise boş bellek pointer’ının ilk değeridir. Solidity’deki hafıza array’lerinin tamamı 32 bitin katları olacak şekilde yer kaplar.(Bu kural `bytes1[]` için de geçerlidir fakat `bytes` ve `string` için geçerli değildir.) Çok boyutlu hafıza array’leri ise başka hafıza array’lerine pointer’lardır. Dinamik array’in uzunluğu array’in ilk slotunda saklanır ve diğer slotlara array’in elemanları gelir.
Uyarı
Statik boyutlandırılmış hafıza array’leri herhangi bir uzunluk alanına sahip değildir fakat bu sonradan dinamik ve statik boyutlandırılmış array’ler arasında daha kolay çevrimi sağlamak için eklenmiş olabilir. Yani bu kurala dayanarak ilerlememelisiniz.
### Hafıza Güvenliği[](#hafiza-guvenligi "Permalink to this heading")
Inline assembly kullanmadan; derleyici(compiler), iyi tanımlanmış bir durumda kalmak için her zaman belleğe güvenir. Bu özellikle [Yul IR üzerinden yeni kod oluşturma hattı Yul IR](https://docs.soliditylang.org/tr/latest/ir-breaking-changes.html#ir-breaking-changes) ile ilgilidir. Bu kod parçası yerel değişkenleri stack üzerinden belleğe atarak stack-too-deep hatasından kaçınmayı sağlar ve eğer bazı kesin varsayımlara uyuyorsa ekstra bellek optimizasyonları uygulayabilir.
Biz her ne kadar Solidity’nin kendi bellek modeline saygı gösterilmesini önersek de Inline assembly belleği uyumsuz bir biçimde kullanmanızı sağlar. Bu nedenle stack değişkenlerini belleğe taşımak ve diğer bellek optimizasyonları, bir bellek işlemi içeren ya da Solidity değişkenlerini belleğe atayan tüm inline assembly bloklarında varsayılan olarak devredışı haldedir.
Fakat bir assembly bloğuna aşağıdaki şekilde özel olarak ek açıklamalar ekleyerek Solidity’nin bellek modeline uyduğunu belirtebilirsiniz:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=YXNzZW1ibHkgKCJtZW1vcnktc2FmZSIpIHsKICAgIC4uLgp9)
assembly ("memory-safe") {
 ...
}
Bellek açısından güvenli bir assembly bloğu sadece aşağıdaki bellek bölümlerine erişebilir: - Sizin tarafınızdan yukarıda anlatıldığı gibi `allocate` benzeri bir mekanizma kullanarak atanmış bir bellek. - Solidity tarafından atanmış bellek, yani sizin referans verdiğiniz bellek array’inin sınırları içerisinde kalan alan. - Yukarıda bahsedilen 0 ile 64 bellek offset’leri arasında kalan geçici alan. - Assembly bloğunun başındaki boş bellek pointer’ının değerinden _sonra_ konumlanmış geçici bellek, yani boş bellek pointer’ının güncellememiş hali için ayrılan bellek alanı.
Bunlara ek olarak, eğer bir assembly bloğu bellekteki bir Solidity değişkenine atanırsa bu erişimin yukarıda belirtilen bellek sınırları içerisinde olduğundan emin olmalısınız.
Belirtilen işlemler genellikle optimizer ile ilgili olduğu için assembly bloğu hata verse de verilen kısıtlamalar takip edilmeli. Bir örnek olarak aşağıda verilen assembly kod parçası bellek açısından güvenli değil. Sebebi ise `returndatasize()` fonksiyonunun değeri belirtilen 64 bitlik geçici bellek alanını aşabilir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=YXNzZW1ibHkgewogIHJldHVybmRhdGFjb3B5KDAsIDAsIHJldHVybmRhdGFzaXplKCkpCiAgcmV2ZXJ0KDAsIHJldHVybmRhdGFzaXplKCkpCn0=)
assembly {
 returndatacopy(0, 0, returndatasize())
 revert(0, returndatasize())
}
Fakat aşağıdaki kod ise bellek açısından _güvenli_ dir. Çünkü boş bellek pointer’ının gösterdiği yerden sonrası güvenli bir şekilde geçici alan olarak kullanılabilir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=YXNzZW1ibHkgKCJtZW1vcnktc2FmZSIpIHsKICBsZXQgcCA6PSBtbG9hZCgweDQwKQogIHJldHVybmRhdGFjb3B5KHAsIDAsIHJldHVybmRhdGFzaXplKCkpCiAgcmV2ZXJ0KHAsIHJldHVybmRhdGFzaXplKCkpCn0=)
assembly ("memory-safe") {
 let p := mload(0x40)
 returndatacopy(p, 0, returndatasize())
 revert(p, returndatasize())
}
Unutmayın ki eğer bir atama yoksa boş bellek pointer’ını güncellemenize gerek yoktur ama belleği kullanmaya boş bellek pointer’ının verdiği offset’ten başlayabilirsiniz.
Eğer bellek işlemleri sıfır uzunluğunu kullanıyorsa -geçici alana düşmediği sürece- herhangi bir offset’i de kullanabilirsiniz.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=YXNzZW1ibHkgKCJtZW1vcnktc2FmZSIpIHsKICByZXZlcnQoMCwgMCkKfQ==)
assembly ("memory-safe") {
 revert(0, 0)
}
Unutmayın ki inline assembly içerisindeki bellek işlemleri bellek için güvenli olmadığı gibi bellekte referans tipinde olan Solidity değişkenlerine olan atamalar da bellek için güvenli olmayabilir. Aşağıdaki örnek bellek için güvenli değildir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ynl0ZXMgbWVtb3J5IHg7CmFzc2VtYmx5IHsKICB4IDo9IDB4NDAKfQp4WzB4MjBdID0gMHg0Mjs=)
bytes memory x;
assembly {
 x := 0x40
}
x\[0x20\] \= 0x42;
Belleğe erişim istemeyen işlemlerden oluşan ve bellek üzerindeki Solidity değişkenlerine atama yapmayan inline assembly otomatik olarak bellek için güvenli sayılır ve ekstra olarak belirtilmesine gerek duyulmaz.
Uyarı
Assembly’nin bellek modelini sağladığından emin olmak sizin sorumluluğunuzdadır. Eğer siz bir assembly bloğunu bellek için güvenli olarak tanımlayıp herhangi bir bellek hatası yaparsanız bu **kesinlikle**, doğru olmayan ya da tanımlanmamış bir davranışa sebep olur. Ve bu hata test yaparak kolay bir şekilde bulunamaz.
Eğer Solidity’nin farklı versiyonları ile uyumlu olacak şekilde bir kütüphane oluşturuyorsanız bir assembly bloğunun bellek için güvenli olduğunu özel bir komut ile belirtebilirsiniz:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8vIEBzb2xpZGl0eSBtZW1vcnktc2FmZS1hc3NlbWJseQphc3NlbWJseSB7CiAgICAuLi4KfQ==)
/// @solidity memory-safe-assembly
assembly {
 ...
}
Unutmayın ki yorum satırları ile belirtmeyi gelecek bir sürümde kaldıracağız yani eğer geçmiş derleyici(compiler) sürümleri ile uyum konusunda yeterli bilgiye sahip değilseniz dialect string kullanmayı tercih edin.

# [Types — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/types.html) 
 _https://docs.soliditylang.org/en/v0.8.30/types.html_

Solidity is a statically typed language, which means that the type of each variable (state and local) needs to be specified. Solidity provides several elementary types which can be combined to form complex types.
In addition, types can interact with each other in expressions containing operators. For a quick reference of the various operators, see [Order of Precedence of Operators](#order).
The concept of “undefined” or “null” values does not exist in Solidity, but newly declared variables always have a [default value](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#default-value) dependent on its type. To handle any unexpected values, you should use the [revert function](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#assert-and-require) to revert the whole transaction, or return a tuple with a second `bool` value denoting success.
## Value Types[](#value-types "Link to this heading")
The following are called value types because their variables will always be passed by value, i.e. they are always copied when they are used as function arguments or in assignments.
Unlike [reference types](#reference-types), value type declarations do not specify a data location since they are small enough to be stored on the stack. The only exception is [state variables](https://docs.soliditylang.org/en/v0.8.30/structure-of-a-contract.html#structure-state-variables). Those are by default located in storage, but can also be marked as [transient](https://docs.soliditylang.org/en/v0.8.30/contracts.html#transient-storage), [constant or immutable](https://docs.soliditylang.org/en/v0.8.30/contracts.html#constants).
### Booleans[](#booleans "Link to this heading")
`bool`: The possible values are constants `true` and `false`.
Operators:
* `!` (logical negation)
 
* `&&` (logical conjunction, “and”)
 
* `||` (logical disjunction, “or”)
 
* `==` (equality)
 
* `!=` (inequality)
 
The operators `||` and `&&` apply the common short-circuiting rules. This means that in the expression `f(x) || g(y)`, if `f(x)` evaluates to `true`, `g(y)` will not be evaluated even if it may have side-effects.
### Integers[](#integers "Link to this heading")
`int` / `uint`: Signed and unsigned integers of various sizes. Keywords `uint8` to `uint256` in steps of `8` (unsigned of 8 up to 256 bits) and `int8` to `int256`. `uint` and `int` are aliases for `uint256` and `int256`, respectively.
Operators:
* Comparisons: `<=`, `<`, `==`, `!=`, `>=`, `>` (evaluate to `bool`)
 
* Bit operators: `&`, `|`, `^` (bitwise exclusive or), `~` (bitwise negation)
 
* Shift operators: `<<` (left shift), `>>` (right shift)
 
* Arithmetic operators: `+`, `-`, unary `-` (only for signed integers), `*`, `/`, `%` (modulo), `**` (exponentiation)
 
For an integer type `X`, you can use `type(X).min` and `type(X).max` to access the minimum and maximum value representable by the type.
Warning
Integers in Solidity are restricted to a certain range. For example, with `uint32`, this is `0` up to `2**32 - 1`. There are two modes in which arithmetic is performed on these types: The “wrapping” or “unchecked” mode and the “checked” mode. By default, arithmetic is always “checked”, meaning that if an operation’s result falls outside the value range of the type, the call is reverted through a [failing assertion](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#assert-and-require). You can switch to “unchecked” mode using `unchecked { ... }`. More details can be found in the section about [unchecked](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#unchecked).
#### Comparisons[](#comparisons "Link to this heading")
The value of a comparison is the one obtained by comparing the integer value.
#### Bit operations[](#bit-operations "Link to this heading")
Bit operations are performed on the two’s complement representation of the number. This means that, for example `~int256(0) == int256(-1)`.
#### Shifts[](#shifts "Link to this heading")
The result of a shift operation has the type of the left operand, truncating the result to match the type. The right operand must be of unsigned type, trying to shift by a signed type will produce a compilation error.
Shifts can be “simulated” using multiplication by powers of two in the following way. Note that the truncation to the type of the left operand is always performed at the end, but not mentioned explicitly.
* `x << y` is equivalent to the mathematical expression `x * 2**y`.
 
* `x >> y` is equivalent to the mathematical expression `x / 2**y`, rounded towards negative infinity.
 
Warning
Before version `0.5.0` a right shift `x >> y` for negative `x` was equivalent to the mathematical expression `x / 2**y` rounded towards zero, i.e., right shifts used rounding up (towards zero) instead of rounding down (towards negative infinity).
Note
Overflow checks are never performed for shift operations as they are done for arithmetic operations. Instead, the result is always truncated.
#### Addition, Subtraction and Multiplication[](#addition-subtraction-and-multiplication "Link to this heading")
Addition, subtraction and multiplication have the usual semantics, with two different modes in regard to over- and underflow:
By default, all arithmetic is checked for under- or overflow, but this can be disabled using the [unchecked block](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#unchecked), resulting in wrapping arithmetic. More details can be found in that section.
The expression `-x` is equivalent to `(T(0) - x)` where `T` is the type of `x`. It can only be applied to signed types. The value of `-x` can be positive if `x` is negative. There is another caveat also resulting from two’s complement representation:
If you have `int x = type(int).min;`, then `-x` does not fit the positive range. This means that `unchecked { assert(-x == x); }` works, and the expression `-x` when used in checked mode will result in a failing assertion.
#### Division[](#division "Link to this heading")
Since the type of the result of an operation is always the type of one of the operands, division on integers always results in an integer. In Solidity, division rounds towards zero. This means that `int256(-5) / int256(2) == int256(-2)`.
Note that in contrast, division on [literals](#rational-literals) results in fractional values of arbitrary precision.
Note
Division by zero causes a [Panic error](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#assert-and-require). This check can **not** be disabled through `unchecked { ... }`.
Note
The expression `type(int).min / (-1)` is the only case where division causes an overflow. In checked arithmetic mode, this will cause a failing assertion, while in wrapping mode, the value will be `type(int).min`.
#### Modulo[](#modulo "Link to this heading")
The modulo operation `a % n` yields the remainder `r` after the division of the operand `a` by the operand `n`, where `q = int(a / n)` and `r = a - (n * q)`. This means that modulo results in the same sign as its left operand (or zero) and `a % n == -(-a % n)` holds for negative `a`:
* `int256(5) % int256(2) == int256(1)`
 
* `int256(5) % int256(-2) == int256(1)`
 
* `int256(-5) % int256(2) == int256(-1)`
 
* `int256(-5) % int256(-2) == int256(-1)`
 
Note
Modulo with zero causes a [Panic error](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#assert-and-require). This check can **not** be disabled through `unchecked { ... }`.
#### Exponentiation[](#exponentiation "Link to this heading")
Exponentiation is only available for unsigned types in the exponent. The resulting type of an exponentiation is always equal to the type of the base. Please take care that it is large enough to hold the result and prepare for potential assertion failures or wrapping behavior.
Note
In checked mode, exponentiation only uses the comparatively cheap `exp` opcode for small bases. For the cases of `x**3`, the expression `x*x*x` might be cheaper. In any case, gas cost tests and the use of the optimizer are advisable.
Note
Note that `0**0` is defined by the EVM as `1`.
### Fixed Point Numbers[](#fixed-point-numbers "Link to this heading")
Warning
Fixed point numbers are not fully supported by Solidity yet. They can be declared, but cannot be assigned to or from.
`fixed` / `ufixed`: Signed and unsigned fixed point number of various sizes. Keywords `ufixedMxN` and `fixedMxN`, where `M` represents the number of bits taken by the type and `N` represents how many decimal points are available. `M` must be divisible by 8 and goes from 8 to 256 bits. `N` must be between 0 and 80, inclusive. `ufixed` and `fixed` are aliases for `ufixed128x18` and `fixed128x18`, respectively.
Operators:
* Comparisons: `<=`, `<`, `==`, `!=`, `>=`, `>` (evaluate to `bool`)
 
* Arithmetic operators: `+`, `-`, unary `-`, `*`, `/`, `%` (modulo)
 
Note
The main difference between floating point (`float` and `double` in many languages, more precisely IEEE 754 numbers) and fixed point numbers is that the number of bits used for the integer and the fractional part (the part after the decimal dot) is flexible in the former, while it is strictly defined in the latter. Generally, in floating point almost the entire space is used to represent the number, while only a small number of bits define where the decimal point is.
### Address[](#address "Link to this heading")
The address type comes in two largely identical flavors:
* `address`: Holds a 20 byte value (size of an Ethereum address).
 
* `address payable`: Same as `address`, but with the additional members `transfer` and `send`.
 
The idea behind this distinction is that `address payable` is an address you can send Ether to, while you are not supposed to send Ether to a plain `address`, for example because it might be a smart contract that was not built to accept Ether.
Type conversions:
Implicit conversions from `address payable` to `address` are allowed, whereas conversions from `address` to `address payable` must be explicit via `payable(<address>)`.
Explicit conversions to and from `address` are allowed for `uint160`, integer literals, `bytes20` and contract types.
Only expressions of type `address` and contract type can be converted to the type `address payable` via the explicit conversion `payable(...)`. For contract-type, this conversion is only allowed if the contract can receive Ether, i.e., the contract either has a [receive](https://docs.soliditylang.org/en/v0.8.30/contracts.html#receive-ether-function) or a payable fallback function. Note that `payable(0)` is valid and is an exception to this rule.
Note
If you need a variable of type `address` and plan to send Ether to it, then declare its type as `address payable` to make this requirement visible. Also, try to make this distinction or conversion as early as possible.
The distinction between `address` and `address payable` was introduced in version 0.5.0. Also starting from that version, contracts are not implicitly convertible to the `address` type, but can still be explicitly converted to `address` or to `address payable`, if they have a receive or payable fallback function.
Operators:
* `<=`, `<`, `==`, `!=`, `>=` and `>`
 
Warning
If you convert a type that uses a larger byte size to an `address`, for example `bytes32`, then the `address` is truncated. To reduce conversion ambiguity, starting with version 0.4.24, the compiler will force you to make the truncation explicit in the conversion. Take for example the 32-byte value `0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC`.
You can use `address(uint160(bytes20(b)))`, which results in `0x111122223333444455556666777788889999aAaa`, or you can use `address(uint160(uint256(b)))`, which results in `0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc`.
Note
Mixed-case hexadecimal numbers conforming to [EIP-55](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md) are automatically treated as literals of the `address` type. See [Address Literals](#address-literals).
#### Members of Addresses[](#members-of-addresses "Link to this heading")
For a quick reference of all members of address, see [Members of Address Types](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#address-related).
* `balance` and `transfer`
 
It is possible to query the balance of an address using the property `balance` and to send Ether (in units of wei) to a payable address using the `transfer` function:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=YWRkcmVzcyBwYXlhYmxlIHggPSBwYXlhYmxlKDB4MTIzKTsKYWRkcmVzcyBteUFkZHJlc3MgPSBhZGRyZXNzKHRoaXMpOwppZiAoeC5iYWxhbmNlIDwgMTAgJiYgbXlBZGRyZXNzLmJhbGFuY2UgPj0gMTApIHgudHJhbnNmZXIoMTApOw==)
address payable x \= payable(0x123);
address myAddress \= address(this);
if (x.balance < 10 && myAddress.balance \>= 10) x.transfer(10);
The `transfer` function fails if the balance of the current contract is not large enough or if the Ether transfer is rejected by the receiving account. The `transfer` function reverts on failure.
Note
If `x` is a contract address, its code (more specifically: its [Receive Ether Function](https://docs.soliditylang.org/en/v0.8.30/contracts.html#receive-ether-function), if present, or otherwise its [Fallback Function](https://docs.soliditylang.org/en/v0.8.30/contracts.html#fallback-function), if present) will be executed together with the `transfer` call (this is a feature of the EVM and cannot be prevented). If that execution runs out of gas or fails in any way, the Ether transfer will be reverted and the current contract will stop with an exception.
* `send`
 
`send` is the low-level counterpart of `transfer`. If the execution fails, the current contract will not stop with an exception, but `send` will return `false`.
Warning
There are some dangers in using `send`: The transfer fails if the call stack depth is at 1024 (this can always be forced by the caller) and it also fails if the recipient runs out of gas. So in order to make safe Ether transfers, always check the return value of `send`, use `transfer` or even better: use a pattern where the recipient withdraws the Ether.
* `call`, `delegatecall` and `staticcall`
 
In order to interface with contracts that do not adhere to the ABI, or to get more direct control over the encoding, the functions `call`, `delegatecall` and `staticcall` are provided. They all take a single `bytes memory` parameter and return the success condition (as a `bool`) and the returned data (`bytes memory`). The functions `abi.encode`, `abi.encodePacked`, `abi.encodeWithSelector` and `abi.encodeWithSignature` can be used to encode structured data.
Example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ynl0ZXMgbWVtb3J5IHBheWxvYWQgPSBhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgicmVnaXN0ZXIoc3RyaW5nKSIsICJNeU5hbWUiKTsKKGJvb2wgc3VjY2VzcywgYnl0ZXMgbWVtb3J5IHJldHVybkRhdGEpID0gYWRkcmVzcyhuYW1lUmVnKS5jYWxsKHBheWxvYWQpOwpyZXF1aXJlKHN1Y2Nlc3MpOw==)
bytes memory payload \= abi.encodeWithSignature("register(string)", "MyName");
(bool success, bytes memory returnData) \= address(nameReg).call(payload);
require(success);
Warning
All these functions are low-level functions and should be used with care. Specifically, any unknown contract might be malicious and if you call it, you hand over control to that contract which could in turn call back into your contract, so be prepared for changes to your state variables when the call returns. The regular way to interact with other contracts is to call a function on a contract object (`x.f()`).
Note
Previous versions of Solidity allowed these functions to receive arbitrary arguments and would also handle a first argument of type `bytes4` differently. These edge cases were removed in version 0.5.0.
It is possible to adjust the supplied gas with the `gas` modifier:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse2dhczogMTAwMDAwMH0oYWJpLmVuY29kZVdpdGhTaWduYXR1cmUoInJlZ2lzdGVyKHN0cmluZykiLCAiTXlOYW1lIikpOw==)
address(nameReg).call{gas: 1000000}(abi.encodeWithSignature("register(string)", "MyName"));
Similarly, the supplied Ether value can be controlled too:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse3ZhbHVlOiAxIGV0aGVyfShhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgicmVnaXN0ZXIoc3RyaW5nKSIsICJNeU5hbWUiKSk7)
address(nameReg).call{value: 1 ether}(abi.encodeWithSignature("register(string)", "MyName"));
Lastly, these modifiers can be combined. Their order does not matter:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse2dhczogMTAwMDAwMCwgdmFsdWU6IDEgZXRoZXJ9KGFiaS5lbmNvZGVXaXRoU2lnbmF0dXJlKCJyZWdpc3RlcihzdHJpbmcpIiwgIk15TmFtZSIpKTs=)
address(nameReg).call{gas: 1000000, value: 1 ether}(abi.encodeWithSignature("register(string)", "MyName"));
In a similar way, the function `delegatecall` can be used: the difference is that only the code of the given address is used, all other aspects (storage, balance, …) are taken from the current contract. The purpose of `delegatecall` is to use library code which is stored in another contract. The user has to ensure that the layout of storage in both contracts is suitable for delegatecall to be used.
Note
Prior to homestead, only a limited variant called `callcode` was available that did not provide access to the original `msg.sender` and `msg.value` values. This function was removed in version 0.5.0.
Since byzantium `staticcall` can be used as well. This is basically the same as `call`, but will revert if the called function modifies the state in any way.
All three functions `call`, `delegatecall` and `staticcall` are very low-level functions and should only be used as a _last resort_ as they break the type-safety of Solidity.
The `gas` option is available on all three methods, while the `value` option is only available on `call`.
Note
It is best to avoid relying on hardcoded gas values in your smart contract code, regardless of whether state is read from or written to, as this can have many pitfalls. Also, access to gas might change in the future.
* `code` and `codehash`
 
You can query the deployed code for any smart contract. Use `.code` to get the EVM bytecode as a `bytes memory`, which might be empty. Use `.codehash` to get the Keccak-256 hash of that code (as a `bytes32`). Note that `addr.codehash` is cheaper than using `keccak256(addr.code)`.
Warning
The output of `addr.codehash` may be `0` if the account associated with `addr` is empty or non-existent (i.e., it has no code, zero balance, and zero nonce as defined by [EIP-161](https://eips.ethereum.org/EIPS/eip-161)). If the account has no code but a non-zero balance or nonce, then `addr.codehash` will output the Keccak-256 hash of empty data (i.e., `keccak256("")` which is equal to `c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`), as defined by [EIP-1052](https://eips.ethereum.org/EIPS/eip-1052).
Note
All contracts can be converted to `address` type, so it is possible to query the balance of the current contract using `address(this).balance`.
### Contract Types[](#contract-types "Link to this heading")
Every [contract](https://docs.soliditylang.org/en/v0.8.30/contracts.html#contracts) defines its own type. You can implicitly convert contracts to contracts they inherit from. Contracts can be explicitly converted to and from the `address` type.
Explicit conversion to and from the `address payable` type is only possible if the contract type has a receive or payable fallback function. The conversion is still performed using `address(x)`. If the contract type does not have a receive or payable fallback function, the conversion to `address payable` can be done using `payable(address(x))`. You can find more information in the section about the [address type](#address).
Note
Before version 0.5.0, contracts directly derived from the address type and there was no distinction between `address` and `address payable`.
If you declare a local variable of contract type (`MyContract c`), you can call functions on that contract. Take care to assign it from somewhere that is the same contract type.
You can also instantiate contracts (which means they are newly created). You can find more details in the [‘Contracts via new’](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#creating-contracts) section.
The data representation of a contract is identical to that of the `address` type and this type is also used in the [ABI](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#abi).
Contracts do not support any operators.
The members of contract types are the external functions of the contract including any state variables marked as `public`.
For a contract `C` you can use `type(C)` to access [type information](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#meta-type) about the contract.
### Fixed-size byte arrays[](#fixed-size-byte-arrays "Link to this heading")
The value types `bytes1`, `bytes2`, `bytes3`, …, `bytes32` hold a sequence of bytes from one to up to 32.
Operators:
* Comparisons: `<=`, `<`, `==`, `!=`, `>=`, `>` (evaluate to `bool`)
 
* Bit operators: `&`, `|`, `^` (bitwise exclusive or), `~` (bitwise negation)
 
* Shift operators: `<<` (left shift), `>>` (right shift)
 
* Index access: If `x` is of type `bytesI`, then `x[k]` for `0 <= k < I` returns the `k` th byte (read-only).
 
The shifting operator works with unsigned integer type as right operand (but returns the type of the left operand), which denotes the number of bits to shift by. Shifting by a signed type will produce a compilation error.
Members:
* `.length` yields the fixed length of the byte array (read-only).
 
Note
The type `bytes1[]` is an array of bytes, but due to padding rules, it wastes 31 bytes of space for each element (except in storage). It is better to use the `bytes` type instead.
Note
Prior to version 0.8.0, `byte` used to be an alias for `bytes1`.
### Address Literals[](#address-literals "Link to this heading")
Hexadecimal literals that pass the address checksum test, for example `0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF` are of `address` type. Hexadecimal literals that are between 39 and 41 digits long and do not pass the checksum test produce an error. You can prepend (for integer types) or append (for bytesNN types) zeros to remove the error.
Note
The mixed-case address checksum format is defined in [EIP-55](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md).
### Rational and Integer Literals[](#rational-and-integer-literals "Link to this heading")
Integer literals are formed from a sequence of digits in the range 0-9. They are interpreted as decimals. For example, `69` means sixty nine. Octal literals do not exist in Solidity and leading zeros are invalid.
Decimal fractional literals are formed by a `.` with at least one number after the decimal point. Examples include `.1` and `1.3` (but not `1.`).
Scientific notation in the form of `2e10` is also supported, where the mantissa can be fractional but the exponent has to be an integer. The literal `MeE` is equivalent to `M * 10**E`. Examples include `2e10`, `-2e10`, `2e-10`, `2.5e1`.
Underscores can be used to separate the digits of a numeric literal to aid readability. For example, decimal `123_000`, hexadecimal `0x2eff_abde`, scientific decimal notation `1_2e345_678` are all valid. Underscores are only allowed between two digits and only one consecutive underscore is allowed. There is no additional semantic meaning added to a number literal containing underscores, the underscores are ignored.
Number literal expressions retain arbitrary precision until they are converted to a non-literal type (i.e. by using them together with anything other than a number literal expression (like boolean literals) or by explicit conversion). This means that computations do not overflow and divisions do not truncate in number literal expressions.
For example, `(2**800 + 1) - 2**800` results in the constant `1` (of type `uint8`) although intermediate results would not even fit the machine word size. Furthermore, `.5 * 8` results in the integer `4` (although non-integers were used in between).
Warning
While most operators produce a literal expression when applied to literals, there are certain operators that do not follow this pattern:
* Ternary operator (`... ? ... : ...`),
 
* Array subscript (`<array>[<index>]`).
 
You might expect expressions like `255 + (true ? 1 : 0)` or `255 + [1, 2, 3][0]` to be equivalent to using the literal 256 directly, but in fact they are computed within the type `uint8` and can overflow.
Any operator that can be applied to integers can also be applied to number literal expressions as long as the operands are integers. If any of the two is fractional, bit operations are disallowed and exponentiation is disallowed if the exponent is fractional (because that might result in a non-rational number).
Shifts and exponentiation with literal numbers as left (or base) operand and integer types as the right (exponent) operand are always performed in the `uint256` (for non-negative literals) or `int256` (for a negative literals) type, regardless of the type of the right (exponent) operand.
Warning
Division on integer literals used to truncate in Solidity prior to version 0.4.0, but it now converts into a rational number, i.e. `5 / 2` is not equal to `2`, but to `2.5`.
Note
Solidity has a number literal type for each rational number. Integer literals and rational number literals belong to number literal types. Moreover, all number literal expressions (i.e. the expressions that contain only number literals and operators) belong to number literal types. So the number literal expressions `1 + 2` and `2 + 1` both belong to the same number literal type for the rational number three.
Note
Number literal expressions are converted into a non-literal type as soon as they are used with non-literal expressions. Disregarding types, the value of the expression assigned to `b` below evaluates to an integer. Because `a` is of type `uint128`, the expression `2.5 + a` has to have a proper type, though. Since there is no common type for the type of `2.5` and `uint128`, the Solidity compiler does not accept this code.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=dWludDEyOCBhID0gMTsKdWludDEyOCBiID0gMi41ICsgYSArIDAuNTs=)
uint128 a \= 1;
uint128 b \= 2.5 + a + 0.5;
### String Literals and Types[](#string-literals-and-types "Link to this heading")
String literals are written with either double or single-quotes (`"foo"` or `'bar'`), and they can also be split into multiple consecutive parts (`"foo" "bar"` is equivalent to `"foobar"`) which can be helpful when dealing with long strings. They do not imply trailing zeroes as in C; `"foo"` represents three bytes, not four. As with integer literals, their type can vary, but they are implicitly convertible to `bytes1`, …, `bytes32`, if they fit, to `bytes` and to `string`.
For example, with `bytes32 samevar = "stringliteral"` the string literal is interpreted in its raw byte form when assigned to a `bytes32` type.
String literals can only contain printable ASCII characters, which means the characters between and including 0x20 .. 0x7E.
Additionally, string literals also support the following escape characters:
* `\<newline>` (escapes an actual newline)
 
* `\\` (backslash)
 
* `\'` (single quote)
 
* `\"` (double quote)
 
* `\n` (newline)
 
* `\r` (carriage return)
 
* `\t` (tab)
 
* `\xNN` (hex escape, see below)
 
* `\uNNNN` (unicode escape, see below)
 
`\xNN` takes a hex value and inserts the appropriate byte, while `\uNNNN` takes a Unicode codepoint and inserts an UTF-8 sequence.
Note
Until version 0.8.0 there were three additional escape sequences: `\b`, `\f` and `\v`. They are commonly available in other languages but rarely needed in practice. If you do need them, they can still be inserted via hexadecimal escapes, i.e. `\x08`, `\x0c` and `\x0b`, respectively, just as any other ASCII character.
The string in the following example has a length of ten bytes. It starts with a newline byte, followed by a double quote, a single quote a backslash character and then (without separator) the character sequence `abcdef`.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=IlxuXCJcJ1xcYWJjXApkZWYi)
Any Unicode line terminator which is not a newline (i.e. LF, VF, FF, CR, NEL, LS, PS) is considered to terminate the string literal. Newline only terminates the string literal if it is not preceded by a `\`.
### Unicode Literals[](#unicode-literals "Link to this heading")
While regular string literals can only contain ASCII, Unicode literals – prefixed with the keyword `unicode` – can contain any valid UTF-8 sequence. They also support the very same escape sequences as regular string literals.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=c3RyaW5nIG1lbW9yeSBhID0gdW5pY29kZSJIZWxsbyDwn5iDIjs=)
string memory a \= unicode"Hello 😃";
### Hexadecimal Literals[](#hexadecimal-literals "Link to this heading")
Hexadecimal literals are prefixed with the keyword `hex` and are enclosed in double or single-quotes (`hex"001122FF"`, `hex'0011_22_FF'`). Their content must be hexadecimal digits which can optionally use a single underscore as separator between byte boundaries. The value of the literal will be the binary representation of the hexadecimal sequence.
Multiple hexadecimal literals separated by whitespace are concatenated into a single literal: `hex"00112233" hex"44556677"` is equivalent to `hex"0011223344556677"`
Hexadecimal literals in some ways behave like [string literals](#string-literals) but are not implicitly convertible to the `string` type.
### Enums[](#enums "Link to this heading")
Enums are one way to create a user-defined type in Solidity. They are explicitly convertible to and from all integer types but implicit conversion is not allowed. The explicit conversion from integer checks at runtime that the value lies inside the range of the enum and causes a [Panic error](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#assert-and-require) otherwise. Enums require at least one member, and its default value when declared is the first member. Enums cannot have more than 256 members.
The data representation is the same as for enums in C: The options are represented by subsequent unsigned integer values starting from `0`.
Using `type(NameOfEnum).min` and `type(NameOfEnum).max` you can get the smallest and respectively largest value of the given enum.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguODsKCmNvbnRyYWN0IHRlc3QgewogICAgZW51bSBBY3Rpb25DaG9pY2VzIHsgR29MZWZ0LCBHb1JpZ2h0LCBHb1N0cmFpZ2h0LCBTaXRTdGlsbCB9CiAgICBBY3Rpb25DaG9pY2VzIGNob2ljZTsKICAgIEFjdGlvbkNob2ljZXMgY29uc3RhbnQgZGVmYXVsdENob2ljZSA9IEFjdGlvbkNob2ljZXMuR29TdHJhaWdodDsKCiAgICBmdW5jdGlvbiBzZXRHb1N0cmFpZ2h0KCkgcHVibGljIHsKICAgICAgICBjaG9pY2UgPSBBY3Rpb25DaG9pY2VzLkdvU3RyYWlnaHQ7CiAgICB9CgogICAgLy8gU2luY2UgZW51bSB0eXBlcyBhcmUgbm90IHBhcnQgb2YgdGhlIEFCSSwgdGhlIHNpZ25hdHVyZSBvZiAiZ2V0Q2hvaWNlIgogICAgLy8gd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGNoYW5nZWQgdG8gImdldENob2ljZSgpIHJldHVybnMgKHVpbnQ4KSIKICAgIC8vIGZvciBhbGwgbWF0dGVycyBleHRlcm5hbCB0byBTb2xpZGl0eS4KICAgIGZ1bmN0aW9uIGdldENob2ljZSgpIHB1YmxpYyB2aWV3IHJldHVybnMgKEFjdGlvbkNob2ljZXMpIHsKICAgICAgICByZXR1cm4gY2hvaWNlOwogICAgfQoKICAgIGZ1bmN0aW9uIGdldERlZmF1bHRDaG9pY2UoKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIHVpbnQoZGVmYXVsdENob2ljZSk7CiAgICB9CgogICAgZnVuY3Rpb24gZ2V0TGFyZ2VzdFZhbHVlKCkgcHVibGljIHB1cmUgcmV0dXJucyAoQWN0aW9uQ2hvaWNlcykgewogICAgICAgIHJldHVybiB0eXBlKEFjdGlvbkNob2ljZXMpLm1heDsKICAgIH0KCiAgICBmdW5jdGlvbiBnZXRTbWFsbGVzdFZhbHVlKCkgcHVibGljIHB1cmUgcmV0dXJucyAoQWN0aW9uQ2hvaWNlcykgewogICAgICAgIHJldHVybiB0eXBlKEFjdGlvbkNob2ljZXMpLm1pbjsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.8;
contract test {
 enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }
 ActionChoices choice;
 ActionChoices constant defaultChoice \= ActionChoices.GoStraight;
 function setGoStraight() public {
 choice \= ActionChoices.GoStraight;
 }
 // Since enum types are not part of the ABI, the signature of "getChoice"
 // will automatically be changed to "getChoice() returns (uint8)"
 // for all matters external to Solidity.
 function getChoice() public view returns (ActionChoices) {
 return choice;
 }
 function getDefaultChoice() public pure returns (uint) {
 return uint(defaultChoice);
 }
 function getLargestValue() public pure returns (ActionChoices) {
 return type(ActionChoices).max;
 }
 function getSmallestValue() public pure returns (ActionChoices) {
 return type(ActionChoices).min;
 }
}
Note
Enums can also be declared on the file level, outside of contract or library definitions.
### User-defined Value Types[](#user-defined-value-types "Link to this heading")
A user-defined value type allows creating a zero cost abstraction over an elementary value type. This is similar to an alias, but with stricter type requirements.
A user-defined value type is defined using `type C is V`, where `C` is the name of the newly introduced type and `V` has to be a built-in value type (the “underlying type”). The function `C.wrap` is used to convert from the underlying type to the custom type. Similarly, the function `C.unwrap` is used to convert from the custom type to the underlying type.
The type `C` does not have any operators or attached member functions. In particular, even the operator `==` is not defined. Explicit and implicit conversions to and from other types are disallowed.
The data-representation of values of such types are inherited from the underlying type and the underlying type is also used in the ABI.
The following example illustrates a custom type `UFixed256x18` representing a decimal fixed point type with 18 decimals and a minimal library to do arithmetic operations on the type.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguODsKCi8vIFJlcHJlc2VudCBhIDE4IGRlY2ltYWwsIDI1NiBiaXQgd2lkZSBmaXhlZCBwb2ludCB0eXBlIHVzaW5nIGEgdXNlci1kZWZpbmVkIHZhbHVlIHR5cGUuCnR5cGUgVUZpeGVkMjU2eDE4IGlzIHVpbnQyNTY7CgovLy8gQSBtaW5pbWFsIGxpYnJhcnkgdG8gZG8gZml4ZWQgcG9pbnQgb3BlcmF0aW9ucyBvbiBVRml4ZWQyNTZ4MTguCmxpYnJhcnkgRml4ZWRNYXRoIHsKICAgIHVpbnQgY29uc3RhbnQgbXVsdGlwbGllciA9IDEwKioxODsKCiAgICAvLy8gQWRkcyB0d28gVUZpeGVkMjU2eDE4IG51bWJlcnMuIFJldmVydHMgb24gb3ZlcmZsb3csIHJlbHlpbmcgb24gY2hlY2tlZAogICAgLy8vIGFyaXRobWV0aWMgb24gdWludDI1Ni4KICAgIGZ1bmN0aW9uIGFkZChVRml4ZWQyNTZ4MTggYSwgVUZpeGVkMjU2eDE4IGIpIGludGVybmFsIHB1cmUgcmV0dXJucyAoVUZpeGVkMjU2eDE4KSB7CiAgICAgICAgcmV0dXJuIFVGaXhlZDI1NngxOC53cmFwKFVGaXhlZDI1NngxOC51bndyYXAoYSkgKyBVRml4ZWQyNTZ4MTgudW53cmFwKGIpKTsKICAgIH0KICAgIC8vLyBNdWx0aXBsaWVzIFVGaXhlZDI1NngxOCBhbmQgdWludDI1Ni4gUmV2ZXJ0cyBvbiBvdmVyZmxvdywgcmVseWluZyBvbiBjaGVja2VkCiAgICAvLy8gYXJpdGhtZXRpYyBvbiB1aW50MjU2LgogICAgZnVuY3Rpb24gbXVsKFVGaXhlZDI1NngxOCBhLCB1aW50MjU2IGIpIGludGVybmFsIHB1cmUgcmV0dXJucyAoVUZpeGVkMjU2eDE4KSB7CiAgICAgICAgcmV0dXJuIFVGaXhlZDI1NngxOC53cmFwKFVGaXhlZDI1NngxOC51bndyYXAoYSkgKiBiKTsKICAgIH0KICAgIC8vLyBUYWtlIHRoZSBmbG9vciBvZiBhIFVGaXhlZDI1NngxOCBudW1iZXIuCiAgICAvLy8gQHJldHVybiB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHRoYXQgZG9lcyBub3QgZXhjZWVkIGBhYC4KICAgIGZ1bmN0aW9uIGZsb29yKFVGaXhlZDI1NngxOCBhKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnQyNTYpIHsKICAgICAgICByZXR1cm4gVUZpeGVkMjU2eDE4LnVud3JhcChhKSAvIG11bHRpcGxpZXI7CiAgICB9CiAgICAvLy8gVHVybnMgYSB1aW50MjU2IGludG8gYSBVRml4ZWQyNTZ4MTggb2YgdGhlIHNhbWUgdmFsdWUuCiAgICAvLy8gUmV2ZXJ0cyBpZiB0aGUgaW50ZWdlciBpcyB0b28gbGFyZ2UuCiAgICBmdW5jdGlvbiB0b1VGaXhlZDI1NngxOCh1aW50MjU2IGEpIGludGVybmFsIHB1cmUgcmV0dXJucyAoVUZpeGVkMjU2eDE4KSB7CiAgICAgICAgcmV0dXJuIFVGaXhlZDI1NngxOC53cmFwKGEgKiBtdWx0aXBsaWVyKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.8;
// Represent a 18 decimal, 256 bit wide fixed point type using a user-defined value type.
type UFixed256x18 is uint256;
/// A minimal library to do fixed point operations on UFixed256x18.
library FixedMath {
 uint constant multiplier \= 10\*\*18;
 /// Adds two UFixed256x18 numbers. Reverts on overflow, relying on checked
 /// arithmetic on uint256.
 function add(UFixed256x18 a, UFixed256x18 b) internal pure returns (UFixed256x18) {
 return UFixed256x18.wrap(UFixed256x18.unwrap(a) + UFixed256x18.unwrap(b));
 }
 /// Multiplies UFixed256x18 and uint256. Reverts on overflow, relying on checked
 /// arithmetic on uint256.
 function mul(UFixed256x18 a, uint256 b) internal pure returns (UFixed256x18) {
 return UFixed256x18.wrap(UFixed256x18.unwrap(a) \* b);
 }
 /// Take the floor of a UFixed256x18 number.
 /// @return the largest integer that does not exceed \`a\`.
 function floor(UFixed256x18 a) internal pure returns (uint256) {
 return UFixed256x18.unwrap(a) / multiplier;
 }
 /// Turns a uint256 into a UFixed256x18 of the same value.
 /// Reverts if the integer is too large.
 function toUFixed256x18(uint256 a) internal pure returns (UFixed256x18) {
 return UFixed256x18.wrap(a \* multiplier);
 }
}
Notice how `UFixed256x18.wrap` and `FixedMath.toUFixed256x18` have the same signature but perform two very different operations: The `UFixed256x18.wrap` function returns a `UFixed256x18` that has the same data representation as the input, whereas `toUFixed256x18` returns a `UFixed256x18` that has the same numerical value.
### Function Types[](#function-types "Link to this heading")
Function types are the types of functions. Variables of a function type can be assigned from functions and function parameters of function type can be used to pass functions to and return functions from function calls. Function types come in two flavours - _internal_ and _external_ functions:
Internal functions can only be called inside the current contract (more specifically, inside the current code unit, which also includes internal library functions and inherited functions) because they cannot be executed outside of the context of the current contract. Calling an internal function is realized by jumping to its entry label, just like when calling a function of the current contract internally.
External functions consist of an address and a function signature and they can be passed via and returned from external function calls.
Note that public functions of the current contract can be used both as an internal and as an external function. To use `f` as an internal function, just use `f`, if you want to use its external form, use `this.f`.
If a function type variable is not initialised, calling it results in a [Panic error](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#assert-and-require). The same happens if you call a function after using `delete` on it.
Note
Lambda or inline functions are planned but not yet supported.
#### Declaration syntax[](#declaration-syntax "Link to this heading")
Function types are notated as follows:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=ZnVuY3Rpb24gKDxwYXJhbWV0ZXIgdHlwZXM+KSB7aW50ZXJuYWx8ZXh0ZXJuYWx9IFtwdXJlfHZpZXd8cGF5YWJsZV0gW3JldHVybnMgKDxyZXR1cm4gdHlwZXM+KV0=)
function (<parameter types\>) {internal|external} \[pure|view|payable\] \[returns (<return types\>)\]
In contrast to the parameter types, the return types cannot be empty - if the function type should not return anything, the whole `returns (<return types>)` part has to be omitted.
By default, function types are internal, so the `internal` keyword can be omitted. Note that this only applies to function types. Visibility has to be specified explicitly for functions defined in contracts, they do not have a default.
#### Conversions[](#conversions "Link to this heading")
A function type `A` is implicitly convertible to a function type `B` if and only if their parameter types are identical, their return types are identical, their internal/external property is identical and the state mutability of `A` is more restrictive than the state mutability of `B`. In particular:
* `pure` functions can be converted to `view` and `non-payable` functions
 
* `view` functions can be converted to `non-payable` functions
 
* `payable` functions can be converted to `non-payable` functions
 
No other conversions between function types are possible.
The rule about `payable` and `non-payable` might be a little confusing, but in essence, if a function is `payable`, this means that it also accepts a payment of zero Ether, so it also is `non-payable`. On the other hand, a `non-payable` function will reject Ether sent to it, so `non-payable` functions cannot be converted to `payable` functions. To clarify, rejecting ether is more restrictive than not rejecting ether. This means you can override a payable function with a non-payable but not the other way around.
Additionally, When you define a `non-payable` function pointer, the compiler does not enforce that the pointed function will actually reject ether. Instead, it enforces that the function pointer is never used to send ether. Which makes it possible to assign a `payable` function pointer to a `non-payable` function pointer ensuring both types behave the same way, i.e, both cannot be used to send ether.
If external function types are used outside of the context of Solidity, they are treated as the `function` type, which encodes the address followed by the function identifier together in a single `bytes24` type.
A function of an internal type can be assigned to a variable of an internal function type regardless of where it is defined. This includes private, internal and public functions of both contracts and libraries as well as free functions. External function types, on the other hand, are only compatible with public and external contract functions.
Note
External functions with `calldata` parameters are incompatible with external function types with `calldata` parameters. They are compatible with the corresponding types with `memory` parameters instead. For example, there is no function that can be pointed at by a value of type `function (string calldata) external` while `function (string memory) external` can point at both `function f(string memory) external {}` and `function g(string calldata) external {}`. This is because for both locations the arguments are passed to the function in the same way. The caller cannot pass its calldata directly to an external function and always ABI-encodes the arguments into memory. Marking the parameters as `calldata` only affects the implementation of the external function and is meaningless in a function pointer on the caller’s side.
Warning
Comparison of internal function pointers can have unexpected results in the legacy pipeline with the optimizer enabled, as it can collapse identical functions into one, which will then lead to said function pointers comparing as equal instead of not. Such comparisons are not advised, and will lead to the compiler issuing a warning, until the next breaking release (0.9.0), when the warning will be upgraded to an error, thereby making such comparisons disallowed.
Libraries are excluded because they require a `delegatecall` and use [a different ABI convention for their selectors](https://docs.soliditylang.org/en/v0.8.30/contracts.html#library-selectors). Functions declared in interfaces do not have definitions so pointing at them does not make sense either.
#### Members[](#members "Link to this heading")
External (or public) functions have the following members:
* `.address` returns the address of the contract of the function.
 
* `.selector` returns the [ABI function selector](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#abi-function-selector)
 
Note
External (or public) functions used to have the additional members `.gas(uint)` and `.value(uint)`. These were deprecated in Solidity 0.6.2 and removed in Solidity 0.7.0. Instead use `{gas: ...}` and `{value: ...}` to specify the amount of gas or the amount of wei sent to a function, respectively. See [External Function Calls](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#external-function-calls) for more information.
#### Value stability across contract updates[](#value-stability-across-contract-updates "Link to this heading")
An important aspect to consider when using values of function types is whether the value will remain valid if the underlying code changes.
The state of the blockchain is not completely immutable and there are multiple ways to place different code under the same address:
* Directly deploying different code using [salted contract creation](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#salted-contract-creations).
 
* Delegating to a different contract via [DELEGATECALL](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#delegatecall) (upgradeable code behind a proxy contract is a common example of this).
 
* Account abstraction as defined by [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702).
 
External function types can be considered as stable as contract’s ABI, which makes them very portable. Their ABI representation always consists of a contract address and a function selector and it is perfectly safe to store them long-term or pass them between contracts. While it is possible for the referenced function to change or disappear, a direct external call would be affected the same way, so there is no additional risk in such use.
In case of internal functions, however, the value is an identifier that is strongly tied to contract’s bytecode. The actual representation of the identifier is an implementation detail and may change between compiler versions or even [between different backends](https://docs.soliditylang.org/en/v0.8.30/ir-breaking-changes.html#internal-function-pointers-in-ir). Values assigned under a given representation are deterministic (i.e. guaranteed to remain the same as long as the source code is the same) but are easily affected by changes such as adding, removing or reordering of functions. The compiler is also free to remove internal functions that are never used, which may affect other identifiers. Some representations, e.g. one where identifiers are simply jump targets, may be affected by virtually any change, even one completely unrelated to internal functions.
To counter this, the language limits the use of internal function types outside of the context in which they are valid. This is why internal function types cannot be used as parameters of external functions (or in any other way that is exposed in contract’s ABI). However, there are still situations where it is up to the user to decide whether their use is safe or not. For example long-term storage of such values in state variables is discouraged, but may be safe if the contract code is never going to be updated. It is also always possible to side-step any safeguards by using inline assembly. Such use always needs careful consideration.
Note
The removal of unused internal functions only takes into account explicit references to such functions by name. Implicit references, such as assigning a new value to a function type variable in inline assembly may still lead to the removal of the function if it is not also referenced explicitly elsewhere in the source.
#### Examples[](#examples "Link to this heading")
Example that shows how to use the members:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjQgPDAuOS4wOwoKY29udHJhY3QgRXhhbXBsZSB7CiAgICBmdW5jdGlvbiBmKCkgcHVibGljIHBheWFibGUgcmV0dXJucyAoYnl0ZXM0KSB7CiAgICAgICAgYXNzZXJ0KHRoaXMuZi5hZGRyZXNzID09IGFkZHJlc3ModGhpcykpOwogICAgICAgIHJldHVybiB0aGlzLmYuc2VsZWN0b3I7CiAgICB9CgogICAgZnVuY3Rpb24gZygpIHB1YmxpYyB7CiAgICAgICAgdGhpcy5me2dhczogMTAsIHZhbHVlOiA4MDB9KCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.4 <0.9.0;
contract Example {
 function f() public payable returns (bytes4) {
 assert(this.f.address \== address(this));
 return this.f.selector;
 }
 function g() public {
 this.f{gas: 10, value: 800}();
 }
}
Example that shows how to use internal function types:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmxpYnJhcnkgQXJyYXlVdGlscyB7CiAgICAvLyBpbnRlcm5hbCBmdW5jdGlvbnMgY2FuIGJlIHVzZWQgaW4gaW50ZXJuYWwgbGlicmFyeSBmdW5jdGlvbnMgYmVjYXVzZQogICAgLy8gdGhleSB3aWxsIGJlIHBhcnQgb2YgdGhlIHNhbWUgY29kZSBjb250ZXh0CiAgICBmdW5jdGlvbiBtYXAodWludFtdIG1lbW9yeSBzZWxmLCBmdW5jdGlvbiAodWludCkgcHVyZSByZXR1cm5zICh1aW50KSBmKQogICAgICAgIGludGVybmFsCiAgICAgICAgcHVyZQogICAgICAgIHJldHVybnMgKHVpbnRbXSBtZW1vcnkgcikKICAgIHsKICAgICAgICByID0gbmV3IHVpbnRbXShzZWxmLmxlbmd0aCk7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykgewogICAgICAgICAgICByW2ldID0gZihzZWxmW2ldKTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gcmVkdWNlKAogICAgICAgIHVpbnRbXSBtZW1vcnkgc2VsZiwKICAgICAgICBmdW5jdGlvbiAodWludCwgdWludCkgcHVyZSByZXR1cm5zICh1aW50KSBmCiAgICApCiAgICAgICAgaW50ZXJuYWwKICAgICAgICBwdXJlCiAgICAgICAgcmV0dXJucyAodWludCByKQogICAgewogICAgICAgIHIgPSBzZWxmWzBdOwogICAgICAgIGZvciAodWludCBpID0gMTsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgciA9IGYociwgc2VsZltpXSk7CiAgICAgICAgfQogICAgfQoKICAgIGZ1bmN0aW9uIHJhbmdlKHVpbnQgbGVuZ3RoKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnRbXSBtZW1vcnkgcikgewogICAgICAgIHIgPSBuZXcgdWludFtdKGxlbmd0aCk7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgci5sZW5ndGg7IGkrKykgewogICAgICAgICAgICByW2ldID0gaTsKICAgICAgICB9CiAgICB9Cn0KCgpjb250cmFjdCBQeXJhbWlkIHsKICAgIHVzaW5nIEFycmF5VXRpbHMgZm9yICo7CgogICAgZnVuY3Rpb24gcHlyYW1pZCh1aW50IGwpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4gQXJyYXlVdGlscy5yYW5nZShsKS5tYXAoc3F1YXJlKS5yZWR1Y2Uoc3VtKTsKICAgIH0KCiAgICBmdW5jdGlvbiBzcXVhcmUodWludCB4KSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4geCAqIHg7CiAgICB9CgogICAgZnVuY3Rpb24gc3VtKHVpbnQgeCwgdWludCB5KSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4geCArIHk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
library ArrayUtils {
 // internal functions can be used in internal library functions because
 // they will be part of the same code context
 function map(uint\[\] memory self, function (uint) pure returns (uint) f)
 internal
 pure
 returns (uint\[\] memory r)
 {
 r \= new uint\[\](self.length);
 for (uint i \= 0; i < self.length; i++) {
 r\[i\] \= f(self\[i\]);
 }
 }
 function reduce(
 uint\[\] memory self,
 function (uint, uint) pure returns (uint) f
 )
 internal
 pure
 returns (uint r)
 {
 r \= self\[0\];
 for (uint i \= 1; i < self.length; i++) {
 r \= f(r, self\[i\]);
 }
 }
 function range(uint length) internal pure returns (uint\[\] memory r) {
 r \= new uint\[\](length);
 for (uint i \= 0; i < r.length; i++) {
 r\[i\] \= i;
 }
 }
}
contract Pyramid {
 using ArrayUtils for \*;
 function pyramid(uint l) public pure returns (uint) {
 return ArrayUtils.range(l).map(square).reduce(sum);
 }
 function square(uint x) internal pure returns (uint) {
 return x \* x;
 }
 function sum(uint x, uint y) internal pure returns (uint) {
 return x + y;
 }
}
Another example that uses external function types:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCgpjb250cmFjdCBPcmFjbGUgewogICAgc3RydWN0IFJlcXVlc3QgewogICAgICAgIGJ5dGVzIGRhdGE7CiAgICAgICAgZnVuY3Rpb24odWludCkgZXh0ZXJuYWwgY2FsbGJhY2s7CiAgICB9CgogICAgUmVxdWVzdFtdIHByaXZhdGUgcmVxdWVzdHM7CiAgICBldmVudCBOZXdSZXF1ZXN0KHVpbnQpOwoKICAgIGZ1bmN0aW9uIHF1ZXJ5KGJ5dGVzIG1lbW9yeSBkYXRhLCBmdW5jdGlvbih1aW50KSBleHRlcm5hbCBjYWxsYmFjaykgcHVibGljIHsKICAgICAgICByZXF1ZXN0cy5wdXNoKFJlcXVlc3QoZGF0YSwgY2FsbGJhY2spKTsKICAgICAgICBlbWl0IE5ld1JlcXVlc3QocmVxdWVzdHMubGVuZ3RoIC0gMSk7CiAgICB9CgogICAgZnVuY3Rpb24gcmVwbHkodWludCByZXF1ZXN0SUQsIHVpbnQgcmVzcG9uc2UpIHB1YmxpYyB7CiAgICAgICAgLy8gSGVyZSBnb2VzIHRoZSBjaGVjayB0aGF0IHRoZSByZXBseSBjb21lcyBmcm9tIGEgdHJ1c3RlZCBzb3VyY2UKICAgICAgICByZXF1ZXN0c1tyZXF1ZXN0SURdLmNhbGxiYWNrKHJlc3BvbnNlKTsKICAgIH0KfQoKCmNvbnRyYWN0IE9yYWNsZVVzZXIgewogICAgT3JhY2xlIGNvbnN0YW50IHByaXZhdGUgT1JBQ0xFX0NPTlNUID0gT3JhY2xlKGFkZHJlc3MoMHgwMDAwMDAwMDIxOWFiNTQwMzU2Y0JCODM5Q2JlMDUzMDNkNzcwNUZhKSk7IC8vIGtub3duIGNvbnRyYWN0CiAgICB1aW50IHByaXZhdGUgZXhjaGFuZ2VSYXRlOwoKICAgIGZ1bmN0aW9uIGJ1eVNvbWV0aGluZygpIHB1YmxpYyB7CiAgICAgICAgT1JBQ0xFX0NPTlNULnF1ZXJ5KCJVU0QiLCB0aGlzLm9yYWNsZVJlc3BvbnNlKTsKICAgIH0KCiAgICBmdW5jdGlvbiBvcmFjbGVSZXNwb25zZSh1aW50IHJlc3BvbnNlKSBwdWJsaWMgewogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgIG1zZy5zZW5kZXIgPT0gYWRkcmVzcyhPUkFDTEVfQ09OU1QpLAogICAgICAgICAgICAiT25seSBvcmFjbGUgY2FuIGNhbGwgdGhpcy4iCiAgICAgICAgKTsKICAgICAgICBleGNoYW5nZVJhdGUgPSByZXNwb25zZTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.22 <0.9.0;
contract Oracle {
 struct Request {
 bytes data;
 function(uint) external callback;
 }
 Request\[\] private requests;
 event NewRequest(uint);
 function query(bytes memory data, function(uint) external callback) public {
 requests.push(Request(data, callback));
 emit NewRequest(requests.length \- 1);
 }
 function reply(uint requestID, uint response) public {
 // Here goes the check that the reply comes from a trusted source
 requests\[requestID\].callback(response);
 }
}
contract OracleUser {
 Oracle constant private ORACLE\_CONST \= Oracle(address(0x00000000219ab540356cBB839Cbe05303d7705Fa)); // known contract
 uint private exchangeRate;
 function buySomething() public {
 ORACLE\_CONST.query("USD", this.oracleResponse);
 }
 function oracleResponse(uint response) public {
 require(
 msg.sender \== address(ORACLE\_CONST),
 "Only oracle can call this."
 );
 exchangeRate \= response;
 }
}
## Reference Types[](#reference-types "Link to this heading")
Values of reference type can be modified through multiple different names. Contrast this with value types where you get an independent copy whenever a variable of value type is used. Because of that, reference types have to be handled more carefully than value types. Currently, reference types comprise structs, arrays and mappings. If you use a reference type, you always have to explicitly provide the data area where the type is stored: `memory` (whose lifetime is limited to an external function call), `storage` (the location where the state variables are stored, where the lifetime is limited to the lifetime of a contract) or `calldata` (special data location that contains the function arguments).
An assignment or type conversion that changes the data location will always incur an automatic copy operation, while assignments inside the same data location only copy in some cases for storage types.
### Data location[](#data-location "Link to this heading")
Every reference type has an additional annotation, the “data location”, about where it is stored. There are three data locations: `memory`, `storage` and `calldata`. Calldata is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.
Note
`transient` is not yet supported as a data location for reference types.
Note
If you can, try to use `calldata` as data location because it will avoid copies and also makes sure that the data cannot be modified. Arrays and structs with `calldata` data location can also be returned from functions, but it is not possible to allocate such types.
Note
Arrays and structs with `calldata` location declared in a function body or as its return parameters must be assigned before being used or returned. There are certain cases in which non-trivial control flow is used and the compiler can’t properly detect the initialization. A common workaround in such cases is to assign the affected variable to itself before the correct initialization takes place.
Note
Prior to version 0.6.9 data location for reference-type arguments was limited to `calldata` in external functions, `memory` in public functions and either `memory` or `storage` in internal and private ones. Now `memory` and `calldata` are allowed in all functions regardless of their visibility.
Note
Constructor parameters cannot use `calldata` as their data location.
Note
Prior to version 0.5.0 the data location could be omitted, and would default to different locations depending on the kind of variable, function type, etc., but all complex types must now give an explicit data location.
#### Data location and assignment behavior[](#data-location-and-assignment-behavior "Link to this heading")
Data locations are not only relevant for persistency of data, but also for the semantics of assignments:
* Assignments between `storage` and `memory` (or from `calldata`) always create an independent copy.
 
* Assignments from `memory` to `memory` only create references. This means that changes to one memory variable are also visible in all other memory variables that refer to the same data.
 
* Assignments from `storage` to a **local** storage variable also only assign a reference.
 
* All other assignments to `storage` always copy. Examples for this case are assignments to state variables or to members of local variables of storage struct type, even if the local variable itself is just a reference.
 
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICAvLyBUaGUgZGF0YSBsb2NhdGlvbiBvZiB4IGlzIHN0b3JhZ2UuCiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHBsYWNlIHdoZXJlIHRoZQogICAgLy8gZGF0YSBsb2NhdGlvbiBjYW4gYmUgb21pdHRlZC4KICAgIHVpbnRbXSB4OwoKICAgIC8vIFRoZSBkYXRhIGxvY2F0aW9uIG9mIG1lbW9yeUFycmF5IGlzIG1lbW9yeS4KICAgIGZ1bmN0aW9uIGYodWludFtdIG1lbW9yeSBtZW1vcnlBcnJheSkgcHVibGljIHsKICAgICAgICB4ID0gbWVtb3J5QXJyYXk7IC8vIHdvcmtzLCBjb3BpZXMgdGhlIHdob2xlIGFycmF5IHRvIHN0b3JhZ2UKICAgICAgICB1aW50W10gc3RvcmFnZSB5ID0geDsgLy8gd29ya3MsIGFzc2lnbnMgYSBwb2ludGVyLCBkYXRhIGxvY2F0aW9uIG9mIHkgaXMgc3RvcmFnZQogICAgICAgIHlbN107IC8vIGZpbmUsIHJldHVybnMgdGhlIDh0aCBlbGVtZW50CiAgICAgICAgeS5wb3AoKTsgLy8gZmluZSwgbW9kaWZpZXMgeCB0aHJvdWdoIHkKICAgICAgICBkZWxldGUgeDsgLy8gZmluZSwgY2xlYXJzIHRoZSBhcnJheSwgYWxzbyBtb2RpZmllcyB5CiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBkb2VzIG5vdCB3b3JrOyBpdCB3b3VsZCBuZWVkIHRvIGNyZWF0ZSBhIG5ldyB0ZW1wb3JhcnkgLwogICAgICAgIC8vIHVubmFtZWQgYXJyYXkgaW4gc3RvcmFnZSwgYnV0IHN0b3JhZ2UgaXMgInN0YXRpY2FsbHkiIGFsbG9jYXRlZDoKICAgICAgICAvLyB5ID0gbWVtb3J5QXJyYXk7CiAgICAgICAgLy8gU2ltaWxhcmx5LCAiZGVsZXRlIHkiIGlzIG5vdCB2YWxpZCwgYXMgYXNzaWdubWVudHMgdG8gbG9jYWwgdmFyaWFibGVzCiAgICAgICAgLy8gcmVmZXJlbmNpbmcgc3RvcmFnZSBvYmplY3RzIGNhbiBvbmx5IGJlIG1hZGUgZnJvbSBleGlzdGluZyBzdG9yYWdlIG9iamVjdHMuCiAgICAgICAgLy8gSXQgd291bGQgInJlc2V0IiB0aGUgcG9pbnRlciwgYnV0IHRoZXJlIGlzIG5vIHNlbnNpYmxlIGxvY2F0aW9uIGl0IGNvdWxkIHBvaW50IHRvLgogICAgICAgIC8vIEZvciBtb3JlIGRldGFpbHMgc2VlIHRoZSBkb2N1bWVudGF0aW9uIG9mIHRoZSAiZGVsZXRlIiBvcGVyYXRvci4KICAgICAgICAvLyBkZWxldGUgeTsKICAgICAgICBnKHgpOyAvLyBjYWxscyBnLCBoYW5kaW5nIG92ZXIgYSByZWZlcmVuY2UgdG8geAogICAgICAgIGgoeCk7IC8vIGNhbGxzIGggYW5kIGNyZWF0ZXMgYW4gaW5kZXBlbmRlbnQsIHRlbXBvcmFyeSBjb3B5IGluIG1lbW9yeQogICAgfQoKICAgIGZ1bmN0aW9uIGcodWludFtdIHN0b3JhZ2UpIGludGVybmFsIHB1cmUge30KICAgIGZ1bmN0aW9uIGgodWludFtdIG1lbW9yeSkgcHVibGljIHB1cmUge30KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
contract C {
 // The data location of x is storage.
 // This is the only place where the
 // data location can be omitted.
 uint\[\] x;
 // The data location of memoryArray is memory.
 function f(uint\[\] memory memoryArray) public {
 x \= memoryArray; // works, copies the whole array to storage
 uint\[\] storage y \= x; // works, assigns a pointer, data location of y is storage
 y\[7\]; // fine, returns the 8th element
 y.pop(); // fine, modifies x through y
 delete x; // fine, clears the array, also modifies y
 // The following does not work; it would need to create a new temporary /
 // unnamed array in storage, but storage is "statically" allocated:
 // y = memoryArray;
 // Similarly, "delete y" is not valid, as assignments to local variables
 // referencing storage objects can only be made from existing storage objects.
 // It would "reset" the pointer, but there is no sensible location it could point to.
 // For more details see the documentation of the "delete" operator.
 // delete y;
 g(x); // calls g, handing over a reference to x
 h(x); // calls h and creates an independent, temporary copy in memory
 }
 function g(uint\[\] storage) internal pure {}
 function h(uint\[\] memory) public pure {}
}
### Arrays[](#arrays "Link to this heading")
Arrays can have a compile-time fixed size, or they can have a dynamic size.
The type of an array of fixed size `k` and element type `T` is written as `T[k]`, and an array of dynamic size as `T[]`.
For example, an array of 5 dynamic arrays of `uint` is written as `uint[][5]`. The notation is reversed compared to some other languages. In Solidity, `X[3]` is always an array containing three elements of type `X`, even if `X` is itself an array. This is not the case in other languages such as C.
Indices are zero-based, and access is in the opposite direction of the declaration.
For example, if you have a variable `uint[][5] memory x`, you access the seventh `uint` in the third dynamic array using `x[2][6]`, and to access the third dynamic array, use `x[2]`. Again, if you have an array `T[5] a` for a type `T` that can also be an array, then `a[2]` always has type `T`.
Array elements can be of any type, including mapping or struct. The general restrictions for types apply, in that mappings can only be stored in the `storage` data location and publicly-visible functions need parameters that are [ABI types](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#abi).
It is possible to mark state variable arrays `public` and have Solidity create a [getter](https://docs.soliditylang.org/en/v0.8.30/contracts.html#visibility-and-getters). The numeric index becomes a required parameter for the getter.
Accessing an array past its end causes a failing assertion. Methods `.push()` and `.push(value)` can be used to append a new element at the end of a dynamically-sized array, where `.push()` appends a zero-initialized element and returns a reference to it.
Note
Dynamically-sized arrays can only be resized in storage. In memory, such arrays can be of arbitrary size but the size cannot be changed once an array is allocated.
#### `bytes` and `string` as Arrays[](#bytes-and-string-as-arrays "Link to this heading")
Variables of type `bytes` and `string` are special arrays. The `bytes` type is similar to `bytes1[]`, but it is packed tightly in calldata and memory. `string` is equal to `bytes` but does not allow length or index access.
Solidity does not have string manipulation functions, but there are third-party string libraries. You can also compare two strings by their keccak256-hash using `keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))` and concatenate two strings using `string.concat(s1, s2)`.
You should use `bytes` over `bytes1[]` because it is cheaper, since using `bytes1[]` in `memory` adds 31 padding bytes between the elements. Note that in `storage`, the padding is absent due to tight packing, see [bytes and string](https://docs.soliditylang.org/en/v0.8.30/internals/layout_in_storage.html#bytes-and-string). As a general rule, use `bytes` for arbitrary-length raw byte data and `string` for arbitrary-length string (UTF-8) data. If you can limit the length to a certain number of bytes, always use one of the value types `bytes1` to `bytes32` because they are much cheaper.
Note
If you want to access the byte-representation of a string `s`, use `bytes(s).length` / `bytes(s)[7] = 'x';`. Keep in mind that you are accessing the low-level bytes of the UTF-8 representation, and not the individual characters.
#### The functions `bytes.concat` and `string.concat`[](#the-functions-bytes-concat-and-string-concat "Link to this heading")
You can concatenate an arbitrary number of `string` values using `string.concat`. The function returns a single `string memory` array that contains the contents of the arguments without padding. If you want to use parameters of other types that are not implicitly convertible to `string`, you need to convert them to `string` first.
Analogously, the `bytes.concat` function can concatenate an arbitrary number of `bytes` or `bytes1 ... bytes32` values. The function returns a single `bytes memory` array that contains the contents of the arguments without padding. If you want to use string parameters or other types that are not implicitly convertible to `bytes`, you need to convert them to `bytes` or `bytes1`/…/`bytes32` first.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTI7Cgpjb250cmFjdCBDIHsKICAgIHN0cmluZyBzID0gIlN0b3JhZ2UiOwogICAgZnVuY3Rpb24gZihieXRlcyBjYWxsZGF0YSBiYywgc3RyaW5nIG1lbW9yeSBzbSwgYnl0ZXMxNiBiKSBwdWJsaWMgdmlldyB7CiAgICAgICAgc3RyaW5nIG1lbW9yeSBjb25jYXRTdHJpbmcgPSBzdHJpbmcuY29uY2F0KHMsIHN0cmluZyhiYyksICJMaXRlcmFsIiwgc20pOwogICAgICAgIGFzc2VydCgoYnl0ZXMocykubGVuZ3RoICsgYmMubGVuZ3RoICsgNyArIGJ5dGVzKHNtKS5sZW5ndGgpID09IGJ5dGVzKGNvbmNhdFN0cmluZykubGVuZ3RoKTsKCiAgICAgICAgYnl0ZXMgbWVtb3J5IGNvbmNhdEJ5dGVzID0gYnl0ZXMuY29uY2F0KGJ5dGVzKHMpLCBiYywgYmNbOjJdLCAiTGl0ZXJhbCIsIGJ5dGVzKHNtKSwgYik7CiAgICAgICAgYXNzZXJ0KChieXRlcyhzKS5sZW5ndGggKyBiYy5sZW5ndGggKyAyICsgNyArIGJ5dGVzKHNtKS5sZW5ndGggKyBiLmxlbmd0aCkgPT0gY29uY2F0Qnl0ZXMubGVuZ3RoKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.12;
contract C {
 string s \= "Storage";
 function f(bytes calldata bc, string memory sm, bytes16 b) public view {
 string memory concatString \= string.concat(s, string(bc), "Literal", sm);
 assert((bytes(s).length + bc.length + 7 + bytes(sm).length) \== bytes(concatString).length);
 bytes memory concatBytes \= bytes.concat(bytes(s), bc, bc\[:2\], "Literal", bytes(sm), b);
 assert((bytes(s).length + bc.length + 2 + 7 + bytes(sm).length + b.length) \== concatBytes.length);
 }
}
If you call `string.concat` or `bytes.concat` without arguments they return an empty array.
#### Allocating Memory Arrays[](#allocating-memory-arrays "Link to this heading")
Memory arrays with dynamic length can be created using the `new` operator. As opposed to storage arrays, it is **not** possible to resize memory arrays (e.g. the `.push` member functions are not available). You either have to calculate the required size in advance or create a new memory array and copy every element.
As all variables in Solidity, the elements of newly allocated arrays are always initialized with the [default value](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#default-value).
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50IGxlbikgcHVibGljIHB1cmUgewogICAgICAgIHVpbnRbXSBtZW1vcnkgYSA9IG5ldyB1aW50W10oNyk7CiAgICAgICAgYnl0ZXMgbWVtb3J5IGIgPSBuZXcgYnl0ZXMobGVuKTsKICAgICAgICBhc3NlcnQoYS5sZW5ndGggPT0gNyk7CiAgICAgICAgYXNzZXJ0KGIubGVuZ3RoID09IGxlbik7CiAgICAgICAgYVs2XSA9IDg7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 function f(uint len) public pure {
 uint\[\] memory a \= new uint\[\](7);
 bytes memory b \= new bytes(len);
 assert(a.length \== 7);
 assert(b.length \== len);
 a\[6\] \= 8;
 }
}
#### Array Literals[](#array-literals "Link to this heading")
An array literal is a comma-separated list of one or more expressions, enclosed in square brackets (`[...]`). For example `[1, a, f(3)]`. The type of the array literal is determined as follows:
It is always a statically-sized memory array whose length is the number of expressions.
The base type of the array is the type of the first expression on the list such that all other expressions can be implicitly converted to it. It is a type error if this is not possible.
It is not enough that there is a type all the elements can be converted to. One of the elements has to be of that type.
In the example below, the type of `[1, 2, 3]` is `uint8[3] memory`, because the type of each of these constants is `uint8`. If you want the result to be a `uint[3] memory` type, you need to convert the first element to `uint`.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHsKICAgICAgICBnKFt1aW50KDEpLCAyLCAzXSk7CiAgICB9CiAgICBmdW5jdGlvbiBnKHVpbnRbM10gbWVtb3J5KSBwdWJsaWMgcHVyZSB7CiAgICAgICAgLy8gLi4uCiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 function f() public pure {
 g(\[uint(1), 2, 3\]);
 }
 function g(uint\[3\] memory) public pure {
 // ...
 }
}
The array literal `[1, -1]` is invalid because the type of the first expression is `uint8` while the type of the second is `int8` and they cannot be implicitly converted to each other. To make it work, you can use `[int8(1), -1]`, for example.
Since fixed-size memory arrays of different type cannot be converted into each other (even if the base types can), you always have to specify a common base type explicitly if you want to use two-dimensional array literals:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQyNFsyXVs0XSBtZW1vcnkpIHsKICAgICAgICB1aW50MjRbMl1bNF0gbWVtb3J5IHggPSBbW3VpbnQyNCgweDEpLCAxXSwgWzB4ZmZmZmZmLCAyXSwgW3VpbnQyNCgweGZmKSwgM10sIFt1aW50MjQoMHhmZmZmKSwgNF1dOwogICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgZG9lcyBub3Qgd29yaywgYmVjYXVzZSBzb21lIG9mIHRoZSBpbm5lciBhcnJheXMgYXJlIG5vdCBvZiB0aGUgcmlnaHQgdHlwZS4KICAgICAgICAvLyB1aW50WzJdWzRdIG1lbW9yeSB4ID0gW1sweDEsIDFdLCBbMHhmZmZmZmYsIDJdLCBbMHhmZiwgM10sIFsweGZmZmYsIDRdXTsKICAgICAgICByZXR1cm4geDsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 function f() public pure returns (uint24\[2\]\[4\] memory) {
 uint24\[2\]\[4\] memory x \= \[\[uint24(0x1), 1\], \[0xffffff, 2\], \[uint24(0xff), 3\], \[uint24(0xffff), 4\]\];
 // The following does not work, because some of the inner arrays are not of the right type.
 // uint\[2\]\[4\] memory x = \[\[0x1, 1\], \[0xffffff, 2\], \[0xff, 3\], \[0xffff, 4\]\];
 return x;
 }
}
Fixed size memory arrays cannot be assigned to dynamically-sized memory arrays, i.e. the following is not possible:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKLy8gVGhpcyB3aWxsIG5vdCBjb21waWxlLgpjb250cmFjdCBDIHsKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIC8vIFRoZSBuZXh0IGxpbmUgY3JlYXRlcyBhIHR5cGUgZXJyb3IgYmVjYXVzZSB1aW50WzNdIG1lbW9yeQogICAgICAgIC8vIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gdWludFtdIG1lbW9yeS4KICAgICAgICB1aW50W10gbWVtb3J5IHggPSBbdWludCgxKSwgMywgNF07CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
// This will not compile.
contract C {
 function f() public {
 // The next line creates a type error because uint\[3\] memory
 // cannot be converted to uint\[\] memory.
 uint\[\] memory x \= \[uint(1), 3, 4\];
 }
}
It is planned to remove this restriction in the future, but it creates some complications because of how arrays are passed in the ABI.
If you want to initialize dynamically-sized arrays, you have to assign the individual elements:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHsKICAgICAgICB1aW50W10gbWVtb3J5IHggPSBuZXcgdWludFtdKDMpOwogICAgICAgIHhbMF0gPSAxOwogICAgICAgIHhbMV0gPSAzOwogICAgICAgIHhbMl0gPSA0OwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 function f() public pure {
 uint\[\] memory x \= new uint\[\](3);
 x\[0\] \= 1;
 x\[1\] \= 3;
 x\[2\] \= 4;
 }
}
#### Array Members[](#array-members "Link to this heading")
**length**:
Arrays have a `length` member that contains their number of elements. The length of memory arrays is fixed (but dynamic, i.e. it can depend on runtime parameters) once they are created.
**push()**:
Dynamic storage arrays and `bytes` (not `string`) have a member function called `push()` that you can use to append a zero-initialised element at the end of the array. It returns a reference to the element, so that it can be used like `x.push().t = 2` or `x.push() = b`.
**push(x)**:
Dynamic storage arrays and `bytes` (not `string`) have a member function called `push(x)` that you can use to append a given element at the end of the array. The function returns nothing.
**pop()**:
Dynamic storage arrays and `bytes` (not `string`) have a member function called `pop()` that you can use to remove an element from the end of the array. This also implicitly calls [delete](#delete) on the removed element. The function returns nothing.
Note
Increasing the length of a storage array by calling `push()` has constant gas costs because storage is zero-initialised, while decreasing the length by calling `pop()` has a cost that depends on the “size” of the element being removed. If that element is an array, it can be very costly, because it includes explicitly clearing the removed elements similar to calling [delete](#delete) on them.
Note
To use arrays of arrays in external (instead of public) functions, you need to activate ABI coder v2.
Note
In EVM versions before Byzantium, it was not possible to access dynamic arrays returned from function calls. If you call functions that return dynamic arrays, make sure to use an EVM that is set to Byzantium mode.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQXJyYXlDb250cmFjdCB7CiAgICB1aW50WzIqKjIwXSBhTG90T2ZJbnRlZ2VyczsKICAgIC8vIE5vdGUgdGhhdCB0aGUgZm9sbG93aW5nIGlzIG5vdCBhIHBhaXIgb2YgZHluYW1pYyBhcnJheXMgYnV0IGEKICAgIC8vIGR5bmFtaWMgYXJyYXkgb2YgcGFpcnMgKGkuZS4gb2YgZml4ZWQgc2l6ZSBhcnJheXMgb2YgbGVuZ3RoIHR3bykuCiAgICAvLyBJbiBTb2xpZGl0eSwgVFtrXSBhbmQgVFtdIGFyZSBhbHdheXMgYXJyYXlzIHdpdGggZWxlbWVudHMgb2YgdHlwZSBULAogICAgLy8gZXZlbiBpZiBUIGl0c2VsZiBpcyBhbiBhcnJheS4KICAgIC8vIEJlY2F1c2Ugb2YgdGhhdCwgYm9vbFsyXVtdIGlzIGEgZHluYW1pYyBhcnJheSBvZiBlbGVtZW50cwogICAgLy8gdGhhdCBhcmUgYm9vbFsyXS4gVGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBvdGhlciBsYW5ndWFnZXMsIGxpa2UgQy4KICAgIC8vIERhdGEgbG9jYXRpb24gZm9yIGFsbCBzdGF0ZSB2YXJpYWJsZXMgaXMgc3RvcmFnZS4KICAgIGJvb2xbMl1bXSBwYWlyc09mRmxhZ3M7CgogICAgLy8gbmV3UGFpcnMgaXMgc3RvcmVkIGluIG1lbW9yeQogICAgZnVuY3Rpb24gc2V0QWxsRmxhZ1BhaXJzKGJvb2xbMl1bXSBtZW1vcnkgbmV3UGFpcnMpIHB1YmxpYyB7CiAgICAgICAgLy8gYXNzaWdubWVudCB0byBhIHN0b3JhZ2UgYXJyYXkgcGVyZm9ybXMgYSBjb3B5IG9mIGBgbmV3UGFpcnNgYCBhbmQKICAgICAgICAvLyByZXBsYWNlcyB0aGUgY29tcGxldGUgYXJyYXkgYGBwYWlyc09mRmxhZ3NgYC4KICAgICAgICBwYWlyc09mRmxhZ3MgPSBuZXdQYWlyczsKICAgIH0KCiAgICBzdHJ1Y3QgU3RydWN0VHlwZSB7CiAgICAgICAgdWludFtdIGNvbnRlbnRzOwogICAgICAgIHVpbnQgbW9yZUluZm87CiAgICB9CiAgICBTdHJ1Y3RUeXBlIHM7CgogICAgZnVuY3Rpb24gZih1aW50W10gbWVtb3J5IGMpIHB1YmxpYyB7CiAgICAgICAgLy8gc3RvcmVzIGEgcmVmZXJlbmNlIHRvIGBgc2BgIGluIGBgZ2BgCiAgICAgICAgU3RydWN0VHlwZSBzdG9yYWdlIGcgPSBzOwogICAgICAgIC8vIGFsc28gY2hhbmdlcyBgYHMubW9yZUluZm9gYC4KICAgICAgICBnLm1vcmVJbmZvID0gMjsKICAgICAgICAvLyBhc3NpZ25zIGEgY29weSBiZWNhdXNlIGBgZy5jb250ZW50c2BgCiAgICAgICAgLy8gaXMgbm90IGEgbG9jYWwgdmFyaWFibGUsIGJ1dCBhIG1lbWJlciBvZgogICAgICAgIC8vIGEgbG9jYWwgdmFyaWFibGUuCiAgICAgICAgZy5jb250ZW50cyA9IGM7CiAgICB9CgogICAgZnVuY3Rpb24gc2V0RmxhZ1BhaXIodWludCBpbmRleCwgYm9vbCBmbGFnQSwgYm9vbCBmbGFnQikgcHVibGljIHsKICAgICAgICAvLyBhY2Nlc3MgdG8gYSBub24tZXhpc3RpbmcgaW5kZXggd2lsbCB0aHJvdyBhbiBleGNlcHRpb24KICAgICAgICBwYWlyc09mRmxhZ3NbaW5kZXhdWzBdID0gZmxhZ0E7CiAgICAgICAgcGFpcnNPZkZsYWdzW2luZGV4XVsxXSA9IGZsYWdCOwogICAgfQoKICAgIGZ1bmN0aW9uIGNoYW5nZUZsYWdBcnJheVNpemUodWludCBuZXdTaXplKSBwdWJsaWMgewogICAgICAgIC8vIHVzaW5nIHB1c2ggYW5kIHBvcCBpcyB0aGUgb25seSB3YXkgdG8gY2hhbmdlIHRoZQogICAgICAgIC8vIGxlbmd0aCBvZiBhbiBhcnJheQogICAgICAgIGlmIChuZXdTaXplIDwgcGFpcnNPZkZsYWdzLmxlbmd0aCkgewogICAgICAgICAgICB3aGlsZSAocGFpcnNPZkZsYWdzLmxlbmd0aCA+IG5ld1NpemUpCiAgICAgICAgICAgICAgICBwYWlyc09mRmxhZ3MucG9wKCk7CiAgICAgICAgfSBlbHNlIGlmIChuZXdTaXplID4gcGFpcnNPZkZsYWdzLmxlbmd0aCkgewogICAgICAgICAgICB3aGlsZSAocGFpcnNPZkZsYWdzLmxlbmd0aCA8IG5ld1NpemUpCiAgICAgICAgICAgICAgICBwYWlyc09mRmxhZ3MucHVzaCgpOwogICAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiBjbGVhcigpIHB1YmxpYyB7CiAgICAgICAgLy8gdGhlc2UgY2xlYXIgdGhlIGFycmF5cyBjb21wbGV0ZWx5CiAgICAgICAgZGVsZXRlIHBhaXJzT2ZGbGFnczsKICAgICAgICBkZWxldGUgYUxvdE9mSW50ZWdlcnM7CiAgICAgICAgLy8gaWRlbnRpY2FsIGVmZmVjdCBoZXJlCiAgICAgICAgcGFpcnNPZkZsYWdzID0gbmV3IGJvb2xbMl1bXSgwKTsKICAgIH0KCiAgICBieXRlcyBieXRlRGF0YTsKCiAgICBmdW5jdGlvbiBieXRlQXJyYXlzKGJ5dGVzIG1lbW9yeSBkYXRhKSBwdWJsaWMgewogICAgICAgIC8vIGJ5dGUgYXJyYXlzICgiYnl0ZXMiKSBhcmUgZGlmZmVyZW50IGFzIHRoZXkgYXJlIHN0b3JlZCB3aXRob3V0IHBhZGRpbmcsCiAgICAgICAgLy8gYnV0IGNhbiBiZSB0cmVhdGVkIGlkZW50aWNhbCB0byAidWludDhbXSIKICAgICAgICBieXRlRGF0YSA9IGRhdGE7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgNzsgaSsrKQogICAgICAgICAgICBieXRlRGF0YS5wdXNoKCk7CiAgICAgICAgYnl0ZURhdGFbM10gPSAweDA4OwogICAgICAgIGRlbGV0ZSBieXRlRGF0YVsyXTsKICAgIH0KCiAgICBmdW5jdGlvbiBhZGRGbGFnKGJvb2xbMl0gbWVtb3J5IGZsYWcpIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcGFpcnNPZkZsYWdzLnB1c2goZmxhZyk7CiAgICAgICAgcmV0dXJuIHBhaXJzT2ZGbGFncy5sZW5ndGg7CiAgICB9CgogICAgZnVuY3Rpb24gY3JlYXRlTWVtb3J5QXJyYXkodWludCBzaXplKSBwdWJsaWMgcHVyZSByZXR1cm5zIChieXRlcyBtZW1vcnkpIHsKICAgICAgICAvLyBEeW5hbWljIG1lbW9yeSBhcnJheXMgYXJlIGNyZWF0ZWQgdXNpbmcgYG5ld2A6CiAgICAgICAgdWludFsyXVtdIG1lbW9yeSBhcnJheU9mUGFpcnMgPSBuZXcgdWludFsyXVtdKHNpemUpOwoKICAgICAgICAvLyBJbmxpbmUgYXJyYXlzIGFyZSBhbHdheXMgc3RhdGljYWxseS1zaXplZCBhbmQgaWYgeW91IG9ubHkKICAgICAgICAvLyB1c2UgbGl0ZXJhbHMsIHlvdSBoYXZlIHRvIHByb3ZpZGUgYXQgbGVhc3Qgb25lIHR5cGUuCiAgICAgICAgYXJyYXlPZlBhaXJzWzBdID0gW3VpbnQoMSksIDJdOwoKICAgICAgICAvLyBDcmVhdGUgYSBkeW5hbWljIGJ5dGUgYXJyYXk6CiAgICAgICAgYnl0ZXMgbWVtb3J5IGIgPSBuZXcgYnl0ZXMoMjAwKTsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKQogICAgICAgICAgICBiW2ldID0gYnl0ZXMxKHVpbnQ4KGkpKTsKICAgICAgICByZXR1cm4gYjsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract ArrayContract {
 uint\[2\*\*20\] aLotOfIntegers;
 // Note that the following is not a pair of dynamic arrays but a
 // dynamic array of pairs (i.e. of fixed size arrays of length two).
 // In Solidity, T\[k\] and T\[\] are always arrays with elements of type T,
 // even if T itself is an array.
 // Because of that, bool\[2\]\[\] is a dynamic array of elements
 // that are bool\[2\]. This is different from other languages, like C.
 // Data location for all state variables is storage.
 bool\[2\]\[\] pairsOfFlags;
 // newPairs is stored in memory
 function setAllFlagPairs(bool\[2\]\[\] memory newPairs) public {
 // assignment to a storage array performs a copy of \`\`newPairs\`\` and
 // replaces the complete array \`\`pairsOfFlags\`\`.
 pairsOfFlags \= newPairs;
 }
 struct StructType {
 uint\[\] contents;
 uint moreInfo;
 }
 StructType s;
 function f(uint\[\] memory c) public {
 // stores a reference to \`\`s\`\` in \`\`g\`\`
 StructType storage g \= s;
 // also changes \`\`s.moreInfo\`\`.
 g.moreInfo \= 2;
 // assigns a copy because \`\`g.contents\`\`
 // is not a local variable, but a member of
 // a local variable.
 g.contents \= c;
 }
 function setFlagPair(uint index, bool flagA, bool flagB) public {
 // access to a non-existing index will throw an exception
 pairsOfFlags\[index\]\[0\] \= flagA;
 pairsOfFlags\[index\]\[1\] \= flagB;
 }
 function changeFlagArraySize(uint newSize) public {
 // using push and pop is the only way to change the
 // length of an array
 if (newSize < pairsOfFlags.length) {
 while (pairsOfFlags.length \> newSize)
 pairsOfFlags.pop();
 } else if (newSize \> pairsOfFlags.length) {
 while (pairsOfFlags.length < newSize)
 pairsOfFlags.push();
 }
 }
 function clear() public {
 // these clear the arrays completely
 delete pairsOfFlags;
 delete aLotOfIntegers;
 // identical effect here
 pairsOfFlags \= new bool\[2\]\[\](0);
 }
 bytes byteData;
 function byteArrays(bytes memory data) public {
 // byte arrays ("bytes") are different as they are stored without padding,
 // but can be treated identical to "uint8\[\]"
 byteData \= data;
 for (uint i \= 0; i < 7; i++)
 byteData.push();
 byteData\[3\] \= 0x08;
 delete byteData\[2\];
 }
 function addFlag(bool\[2\] memory flag) public returns (uint) {
 pairsOfFlags.push(flag);
 return pairsOfFlags.length;
 }
 function createMemoryArray(uint size) public pure returns (bytes memory) {
 // Dynamic memory arrays are created using \`new\`:
 uint\[2\]\[\] memory arrayOfPairs \= new uint\[2\]\[\](size);
 // Inline arrays are always statically-sized and if you only
 // use literals, you have to provide at least one type.
 arrayOfPairs\[0\] \= \[uint(1), 2\];
 // Create a dynamic byte array:
 bytes memory b \= new bytes(200);
 for (uint i \= 0; i < b.length; i++)
 b\[i\] \= bytes1(uint8(i));
 return b;
 }
}
#### Dangling References to Storage Array Elements[](#dangling-references-to-storage-array-elements "Link to this heading")
When working with storage arrays, you need to take care to avoid dangling references. A dangling reference is a reference that points to something that no longer exists or has been moved without updating the reference. A dangling reference can for example occur, if you store a reference to an array element in a local variable and then `.pop()` from the containing array:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50W11bXSBzOwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIC8vIFN0b3JlcyBhIHBvaW50ZXIgdG8gdGhlIGxhc3QgYXJyYXkgZWxlbWVudCBvZiBzLgogICAgICAgIHVpbnRbXSBzdG9yYWdlIHB0ciA9IHNbcy5sZW5ndGggLSAxXTsKICAgICAgICAvLyBSZW1vdmVzIHRoZSBsYXN0IGFycmF5IGVsZW1lbnQgb2Ygcy4KICAgICAgICBzLnBvcCgpOwogICAgICAgIC8vIFdyaXRlcyB0byB0aGUgYXJyYXkgZWxlbWVudCB0aGF0IGlzIG5vIGxvbmdlciB3aXRoaW4gdGhlIGFycmF5LgogICAgICAgIHB0ci5wdXNoKDB4NDIpOwogICAgICAgIC8vIEFkZGluZyBhIG5ldyBlbGVtZW50IHRvIGBgc2BgIG5vdyB3aWxsIG5vdCBhZGQgYW4gZW1wdHkgYXJyYXksIGJ1dAogICAgICAgIC8vIHdpbGwgcmVzdWx0IGluIGFuIGFycmF5IG9mIGxlbmd0aCAxIHdpdGggYGAweDQyYGAgYXMgZWxlbWVudC4KICAgICAgICBzLnB1c2goKTsKICAgICAgICBhc3NlcnQoc1tzLmxlbmd0aCAtIDFdWzBdID09IDB4NDIpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0 <0.9.0;
contract C {
 uint\[\]\[\] s;
 function f() public {
 // Stores a pointer to the last array element of s.
 uint\[\] storage ptr \= s\[s.length \- 1\];
 // Removes the last array element of s.
 s.pop();
 // Writes to the array element that is no longer within the array.
 ptr.push(0x42);
 // Adding a new element to \`\`s\`\` now will not add an empty array, but
 // will result in an array of length 1 with \`\`0x42\`\` as element.
 s.push();
 assert(s\[s.length \- 1\]\[0\] \== 0x42);
 }
}
The write in `ptr.push(0x42)` will **not** revert, despite the fact that `ptr` no longer refers to a valid element of `s`. Since the compiler assumes that unused storage is always zeroed, a subsequent `s.push()` will not explicitly write zeroes to storage, so the last element of `s` after that `push()` will have length `1` and contain `0x42` as its first element.
Note that Solidity does not allow to declare references to value types in storage. These kinds of explicit dangling references are restricted to nested reference types. However, dangling references can also occur temporarily when using complex expressions in tuple assignments:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50W10gczsKICAgIHVpbnRbXSB0OwogICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgLy8gUHVzaCBzb21lIGluaXRpYWwgdmFsdWVzIHRvIHRoZSBzdG9yYWdlIGFycmF5cy4KICAgICAgICBzLnB1c2goMHgwNyk7CiAgICAgICAgdC5wdXNoKDB4MDMpOwogICAgfQoKICAgIGZ1bmN0aW9uIGcoKSBpbnRlcm5hbCByZXR1cm5zICh1aW50W10gc3RvcmFnZSkgewogICAgICAgIHMucG9wKCk7CiAgICAgICAgcmV0dXJuIHQ7CiAgICB9CgogICAgZnVuY3Rpb24gZigpIHB1YmxpYyByZXR1cm5zICh1aW50W10gbWVtb3J5KSB7CiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyB3aWxsIGZpcnN0IGV2YWx1YXRlIGBgcy5wdXNoKClgYCB0byBhIHJlZmVyZW5jZSB0byBhIG5ldyBlbGVtZW50CiAgICAgICAgLy8gYXQgaW5kZXggMS4gQWZ0ZXJ3YXJkcywgdGhlIGNhbGwgdG8gYGBnYGAgcG9wcyB0aGlzIG5ldyBlbGVtZW50LCByZXN1bHRpbmcgaW4KICAgICAgICAvLyB0aGUgbGVmdC1tb3N0IHR1cGxlIGVsZW1lbnQgdG8gYmVjb21lIGEgZGFuZ2xpbmcgcmVmZXJlbmNlLiBUaGUgYXNzaWdubWVudCBzdGlsbAogICAgICAgIC8vIHRha2VzIHBsYWNlIGFuZCB3aWxsIHdyaXRlIG91dHNpZGUgdGhlIGRhdGEgYXJlYSBvZiBgYHNgYC4KICAgICAgICAocy5wdXNoKCksIGcoKVswXSkgPSAoMHg0MiwgMHgxNyk7CiAgICAgICAgLy8gQSBzdWJzZXF1ZW50IHB1c2ggdG8gYGBzYGAgd2lsbCByZXZlYWwgdGhlIHZhbHVlIHdyaXR0ZW4gYnkgdGhlIHByZXZpb3VzCiAgICAgICAgLy8gc3RhdGVtZW50LCBpLmUuIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGBzYGAgYXQgdGhlIGVuZCBvZiB0aGlzIGZ1bmN0aW9uIHdpbGwgaGF2ZQogICAgICAgIC8vIHRoZSB2YWx1ZSBgYDB4NDJgYC4KICAgICAgICBzLnB1c2goKTsKICAgICAgICByZXR1cm4gczsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0 <0.9.0;
contract C {
 uint\[\] s;
 uint\[\] t;
 constructor() {
 // Push some initial values to the storage arrays.
 s.push(0x07);
 t.push(0x03);
 }
 function g() internal returns (uint\[\] storage) {
 s.pop();
 return t;
 }
 function f() public returns (uint\[\] memory) {
 // The following will first evaluate \`\`s.push()\`\` to a reference to a new element
 // at index 1. Afterwards, the call to \`\`g\`\` pops this new element, resulting in
 // the left-most tuple element to become a dangling reference. The assignment still
 // takes place and will write outside the data area of \`\`s\`\`.
 (s.push(), g()\[0\]) \= (0x42, 0x17);
 // A subsequent push to \`\`s\`\` will reveal the value written by the previous
 // statement, i.e. the last element of \`\`s\`\` at the end of this function will have
 // the value \`\`0x42\`\`.
 s.push();
 return s;
 }
}
It is always safer to only assign to storage once per statement and to avoid complex expressions on the left-hand-side of an assignment.
You need to take particular care when dealing with references to elements of `bytes` arrays, since a `.push()` on a bytes array may switch [from short to long layout in storage](https://docs.soliditylang.org/en/v0.8.30/internals/layout_in_storage.html#bytes-and-string).
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjAgPDAuOS4wOwoKLy8gVGhpcyB3aWxsIHJlcG9ydCBhIHdhcm5pbmcKY29udHJhY3QgQyB7CiAgICBieXRlcyB4ID0gIjAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OSI7CgogICAgZnVuY3Rpb24gdGVzdCgpIGV4dGVybmFsIHJldHVybnModWludCkgewogICAgICAgICh4LnB1c2goKSwgeC5wdXNoKCkpID0gKDB4MDEsIDB4MDIpOwogICAgICAgIHJldHVybiB4Lmxlbmd0aDsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0 <0.9.0;
// This will report a warning
contract C {
 bytes x \= "012345678901234567890123456789";
 function test() external returns(uint) {
 (x.push(), x.push()) \= (0x01, 0x02);
 return x.length;
 }
}
Here, when the first `x.push()` is evaluated, `x` is still stored in short layout, thereby `x.push()` returns a reference to an element in the first storage slot of `x`. However, the second `x.push()` switches the bytes array to large layout. Now the element that `x.push()` referred to is in the data area of the array while the reference still points at its original location, which is now a part of the length field and the assignment will effectively garble the length of `x`. To be safe, only enlarge bytes arrays by at most one element during a single assignment and do not simultaneously index-access the array in the same statement.
While the above describes the behavior of dangling storage references in the current version of the compiler, any code with dangling references should be considered to have _undefined behavior_. In particular, this means that any future version of the compiler may change the behavior of code that involves dangling references.
Be sure to avoid dangling references in your code!
### Array Slices[](#array-slices "Link to this heading")
Array slices are a view on a contiguous portion of an array. They are written as `x[start:end]`, where `start` and `end` are expressions resulting in a uint256 type (or implicitly convertible to it). The first element of the slice is `x[start]` and the last element is `x[end - 1]`.
If `start` is greater than `end` or if `end` is greater than the length of the array, an exception is thrown.
Both `start` and `end` are optional: `start` defaults to `0` and `end` defaults to the length of the array.
Array slices do not have any members. They are implicitly convertible to arrays of their underlying type and support index access. Index access is not absolute in the underlying array, but relative to the start of the slice.
Array slices do not have a type name which means no variable can have an array slices as type, they only exist in intermediate expressions.
Note
As of now, array slices are only implemented for calldata arrays.
Array slices are useful to ABI-decode secondary data passed in function parameters:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjUgPDAuOS4wOwpjb250cmFjdCBQcm94eSB7CiAgICAvLy8gQGRldiBBZGRyZXNzIG9mIHRoZSBjbGllbnQgY29udHJhY3QgbWFuYWdlZCBieSBwcm94eSBpLmUuLCB0aGlzIGNvbnRyYWN0CiAgICBhZGRyZXNzIGNsaWVudDsKCiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzIGNsaWVudF8pIHsKICAgICAgICBjbGllbnQgPSBjbGllbnRfOwogICAgfQoKICAgIC8vLyBGb3J3YXJkIGNhbGwgdG8gInNldE93bmVyKGFkZHJlc3MpIiB0aGF0IGlzIGltcGxlbWVudGVkIGJ5IGNsaWVudAogICAgLy8vIGFmdGVyIGRvaW5nIGJhc2ljIHZhbGlkYXRpb24gb24gdGhlIGFkZHJlc3MgYXJndW1lbnQuCiAgICBmdW5jdGlvbiBmb3J3YXJkKGJ5dGVzIGNhbGxkYXRhIHBheWxvYWQpIGV4dGVybmFsIHsKICAgICAgICBieXRlczQgc2lnID0gYnl0ZXM0KHBheWxvYWRbOjRdKTsKICAgICAgICAvLyBEdWUgdG8gdHJ1bmNhdGluZyBiZWhhdmlvciwgYnl0ZXM0KHBheWxvYWQpIHBlcmZvcm1zIGlkZW50aWNhbGx5LgogICAgICAgIC8vIGJ5dGVzNCBzaWcgPSBieXRlczQocGF5bG9hZCk7CiAgICAgICAgaWYgKHNpZyA9PSBieXRlczQoa2VjY2FrMjU2KCJzZXRPd25lcihhZGRyZXNzKSIpKSkgewogICAgICAgICAgICBhZGRyZXNzIG93bmVyID0gYWJpLmRlY29kZShwYXlsb2FkWzQ6XSwgKGFkZHJlc3MpKTsKICAgICAgICAgICAgcmVxdWlyZShvd25lciAhPSBhZGRyZXNzKDApLCAiQWRkcmVzcyBvZiBvd25lciBjYW5ub3QgYmUgemVyby4iKTsKICAgICAgICB9CiAgICAgICAgKGJvb2wgc3RhdHVzLCkgPSBjbGllbnQuZGVsZWdhdGVjYWxsKHBheWxvYWQpOwogICAgICAgIHJlcXVpcmUoc3RhdHVzLCAiRm9yd2FyZGVkIGNhbGwgZmFpbGVkLiIpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.5 <0.9.0;
contract Proxy {
 /// @dev Address of the client contract managed by proxy i.e., this contract
 address client;
 constructor(address client\_) {
 client \= client\_;
 }
 /// Forward call to "setOwner(address)" that is implemented by client
 /// after doing basic validation on the address argument.
 function forward(bytes calldata payload) external {
 bytes4 sig \= bytes4(payload\[:4\]);
 // Due to truncating behavior, bytes4(payload) performs identically.
 // bytes4 sig = bytes4(payload);
 if (sig \== bytes4(keccak256("setOwner(address)"))) {
 address owner \= abi.decode(payload\[4:\], (address));
 require(owner != address(0), "Address of owner cannot be zero.");
 }
 (bool status,) \= client.delegatecall(payload);
 require(status, "Forwarded call failed.");
 }
}
### Structs[](#structs "Link to this heading")
Solidity provides a way to define new types in the form of structs, which is shown in the following example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKLy8gRGVmaW5lcyBhIG5ldyB0eXBlIHdpdGggdHdvIGZpZWxkcy4KLy8gRGVjbGFyaW5nIGEgc3RydWN0IG91dHNpZGUgb2YgYSBjb250cmFjdCBhbGxvd3MKLy8gaXQgdG8gYmUgc2hhcmVkIGJ5IG11bHRpcGxlIGNvbnRyYWN0cy4KLy8gSGVyZSwgdGhpcyBpcyBub3QgcmVhbGx5IG5lZWRlZC4Kc3RydWN0IEZ1bmRlciB7CiAgICBhZGRyZXNzIGFkZHI7CiAgICB1aW50IGFtb3VudDsKfQoKY29udHJhY3QgQ3Jvd2RGdW5kaW5nIHsKICAgIC8vIFN0cnVjdHMgY2FuIGFsc28gYmUgZGVmaW5lZCBpbnNpZGUgY29udHJhY3RzLCB3aGljaCBtYWtlcyB0aGVtCiAgICAvLyB2aXNpYmxlIG9ubHkgdGhlcmUgYW5kIGluIGRlcml2ZWQgY29udHJhY3RzLgogICAgc3RydWN0IENhbXBhaWduIHsKICAgICAgICBhZGRyZXNzIHBheWFibGUgYmVuZWZpY2lhcnk7CiAgICAgICAgdWludCBmdW5kaW5nR29hbDsKICAgICAgICB1aW50IG51bUZ1bmRlcnM7CiAgICAgICAgdWludCBhbW91bnQ7CiAgICAgICAgbWFwcGluZyh1aW50ID0+IEZ1bmRlcikgZnVuZGVyczsKICAgIH0KCiAgICB1aW50IG51bUNhbXBhaWduczsKICAgIG1hcHBpbmcodWludCA9PiBDYW1wYWlnbikgY2FtcGFpZ25zOwoKICAgIGZ1bmN0aW9uIG5ld0NhbXBhaWduKGFkZHJlc3MgcGF5YWJsZSBiZW5lZmljaWFyeSwgdWludCBnb2FsKSBwdWJsaWMgcmV0dXJucyAodWludCBjYW1wYWlnbklEKSB7CiAgICAgICAgY2FtcGFpZ25JRCA9IG51bUNhbXBhaWducysrOyAvLyBjYW1wYWlnbklEIGlzIHJldHVybiB2YXJpYWJsZQogICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgImNhbXBhaWduc1tjYW1wYWlnbklEXSA9IENhbXBhaWduKGJlbmVmaWNpYXJ5LCBnb2FsLCAwLCAwKSIKICAgICAgICAvLyBiZWNhdXNlIHRoZSByaWdodCBoYW5kIHNpZGUgY3JlYXRlcyBhIG1lbW9yeS1zdHJ1Y3QgIkNhbXBhaWduIiB0aGF0IGNvbnRhaW5zIGEgbWFwcGluZy4KICAgICAgICBDYW1wYWlnbiBzdG9yYWdlIGMgPSBjYW1wYWlnbnNbY2FtcGFpZ25JRF07CiAgICAgICAgYy5iZW5lZmljaWFyeSA9IGJlbmVmaWNpYXJ5OwogICAgICAgIGMuZnVuZGluZ0dvYWwgPSBnb2FsOwogICAgfQoKICAgIGZ1bmN0aW9uIGNvbnRyaWJ1dGUodWludCBjYW1wYWlnbklEKSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgQ2FtcGFpZ24gc3RvcmFnZSBjID0gY2FtcGFpZ25zW2NhbXBhaWduSURdOwogICAgICAgIC8vIENyZWF0ZXMgYSBuZXcgdGVtcG9yYXJ5IG1lbW9yeSBzdHJ1Y3QsIGluaXRpYWxpc2VkIHdpdGggdGhlIGdpdmVuIHZhbHVlcwogICAgICAgIC8vIGFuZCBjb3BpZXMgaXQgb3ZlciB0byBzdG9yYWdlLgogICAgICAgIC8vIE5vdGUgdGhhdCB5b3UgY2FuIGFsc28gdXNlIEZ1bmRlcihtc2cuc2VuZGVyLCBtc2cudmFsdWUpIHRvIGluaXRpYWxpc2UuCiAgICAgICAgYy5mdW5kZXJzW2MubnVtRnVuZGVycysrXSA9IEZ1bmRlcih7YWRkcjogbXNnLnNlbmRlciwgYW1vdW50OiBtc2cudmFsdWV9KTsKICAgICAgICBjLmFtb3VudCArPSBtc2cudmFsdWU7CiAgICB9CgogICAgZnVuY3Rpb24gY2hlY2tHb2FsUmVhY2hlZCh1aW50IGNhbXBhaWduSUQpIHB1YmxpYyByZXR1cm5zIChib29sIHJlYWNoZWQpIHsKICAgICAgICBDYW1wYWlnbiBzdG9yYWdlIGMgPSBjYW1wYWlnbnNbY2FtcGFpZ25JRF07CiAgICAgICAgaWYgKGMuYW1vdW50IDwgYy5mdW5kaW5nR29hbCkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIHVpbnQgYW1vdW50ID0gYy5hbW91bnQ7CiAgICAgICAgYy5hbW91bnQgPSAwOwogICAgICAgIGMuYmVuZWZpY2lhcnkudHJhbnNmZXIoYW1vdW50KTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
// Defines a new type with two fields.
// Declaring a struct outside of a contract allows
// it to be shared by multiple contracts.
// Here, this is not really needed.
struct Funder {
 address addr;
 uint amount;
}
contract CrowdFunding {
 // Structs can also be defined inside contracts, which makes them
 // visible only there and in derived contracts.
 struct Campaign {
 address payable beneficiary;
 uint fundingGoal;
 uint numFunders;
 uint amount;
 mapping(uint \=> Funder) funders;
 }
 uint numCampaigns;
 mapping(uint \=> Campaign) campaigns;
 function newCampaign(address payable beneficiary, uint goal) public returns (uint campaignID) {
 campaignID \= numCampaigns++; // campaignID is return variable
 // We cannot use "campaigns\[campaignID\] = Campaign(beneficiary, goal, 0, 0)"
 // because the right hand side creates a memory-struct "Campaign" that contains a mapping.
 Campaign storage c \= campaigns\[campaignID\];
 c.beneficiary \= beneficiary;
 c.fundingGoal \= goal;
 }
 function contribute(uint campaignID) public payable {
 Campaign storage c \= campaigns\[campaignID\];
 // Creates a new temporary memory struct, initialised with the given values
 // and copies it over to storage.
 // Note that you can also use Funder(msg.sender, msg.value) to initialise.
 c.funders\[c.numFunders++\] \= Funder({addr: msg.sender, amount: msg.value});
 c.amount += msg.value;
 }
 function checkGoalReached(uint campaignID) public returns (bool reached) {
 Campaign storage c \= campaigns\[campaignID\];
 if (c.amount < c.fundingGoal)
 return false;
 uint amount \= c.amount;
 c.amount \= 0;
 c.beneficiary.transfer(amount);
 return true;
 }
}
The contract does not provide the full functionality of a crowdfunding contract, but it contains the basic concepts necessary to understand structs. Struct types can be used inside mappings and arrays and they can themselves contain mappings and arrays.
It is not possible for a struct to contain a member of its own type, although the struct itself can be the value type of a mapping member or it can contain a dynamically-sized array of its type. This restriction is necessary, as the size of the struct has to be finite.
Note how in all the functions, a struct type is assigned to a local variable with data location `storage`. This does not copy the struct but only stores a reference so that assignments to members of the local variable actually write to the state.
Of course, you can also directly access the members of the struct without assigning it to a local variable, as in `campaigns[campaignID].amount = 0`.
Note
Until Solidity 0.7.0, memory-structs containing members of storage-only types (e.g. mappings) were allowed and assignments like `campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0)` in the example above would work and just silently skip those members.
## Mapping Types[](#mapping-types "Link to this heading")
Mapping types use the syntax `mapping(KeyType KeyName? => ValueType ValueName?)` and variables of mapping type are declared using the syntax `mapping(KeyType KeyName? => ValueType ValueName?) VariableName`. The `KeyType` can be any built-in value type, `bytes`, `string`, or any contract or enum type. Other user-defined or complex types, such as mappings, structs or array types are not allowed. `ValueType` can be any type, including mappings, arrays and structs. `KeyName` and `ValueName` are optional (so `mapping(KeyType => ValueType)` works as well) and can be any valid identifier that is not a type.
You can think of mappings as [hash tables](https://en.wikipedia.org/wiki/Hash_table), which are virtually initialised such that every possible key exists and is mapped to a value whose byte-representation is all zeros, a type’s [default value](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#default-value). The similarity ends there, the key data is not stored in a mapping, only its `keccak256` hash is used to look up the value.
Because of this, mappings do not have a length or a concept of a key or value being set, and therefore cannot be erased without extra information regarding the assigned keys (see [Clearing Mappings](https://docs.soliditylang.org/en/v0.8.30/security-considerations.html#clearing-mappings)).
Mappings can only have a data location of `storage` and thus are allowed for state variables, as storage reference types in functions, or as parameters for library functions. They cannot be used as parameters or return parameters of contract functions that are publicly visible. These restrictions are also true for arrays and structs that contain mappings.
You can mark state variables of mapping type as `public` and Solidity creates a [getter](https://docs.soliditylang.org/en/v0.8.30/contracts.html#visibility-and-getters) for you. The `KeyType` becomes a parameter with name `KeyName` (if specified) for the getter. If `ValueType` is a value type or a struct, the getter returns `ValueType` with name `ValueName` (if specified). If `ValueType` is an array or a mapping, the getter has one parameter for each `KeyType`, recursively.
In the example below, the `MappingExample` contract defines a public `balances` mapping, with the key type an `address`, and a value type a `uint`, mapping an Ethereum address to an unsigned integer value. As `uint` is a value type, the getter returns a value that matches the type, which you can see in the `MappingUser` contract that returns the value at the specified address.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgTWFwcGluZ0V4YW1wbGUgewogICAgbWFwcGluZyhhZGRyZXNzID0+IHVpbnQpIHB1YmxpYyBiYWxhbmNlczsKCiAgICBmdW5jdGlvbiB1cGRhdGUodWludCBuZXdCYWxhbmNlKSBwdWJsaWMgewogICAgICAgIGJhbGFuY2VzW21zZy5zZW5kZXJdID0gbmV3QmFsYW5jZTsKICAgIH0KfQoKY29udHJhY3QgTWFwcGluZ1VzZXIgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgTWFwcGluZ0V4YW1wbGUgbSA9IG5ldyBNYXBwaW5nRXhhbXBsZSgpOwogICAgICAgIG0udXBkYXRlKDEwMCk7CiAgICAgICAgcmV0dXJuIG0uYmFsYW5jZXMoYWRkcmVzcyh0aGlzKSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract MappingExample {
 mapping(address \=> uint) public balances;
 function update(uint newBalance) public {
 balances\[msg.sender\] \= newBalance;
 }
}
contract MappingUser {
 function f() public returns (uint) {
 MappingExample m \= new MappingExample();
 m.update(100);
 return m.balances(address(this));
 }
}
The example below is a simplified version of an [ERC20 token](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol). `_allowances` is an example of a mapping type inside another mapping type.
In the example below, the optional `KeyName` and `ValueName` are provided for the mapping. It does not affect any contract functionality or bytecode, it only sets the `name` field for the inputs and outputs in the ABI for the mapping’s getter.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTg7Cgpjb250cmFjdCBNYXBwaW5nRXhhbXBsZVdpdGhOYW1lcyB7CiAgICBtYXBwaW5nKGFkZHJlc3MgdXNlciA9PiB1aW50IGJhbGFuY2UpIHB1YmxpYyBiYWxhbmNlczsKCiAgICBmdW5jdGlvbiB1cGRhdGUodWludCBuZXdCYWxhbmNlKSBwdWJsaWMgewogICAgICAgIGJhbGFuY2VzW21zZy5zZW5kZXJdID0gbmV3QmFsYW5jZTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.18;
contract MappingExampleWithNames {
 mapping(address user \=> uint balance) public balances;
 function update(uint newBalance) public {
 balances\[msg.sender\] \= newBalance;
 }
}
The example below uses `_allowances` to record the amount someone else is allowed to withdraw from your account.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCmNvbnRyYWN0IE1hcHBpbmdFeGFtcGxlIHsKCiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gdWludDI1NikgcHJpdmF0ZSBfYmFsYW5jZXM7CiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gbWFwcGluZyhhZGRyZXNzID0+IHVpbnQyNTYpKSBwcml2YXRlIF9hbGxvd2FuY2VzOwoKICAgIGV2ZW50IFRyYW5zZmVyKGFkZHJlc3MgaW5kZXhlZCBmcm9tLCBhZGRyZXNzIGluZGV4ZWQgdG8sIHVpbnQyNTYgdmFsdWUpOwogICAgZXZlbnQgQXBwcm92YWwoYWRkcmVzcyBpbmRleGVkIG93bmVyLCBhZGRyZXNzIGluZGV4ZWQgc3BlbmRlciwgdWludDI1NiB2YWx1ZSk7CgogICAgZnVuY3Rpb24gYWxsb3dhbmNlKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3Mgc3BlbmRlcikgcHVibGljIHZpZXcgcmV0dXJucyAodWludDI1NikgewogICAgICAgIHJldHVybiBfYWxsb3dhbmNlc1tvd25lcl1bc3BlbmRlcl07CiAgICB9CgogICAgZnVuY3Rpb24gdHJhbnNmZXJGcm9tKGFkZHJlc3Mgc2VuZGVyLCBhZGRyZXNzIHJlY2lwaWVudCwgdWludDI1NiBhbW91bnQpIHB1YmxpYyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmVxdWlyZShfYWxsb3dhbmNlc1tzZW5kZXJdW21zZy5zZW5kZXJdID49IGFtb3VudCwgIkVSQzIwOiBBbGxvd2FuY2Ugbm90IGhpZ2ggZW5vdWdoLiIpOwogICAgICAgIF9hbGxvd2FuY2VzW3NlbmRlcl1bbXNnLnNlbmRlcl0gLT0gYW1vdW50OwogICAgICAgIF90cmFuc2ZlcihzZW5kZXIsIHJlY2lwaWVudCwgYW1vdW50KTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBhcHByb3ZlKGFkZHJlc3Mgc3BlbmRlciwgdWludDI1NiBhbW91bnQpIHB1YmxpYyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmVxdWlyZShzcGVuZGVyICE9IGFkZHJlc3MoMCksICJFUkMyMDogYXBwcm92ZSB0byB0aGUgemVybyBhZGRyZXNzIik7CgogICAgICAgIF9hbGxvd2FuY2VzW21zZy5zZW5kZXJdW3NwZW5kZXJdID0gYW1vdW50OwogICAgICAgIGVtaXQgQXBwcm92YWwobXNnLnNlbmRlciwgc3BlbmRlciwgYW1vdW50KTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBfdHJhbnNmZXIoYWRkcmVzcyBzZW5kZXIsIGFkZHJlc3MgcmVjaXBpZW50LCB1aW50MjU2IGFtb3VudCkgaW50ZXJuYWwgewogICAgICAgIHJlcXVpcmUoc2VuZGVyICE9IGFkZHJlc3MoMCksICJFUkMyMDogdHJhbnNmZXIgZnJvbSB0aGUgemVybyBhZGRyZXNzIik7CiAgICAgICAgcmVxdWlyZShyZWNpcGllbnQgIT0gYWRkcmVzcygwKSwgIkVSQzIwOiB0cmFuc2ZlciB0byB0aGUgemVybyBhZGRyZXNzIik7CiAgICAgICAgcmVxdWlyZShfYmFsYW5jZXNbc2VuZGVyXSA+PSBhbW91bnQsICJFUkMyMDogTm90IGVub3VnaCBmdW5kcy4iKTsKCiAgICAgICAgX2JhbGFuY2VzW3NlbmRlcl0gLT0gYW1vdW50OwogICAgICAgIF9iYWxhbmNlc1tyZWNpcGllbnRdICs9IGFtb3VudDsKICAgICAgICBlbWl0IFRyYW5zZmVyKHNlbmRlciwgcmVjaXBpZW50LCBhbW91bnQpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.22 <0.9.0;
contract MappingExample {
 mapping(address \=> uint256) private \_balances;
 mapping(address \=> mapping(address \=> uint256)) private \_allowances;
 event Transfer(address indexed from, address indexed to, uint256 value);
 event Approval(address indexed owner, address indexed spender, uint256 value);
 function allowance(address owner, address spender) public view returns (uint256) {
 return \_allowances\[owner\]\[spender\];
 }
 function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
 require(\_allowances\[sender\]\[msg.sender\] \>= amount, "ERC20: Allowance not high enough.");
 \_allowances\[sender\]\[msg.sender\] \-= amount;
 \_transfer(sender, recipient, amount);
 return true;
 }
 function approve(address spender, uint256 amount) public returns (bool) {
 require(spender != address(0), "ERC20: approve to the zero address");
 \_allowances\[msg.sender\]\[spender\] \= amount;
 emit Approval(msg.sender, spender, amount);
 return true;
 }
 function \_transfer(address sender, address recipient, uint256 amount) internal {
 require(sender != address(0), "ERC20: transfer from the zero address");
 require(recipient != address(0), "ERC20: transfer to the zero address");
 require(\_balances\[sender\] \>= amount, "ERC20: Not enough funds.");
 \_balances\[sender\] \-= amount;
 \_balances\[recipient\] += amount;
 emit Transfer(sender, recipient, amount);
 }
}
### Iterable Mappings[](#iterable-mappings "Link to this heading")
You cannot iterate over mappings, i.e. you cannot enumerate their keys. It is possible, though, to implement a data structure on top of them and iterate over that. For example, the code below implements an `IterableMapping` library that the `User` contract then adds data to, and the `sum` function iterates over to sum all the values.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguODsKCnN0cnVjdCBJbmRleFZhbHVlIHsgdWludCBrZXlJbmRleDsgdWludCB2YWx1ZTsgfQpzdHJ1Y3QgS2V5RmxhZyB7IHVpbnQga2V5OyBib29sIGRlbGV0ZWQ7IH0KCnN0cnVjdCBpdG1hcCB7CiAgICBtYXBwaW5nKHVpbnQgPT4gSW5kZXhWYWx1ZSkgZGF0YTsKICAgIEtleUZsYWdbXSBrZXlzOwogICAgdWludCBzaXplOwp9Cgp0eXBlIEl0ZXJhdG9yIGlzIHVpbnQ7CgpsaWJyYXJ5IEl0ZXJhYmxlTWFwcGluZyB7CiAgICBmdW5jdGlvbiBpbnNlcnQoaXRtYXAgc3RvcmFnZSBzZWxmLCB1aW50IGtleSwgdWludCB2YWx1ZSkgaW50ZXJuYWwgcmV0dXJucyAoYm9vbCByZXBsYWNlZCkgewogICAgICAgIHVpbnQga2V5SW5kZXggPSBzZWxmLmRhdGFba2V5XS5rZXlJbmRleDsKICAgICAgICBzZWxmLmRhdGFba2V5XS52YWx1ZSA9IHZhbHVlOwogICAgICAgIGlmIChrZXlJbmRleCA+IDApCiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIGVsc2UgewogICAgICAgICAgICBrZXlJbmRleCA9IHNlbGYua2V5cy5sZW5ndGg7CiAgICAgICAgICAgIHNlbGYua2V5cy5wdXNoKCk7CiAgICAgICAgICAgIHNlbGYuZGF0YVtrZXldLmtleUluZGV4ID0ga2V5SW5kZXggKyAxOwogICAgICAgICAgICBzZWxmLmtleXNba2V5SW5kZXhdLmtleSA9IGtleTsKICAgICAgICAgICAgc2VsZi5zaXplKys7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gcmVtb3ZlKGl0bWFwIHN0b3JhZ2Ugc2VsZiwgdWludCBrZXkpIGludGVybmFsIHJldHVybnMgKGJvb2wgc3VjY2VzcykgewogICAgICAgIHVpbnQga2V5SW5kZXggPSBzZWxmLmRhdGFba2V5XS5rZXlJbmRleDsKICAgICAgICBpZiAoa2V5SW5kZXggPT0gMCkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIGRlbGV0ZSBzZWxmLmRhdGFba2V5XTsKICAgICAgICBzZWxmLmtleXNba2V5SW5kZXggLSAxXS5kZWxldGVkID0gdHJ1ZTsKICAgICAgICBzZWxmLnNpemUgLS07CiAgICB9CgogICAgZnVuY3Rpb24gY29udGFpbnMoaXRtYXAgc3RvcmFnZSBzZWxmLCB1aW50IGtleSkgaW50ZXJuYWwgdmlldyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmV0dXJuIHNlbGYuZGF0YVtrZXldLmtleUluZGV4ID4gMDsKICAgIH0KCiAgICBmdW5jdGlvbiBpdGVyYXRlU3RhcnQoaXRtYXAgc3RvcmFnZSBzZWxmKSBpbnRlcm5hbCB2aWV3IHJldHVybnMgKEl0ZXJhdG9yKSB7CiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yU2tpcERlbGV0ZWQoc2VsZiwgMCk7CiAgICB9CgogICAgZnVuY3Rpb24gaXRlcmF0ZVZhbGlkKGl0bWFwIHN0b3JhZ2Ugc2VsZiwgSXRlcmF0b3IgaXRlcmF0b3IpIGludGVybmFsIHZpZXcgcmV0dXJucyAoYm9vbCkgewogICAgICAgIHJldHVybiBJdGVyYXRvci51bndyYXAoaXRlcmF0b3IpIDwgc2VsZi5rZXlzLmxlbmd0aDsKICAgIH0KCiAgICBmdW5jdGlvbiBpdGVyYXRlTmV4dChpdG1hcCBzdG9yYWdlIHNlbGYsIEl0ZXJhdG9yIGl0ZXJhdG9yKSBpbnRlcm5hbCB2aWV3IHJldHVybnMgKEl0ZXJhdG9yKSB7CiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yU2tpcERlbGV0ZWQoc2VsZiwgSXRlcmF0b3IudW53cmFwKGl0ZXJhdG9yKSArIDEpOwogICAgfQoKICAgIGZ1bmN0aW9uIGl0ZXJhdGVHZXQoaXRtYXAgc3RvcmFnZSBzZWxmLCBJdGVyYXRvciBpdGVyYXRvcikgaW50ZXJuYWwgdmlldyByZXR1cm5zICh1aW50IGtleSwgdWludCB2YWx1ZSkgewogICAgICAgIHVpbnQga2V5SW5kZXggPSBJdGVyYXRvci51bndyYXAoaXRlcmF0b3IpOwogICAgICAgIGtleSA9IHNlbGYua2V5c1trZXlJbmRleF0ua2V5OwogICAgICAgIHZhbHVlID0gc2VsZi5kYXRhW2tleV0udmFsdWU7CiAgICB9CgogICAgZnVuY3Rpb24gaXRlcmF0b3JTa2lwRGVsZXRlZChpdG1hcCBzdG9yYWdlIHNlbGYsIHVpbnQga2V5SW5kZXgpIHByaXZhdGUgdmlldyByZXR1cm5zIChJdGVyYXRvcikgewogICAgICAgIHdoaWxlIChrZXlJbmRleCA8IHNlbGYua2V5cy5sZW5ndGggJiYgc2VsZi5rZXlzW2tleUluZGV4XS5kZWxldGVkKQogICAgICAgICAgICBrZXlJbmRleCsrOwogICAgICAgIHJldHVybiBJdGVyYXRvci53cmFwKGtleUluZGV4KTsKICAgIH0KfQoKLy8gSG93IHRvIHVzZSBpdApjb250cmFjdCBVc2VyIHsKICAgIC8vIEp1c3QgYSBzdHJ1Y3QgaG9sZGluZyBvdXIgZGF0YS4KICAgIGl0bWFwIGRhdGE7CiAgICAvLyBBcHBseSBsaWJyYXJ5IGZ1bmN0aW9ucyB0byB0aGUgZGF0YSB0eXBlLgogICAgdXNpbmcgSXRlcmFibGVNYXBwaW5nIGZvciBpdG1hcDsKCiAgICAvLyBJbnNlcnQgc29tZXRoaW5nCiAgICBmdW5jdGlvbiBpbnNlcnQodWludCBrLCB1aW50IHYpIHB1YmxpYyByZXR1cm5zICh1aW50IHNpemUpIHsKICAgICAgICAvLyBUaGlzIGNhbGxzIEl0ZXJhYmxlTWFwcGluZy5pbnNlcnQoZGF0YSwgaywgdikKICAgICAgICBkYXRhLmluc2VydChrLCB2KTsKICAgICAgICAvLyBXZSBjYW4gc3RpbGwgYWNjZXNzIG1lbWJlcnMgb2YgdGhlIHN0cnVjdCwKICAgICAgICAvLyBidXQgd2Ugc2hvdWxkIHRha2UgY2FyZSBub3QgdG8gbWVzcyB3aXRoIHRoZW0uCiAgICAgICAgcmV0dXJuIGRhdGEuc2l6ZTsKICAgIH0KCiAgICAvLyBDb21wdXRlcyB0aGUgc3VtIG9mIGFsbCBzdG9yZWQgZGF0YS4KICAgIGZ1bmN0aW9uIHN1bSgpIHB1YmxpYyB2aWV3IHJldHVybnMgKHVpbnQgcykgewogICAgICAgIGZvciAoCiAgICAgICAgICAgIEl0ZXJhdG9yIGkgPSBkYXRhLml0ZXJhdGVTdGFydCgpOwogICAgICAgICAgICBkYXRhLml0ZXJhdGVWYWxpZChpKTsKICAgICAgICAgICAgaSA9IGRhdGEuaXRlcmF0ZU5leHQoaSkKICAgICAgICApIHsKICAgICAgICAgICAgKCwgdWludCB2YWx1ZSkgPSBkYXRhLml0ZXJhdGVHZXQoaSk7CiAgICAgICAgICAgIHMgKz0gdmFsdWU7CiAgICAgICAgfQogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.8;
struct IndexValue { uint keyIndex; uint value; }
struct KeyFlag { uint key; bool deleted; }
struct itmap {
 mapping(uint \=> IndexValue) data;
 KeyFlag\[\] keys;
 uint size;
}
type Iterator is uint;
library IterableMapping {
 function insert(itmap storage self, uint key, uint value) internal returns (bool replaced) {
 uint keyIndex \= self.data\[key\].keyIndex;
 self.data\[key\].value \= value;
 if (keyIndex \> 0)
 return true;
 else {
 keyIndex \= self.keys.length;
 self.keys.push();
 self.data\[key\].keyIndex \= keyIndex + 1;
 self.keys\[keyIndex\].key \= key;
 self.size++;
 return false;
 }
 }
 function remove(itmap storage self, uint key) internal returns (bool success) {
 uint keyIndex \= self.data\[key\].keyIndex;
 if (keyIndex \== 0)
 return false;
 delete self.data\[key\];
 self.keys\[keyIndex \- 1\].deleted \= true;
 self.size \--;
 }
 function contains(itmap storage self, uint key) internal view returns (bool) {
 return self.data\[key\].keyIndex \> 0;
 }
 function iterateStart(itmap storage self) internal view returns (Iterator) {
 return iteratorSkipDeleted(self, 0);
 }
 function iterateValid(itmap storage self, Iterator iterator) internal view returns (bool) {
 return Iterator.unwrap(iterator) < self.keys.length;
 }
 function iterateNext(itmap storage self, Iterator iterator) internal view returns (Iterator) {
 return iteratorSkipDeleted(self, Iterator.unwrap(iterator) + 1);
 }
 function iterateGet(itmap storage self, Iterator iterator) internal view returns (uint key, uint value) {
 uint keyIndex \= Iterator.unwrap(iterator);
 key \= self.keys\[keyIndex\].key;
 value \= self.data\[key\].value;
 }
 function iteratorSkipDeleted(itmap storage self, uint keyIndex) private view returns (Iterator) {
 while (keyIndex < self.keys.length && self.keys\[keyIndex\].deleted)
 keyIndex++;
 return Iterator.wrap(keyIndex);
 }
}
// How to use it
contract User {
 // Just a struct holding our data.
 itmap data;
 // Apply library functions to the data type.
 using IterableMapping for itmap;
 // Insert something
 function insert(uint k, uint v) public returns (uint size) {
 // This calls IterableMapping.insert(data, k, v)
 data.insert(k, v);
 // We can still access members of the struct,
 // but we should take care not to mess with them.
 return data.size;
 }
 // Computes the sum of all stored data.
 function sum() public view returns (uint s) {
 for (
 Iterator i \= data.iterateStart();
 data.iterateValid(i);
 i \= data.iterateNext(i)
 ) {
 (, uint value) \= data.iterateGet(i);
 s += value;
 }
 }
}
## Operators[](#operators "Link to this heading")
Arithmetic and bit operators can be applied even if the two operands do not have the same type. For example, you can compute `y = x + z`, where `x` is a `uint8` and `z` has the type `uint32`. In these cases, the following mechanism will be used to determine the type in which the operation is computed (this is important in case of overflow) and the type of the operator’s result:
1. If the type of the right operand can be implicitly converted to the type of the left operand, use the type of the left operand,
 
2. if the type of the left operand can be implicitly converted to the type of the right operand, use the type of the right operand,
 
3. otherwise, the operation is not allowed.
 
In case one of the operands is a [literal number](#rational-literals) it is first converted to its “mobile type”, which is the smallest type that can hold the value (unsigned types of the same bit-width are considered “smaller” than the signed types). If both are literal numbers, the operation is computed with effectively unlimited precision in that the expression is evaluated to whatever precision is necessary so that none is lost when the result is used with a non-literal type.
The operator’s result type is the same as the type the operation is performed in, except for comparison operators where the result is always `bool`.
The operators `**` (exponentiation), `<<` and `>>` use the type of the left operand for the operation and the result.
### Ternary Operator[](#ternary-operator "Link to this heading")
The ternary operator is used in expressions of the form `<expression> ? <trueExpression> : <falseExpression>`. It evaluates one of the latter two given expressions depending upon the result of the evaluation of the main `<expression>`. If `<expression>` evaluates to `true`, then `<trueExpression>` will be evaluated, otherwise `<falseExpression>` is evaluated.
The result of the ternary operator does not have a rational number type, even if all of its operands are rational number literals. The result type is determined from the types of the two operands in the same way as above, converting to their mobile type first if required.
As a consequence, `255 + (true ? 1 : 0)` will revert due to arithmetic overflow. The reason is that `(true ? 1 : 0)` is of `uint8` type, which forces the addition to be performed in `uint8` as well, and 256 exceeds the range allowed for this type.
Another consequence is that an expression like `1.5 + 1.5` is valid but `1.5 + (true ? 1.5 : 2.5)` is not. This is because the former is a rational expression evaluated in unlimited precision and only its final value matters. The latter involves a conversion of a fractional rational number to an integer, which is currently disallowed.
### Compound and Increment/Decrement Operators[](#compound-and-increment-decrement-operators "Link to this heading")
If `a` is an LValue (i.e. a variable or something that can be assigned to), the following operators are available as shorthands:
`a += e` is equivalent to `a = a + e`. The operators `-=`, `*=`, `/=`, `%=`, `|=`, `&=`, `^=`, `<<=` and `>>=` are defined accordingly. `a++` and `a--` are equivalent to `a += 1` / `a -= 1` but the expression itself still has the previous value of `a`. In contrast, `--a` and `++a` have the same effect on `a` but return the value after the change.
### delete[](#delete "Link to this heading")
`delete a` assigns the initial value for the type to `a`. I.e. for integers it is equivalent to `a = 0`, but it can also be used on arrays, where it assigns a dynamic array of length zero or a static array of the same length with all elements set to their initial value. `delete a[x]` deletes the item at index `x` of the array and leaves all other elements and the length of the array untouched. This especially means that it leaves a gap in the array. If you plan to remove items, a [mapping](#mapping-types) is probably a better choice.
For structs, it assigns a struct with all members reset. In other words, the value of `a` after `delete a` is the same as if `a` would be declared without assignment, with the following caveat:
`delete` has no effect on mappings (as the keys of mappings may be arbitrary and are generally unknown). So if you delete a struct, it will reset all members that are not mappings and also recurse into the members unless they are mappings. However, individual keys and what they map to can be deleted: If `a` is a mapping, then `delete a[x]` will delete the value stored at `x`.
It is important to note that `delete a` really behaves like an assignment to `a`, i.e. it stores a new object in `a`. This distinction is visible when `a` is reference variable: It will only reset `a` itself, not the value it referred to previously.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgRGVsZXRlRXhhbXBsZSB7CiAgICB1aW50IGRhdGE7CiAgICB1aW50W10gZGF0YUFycmF5OwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIHVpbnQgeCA9IGRhdGE7CiAgICAgICAgZGVsZXRlIHg7IC8vIHNldHMgeCB0byAwLCBkb2VzIG5vdCBhZmZlY3QgZGF0YQogICAgICAgIGRlbGV0ZSBkYXRhOyAvLyBzZXRzIGRhdGEgdG8gMCwgZG9lcyBub3QgYWZmZWN0IHgKICAgICAgICB1aW50W10gc3RvcmFnZSB5ID0gZGF0YUFycmF5OwogICAgICAgIGRlbGV0ZSBkYXRhQXJyYXk7IC8vIHRoaXMgc2V0cyBkYXRhQXJyYXkubGVuZ3RoIHRvIHplcm8sIGJ1dCBhcyB1aW50W10gaXMgYSBjb21wbGV4IG9iamVjdCwgYWxzbwogICAgICAgIC8vIHkgaXMgYWZmZWN0ZWQgd2hpY2ggaXMgYW4gYWxpYXMgdG8gdGhlIHN0b3JhZ2Ugb2JqZWN0CiAgICAgICAgLy8gT24gdGhlIG90aGVyIGhhbmQ6ICJkZWxldGUgeSIgaXMgbm90IHZhbGlkLCBhcyBhc3NpZ25tZW50cyB0byBsb2NhbCB2YXJpYWJsZXMKICAgICAgICAvLyByZWZlcmVuY2luZyBzdG9yYWdlIG9iamVjdHMgY2FuIG9ubHkgYmUgbWFkZSBmcm9tIGV4aXN0aW5nIHN0b3JhZ2Ugb2JqZWN0cy4KICAgICAgICBhc3NlcnQoeS5sZW5ndGggPT0gMCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract DeleteExample {
 uint data;
 uint\[\] dataArray;
 function f() public {
 uint x \= data;
 delete x; // sets x to 0, does not affect data
 delete data; // sets data to 0, does not affect x
 uint\[\] storage y \= dataArray;
 delete dataArray; // this sets dataArray.length to zero, but as uint\[\] is a complex object, also
 // y is affected which is an alias to the storage object
 // On the other hand: "delete y" is not valid, as assignments to local variables
 // referencing storage objects can only be made from existing storage objects.
 assert(y.length \== 0);
 }
}
### Order of Precedence of Operators[](#order-of-precedence-of-operators "Link to this heading")
The following is the order of precedence for operators, listed in order of evaluation.
Precedence
Description
Operator
_1_
Postfix increment and decrement
`++`, `--`
New expression
`new <typename>`
Array subscripting
`<array>[<index>]`
Member access
`<object>.<member>`
Function-like call
`<func>(<args...>)`
Parentheses
`(<statement>)`
_2_
Prefix increment and decrement
`++`, `--`
Unary minus
`-`
Unary operations
`delete`
Logical NOT
`!`
Bitwise NOT
`~`
_3_
Exponentiation
`**`
_4_
Multiplication, division and modulo
`*`, `/`, `%`
_5_
Addition and subtraction
`+`, `-`
_6_
Bitwise shift operators
`<<`, `>>`
_7_
Bitwise AND
`&`
_8_
Bitwise XOR
`^`
_9_
Bitwise OR
`|`
_10_
Inequality operators
`<`, `>`, `<=`, `>=`
_11_
Equality operators
`==`, `!=`
_12_
Logical AND
`&&`
_13_
Logical OR
`||`
_14_
Ternary operator
`<conditional> ? <if-true> : <if-false>`
Assignment operators
`=`, `|=`, `^=`, `&=`, `<<=`, `>>=`, `+=`, `-=`, `*=`, `/=`, `%=`
_15_
Comma operator
`,`
## Conversions between Elementary Types[](#conversions-between-elementary-types "Link to this heading")
### Implicit Conversions[](#implicit-conversions "Link to this heading")
An implicit type conversion is automatically applied by the compiler in some cases during assignments, when passing arguments to functions and when applying operators. In general, an implicit conversion between value-types is possible if it makes sense semantically and no information is lost.
For example, `uint8` is convertible to `uint16` and `int128` to `int256`, but `int8` is not convertible to `uint256`, because `uint256` cannot hold values such as `-1`.
If an operator is applied to different types, the compiler tries to implicitly convert one of the operands to the type of the other (the same is true for assignments). This means that operations are always performed in the type of one of the operands.
For more details about which implicit conversions are possible, please consult the sections about the types themselves.
In the example below, `y` and `z`, the operands of the addition, do not have the same type, but `uint8` can be implicitly converted to `uint16` and not vice-versa. Because of that, `y` is converted to the type of `z` before the addition is performed in the `uint16` type. The resulting type of the expression `y + z` is `uint16`. Because it is assigned to a variable of type `uint32` another implicit conversion is performed after the addition.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=dWludDggeTsKdWludDE2IHo7CnVpbnQzMiB4ID0geSArIHo7)
uint8 y;
uint16 z;
uint32 x \= y + z;
### Explicit Conversions[](#explicit-conversions "Link to this heading")
If the compiler does not allow implicit conversion but you are confident a conversion will work, an explicit type conversion is sometimes possible. This may result in unexpected behavior and allows you to bypass some security features of the compiler, so be sure to test that the result is what you want and expect!
Take the following example that converts a negative `int` to a `uint`:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=aW50ICB5ID0gLTM7CnVpbnQgeCA9IHVpbnQoeSk7)
int y \= \-3;
uint x \= uint(y);
At the end of this code snippet, `x` will have the value `0xfffff..fd` (64 hex characters), which is -3 in the two’s complement representation of 256 bits.
If an integer is explicitly converted to a smaller type, higher-order bits are cut off:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=dWludDMyIGEgPSAweDEyMzQ1Njc4Owp1aW50MTYgYiA9IHVpbnQxNihhKTsgLy8gYiB3aWxsIGJlIDB4NTY3OCBub3c=)
uint32 a \= 0x12345678;
uint16 b \= uint16(a); // b will be 0x5678 now
If an integer is explicitly converted to a larger type, it is padded on the left (i.e., at the higher order end). The result of the conversion will compare equal to the original integer:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=dWludDE2IGEgPSAweDEyMzQ7CnVpbnQzMiBiID0gdWludDMyKGEpOyAvLyBiIHdpbGwgYmUgMHgwMDAwMTIzNCBub3cKYXNzZXJ0KGEgPT0gYik7)
uint16 a \= 0x1234;
uint32 b \= uint32(a); // b will be 0x00001234 now
assert(a \== b);
Fixed-size bytes types behave differently during conversions. They can be thought of as sequences of individual bytes and converting to a smaller type will cut off the sequence:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ynl0ZXMyIGEgPSAweDEyMzQ7CmJ5dGVzMSBiID0gYnl0ZXMxKGEpOyAvLyBiIHdpbGwgYmUgMHgxMg==)
bytes2 a \= 0x1234;
bytes1 b \= bytes1(a); // b will be 0x12
If a fixed-size bytes type is explicitly converted to a larger type, it is padded on the right. Accessing the byte at a fixed index will result in the same value before and after the conversion (if the index is still in range):
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ynl0ZXMyIGEgPSAweDEyMzQ7CmJ5dGVzNCBiID0gYnl0ZXM0KGEpOyAvLyBiIHdpbGwgYmUgMHgxMjM0MDAwMAphc3NlcnQoYVswXSA9PSBiWzBdKTsKYXNzZXJ0KGFbMV0gPT0gYlsxXSk7)
bytes2 a \= 0x1234;
bytes4 b \= bytes4(a); // b will be 0x12340000
assert(a\[0\] \== b\[0\]);
assert(a\[1\] \== b\[1\]);
Since integers and fixed-size byte arrays behave differently when truncating or padding, explicit conversions between integers and fixed-size byte arrays are only allowed, if both have the same size. If you want to convert between integers and fixed-size byte arrays of different size, you have to use intermediate conversions that make the desired truncation and padding rules explicit:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ynl0ZXMyIGEgPSAweDEyMzQ7CnVpbnQzMiBiID0gdWludDE2KGEpOyAvLyBiIHdpbGwgYmUgMHgwMDAwMTIzNAp1aW50MzIgYyA9IHVpbnQzMihieXRlczQoYSkpOyAvLyBjIHdpbGwgYmUgMHgxMjM0MDAwMAp1aW50OCBkID0gdWludDgodWludDE2KGEpKTsgLy8gZCB3aWxsIGJlIDB4MzQKdWludDggZSA9IHVpbnQ4KGJ5dGVzMShhKSk7IC8vIGUgd2lsbCBiZSAweDEy)
bytes2 a \= 0x1234;
uint32 b \= uint16(a); // b will be 0x00001234
uint32 c \= uint32(bytes4(a)); // c will be 0x12340000
uint8 d \= uint8(uint16(a)); // d will be 0x34
uint8 e \= uint8(bytes1(a)); // e will be 0x12
`bytes` arrays and `bytes` calldata slices can be converted explicitly to fixed bytes types (`bytes1`/…/`bytes32`). In case the array is longer than the target fixed bytes type, truncation at the end will happen. If the array is shorter than the target type, it will be padded with zeros at the end.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNTsKCmNvbnRyYWN0IEMgewogICAgYnl0ZXMgcyA9ICJhYmNkZWZnaCI7CiAgICBmdW5jdGlvbiBmKGJ5dGVzIGNhbGxkYXRhIGMsIGJ5dGVzIG1lbW9yeSBtKSBwdWJsaWMgdmlldyByZXR1cm5zIChieXRlczE2LCBieXRlczMpIHsKICAgICAgICByZXF1aXJlKGMubGVuZ3RoID09IDE2LCAiIik7CiAgICAgICAgYnl0ZXMxNiBiID0gYnl0ZXMxNihtKTsgIC8vIGlmIGxlbmd0aCBvZiBtIGlzIGdyZWF0ZXIgdGhhbiAxNiwgdHJ1bmNhdGlvbiB3aWxsIGhhcHBlbgogICAgICAgIGIgPSBieXRlczE2KHMpOyAgLy8gcGFkZGVkIG9uIHRoZSByaWdodCwgc28gcmVzdWx0IGlzICJhYmNkZWZnaFwwXDBcMFwwXDBcMFwwXDAiCiAgICAgICAgYnl0ZXMzIGIxID0gYnl0ZXMzKHMpOyAvLyB0cnVuY2F0ZWQsIGIxIGVxdWFscyB0byAiYWJjIgogICAgICAgIGIgPSBieXRlczE2KGNbOjhdKTsgIC8vIGFsc28gcGFkZGVkIHdpdGggemVyb3MKICAgICAgICByZXR1cm4gKGIsIGIxKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.5;
contract C {
 bytes s \= "abcdefgh";
 function f(bytes calldata c, bytes memory m) public view returns (bytes16, bytes3) {
 require(c.length \== 16, "");
 bytes16 b \= bytes16(m); // if length of m is greater than 16, truncation will happen
 b \= bytes16(s); // padded on the right, so result is "abcdefgh\\0\\0\\0\\0\\0\\0\\0\\0"
 bytes3 b1 \= bytes3(s); // truncated, b1 equals to "abc"
 b \= bytes16(c\[:8\]); // also padded with zeros
 return (b, b1);
 }
}
## Conversions between Literals and Elementary Types[](#conversions-between-literals-and-elementary-types "Link to this heading")
### Integer Types[](#integer-types "Link to this heading")
Decimal and hexadecimal number literals can be implicitly converted to any integer type that is large enough to represent it without truncation:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=dWludDggYSA9IDEyOyAvLyBmaW5lCnVpbnQzMiBiID0gMTIzNDsgLy8gZmluZQp1aW50MTYgYyA9IDB4MTIzNDU2OyAvLyBmYWlscywgc2luY2UgaXQgd291bGQgaGF2ZSB0byB0cnVuY2F0ZSB0byAweDM0NTY=)
uint8 a \= 12; // fine
uint32 b \= 1234; // fine
uint16 c \= 0x123456; // fails, since it would have to truncate to 0x3456
Note
Prior to version 0.8.0, any decimal or hexadecimal number literals could be explicitly converted to an integer type. From 0.8.0, such explicit conversions are as strict as implicit conversions, i.e., they are only allowed if the literal fits in the resulting range.
### Fixed-Size Byte Arrays[](#index-34 "Link to this heading")
Decimal number literals cannot be implicitly converted to fixed-size byte arrays. Hexadecimal number literals can be, but only if the number of hex digits exactly fits the size of the bytes type. As an exception both decimal and hexadecimal literals which have a value of zero can be converted to any fixed-size bytes type:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ynl0ZXMyIGEgPSA1NDMyMTsgLy8gbm90IGFsbG93ZWQKYnl0ZXMyIGIgPSAweDEyOyAvLyBub3QgYWxsb3dlZApieXRlczIgYyA9IDB4MTIzOyAvLyBub3QgYWxsb3dlZApieXRlczIgZCA9IDB4MTIzNDsgLy8gZmluZQpieXRlczIgZSA9IDB4MDAxMjsgLy8gZmluZQpieXRlczQgZiA9IDA7IC8vIGZpbmUKYnl0ZXM0IGcgPSAweDA7IC8vIGZpbmU=)
bytes2 a \= 54321; // not allowed
bytes2 b \= 0x12; // not allowed
bytes2 c \= 0x123; // not allowed
bytes2 d \= 0x1234; // fine
bytes2 e \= 0x0012; // fine
bytes4 f \= 0; // fine
bytes4 g \= 0x0; // fine
String literals and hex string literals can be implicitly converted to fixed-size byte arrays, if their number of characters is less than or equal to the size of the bytes type:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ynl0ZXMyIGEgPSBoZXgiMTIzNCI7IC8vIGZpbmUKYnl0ZXMyIGIgPSAieHkiOyAvLyBmaW5lCmJ5dGVzMiBjID0gaGV4IjEyIjsgLy8gZmluZQpieXRlczIgZSA9ICJ4IjsgLy8gZmluZQpieXRlczIgZiA9ICJ4eXoiOyAvLyBub3QgYWxsb3dlZA==)
bytes2 a \= hex"1234"; // fine
bytes2 b \= "xy"; // fine
bytes2 c \= hex"12"; // fine
bytes2 e \= "x"; // fine
bytes2 f \= "xyz"; // not allowed
### Addresses[](#addresses "Link to this heading")
As described in [Address Literals](#address-literals), hex literals of the correct size that pass the checksum test are of `address` type. No other literals can be implicitly converted to the `address` type.
Explicit conversions to `address` are allowed only from `bytes20` and `uint160`.
An `address a` can be converted explicitly to `address payable` via `payable(a)`.
Note
Prior to version 0.8.0, it was possible to explicitly convert from any integer type (of any size, signed or unsigned) to `address` or `address payable`. Starting with 0.8.0 only conversion from `uint160` is allowed.

# [Solidity — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/index.html) 
 _https://docs.soliditylang.org/fr/latest/index.html_

Avertissement
You are reading a community translation of the Solidity documentation. The Solidity team can give no guarantees on the quality and accuracy of the translations provided. The English reference version is and will remain the only officially supported version by the Solidity team and will always be the most accurate and most up-to-date one. When in doubt, please always refer to the [English (original) documentation](https://docs.soliditylang.org/en/latest/).
Solidity est un langage orienté objet et de haut niveau pour la mise en œuvre de contrats intelligents. Les contrats intelligents sont des programmes qui régissent le comportement des comptes dans l’état Ethereum.
Solidity est un [langage d’accolades](https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Curly-bracket_languages). Il est influencé par le C++, le Python et le JavaScript, et est conçu pour cibler la machine virtuelle Ethereum (EVM). Vous pouvez trouver plus de détails sur les langages dont Solidity s’est inspiré dans la section sur les [influences linguistiques](https://docs.soliditylang.org/fr/latest/language-influences.html).
Solidity est typée statiquement, supporte l’héritage, les bibliothèques et les types complexes définis par l’utilisateur, entre autres caractéristiques.
Avec Solidity, vous pouvez créer des contrats pour des utilisations telles que le vote, le crowdfunding, les enchères à l’aveugle et les portefeuilles à signatures multiples.
Lorsque vous déployez des contrats, vous devez utiliser la dernière version publiée de Solidity. Sauf cas exceptionnel, seule la dernière version reçoit des [correctifs de sécurité](https://github.com/ethereum/solidity/security/policy#supported-versions). En outre, les changements de rupture ainsi que les nouvelles fonctionnalités sont introduites régulièrement. Nous utilisons actuellement un numéro de version 0.y.z [pour indiquer ce rythme rapide de changement](https://semver.org/#spec-item-4).
Avertissement
Solidity a récemment publié la version 0.8.x qui a introduit de nombreux changements. Assurez-vous de lire [la liste complète](https://docs.soliditylang.org/fr/latest/080-breaking-changes.html).
Les idées pour améliorer Solidity ou cette documentation sont toujours les bienvenues, lisez notre [guide des contributeurs](https://docs.soliditylang.org/fr/latest/contributing.html) pour plus de détails.
Astuce
Vous pouvez télécharger cette documentation au format PDF, HTML ou Epub en cliquant sur le menu déroulant des versions dans le coin inférieur gauche et en sélectionnant le format de téléchargement préféré.
## Pour commencer[](#pour-commencer "Lien permanent vers cette rubrique")
**1\. Comprendre les bases des contrats intelligents**
Si le concept des contrats intelligents est nouveau pour vous, nous vous recommandons de commencer par vous plonger dans la section « Introduction aux contrats intelligents ». dans la section « Introduction aux contrats intelligents », qui couvre :
* [Un exemple simple de smart contract](https://docs.soliditylang.org/fr/latest/introduction-to-smart-contracts.html#simple-smart-contract) écrit sous Solidity.
 
* [Les bases de la blockchain](https://docs.soliditylang.org/fr/latest/introduction-to-smart-contracts.html#blockchain-basics).
 
* [La Ethereum Virtual Machine](https://docs.soliditylang.org/fr/latest/introduction-to-smart-contracts.html#the-ethereum-virtual-machine).
 
**2\. Apprenez à connaître Solidity**
Une fois que vous êtes habitué aux bases, nous vous recommandons de lire les sections [« Solidity by Example »](https://docs.soliditylang.org/fr/latest/solidity-by-example.html) et « Description du langage » pour comprendre les concepts fondamentaux du langage.
**3\. Installer le compilateur Solidity**
Il existe plusieurs façons d’installer le compilateur Solidity. Il vous suffit de choisir votre option préférée et de suivre les étapes décrites sur la [installation page](https://docs.soliditylang.org/fr/latest/installing-solidity.html#installing-solidity).
Indication
Vous pouvez essayer des exemples de code directement dans votre navigateur grâce à la fonction [Remix IDE](https://remix.ethereum.org/). Remix est un IDE basé sur un navigateur web qui vous permet d’écrire, de déployer et d’administrer les smart contracts Solidity, sans avoir à sans avoir besoin d’installer Solidity localement.
Avertissement
Comme les humains écrivent des logiciels, ceux-ci peuvent comporter des bugs. Vous devez suivre les meilleures pratiques établies en matière de développement de logiciels lorsque vous écrivez vos contrats intelligents. Cela inclut la révision du code, les tests, les audits et les preuves de correction. Les utilisateurs de contrats intelligents sont parfois plus confiants dans le code que ses auteurs, et les blockchains et les contrats intelligents ont leurs propres problèmes à surveiller. Avant de travailler sur le code de production, assurez-vous de lire la section [Considérations de sécurité](https://docs.soliditylang.org/fr/latest/security-considerations.html#security-considerations).
**4\. En savoir plus**
Si vous souhaitez en savoir plus sur la création d’applications décentralisées sur Ethereum, le programme [Ethereum Developer Resources](https://ethereum.org/en/developers/) peut vous aider à trouver de la documentation générale sur Ethereum, ainsi qu’une large sélection de tutoriels, d’outils et de cadres de développement.
Si vous avez des questions, vous pouvez essayer de chercher des réponses ou de les poser sur [Ethereum StackExchange](https://ethereum.stackexchange.com/), ou sur notre [salon Gitter](https://gitter.im/ethereum/solidity/).
## Traductions[](#traductions "Lien permanent vers cette rubrique")
Des bénévoles de la communauté aident à traduire cette documentation en plusieurs langues. Leur degré d’exhaustivité et de mise à jour varie. La version anglaise est une référence.
Note
Nous avons récemment mis en place une nouvelle organisation GitHub et un nouveau flux de traduction pour aider à rationaliser les efforts de la communauté. Veuillez vous référer au [guide de traduction](https://github.com/solidity-docs/translation-guide) pour obtenir des informations sur la manière de contribuer aux traductions communautaires en cours.
* [Français](https://docs.soliditylang.org/fr/latest/)
 
* [Italien](https://github.com/damianoazzolini/solidity) (en cours)
 
* [Japonais](https://solidity-jp.readthedocs.io/)
 
* [Coréen](https://solidity-kr.readthedocs.io/) (en cours)
 
* [Russe](https://github.com/ethereum/wiki/wiki/%5BRussian%5D-%D0%A0%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE-%D0%BF%D0%BE-Solidity) (rather outdated)
 
* [Chinois simplifié](https://learnblockchain.cn/docs/solidity/) (en cours)
 
* [Espagnol](https://solidity-es.readthedocs.io/)
 
* [Turc](https://github.com/denizozzgur/Solidity_TR/blob/master/README.md) (partiel)

# [Style Guide — Solidity 0.4.26 documentation](https://docs.soliditylang.org/en/v0.4.26/style-guide.html) 
 _https://docs.soliditylang.org/en/v0.4.26/style-guide.html_

[Solidity](https://docs.soliditylang.org/en/v0.4.26/index.html)
## Introduction[¶](#introduction "Permalink to this headline")
This guide is intended to provide coding conventions for writing solidity code. This guide should be thought of as an evolving document that will change over time as useful conventions are found and old conventions are rendered obsolete.
Many projects will implement their own style guides. In the event of conflicts, project specific style guides take precedence.
The structure and many of the recommendations within this style guide were taken from python’s [pep8 style guide](https://www.python.org/dev/peps/pep-0008/).
The goal of this guide is _not_ to be the right way or the best way to write solidity code. The goal of this guide is _consistency_. A quote from python’s [pep8](https://www.python.org/dev/peps/pep-0008/#a-foolish-consistency-is-the-hobgoblin-of-little-minds) captures this concept well.
> A style guide is about consistency. Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is most important. But most importantly: know when to be inconsistent – sometimes the style guide just doesn’t apply. When in doubt, use your best judgement. Look at other examples and decide what looks best. And don’t hesitate to ask!
## Code Layout[¶](#code-layout "Permalink to this headline")
### Indentation[¶](#indentation "Permalink to this headline")
Use 4 spaces per indentation level.
### Tabs or Spaces[¶](#tabs-or-spaces "Permalink to this headline")
Spaces are the preferred indentation method.
Mixing tabs and spaces should be avoided.
### Blank Lines[¶](#blank-lines "Permalink to this headline")
Surround top level declarations in solidity source with two blank lines.
Yes:
contract A {
 ...
}
contract B {
 ...
}
contract C {
 ...
}
No:
contract A {
 ...
}
contract B {
 ...
}
contract C {
 ...
}
Within a contract surround function declarations with a single blank line.
Blank lines may be omitted between groups of related one-liners (such as stub functions for an abstract contract)
Yes:
contract A {
 function spam() public;
 function ham() public;
}
contract B is A {
 function spam() public {
 ...
 }
 function ham() public {
 ...
 }
}
No:
contract A {
 function spam() public {
 ...
 }
 function ham() public {
 ...
 }
}
### Maximum Line Length[¶](#maximum-line-length "Permalink to this headline")
Keeping lines under the [PEP 8 recommendation](https://www.python.org/dev/peps/pep-0008/#maximum-line-length) to a maximum of 79 (or 99) characters helps readers easily parse the code.
Wrapped lines should conform to the following guidelines.
1. The first argument should not be attached to the opening parenthesis.
2. One, and only one, indent should be used.
3. Each argument should fall on its own line.
4. The terminating element, `);`, should be placed on the final line by itself.
Function Calls
Yes:
thisFunctionCallIsReallyLong(
 longArgument1,
 longArgument2,
 longArgument3
);
No:
thisFunctionCallIsReallyLong(longArgument1,
 longArgument2,
 longArgument3
);
thisFunctionCallIsReallyLong(longArgument1,
 longArgument2,
 longArgument3
);
thisFunctionCallIsReallyLong(
 longArgument1, longArgument2,
 longArgument3
);
thisFunctionCallIsReallyLong(
longArgument1,
longArgument2,
longArgument3
);
thisFunctionCallIsReallyLong(
 longArgument1,
 longArgument2,
 longArgument3);
Assignment Statements
Yes:
thisIsALongNestedMapping\[being\]\[set\]\[to\_some\_value\] \= someFunction(
 argument1,
 argument2,
 argument3,
 argument4
);
No:
thisIsALongNestedMapping\[being\]\[set\]\[to\_some\_value\] \= someFunction(argument1,
 argument2,
 argument3,
 argument4);
Event Definitions and Event Emitters
Yes:
event LongAndLotsOfArgs(
 adress sender,
 adress recipient,
 uint256 publicKey,
 uint256 amount,
 bytes32\[\] options
);
LongAndLotsOfArgs(
 sender,
 recipient,
 publicKey,
 amount,
 options
);
No:
event LongAndLotsOfArgs(adress sender,
 adress recipient,
 uint256 publicKey,
 uint256 amount,
 bytes32\[\] options);
LongAndLotsOfArgs(sender,
 recipient,
 publicKey,
 amount,
 options);
### Source File Encoding[¶](#source-file-encoding "Permalink to this headline")
UTF-8 or ASCII encoding is preferred.
### Imports[¶](#imports "Permalink to this headline")
Import statements should always be placed at the top of the file.
Yes:
import "owned";
contract A {
 ...
}
contract B is owned {
 ...
}
No:
contract A {
 ...
}
import "owned";
contract B is owned {
 ...
}
### Order of Functions[¶](#order-of-functions "Permalink to this headline")
Ordering helps readers identify which functions they can call and to find the constructor and fallback definitions easier.
Functions should be grouped according to their visibility and ordered:
* constructor
* fallback function (if exists)
* external
* public
* internal
* private
Within a grouping, place the `view` and `pure` functions last.
Yes:
contract A {
 function A() public {
 ...
 }
 function() public {
 ...
 }
 // External functions
 // ...
 // External functions that are view
 // ...
 // External functions that are pure
 // ...
 // Public functions
 // ...
 // Internal functions
 // ...
 // Private functions
 // ...
}
No:
contract A {
 // External functions
 // ...
 // Private functions
 // ...
 // Public functions
 // ...
 function A() public {
 ...
 }
 function() public {
 ...
 }
 // Internal functions
 // ...
}
### Whitespace in Expressions[¶](#whitespace-in-expressions "Permalink to this headline")
Avoid extraneous whitespace in the following situations:
Immediately inside parenthesis, brackets or braces, with the exception of single line function declarations.
Yes:
spam(ham\[1\], Coin({name: "ham"}));
No:
spam( ham\[ 1 \], Coin( { name: "ham" } ) );
Exception:
function singleLine() public { spam(); }
Immediately before a comma, semicolon:
Yes:
function spam(uint i, Coin coin) public;
No:
function spam(uint i , Coin coin) public ;
More than one space around an assignment or other operator to align with
another:
Yes:
x \= 1;
y \= 2;
long\_variable \= 3;
No:
x \= 1;
y \= 2;
long\_variable \= 3;
Don’t include a whitespace in the fallback function:
Yes:
function() public {
 ...
}
No:
function () public {
 ...
}
### Control Structures[¶](#control-structures "Permalink to this headline")
The braces denoting the body of a contract, library, functions and structs should:
* open on the same line as the declaration
* close on their own line at the same indentation level as the beginning of the declaration.
* The opening brace should be proceeded by a single space.
Yes:
contract Coin {
 struct Bank {
 address owner;
 uint balance;
 }
}
No:
contract Coin
{
 struct Bank {
 address owner;
 uint balance;
 }
}
The same recommendations apply to the control structures `if`, `else`, `while`, and `for`.
Additionally there should be a single space between the control structures `if`, `while`, and `for` and the parenthetic block representing the conditional, as well as a single space between the conditional parenthetic block and the opening brace.
Yes:
if (...) {
 ...
}
for (...) {
 ...
}
No:
if (...)
{
 ...
}
while(...){
}
for (...) {
 ...;}
For control structures whose body contains a single statement, omitting the braces is ok _if_ the statement is contained on a single line.
Yes:
No:
if (x < 10)
 someArray.push(Coin({
 name: 'spam',
 value: 42
 }));
For `if` blocks which have an `else` or `else if` clause, the `else` should be placed on the same line as the `if`’s closing brace. This is an exception compared to the rules of other block-like structures.
Yes:
if (x < 3) {
 x += 1;
} else if (x \> 7) {
 x \-= 1;
} else {
 x \= 5;
}
if (x < 3)
 x += 1;
else
 x \-= 1;
No:
if (x < 3) {
 x += 1;
}
else {
 x \-= 1;
}
### Function Declaration[¶](#function-declaration "Permalink to this headline")
For short function declarations, it is recommended for the opening brace of the function body to be kept on the same line as the function declaration.
The closing brace should be at the same indentation level as the function declaration.
The opening brace should be preceded by a single space.
Yes:
function increment(uint x) public pure returns (uint) {
 return x + 1;
}
function increment(uint x) public pure onlyowner returns (uint) {
 return x + 1;
}
No:
function increment(uint x) public pure returns (uint)
{
 return x + 1;
}
function increment(uint x) public pure returns (uint){
 return x + 1;
}
function increment(uint x) public pure returns (uint) {
 return x + 1;
 }
function increment(uint x) public pure returns (uint) {
 return x + 1;}
You should explicitly label the visibility of all functions, including constructors.
Yes:
function explicitlyPublic(uint val) public {
 doSomething();
}
No:
function implicitlyPublic(uint val) {
 doSomething();
}
The visibility modifier for a function should come before any custom modifiers.
Yes:
function kill() public onlyowner {
 selfdestruct(owner);
}
No:
function kill() onlyowner public {
 selfdestruct(owner);
}
For long function declarations, it is recommended to drop each argument onto it’s own line at the same indentation level as the function body. The closing parenthesis and opening bracket should be placed on their own line as well at the same indentation level as the function declaration.
Yes:
function thisFunctionHasLotsOfArguments(
 address a,
 address b,
 address c,
 address d,
 address e,
 address f
)
 public
{
 doSomething();
}
No:
function thisFunctionHasLotsOfArguments(address a, address b, address c,
 address d, address e, address f) public {
 doSomething();
}
function thisFunctionHasLotsOfArguments(address a,
 address b,
 address c,
 address d,
 address e,
 address f) public {
 doSomething();
}
function thisFunctionHasLotsOfArguments(
 address a,
 address b,
 address c,
 address d,
 address e,
 address f) public {
 doSomething();
}
If a long function declaration has modifiers, then each modifier should be dropped to its own line.
Yes:
function thisFunctionNameIsReallyLong(address x, address y, address z)
 public
 onlyowner
 priced
 returns (address)
{
 doSomething();
}
function thisFunctionNameIsReallyLong(
 address x,
 address y,
 address z,
)
 public
 onlyowner
 priced
 returns (address)
{
 doSomething();
}
No:
function thisFunctionNameIsReallyLong(address x, address y, address z)
 public
 onlyowner
 priced
 returns (address) {
 doSomething();
}
function thisFunctionNameIsReallyLong(address x, address y, address z)
 public onlyowner priced returns (address)
{
 doSomething();
}
function thisFunctionNameIsReallyLong(address x, address y, address z)
 public
 onlyowner
 priced
 returns (address) {
 doSomething();
}
Multiline output parameters and return statements should follow the same style recommended for wrapping long lines found in the [Maximum Line Length](#maximum-line-length) section.
Yes:
function thisFunctionNameIsReallyLong(
 address a,
 address b,
 address c
)
 public
 returns (
 address someAddressName,
 uint256 LongArgument,
 uint256 Argument
 )
{
 doSomething()
 return (
 veryLongReturnArg1,
 veryLongReturnArg2,
 veryLongReturnArg3
 );
}
No:
function thisFunctionNameIsReallyLong(
 address a,
 address b,
 address c
)
 public
 returns (address someAddressName,
 uint256 LongArgument,
 uint256 Argument)
{
 doSomething()
 return (veryLongReturnArg1,
 veryLongReturnArg1,
 veryLongReturnArg1);
}
For constructor functions on inherited contracts whose bases require arguments, it is recommended to drop the base constructors onto new lines in the same manner as modifiers if the function declaration is long or hard to read.
Yes:
contract A is B, C, D {
 function A(uint param1, uint param2, uint param3, uint param4, uint param5)
 B(param1)
 C(param2, param3)
 D(param4)
 public
 {
 // do something with param5
 }
}
No:
contract A is B, C, D {
 function A(uint param1, uint param2, uint param3, uint param4, uint param5)
 B(param1)
 C(param2, param3)
 D(param4)
 public
 {
 // do something with param5
 }
}
contract A is B, C, D {
 function A(uint param1, uint param2, uint param3, uint param4, uint param5)
 B(param1)
 C(param2, param3)
 D(param4)
 public {
 // do something with param5
 }
}
When declaring short functions with a single statement, it is permissible to do it on a single line.
Permissible:
function shortFunction() public { doSomething(); }
These guidelines for function declarations are intended to improve readability. Authors should use their best judgement as this guide does not try to cover all possible permutations for function declarations.
### Variable Declarations[¶](#variable-declarations "Permalink to this headline")
Declarations of array variables should not have a space between the type and the brackets.
Yes:
No:
### Other Recommendations[¶](#other-recommendations "Permalink to this headline")
* Strings should be quoted with double-quotes instead of single-quotes.
Yes:
str \= "foo";
str \= "Hamlet says, 'To be or not to be...'";
No:
str \= 'bar';
str \= '"Be yourself; everyone else is already taken." -Oscar Wilde';
* Surround operators with a single space on either side.
Yes:
x \= 3;
x \= 100 / 10;
x += 3 + 4;
x |= y && z;
No:
x\=3;
x \= 100/10;
x += 3+4;
x |= y&&z;
* Operators with a higher priority than others can exclude surrounding whitespace in order to denote precedence. This is meant to allow for improved readability for complex statement. You should always use the same amount of whitespace on either side of an operator:
Yes:
x \= 2\*\*3 + 5;
x \= 2\*y + 3\*z;
x \= (a+b) \* (a\-b);
No:
x \= 2\*\* 3 + 5;
x \= y+z;
x +=1;
## Naming Conventions[¶](#naming-conventions "Permalink to this headline")
Naming conventions are powerful when adopted and used broadly. The use of different conventions can convey significant _meta_ information that would otherwise not be immediately available.
The naming recommendations given here are intended to improve the readability, and thus they are not rules, but rather guidelines to try and help convey the most information through the names of things.
Lastly, consistency within a codebase should always supercede any conventions outlined in this document.
### Naming Styles[¶](#naming-styles "Permalink to this headline")
To avoid confusion, the following names will be used to refer to different naming styles.
* `b` (single lowercase letter)
* `B` (single uppercase letter)
* `lowercase`
* `lower_case_with_underscores`
* `UPPERCASE`
* `UPPER_CASE_WITH_UNDERSCORES`
* `CapitalizedWords` (or CapWords)
* `mixedCase` (differs from CapitalizedWords by initial lowercase character!)
* `Capitalized_Words_With_Underscores`
Note
When using initialisms in CapWords, capitalize all the letters of the initialisms. Thus HTTPServerError is better than HttpServerError. When using initialisms is mixedCase, capitalize all the letters of the initialisms, except keep the first one lower case if it is the beginning of the name. Thus xmlHTTPRequest is better than XMLHTTPRequest.
### Names to Avoid[¶](#names-to-avoid "Permalink to this headline")
* `l` - Lowercase letter el
* `O` - Uppercase letter oh
* `I` - Uppercase letter eye
Never use any of these for single letter variable names. They are often indistinguishable from the numerals one and zero.
### Contract and Library Names[¶](#contract-and-library-names "Permalink to this headline")
Contracts and libraries should be named using the CapWords style. Examples: `SimpleToken`, `SmartBank`, `CertificateHashRepository`, `Player`.
### Struct Names[¶](#struct-names "Permalink to this headline")
Structs should be named using the CapWords style. Examples: `MyCoin`, `Position`, `PositionXY`.
### Event Names[¶](#event-names "Permalink to this headline")
Events should be named using the CapWords style. Examples: `Deposit`, `Transfer`, `Approval`, `BeforeTransfer`, `AfterTransfer`.
### Function Names[¶](#function-names "Permalink to this headline")
Functions other than constructors should use mixedCase. Examples: `getBalance`, `transfer`, `verifyOwner`, `addMember`, `changeOwner`.
### Function Argument Names[¶](#function-argument-names "Permalink to this headline")
Function arguments should use mixedCase. Examples: `initialSupply`, `account`, `recipientAddress`, `senderAddress`, `newOwner`.
When writing library functions that operate on a custom struct, the struct should be the first argument and should always be named `self`.
### Local and State Variable Names[¶](#local-and-state-variable-names "Permalink to this headline")
Use mixedCase. Examples: `totalSupply`, `remainingSupply`, `balancesOf`, `creatorAddress`, `isPreSale`, `tokenExchangeRate`.
### Constants[¶](#constants "Permalink to this headline")
Constants should be named with all capital letters with underscores separating words. Examples: `MAX_BLOCKS`, `TOKEN_NAME`, `TOKEN_TICKER`, `CONTRACT_VERSION`.
### Modifier Names[¶](#modifier-names "Permalink to this headline")
Use mixedCase. Examples: `onlyBy`, `onlyAfter`, `onlyDuringThePreSale`.
### Enums[¶](#enums "Permalink to this headline")
Enums, in the style of simple type declarations, should be named using the CapWords style. Examples: `TokenGroup`, `Frame`, `HashStyle`, `CharacterLocation`.
### Avoiding Naming Collisions[¶](#avoiding-naming-collisions "Permalink to this headline")
* `single_trailing_underscore_`
This convention is suggested when the desired name collides with that of a built-in or otherwise reserved name.
### General Recommendations[¶](#general-recommendations "Permalink to this headline")
TODO

# [Solidity by Example — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/solidity-by-example.html) 
 _https://docs.soliditylang.org/tr/latest/solidity-by-example.html_

## Oylama[](#oylama "Permalink to this heading")
Birazdan göreceğiniz sözleşme biraz karışık ancak Solidity’nin bir çok özelliğini görebilirsiniz. Göreceğiniz kontrat bir oylama kontratıdır. Elektronik oy kullanmada asıl problem oy hakkının doğru kişilere nasıl verildiği ve manipülasyonun nasıl engelleneceğidir. Bütün problemleri burada çözmeyeceğiz ama en azından yetkilendirilmiş kişilerle hem otomatik hem de şeffaf olarak nasıl oylama yapılacağını göstereceğiz.
Fikrimiz oy sandığı başına bir kontrat oluşturup her seçenek için kısa isimler vermek. Sonrasında kontratın yaratıcısı, aynı zamanda seçim başkanı oluyor, her cüzdana tek tek oy hakkı verecek.
Sonrasında cüzdan sahipleri kendilerine ya da güvendikleri bir kişiye oy verebilirler.
Oylamanın süresi dolduğunda, `winningProposal()` en yüksek oyu almış teklifi geri döndürecek.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwovLy8gQHRpdGxlIFlldGtpbGkgT3lsYW1hCmNvbnRyYWN0IEJhbGxvdCB7CiAgICAvLyBCdSBzb25yYXPEsW5kYSBkZcSfacWfa2VuIG9sYXJhawogICAgLy8ga3VsbGFuxLFsbWFrIGnDp2luIG9sdcWfdHVydWxtdcWfIGtvbXBsZWtzIGJpciB0w7xyCiAgICAvLyBUZWsgYmlyIHNlw6dtZW5pIHRlbXNpbCBlZGVyCiAgICBzdHJ1Y3QgVm90ZXIgewogICAgICAgIHVpbnQgd2VpZ2h0OyAvLyBveXVuIHNlw6dpbWRla2kgZXRraSBhxJ/EsXJsxLHEn8SxCiAgICAgICAgYm9vbCB2b3RlZDsgIC8vIHRydWUgaXNlIG95IGt1bGxhbsSxbG3EscWfdMSxcgogICAgICAgIGFkZHJlc3MgZGVsZWdhdGU7IC8vIHlldGtpbGVuZGlyaWxlY2VrIGtpxZ9pbmluIGFkcmVzaQogICAgICAgIHVpbnQgdm90ZTsgICAvLyBveSB2ZXJpbG1pxZ8gcHJvcG9zYWzEsW4gaW5kZXggbnVtYXJhc8SxCiAgICB9CgogICAgLy8gVGVrbGkgdGVrbGlmIHTDvHLDvAogICAgc3RydWN0IFByb3Bvc2FsIHsKICAgICAgICBieXRlczMyIG5hbWU7ICAgLy8ga8Sxc2EgaXNtaSAoMzIgYmF5dGEga2FkYXIpCiAgICAgICAgdWludCB2b3RlQ291bnQ7IC8vIHRvcGxhbSBveSBtaWt0YXLEsQogICAgfQoKICAgIGFkZHJlc3MgcHVibGljIGNoYWlycGVyc29uOyAvLyBzZcOnaW0gYmHFn2thbsSxbsSxbiBhZHJlc2kKCiAgICAvLyBIZXIgYWRyZXMgacOnaW4gYFZvdGVyYCAoT3kga3VsbGFuYW4ga2nFn2kpCiAgICAvLyBzdHJ1Y3TEsW5hIG1hcHBpbmcgKGXFn2xlxZ90aXJtZSkgZGXEn2nFn2tlbmkKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiBWb3RlcikgcHVibGljIHZvdGVyczsKCiAgICAvLyBgUHJvcG9zYWxgIHN0cnVjdGxhcsSxbmRhbiBvbHXFn2FuIGJpciBkaW5hbWlrIGRpemkgKGR5bmFtaWMgYXJyYXkpLgogICAgUHJvcG9zYWxbXSBwdWJsaWMgcHJvcG9zYWxzOwoKICAgIC8vLyBgcHJvcG9zYWxOYW1lc2BsZXJkZW4gYmlyaW5pIHNlw6dtZWsgacOnaW4gYmlyIG95IHNhbmTEscSfxLEgb2x1xZ90dXJ1ci4KICAgIGNvbnN0cnVjdG9yKGJ5dGVzMzJbXSBtZW1vcnkgcHJvcG9zYWxOYW1lcykgewogICAgICAgIGNoYWlycGVyc29uID0gbXNnLnNlbmRlcjsKICAgICAgICB2b3RlcnNbY2hhaXJwZXJzb25dLndlaWdodCA9IDE7CgogICAgICAgIC8vIEhlciB0ZWtsaWYgaXNtaSBpw6dpbiBiaXIgdGVrbGlmIG9iamVzaSBvbHXFn3R1cnVwCiAgICAgICAgLy8gZGl6aW5pbiAoYXJyYXkpIHNvbnVuYSBla2xlCiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgcHJvcG9zYWxOYW1lcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAvLyBgUHJvcG9zYWwoey4uLn0pYCBnZcOnaWNpIGJpciBQcm9wb3NhbCAoVGVrbGlmKQogICAgICAgICAgICAvLyBvYmplc2kgb2x1xZ90dXJ1ciB2ZSBgcHJvcG9zYWxzLnB1c2goLi4uKWAKICAgICAgICAgICAgLy8gb2JqZXlpIGBwcm9wb3NhbHNgIGRpemlzaW5pbiBzb251bmEgZWtsZXIuCiAgICAgICAgICAgIHByb3Bvc2Fscy5wdXNoKFByb3Bvc2FsKHsKICAgICAgICAgICAgICAgIG5hbWU6IHByb3Bvc2FsTmFtZXNbaV0sCiAgICAgICAgICAgICAgICB2b3RlQ291bnQ6IDAKICAgICAgICAgICAgfSkpOwogICAgICAgIH0KICAgIH0KCiAgICAvLyBgdm90ZXJgYSBidSBzYW5kxLFrdGEgb3kga3VsbGFubWEgeWV0a2lzaSB2ZXIuCiAgICAvLyBgY2hhaXJwZXJzb25gIGJ1IGZvbmtzaXlvbnUgw6dhxJ/EsXJhYmlsaXIuCiAgICBmdW5jdGlvbiBnaXZlUmlnaHRUb1ZvdGUoYWRkcmVzcyB2b3RlcikgZXh0ZXJuYWwgewogICAgICAgIC8vIEXEn2VyIGByZXF1aXJlYMSxbiBpbGsgYXJnw7xtYW7EsSBgZmFsc2VgCiAgICAgICAgLy8gZ2VsaXJzZSBpxZ9sZW0gaXB0YWwgb2x1ciB2ZSBFdGhlcgogICAgICAgIC8vIGhhcmNhbWFsYXLEsSBlc2tpIGhhbGluZSBnZWxpcgogICAgICAgIC8vIEVza2lkZW4gYnUgZHVydW1kYSBiw7x0w7xuIGdhcyBoYXJjYW7EsXJkxLEKICAgICAgICAvLyBhbWEgYXJ0xLFrIGhhcmNhbm3EsXlvci4KICAgICAgICAvLyDDh2/En3UgemFtYW4gZm9ua3NpeW9udW4gZG/En3J1IMOnYcSfcsSxbMSxcAogICAgICAgIC8vIMOnYcSfcsSxbG1hZMSxxJ/EsW7EsSBhbmxhbWFrIGnDp2luIGByZXF1aXJlYAogICAgICAgIC8vIGt1bGxhbsSxbMSxcnNhIGl5aSBvbHVyCiAgICAgICAgLy8gxLBraW5jaSBhcmfDvG1hbiBvbGFyYWsgbmV5aW4gaGF0YWzEsSBvbGR1xJ91bnUKICAgICAgICAvLyBhw6fEsWtsYXlhbiBiaXIgeWF6xLEgZ2lyaWxlYmlsaXIuCiAgICAgICAgcmVxdWlyZSgKICAgICAgICAgICAgbXNnLnNlbmRlciA9PSBjaGFpcnBlcnNvbiwKICAgICAgICAgICAgIlNhZGVjZSBjaGFpcnBlcnNvbiB5ZXRraSB2ZXJlYmlsaXIuIgogICAgICAgICk7CiAgICAgICAgcmVxdWlyZSgKICAgICAgICAgICAgIXZvdGVyc1t2b3Rlcl0udm90ZWQsCiAgICAgICAgICAgICJLacWfaSB6YXRlbiBveSBrdWxsYW5kxLEuIgogICAgICAgICk7CiAgICAgICAgcmVxdWlyZSh2b3RlcnNbdm90ZXJdLndlaWdodCA9PSAwKTsKICAgICAgICB2b3RlcnNbdm90ZXJdLndlaWdodCA9IDE7CiAgICB9CgogICAgLy8vIERlbGVnZSBgdG9gIGF0YS4KICAgIGZ1bmN0aW9uIGRlbGVnYXRlKGFkZHJlc3MgdG8pIGV4dGVybmFsIHsKICAgICAgICAvLyByZWZlcmFucyBhdGFyCiAgICAgICAgVm90ZXIgc3RvcmFnZSBzZW5kZXIgPSB2b3RlcnNbbXNnLnNlbmRlcl07CiAgICAgICAgcmVxdWlyZShzZW5kZXIud2VpZ2h0ICE9IDAsICJPeSB2ZXJtZSB5ZXRraW4geW9rIik7CiAgICAgICAgcmVxdWlyZSghc2VuZGVyLnZvdGVkLCAiWmF0ZW4gb3kga3VsbGFuZMSxbi4iKTsKCiAgICAgICAgcmVxdWlyZSh0byAhPSBtc2cuc2VuZGVyLCAiS2VuZGluaSB0ZW1zaWxjaSBnw7ZzdGVyZW1lenNpbi4iKTsKCiAgICAgICAgLy8gRGVsZWdlIGF0YW1hc8SxbsSxIGB0b2AgZGEgZGVsZWdlIGF0YW5kxLF5c2EKICAgICAgICAvLyBha3RhcsSxcgogICAgICAgIC8vIEdlbmVsZGUgYnUgdMO8ciBkw7ZuZ8O8bGVyIG9sZHVrw6dhIHRlaGxpa2VsaWRpciwKICAgICAgICAvLyDDp8O8bmvDvCBlxJ9lciDDp29rIGZhemxhIMOnYWzEscWfxLFybGFyc2EgYmxva3Rha2kKICAgICAgICAvLyBrdWxsYW7EsWxhYmlsaXIgZ2FzJ3RlbiBkYWhhIGZhemxhc8SxbmEgaWh0aXlhw6cgZHV5YWJpbGlyLgogICAgICAgIC8vIEJ1IGR1cnVtZGEsIGRlbGVnZSBhdGFtYSDDp2FsxLHFn21heWFjYWt0xLFyCiAgICAgICAgLy8gYW1hIGJhxZ9rYSBkdXJ1bWxhcmRhIGJ1IHTDvHIgZMO2bmfDvGxlcgogICAgICAgIC8vIGtvbnRyYXTEsW4gdGFtYW1peWxlIGtpdGxlbm1lc2luZSBzZWJlcCBvbGFiaWxpci4KICAgICAgICB3aGlsZSAodm90ZXJzW3RvXS5kZWxlZ2F0ZSAhPSBhZGRyZXNzKDApKSB7CiAgICAgICAgICAgIHRvID0gdm90ZXJzW3RvXS5kZWxlZ2F0ZTsKCiAgICAgICAgICAgIC8vIERlbGVnZSBhdGFtYWRhIGJpciBkw7ZuZ8O8IGJ1bGR1aywgYnVudSBpc3RlbWl5b3J1egogICAgICAgICAgICByZXF1aXJlKHRvICE9IG1zZy5zZW5kZXIsICJEZWxlZ2UgYXRhbWFkYSBkw7ZuZ8O8IGJ1bHVuZHUuIik7CiAgICAgICAgfQoKICAgICAgICBWb3RlciBzdG9yYWdlIGRlbGVnYXRlXyA9IHZvdGVyc1t0b107CgogICAgICAgIC8vIE95IGt1bGxhbmFuIGtpxZ9pIG95IGt1bGxhbmFtYXlhbiBracWfaWxlcmkgZGVsZWdlIGfDtnN0ZXJlbWV6LgogICAgICAgIHJlcXVpcmUoZGVsZWdhdGVfLndlaWdodCA+PSAxKTsKCiAgICAgICAgLy8gYHNlbmRlcmAgYmlyIHJlZmVyYW5zIG9sZHXEn3VuZGFuCiAgICAgICAgLy8gYHZvdGVyc1ttc2cuc2VuZGVyXWAgZGXEn2nFn2lyLgogICAgICAgIHNlbmRlci52b3RlZCA9IHRydWU7CiAgICAgICAgc2VuZGVyLmRlbGVnYXRlID0gdG87CgogICAgICAgIGlmIChkZWxlZ2F0ZV8udm90ZWQpIHsKICAgICAgICAgICAgLy8gRcSfZXIgZGVsZWdlIHphdGVuIG95bGFuZMSxeXNhCiAgICAgICAgICAgIC8vIG90b21hdGlrIG9sYXJhayBveWxhcmEgZWtsZW5pcgogICAgICAgICAgICBwcm9wb3NhbHNbZGVsZWdhdGVfLnZvdGVdLnZvdGVDb3VudCArPSBzZW5kZXIud2VpZ2h0OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8vIEXEn2VyIGRlbGVnZSBveWxhbm1hZMSxeXNhCiAgICAgICAgICAgIC8vIGHEn8SxcmzEscSfxLFuYSBla2xlbmlyLgogICAgICAgICAgICBkZWxlZ2F0ZV8ud2VpZ2h0ICs9IHNlbmRlci53ZWlnaHQ7CiAgICAgICAgfQogICAgfQoKICAgIC8vLyBPeSBrdWxsYW4gKHNhbmEgYXRhbm3EscWfIG95bGFyIGRhIGRhaGlsKQogICAgLy8vIHRla2xpZiBpc21pbmUgYHByb3Bvc2Fsc1twcm9wb3NhbF0ubmFtZWAuCiAgICBmdW5jdGlvbiB2b3RlKHVpbnQgcHJvcG9zYWwpIGV4dGVybmFsIHsKICAgICAgICBWb3RlciBzdG9yYWdlIHNlbmRlciA9IHZvdGVyc1ttc2cuc2VuZGVyXTsKICAgICAgICByZXF1aXJlKHNlbmRlci53ZWlnaHQgIT0gMCwgIk95IGt1bGxhbm1hIHlldGtpc2kgeW9rIik7CiAgICAgICAgcmVxdWlyZSghc2VuZGVyLnZvdGVkLCAiQWxyZWFkeSB2b3RlZC4iKTsKICAgICAgICBzZW5kZXIudm90ZWQgPSB0cnVlOwogICAgICAgIHNlbmRlci52b3RlID0gcHJvcG9zYWw7CgogICAgICAgIC8vIEXEn2VyIGBwcm9wb3NhbGAgZGl6aW5pbiBpw6dpbmRlIHlva3NhLAogICAgICAgIC8vIG90b21hdGlrIG9sYXJhayBiw7x0w7xuIGRlxJ9pxZ9pa2xpa2xlcgogICAgICAgIC8vIGVza2kgaGFsaW5lIGTDtm5lcgogICAgICAgIHByb3Bvc2Fsc1twcm9wb3NhbF0udm90ZUNvdW50ICs9IHNlbmRlci53ZWlnaHQ7CiAgICB9CgogICAgLy8vIEBkZXYgQsO8dMO8biBveWxhcsSxIGhlc2FwbGF5YXJhayBrYXphbmFuCiAgICAvLy8gdGVrbGlmaSBoZXNhcGxhcgogICAgZnVuY3Rpb24gd2lubmluZ1Byb3Bvc2FsKCkgcHVibGljIHZpZXcKICAgICAgICAgICAgcmV0dXJucyAodWludCB3aW5uaW5nUHJvcG9zYWxfKQogICAgewogICAgICAgIHVpbnQgd2lubmluZ1ZvdGVDb3VudCA9IDA7CiAgICAgICAgZm9yICh1aW50IHAgPSAwOyBwIDwgcHJvcG9zYWxzLmxlbmd0aDsgcCsrKSB7CiAgICAgICAgICAgIGlmIChwcm9wb3NhbHNbcF0udm90ZUNvdW50ID4gd2lubmluZ1ZvdGVDb3VudCkgewogICAgICAgICAgICAgICAgd2lubmluZ1ZvdGVDb3VudCA9IHByb3Bvc2Fsc1twXS52b3RlQ291bnQ7CiAgICAgICAgICAgICAgICB3aW5uaW5nUHJvcG9zYWxfID0gcDsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH0KCiAgICAvLyBLYXphbmFuIHRla2xpZmluIGluZGVrcyBudW1hcmFzxLFuxLEgYnVsbWFrIGnDp2luCiAgICAvLyB3aW5uaW5nUHJvcG9zYWwoKSBmb25rc2l5b251bnUgw6dhxJ/EsXLEsXIgYXJkxLFuZGFuCiAgICAvLyBrYXphbmFuIHRla2xpZmluIGFkxLFuxLEgZMO2bmTDvHLDvHIuCiAgICBmdW5jdGlvbiB3aW5uZXJOYW1lKCkgZXh0ZXJuYWwgdmlldwogICAgICAgICAgICByZXR1cm5zIChieXRlczMyIHdpbm5lck5hbWVfKQogICAgewogICAgICAgIHdpbm5lck5hbWVfID0gcHJvcG9zYWxzW3dpbm5pbmdQcm9wb3NhbCgpXS5uYW1lOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
/// @title Yetkili Oylama
contract Ballot {
 // Bu sonrasında değişken olarak
 // kullanılmak için oluşturulmuş kompleks bir tür
 // Tek bir seçmeni temsil eder
 struct Voter {
 uint weight; // oyun seçimdeki etki ağırlığı
 bool voted; // true ise oy kullanılmıştır
 address delegate; // yetkilendirilecek kişinin adresi
 uint vote; // oy verilmiş proposalın index numarası
 }
 // Tekli teklif türü
 struct Proposal {
 bytes32 name; // kısa ismi (32 bayta kadar)
 uint voteCount; // toplam oy miktarı
 }
 address public chairperson; // seçim başkanının adresi
 // Her adres için \`Voter\` (Oy kullanan kişi)
 // structına mapping (eşleştirme) değişkeni
 mapping(address \=> Voter) public voters;
 // \`Proposal\` structlarından oluşan bir dinamik dizi (dynamic array).
 Proposal\[\] public proposals;
 /// \`proposalNames\`lerden birini seçmek için bir oy sandığı oluşturur.
 constructor(bytes32\[\] memory proposalNames) {
 chairperson \= msg.sender;
 voters\[chairperson\].weight \= 1;
 // Her teklif ismi için bir teklif objesi oluşturup
 // dizinin (array) sonuna ekle
 for (uint i \= 0; i < proposalNames.length; i++) {
 // \`Proposal({...})\` geçici bir Proposal (Teklif)
 // objesi oluşturur ve \`proposals.push(...)\`
 // objeyi \`proposals\` dizisinin sonuna ekler.
 proposals.push(Proposal({
 name: proposalNames\[i\],
 voteCount: 0
 }));
 }
 }
 // \`voter\`a bu sandıkta oy kullanma yetkisi ver.
 // \`chairperson\` bu fonksiyonu çağırabilir.
 function giveRightToVote(address voter) external {
 // Eğer \`require\`ın ilk argümanı \`false\`
 // gelirse işlem iptal olur ve Ether
 // harcamaları eski haline gelir
 // Eskiden bu durumda bütün gas harcanırdı
 // ama artık harcanmıyor.
 // Çoğu zaman fonksiyonun doğru çağrılıp
 // çağrılmadığını anlamak için \`require\`
 // kullanılırsa iyi olur
 // İkinci argüman olarak neyin hatalı olduğunu
 // açıklayan bir yazı girilebilir.
 require(
 msg.sender \== chairperson,
 "Sadece chairperson yetki verebilir."
 );
 require(
 !voters\[voter\].voted,
 "Kişi zaten oy kullandı."
 );
 require(voters\[voter\].weight \== 0);
 voters\[voter\].weight \= 1;
 }
 /// Delege \`to\` ata.
 function delegate(address to) external {
 // referans atar
 Voter storage sender \= voters\[msg.sender\];
 require(sender.weight != 0, "Oy verme yetkin yok");
 require(!sender.voted, "Zaten oy kullandın.");
 require(to != msg.sender, "Kendini temsilci gösteremezsin.");
 // Delege atamasını \`to\` da delege atandıysa
 // aktarır
 // Genelde bu tür döngüler oldukça tehlikelidir,
 // çünkü eğer çok fazla çalışırlarsa bloktaki
 // kullanılabilir gas'ten daha fazlasına ihtiyaç duyabilir.
 // Bu durumda, delege atama çalışmayacaktır
 // ama başka durumlarda bu tür döngüler
 // kontratın tamamiyle kitlenmesine sebep olabilir.
 while (voters\[to\].delegate != address(0)) {
 to \= voters\[to\].delegate;
 // Delege atamada bir döngü bulduk, bunu istemiyoruz
 require(to != msg.sender, "Delege atamada döngü bulundu.");
 }
 Voter storage delegate\_ \= voters\[to\];
 // Oy kullanan kişi oy kullanamayan kişileri delege gösteremez.
 require(delegate\_.weight \>= 1);
 // \`sender\` bir referans olduğundan
 // \`voters\[msg.sender\]\` değişir.
 sender.voted \= true;
 sender.delegate \= to;
 if (delegate\_.voted) {
 // Eğer delege zaten oylandıysa
 // otomatik olarak oylara eklenir
 proposals\[delegate\_.vote\].voteCount += sender.weight;
 } else {
 // Eğer delege oylanmadıysa
 // ağırlığına eklenir.
 delegate\_.weight += sender.weight;
 }
 }
 /// Oy kullan (sana atanmış oylar da dahil)
 /// teklif ismine \`proposals\[proposal\].name\`.
 function vote(uint proposal) external {
 Voter storage sender \= voters\[msg.sender\];
 require(sender.weight != 0, "Oy kullanma yetkisi yok");
 require(!sender.voted, "Already voted.");
 sender.voted \= true;
 sender.vote \= proposal;
 // Eğer \`proposal\` dizinin içinde yoksa,
 // otomatik olarak bütün değişiklikler
 // eski haline döner
 proposals\[proposal\].voteCount += sender.weight;
 }
 /// @dev Bütün oyları hesaplayarak kazanan
 /// teklifi hesaplar
 function winningProposal() public view
 returns (uint winningProposal\_)
 {
 uint winningVoteCount \= 0;
 for (uint p \= 0; p < proposals.length; p++) {
 if (proposals\[p\].voteCount \> winningVoteCount) {
 winningVoteCount \= proposals\[p\].voteCount;
 winningProposal\_ \= p;
 }
 }
 }
 // Kazanan teklifin indeks numarasını bulmak için
 // winningProposal() fonksiyonunu çağırır ardından
 // kazanan teklifin adını döndürür.
 function winnerName() external view
 returns (bytes32 winnerName\_)
 {
 winnerName\_ \= proposals\[winningProposal()\].name;
 }
}
### Olası İyileştirmeler[](#olasi-iyilestirmeler "Permalink to this heading")
Şu an tüm katılımcılara yetki vermek için çok sayıda işlem gerçekleştirilmesi gerekiyor. Daha iyi bir yöntem düşünebiliyor musunuz?
## Gizli İhale[](#gizli-ihale "Permalink to this heading")
Bu bölümde Ethereum’da tamamiyle gizli bir ihale kontratı oluşturmanın ne kadar kolay olduğunu göstereceğiz. Önce herkesin başkalarının tekliflerini görebildiği açık bir ihale kontratı oluşturup sonrasında ondan teklif süresi dolana kadar kimsenin başkasının teklifini göremediği gizli bir ihale kontratı oluşturacağız.
### Basit Açık İhale[](#basit-acik-ihale "Permalink to this heading")
Aşağıdaki basit ihale kontratındaki fikir herkes teklif sürecinde teklfilerini gönderebilcek. Teklifler yanında teklif verenlerin tekliflerine sadık kalmaları için teklifte belirtilen parayı da içerecek. Eğer en yüksek teklif geçilirse önceki en yüksek teklifi veren kişi parasını geri alacak. Teklif süreci bittiğinde kontratlar kendi kendilerine çalışamadıklarından hak sahibi parasını almak için kontratı manuel olarak çağırılmalıdır.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKY29udHJhY3QgU2ltcGxlQXVjdGlvbiB7CiAgICAvLyDEsGhhbGVuaW4gcGFyYW1ldHJlbGVyaS4gU8O8cmVsZXIgdW5peCB6YW1hbiBkYW1nYXPEsQogICAgLy8gKDE5NzAtMDEtMDEnZGVuIGl0aWJhcmVuIHNhbml5ZWxlcikgeWEgZGEgc2FuaXllCiAgICAvLyBjaW5zaW5kZW4gbmUga2FkYXIgc8O8cmVjZcSfaS4KICAgIGFkZHJlc3MgcGF5YWJsZSBwdWJsaWMgYmVuZWZpY2lhcnk7CiAgICB1aW50IHB1YmxpYyBhdWN0aW9uRW5kVGltZTsKCiAgICAvLyDEsGhhbGVuaW4gxZ91IGFuIGtpIGR1cnVtdQogICAgYWRkcmVzcyBwdWJsaWMgaGlnaGVzdEJpZGRlcjsKICAgIHVpbnQgcHVibGljIGhpZ2hlc3RCaWQ7CgogICAgLy8gw5ZuY2VraSB0ZWtsaWZsZXJkZW4gcGFyYSDDp2VrbWV5ZSBpemluIHZlcmlsZW5sZXIKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50KSBwZW5kaW5nUmV0dXJuczsKCiAgICAvLyBFbiBzb24gYHRydWVgeWEgw6dldmlyLCBoZXJoYW5naSBiaXIgZGXEn2nFn2lrbGlrIHlhcMSxbG1hc8SxbsSxIGVuZ2VsbGVyCiAgICAvLyB2YXJzYXnEsWxhbiBvbGFyYWsgYGZhbHNlYCB0YW7EsW1sYW7EsXIuCiAgICBib29sIGVuZGVkOwoKICAgIC8vIERlxJ9pxZ9pa2xpa2xlcmRlIHlhecSxbmxhbmFjYWsgRXZlbnQnbGVyCiAgICBldmVudCBIaWdoZXN0QmlkSW5jcmVhc2VkKGFkZHJlc3MgYmlkZGVyLCB1aW50IGFtb3VudCk7CiAgICBldmVudCBBdWN0aW9uRW5kZWQoYWRkcmVzcyB3aW5uZXIsIHVpbnQgYW1vdW50KTsKCiAgICAvLyBCYcWfYXLEsXPEsXpsYXLEsSBhw6fEsWtsYXlhbiBoYXRhbGFyCgogICAgLy8gw5zDp2zDvCBlxJ9payDDp2l6Z2lsZXIgbmF0c3BlYyB5b3J1bWxhcsSxIG9sYXJhawogICAgLy8gYWRsYW5kxLFyxLFsxLFyLiBLdWxsYW7EsWPEsXlhIGJpciBpxZ9sZW1pIG9uYXlsYXlhY2HEn8SxCiAgICAvLyB6YW1hbiB5YSBkYSBiaXIgaGF0YWRhIGfDtnN0ZXJpbGlyLgoKICAgIC8vLyDEsGhhbGUgYml0dGkuCiAgICBlcnJvciBBdWN0aW9uQWxyZWFkeUVuZGVkKCk7CiAgICAvLy8gRcWfaXQgeWEgZGEgZGFoYSB5w7xrc2VrIGJpciB0ZWtsaWYgdmFyLgogICAgZXJyb3IgQmlkTm90SGlnaEVub3VnaCh1aW50IGhpZ2hlc3RCaWQpOwogICAgLy8vIFRla2xpZiBoZW7DvHogYml0bWVkaS4KICAgIGVycm9yIEF1Y3Rpb25Ob3RZZXRFbmRlZCgpOwogICAgLy8vIGF1Y3Rpb25FbmQgZm9ua3NpeW9udSB6YXRlbiDDp2HEn3LEsWxkxLEuCiAgICBlcnJvciBBdWN0aW9uRW5kQWxyZWFkeUNhbGxlZCgpOwoKICAgIC8vLyBIYWsgc2FoaWJpIGFkxLFuYSBgYmVuZWZpY2lhcnlBZGRyZXNzYAogICAgLy8vIGBiaWRkaW5nVGltZWAgZGFraSBzw7xyZSBpbGUgYmlyIGloYWxlIGJhxZ9sYXTEsXIuCiAgICBjb25zdHJ1Y3RvcigKICAgICAgICB1aW50IGJpZGRpbmdUaW1lLAogICAgICAgIGFkZHJlc3MgcGF5YWJsZSBiZW5lZmljaWFyeUFkZHJlc3MKICAgICkgewogICAgICAgIGJlbmVmaWNpYXJ5ID0gYmVuZWZpY2lhcnlBZGRyZXNzOwogICAgICAgIGF1Y3Rpb25FbmRUaW1lID0gYmxvY2sudGltZXN0YW1wICsgYmlkZGluZ1RpbWU7CiAgICB9CgogICAgLy8vIMSwxZ9sZW1sZSBiaXJsaWt0ZSB0ZWtsaWZ0ZWtpIHBhcmEgZGEKICAgIC8vLyBnw7ZuZGVyaWxpci4gw5ZkZW1lIHNhZGVjZSB0ZWtsaWYga2F6YW5tYXpzYQogICAgLy8vIGlhZGUgZWRpbGlyLgogICAgZnVuY3Rpb24gYmlkKCkgZXh0ZXJuYWwgcGF5YWJsZSB7CiAgICAgICAgLy8gSGVyaGFuZ2kgYmlyIGFyZ8O8bWFuYSBnZXJlayB5b2ssCiAgICAgICAgLy8gYsO8dMO8biBiaWxnaSB6YXRlbiBpxZ9sZW1pbiBwYXLDp2FzxLEuCiAgICAgICAgLy8gcGF5YWJsZSBhbmFodGFyIGtlbGltZXNpIGZvbmtzaXlvbnVuCiAgICAgICAgLy8gRXRoZXIgYWxhYmlsbWVzaSBpw6dpbiB6b3J1bmx1LgoKICAgICAgICAvLyB0ZWtsaWYgc8O8cmVjaSBiaXR0aXlzZSDDp2HEn3LEsXnEsQogICAgICAgIC8vIGdlcmkgw6dldmlyLgogICAgICAgIGlmIChibG9jay50aW1lc3RhbXAgPiBhdWN0aW9uRW5kVGltZSkKICAgICAgICAgICAgcmV2ZXJ0IEF1Y3Rpb25BbHJlYWR5RW5kZWQoKTsKICAgICAgICAvLyBUZWtsaWYgZGFoYSB5w7xrc2VrIGRlxJ9pbHNlLAogICAgICAgIC8vIHBhcmF5xLEgZ2VyaSBnw7ZuZGVyaW4gKHJldmVydCBpZmFkZXNpCiAgICAgICAgLy8gcGFyYXnEsSBhbG3EscWfIG9sbWFzxLEgZGEgZGFoaWwgb2xtYWsKICAgICAgICAvLyDDvHplcmUgYnUgZm9ua3NpeW9uIHnDvHLDvHRtZXNpbmRla2kgdMO8bQogICAgICAgIC8vIGRlxJ9pxZ9pa2xpa2xlcmkgZ2VyaSBhbGFjYWt0xLFyKS4KICAgICAgICBpZiAobXNnLnZhbHVlIDw9IGhpZ2hlc3RCaWQpCiAgICAgICAgICAgIHJldmVydCBCaWROb3RIaWdoRW5vdWdoKGhpZ2hlc3RCaWQpOwoKICAgICAgICBpZiAoaGlnaGVzdEJpZCAhPSAwKSB7CiAgICAgICAgICAgIC8vIEJhc2l0IGJpciDFn2VraWxkZSBoaWdoZXN0QmlkZGVyLnNlbmQoaGlnaGVzdEJpZCknaQogICAgICAgICAgICAvLyBrdWxsYW5hcmFrIHBhcmEgZ8O2bmRlcm1layBiaXIgZ8O8dmVubGlrIHJpc2tpIG9sdcWfdHVydXlvcgogICAgICAgICAgICAvLyDDp8O8bmvDvCBnw7x2ZW5pbG1leiBiaXIga29udHJhdMSxIChpw6dpbmRlIGZhbGxiYWNrIGZvbmtzaXlvbnUKICAgICAgICAgICAgLy8gacOnZXJlbikgw6dhbMSxxZ90xLFyYWJpbGlyLiBIZXIgemFtYW4ga2F0xLFsxLFtY8SxbGFyxLFuIHBhcmFsYXLEsW7EsQogICAgICAgICAgICAvLyBrZW5kaWxlcmluaW4gw6dla21lbGVyaSBkYWhhIGfDvHZlbmlsaXJkaXIuCiAgICAgICAgICAgIHBlbmRpbmdSZXR1cm5zW2hpZ2hlc3RCaWRkZXJdICs9IGhpZ2hlc3RCaWQ7CiAgICAgICAgfQogICAgICAgIGhpZ2hlc3RCaWRkZXIgPSBtc2cuc2VuZGVyOwogICAgICAgIGhpZ2hlc3RCaWQgPSBtc2cudmFsdWU7CiAgICAgICAgZW1pdCBIaWdoZXN0QmlkSW5jcmVhc2VkKG1zZy5zZW5kZXIsIG1zZy52YWx1ZSk7CiAgICB9CgogICAgLy8vIEdlw6dpbG1pxZ8gYmlyIHRla2xpZmluIHBhcmFzxLFuxLEgZ2VyaSDDp2VrLgogICAgZnVuY3Rpb24gd2l0aGRyYXcoKSBleHRlcm5hbCByZXR1cm5zIChib29sKSB7CiAgICAgICAgdWludCBhbW91bnQgPSBwZW5kaW5nUmV0dXJuc1ttc2cuc2VuZGVyXTsKICAgICAgICBpZiAoYW1vdW50ID4gMCkgewogICAgICAgICAgICAvLyBCdSBkZcSfZXJpIHPEsWbEsXJhIGXFn2l0bGVtZWsgw7ZuZW1saSDDp8O8bmvDvCBhbMSxY8SxIGJ1IGZvbmtzaXlvbnUKICAgICAgICAgICAgLy8gYHNlbmRgIHRhbWFtbGFubWFkYW4gdGVrcmFyIMOnYcSfxLFyxLFyc2EgKHJlZW50cmFuY3kpIGFsbWFzxLEgZ2VyZWtlbmRlbgogICAgICAgICAgICAvLyBkYWhhIGZhemxhIHBhcmEgw6dla2ViaWxpci4KICAgICAgICAgICAgcGVuZGluZ1JldHVybnNbbXNnLnNlbmRlcl0gPSAwOwoKICAgICAgICAgICAgLy8gbXNnLnNlbmRlciBgYWRkcmVzcyBwYXlhYmxlYCB0w7xyw7xuZGUgZGXEn2lsIHZlIGBzZW5kKClgCiAgICAgICAgICAgIC8vIGZvbmtzaXlvbnVuZGEgw6dhxJ9yxLFsYWJpbG1lc2kgYHBheWFibGUobXNnLnNlbmRlcilgIGlsZQogICAgICAgICAgICAvLyBgYWRkcmVzcyBwYXlhYmxlYCBhIGTDtm7DvMWfdMO8csO8bG1lc2kgZ2VyZWtpeW9yLgogICAgICAgICAgICBpZiAoIXBheWFibGUobXNnLnNlbmRlcikuc2VuZChhbW91bnQpKSB7CiAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGNhbGwgdGhyb3cgaGVyZSwganVzdCByZXNldCB0aGUgYW1vdW50IG93aW5nCiAgICAgICAgICAgICAgICBwZW5kaW5nUmV0dXJuc1ttc2cuc2VuZGVyXSA9IGFtb3VudDsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICAvLy8gxLBoYWxleWkgYml0aXIgdmUgZW4gecO8a3NlayB0ZWtsaWZpCiAgICAvLy8gaGFrIHNhaGliaW5lIGfDtm5kZXIuCiAgICBmdW5jdGlvbiBhdWN0aW9uRW5kKCkgZXh0ZXJuYWwgewogICAgICAgIC8vIERpxJ9lciBrb250cmF0bGFyIGlsZSBldGtpbGXFn2ltZSBnaXJlbiAoZm9ua3NpeW9uIMOnYcSfxLFyYW4geWEgZGEKICAgICAgICAvLyBFdGhlciBnw7ZuZGVyZW4pIGZvbmtzaXlvbmxhcsSxIMO8w6cgcGFyw6dhZGEgxZ9la2lsbGRlbmlybWVrIGfDvHplbCBiaXIgecO2bnRlbS4KICAgICAgICAvLyDFnnUgcGFyw6dhbGFyCiAgICAgICAgLy8gMS4ga2/Fn3VsIGtvbnRyb2xsZXJpCiAgICAgICAgLy8gMi4gZXlsZW0gZ2Vyw6dla2xlxZ90aXJlbmxlciAoa2/Fn3VsbGFyxLEgZGXEn2nFn3RpcmViaWxpcmxlcikKICAgICAgICAvLyAzLiBiYcWfa2Ega29udHJhdGxhcmxhciBldGtpbGXFn2ltZSBnaXJlbmxlcgogICAgICAgIC8vIEXDvGVyIGJ1IGZhemxhciBrYXLEscWfxLFyc2EsIGRpxJ9lciBrb250cmF0IGJ1IGtvbnRyYXTEsSDDp2HEn8SxcsSxcAogICAgICAgIC8vIGR1cnVtbGFyxLEgZGXEn2nFn3RpcmViaWxpciB5YSBkYSBvbGF5bGFyxLFuIChldGhlciDDtmRlbWVzaSBnaWJpKQogICAgICAgIC8vIGJpcmthw6cga2VyZSBnZXLDp2VrbGXFn21lc2luZSBzZWJlcCBvbGFiaWxpci4KICAgICAgICAvLyBFxJ9lciBpw6dlcmlkZW4gw6dhxJ/EsXLEsWxhbiBmb25rc2l5b25sYXIgYmHFn2thIGtvbnRyYXRsYXJsYSBldGtpbGXFn2ltZQogICAgICAgIC8vIGdpcml5b3JzYSBvIGZvbmtzaXlvbmxhciBkYSBiYcWfa2EgZm9ua3NpeW9ubGFybGEgZXRraWxlxZ9lbmxlciBvbGFyYWsKICAgICAgICAvLyBkZcSfZXJsZW5kaXJpbG1lbGkKCiAgICAgICAgLy8gMS4gxZ5hcnRsYXIKICAgICAgICBpZiAoYmxvY2sudGltZXN0YW1wIDwgYXVjdGlvbkVuZFRpbWUpCiAgICAgICAgICAgIHJldmVydCBBdWN0aW9uTm90WWV0RW5kZWQoKTsKICAgICAgICBpZiAoZW5kZWQpCiAgICAgICAgICAgIHJldmVydCBBdWN0aW9uRW5kQWxyZWFkeUNhbGxlZCgpOwoKICAgICAgICAvLyAyLiBFdGtpbGVyCiAgICAgICAgZW5kZWQgPSB0cnVlOwogICAgICAgIGVtaXQgQXVjdGlvbkVuZGVkKGhpZ2hlc3RCaWRkZXIsIGhpZ2hlc3RCaWQpOwoKICAgICAgICAvLyAzLiBFdGtpbGXFn2ltCiAgICAgICAgYmVuZWZpY2lhcnkudHJhbnNmZXIoaGlnaGVzdEJpZCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract SimpleAuction {
 // İhalenin parametreleri. Süreler unix zaman damgası
 // (1970-01-01'den itibaren saniyeler) ya da saniye
 // cinsinden ne kadar süreceği.
 address payable public beneficiary;
 uint public auctionEndTime;
 // İhalenin şu an ki durumu
 address public highestBidder;
 uint public highestBid;
 // Önceki tekliflerden para çekmeye izin verilenler
 mapping(address \=> uint) pendingReturns;
 // En son \`true\`ya çevir, herhangi bir değişiklik yapılmasını engeller
 // varsayılan olarak \`false\` tanımlanır.
 bool ended;
 // Değişikliklerde yayınlanacak Event'ler
 event HighestBidIncreased(address bidder, uint amount);
 event AuctionEnded(address winner, uint amount);
 // Başarısızları açıklayan hatalar
 // Üçlü eğik çizgiler natspec yorumları olarak
 // adlandırılır. Kullanıcıya bir işlemi onaylayacağı
 // zaman ya da bir hatada gösterilir.
 /// İhale bitti.
 error AuctionAlreadyEnded();
 /// Eşit ya da daha yüksek bir teklif var.
 error BidNotHighEnough(uint highestBid);
 /// Teklif henüz bitmedi.
 error AuctionNotYetEnded();
 /// auctionEnd fonksiyonu zaten çağrıldı.
 error AuctionEndAlreadyCalled();
 /// Hak sahibi adına \`beneficiaryAddress\`
 /// \`biddingTime\` daki süre ile bir ihale başlatır.
 constructor(
 uint biddingTime,
 address payable beneficiaryAddress
 ) {
 beneficiary \= beneficiaryAddress;
 auctionEndTime \= block.timestamp + biddingTime;
 }
 /// İşlemle birlikte teklifteki para da
 /// gönderilir. Ödeme sadece teklif kazanmazsa
 /// iade edilir.
 function bid() external payable {
 // Herhangi bir argümana gerek yok,
 // bütün bilgi zaten işlemin parçası.
 // payable anahtar kelimesi fonksiyonun
 // Ether alabilmesi için zorunlu.
 // teklif süreci bittiyse çağrıyı
 // geri çevir.
 if (block.timestamp \> auctionEndTime)
 revert AuctionAlreadyEnded();
 // Teklif daha yüksek değilse,
 // parayı geri gönderin (revert ifadesi
 // parayı almış olması da dahil olmak
 // üzere bu fonksiyon yürütmesindeki tüm
 // değişiklikleri geri alacaktır).
 if (msg.value <= highestBid)
 revert BidNotHighEnough(highestBid);
 if (highestBid != 0) {
 // Basit bir şekilde highestBidder.send(highestBid)'i
 // kullanarak para göndermek bir güvenlik riski oluşturuyor
 // çünkü güvenilmez bir kontratı (içinde fallback fonksiyonu
 // içeren) çalıştırabilir. Her zaman katılımcıların paralarını
 // kendilerinin çekmeleri daha güvenilirdir.
 pendingReturns\[highestBidder\] += highestBid;
 }
 highestBidder \= msg.sender;
 highestBid \= msg.value;
 emit HighestBidIncreased(msg.sender, msg.value);
 }
 /// Geçilmiş bir teklifin parasını geri çek.
 function withdraw() external returns (bool) {
 uint amount \= pendingReturns\[msg.sender\];
 if (amount \> 0) {
 // Bu değeri sıfıra eşitlemek önemli çünkü alıcı bu fonksiyonu
 // \`send\` tamamlanmadan tekrar çağırırsa (reentrancy) alması gerekenden
 // daha fazla para çekebilir.
 pendingReturns\[msg.sender\] \= 0;
 // msg.sender \`address payable\` türünde değil ve \`send()\`
 // fonksiyonunda çağrılabilmesi \`payable(msg.sender)\` ile
 // \`address payable\` a dönüştürülmesi gerekiyor.
 if (!payable(msg.sender).send(amount)) {
 // No need to call throw here, just reset the amount owing
 pendingReturns\[msg.sender\] \= amount;
 return false;
 }
 }
 return true;
 }
 /// İhaleyi bitir ve en yüksek teklifi
 /// hak sahibine gönder.
 function auctionEnd() external {
 // Diğer kontratlar ile etkileşime giren (fonksiyon çağıran ya da
 // Ether gönderen) fonksiyonları üç parçada şekilldenirmek güzel bir yöntem.
 // Şu parçalar
 // 1. koşul kontrolleri
 // 2. eylem gerçekleştirenler (koşulları değiştirebilirler)
 // 3. başka kontratlarlar etkileşime girenler
 // Eüer bu fazlar karışırsa, diğer kontrat bu kontratı çağırıp
 // durumları değiştirebilir ya da olayların (ether ödemesi gibi)
 // birkaç kere gerçekleşmesine sebep olabilir.
 // Eğer içeriden çağırılan fonksiyonlar başka kontratlarla etkileşime
 // giriyorsa o fonksiyonlar da başka fonksiyonlarla etkileşenler olarak
 // değerlendirilmeli
 // 1. Şartlar
 if (block.timestamp < auctionEndTime)
 revert AuctionNotYetEnded();
 if (ended)
 revert AuctionEndAlreadyCalled();
 // 2. Etkiler
 ended \= true;
 emit AuctionEnded(highestBidder, highestBid);
 // 3. Etkileşim
 beneficiary.transfer(highestBid);
 }
}
### Gizli İhale[](#id2 "Permalink to this heading")
Aşağıda yukarıdaki açık ihalenin kapalı ihaleye dönüştürülmüş halini bulabilirsiniz. Gizli ihalenin avantajı ihale sürecinin sonunda doğru bir zaman baskısı oluşturmaması. Saydam bir işlem platformunda gizli ihale oluşturmak çelişkili olsa da kriptografi burada yardımımıza koşuyor.
**Teklif süreci** boyunca, teklif veren kişi aslında gerçekten teklif yapmıyor, sadece hashlenmiş bir halini gönderiyor. Şu an hash değerleri eşit olan iki değer (yeterince uzun) bulmak pratik olarak imkansız olduğundan, teklif veren kişi bu şekilde teklif oluşturmuş olur. Teklif süreci bittikten sonra teklif veren kişiler tekliflerini açıklamalı, girdikleri şifrelenmemiş değerin hashlenmiş hali ile önceden girdikleri hash ile aynı olmalıdır.
Başka bir zorluk da **gizlilik ve bağlayıcılığı** aynı anda sağlamak. Teklif veren kişinin kazandıktan sonra teklifinden vazgeçmemesinin tek yolu teklif ile birlikte parayı da yollaması ancak transferler Ethereum’da gizlenemediğinden herhangi bir kişi miktarı görebilir.
Aşağıdaki kotnrat bu sorunu teklif ile birlikte herhangi bir miktar paranın birlikte gönderilmesiyle çözüyor. Miktar ile teklifin eşitliği sadece açıklama fazında ortaya anlaşılabildiği için bazı teklifleri **geçersiz** olabilir, ve teklif veren kişiler bunu kasıtlı olarak kullanabilir (hatta bu durum daha fazla gizlilik sağlıyor) Teklif veren kişiler kasıtlı olarak bir kaç yüksek ve düşük geçersiz teklifler oluşturarak kafa karıştırabilirler.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKY29udHJhY3QgQmxpbmRBdWN0aW9uIHsKICAgIHN0cnVjdCBCaWQgewogICAgICAgIGJ5dGVzMzIgYmxpbmRlZEJpZDsKICAgICAgICB1aW50IGRlcG9zaXQ7CiAgICB9CgogICAgYWRkcmVzcyBwYXlhYmxlIHB1YmxpYyBiZW5lZmljaWFyeTsKICAgIHVpbnQgcHVibGljIGJpZGRpbmdFbmQ7CiAgICB1aW50IHB1YmxpYyByZXZlYWxFbmQ7CiAgICBib29sIHB1YmxpYyBlbmRlZDsKCiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gQmlkW10pIHB1YmxpYyBiaWRzOwoKICAgIGFkZHJlc3MgcHVibGljIGhpZ2hlc3RCaWRkZXI7CiAgICB1aW50IHB1YmxpYyBoaWdoZXN0QmlkOwoKICAgIC8vIMOWbmNla2kgdGVrbGlmbGVyZGVuIHBhcmEgw6dla21leWUgaXppbiB2ZXJpbGVubGVyCiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gdWludCkgcGVuZGluZ1JldHVybnM7CgogICAgZXZlbnQgQXVjdGlvbkVuZGVkKGFkZHJlc3Mgd2lubmVyLCB1aW50IGhpZ2hlc3RCaWQpOwoKICAgIC8vIEJhxZ9hcsSxc8SxemxhcsSxIGHDp8Sxa2xheWFuIGhhdGFsYXIKCiAgICAvLy8gRm9ua3NpeW9uIGVya2VuIMOnYcSfxLFyxLFsZMSxLgogICAgLy8vIGB0aW1lYCBkZSB0ZWtyYXIgZGVuZXlpbi4KICAgIGVycm9yIFRvb0Vhcmx5KHVpbnQgdGltZSk7CiAgICAvLy8gRm9ua3N5aW9uIGdlw6cgw6dhxJ/EsXLEsWxkxLEuCiAgICAvLy8gYHRpbWVgIGRhbiBzb25yYSDDp2HEn8SxcsSxbGFtYXouCiAgICBlcnJvciBUb29MYXRlKHVpbnQgdGltZSk7CiAgICAvLy8gYXVjdGlvbkVuZCBmb25rc3lpb251IHphdGVuIMOnYcSfxLFyxLFsZMSxLgogICAgZXJyb3IgQXVjdGlvbkVuZEFscmVhZHlDYWxsZWQoKTsKCiAgICAvLyBNb2RpZmllcmxhciBmb25rc2l5b24gZ2lyZGlsZXJpbmkga29udHJvbCBldG1lbmluCiAgICAvLyBrb2xheSBiaXIgecO2bnRlbWlkaXIuIGBvbmx5QmVmb3JlYCBtb2RpZmllcsSxIGHFn2HEn8SxZGFraQogICAgLy8gYGJpZGAgZSB1eWd1bGFuZMSxOgogICAgLy8gWWVuaSBmb25rc3lpb251biBnw7Z2ZGUga8Sxc23EsSBtb2RpZmllcsSxbiBnw7Z2ZGUga8Sxc23EsSBvbHV5b3IuCiAgICAvLyBTYWRlY2UgYF9gIGVza2kgZm9ua3NpeW9udW4gZ8O2dmRlc2l5bGUgZGXEn2nFn2l5b3IuLgogICAgbW9kaWZpZXIgb25seUJlZm9yZSh1aW50IHRpbWUpIHsKICAgICAgICBpZiAoYmxvY2sudGltZXN0YW1wID49IHRpbWUpIHJldmVydCBUb29MYXRlKHRpbWUpOwogICAgICAgIF87CiAgICB9CiAgICBtb2RpZmllciBvbmx5QWZ0ZXIodWludCB0aW1lKSB7CiAgICAgICAgaWYgKGJsb2NrLnRpbWVzdGFtcCA8PSB0aW1lKSByZXZlcnQgVG9vRWFybHkodGltZSk7CiAgICAgICAgXzsKICAgIH0KCiAgICBjb25zdHJ1Y3RvcigKICAgICAgICB1aW50IGJpZGRpbmdUaW1lLAogICAgICAgIHVpbnQgcmV2ZWFsVGltZSwKICAgICAgICBhZGRyZXNzIHBheWFibGUgYmVuZWZpY2lhcnlBZGRyZXNzCiAgICApIHsKICAgICAgICBiZW5lZmljaWFyeSA9IGJlbmVmaWNpYXJ5QWRkcmVzczsKICAgICAgICBiaWRkaW5nRW5kID0gYmxvY2sudGltZXN0YW1wICsgYmlkZGluZ1RpbWU7CiAgICAgICAgcmV2ZWFsRW5kID0gYmlkZGluZ0VuZCArIHJldmVhbFRpbWU7CiAgICB9CiAgICAvLy8gYGJsaW5kZWRCaWRgID0ga2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQodmFsdWUsIGZha2UsIHNlY3JldCkpCiAgICAvLy8gaWxlIGdpemxpIGJpciB0ZWtsaWYgdmVyLiBHw7ZuZGVyaWxlbiBldGhlciBzYWRlY2UgdGVrbGlmIGRvxJ9ydQogICAgLy8vIGJpciDFn2VraWxkZSBhw6fEsWtsYW5kxLF5c2EgZ2VyaSBhbMSxbmFiaWxpci4gVGVrbGlmIGXEn2VyICJ2YWx1ZSJkYWtpCiAgICAvLy8gZGXEn2VyIGlsZSBlbiBheiBnw7ZuZGVyaWxlbiBFdGhlciBrYWRhciB5YSBkYSAiZmFrZSIgZGXEn2VyaSBgZmFsc2VgCiAgICAvLy8gaXNlIGdlw6dlcmxpZGlyLiAgQmlyIG1pa3RhciBFdGhlciB5YXTEsXLEsWxtYXPEsSAgZ2VyZWtzZW5lZGUKICAgIC8vLyAiZmFrZSIgZGXEn2VyaW5pIGB0cnVlYCB5YXBtYWsgdmUgInZhbHVlIiBkZcSfZXJpbmRlbgogICAgLy8vIGZhcmtsxLEgbWlrdGFyZGEgRXRoZXIgZ8O2bmRlcm1layBnZXLDp2VrIHRla2xpZmkgZ2l6bGVtZW5pbiB5w7ZudGVtbGVyaWRpci4KICAgIC8vLyBBeW7EsSBhZHJlcyBiaXJkZW4gZmF6bGEga2V6IHBhcmEgeWF0xLFyYWJpbGlyLgogICAgZnVuY3Rpb24gYmlkKGJ5dGVzMzIgYmxpbmRlZEJpZCkKICAgICAgICBleHRlcm5hbAogICAgICAgIHBheWFibGUKICAgICAgICBvbmx5QmVmb3JlKGJpZGRpbmdFbmQpCiAgICB7CiAgICAgICAgYmlkc1ttc2cuc2VuZGVyXS5wdXNoKEJpZCh7CiAgICAgICAgICAgIGJsaW5kZWRCaWQ6IGJsaW5kZWRCaWQsCiAgICAgICAgICAgIGRlcG9zaXQ6IG1zZy52YWx1ZQogICAgICAgIH0pKTsKICAgIH0KCiAgICAvLy8gR2l6bGkgdGVrbGlmaW5pIGHDp8Sxa2xhLiBUw7xtIHRla2xpZmxlciBhcmFzxLFuZGEgZW4gecO8a3NlayBvbGFuIGhhcmnDpwogICAgLy8vIGRvxJ9ydSDFn2VraWxkZSBhw6fEsWtsYW5txLHFnyB0w7xtIHRla2xpZmxlcmluIHBhcmFzxLFuxLEgaWFkZSBhbGFiaWxpcnNpbi4KICAgIGZ1bmN0aW9uIHJldmVhbCgKICAgICAgICB1aW50W10gY2FsbGRhdGEgdmFsdWVzLAogICAgICAgIGJvb2xbXSBjYWxsZGF0YSBmYWtlcywKICAgICAgICBieXRlczMyW10gY2FsbGRhdGEgc2VjcmV0cwogICAgKQogICAgICAgIGV4dGVybmFsCiAgICAgICAgb25seUFmdGVyKGJpZGRpbmdFbmQpCiAgICAgICAgb25seUJlZm9yZShyZXZlYWxFbmQpCiAgICB7CiAgICAgICAgdWludCBsZW5ndGggPSBiaWRzW21zZy5zZW5kZXJdLmxlbmd0aDsKICAgICAgICByZXF1aXJlKHZhbHVlcy5sZW5ndGggPT0gbGVuZ3RoKTsKICAgICAgICByZXF1aXJlKGZha2VzLmxlbmd0aCA9PSBsZW5ndGgpOwogICAgICAgIHJlcXVpcmUoc2VjcmV0cy5sZW5ndGggPT0gbGVuZ3RoKTsKCiAgICAgICAgdWludCByZWZ1bmQ7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgQmlkIHN0b3JhZ2UgYmlkVG9DaGVjayA9IGJpZHNbbXNnLnNlbmRlcl1baV07CiAgICAgICAgICAgICh1aW50IHZhbHVlLCBib29sIGZha2UsIGJ5dGVzMzIgc2VjcmV0KSA9CiAgICAgICAgICAgICAgICAgICAgKHZhbHVlc1tpXSwgZmFrZXNbaV0sIHNlY3JldHNbaV0pOwogICAgICAgICAgICBpZiAoYmlkVG9DaGVjay5ibGluZGVkQmlkICE9IGtlY2NhazI1NihhYmkuZW5jb2RlUGFja2VkKHZhbHVlLCBmYWtlLCBzZWNyZXQpKSkgewogICAgICAgICAgICAgICAgLy8gVGVrbGlmIGHDp8Sxa2xhbm1hZMSxCiAgICAgICAgICAgICAgICAvLyBZYXTEsXLEsWxhbiBwYXJhecSxIGlhZGUgZXRtZQogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmVmdW5kICs9IGJpZFRvQ2hlY2suZGVwb3NpdDsKICAgICAgICAgICAgaWYgKCFmYWtlICYmIGJpZFRvQ2hlY2suZGVwb3NpdCA+PSB2YWx1ZSkgewogICAgICAgICAgICAgICAgaWYgKHBsYWNlQmlkKG1zZy5zZW5kZXIsIHZhbHVlKSkKICAgICAgICAgICAgICAgICAgICByZWZ1bmQgLT0gdmFsdWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8gR8O2bmRlcmljaW5pbiBnw7ZuZGVyZGnEn2kgcGFyYXnEsSB0ZWtyYXIgZ2VyaSBhbG1hc8SxbsSxCiAgICAgICAgICAgIC8vIGlta2Fuc8SxeiBoYWxlIGdldGlyLgogICAgICAgICAgICBiaWRUb0NoZWNrLmJsaW5kZWRCaWQgPSBieXRlczMyKDApOwogICAgICAgIH0KICAgICAgICBwYXlhYmxlKG1zZy5zZW5kZXIpLnRyYW5zZmVyKHJlZnVuZCk7CiAgICB9CgogICAgLy8vIEZhemxhZGFuIHBhcmEgeWF0xLFyxLFsbcSxxZ8gYmlyIHRla2xpZmkgZ2VyaSDDp2VrLgogICAgZnVuY3Rpb24gd2l0aGRyYXcoKSBleHRlcm5hbCB7CiAgICAgICAgdWludCBhbW91bnQgPSBwZW5kaW5nUmV0dXJuc1ttc2cuc2VuZGVyXTsKICAgICAgICBpZiAoYW1vdW50ID4gMCkgewogICAgICAgICAgICAvLyBCdSBkZcSfZXJpIHPEsWbEsXJhIGXFn2l0bGVtZWsgw7ZuZW1saSDDp8O8bmvDvCBhbMSxY8SxIGJ1IGZvbmtzaXlvbnUKICAgICAgICAgICAgLy8gYHNlbmRgIHRhbWFtbGFubWFkYW4gdGVrcmFyIMOnYcSfxLFyxLFyc2EgKHJlZW50cmFuY3kpIGFsbWFzxLEgZ2VyZWtlbmRlbgogICAgICAgICAgICAvLyBkYWhhIGZhemxhIHBhcmEgw6dla2ViaWxpci4gKHl1a2FyxLFkYWtpIMWfYXJ0bGFyIC0+IGV0a2lsZXIgLT4gZXRraWxlxZ9pbWxlcgogICAgICAgICAgICAvLyBoYWtrxLFuZGFraSBiaWxnaWxlbmRpcm1leWUgYmFrYWJpbGlyc2luaXopCiAgICAgICAgICAgIHBlbmRpbmdSZXR1cm5zW21zZy5zZW5kZXJdID0gMDsKCiAgICAgICAgICAgIHBheWFibGUobXNnLnNlbmRlcikudHJhbnNmZXIoYW1vdW50KTsKICAgICAgICB9CiAgICB9CgogICAgLy8vIMSwaGFsZXlpIGJpdGlyIHZlIGVuIHnDvHNlayB0ZWtsaWZpCiAgICAvLy8gaGFrIHNhaGliaW5lIGfDtm5kZXIuCiAgICBmdW5jdGlvbiBhdWN0aW9uRW5kKCkKICAgICAgICBleHRlcm5hbAogICAgICAgIG9ubHlBZnRlcihyZXZlYWxFbmQpCiAgICB7CiAgICAgICAgaWYgKGVuZGVkKSByZXZlcnQgQXVjdGlvbkVuZEFscmVhZHlDYWxsZWQoKTsKICAgICAgICBlbWl0IEF1Y3Rpb25FbmRlZChoaWdoZXN0QmlkZGVyLCBoaWdoZXN0QmlkKTsKICAgICAgICBlbmRlZCA9IHRydWU7CiAgICAgICAgYmVuZWZpY2lhcnkudHJhbnNmZXIoaGlnaGVzdEJpZCk7CiAgICB9CgogICAgLy8gImludGVybmFsIiAoacOnc2VsKSBiaXIgZm9ua3NpeW9uIHlhbmkgc2FkZWNlIGtvbnRyYXTEsW4KICAgIC8vIGtlbmRpc2kgKHlhIGRhIGJ1IGtvbnRyYXR0YW4gw6fEsWthbiAoZGVyaXZlIGVkaWxlbikga29udHJhdGxhcikKICAgIC8vIGJ1bnUgw6dhxJ/EsXJhYmlsaXIuCiAgICBmdW5jdGlvbiBwbGFjZUJpZChhZGRyZXNzIGJpZGRlciwgdWludCB2YWx1ZSkgaW50ZXJuYWwKICAgICAgICAgICAgcmV0dXJucyAoYm9vbCBzdWNjZXNzKQogICAgewogICAgICAgIGlmICh2YWx1ZSA8PSBoaWdoZXN0QmlkKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgICAgaWYgKGhpZ2hlc3RCaWRkZXIgIT0gYWRkcmVzcygwKSkgewogICAgICAgICAgICAvLyDDlm5jZWtpIGVuIHnDvGtzZWsgdGVrbGlmaW4gcGFyYXPEsW7EsSBpYWRlIGV0LgogICAgICAgICAgICBwZW5kaW5nUmV0dXJuc1toaWdoZXN0QmlkZGVyXSArPSBoaWdoZXN0QmlkOwogICAgICAgIH0KICAgICAgICBoaWdoZXN0QmlkID0gdmFsdWU7CiAgICAgICAgaGlnaGVzdEJpZGRlciA9IGJpZGRlcjsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract BlindAuction {
 struct Bid {
 bytes32 blindedBid;
 uint deposit;
 }
 address payable public beneficiary;
 uint public biddingEnd;
 uint public revealEnd;
 bool public ended;
 mapping(address \=> Bid\[\]) public bids;
 address public highestBidder;
 uint public highestBid;
 // Önceki tekliflerden para çekmeye izin verilenler
 mapping(address \=> uint) pendingReturns;
 event AuctionEnded(address winner, uint highestBid);
 // Başarısızları açıklayan hatalar
 /// Fonksiyon erken çağırıldı.
 /// \`time\` de tekrar deneyin.
 error TooEarly(uint time);
 /// Fonksyion geç çağırıldı.
 /// \`time\` dan sonra çağırılamaz.
 error TooLate(uint time);
 /// auctionEnd fonksyionu zaten çağırıldı.
 error AuctionEndAlreadyCalled();
 // Modifierlar fonksiyon girdilerini kontrol etmenin
 // kolay bir yöntemidir. \`onlyBefore\` modifierı aşağıdaki
 // \`bid\` e uygulandı:
 // Yeni fonksyionun gövde kısmı modifierın gövde kısmı oluyor.
 // Sadece \`\_\` eski fonksiyonun gövdesiyle değişiyor..
 modifier onlyBefore(uint time) {
 if (block.timestamp \>= time) revert TooLate(time);
 \_;
 }
 modifier onlyAfter(uint time) {
 if (block.timestamp <= time) revert TooEarly(time);
 \_;
 }
 constructor(
 uint biddingTime,
 uint revealTime,
 address payable beneficiaryAddress
 ) {
 beneficiary \= beneficiaryAddress;
 biddingEnd \= block.timestamp + biddingTime;
 revealEnd \= biddingEnd + revealTime;
 }
 /// \`blindedBid\` = keccak256(abi.encodePacked(value, fake, secret))
 /// ile gizli bir teklif ver. Gönderilen ether sadece teklif doğru
 /// bir şekilde açıklandıysa geri alınabilir. Teklif eğer "value"daki
 /// değer ile en az gönderilen Ether kadar ya da "fake" değeri \`false\`
 /// ise geçerlidir. Bir miktar Ether yatırılması gereksenede
 /// "fake" değerini \`true\` yapmak ve "value" değerinden
 /// farklı miktarda Ether göndermek gerçek teklifi gizlemenin yöntemleridir.
 /// Aynı adres birden fazla kez para yatırabilir.
 function bid(bytes32 blindedBid)
 external
 payable
 onlyBefore(biddingEnd)
 {
 bids\[msg.sender\].push(Bid({
 blindedBid: blindedBid,
 deposit: msg.value
 }));
 }
 /// Gizli teklifini açıkla. Tüm teklifler arasında en yüksek olan hariç
 /// doğru şekilde açıklanmış tüm tekliflerin parasını iade alabilirsin.
 function reveal(
 uint\[\] calldata values,
 bool\[\] calldata fakes,
 bytes32\[\] calldata secrets
 )
 external
 onlyAfter(biddingEnd)
 onlyBefore(revealEnd)
 {
 uint length \= bids\[msg.sender\].length;
 require(values.length \== length);
 require(fakes.length \== length);
 require(secrets.length \== length);
 uint refund;
 for (uint i \= 0; i < length; i++) {
 Bid storage bidToCheck \= bids\[msg.sender\]\[i\];
 (uint value, bool fake, bytes32 secret) \=
 (values\[i\], fakes\[i\], secrets\[i\]);
 if (bidToCheck.blindedBid != keccak256(abi.encodePacked(value, fake, secret))) {
 // Teklif açıklanmadı
 // Yatırılan parayı iade etme
 continue;
 }
 refund += bidToCheck.deposit;
 if (!fake && bidToCheck.deposit \>= value) {
 if (placeBid(msg.sender, value))
 refund \-= value;
 }
 // Göndericinin gönderdiği parayı tekrar geri almasını
 // imkansız hale getir.
 bidToCheck.blindedBid \= bytes32(0);
 }
 payable(msg.sender).transfer(refund);
 }
 /// Fazladan para yatırılmış bir teklifi geri çek.
 function withdraw() external {
 uint amount \= pendingReturns\[msg.sender\];
 if (amount \> 0) {
 // Bu değeri sıfıra eşitlemek önemli çünkü alıcı bu fonksiyonu
 // \`send\` tamamlanmadan tekrar çağırırsa (reentrancy) alması gerekenden
 // daha fazla para çekebilir. (yukarıdaki şartlar -> etkiler -> etkileşimler
 // hakkındaki bilgilendirmeye bakabilirsiniz)
 pendingReturns\[msg.sender\] \= 0;
 payable(msg.sender).transfer(amount);
 }
 }
 /// İhaleyi bitir ve en yüsek teklifi
 /// hak sahibine gönder.
 function auctionEnd()
 external
 onlyAfter(revealEnd)
 {
 if (ended) revert AuctionEndAlreadyCalled();
 emit AuctionEnded(highestBidder, highestBid);
 ended \= true;
 beneficiary.transfer(highestBid);
 }
 // "internal" (içsel) bir fonksiyon yani sadece kontratın
 // kendisi (ya da bu kontrattan çıkan (derive edilen) kontratlar)
 // bunu çağırabilir.
 function placeBid(address bidder, uint value) internal
 returns (bool success)
 {
 if (value <= highestBid) {
 return false;
 }
 if (highestBidder != address(0)) {
 // Önceki en yüksek teklifin parasını iade et.
 pendingReturns\[highestBidder\] += highestBid;
 }
 highestBid \= value;
 highestBidder \= bidder;
 return true;
 }
}
## Güvenli Uzaktan Alışveriş[](#guvenli-uzaktan-alisveris "Permalink to this heading")
Uzaktan bir mal satın almak birden fazla tarafın birbirine güvenmesini gerektirir. En basit durumda bir satıcı bir de alıcı olur. Alıcı ürünü satıcıdan almak ister, satıcı da karılığında parayı (ya da eş değeri bir şeyi) almak. Burada problemli kısım kargolama: Kesin olarak malın alıcıya ulaştığından emin olmanın yolu yok.
Bu problemmi çözmenin birden fazla yolu var ama hepsinin bir şekilde bir eksiği oluyor. Aşağıdaki örnekte, iki taraf da kontrata malın değerinin iki katını yatırırlar. Yatırma gerçekleştiği anda alıcı onaylayana kadar iki tafaında parası içeride kitli kalır. Alıcı satın almayı onayladığında malın değeri (yatırdığının yarısı) karşı tarafa geçer ve satıcı malın üç katını (yatırdığı iki kat ve alıcının yatırdığı malın değeri) geri çeker. Bu sistemin arkaplanındaki fikir iki tarafında problemi çözmeleri için gönüllü olmaları yoksa ikisinin parası da içeride sonsuza kadar kitli kalacak
Bu kontrat tabi ki bu problemi çözmüyor ama makine benzeri yapıları sözleşmede nasıl kullanabileceğinize dair genel bir bakış sağlıyor.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKY29udHJhY3QgUHVyY2hhc2UgewogICAgdWludCBwdWJsaWMgdmFsdWU7CiAgICBhZGRyZXNzIHBheWFibGUgcHVibGljIHNlbGxlcjsKICAgIGFkZHJlc3MgcGF5YWJsZSBwdWJsaWMgYnV5ZXI7CgogICAgZW51bSBTdGF0ZSB7IENyZWF0ZWQsIExvY2tlZCwgUmVsZWFzZSwgSW5hY3RpdmUgfQogICAgLy8gc3RhdGUgZGXEn2nFn2tlbmkgdmFyc2F5xLFsYW4gb2xhcmFrIGlsayDDvHllZGlyLCAgYFN0YXRlLmNyZWF0ZWRgCiAgICBTdGF0ZSBwdWJsaWMgc3RhdGU7CgogICAgbW9kaWZpZXIgY29uZGl0aW9uKGJvb2wgY29uZGl0aW9uXykgewogICAgICAgIHJlcXVpcmUoY29uZGl0aW9uXyk7CiAgICAgICAgXzsKICAgIH0KCiAgICAvLy8gQnUgZm9ua3NpeW9udSBzYWRlY2UgYWzEsWPEsSDDp2HEn8SxcmFiaWxpcgogICAgZXJyb3IgT25seUJ1eWVyKCk7CiAgICAvLy8gQlUgZm9ua3N5aW9udSBzYWRlY2Ugc2F0xLFjxLEgw6dhxJ/EsXJhYmlsaXIuCiAgICBlcnJvciBPbmx5U2VsbGVyKCk7CiAgICAvLy8gQnUgZm9ua3NpeW9uIMWfdSBhbiDDp2HEn8SxcsSxbGFtYXouCiAgICBlcnJvciBJbnZhbGlkU3RhdGUoKTsKICAgIC8vLyBHaXJpbGVuIGRlxJ9lciDDp2lmdCBvbG1hbMSxLgogICAgZXJyb3IgVmFsdWVOb3RFdmVuKCk7CgogICAgbW9kaWZpZXIgb25seUJ1eWVyKCkgewogICAgICAgIGlmIChtc2cuc2VuZGVyICE9IGJ1eWVyKQogICAgICAgICAgICByZXZlcnQgT25seUJ1eWVyKCk7CiAgICAgICAgXzsKICAgIH0KCiAgICBtb2RpZmllciBvbmx5U2VsbGVyKCkgewogICAgICAgIGlmIChtc2cuc2VuZGVyICE9IHNlbGxlcikKICAgICAgICAgICAgcmV2ZXJ0IE9ubHlTZWxsZXIoKTsKICAgICAgICBfOwogICAgfQoKICAgIG1vZGlmaWVyIGluU3RhdGUoU3RhdGUgc3RhdGVfKSB7CiAgICAgICAgaWYgKHN0YXRlICE9IHN0YXRlXykKICAgICAgICAgICAgcmV2ZXJ0IEludmFsaWRTdGF0ZSgpOwogICAgICAgIF87CiAgICB9CgogICAgZXZlbnQgQWJvcnRlZCgpOwogICAgZXZlbnQgUHVyY2hhc2VDb25maXJtZWQoKTsKICAgIGV2ZW50IEl0ZW1SZWNlaXZlZCgpOwogICAgZXZlbnQgU2VsbGVyUmVmdW5kZWQoKTsKCiAgICAvLyBgbXNnLnZhbHVlYCBpbiDDp2lmdCBvbGR1xJ91bmRhbiBlbWluIG9sLgogICAgLy8gRcSfZXIgdGVrIHNhecSxIGlzZSBiw7ZsbWUga8SxcnDEsWxtxLHFnyBiaXIgc29udcOnIG9sYWNhay4KICAgIC8vIMOHYXJwbWEgaWxlIHRlayBzYXnEsSBvbG1hZMSxxJ/EsW7EsSBrb250cm9sIGV0LgogICAgY29uc3RydWN0b3IoKSBwYXlhYmxlIHsKICAgICAgICBzZWxsZXIgPSBwYXlhYmxlKG1zZy5zZW5kZXIpOwogICAgICAgIHZhbHVlID0gbXNnLnZhbHVlIC8gMjsKICAgICAgICBpZiAoKDIgKiB2YWx1ZSkgIT0gbXNnLnZhbHVlKQogICAgICAgICAgICByZXZlcnQgVmFsdWVOb3RFdmVuKCk7CiAgICB9CgogICAgLy8vIFNhdMSxbiBhbG1hecSxIGlwdGFsIGV0IHZlIGV0aGVyaSBnZXJpIGFsLgogICAgLy8vIFNhZGVjZSBzYXTEsWPEsSB0YXJhZsSxbmRhbiBrb250cmF0IGtpdGxlbm1lZGVuCiAgICAvLy8gw7ZuY2Ugw6dhxJ/EsXLEsWxhYmlsaXIuCiAgICBmdW5jdGlvbiBhYm9ydCgpCiAgICAgICAgZXh0ZXJuYWwKICAgICAgICBvbmx5U2VsbGVyCiAgICAgICAgaW5TdGF0ZShTdGF0ZS5DcmVhdGVkKQogICAgewogICAgICAgIGVtaXQgQWJvcnRlZCgpOwogICAgICAgIHN0YXRlID0gU3RhdGUuSW5hY3RpdmU7CiAgICAgICAgLy8gQnVyYWRhIHRyYW5zZmVyJ2kgZGlyZWt0IG9sYXJhayBrdWxsYW7EsXlvcnV6LgogICAgICAgIC8vIFRla3JhciBnaXJpxZ8gKHJlZW50cmFuY3kpIHNhbGTEsXLEsWxhcsSxbmEga2FyxZ/EsSBnw7x2ZW5saQogICAgICAgIC8vIMOnw7xua8O8IGZvbmtzaXlvbmRha2kgc29uIMOnYcSfcsSxIChjYWxsKSB2ZSBkdXJ1bXUgKHN0YXRlKQogICAgICAgIC8vIHphdGVuIGRlxJ9pxZ90aXJkaWsuCiAgICAgICAgc2VsbGVyLnRyYW5zZmVyKGFkZHJlc3ModGhpcykuYmFsYW5jZSk7CiAgICB9CgogICAgLy8vIEFsxLFjxLEgb2xhcmFrIHNhdMSxbiBhbG1hecSxIG9uYXlsYS4KICAgIC8vLyDEsMWfbGVtIGAyICogdmFsdWVgIGthZGFyIGV0aGVyIGnDp2VybWVsaS4KICAgIC8vLyBFdGhlciBjb25maXJtUmVjZWl2ZWQgZm9ua3NpeW9udSDDp2HEn8SxcsSxbGFuYQogICAgLy8vIGthZGFyIGtpdGxpIGthbGFjYWsuCiAgICBmdW5jdGlvbiBjb25maXJtUHVyY2hhc2UoKQogICAgICAgIGV4dGVybmFsCiAgICAgICAgaW5TdGF0ZShTdGF0ZS5DcmVhdGVkKQogICAgICAgIGNvbmRpdGlvbihtc2cudmFsdWUgPT0gKDIgKiB2YWx1ZSkpCiAgICAgICAgcGF5YWJsZQogICAgewogICAgICAgIGVtaXQgUHVyY2hhc2VDb25maXJtZWQoKTsKICAgICAgICBidXllciA9IHBheWFibGUobXNnLnNlbmRlcik7CiAgICAgICAgc3RhdGUgPSBTdGF0ZS5Mb2NrZWQ7CiAgICB9CgogICAgLy8vIE1hbMSxIHRlc2xpbSBhbGTEscSfxLFuxLEgb25heWxhIChhbMSxY8SxKQogICAgLy8vIEtpdGxpIGV0aGVyaSBzZXJiZXN0IGLEsXJha2FjYWsuCiAgICBmdW5jdGlvbiBjb25maXJtUmVjZWl2ZWQoKQogICAgICAgIGV4dGVybmFsCiAgICAgICAgb25seUJ1eWVyCiAgICAgICAgaW5TdGF0ZShTdGF0ZS5Mb2NrZWQpCiAgICB7CiAgICAgICAgZW1pdCBJdGVtUmVjZWl2ZWQoKTsKICAgICAgICAvLyBEdXJ1bXUgKHN0YXRlKSDDtm5jZWRlbiBkZcSfacWfdGlybWVrIG9sZHVrw6dhIMO2bmVtbGkKICAgICAgICAvLyB5b2tzYSBhxZ9hxJ/EsWRha2kgYHNlbmRgIGkga29udHJhdGxhciBidXJhZGEgdGVrcmFyCiAgICAgICAgLy8gYnUgZm9ua3NpeW9udSDDp2HEn8SxcmFiaWxpci4gKHRla3JhciBnaXJpxZ8gc2FsZMSxcsSxc8SxIC0gcmVlbnRyYW5jeSBhdHRhY2spCiAgICAgICAgc3RhdGUgPSBTdGF0ZS5SZWxlYXNlOwoKICAgICAgICBidXllci50cmFuc2Zlcih2YWx1ZSk7CiAgICB9CgogICAgLy8vIEJ1IGZvbmtzaXlvbiBzYXTEsWPEsXlhIGlhZGUgZWRlcgogICAgLy8vIChzYXTEsWPEsW7EsW4ga2l0bGkgcGFyYXPEsW7EsSBnZXJpIMO2ZGVyKQogICAgZnVuY3Rpb24gcmVmdW5kU2VsbGVyKCkKICAgICAgICBleHRlcm5hbAogICAgICAgIG9ubHlTZWxsZXIKICAgICAgICBpblN0YXRlKFN0YXRlLlJlbGVhc2UpCiAgICB7CiAgICAgICAgZW1pdCBTZWxsZXJSZWZ1bmRlZCgpOwogICAgICAgIC8vIER1cnVtdSAoc3RhdGUpIMO2bmNlZGVuIGRlxJ9pxZ90aXJtZWsgb2xkdWvDp2Egw7ZuZW1saQogICAgICAgIC8vIHlva3NhIGHFn2HEn8SxZGFraSBgc2VuZGAgaSBrb250cmF0bGFyIGJ1cmFkYSB0ZWtyYXIKICAgICAgICAvLyBidSBmb25rc2l5b251IMOnYcSfxLFyYWJpbGlyLiAodGVrcmFyIGdpcmnFnyBzYWxkxLFyxLFzxLEgLSByZWVudHJhbmN5IGF0dGFjaykKICAgICAgICBzdGF0ZSA9IFN0YXRlLkluYWN0aXZlOwoKICAgICAgICBzZWxsZXIudHJhbnNmZXIoMyAqIHZhbHVlKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract Purchase {
 uint public value;
 address payable public seller;
 address payable public buyer;
 enum State { Created, Locked, Release, Inactive }
 // state değişkeni varsayılan olarak ilk üyedir, \`State.created\`
 State public state;
 modifier condition(bool condition\_) {
 require(condition\_);
 \_;
 }
 /// Bu fonksiyonu sadece alıcı çağırabilir
 error OnlyBuyer();
 /// BU fonksyionu sadece satıcı çağırabilir.
 error OnlySeller();
 /// Bu fonksiyon şu an çağırılamaz.
 error InvalidState();
 /// Girilen değer çift olmalı.
 error ValueNotEven();
 modifier onlyBuyer() {
 if (msg.sender != buyer)
 revert OnlyBuyer();
 \_;
 }
 modifier onlySeller() {
 if (msg.sender != seller)
 revert OnlySeller();
 \_;
 }
 modifier inState(State state\_) {
 if (state != state\_)
 revert InvalidState();
 \_;
 }
 event Aborted();
 event PurchaseConfirmed();
 event ItemReceived();
 event SellerRefunded();
 // \`msg.value\` in çift olduğundan emin ol.
 // Eğer tek sayı ise bölme kırpılmış bir sonuç olacak.
 // Çarpma ile tek sayı olmadığını kontrol et.
 constructor() payable {
 seller \= payable(msg.sender);
 value \= msg.value / 2;
 if ((2 \* value) != msg.value)
 revert ValueNotEven();
 }
 /// Satın almayı iptal et ve etheri geri al.
 /// Sadece satıcı tarafından kontrat kitlenmeden
 /// önce çağırılabilir.
 function abort()
 external
 onlySeller
 inState(State.Created)
 {
 emit Aborted();
 state \= State.Inactive;
 // Burada transfer'i direkt olarak kullanıyoruz.
 // Tekrar giriş (reentrancy) saldırılarına karşı güvenli
 // çünkü fonksiyondaki son çağrı (call) ve durumu (state)
 // zaten değiştirdik.
 seller.transfer(address(this).balance);
 }
 /// Alıcı olarak satın almayı onayla.
 /// İşlem \`2 \* value\` kadar ether içermeli.
 /// Ether confirmReceived fonksiyonu çağırılana
 /// kadar kitli kalacak.
 function confirmPurchase()
 external
 inState(State.Created)
 condition(msg.value \== (2 \* value))
 payable
 {
 emit PurchaseConfirmed();
 buyer \= payable(msg.sender);
 state \= State.Locked;
 }
 /// Malı teslim aldığını onayla (alıcı)
 /// Kitli etheri serbest bırakacak.
 function confirmReceived()
 external
 onlyBuyer
 inState(State.Locked)
 {
 emit ItemReceived();
 // Durumu (state) önceden değiştirmek oldukça önemli
 // yoksa aşağıdaki \`send\` i kontratlar burada tekrar
 // bu fonksiyonu çağırabilir. (tekrar giriş saldırısı - reentrancy attack)
 state \= State.Release;
 buyer.transfer(value);
 }
 /// Bu fonksiyon satıcıya iade eder
 /// (satıcının kitli parasını geri öder)
 function refundSeller()
 external
 onlySeller
 inState(State.Release)
 {
 emit SellerRefunded();
 // Durumu (state) önceden değiştirmek oldukça önemli
 // yoksa aşağıdaki \`send\` i kontratlar burada tekrar
 // bu fonksiyonu çağırabilir. (tekrar giriş saldırısı - reentrancy attack)
 state \= State.Inactive;
 seller.transfer(3 \* value);
 }
}
## Mikro Ödeme Kanalı[](#mikro-odeme-kanali "Permalink to this heading")
Bu bölümde bir ödeme kanalı örneğinin nasıl yapılacağını öğreneceğiz. Bu sistem belli kişiler arasındaki Ether transferini güvenli, anında ve işlem masrafsız gerçekleştirmek için kriptografik imzaları kullanacak. Bu örnek için, imzaların nasıl imzalandığını ve doğrulandığını anlamamız gerekiyor.
### İmza Oluşturma ve Doğrulama[](#imza-olusturma-ve-dogrulama "Permalink to this heading")
Mesela Alice Bob’a bir miktar Ether göndermek istiyor. Başka bir deyişle Alice gönderici Bob ise alıcı.
Alice’in Bob’a, çek yazmaya benzer bir şekilde, sadece kriptografik olarak imzalanmış off-chain (zincir dışı) bir mesaj göndermesi yeterli.
Alice ve Bob bu imzaları ödemeleri yetkilendirmek için kullanabilirler ve bu Ethereum üzerindeki akıllı kontratlar ile mümkün olan bir şey. Alice Ethere göndermek için basit bir akıllı kontrat yazacak ancak bu fonksiyonu kendi çağırmak yerine Bob’un çağırmasını isteyecek böylece Bob işlem masraflarını da ödemiş olacak.
Kontrat aşağıdaki şekilde ilerleyecek.
> 1. Alice içine ödeme için gerekli Ether’i de ekleyerek `ReceiverPays` kontratını yayınlayacak.
> 
> 2. Alice ödemeyi gizli anahtarı ile imzalayarak yetkilendirecek.
> 
> 3. Alice kriptografik olarak imzalanmış mesajı Bob’a gönderecek. Mesajın gizli tutulmasına (daha sonra açıklanacak) gerek yok ve mesaj herhangi bir yöntem ile gönderilebilir.
> 
> 4. Bob imzalanmış mesajı akıllı kontrata girerek ödemesini alabilir, akullı kontrat mesajın gerçekliğini doğrular ve ödemeyi serbest bırakır.
> 
#### İmza oluşturma[](#imza-olusturma "Permalink to this heading")
Alice’in ödemeyi imzlamak için Ethereum ağı ile etkileşime girmesine gerek yok, bu işlem tamamiyle çevrimdışı gerçekleştirilebilir. Bu eğitimde, mesajları tarayıcıda [web3.js](https://github.com/ethereum/web3.js) ve [MetaMask](https://metamask.io/) kullanarak ve getirdiği güvenlik kazançları için [EIP-712](https://github.com/ethereum/EIPs/pull/712) gösterilen metot ile imzalayacağız.
/// En başta "Hash"leme işleri daha kolay bir hale getirir
var hash \= web3.utils.sha3("imzalanacak mesaj");
web3.eth.personal.sign(hash, web3.eth.defaultAccount, function () { console.log("İmzalandı"); });
Not
`web3.eth.personal.sign` mesajın uzunluğunu imzalanmış bilginin başına ekler. İlk olarak “hash”lediğimiz için, mesaj her zaman 32 bayt uzunluğunda olacak ve dolayısıyla bu uzunluk ön eki her zaman aynı olacak.
#### Ne İmzalanacak[](#ne-imzalanacak "Permalink to this heading")
Ödeme gerçekleştiren bir kontrat için, imzalanmış bir mesaj aşağıdakiler içermeli:
> 1. Alıcının adresi.
> 
> 2. Transfer edilecek miktar.
> 
> 3. Tekrarlama saldırılarına karşı önlem
> 
Tekrarlama saldırısı, imzalanmış bir mesajın tekrar yetkilendirme için kullanılmasıdır. Tekrarlama saldırılarını önlemek için Ethereum işlemlerinden kullanan bir cüzdandan yapılan işlem sayısını, nonce, kullanan tekniği kullanacğız. Akıllı kontrat bir nonce un bir kaç kez kullanılıp kullanılmadığını kontrol edecek.
Başka bir tekrarlamma saldırısı açığı ödemeyi gönderen kişi `ReceiverPays` akıllı kontratını yayınlayıp sonrasında yok edip sonra tekrar yayınladığında oluşur. Bunun sebebi tekrar yayınlanan kontrat önceki kontratta kullanılan nonce ları bilemediğinden saldırgan eski mesajları tekrar kullanabilir.
Alice buna karşı korunmak için kontratın adresini de mesajın içerisine ekleyebilir. Böylece sadece kontrat’ın adresini içeren mesajlar onaylanır. Bu örneği bu bölümün sonundaki tam kontratın `claimPayment()` fonksiyonundaki ilk iki satırda görebilirsiniz.
#### Argümanları Paketleme[](#argumanlari-paketleme "Permalink to this heading")
Şimdi imzalanmış mesajımızda nelerin olacağına karar verdiğimize göre mesajı mesajı oluşturup, hashleyip, imzalamaya hazırız. Basit olsun diye verileri art arda bağlayacağız. [ethereumjs-abi](https://github.com/ethereumjs/ethereumjs-abi) kütüphanesi bize `soliditySHA3` adında Solidity’deki `abi.encodePacked` ile enkode edilmiş argümanlara `keccak256` fonksiyonu uygulanması ile aynı işlevi gören bir fonksiyon sağlıyor. Aşağıda `ReceiverPays` için düzgün bir imza sağlayan JavaScript fonksiyonunu görebilirsiniz.
// recipient alıcı adres,
// amount, wei cinsinden, ne kadar gönderilmesi gerektiği
// nonce, tekrarlama saldırılarını önlemek için eşsiz bir sayı
// contractAddress, kontratlar arası tekrarlama saldırısını engellemek için kontrat adresi
function signPayment(recipient, amount, nonce, contractAddress, callback) {
 var hash \= "0x" + abi.soliditySHA3(
 \["address", "uint256", "uint256", "address"\],
 \[recipient, amount, nonce, contractAddress\]
 ).toString("hex");
 web3.eth.personal.sign(hash, web3.eth.defaultAccount, callback);
}
#### Solidity’de İmzalayanı Bulma[](#solidity-de-imzalayani-bulma "Permalink to this heading")
Genelde ECDSA imzaları iki parametreden oluşur, `r` ve `s`. Ethereum’daki imzalar `v` denilen üçüncü bir parametre daha içerir. `v` parametresi ile mesajı imzalamak için kullanılmış cüzdanın gizli anahtarı doğrulanabiliyirsiniz. Solidity [ecrecover](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html#mathematical-and-cryptographic-functions) fonksiyonunu gömülü olarak sağlamaktadır. Bu fonksiyon mesajla birlikte `r`, `s` ve `v` parametrelerini de alır ve mesajı imzalamak için kullanılmış adresi verir.
#### İmza Parametrelerini Çıkartma[](#imza-parametrelerini-cikartma "Permalink to this heading")
web3.js ile oluşturulmuş imzalar `r`, `s` ve `v`’in birleştirilmesi ile oluşturulur, yani ilk adım bu parametreleri ayırmak. Bunu kullanıcı tarafında da yapabilirsiniz ancak parametre ayırma işleminin akıllı kontratın içinde olması akıllı kontrata üç parametre yerine sadece bir parametre göndermemizi sağlar. Bir bayt dizisini (byte array) bileşenlerine ayırmak biraz karışık dolayısıyla bu işlemi `splitSignature` fonksiyonunda yapmak için [inline assembly](https://docs.soliditylang.org/tr/latest/assembly.html) kullanacağız. (Bu bölümün sonundaki tam kontrattaki üçüncü fonksiyon.)
#### Mesaj Hashini Hesaplama[](#mesaj-hashini-hesaplama "Permalink to this heading")
Akıllı kontratın tam olarak hangi parametrelerin izalandığını bilmesi gerekiyor çünkü kontratın imzzayı doğrulamak için mesajı parametrelerinden tekrar oluşturması lazım. `claimPayment` fonksiyonundaki `prefixed` ve `recoverSigner` fonksiyonları bu işlemi gerçekleştiriyor.
#### Tam Kontrat[](#tam-kontrat "Permalink to this heading")
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwpjb250cmFjdCBSZWNlaXZlclBheXMgewogICAgYWRkcmVzcyBvd25lciA9IG1zZy5zZW5kZXI7CgogICAgbWFwcGluZyh1aW50MjU2ID0+IGJvb2wpIHVzZWROb25jZXM7CgogICAgY29uc3RydWN0b3IoKSBwYXlhYmxlIHt9CgogICAgZnVuY3Rpb24gY2xhaW1QYXltZW50KHVpbnQyNTYgYW1vdW50LCB1aW50MjU2IG5vbmNlLCBieXRlcyBtZW1vcnkgc2lnbmF0dXJlKSBleHRlcm5hbCB7CiAgICAgICAgcmVxdWlyZSghdXNlZE5vbmNlc1tub25jZV0pOwogICAgICAgIHVzZWROb25jZXNbbm9uY2VdID0gdHJ1ZTsKCiAgICAgICAgLy8gaXN0ZW1jaWRlIGltemFsYW5txLHFnyBtZXNhasSxIHRla3JhciBvbHXFn3R1cnVyLgogICAgICAgIGJ5dGVzMzIgbWVzc2FnZSA9IHByZWZpeGVkKGtlY2NhazI1NihhYmkuZW5jb2RlUGFja2VkKG1zZy5zZW5kZXIsIGFtb3VudCwgbm9uY2UsIHRoaXMpKSk7CgogICAgICAgIHJlcXVpcmUocmVjb3ZlclNpZ25lcihtZXNzYWdlLCBzaWduYXR1cmUpID09IG93bmVyKTsKCiAgICAgICAgcGF5YWJsZShtc2cuc2VuZGVyKS50cmFuc2ZlcihhbW91bnQpOwogICAgfQoKICAgIC8vLyBzw7Z6bGXFn21leWkgeW9rIGVkZXIgdmUga2FsYW4gcGFyYXnEsSBnZXJpIGFsxLFyCiAgICBmdW5jdGlvbiBzaHV0ZG93bigpIGV4dGVybmFsIHsKICAgICAgICByZXF1aXJlKG1zZy5zZW5kZXIgPT0gb3duZXIpOwogICAgICAgIHNlbGZkZXN0cnVjdChwYXlhYmxlKG1zZy5zZW5kZXIpKTsKICAgIH0KCiAgICAvLy8gaW16YSBtZXRob2RsYXLEsQogICAgZnVuY3Rpb24gc3BsaXRTaWduYXR1cmUoYnl0ZXMgbWVtb3J5IHNpZykKICAgICAgICBpbnRlcm5hbAogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50OCB2LCBieXRlczMyIHIsIGJ5dGVzMzIgcykKICAgIHsKICAgICAgICByZXF1aXJlKHNpZy5sZW5ndGggPT0gNjUpOwoKICAgICAgICBhc3NlbWJseSB7CiAgICAgICAgICAgIC8vIHV6dW5sdWsgw7ZuZWtpbmRlbiBzb25yYWtpIGlsayAzMiBiYXl0LgogICAgICAgICAgICByIDo9IG1sb2FkKGFkZChzaWcsIDMyKSkKICAgICAgICAgICAgLy8gaWtpbmNpIDMyIGJheXQKICAgICAgICAgICAgcyA6PSBtbG9hZChhZGQoc2lnLCA2NCkpCiAgICAgICAgICAgIC8vIHNvbiBiYXl0IChnZWxlY2VrIDMyIGJheXTEsW4gc29uIGJheXTEsSkKICAgICAgICAgICAgdiA6PSBieXRlKDAsIG1sb2FkKGFkZChzaWcsIDk2KSkpCiAgICAgICAgfQoKICAgICAgICByZXR1cm4gKHYsIHIsIHMpOwogICAgfQoKICAgIGZ1bmN0aW9uIHJlY292ZXJTaWduZXIoYnl0ZXMzMiBtZXNzYWdlLCBieXRlcyBtZW1vcnkgc2lnKQogICAgICAgIGludGVybmFsCiAgICAgICAgcHVyZQogICAgICAgIHJldHVybnMgKGFkZHJlc3MpCiAgICB7CiAgICAgICAgKHVpbnQ4IHYsIGJ5dGVzMzIgciwgYnl0ZXMzMiBzKSA9IHNwbGl0U2lnbmF0dXJlKHNpZyk7CgogICAgICAgIHJldHVybiBlY3JlY292ZXIobWVzc2FnZSwgdiwgciwgcyk7CiAgICB9CgogICAgLy8vIGV0aF9zaWduJ2kga29weWFsYXlhbiDDtm7DvG5lIGVrbGVubWnFnyBoYXNoIG9sdcWfdHVydXIuCiAgICBmdW5jdGlvbiBwcmVmaXhlZChieXRlczMyIGhhc2gpIGludGVybmFsIHB1cmUgcmV0dXJucyAoYnl0ZXMzMikgewogICAgICAgIHJldHVybiBrZWNjYWsyNTYoYWJpLmVuY29kZVBhY2tlZCgiXHgxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxuMzIiLCBoYXNoKSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract ReceiverPays {
 address owner \= msg.sender;
 mapping(uint256 \=> bool) usedNonces;
 constructor() payable {}
 function claimPayment(uint256 amount, uint256 nonce, bytes memory signature) external {
 require(!usedNonces\[nonce\]);
 usedNonces\[nonce\] \= true;
 // istemcide imzalanmış mesajı tekrar oluşturur.
 bytes32 message \= prefixed(keccak256(abi.encodePacked(msg.sender, amount, nonce, this)));
 require(recoverSigner(message, signature) \== owner);
 payable(msg.sender).transfer(amount);
 }
 /// sözleşmeyi yok eder ve kalan parayı geri alır
 function shutdown() external {
 require(msg.sender \== owner);
 selfdestruct(payable(msg.sender));
 }
 /// imza methodları
 function splitSignature(bytes memory sig)
 internal
 pure
 returns (uint8 v, bytes32 r, bytes32 s)
 {
 require(sig.length \== 65);
 assembly {
 // uzunluk önekinden sonraki ilk 32 bayt.
 r := mload(add(sig, 32))
 // ikinci 32 bayt
 s := mload(add(sig, 64))
 // son bayt (gelecek 32 baytın son baytı)
 v := byte(0, mload(add(sig, 96)))
 }
 return (v, r, s);
 }
 function recoverSigner(bytes32 message, bytes memory sig)
 internal
 pure
 returns (address)
 {
 (uint8 v, bytes32 r, bytes32 s) \= splitSignature(sig);
 return ecrecover(message, v, r, s);
 }
 /// eth\_sign'i kopyalayan önüne eklenmiş hash oluşturur.
 function prefixed(bytes32 hash) internal pure returns (bytes32) {
 return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));
 }
}
### Basit Bir Ödeme Kanalı Yazmak[](#basit-bir-odeme-kanali-yazmak "Permalink to this heading")
Alice şimdi ödeme basit ama tam işlevsel bir ödeme kanalı oluşturacak. Ödeme kanalları anında ve masrafsız tekrarlayan Ether transferleri gerçekleştirmek için kriptografik imzaları kullanırlar.
#### Ödeme Kanalı Nedir?[](#odeme-kanali-nedir "Permalink to this heading")
Ödeme kanalları katılımcıların herhangi bir işlem gerçekleştirmeden tekrarlayan Ether transferleri gerçekleştirmelerini sağlar. Bu sayesede ödemeyle ilgili gecikme ve masraflardan kurtulabilirsiniz. Şimdi iki kişi (Alice ve Bob) arasında tek yönlü bir ödeme kanalı nasıl oluşturul onu göreceğiz. Böyle bir sistemi 3 adımda oluşturabiliriz. Bunlar:
> 1. Alice ödeme kanalına Ether yükler böylece ödeme kanali “açık” hale gelir.
> 
> 2. Alice ne kadar Ether’in ödenmesi gerektiğini bir mesajda belirtir. Bu adım her ödemede tekrar gerçekleştirilir.
> 
> 3. Bob Ether ödemesini alıp kalanı geri göndererek ödeme kanalını kapatır.
> 
Not
Sadece 1. ve 3. adımlar Ethereum işlemi gerektiriyor. 2. adımda gönderici kriptografik olarak imzalanmış mesajı alıcıya zincir dışı (off-chain) bir şekilde (mesela e-posta) gönderebilir. Kısaca herhangi bir sayıda transfer için 2 Ethereum işlemi gerekiyor.
Bob kesinlikle parasını alacak çünkü Ether bir akıllı kontratta tutuluyor ve geçerli bir imzalı mesaj ile akıllı kontratlar her zaman işlemi gerçekleştirir. Akıllı kontrat ayrıca zaman aşımını da zorunlu tutar, yani alıcı parası almazsa Alice eninde sonunda parasını geri alabilir. Zaman aşımının süresine katılımcılar kendi karar verir. İnternet kafedeki kullanım süresi gibi kısa süreli bir işlem için, ödeme kanalı süreli bir şekilde oluşturulabilir. Diğer bir yandan, bir çalışana saatlik maaşını ödemek gibi tekrarlayan bir ödeme için ödeme kanalı bir kaç ay ya da yıl açık kalabilir.
#### Ödeme Kanalını Açma[](#odeme-kanalini-acma "Permalink to this heading")
Ödeme kanalını açmak için Alice içine gerekli Ether’i ekleyip ve alıcının kim olduğunu girerek akıllı kontratı yayınlar. Bu işlemi bölümün sonundaki kontratta `SimplePaymentChannel` fonksiyonu gerçekleştirir.
#### Ödeme Gerçekleştirme[](#odeme-gerceklestirme "Permalink to this heading")
Alice ödemeyi Bob’a imzalanmış mesajı göndererek yapar. Bu adım tamammiyle Etherum ağının dışında gerçekeleşir. Mesaj gönderici tarafında kriptografik olarak imzalanır ve direkt olarak alıcıya gönderilir.
Her mesaj aşağıdaki bilgileri içerir:
> * Akıllı kontratın adresi, kontratlar arası tekrarlama saldırılarını önlemek için.
> 
> * Alıcıya borçlu olunan Ether miktarı.
> 
Ödeme kanalı bütün transferler gerçekleştikten sonra sadece bir kez kapanır. Bundan dolayı sadece bir mesajın ödemesi gerçekleşir. Bu yüzden her mesaj küçük ödemeler yerine toplam gönderilmesi gereken Ether miktarını içerir. Alıcı doğal olarak en yüksek miktarı alabilmek için en güncel mesajın ödemesini alır. Artık akıllı kontrat sadece bir mesaj okuduğunderstan artık işlem sayısını (nonce) mesaja eklemeye gerek yok ancak akıllı kontratın adresine mesajın başka bir ödeme kanalında kullanılmaması için hala ihtiyaç var.
Aşağıda önceki bölümdeki mesajın kriptografik imzalanmasını sağlayan JavaScript kodunun düzenlenmiş bir halini bulabilirsiniz.
function constructPaymentMessage(contractAddress, amount) {
 return abi.soliditySHA3(
 \["address", "uint256"\],
 \[contractAddress, amount\]
 );
}
function signMessage(message, callback) {
 web3.eth.personal.sign(
 "0x" + message.toString("hex"),
 web3.eth.defaultAccount,
 callback
 );
}
// contractAddress, kontratlar arası tekrarlama saldırısını engellemek için kontrat adresi
// amount, wei cinsinden, ne kadar gönderilmesi gerektiği
function signPayment(contractAddress, amount, callback) {
 var message \= constructPaymentMessage(contractAddress, amount);
 signMessage(message, callback);
}
#### Ödeme Kanalını Kapatma[](#odeme-kanalini-kapatma "Permalink to this heading")
Bob ödemesini almaya hazır olduğunda ödeme kanalını da `close` fonksiyonunu çağırarak kapatmanın vakti de gelmiş demektir. Kanal kapatıldığında alıcı kendine borçlu olunan Ether miktarını alır ve kalan miktarı Alice’e geri göndererek kontratı yok eder. Bob sadece Alice tarafında imzalanmış bir mesaj ile kanalı kapatabilir.
Akıllı kontratın göndericiden gelen geçerli bir mesajı doğrulaması gerekir. Bu doğrulama süreci alıcının kullandığı süreç ile aynıdır. Solidity fonksiyonlarından `isValidSignature` ve `recoverSigner` (`ReceiverPays` kontratından aldık) önceki bölümdeki JavaScript hallerindekiyle aynı şekilde çalışır.
Sadece ödeme kanalının alıcısı `close` fonksiyonunu çağırabilir. Alıcı da doğal olarak en yüksek miktarı taşığı için en güncel mesajı gönderir. Eğer gönderici bu mesajı çağırabiliyor olsaydı daha düşük bir miktar içeren bir mesaj ile çağırıp, ödemeleri gerekenden daha düşük bir para göndererek hile yapabilirlerdi.
Fonksiyon verilen parametreler ile imzalanmış mesajı doğrular. Eğer her şey uygunsa, alıcıya kendi payına düşen Ether miktarı gönderilir ve göndericiye kalan miktar `selfdestruct` ile gönderilir. Tam kontratta `close` fonksiyonunu görebilirsiniz.
#### Kanalın Zaman Aşımına Uğraması[](#kanalin-zaman-asimina-ugramasi "Permalink to this heading")
Bob istediği zaman ödeme kanalını kapatabilir anca kapatmazsa Alice’in bir şekilde parasını geri alması gerekiyor. Bunun için kontrata bir _zaman aşımı_ süresi girilir. Süre dolduğunda, Alice `claimTimeout` fonksiyonunu çağırarak içerideki parasını geri alabilir. `claimTimeout` fonksyionunu tam kontratta görebilirsiniz.
Bu fonksiyon çağırıldıktan sonra Bob artık sistemden Ether alamaz dolayısıyla Bob’un zaman aşımına uğramadan parasını alması oldukça önemli.
#### Tam Kontrat[](#id3 "Permalink to this heading")
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwpjb250cmFjdCBTaW1wbGVQYXltZW50Q2hhbm5lbCB7CiAgICBhZGRyZXNzIHBheWFibGUgcHVibGljIHNlbmRlcjsgICAgICAvLyBnw7ZuZGVyaWNpbmluIGFkcmVzaS4KICAgIGFkZHJlc3MgcGF5YWJsZSBwdWJsaWMgcmVjaXBpZW50OyAgIC8vIGFsxLFjxLFuxLFuIGFkcmVzaS4KICAgIHVpbnQyNTYgcHVibGljIGV4cGlyYXRpb247ICAvLyBrYXBhbm1hbWFzxLEgZHVydW11bmRhIHphbWFuIGHFn8SxbcSxIHPDvHJlc2kuCgogICAgY29uc3RydWN0b3IgKGFkZHJlc3MgcGF5YWJsZSByZWNpcGllbnRBZGRyZXNzLCB1aW50MjU2IGR1cmF0aW9uKQogICAgICAgIHBheWFibGUKICAgIHsKICAgICAgICBzZW5kZXIgPSBwYXlhYmxlKG1zZy5zZW5kZXIpOwogICAgICAgIHJlY2lwaWVudCA9IHJlY2lwaWVudEFkZHJlc3M7CiAgICAgICAgZXhwaXJhdGlvbiA9IGJsb2NrLnRpbWVzdGFtcCArIGR1cmF0aW9uOwogICAgfQoKICAgIC8vLyBhbMSxY8SxLCBnw7ZuZGVyaWNpbmluIGltemFsxLEgbWVzYWrEsSBpbGUgaXN0ZWRpxJ9pIHphbWFuIGthbmFsxLEga2FwYXRhYmlsaXIuCiAgICAvLy8gYWzEsWPEsSBhbGFjYWtsxLFzxLEgb2xkdcSfdSBtaWt0YXLEsSBhbMSxcAogICAgLy8vIGthbGFuxLEgZ8O2bmRlcmljaXllIGdlcmkgZ8O2bmRlcmlyLgogICAgZnVuY3Rpb24gY2xvc2UodWludDI1NiBhbW91bnQsIGJ5dGVzIG1lbW9yeSBzaWduYXR1cmUpIGV4dGVybmFsIHsKICAgICAgICByZXF1aXJlKG1zZy5zZW5kZXIgPT0gcmVjaXBpZW50KTsKICAgICAgICByZXF1aXJlKGlzVmFsaWRTaWduYXR1cmUoYW1vdW50LCBzaWduYXR1cmUpKTsKCiAgICAgICAgcmVjaXBpZW50LnRyYW5zZmVyKGFtb3VudCk7CiAgICAgICAgc2VsZmRlc3RydWN0KHNlbmRlcik7CiAgICB9CgogICAgLy8vIGfDtm5kZXJpY2kgemFtYW4gYcWfxLFtxLEgc8O8cmVzaW5pIGlzdGVkacSfaSB6YW1hbiBhcnR0xLFyYWJpbGlyCiAgICBmdW5jdGlvbiBleHRlbmQodWludDI1NiBuZXdFeHBpcmF0aW9uKSBleHRlcm5hbCB7CiAgICAgICAgcmVxdWlyZShtc2cuc2VuZGVyID09IHNlbmRlcik7CiAgICAgICAgcmVxdWlyZShuZXdFeHBpcmF0aW9uID4gZXhwaXJhdGlvbik7CgogICAgICAgIGV4cGlyYXRpb24gPSBuZXdFeHBpcmF0aW9uOwogICAgfQoKICAgIC8vLyBFxJ9lciBzw7xyZSBhbMSxY8SxIGthbmFsxLEga2FwYXRtYWRhbiBkb2xhcnNhCiAgICAvLy8gRXRoZXIgZ8O2bmRlcmljaXllIGdlcmkgZMO2bmVyCiAgICBmdW5jdGlvbiBjbGFpbVRpbWVvdXQoKSBleHRlcm5hbCB7CiAgICAgICAgcmVxdWlyZShibG9jay50aW1lc3RhbXAgPj0gZXhwaXJhdGlvbik7CiAgICAgICAgc2VsZmRlc3RydWN0KHNlbmRlcik7CiAgICB9CgogICAgZnVuY3Rpb24gaXNWYWxpZFNpZ25hdHVyZSh1aW50MjU2IGFtb3VudCwgYnl0ZXMgbWVtb3J5IHNpZ25hdHVyZSkKICAgICAgICBpbnRlcm5hbAogICAgICAgIHZpZXcKICAgICAgICByZXR1cm5zIChib29sKQogICAgewogICAgICAgIGJ5dGVzMzIgbWVzc2FnZSA9IHByZWZpeGVkKGtlY2NhazI1NihhYmkuZW5jb2RlUGFja2VkKHRoaXMsIGFtb3VudCkpKTsKCiAgICAgICAgLy8gaW16YW7EsW4gZ8O2bmRlcmljaWRlbiBnZWxkacSfaW5pIGtvbnRyb2wgZXQKICAgICAgICByZXR1cm4gcmVjb3ZlclNpZ25lcihtZXNzYWdlLCBzaWduYXR1cmUpID09IHNlbmRlcjsKICAgIH0KCiAgICAvLy8gQcWfYcSfxLFkYWtpIHTDvG0ga29ua3N5aW9ubGFyICdpbXphIG9sdcWfdHVybWEgdmUgZG/En3J1bGFtYScKICAgIC8vLyBiw7Zsw7xtw7xuZGVuIGFsxLFuZMSxLgoKICAgIGZ1bmN0aW9uIHNwbGl0U2lnbmF0dXJlKGJ5dGVzIG1lbW9yeSBzaWcpCiAgICAgICAgaW50ZXJuYWwKICAgICAgICBwdXJlCiAgICAgICAgcmV0dXJucyAodWludDggdiwgYnl0ZXMzMiByLCBieXRlczMyIHMpCiAgICB7CiAgICAgICAgcmVxdWlyZShzaWcubGVuZ3RoID09IDY1KTsKCiAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICAvLyB1enVubHVrIMO2bmVraW5kZW4gc29ucmFraSBpbGsgMzIgYmF5dC4KICAgICAgICAgICAgciA6PSBtbG9hZChhZGQoc2lnLCAzMikpCiAgICAgICAgICAgIC8vIGlraW5jaSAzMiBiYXl0CiAgICAgICAgICAgIHMgOj0gbWxvYWQoYWRkKHNpZywgNjQpKQogICAgICAgICAgICAvLyBzb24gYmF5dCAoZ2VsZWNlayAzMiBiYXl0xLFuIHNvbiBiYXl0xLEpCiAgICAgICAgICAgIHYgOj0gYnl0ZSgwLCBtbG9hZChhZGQoc2lnLCA5NikpKQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuICh2LCByLCBzKTsKICAgIH0KCiAgICBmdW5jdGlvbiByZWNvdmVyU2lnbmVyKGJ5dGVzMzIgbWVzc2FnZSwgYnl0ZXMgbWVtb3J5IHNpZykKICAgICAgICBpbnRlcm5hbAogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zIChhZGRyZXNzKQogICAgewogICAgICAgICh1aW50OCB2LCBieXRlczMyIHIsIGJ5dGVzMzIgcykgPSBzcGxpdFNpZ25hdHVyZShzaWcpOwoKICAgICAgICByZXR1cm4gZWNyZWNvdmVyKG1lc3NhZ2UsIHYsIHIsIHMpOwogICAgfQoKICAgIC8vLyBldGhfc2lnbidpIGtvcHlhbGF5YW4gw7Zuw7xuZSBla2xlbm1pxZ8gaGFzaCBvbHXFn3R1cnVyLgogICAgZnVuY3Rpb24gcHJlZml4ZWQoYnl0ZXMzMiBoYXNoKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKGJ5dGVzMzIpIHsKICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQoIlx4MTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcbjMyIiwgaGFzaCkpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract SimplePaymentChannel {
 address payable public sender; // göndericinin adresi.
 address payable public recipient; // alıcının adresi.
 uint256 public expiration; // kapanmaması durumunda zaman aşımı süresi.
 constructor (address payable recipientAddress, uint256 duration)
 payable
 {
 sender \= payable(msg.sender);
 recipient \= recipientAddress;
 expiration \= block.timestamp + duration;
 }
 /// alıcı, göndericinin imzalı mesajı ile istediği zaman kanalı kapatabilir.
 /// alıcı alacaklısı olduğu miktarı alıp
 /// kalanı göndericiye geri gönderir.
 function close(uint256 amount, bytes memory signature) external {
 require(msg.sender \== recipient);
 require(isValidSignature(amount, signature));
 recipient.transfer(amount);
 selfdestruct(sender);
 }
 /// gönderici zaman aşımı süresini istediği zaman arttırabilir
 function extend(uint256 newExpiration) external {
 require(msg.sender \== sender);
 require(newExpiration \> expiration);
 expiration \= newExpiration;
 }
 /// Eğer süre alıcı kanalı kapatmadan dolarsa
 /// Ether göndericiye geri döner
 function claimTimeout() external {
 require(block.timestamp \>= expiration);
 selfdestruct(sender);
 }
 function isValidSignature(uint256 amount, bytes memory signature)
 internal
 view
 returns (bool)
 {
 bytes32 message \= prefixed(keccak256(abi.encodePacked(this, amount)));
 // imzanın göndericiden geldiğini kontrol et
 return recoverSigner(message, signature) \== sender;
 }
 /// Aşağıdaki tüm konksyionlar 'imza oluşturma ve doğrulama'
 /// bölümünden alındı.
 function splitSignature(bytes memory sig)
 internal
 pure
 returns (uint8 v, bytes32 r, bytes32 s)
 {
 require(sig.length \== 65);
 assembly {
 // uzunluk önekinden sonraki ilk 32 bayt.
 r := mload(add(sig, 32))
 // ikinci 32 bayt
 s := mload(add(sig, 64))
 // son bayt (gelecek 32 baytın son baytı)
 v := byte(0, mload(add(sig, 96)))
 }
 return (v, r, s);
 }
 function recoverSigner(bytes32 message, bytes memory sig)
 internal
 pure
 returns (address)
 {
 (uint8 v, bytes32 r, bytes32 s) \= splitSignature(sig);
 return ecrecover(message, v, r, s);
 }
 /// eth\_sign'i kopyalayan önüne eklenmiş hash oluşturur.
 function prefixed(bytes32 hash) internal pure returns (bytes32) {
 return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));
 }
}
Not
`splitSignature` fonksiyonu bütün güvenlik önlemlerini almıyor. Gerçek bir uygulamada openzeppelin’in [versionu](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol) gibi daha iyi test edilmiş bir kütüphane kullanılmalı.
#### Ödemeleri Doğrulama[](#odemeleri-dogrulama "Permalink to this heading")
Önceki bölümlerdekinin aksine, ödeme kanalındaki mesajlar anında alınmamakta. Alıcı mesajların takibini yapıp zamanı geldiğinde ödeme kanalını kapatır. Yani bu durumda alıcının mesajları kendisinin doğrulaması oldukça önemli. Yoksa alıcının ödemesini kesin alacağının bir garantisi yok.
Alıcı her mesajı aşağıdaki işlemler ile doğrulamalı:
> 1. Mesajdaki kontrat adresinin ödeme kanalı ile aynı olduğunu kontrol et
> 
> 2. Yeni toplam miktarın beklenen miktar ile aynı olduğunu kontrol et
> 
> 3. Yeni toplam miktarın kontrattakinden fazla olmadığını kontrol et
> 
> 4. Mesajın ödeme kanalının göndericisinden geldiğini kontrol et.
> 
Bu doğrulamayı yazmak için [ethereumjs-util](https://github.com/ethereumjs/ethereumjs-util) kütüphanesini kullanacağız. Son adım için bir çok farklı yol var ve biz JavaScript kullanacağuz. Aşağıdaki kod `constructPaymentMessage` fonksiyonunu yukarıdaki imzalama **JavaScript kodundan** ödünç alıyor:
// Bu eth\_sign JSON-RPC metodunun ön ekleme özelliğini taklit eder.
function prefixed(hash) {
 return ethereumjs.ABI.soliditySHA3(
 \["string", "bytes32"\],
 \["\\x19Ethereum Signed Message:\\n32", hash\]
 );
}
function recoverSigner(message, signature) {
 var split \= ethereumjs.Util.fromRpcSig(signature);
 var publicKey \= ethereumjs.Util.ecrecover(message, split.v, split.r, split.s);
 var signer \= ethereumjs.Util.pubToAddress(publicKey).toString("hex");
 return signer;
}
function isValidSignature(contractAddress, amount, signature, expectedSigner) {
 var message \= prefixed(constructPaymentMessage(contractAddress, amount));
 var signer \= recoverSigner(message, signature);
 return signer.toLowerCase() \==
 ethereumjs.Util.stripHexPrefix(expectedSigner).toLowerCase();
}
## Modüler Kontratlar[](#moduler-kontratlar "Permalink to this heading")
Kontratları oluştururken modüler bir yaklaşım izlemek kodların karışıklığını azaltıp, okunabilirliğini arttırır. Bu durumda hataların ve açıkların daha kolay bir şekilde bulunmasını sağlar. Eğer her modülün nasıl davranacağını izole bir şekilde tanımlar ve kontrol ederseniz, sadece bütün kontratta olup biten yerine o kontratlar arasındaki ilişkileri inceleyebilirsiniz. Aşağıdaki örnekte kontrat adresler arasında gönderilenin beklenen şekilde olup olmadığını görmek için `Balances` [library](https://docs.soliditylang.org/tr/latest/contracts.html#libraries) kütüphanesinin `move` metodunu kullanır. `Balances` kütüphanesinin asla nefatif bir bakiye çıkarmadığı ya da bütün bakiyelerin toplamından overflow yaratmayacağı kolaylıkla doğrulanabilir ve bu durum kontratın yaşam süresi boyunca değişmez.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKbGlicmFyeSBCYWxhbmNlcyB7CiAgICBmdW5jdGlvbiBtb3ZlKG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50MjU2KSBzdG9yYWdlIGJhbGFuY2VzLCBhZGRyZXNzIGZyb20sIGFkZHJlc3MgdG8sIHVpbnQgYW1vdW50KSBpbnRlcm5hbCB7CiAgICAgICAgcmVxdWlyZShiYWxhbmNlc1tmcm9tXSA+PSBhbW91bnQpOwogICAgICAgIHJlcXVpcmUoYmFsYW5jZXNbdG9dICsgYW1vdW50ID49IGJhbGFuY2VzW3RvXSk7CiAgICAgICAgYmFsYW5jZXNbZnJvbV0gLT0gYW1vdW50OwogICAgICAgIGJhbGFuY2VzW3RvXSArPSBhbW91bnQ7CiAgICB9Cn0KCmNvbnRyYWN0IFRva2VuIHsKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50MjU2KSBiYWxhbmNlczsKICAgIHVzaW5nIEJhbGFuY2VzIGZvciAqOwogICAgbWFwcGluZyhhZGRyZXNzID0+IG1hcHBpbmcgKGFkZHJlc3MgPT4gdWludDI1NikpIGFsbG93ZWQ7CgogICAgZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBmcm9tLCBhZGRyZXNzIHRvLCB1aW50IGFtb3VudCk7CiAgICBldmVudCBBcHByb3ZhbChhZGRyZXNzIG93bmVyLCBhZGRyZXNzIHNwZW5kZXIsIHVpbnQgYW1vdW50KTsKCiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIHRvLCB1aW50IGFtb3VudCkgZXh0ZXJuYWwgcmV0dXJucyAoYm9vbCBzdWNjZXNzKSB7CiAgICAgICAgYmFsYW5jZXMubW92ZShtc2cuc2VuZGVyLCB0bywgYW1vdW50KTsKICAgICAgICBlbWl0IFRyYW5zZmVyKG1zZy5zZW5kZXIsIHRvLCBhbW91bnQpOwogICAgICAgIHJldHVybiB0cnVlOwoKICAgIH0KCiAgICBmdW5jdGlvbiB0cmFuc2ZlckZyb20oYWRkcmVzcyBmcm9tLCBhZGRyZXNzIHRvLCB1aW50IGFtb3VudCkgZXh0ZXJuYWwgcmV0dXJucyAoYm9vbCBzdWNjZXNzKSB7CiAgICAgICAgcmVxdWlyZShhbGxvd2VkW2Zyb21dW21zZy5zZW5kZXJdID49IGFtb3VudCk7CiAgICAgICAgYWxsb3dlZFtmcm9tXVttc2cuc2VuZGVyXSAtPSBhbW91bnQ7CiAgICAgICAgYmFsYW5jZXMubW92ZShmcm9tLCB0bywgYW1vdW50KTsKICAgICAgICBlbWl0IFRyYW5zZmVyKGZyb20sIHRvLCBhbW91bnQpOwogICAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICAgIGZ1bmN0aW9uIGFwcHJvdmUoYWRkcmVzcyBzcGVuZGVyLCB1aW50IHRva2VucykgZXh0ZXJuYWwgcmV0dXJucyAoYm9vbCBzdWNjZXNzKSB7CiAgICAgICAgcmVxdWlyZShhbGxvd2VkW21zZy5zZW5kZXJdW3NwZW5kZXJdID09IDAsICIiKTsKICAgICAgICBhbGxvd2VkW21zZy5zZW5kZXJdW3NwZW5kZXJdID0gdG9rZW5zOwogICAgICAgIGVtaXQgQXBwcm92YWwobXNnLnNlbmRlciwgc3BlbmRlciwgdG9rZW5zKTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBiYWxhbmNlT2YoYWRkcmVzcyB0b2tlbk93bmVyKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKHVpbnQgYmFsYW5jZSkgewogICAgICAgIHJldHVybiBiYWxhbmNlc1t0b2tlbk93bmVyXTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
library Balances {
 function move(mapping(address \=> uint256) storage balances, address from, address to, uint amount) internal {
 require(balances\[from\] \>= amount);
 require(balances\[to\] + amount \>= balances\[to\]);
 balances\[from\] \-= amount;
 balances\[to\] += amount;
 }
}
contract Token {
 mapping(address \=> uint256) balances;
 using Balances for \*;
 mapping(address \=> mapping (address \=> uint256)) allowed;
 event Transfer(address from, address to, uint amount);
 event Approval(address owner, address spender, uint amount);
 function transfer(address to, uint amount) external returns (bool success) {
 balances.move(msg.sender, to, amount);
 emit Transfer(msg.sender, to, amount);
 return true;
 }
 function transferFrom(address from, address to, uint amount) external returns (bool success) {
 require(allowed\[from\]\[msg.sender\] \>= amount);
 allowed\[from\]\[msg.sender\] \-= amount;
 balances.move(from, to, amount);
 emit Transfer(from, to, amount);
 return true;
 }
 function approve(address spender, uint tokens) external returns (bool success) {
 require(allowed\[msg.sender\]\[spender\] \== 0, "");
 allowed\[msg.sender\]\[spender\] \= tokens;
 emit Approval(msg.sender, spender, tokens);
 return true;
 }
 function balanceOf(address tokenOwner) external view returns (uint balance) {
 return balances\[tokenOwner\];
 }
}

# [调用数据的存储结构 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/internals/layout_in_calldata.html) 
 _https://docs.soliditylang.org/zh-cn/latest/internals/layout_in_calldata.html_

* [](https://docs.soliditylang.org/zh-cn/latest/index.html)
* 调用数据的存储结构
* [在 GitHub 上编辑](https://github.com/solidity-docs/zh-chinese/blob/develop/docs/internals/layout_in_calldata.rst)
* * *
## 调用数据的存储结构[](#id1 "此标题的永久链接")
一个函数调用的输入数据的格式被认为会遵循 [ABI规范](https://docs.soliditylang.org/zh-cn/latest/abi-spec.html#abi) 所定义的格式。 其中，ABI规范要求参数被填充为32字节的倍数。而内部函数调用会使用不同规则。
合约的构造函数的参数直接附加在合约的字节码末尾， 也是ABI编码的。构造函数将通过一个硬编码的偏移量来访问它们， 而不是通过使用 `codesize` 操作码，因为在向代码追加数据时它会发生改变。

# [Solidity v0.7.0 重大变化 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/070-breaking-changes.html) 
 _https://docs.soliditylang.org/zh-cn/latest/070-breaking-changes.html_

本节强调了 Solidity 0.7.0 版本中引入的主要重大变化， 以及这些变化背后的原因和如何更新受影响的代码。 对于完整的列表，请查看 [版本更新日志](https://github.com/ethereum/solidity/releases/tag/v0.7.0)。
## 语义的微小变化[](#id2 "此标题的永久链接")
* 用非字符量进行指数和移位（例如： `1 << x` 或 `2 ** x`） 将总是使用 `uint256` 类型（对于非负数）或 `int256` 类型（对于负数）来执行操作。 在此之前，该操作是在移位量/指数的类型中进行的，这可能会产生误导。
 
## 语法的变化[](#id3 "此标题的永久链接")
* 在外部函数和合约创建调用中，现在使用新的语法指定以太和燃料： `x.f{gas: 10000, value: 2 ether}(arg1, arg2)`。 旧的语法 – `x.f.gas(10000).value(2 ether)(arg1, arg2)` – 会导致错误。
 
* 全局变量 `now` 已被弃用， 应该使用 `block.timestamp` 来替换。 对于一个全局变量来说，单一的标识符 `now` 太通用了，可能会让人觉得它在事务处理过程中发生变化， 而 `block.timestamp` 正确地反映了它只是块的一个属性。
 
* 对变量的NatSpec注释只允许用于公共状态变量，而不允许用于本地或内部变量。
 
* 代号 `gwei` 现在是一个关键词（用于指定，例如 `2 gwei` 作为一个数字），不能作为一个标识符使用。
 
* 字符串现在只能包含可打印的ASCII字符，这也包括各种转义序列， 如十六进制（ `\xff`）和unicode转义（ `\u20ac`）。
 
* 现在支持Unicode字符串文本来容纳有效的UTF-8序列。 它们用 `unicode` 前缀来标识： `unicode"Hello 😃"`。
 
* 状态可变性：现在可以在继承过程中限制函数的状态可变性。 具有默认状态可变性的函数可以被 `pure` 和 `view` 函数所覆盖， 而 `view` 函数可以被 `pure` 函数所覆盖。 同时，公共状态变量被认为是 `view`，甚至是 `pure`，如果它们是常量。
 
### 内联汇编[](#id4 "此标题的永久链接")
* 在用户定义的函数和变量名称中，不允许在内联汇编中使用 `.`。 如果您在“仅Yul”模式下使用Solidity，它仍然有效。
 
* 存储指针变量 `x` 的槽和偏移量通过 `x.slot` 和 `x.offset` 访问， 而不是 `x_slot` 和 `x_offset`。
 
## 移除未使用或不安全的功能[](#id5 "此标题的永久链接")
### 存储之外的映射关系[](#id6 "此标题的永久链接")
* 如果一个结构或数组包含一个映射，它只能在存储中使用。 以前，映射成员在内存中被默默地跳过，这让人困惑，也容易出错。
 
* 如果存储中的结构或数组包含映射，则对其进行赋值是不可行的。 以前，在复制操作过程中，映射会被默默地跳过，这是一种误导，而且容易出错。
 
### 函数和事件[](#id7 "此标题的永久链接")
* 构造函数不再需要可见性（ `public` / `internal`）了。 为了防止合约被创建，可以将其标记为 `abstract`。 这使得构造函数的可见性概念变得过时了。
 
* 类型检查器：不允许库函数为 `virtual`： 由于库合约不能被继承，库函数不应该被标记为 virtual。
 
* 不允许在同一继承层次中具有相同名称和参数类型的多个事件。
 
* `using A for B` 只影响到它所提到的合约。以前，这种影响是继承的。 现在，您必须在所有使用该特性的派生合约中重复 `using` 语句。
 
### 表达式[](#id8 "此标题的永久链接")
* 有符号类型的移位是不允许的。以前，允许负数的移位，但它在运行时会被还原。
 
* `finney` 和 `szabo` 的面额被删除。它们很少被使用，并且不能使实际的金额清晰可见。 相反，可以使用明确的数值，如 `1e20` 或非常常见的 `gwei`。
 
### 声明[](#id9 "此标题的永久链接")
* 关键字 `var` 不能再使用了。 以前，这个关键词可以解析，但会导致一个类型错误， 并建议使用哪种类型。现在，它导致一个解析器错误。
 
## 接口变化[](#id10 "此标题的永久链接")
* JSON AST：用 `kind: "hexString"` 来标记十六进制字符串文本。
 
* JSON AST：值为 `null` 的成员将从JSON输出中删除。
 
* NatSpec：构造器和函数有一致的用户文档输出。
 
## 如何更新您的代码[](#id11 "此标题的永久链接")
本节详细说明了如何为每一个重大变化更新先前的代码。
* 将 `x.f.value(...)()` 改为 `x.f{value: ...}()`。类似地， `(new C).value(...)()` 改为 `new C{value: ...}()`， `x.f.gas(...).value(...)()` 改为 `x.f{gas: ..., value: ...}()`。
 
* 将 `now` 改为 `block.timestamp`.
 
* 将移位运算符中的右操作数的类型改为无符号类型。 例如，将 `x >> (256 - y)` 改为 `x >> uint(256 - y)`。
 
* 如果需要，在所有派生合约中重复 `using A for B` 的语句。
 
* 从每个构造函数中删除 `public` 关键字。
 
* 从每个构造函数中删除 `internal` 关键字，并在合约中添加 `abstract` （如果还没有存在）。
 
* 将内联汇编中的 `_slot` 和 `_offset` 后缀分别改为 `.slot` 和 `.offset`。

# [Layout in Memory — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/internals/layout_in_memory.html) 
 _https://docs.soliditylang.org/en/v0.8.30/internals/layout_in_memory.html_

Solidity reserves four 32-byte slots, with specific byte ranges (inclusive of endpoints) being used as follows:
* `0x00` - `0x3f` (64 bytes): scratch space for hashing methods
 
* `0x40` - `0x5f` (32 bytes): currently allocated memory size (aka. free memory pointer)
 
* `0x60` - `0x7f` (32 bytes): zero slot
 
Scratch space can be used between statements (i.e. within inline assembly). The zero slot is used as initial value for dynamic memory arrays and should never be written to (the free memory pointer points to `0x80` initially).
Solidity always places new objects at the free memory pointer and memory is never freed (this might change in the future).
Elements in memory arrays in Solidity always occupy multiples of 32 bytes (this is even true for `bytes1[]`, but not for `bytes` and `string`). Multi-dimensional memory arrays are pointers to memory arrays. The length of a dynamic array is stored at the first slot of the array and followed by the array elements.
Warning
There are some operations in Solidity that need a temporary memory area larger than 64 bytes and therefore will not fit into the scratch space. They will be placed where the free memory points to, but given their short lifetime, the pointer is not updated. The memory may or may not be zeroed out. Because of this, one should not expect the free memory to point to zeroed out memory.
While it may seem like a good idea to use `msize` to arrive at a definitely zeroed out memory area, using such a pointer non-temporarily without updating the free memory pointer can have unexpected results.
## Differences to Layout in Storage[](#differences-to-layout-in-storage "Link to this heading")
As described above the layout in memory is different from the layout in [storage](https://docs.soliditylang.org/en/v0.8.30/internals/layout_in_storage.html#storage-inplace-encoding). Below there are some examples.
### Example for Difference in Arrays[](#example-for-difference-in-arrays "Link to this heading")
The following array occupies 32 bytes (1 slot) in storage, but 128 bytes (4 items with 32 bytes each) in memory.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=dWludDhbNF0gYTs=)
### Example for Difference in Struct Layout[](#example-for-difference-in-struct-layout "Link to this heading")
The following struct occupies 96 bytes (3 slots of 32 bytes) in storage, but 128 bytes (4 items with 32 bytes each) in memory.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=c3RydWN0IFMgewogICAgdWludCBhOwogICAgdWludCBiOwogICAgdWludDggYzsKICAgIHVpbnQ4IGQ7Cn0=)
struct S {
 uint a;
 uint b;
 uint8 c;
 uint8 d;
}

# [Credits and Attribution — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/credits-and-attribution.html) 
 _https://docs.soliditylang.org/en/v0.8.30/credits-and-attribution.html_

* [](https://docs.soliditylang.org/en/v0.8.30/index.html)
* Credits and Attribution
* [Edit on GitHub](https://github.com/ethereum/solidity/blob/develop/docs/credits-and-attribution.rst)
* * *
## Website icons[](#website-icons "Link to this heading")
Icon
Attribution
* Source: [share icon](https://fontawesome.com/v5.15/icons/share?style=solid) from Font Awesome 5.15.0.
 
* License: [Font Awesome Free License](https://fontawesome.com/license/free) (CC BY 4.0).

# [Solidity Kaynak Dosyasının Düzeni — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/layout-of-source-files.html) 
 _https://docs.soliditylang.org/tr/latest/layout-of-source-files.html_

Kaynak dosyalar, istenilen sayıda [contract definitions](https://docs.soliditylang.org/tr/latest/structure-of-a-contract.html#contract-structure), [import](#import) ,:ref:pragma<pragma> ve [using for](https://docs.soliditylang.org/tr/latest/contracts.html#using-for) yönergeleri ile [struct](https://docs.soliditylang.org/tr/latest/types.html#structs),:ref:enum<enums>, [function](https://docs.soliditylang.org/tr/latest/contracts.html#functions), [error](https://docs.soliditylang.org/tr/latest/contracts.html#errors) ve [constant variable](https://docs.soliditylang.org/tr/latest/contracts.html#constants) tanımları içerebilir.
## SPDX Lisans Tanımlayıcısı[](#spdx-lisans-tanimlayicisi "Permalink to this heading")
Kaynak kodlarının erişilebilir olması, akıllı sözleşmeleri daha güvenilir hale getirebilir. Kaynak kodunun erişilebilir hale getirilmesi her zaman telif hakkı ile ilgili yasal sorunlara yol açtığından, Solidity derleyicisi, makine tarafından okunabilen [SPDX lisans tanımlayıcılarının](https://spdx.org/) kullanılmasını teşvik eder:
`// SPDX-License-Identifier: MIT`
Derleyici, lisansın, [SPDX’in izin verdiği liste](https://spdx.org/licenses/) kapsamında olduğunu doğrulamaz ancak sağlanan dizeyi [bytecode metadata](https://docs.soliditylang.org/tr/latest/metadata.html#metadata) içine dahil eder.
Bir lisans belirtmek istemiyorsanız veya kaynak kodu açık kaynak değilse, lütfen `UNLICENSED` özel değerini kullanın. `UNLICENSED` (kullanıma izin verilmez, SPDX lisans listesinde bulunmaz) değerinin, `UNLICENSE` (herkese tüm hakları verir) değerinden farklı olduğunu unutmayın. Solidity, \` npm önerisine <[https://docs.npmjs.com/cli/v7/configuring-npm/package-json#license](https://docs.npmjs.com/cli/v7/configuring-npm/package-json#license)\>\`\_ uyar.
Bu açıklamayı eklemeniz, elbette ki sizi, her kaynak dosyada belirli bir lisans adından veya telif hakkının orijinal sahibinden bahsetme zorunluluğu gibi, lisans konusuyla ilgili diğer yükümlülüklerden muaf tutmaz. Derleyici, açıklamayı, dosya düzeyinde dosyanın herhangi bir yerinde algılayabilir ancak dosyanın üst kısmına eklenmesi önerilir.
SPDX lisans tanımlayıcılarının nasıl kullanılacağı hakkında daha fazla bilgi [SPDX web sitesinde](https://spdx.org/ids-how) bulunabilir.
## Pragmalar[](#pragmalar "Permalink to this heading")
`Pragma` anahtar sözcüğü, belirli derleyici özelliklerini veya kontrollerini etkinleştirmek için kullanılır. Bir pragma yönergesi, her zaman bir kaynak dosya için yereldir, bu nedenle pragmayı tüm projenizde etkinleştirmek istiyorsanız tüm dosyalarınıza eklemeniz gerekir. Başka bir dosyayı [içe aktarırsanız](#import) o dosyadaki pragma, içe aktarılan dosyaya otomatik olarak \_\*uygulanmaz\*.\_ .. index:: ! pragma, version
### Sürüm Pragması[](#surum-pragmasi "Permalink to this heading")
Uyumsuz değişiklikler getirebilecek gelecekteki derleyici sürümleriyle derlemeyi önlemek için kaynak dosyalarına bir sürüm pragması eklenebilir (ve eklenmelidir). Bunları mutlak minimumda tutmaya ve anlambilimdeki değişikliklerin sözdiziminde de değişiklik gerektireceği şekilde tanıtmaya çalışıyoruz, ancak bu her zaman mümkün olmayabilir. Bu nedenle, en azından işleyişi bozan değişiklikler içeren sürümler için değişiklik günlüğünü okumak her zaman iyi bir fikirdir. Bu sürümler her zaman `0.x.0` veya `x.0.0` biçiminde versiyonlara sahiptir.
Sürüm pragması aşağıdaki gibi kullanılır: `pragma solidity ^0.5.2;`
Yukarıdaki satırı içeren bir kaynak dosyası, 0.5.2’den eski sürümlü bir derleyiciyle derleme yapmadığı gibi, 0.6.0’dan yeni sürümlü bir derleyicide de çalışmaz (bu ikinci koşul `^` kullanılarak eklenir). `0.6.0` sürümüne kadar işleyişi bozan bir değişiklik olmayacağından, kodunuzun amaçladığınız şekilde derleme yaptığından emin olabilirsiniz. Derleyicinin tam sürümü sabit olmadığından hata düzeltme sürümlerinin kullanılması da mümkün olacaktır.
Derleyici sürümü için daha karmaşık kurallar belirlemek mümkündür, bunlar [npm](https://docs.npmjs.com/cli/v6/using-npm/semver) tarafından kullanılan sözdizimin aynısına uyar.
Not
Sürüm pragmasının kullanılması, derleyicinin sürümünü \_\*değiştirmez\*.\_ Derleyicinin özelliklerini etkinleştirme veya devre dışı bırakma işlevine de sahip \_\*değildir\*.\_ Yalnızca, derleyiciye kendi sürümünün, pragmanın gerektirdiği sürüm ile uyumlu olup olmadığını kontrol etmesi için yönerge verir. Sürümler uyumlu değilse derleyici hata verir.
### ABI Kodlayıcı Pragması[](#abi-kodlayici-pragmasi "Permalink to this heading")
`pragma abicoder v1` veya `pragma abicoder v2` kullanarak ABI kodlayıcı ile kod çözücü iki uygulama arasında seçim yapabilirsiniz.
Yeni ABI kodlayıcı (v2) keyfi olarak iç içe geçmiş dizileri ve yapıları kodlama(encode) ve kod çözme(decode) yapabilir . Daha az optimal kod üretebilir ve eski kodlayıcı kadar test edilmemiştir, ancak Solidity 0.6.0’dan itibaren deneysel olmayan olarak kabul edilir. Yine de `pragma abicoder v2;` kullanarak açıkça etkinleştirmeniz gerekir. Solidity 0.8.0’dan itibaren varsayılan olarak etkinleştirileceğinden, `pragma abicoder v1;` kullanarak eski kodlayıcıyı seçme seçeneği vardır.
Yeni kodlayıcı tarafından desteklenen türler, eskisi tarafından desteklenenlerin katı bir üst kümesidir. Bunu kullanan sözleşmeler, kullanmayanlarla sınırlama olmadan etkileşime girebilir. Bunun tersi ancak, `abicoder v2` dışı sözleşme, yalnızca yeni kodlayıcı tarafından desteklenen kod çözme türlerini gerektirecek çağrılarda bulunmaya çalışmadığı sürece mümkündür. Aksi halde, derleyici bu çağrıları tespit ederek hata verebilir. Sözleşmeniz için `abicoder v2` yi etkinleştirmeniz hatanın ortadan kalkması için yeterlidir.
Not
Bu pragma, en nihayetinde kodun nerede sonlandığına bakılmaksızın, etkinleştirildiği dosyada tanımlanan tüm kodlar için geçerlidir. Yani, kaynak dosyası ABI coder v1 ile derlenmek üzere seçilen bir sözleşme, başka bir sözleşmeden kalıt alarak, yeni kodlayıcıyı kullanan kod içermeye devam edebilir. Bu, yeni türlerin, external fonksiyon imzalarında değil, yalnızca dahili olarak kullanılması halinde mümkündür.
Not
Solidity 0.7.4’e kadar, `pragma experimental ABIEncoderV2` kullanarak ABI kodlayıcı v2’yi seçmek mümkündü, ancak varsayılan olduğu için kodlayıcı v1’i açık bir şekilde seçmek mümkün değildi.
### Deneysel Pragma[](#deneysel-pragma "Permalink to this heading")
İkinci pragma deneysel pragmadır. Derleyicinin veya dilin henüz varsayılan olarak etkinleştirilmemiş özelliklerini etkinleştirmek için kullanılabilir. Şu anda, aşağıdaki deneysel pragmalar desteklenmektedir:
#### ABIEncoderV2[](#abiencoderv2 "Permalink to this heading")
ABI kodlayıcı v2 artık deneysel kabul edilmediğinden Solidity 0.7.4 sonrasında `pragma abicoder v2` aracılığıyla seçilebilir (lütfen yukarıya bakın).
#### SMTChecker[](#smtchecker "Permalink to this heading")
Bu bileşeni, Solidity derleyicisi oluşturulduğunda etkinleştirmek gerektiği için tüm Solidity binary’lerinde mevcut değildir. [build yönergeleri](https://docs.soliditylang.org/tr/latest/installing-solidity.html#smt-solvers-build) bu seçeneğin nasıl etkinleştirileceğini açıklar. Çoğu sürümde Ubuntu PPA sürümleri için etkinleştirilmiş olsa da Docker görüntüleri, Windows binary’leri veya statik olarak oluşturulmuş Linux binary’leri için etkin değildir. Yerel olarak yüklenmiş bir SMT çözücünüz varsa ve solc-js’yi node üzerinden (tarayıcı üzerinden değil) çalıştırıyorsanız [smtCallback](https://github.com/ethereum/solcjs#example-usage-with-smtsolver-callback) kullanarak solc-js için etkinleştirebilirsiniz.
Eğer `pragma experimental SMTChecker;` kullanırsanız bir SMT çözücü sorgulatarak ek:ref:güvenlik uyarıları<formal\_verification> alırsınız. Bileşen henüz Solidity dilinin tüm özelliklerini desteklememekte ve muhtemelen çok sayıda uyarı vermektedir. Desteklenmeyen özellikleri bildirmesi durumunda, analiz tamamen sağlıklı olmayabilir.
## Diğer Kaynak Dosyalarını İçe Aktarma[](#diger-kaynak-dosyalarini-ice-aktarma "Permalink to this heading")
### Sözdizimi ve Anlambilim[](#sozdizimi-ve-anlambilim "Permalink to this heading")
Solidity, kodunuzu modüler hale getirmenize yardımcı olmak için Javascript’te mevcut olanlara (ES6’dan sonrası) benzer import ifadelerini destekler. Ancak, Solidity [varsayılan export](https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export#Description) kavramını desteklemez.
Genel düzeyde, aşağıdaki formdaki içe aktarma deyimlerini kullanabilirsiniz:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=aW1wb3J0ICJmaWxlbmFtZSI7)
`filename` kısmı _import path_ olarak adlandırılır. Bu deyim, “filename “deki tüm global sembolleri (ve orada içe aktarılan sembolleri) geçerli global kapsama içe aktarır (ES6’dakinden farklıdır, ancak Solidity için geriye dönük olarak uyumludur). Bu formun kullanılması tavsiye edilmez, çünkü isim alanını tahmin edilemeyecek şekilde kirletir. “filename” içine yeni üst düzey öğeler eklerseniz, bunlar otomatik olarak “filename “den bu şekilde içe aktarılan tüm dosyalarda görünür. Belirli sembolleri açık bir şekilde içe aktarmak daha iyidir.
Aşağıdaki örnek, üyeleri `"filename"` içindeki tüm global semboller olan yeni bir global sembol `symbolName` oluşturur:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=aW1wb3J0ICogYXMgc3ltYm9sTmFtZSBmcm9tICJmaWxlbmFtZSI7)
import \* as symbolName from "filename";
bu da tüm global sembollerin `symbolName.symbol` biçiminde kullanılabilir olmasıyla sonuçlanır.
Bu sözdiziminin ES6’nın bir parçası olmayan, ancak muhtemelen yararlı olan bir çeşidi: .. code-block:: solidity
> import “filename” as symbolName;
bu da `import * as symbolName from "filename";` ile eşdeğerdir.
Bir adlandırma çakışması varsa içe aktarma sırasında sembolleri yeniden adlandırabilirsiniz. Örneğin, aşağıdaki kod sırasıyla `"filename"` içinden `symbol1` ve `symbol2` yi referans veren yeni global semboller `alias` ve `symbol2` oluşturur. .. code-block:: solidity
> import {symbol1 as alias, symbol2} from “filename”;
### İçe Aktarma Yolları[](#ice-aktarma-yollari "Permalink to this heading")
Tüm platformlarda tekrarlanabilir derlemeleri destekleyebilmek için Solidity derleyicisinin kaynak dosyalarının depolandığı dosya sisteminin ayrıntılarını soyutlaması gerekir. Bu nedenle içe aktarma yolları doğrudan ana dosya sistemindeki dosyalara başvurmaz. Bunun yerine derleyici, her kaynak birime opak ve yapılandırılmamış bir tanımlayıcı olan benzersiz bir _kaynak birim adı_ atanan dahili bir veritabanı (_sanal dosya sistemi_ veya kısaca _VFS_) tutar. İçe aktarma ifadesinde belirtilen içe aktarma yolu, bir kaynak birim adına çevrilir ve veritabanında ilgili kaynak birimini bulmak için kullanılır.
[Standart JSON](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#compiler-api) API’sini kullanarak, derleyici girdisinin bir parçası olarak tüm kaynak dosyaların adlarını ve içeriğini doğrudan sağlamak mümkündür. Bu durumda kaynak birim adları gerçekten keyfi olabilir. Ancak, derleyicinin kaynak kodu otomatik olarak bulmasını ve VFS’ye yüklemesini istiyorsanız, kaynak birim adlarınızın bir [import callback](https://docs.soliditylang.org/tr/latest/path-resolution.html#import-callback) i mümkün kılacak şekilde yapılandırılması gerekir. Komut satırı derleyicisini kullanırken varsayılan import callback yalnızca kaynak kodun bir ana bilgisayar dosya sisteminden yüklenmesini destekler; yani kaynak birim adları, yollar olmalıdır.\`\`\` Bazı ortamlar daha çok yönlü olan özel callback’ler sağlar. Örneğin [Remix IDE](https://remix.ethereum.org/), HTTP, IPFS ve Swarm URL’lerinden dosya içe aktarmanıza veya doğrudan [NPM kayıt defterindeki paketlere](https://remix-ide.readthedocs.io/en/latest/import.html) başvurmanıza olanak tanıyan bir tane sağlar. Derleyici tarafından kullanılan sanal dosya sistemi ve yol çözümleme mantığının tam bir açıklaması için bkz [Path Resolution](https://docs.soliditylang.org/tr/latest/path-resolution.html#path-resolution).
## Yorumlar[](#yorumlar "Permalink to this heading")
Tek satırlı yorumlar (`//`) ve çok satırlı yorumlar (`/*...*/`) mümkündür.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gVGhpcyBpcyBhIHNpbmdsZS1saW5lIGNvbW1lbnQuCgovKgpUaGlzIGlzIGEKbXVsdGktbGluZSBjb21tZW50LgoqLw==)
// This is a single-line comment.
/\*
This is a
multi-line comment.
\*/
Not
Tek satırlık bir yorum UTF-8 kodlamasında herhangi bir unicode satır sonlandırıcısı (LF, VF, FF, CR, NEL, LS veya PS) ile sonlandırılır. Sonlandırıcı, yorumdan sonra hala kaynak kodun bir parçasıdır, bu nedenle bir ASCII sembolü değilse (bunlar NEL, LS ve PS’dir), bir ayrıştırıcı hatasına yol açacaktır. Ayrıca, NatSpec yorumu adı verilen başka bir yorum türü daha vardır, [stil kılavuzu](https://docs.soliditylang.org/tr/latest/style-guide.html#style-guide-natspec) içinde ayrıntılı olarak açıklanmıştır. Bunlar üçlü eğik çizgi (`///`) veya çift yıldız bloğu (`/** ... */`) ile yazılır ve doğrudan fonksiyon bildirimlerinin veya deyimlerinin üzerinde kullanılmalıdır.

# [Structure of a Contract — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/structure-of-a-contract.html) 
 _https://docs.soliditylang.org/en/latest/structure-of-a-contract.html_

Contracts in Solidity are similar to classes in object-oriented languages. Each contract can contain declarations of [State Variables](#structure-state-variables), [Functions](#structure-functions), [Function Modifiers](#structure-function-modifiers), [Events](#structure-events), [Errors](#structure-errors), [Struct Types](#structure-struct-types) and [Enum Types](#structure-enum-types). Furthermore, contracts can inherit from other contracts.
There are also special kinds of contracts called [libraries](https://docs.soliditylang.org/en/latest/contracts.html#libraries) and [interfaces](https://docs.soliditylang.org/en/latest/contracts.html#interfaces).
The section about [contracts](https://docs.soliditylang.org/en/latest/contracts.html#contracts) contains more details than this section, which serves to provide a quick overview.
## State Variables[](#state-variables "Link to this heading")
State variables are variables whose values are either permanently stored in contract storage or, alternatively, temporarily stored in transient storage which is cleaned at the end of each transaction. See [data locations](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#locations) for more details.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgU2ltcGxlU3RvcmFnZSB7CiAgICB1aW50IHN0b3JlZERhdGE7IC8vIFN0YXRlIHZhcmlhYmxlCiAgICAvLyAuLi4KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract SimpleStorage {
 uint storedData; // State variable
 // ...
}
See the [Types](https://docs.soliditylang.org/en/latest/types.html#types) section for valid state variable types and [Visibility and Getters](https://docs.soliditylang.org/en/latest/contracts.html#visibility-and-getters) for possible choices for visibility.
## Functions[](#functions "Link to this heading")
Functions are the executable units of code. Functions are usually defined inside a contract, but they can also be defined outside of contracts.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKY29udHJhY3QgU2ltcGxlQXVjdGlvbiB7CiAgICBmdW5jdGlvbiBiaWQoKSBwdWJsaWMgcGF5YWJsZSB7IC8vIEZ1bmN0aW9uCiAgICAgICAgLy8gLi4uCiAgICB9Cn0KCi8vIEhlbHBlciBmdW5jdGlvbiBkZWZpbmVkIG91dHNpZGUgb2YgYSBjb250cmFjdApmdW5jdGlvbiBoZWxwZXIodWludCB4KSBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgIHJldHVybiB4ICogMjsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.1 <0.9.0;
contract SimpleAuction {
 function bid() public payable { // Function
 // ...
 }
}
// Helper function defined outside of a contract
function helper(uint x) pure returns (uint) {
 return x \* 2;
}
[Function Calls](https://docs.soliditylang.org/en/latest/control-structures.html#function-calls) can happen internally or externally and have different levels of [visibility](https://docs.soliditylang.org/en/latest/contracts.html#visibility-and-getters) towards other contracts. [Functions](https://docs.soliditylang.org/en/latest/contracts.html#functions) accept [parameters and return variables](https://docs.soliditylang.org/en/latest/contracts.html#function-parameters-return-variables) to pass parameters and values between them.
## Function Modifiers[](#function-modifiers "Link to this heading")
Function modifiers can be used to amend the semantics of functions in a declarative way (see [Function Modifiers](https://docs.soliditylang.org/en/latest/contracts.html#modifiers) in the contracts section).
Overloading, that is, having the same modifier name with different parameters, is not possible.
Like functions, modifiers can be [overridden](https://docs.soliditylang.org/en/latest/contracts.html#modifier-overriding).
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCmNvbnRyYWN0IFB1cmNoYXNlIHsKICAgIGFkZHJlc3MgcHVibGljIHNlbGxlcjsKCiAgICBtb2RpZmllciBvbmx5U2VsbGVyKCkgeyAvLyBNb2RpZmllcgogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgIG1zZy5zZW5kZXIgPT0gc2VsbGVyLAogICAgICAgICAgICAiT25seSBzZWxsZXIgY2FuIGNhbGwgdGhpcy4iCiAgICAgICAgKTsKICAgICAgICBfOwogICAgfQoKICAgIGZ1bmN0aW9uIGFib3J0KCkgcHVibGljIHZpZXcgb25seVNlbGxlciB7IC8vIE1vZGlmaWVyIHVzYWdlCiAgICAgICAgLy8gLi4uCiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.22 <0.9.0;
contract Purchase {
 address public seller;
 modifier onlySeller() { // Modifier
 require(
 msg.sender \== seller,
 "Only seller can call this."
 );
 \_;
 }
 function abort() public view onlySeller { // Modifier usage
 // ...
 }
}
## Events[](#events "Link to this heading")
Events are convenience interfaces with the EVM logging facilities.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjI7CgpldmVudCBIaWdoZXN0QmlkSW5jcmVhc2VkKGFkZHJlc3MgYmlkZGVyLCB1aW50IGFtb3VudCk7IC8vIEV2ZW50Cgpjb250cmFjdCBTaW1wbGVBdWN0aW9uIHsKICAgIGZ1bmN0aW9uIGJpZCgpIHB1YmxpYyBwYXlhYmxlIHsKICAgICAgICAvLyAuLi4KICAgICAgICBlbWl0IEhpZ2hlc3RCaWRJbmNyZWFzZWQobXNnLnNlbmRlciwgbXNnLnZhbHVlKTsgLy8gVHJpZ2dlcmluZyBldmVudAogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.22;
event HighestBidIncreased(address bidder, uint amount); // Event
contract SimpleAuction {
 function bid() public payable {
 // ...
 emit HighestBidIncreased(msg.sender, msg.value); // Triggering event
 }
}
See [Events](https://docs.soliditylang.org/en/latest/contracts.html#events) in contracts section for information on how events are declared and can be used from within a dapp.
## Errors[](#errors "Link to this heading")
Errors allow you to define descriptive names and data for failure situations. Errors can be used in [revert statements](https://docs.soliditylang.org/en/latest/control-structures.html#revert-statement). In comparison to string descriptions, errors are much cheaper and allow you to encode additional data. You can use NatSpec to describe the error to the user.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCi8vLyBOb3QgZW5vdWdoIGZ1bmRzIGZvciB0cmFuc2Zlci4gUmVxdWVzdGVkIGByZXF1ZXN0ZWRgLAovLy8gYnV0IG9ubHkgYGF2YWlsYWJsZWAgYXZhaWxhYmxlLgplcnJvciBOb3RFbm91Z2hGdW5kcyh1aW50IHJlcXVlc3RlZCwgdWludCBhdmFpbGFibGUpOwoKY29udHJhY3QgVG9rZW4gewogICAgbWFwcGluZyhhZGRyZXNzID0+IHVpbnQpIGJhbGFuY2VzOwogICAgZnVuY3Rpb24gdHJhbnNmZXIoYWRkcmVzcyB0bywgdWludCBhbW91bnQpIHB1YmxpYyB7CiAgICAgICAgdWludCBiYWxhbmNlID0gYmFsYW5jZXNbbXNnLnNlbmRlcl07CiAgICAgICAgaWYgKGJhbGFuY2UgPCBhbW91bnQpCiAgICAgICAgICAgIHJldmVydCBOb3RFbm91Z2hGdW5kcyhhbW91bnQsIGJhbGFuY2UpOwogICAgICAgIGJhbGFuY2VzW21zZy5zZW5kZXJdIC09IGFtb3VudDsKICAgICAgICBiYWxhbmNlc1t0b10gKz0gYW1vdW50OwogICAgICAgIC8vIC4uLgogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
/// Not enough funds for transfer. Requested \`requested\`,
/// but only \`available\` available.
error NotEnoughFunds(uint requested, uint available);
contract Token {
 mapping(address \=> uint) balances;
 function transfer(address to, uint amount) public {
 uint balance \= balances\[msg.sender\];
 if (balance < amount)
 revert NotEnoughFunds(amount, balance);
 balances\[msg.sender\] \-= amount;
 balances\[to\] += amount;
 // ...
 }
}
See [Custom Errors](https://docs.soliditylang.org/en/latest/contracts.html#errors) in the contracts section for more information.
## Struct Types[](#struct-types "Link to this heading")
Structs are custom defined types that can group several variables (see [Structs](https://docs.soliditylang.org/en/latest/types.html#structs) in types section).
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQmFsbG90IHsKICAgIHN0cnVjdCBWb3RlciB7IC8vIFN0cnVjdAogICAgICAgIHVpbnQgd2VpZ2h0OwogICAgICAgIGJvb2wgdm90ZWQ7CiAgICAgICAgYWRkcmVzcyBkZWxlZ2F0ZTsKICAgICAgICB1aW50IHZvdGU7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract Ballot {
 struct Voter { // Struct
 uint weight;
 bool voted;
 address delegate;
 uint vote;
 }
}
## Enum Types[](#enum-types "Link to this heading")
Enums can be used to create custom types with a finite set of ‘constant values’ (see [Enums](https://docs.soliditylang.org/en/latest/types.html#enums) in types section).
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgUHVyY2hhc2UgewogICAgZW51bSBTdGF0ZSB7IENyZWF0ZWQsIExvY2tlZCwgSW5hY3RpdmUgfSAvLyBFbnVtCn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract Purchase {
 enum State { Created, Locked, Inactive } // Enum
}

# [SMT检查器和形式化验证 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/smtchecker.html) 
 _https://docs.soliditylang.org/zh-cn/latest/smtchecker.html_

使用形式化验证，有可能进行自动数学证明， 证明您的源代码符合某种形式化规范。 该规范仍然是正式的（就像源代码一样），但通常要简单得多。
请注意，形式化验证本身只能帮助您理解您所做的（规范）和您如何做的（实际实现）之间的区别。 您仍然需要检查规范是否是您想要的，以及您没有遗漏任何意想不到的效果。
Solidity 实现了基于 [SMT（可满足性模型理论（Satisfiability Modulo Theories）](https://en.wikipedia.org/wiki/Satisfiability_modulo_theoris) 和 [Horn](https://en.wikipedia.org/wiki/Horn-satisfiability) 解决的形式验证方法。 SMT检查器模块自动尝试证明代码满足由 `require` 和 `assert` 语句给出的规范。 也就是说，它把 `require` 语句视为假设，并试图证明 `assert` 语句中的条件总是真的。 如果发现断言失败，则可以向用户提供一个反例，说明断言是如何被违反的。 如果 SMT 检查器对某一属性没有给出警告，这意味着该属性是安全的。
SMT 检查器在编译时检查的其他验证目标有：
* 算术上的下溢和溢出。
 
* 除以0的除法。
 
* 无用的条件和无法访问的代码。
 
* 弹出一个空数组。
 
* 超出界限的索引访问。
 
* 转账资金不足。
 
如果所有检查引擎都被启用，上述所有目标都被默认为自动检查， 除了 Solidity >=0.8.7 的下溢和溢出。
SMT 检查器所报告的潜在警告是：
* `<失败的属性> 发生在这里`。这意味着 SMT 检查器证明了某一属性失败。可能会给出一个反例，但是在复杂的情况下，也可能不会显示反例。在某些情况下，当 SMT 编码为 Solidity 代码添加了难以表达或无法表达的抽象时，这个结果也可能是一个假阳性。
 
* `<失败的属性> 可能发生在这里`。这意味着求解器无法在给定的超时时间内证明两种情况。由于结果是未知的，SMT 检查器会报告潜在的健全性失败。这可以通过增加查询超时时间来解决，但问题也可能只是对引擎来说太难解决。
 
要启用SMT检查器，您必须选择 [应该运行哪一个引擎](#smtchecker-engines)， 其中默认的是没有引擎。选择引擎可以在所有文件上启用SMT检查器。
备注
在 Solidity 0.8.4 之前，启用SMT检查器的默认方式是通过 `pragma experimental SMTChecker;` 并且只有包含 pragma 的合约才会被分析。该 pragma 已被弃用， 尽管它仍能使SMT检查器向后兼容，但它将在 Solidity 0.9.0 中被移除。 还要注意的是，现在即使在一个文件中使用 pragma，也会对所有文件启用SMT检查器。
备注
假设SMT检查器和底层求解器中没有错误， 那么验证目标没有警告就代表了一个无可争议的正确性数学证明。 请记住，这些问题在一般情况下是 _很难_ 的，有时是 _不可能_ 自动解决的。 因此，有几个属性可能无法解决，或者可能导致大型合约的假阳性。 每一个被证明的属性都应该被看作是一个重要的成就。 对于高级用户，请参阅 [SMT检查器 调优](#smtchecker-options) 来了解一些可能有助于证明更复杂属性的选项。
## 教程[](#id1 "此标题的永久链接")
### 溢出[](#id2 "此标题的永久链接")
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBPdmVyZmxvdyB7CiAgICB1aW50IGltbXV0YWJsZSB4OwogICAgdWludCBpbW11dGFibGUgeTsKCiAgICBmdW5jdGlvbiBhZGQodWludCB4XywgdWludCB5XykgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIHhfICsgeV87CiAgICB9CgogICAgY29uc3RydWN0b3IodWludCB4XywgdWludCB5XykgewogICAgICAgICh4LCB5KSA9ICh4XywgeV8pOwogICAgfQoKICAgIGZ1bmN0aW9uIHN0YXRlQWRkKCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBhZGQoeCwgeSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Overflow {
 uint immutable x;
 uint immutable y;
 function add(uint x\_, uint y\_) internal pure returns (uint) {
 return x\_ + y\_;
 }
 constructor(uint x\_, uint y\_) {
 (x, y) \= (x\_, y\_);
 }
 function stateAdd() public view returns (uint) {
 return add(x, y);
 }
}
上面的合约显示了一个溢出检查的例子。 对于 Solidity >=0.8.7，SMT检查器默认不检查下溢和溢出， 所以我们需要使用命令行选项 `--model-checker-targets "underflow,overflow"` 或者JSON选项 `settings.modelChecker.targets = ["underflow", "overflow"]`。 参见 [本节的目标配置](#smtchecker-targets)。此处，它报告如下：
Warning: CHC: Overflow (resulting value larger than 2\*\*256 - 1) happens here.
Counterexample:
x = 1, y = 115792089237316195423570985008687907853269984665640564039457584007913129639935
 = 0
Transaction trace:
Overflow.constructor(1, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
State: x = 1, y = 115792089237316195423570985008687907853269984665640564039457584007913129639935
Overflow.stateAdd()
 Overflow.add(1, 115792089237316195423570985008687907853269984665640564039457584007913129639935) -- internal call
 --> o.sol:9:20:
 |
9 | return x\_ + y\_;
 | ^^^^^^^
如果我们添加了过滤掉溢出情况的 `require` 语句， SMT检查器就会证明没有溢出是可以达到的（会通过不报告警告表现出来）。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBPdmVyZmxvdyB7CiAgICB1aW50IGltbXV0YWJsZSB4OwogICAgdWludCBpbW11dGFibGUgeTsKCiAgICBmdW5jdGlvbiBhZGQodWludCB4XywgdWludCB5XykgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIHhfICsgeV87CiAgICB9CgogICAgY29uc3RydWN0b3IodWludCB4XywgdWludCB5XykgewogICAgICAgICh4LCB5KSA9ICh4XywgeV8pOwogICAgfQoKICAgIGZ1bmN0aW9uIHN0YXRlQWRkKCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJlcXVpcmUoeCA8IHR5cGUodWludDEyOCkubWF4KTsKICAgICAgICByZXF1aXJlKHkgPCB0eXBlKHVpbnQxMjgpLm1heCk7CiAgICAgICAgcmV0dXJuIGFkZCh4LCB5KTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Overflow {
 uint immutable x;
 uint immutable y;
 function add(uint x\_, uint y\_) internal pure returns (uint) {
 return x\_ + y\_;
 }
 constructor(uint x\_, uint y\_) {
 (x, y) \= (x\_, y\_);
 }
 function stateAdd() public view returns (uint) {
 require(x < type(uint128).max);
 require(y < type(uint128).max);
 return add(x, y);
 }
}
### 断言[](#id3 "此标题的永久链接")
断言表示代码中的一个不变量： _对于所有的事务，包括所有的输入和存储值_， 一个属性必须为真，否则就会出现错误。
下面的代码定义了一个保证没有溢出的函数 `f`。 函数 `inv` 定义了 `f` 是单调递增的规范： 对于每个可能的数值对 `(a, b)`，如果 `b > a`，那么 `f(b) > f(a)`。 由于 `f` 确实是单调增长的，SMT检查器证明了我们的属性是正确的。 我们鼓励您试试这个属性和函数定义，看看会有什么样的结果!
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBNb25vdG9uaWMgewogICAgZnVuY3Rpb24gZih1aW50IHgpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJlcXVpcmUoeCA8IHR5cGUodWludDEyOCkubWF4KTsKICAgICAgICByZXR1cm4geCAqIDQyOwogICAgfQoKICAgIGZ1bmN0aW9uIGludih1aW50IGEsIHVpbnQgYikgcHVibGljIHB1cmUgewogICAgICAgIHJlcXVpcmUoYiA+IGEpOwogICAgICAgIGFzc2VydChmKGIpID4gZihhKSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Monotonic {
 function f(uint x) internal pure returns (uint) {
 require(x < type(uint128).max);
 return x \* 42;
 }
 function inv(uint a, uint b) public pure {
 require(b \> a);
 assert(f(b) \> f(a));
 }
}
我们还可以在循环中添加断言，以验证更多的复杂的属性。 下面的代码搜索一个不受限制的数字数组的最大元素， 并断言找到的元素必须大于或等于数组中的每个元素的属性。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBNYXggewogICAgZnVuY3Rpb24gbWF4KHVpbnRbXSBtZW1vcnkgYSkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHVpbnQgbSA9IDA7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkKICAgICAgICAgICAgaWYgKGFbaV0gPiBtKQogICAgICAgICAgICAgICAgbSA9IGFbaV07CgogICAgICAgIGZvciAodWludCBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpCiAgICAgICAgICAgIGFzc2VydChtID49IGFbaV0pOwoKICAgICAgICByZXR1cm4gbTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Max {
 function max(uint\[\] memory a) public pure returns (uint) {
 uint m \= 0;
 for (uint i \= 0; i < a.length; ++i)
 if (a\[i\] \> m)
 m \= a\[i\];
 for (uint i \= 0; i < a.length; ++i)
 assert(m \>= a\[i\]);
 return m;
 }
}
注意，在这个例子中，SMT检查器将自动尝试证明三个属性：
1. 第一个循环中的 `++i` 不会溢出。
 
2. 第二个循环中的 `++i` 不会溢出。
 
3. 该断言始终是正确的。
 
备注
这些属性涉及到循环，这使得它比前面的例子 _更加_ 难了，所以要当心循环的问题！
所有的属性都被正确证明是安全的。 可以随意改变属性和/或在数组上添加限制，以看到不同的结果。例如，将代码改为
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBNYXggewogICAgZnVuY3Rpb24gbWF4KHVpbnRbXSBtZW1vcnkgYSkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJlcXVpcmUoYS5sZW5ndGggPj0gNSk7CiAgICAgICAgdWludCBtID0gMDsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKQogICAgICAgICAgICBpZiAoYVtpXSA+IG0pCiAgICAgICAgICAgICAgICBtID0gYVtpXTsKCiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkKICAgICAgICAgICAgYXNzZXJ0KG0gPiBhW2ldKTsKCiAgICAgICAgcmV0dXJuIG07CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Max {
 function max(uint\[\] memory a) public pure returns (uint) {
 require(a.length \>= 5);
 uint m \= 0;
 for (uint i \= 0; i < a.length; ++i)
 if (a\[i\] \> m)
 m \= a\[i\];
 for (uint i \= 0; i < a.length; ++i)
 assert(m \> a\[i\]);
 return m;
 }
}
我们得到的结果：
Warning: CHC: Assertion violation happens here.
Counterexample:
a = \[0, 0, 0, 0, 0\]
 = 0
Transaction trace:
Test.constructor()
Test.max(\[0, 0, 0, 0, 0\])
 --> max.sol:14:4:
 |
14 | assert(m > a\[i\]);
### 状态属性[](#id4 "此标题的永久链接")
到目前为止，这些例子只展示了SMT检查器在纯代码上的使用， 证明了关于特定操作或算法的属性。 智能合约中常见的属性类型是涉及合约状态的属性。 对于这样的属性，可能需要多个交易来使断言失效。
举一个例子，考虑一个二维网格，其中两个轴的坐标都在（-2^128, 2^128 - 1）范围内。 让我们在位置（0，0）放置一个机器人。该机器人只能在对角线上移动，一次只能走一步， 不能在网格外移动。机器人的状态机可以用下面的智能合约来表示。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBSb2JvdCB7CiAgICBpbnQgeCA9IDA7CiAgICBpbnQgeSA9IDA7CgogICAgbW9kaWZpZXIgd2FsbCB7CiAgICAgICAgcmVxdWlyZSh4ID4gdHlwZShpbnQxMjgpLm1pbiAmJiB4IDwgdHlwZShpbnQxMjgpLm1heCk7CiAgICAgICAgcmVxdWlyZSh5ID4gdHlwZShpbnQxMjgpLm1pbiAmJiB5IDwgdHlwZShpbnQxMjgpLm1heCk7CiAgICAgICAgXzsKICAgIH0KCiAgICBmdW5jdGlvbiBtb3ZlTGVmdFVwKCkgd2FsbCBwdWJsaWMgewogICAgICAgIC0teDsKICAgICAgICArK3k7CiAgICB9CgogICAgZnVuY3Rpb24gbW92ZUxlZnREb3duKCkgd2FsbCBwdWJsaWMgewogICAgICAgIC0teDsKICAgICAgICAtLXk7CiAgICB9CgogICAgZnVuY3Rpb24gbW92ZVJpZ2h0VXAoKSB3YWxsIHB1YmxpYyB7CiAgICAgICAgKyt4OwogICAgICAgICsreTsKICAgIH0KCiAgICBmdW5jdGlvbiBtb3ZlUmlnaHREb3duKCkgd2FsbCBwdWJsaWMgewogICAgICAgICsreDsKICAgICAgICAtLXk7CiAgICB9CgogICAgZnVuY3Rpb24gaW52KCkgcHVibGljIHZpZXcgewogICAgICAgIGFzc2VydCgoeCArIHkpICUgMiA9PSAwKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Robot {
 int x \= 0;
 int y \= 0;
 modifier wall {
 require(x \> type(int128).min && x < type(int128).max);
 require(y \> type(int128).min && y < type(int128).max);
 \_;
 }
 function moveLeftUp() wall public {
 \--x;
 ++y;
 }
 function moveLeftDown() wall public {
 \--x;
 \--y;
 }
 function moveRightUp() wall public {
 ++x;
 ++y;
 }
 function moveRightDown() wall public {
 ++x;
 \--y;
 }
 function inv() public view {
 assert((x + y) % 2 \== 0);
 }
}
函数 `inv` 代表状态机的一个不变量，即 `x + y` 必须是偶数。 SMT检查器设法证明，无论我们给机器人多少条命令， 即使是无限多的命令，这个不变量都 _不会_ 失败。 有兴趣的读者可能也想手动证明这个事实。 提示：这个不变量是归纳性的。
我们也可以欺骗SMT检查器，让它给我们提供一条通往某个我们认为可能是可访问的位置的路径。 我们可以通过添加以下函数，来增加(2, 4)是 _不_ 可访问的属性。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=ZnVuY3Rpb24gcmVhY2hfMl80KCkgcHVibGljIHZpZXcgewogICAgYXNzZXJ0KCEoeCA9PSAyICYmIHkgPT0gNCkpOwp9)
function reach\_2\_4() public view {
 assert(!(x \== 2 && y \== 4));
}
这个属性是假的，在证明这个属性是假的同时， SMT检查器准确地告诉我们 _如何_ 访问到(2, 4)。
Warning: CHC: Assertion violation happens here.
Counterexample:
x = 2, y = 4
Transaction trace:
Robot.constructor()
State: x = 0, y = 0
Robot.moveLeftUp()
State: x = (- 1), y = 1
Robot.moveRightUp()
State: x = 0, y = 2
Robot.moveRightUp()
State: x = 1, y = 3
Robot.moveRightUp()
State: x = 2, y = 4
Robot.reach\_2\_4()
 --> r.sol:35:4:
 |
35 | assert(!(x == 2 && y == 4));
 | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
请注意，上面的路径不一定是确定的， 因为还有其他路径可以访问（2，4）。 选择哪条路径可能会根据所使用的解算器，其使用版本，或者只是随机地改变。
### 外部调用和重入[](#id5 "此标题的永久链接")
每个外部调用都被SMT检查器视为对未知代码的调用。 这背后的原因是，即使被调用合约的代码在编译时是可用的， 也不能保证部署的合约确实与编译时接口所在的合约相同。
在某些情况下，有可能在状态变量上自动推断出属性， 即使外部调用的代码可以做任何事情，包括重新进入调用者合约， 这些属性仍然是真的。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7CgppbnRlcmZhY2UgVW5rbm93biB7CiAgICBmdW5jdGlvbiBydW4oKSBleHRlcm5hbDsKfQoKY29udHJhY3QgTXV0ZXggewogICAgdWludCB4OwogICAgYm9vbCBsb2NrOwoKICAgIFVua25vd24gaW1tdXRhYmxlIHVua25vd247CgogICAgY29uc3RydWN0b3IoVW5rbm93biB1KSB7CiAgICAgICAgcmVxdWlyZShhZGRyZXNzKHUpICE9IGFkZHJlc3MoMCkpOwogICAgICAgIHVua25vd24gPSB1OwogICAgfQoKICAgIG1vZGlmaWVyIG11dGV4IHsKICAgICAgICByZXF1aXJlKCFsb2NrKTsKICAgICAgICBsb2NrID0gdHJ1ZTsKICAgICAgICBfOwogICAgICAgIGxvY2sgPSBmYWxzZTsKICAgIH0KCiAgICBmdW5jdGlvbiBzZXQodWludCB4XykgbXV0ZXggcHVibGljIHsKICAgICAgICB4ID0geF87CiAgICB9CgogICAgZnVuY3Rpb24gcnVuKCkgbXV0ZXggcHVibGljIHsKICAgICAgICB1aW50IHhQcmUgPSB4OwogICAgICAgIHVua25vd24ucnVuKCk7CiAgICAgICAgYXNzZXJ0KHhQcmUgPT0geCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
interface Unknown {
 function run() external;
}
contract Mutex {
 uint x;
 bool lock;
 Unknown immutable unknown;
 constructor(Unknown u) {
 require(address(u) != address(0));
 unknown \= u;
 }
 modifier mutex {
 require(!lock);
 lock \= true;
 \_;
 lock \= false;
 }
 function set(uint x\_) mutex public {
 x \= x\_;
 }
 function run() mutex public {
 uint xPre \= x;
 unknown.run();
 assert(xPre \== x);
 }
}
上面的例子显示了一个使用互斥标志来禁止重入的合约。 解算器能够推断出，当 `unknown.run()` 被调用时，合约已经被 “锁定”， 所以无论未知的调用代码做什么，都不可能改变 `x` 的值。
如果我们“忘记”在函数 `set` 上使用 `mutex` 修饰符， SMT检查器就能合成外部调用代码的行为，从而使断言失败：
Warning: CHC: Assertion violation happens here.
Counterexample:
x = 1, lock = true, unknown = 1
Transaction trace:
Mutex.constructor(1)
State: x = 0, lock = false, unknown = 1
Mutex.run()
 unknown.run() -- untrusted external call, synthesized as:
 Mutex.set(1) -- reentrant call
 --> m.sol:32:3:
 |
32 | assert(xPre == x);
 | ^^^^^^^^^^^^^^^^^
## SMT检查器选项和调试[](#smtchecker-options "此标题的永久链接")
### 超时[](#id7 "此标题的永久链接")
SMT检查器使用了一个硬编码的资源限制（ `rlimit` ）， 这个限制是根据每个求解器选择的，与时间没有确切的关系。 我们选择 `rlimit` 选项作为默认值，因为它比求解器内部的时间提供了更多的确定性保证。
这个选项大致转化为每个查询 “几秒钟超时”。 当然，许多属性非常复杂，需要大量的时间来解决，而决定并不重要。 如果SMT检查器不能用默认的 `rlimit` 选项处理合约属性， 则可以通过命令行界面（CLI）选项 `--model-checker-timeout <time>` 或 JSON选项 `settings.modelChecker.timeout=<time>` 给出以毫秒为单位的超时。 其中0表示不超时。
### 验证目标[](#smtchecker-targets "此标题的永久链接")
SMT检查器创建的验证目标的类型也可以通过命令行界面选项 `--model-checker-target <targets>` 或JSON选项 `settings.modelChecker.targets=<targets>` 来定制。 在命令行界面情况下， `<targets>` 是一个没有空格的逗号分隔的一个或多个验证目标的列表， 在JSON输入中是一个或多个作为字符串的目标数组。 代表目标的关键词是：
* 断言： `assert`。
 
* 算术下溢： `underflow`。
 
* 算术溢出： `overflow`。
 
* 除以零： `divByZero`。
 
* 无用的条件和无法访问的代码： `constantCondition`。
 
* 弹出一个空数组： `popEmptyArray`。
 
* 越界的数组/固定字节索引访问： `outOfBounds`。
 
* 转账资金不足： `balance`。
 
* 以上都是： `default` （仅适用命令行界面）。
 
一个常见的目标子集可能是，例如： `--model-checker-targets assert,overflow`。
所有目标都被默认检查，除了Solidity >=0.8.7的下溢和溢出。
关于如何以及何时分割验证目标，没有精确的指导方法。 但在处理大型合约时，它可能是有用的。
### 已验证的目标[](#id9 "此标题的永久链接")
果有任何已证明的目标，SMT检查器会向每个引擎发出一个警告， 说明有多少目标已证明。如果用户希望查看所有已证明的具体目标， 可使用命令行选项 `--model-checker-show-proved` 和 JSON选项 `settings.modelChecker.showProved = true`。
### 未验证的目标[](#id10 "此标题的永久链接")
如果有任何未验证的目标，SMT检查器会发出一个警告， 说明有多少个未验证的目标。如果用户希望看到所有具体的未验证的目标， 可以使用命令行界面选项 `--model-checker-show-unproved` 和JSON选项 `settings.modelChecker.showUnproved = true`。
### 不支持的语言特性[](#id11 "此标题的永久链接")
SMT检查器应用的SMT编码不完全支持某些Solidity语言特性， 例如汇编块。 不支持的构造会通过过度逼近进行抽象， 以保持稳健性，这意味着即使不支持该特性， 任何报告为安全的属性也是安全的。 然而，当目标属性依赖于不支持特征的精确行为时， 这种抽象可能会导致误报。 如果编码器遇到这种情况，默认情况下会报告一个通用警告， 说明它看到了多少个不支持的特性。 如果用户希望查看所有特定的不支持特性，可以使用CLI选项 `--model-checker-show-unsupported` 和 JSON选项 `settings.modelChecker.showUnsupported = true`， 它们的默认值是 `false`。
### 已验证过的合约[](#id12 "此标题的永久链接")
默认情况下，给定来源中的所有可部署合约都会被单独分析，正如将被部署的那一个合约一样。 这意味着，如果一个合约有许多直接和间接的继承父类，所有这些都将被单独分析， 尽管只有最终派生的合约可以在区块链上被直接访问。 这给SMT检查器和求解器造成了不必要的负担。 为了帮助缓解这样的情况，用户可以指定哪些合约应该作为部署的合约进行分析。 当然，基类合约仍然被分析，但只是在分析最终派生的合约的情况下才进行， 这可以减少编码和生成查询的复杂性。 请注意，抽象合约在默认情况下不会被SMT检查器分析为最终派生的合约。
选择的合约可以通过命令行界面，用 <source>:<contract> 形式的键值对，以逗号分隔的列表（不允许有空格）给出： `--model-checker-contracts "<source1.sol:contract1>,<source2.sol:contract2>,<source2.sol:contract3>"`， 以及通过 [JSON 输入](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#compiler-api) 中的对象 `settings.modelChecker.contracts`，它有如下格式：
"contracts": {
 "source1.sol": \["contract1"\],
 "source2.sol": \["contract2", "contract3"\]
}
### 可信任的外部调用[](#id13 "此标题的永久链接")
默认情况下，SMT检查器不假定编译时可用的代码与外部调用的运行时代码相同。 以以下合约为例：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBFeHQgewogICAgdWludCBwdWJsaWMgeDsKICAgIGZ1bmN0aW9uIHNldFgodWludCBfeCkgcHVibGljIHsgeCA9IF94OyB9Cn0KY29udHJhY3QgTXlDb250cmFjdCB7CiAgICBmdW5jdGlvbiBjYWxsRXh0KEV4dCBfZSkgcHVibGljIHsKICAgICAgICBfZS5zZXRYKDQyKTsKICAgICAgICBhc3NlcnQoX2UueCgpID09IDQyKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Ext {
 uint public x;
 function setX(uint \_x) public { x \= \_x; }
}
contract MyContract {
 function callExt(Ext \_e) public {
 \_e.setX(42);
 assert(\_e.x() \== 42);
 }
}
当调用 `MyContract.callExt` 时，一个地址被作为参数给出。 在部署时，我们不能确定地知道地址 `_e` 实际上是否包含了 `Ext` 合约的部署。 因此，SMT检查器会警告上述断言可能被违反， 这是真实的，如果 `_e` 包含了其他不是 `Ext` 的合约。
然而，将这些外部调用视为可信是有用的， 例如，测试不同接口的实现是否符合相同的属性。 这意味着假设地址 `_e` 确实被作为 `Ext` 合约部署。 这种模式可以通过CLI选项 `--model-checker-ext-calls=trusted` 或JSON字段 `settings.modelChecker.extCalls: "trusted"` 启用。
请注意，启用此模式可能会使SMT检查器分析的计算成本大大提高。
这种模式的一个重要部分是，它适用于合约类型和对合约的高级外部调用， 而不适用于如 `call` 和 `delegatecall` 等低级调用。 一个地址的存储是按合约类型存储的， SMT检查器假定外部调用的合约具有调用者表达式的类型。 因此，将一个 `address` 或一个合约转换为不同的合约类型将产生不同的存储值， 如果假设不一致，可能会产生不可靠的结果，如下例：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBEIHsKICAgIGNvbnN0cnVjdG9yKHVpbnQgX3gpIHsgeCA9IF94OyB9CiAgICB1aW50IHB1YmxpYyB4OwogICAgZnVuY3Rpb24gc2V0WCh1aW50IF94KSBwdWJsaWMgeyB4ID0gX3g7IH0KfQoKY29udHJhY3QgRSB7CiAgICBjb25zdHJ1Y3RvcigpIHsgeCA9IDI7IH0KICAgIHVpbnQgcHVibGljIHg7CiAgICBmdW5jdGlvbiBzZXRYKHVpbnQgX3gpIHB1YmxpYyB7IHggPSBfeDsgfQp9Cgpjb250cmFjdCBDIHsKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIGFkZHJlc3MgZCA9IGFkZHJlc3MobmV3IEQoNDIpKTsKCiAgICAgICAgLy8gYGRgIOiiq+mDqOe9suS4uiBgRGAsIOaJgOS7peeOsOWcqOWug+eahCBgeGAg5bqU6K+l5pivNDLjgIIKICAgICAgICBhc3NlcnQoRChkKS54KCkgPT0gNDIpOyAvLyDlupTor6XmiJDlip8KICAgICAgICBhc3NlcnQoRChkKS54KCkgPT0gNDMpOyAvLyDlupTor6XlpLHotKUKCiAgICAgICAgLy8gRSDlkowgRCDlhbfmnInnm7jlkIznmoTmjqXlj6PvvIwKICAgICAgICAvLyDmiYDku6Xku6XkuIvnmoTosIPnlKjlnKjov5DooYzml7bkuZ/kvJrlt6XkvZzjgIIKICAgICAgICAvLyDnhLbogIzvvIzlr7kgYEUoZClgIOeahOabtOaUueW5tuayoeacieWPjeaYoOWcqCBgRChkKWAg5LiK44CCCiAgICAgICAgRShkKS5zZXRYKDEwMjQpOwoKICAgICAgICAvLyDnjrDlnKjku44gYEQoZClgIOivu+WPluWwhuaYvuekuuaXp+WAvOOAggogICAgICAgIC8vIOS4i+mdoueahOaWreiogOacrOW6lOWcqOi/kOihjOaXtuWksei0pe+8jAogICAgICAgIC8vIOS9huWcqOatpOaooeW8j+eahOWIhuaekOS4reWNtOaIkOWKn+S6hu+8iOS4jeWBpeWFqO+8ieOAggogICAgICAgIGFzc2VydChEKGQpLngoKSA9PSA0Mik7CiAgICAgICAgLy8g5LiL6Z2i55qE5pat6KiA5Zyo6L+Q6KGM5pe25bqU6K+l5oiQ5Yqf77yMCiAgICAgICAgLy8g5L2G5Zyo6L+Z56eN5qih5byP55qE5YiG5p6Q5Lit5Y205Lya5aSx6LSl77yI5YGH6Ziz5oCn77yJ44CCCiAgICAgICAgYXNzZXJ0KEQoZCkueCgpID09IDEwMjQpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract D {
 constructor(uint \_x) { x \= \_x; }
 uint public x;
 function setX(uint \_x) public { x \= \_x; }
}
contract E {
 constructor() { x \= 2; }
 uint public x;
 function setX(uint \_x) public { x \= \_x; }
}
contract C {
 function f() public {
 address d \= address(new D(42));
 // \`d\` 被部署为 \`D\`, 所以现在它的 \`x\` 应该是42。
 assert(D(d).x() \== 42); // 应该成功
 assert(D(d).x() \== 43); // 应该失败
 // E 和 D 具有相同的接口，
 // 所以以下的调用在运行时也会工作。
 // 然而，对 \`E(d)\` 的更改并没有反映在 \`D(d)\` 上。
 E(d).setX(1024);
 // 现在从 \`D(d)\` 读取将显示旧值。
 // 下面的断言本应在运行时失败，
 // 但在此模式的分析中却成功了（不健全）。
 assert(D(d).x() \== 42);
 // 下面的断言在运行时应该成功，
 // 但在这种模式的分析中却会失败（假阳性）。
 assert(D(d).x() \== 1024);
 }
}
由于以上原因，确保对某个 `address` 或 `contract` 类型的变量的可信外部调用总是具有相同的调用者表达式类型。
在继承的情况下，将被调用的合约的变量作为最终派生类型的类型进行转换也是有帮助的。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7CgppbnRlcmZhY2UgVG9rZW4gewogICAgZnVuY3Rpb24gYmFsYW5jZU9mKGFkZHJlc3MgX2EpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAodWludCk7CiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIF90bywgdWludCBfYW10KSBleHRlcm5hbDsKfQoKY29udHJhY3QgVG9rZW5Db3JyZWN0IGlzIFRva2VuIHsKICAgIG1hcHBpbmcgKGFkZHJlc3MgPT4gdWludCkgYmFsYW5jZTsKICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MgX2EsIHVpbnQgX2IpIHsKICAgICAgICBiYWxhbmNlW19hXSA9IF9iOwogICAgfQogICAgZnVuY3Rpb24gYmFsYW5jZU9mKGFkZHJlc3MgX2EpIHB1YmxpYyB2aWV3IG92ZXJyaWRlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4gYmFsYW5jZVtfYV07CiAgICB9CiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIF90bywgdWludCBfYW10KSBwdWJsaWMgb3ZlcnJpZGUgewogICAgICAgIHJlcXVpcmUoYmFsYW5jZVttc2cuc2VuZGVyXSA+PSBfYW10KTsKICAgICAgICBiYWxhbmNlW21zZy5zZW5kZXJdIC09IF9hbXQ7CiAgICAgICAgYmFsYW5jZVtfdG9dICs9IF9hbXQ7CiAgICB9Cn0KCmNvbnRyYWN0IFRlc3QgewogICAgZnVuY3Rpb24gcHJvcGVydHlfdHJhbnNmZXIoYWRkcmVzcyBfdG9rZW4sIGFkZHJlc3MgX3RvLCB1aW50IF9hbXQpIHB1YmxpYyB7CiAgICAgICAgcmVxdWlyZShfdG8gIT0gYWRkcmVzcyh0aGlzKSk7CgogICAgICAgIFRva2VuQ29ycmVjdCB0ID0gVG9rZW5Db3JyZWN0KF90b2tlbik7CgogICAgICAgIHVpbnQgeFByZSA9IHQuYmFsYW5jZU9mKGFkZHJlc3ModGhpcykpOwogICAgICAgIHJlcXVpcmUoeFByZSA+PSBfYW10KTsKICAgICAgICB1aW50IHlQcmUgPSB0LmJhbGFuY2VPZihfdG8pOwoKICAgICAgICB0LnRyYW5zZmVyKF90bywgX2FtdCk7CiAgICAgICAgdWludCB4UG9zdCA9IHQuYmFsYW5jZU9mKGFkZHJlc3ModGhpcykpOwogICAgICAgIHVpbnQgeVBvc3QgPSB0LmJhbGFuY2VPZihfdG8pOwoKICAgICAgICBhc3NlcnQoeFBvc3QgPT0geFByZSAtIF9hbXQpOwogICAgICAgIGFzc2VydCh5UG9zdCA9PSB5UHJlICsgX2FtdCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
interface Token {
 function balanceOf(address \_a) external view returns (uint);
 function transfer(address \_to, uint \_amt) external;
}
contract TokenCorrect is Token {
 mapping (address \=> uint) balance;
 constructor(address \_a, uint \_b) {
 balance\[\_a\] \= \_b;
 }
 function balanceOf(address \_a) public view override returns (uint) {
 return balance\[\_a\];
 }
 function transfer(address \_to, uint \_amt) public override {
 require(balance\[msg.sender\] \>= \_amt);
 balance\[msg.sender\] \-= \_amt;
 balance\[\_to\] += \_amt;
 }
}
contract Test {
 function property\_transfer(address \_token, address \_to, uint \_amt) public {
 require(\_to != address(this));
 TokenCorrect t \= TokenCorrect(\_token);
 uint xPre \= t.balanceOf(address(this));
 require(xPre \>= \_amt);
 uint yPre \= t.balanceOf(\_to);
 t.transfer(\_to, \_amt);
 uint xPost \= t.balanceOf(address(this));
 uint yPost \= t.balanceOf(\_to);
 assert(xPost \== xPre \- \_amt);
 assert(yPost \== yPre + \_amt);
 }
}
注意，在函数 `property_transfer` 中， 外部调用是在变量 `t` 上执行的。
这种模式的另一个注意事项是对合约类型的状态变量的调用在被分析的合约之外。 在下面的代码中，即使合约 `B` 部署了合约 `A`， 存储在 `B.a` 中的地址也可以被任何人在合约 `B` 之外和合约 `B` 本身的交易之间调用。 为了反映对 `B.a` 的可能更改，编码允许对 `B.a` 进行无限次数的外部调用。 编码将跟踪 `B.a` 的存储，因此断言（2）应该成立。 然而，目前的编码允许这样的调用从概念上从合约 `B` 进行，因此断言（3）失败。 逻辑上使编码更强大是信任模式的扩展，正在开发中。 请注意，编码不跟踪 `address` 变量的存储，因此， 如果 `B.a` 的类型是 `address`，编码将假定其存储在对合约 `B` 的交易之间不会更改。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBBIHsKICAgIHVpbnQgcHVibGljIHg7CiAgICBhZGRyZXNzIGltbXV0YWJsZSBwdWJsaWMgb3duZXI7CiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgICBvd25lciA9IG1zZy5zZW5kZXI7CiAgICB9CiAgICBmdW5jdGlvbiBzZXRYKHVpbnQgX3gpIHB1YmxpYyB7CiAgICAgICAgcmVxdWlyZShtc2cuc2VuZGVyID09IG93bmVyKTsKICAgICAgICB4ID0gX3g7CiAgICB9Cn0KCmNvbnRyYWN0IEIgewogICAgQSBhOwogICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgYSA9IG5ldyBBKCk7CiAgICAgICAgYXNzZXJ0KGEueCgpID09IDApOyAvLyAoMSkg5bqU6K+l5oiQ56uLCiAgICB9CiAgICBmdW5jdGlvbiBnKCkgcHVibGljIHZpZXcgewogICAgICAgIGFzc2VydChhLm93bmVyKCkgPT0gYWRkcmVzcyh0aGlzKSk7IC8vICgyKSDlupTor6XmiJDnq4sKICAgICAgICBhc3NlcnQoYS54KCkgPT0gMCk7IC8vICgzKSDlupTor6XmiJDnq4ssIOS9huWksei0peS6hu+8jOeUseS6juWBh+mYs+aApwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract A {
 uint public x;
 address immutable public owner;
 constructor() {
 owner \= msg.sender;
 }
 function setX(uint \_x) public {
 require(msg.sender \== owner);
 x \= \_x;
 }
}
contract B {
 A a;
 constructor() {
 a \= new A();
 assert(a.x() \== 0); // (1) 应该成立
 }
 function g() public view {
 assert(a.owner() \== address(this)); // (2) 应该成立
 assert(a.x() \== 0); // (3) 应该成立, 但失败了，由于假阳性
 }
}
### 报告推断的归纳变量[](#id14 "此标题的永久链接")
对于那些被CHC引擎证明为安全的属性， SMT检查器可以检索由Horn求解器推断出的归纳不变性，作为证明的一部分。 目前有两种类型的不变量可以报告给用户：
* 合约不变量：这些是合约的状态变量的属性，在合约可能运行的每一个可能的事务之前和之后都是真的。 例如， `x >= y`，其中 `x` 和 `y` 是一个合约的状态变量。
 
* 可重入性属性：它们代表了合约在存在对未知代码的外部调用时的行为。 这些属性可以表达外部调用前后状态变量的值之间的关系， 其中外部调用可以自由地做任何事情，包括对分析的合约进行可重入调用。 导数变量代表所述外部调用后的状态变量的值。例如： `lock -> x = x'`。
 
用户可以使用命令行界面选项 `--model-checker-invariants "contract,reentrancy"` 来选择要报告的不变量类型， 或者在 [JSON 输入](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#compiler-api) 中的字段 `settings.modelChecker.invariants` 中作为数组。 默认情况下，SMT检查器不报告不变量。
### 有松弛变量的除法和模数运算[](#id15 "此标题的永久链接")
Spacer是SMT检查器使用的默认Horn求解器，它通常不喜欢Horn规则中的除法和模数操作。 正因为如此，默认情况下，Solidity的除法和模运算是用约束条件 `a = b * d + m` 来编码的， 其中 `d = a / b` 和 `m = a % b`。 然而，对于其他求解器，如Eldarica，更喜欢语法上的精确操作。 命令行标志 `--model-checker-div-mod-no-slacks` 和 JSON选项 `settings.modelChecker.divModNoSlacks` 可以用来切换编码， 这取决于所用求解器的偏好。
### Natspec标签函数抽象化[](#natspec "此标题的永久链接")
某些函数包括常见的数学方法，如 `pow` 和 `sqrt`， 可能它们过于复杂，无法用完全自动化的方式进行分析。 这些函数可以用Natspec标签进行注释，向SMT检查器表明这些函数应该被抽象化。 这意味着在调用此函数时，不会使用函数的主体，函数将：
* 返回一个非决定性的值，如果抽象函数是 view/pure 类型的，则保持状态变量不变， 否则会将状态变量设置为非决定性的值。 可以通过注解 `//@custom:smtchecker abstract-function-nondet` 来使用。
 
* 作为一个未被解释的函数。这意味着函数的语义（由主体给出）会被忽略， 这个函数的唯一属性是，给定相同的输入，它保证有相同的输出。 这一点目前正在开发中，并将通过注解 `//@custom:smtchecker abstract-function-uf` 来使用。
 
### 模型检查引擎[](#smtchecker-engines "此标题的永久链接")
SMT检查器模块实现了两个不同的推理引擎，一个是有界模型检查器（Bounded Model Checker， BMC）， 一个是约束角条款（Constrained Horn Clauses， CHC）系统。 这两个引擎目前都在开发中，并且有不同的特点。 这两个引擎是独立的，每一个属性警告都说明它来自哪个引擎。 请注意，上面所有带有反例的例子都是由CHC这个更强大的引擎报告的。
默认情况下，两个引擎都会被使用，其中首先运行CHC， 每一个没有被证明的属性都被传递给BMC。 您可以通过命令行界面选项 `--model-checker-engine {all,bmc,chc,none}` 或 JSON选项 `settings.modelChecker.engine {all,bmc,chc,none}` 来选择一个特定的引擎。
#### 有界模型检查器 （BMC）[](#bmc "此标题的永久链接")
BMC引擎单独地分析函数，也就是说，它在分析每个函数时不会考虑合约在多个交易中的整体行为。 目前在这个引擎中循环也会被忽略了。 只要不是直接或间接的递归，内部函数调用是内联的。 如果可能的话，外部函数调用是内联的。 有可能受重入影响的理论在此被忽略。
上述特点使BMC容易报告假阳性， 但它也是轻量级的，应该能够快速找到小的局部bug。
#### 受约束的角条款（Constrained Horn Clauses， CHC）[](#constrained-horn-clauses-chc "此标题的永久链接")
合约的控制流程图（CFG）被建模为一个Horn条款系统， 其中合约的生命周期由一个可以非确定性地访问每个公共/外部函数的循环表示。 这样，在分析任何函数时都会考虑到整个合约在无限制数量的事务中的行为。 这个引擎完全支持循环。 支持内部函数调用，而外部函数调用假定被调用的代码是未知的，可以做任何事情。
在能够证明的内容方面，CHC引擎要比BMC强大得多，但可能需要更多的计算资源。
### SMT和Horn求解器[](#smthorn "此标题的永久链接")
上面详述的两个引擎使用自动定理证明器作为其逻辑后端。 BMC使用一个SMT求解器，而CHC使用一个Horn求解器。 通常同一个工具可以同时充当这两种工具，如 [z3](https://github.com/Z3Prover/z3)， 它主要是一个SMT求解器，并将 [Spacer](https://spacer.bitbucket.io/) 作为一个Horn求解器使用，而 [Eldarica](https://github.com/uuverifiers/eldarica) 则同时做这两种工作。
如果求解器可用的话，用户可以通过命令行界面选项 `--model-checker-solvers {all,cvc4,eld,smtlib2,z3}` 或JSON选项 `settings.modelChecker.solvers=[smtlib2,z3]` 来选择应该使用哪个求解器， 其中：
* `cvc4` 仅在使用 `solc` 编译二进制文件时可用。并且只有BMC使用 `cvc4`。
 
* `eld` 是通过其二进制文件使用的，必须安装在系统中。只有CHC使用了 `eld`，并且是在只有 `z3` 没有被启用的情况下。
 
* `smtlib2` 以 [smtlib2](http://smtlib.cs.uiowa.edu/) 格式输出 SMT/Horn 查询。 这些可以和编译器的 [回调机制](https://github.com/ethereum/solc-js) 一起使用， 这样就可以采用系统中的任何求解器二进制来同步返回查询的结果给编译器。 根据调用哪个求解器，BMC和CHC都可以使用此方法。
 
* `z3` 是可用的情况
 
 * 如果 `solc` 与它一起被编译的话；
 
 * 如果Linux系统中安装了4.8.x及其以上版本的动态 `z3` 库（从Solidity 0.7.6开始）；
 
 * 在 `soljson.js` （从Solidity 0.6.9开始）中静态的，也就是编译器的JavaScript二进制。
 
备注
z3 4.8.16 版本破坏了与以前版本的 ABI 兼容性， 不能与 solc <=0.8.13 版本一起使用。如果您正在使用 z3 >=4.8.16 的版本， 请使用 solc >=0.8.14 的版本。反之，只使用旧的z3与旧的solc版本。 我们也建议使用最新的z3版本，这也是SMT检查器的作用。
由于 BMC 和 CHC 都使用 `z3`，而且 `z3` 可以在更多的环境中使用，包括在浏览器中， 大多数用户几乎不需要关心这个选项。更高级的用户可能会应用这个选项，在更复杂的问题上尝试其他求解器。
请注意，所选择的引擎和求解器的某些组合将导致SMT检查器不做任何事情，例如选择CHC和 `cvc4`。
## 抽象和假阳性结果[](#id18 "此标题的永久链接")
SMT检查器以一种不完整但健全的方式实现了抽象： 如果报告了一个bug，它可能是由抽象引入的假阳性（由于删除了知识或使用了非精确类型）。 如果它确定一个验证目标是安全的，那么它确实是安全的，也就是说， 不存在假阴性（除非SMT检查器中存在一个bug）。
如果一个目标不能被证明，您可以尝试通过使用上一节中的调整选项来帮助求解器。 如果您确定是假阳性，在代码中加入有更多信息的 `require` 语句也可能给求解器带来一些更多的帮助。
### SMT的编码和类型[](#id19 "此标题的永久链接")
SMT检查器编码试图尽可能精确， 将Solidity类型和表达式映射到它们最接近的 [SMT-LIB](http://smtlib.cs.uiowa.edu/) 表示法上， 正如下表所示。
关于 SMT 编码内部如何工作的更多细节，请参阅论文 [基于 SMT 的 Solidity 智能合约验证](https://github.com/chriseth/solidity_isola/blob/master/main.pdf)。
尚不支持的类型由一个256位无符号整数抽象出来，其不支持的操作被忽略。
关于SMT编码的内部工作方式的更多细节，请参见论文 [基于SMT的Solidity智能合约验证](https://github.com/leonardoalt/text/blob/master/solidity_isola_2018/main.pdf)。
### 函数调用[](#id20 "此标题的永久链接")
在BMC引擎中，当可能时，即当它们的实现可用时，对相同合约（或基础合约）的函数调用被内联。 对其他合约中的函数的调用不被内联，即使它们的代码是可用的，因为我们不能保证实际部署的代码是相同的。
CHC引擎创建了非线性的Horn选项，使用被调用函数的摘要来支持内部函数调用。 外部函数调用被视为对未知代码的调用，包括潜在的可重入调用。
复杂的纯函数是由参数上的未转译函数（UF）抽象出来的。
方法
BMC/CHC 运行方式
`assert`
验证目标。
`require`
假设。
内部调用
BMC: 内联函数调用。 CHC：函数摘要。
对已知代码的外部调用
BMC: 内联函数调用或 抹去关于状态变量的记忆 和本地存储引用。 CHC: 假设被调用的代码是未知的。 试图推断出在调用返回后仍然成立的不变性。
存储数组的压栈和出栈
精确地支持 检查是否从一个空数组弹出。
ABI 函数
用UF函数进行抽象
`addmod`, `mulmod`
精确地支持
`gasleft`, `blockhash`, `keccak256`, `ecrecover` `ripemd160`
用UF函数进行抽象
无执行动作的纯函数（外部或复杂）。
用UF函数进行抽象
无执行动作的外部函数
BMC：擦除状态记忆并假定结果是不确定的。 CHC：不确定的摘要。 试图推断出在调用返回后仍然成立的不变性。
transfer
BMC：检查合约的余额是否足够。 CHC：还不执行检查。
其他调用
目前不支持
使用抽象意味着失去精确的知识，但在许多情况下，这并不意味着失去证明力。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBSZWNvdmVyCnsKICAgIGZ1bmN0aW9uIGYoCiAgICAgICAgYnl0ZXMzMiBoYXNoLAogICAgICAgIHVpbnQ4IHYxLCB1aW50OCB2MiwKICAgICAgICBieXRlczMyIHIxLCBieXRlczMyIHIyLAogICAgICAgIGJ5dGVzMzIgczEsIGJ5dGVzMzIgczIKICAgICkgcHVibGljIHB1cmUgcmV0dXJucyAoYWRkcmVzcykgewogICAgICAgIGFkZHJlc3MgYTEgPSBlY3JlY292ZXIoaGFzaCwgdjEsIHIxLCBzMSk7CiAgICAgICAgcmVxdWlyZSh2MSA9PSB2Mik7CiAgICAgICAgcmVxdWlyZShyMSA9PSByMik7CiAgICAgICAgcmVxdWlyZShzMSA9PSBzMik7CiAgICAgICAgYWRkcmVzcyBhMiA9IGVjcmVjb3ZlcihoYXNoLCB2MiwgcjIsIHMyKTsKICAgICAgICBhc3NlcnQoYTEgPT0gYTIpOwogICAgICAgIHJldHVybiBhMTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Recover
{
 function f(
 bytes32 hash,
 uint8 v1, uint8 v2,
 bytes32 r1, bytes32 r2,
 bytes32 s1, bytes32 s2
 ) public pure returns (address) {
 address a1 \= ecrecover(hash, v1, r1, s1);
 require(v1 \== v2);
 require(r1 \== r2);
 require(s1 \== s2);
 address a2 \= ecrecover(hash, v2, r2, s2);
 assert(a1 \== a2);
 return a1;
 }
}
在上面的例子中，SMT检查器的表达能力不足以实际计算 `ecrecover`， 但通过将函数调用建模为未转译的函数，我们知道在同等参数上调用时返回值是相同的。 这就足以证明上面的断言总是正确的。
对于已知是确定性的函数，可以用UF来抽象一个函数调用， 对于纯函数也很容易做到。 然而，对于一般的外部函数来说，这是很难做到的， 因为它们可能依赖于状态变量。
### 引用类型和别名[](#id21 "此标题的永久链接")
Solidity 为具有相同 [数据位置](https://docs.soliditylang.org/zh-cn/latest/types.html#data-location) 的引用类型实现了别名。 这意味着可以通过对同一数据区域的引用来修改一个变量。 SMT检查器并不跟踪哪些引用是指向相同的数据。 这意味着每当分配一个局部引用或引用类型的状态变量时， 所有关于相同类型和数据位置的变量的知识都会被抹去。 如果类型是嵌套的，知识删除也包括所有的前缀基础类型。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBBbGlhc2luZwp7CiAgICB1aW50W10gYXJyYXkxOwogICAgdWludFtdW10gYXJyYXkyOwogICAgZnVuY3Rpb24gZigKICAgICAgICB1aW50W10gbWVtb3J5IGEsCiAgICAgICAgdWludFtdIG1lbW9yeSBiLAogICAgICAgIHVpbnRbXVtdIG1lbW9yeSBjLAogICAgICAgIHVpbnRbXSBzdG9yYWdlIGQKICAgICkgaW50ZXJuYWwgewogICAgICAgIGFycmF5MVswXSA9IDQyOwogICAgICAgIGFbMF0gPSAyOwogICAgICAgIGNbMF1bMF0gPSAyOwogICAgICAgIGJbMF0gPSAxOwogICAgICAgIC8vIOWIoOmZpOWFs+S6juWGheWtmOW8leeUqOeahOiusOW/huS4jeW6lOivpeWIoOmZpOWFs+S6jueKtuaAgeWPmOmHj+eahOiusOW/huOAggogICAgICAgIGFzc2VydChhcnJheTFbMF0gPT0gNDIpOwogICAgICAgIC8vIOS9huaYr++8jOWvueWtmOWCqOW8leeUqOeahOi1i+WAvOWwhuebuOW6lOWcsOWIoOmZpOWtmOWCqOiusOW/huOAggogICAgICAgIGRbMF0gPSAyOwogICAgICAgIC8vIOeUseS6juS4iumdoueahOWIhumFje+8jOWksei0peS4uuWBh+mYs+aAp+OAggogICAgICAgIGFzc2VydChhcnJheTFbMF0gPT0gNDIpOwogICAgICAgIC8vIOWksei0pe+8jOWboOS4uiBgYSA9PSBiYCDmmK/lj6/og73nmoTjgIIKICAgICAgICBhc3NlcnQoYVswXSA9PSAyKTsKICAgICAgICAvLyDlpLHotKXvvIzlm6DkuLogYGNbaV0gPT0gYmAg5piv5Y+v6IO955qE44CCCiAgICAgICAgYXNzZXJ0KGNbMF1bMF0gPT0gMik7CiAgICAgICAgYXNzZXJ0KGRbMF0gPT0gMik7CiAgICAgICAgYXNzZXJ0KGJbMF0gPT0gMSk7CiAgICB9CiAgICBmdW5jdGlvbiBnKAogICAgICAgIHVpbnRbXSBtZW1vcnkgYSwKICAgICAgICB1aW50W10gbWVtb3J5IGIsCiAgICAgICAgdWludFtdW10gbWVtb3J5IGMsCiAgICAgICAgdWludCB4CiAgICApIHB1YmxpYyB7CiAgICAgICAgZihhLCBiLCBjLCBhcnJheTJbeF0pOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.0;
contract Aliasing
{
 uint\[\] array1;
 uint\[\]\[\] array2;
 function f(
 uint\[\] memory a,
 uint\[\] memory b,
 uint\[\]\[\] memory c,
 uint\[\] storage d
 ) internal {
 array1\[0\] \= 42;
 a\[0\] \= 2;
 c\[0\]\[0\] \= 2;
 b\[0\] \= 1;
 // 删除关于内存引用的记忆不应该删除关于状态变量的记忆。
 assert(array1\[0\] \== 42);
 // 但是，对存储引用的赋值将相应地删除存储记忆。
 d\[0\] \= 2;
 // 由于上面的分配，失败为假阳性。
 assert(array1\[0\] \== 42);
 // 失败，因为 \`a == b\` 是可能的。
 assert(a\[0\] \== 2);
 // 失败，因为 \`c\[i\] == b\` 是可能的。
 assert(c\[0\]\[0\] \== 2);
 assert(d\[0\] \== 2);
 assert(b\[0\] \== 1);
 }
 function g(
 uint\[\] memory a,
 uint\[\] memory b,
 uint\[\]\[\] memory c,
 uint x
 ) public {
 f(a, b, c, array2\[x\]);
 }
}
在对 `b[0]` 进行赋值后，我们需要清除关于 `a` 的知识， 因为它有相同的类型（ `uint[]` ）和数据位置（内存）。 我们还需要清除关于 `c` 的知识，因为它的基本类型也是一个位于内存中的 `uint[]`。 这意味着一些 `c[i]` 可能与 `b` 或 `a` 指的是同一个数据。
注意，我们没有清除关于 `array` 和 `d` 的知识， 因为它们位于存储区，尽管它们也有 `uint[]` 类型。 然而，如果 `d` 被分配，我们就需要清除关于 `array` 的知识，反之亦然。
### 合约余额[](#id22 "此标题的永久链接")
如果在部署交易中 `msg.value` > 0，则合约可能在部署时被发送资金。 然而，合约的地址在部署前可能已经有了资金， 这些资金由合约保存。 因此，SMT检查器在构造函数中假定 `address(this).balance >= msg.value`， 以便与EVM规则一致。合约的余额也可能在不触发任何对合约的调用的情况下增加，如果
* `selfdestruct` 是由另一个合约执行的，被分析的合约是剩余资金的接收目标。
 
* 该合约是某个区块的coinbase（即 `block.coinbase`）。
 
为了正确建模，SMT检查器假设在每一笔新的交易中，合约的余额可能至少增长 `msg.value` 的值。
## 现实世界的假设[](#id23 "此标题的永久链接")
有些情况可以在Solidity和EVM中可以表达出，但可能在实践中不会发生。 其中一种情况是动态存储数组的长度在压栈过程中溢出： 如果 `push` 操作被应用于一个长度为 2^256 - 1的数组，它的长度会悄悄溢出。 然而，这在实践中不太可能发生，因为将数组增长到这一点所需的操作需要数十亿年的时间来执行。 SMT检查器采取的另一个类似的假设是，一个地址的余额永远不会溢出。
类似的想法在 [EIP-1985](https://eips.ethereum.org/EIPS/eip-1985) 中提出过。

# [Index — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/genindex.html) 
 _https://docs.soliditylang.org/en/latest/genindex.html_

[**Symbols**](#Symbols) | [**A**](#A) | [**B**](#B) | [**C**](#C) | [**D**](#D) | [**E**](#E) | [**F**](#F) | [**G**](#G) | [**H**](#H) | [**I**](#I) | [**J**](#J) | [**K**](#K) | [**L**](#L) | [**M**](#M) | [**N**](#N) | [**O**](#O) | [**P**](#P) | [**R**](#R) | [**S**](#S) | [**T**](#T) | [**U**](#U) | [**V**](#V) | [**W**](#W) | [**Y**](#Y)
## Symbols
* [**\--allow-paths**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-8), [\[1\]](https://docs.soliditylang.org/en/latest/using-the-compiler.html#index-1)
* [**\--base-path**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-7), [\[1\]](https://docs.soliditylang.org/en/latest/using-the-compiler.html#index-1), [\[2\]](https://docs.soliditylang.org/en/latest/using-the-compiler.html#index-3)
* [**\--include-path**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-7), [\[1\]](https://docs.soliditylang.org/en/latest/using-the-compiler.html#index-1)
* [**\--libraries**](https://docs.soliditylang.org/en/latest/using-the-compiler.html#index-2)
* [**\--link**](https://docs.soliditylang.org/en/latest/using-the-compiler.html#index-2)
* [**\--no-import-callback**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-1)
* [**\--standard-json**](https://docs.soliditylang.org/en/latest/using-the-compiler.html#index-5), [\[1\]](https://docs.soliditylang.org/en/latest/using-the-compiler.html#index-3)
* [<stdin>](https://docs.soliditylang.org/en/latest/path-resolution.html#index-3)
## A
* [abi](https://docs.soliditylang.org/en/latest/abi-spec.html#index-0), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-3), [\[2\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-4)
 * [decode](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-1)
 * [encode](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-1)
 * [encodeCall](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-1)
 * [encodePacked](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-1)
 * [encodeWithSelector](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-1)
 * [encodeWithSignature](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-1)
* [**ABI coder**](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-3)
* [**abstract contract**](https://docs.soliditylang.org/en/latest/contracts.html#index-25), [\[1\]](https://docs.soliditylang.org/en/latest/contracts.html#index-23)
* access
 * [restricting](https://docs.soliditylang.org/en/latest/common-patterns.html#index-1)
* [**account**](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-7)
* [addmod](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-8)
* [address](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-7), [\[1\]](https://docs.soliditylang.org/en/latest/types.html#index-5), [\[2\]](https://docs.soliditylang.org/en/latest/types.html#index-8)
 * [balance](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-3)
 * [code](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-3)
 * [codehash](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-3)
 * [send](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-3)
 * [transfer](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-3)
* [**allowed paths**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-8), [\[1\]](https://docs.soliditylang.org/en/latest/using-the-compiler.html#index-1)
* [analyse](https://docs.soliditylang.org/en/latest/analysing-compilation-output.html#index-0)
* [anonymous](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-11)
* [application binary interface](https://docs.soliditylang.org/en/latest/abi-spec.html#index-0)
* [**array**](https://docs.soliditylang.org/en/latest/types.html#index-17), [\[1\]](https://docs.soliditylang.org/en/latest/contracts.html#index-10), [\[2\]](https://docs.soliditylang.org/en/latest/types.html#index-16)
 * [**allocating**](https://docs.soliditylang.org/en/latest/types.html#index-20)
 * [**dangling storage references**](https://docs.soliditylang.org/en/latest/types.html#index-23)
 * [**length**](https://docs.soliditylang.org/en/latest/types.html#index-22)
 * [**pop**](https://docs.soliditylang.org/en/latest/types.html#index-22)
 * [**push**](https://docs.soliditylang.org/en/latest/types.html#index-22)
 * [**slice**](https://docs.soliditylang.org/en/latest/types.html#index-24)
* [array of strings](https://docs.soliditylang.org/en/latest/contracts.html#index-10)
* [**asm**](https://docs.soliditylang.org/en/latest/assembly.html#index-0), [**\[1\]**](https://docs.soliditylang.org/en/latest/yul.html#index-0), [\[2\]](https://docs.soliditylang.org/en/latest/analysing-compilation-output.html#index-0)
* [**assembly**](https://docs.soliditylang.org/en/latest/assembly.html#index-0), [**\[1\]**](https://docs.soliditylang.org/en/latest/yul.html#index-0)
* [assembly-flags (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.assemblyFlags)
* [assembly-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.assemblyStatement)
* [**assert**](https://docs.soliditylang.org/en/latest/control-structures.html#index-8), [\[1\]](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-6), [\[2\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-7)
* [**assignment**](https://docs.soliditylang.org/en/latest/control-structures.html#index-4), [\[1\]](https://docs.soliditylang.org/en/latest/types.html#index-29)
 * [**destructuring**](https://docs.soliditylang.org/en/latest/control-structures.html#index-5)
* auction
 * [blind](https://docs.soliditylang.org/en/latest/solidity-by-example.html#index-1)
 * [open](https://docs.soliditylang.org/en/latest/solidity-by-example.html#index-1)
## B
* [balance](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-7), [\[1\]](https://docs.soliditylang.org/en/latest/types.html#index-5), [\[2\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-9)
* [ballot](https://docs.soliditylang.org/en/latest/solidity-by-example.html#index-0)
* base
 * [**constructor**](https://docs.soliditylang.org/en/latest/contracts.html#index-23)
* [**base class**](https://docs.soliditylang.org/en/latest/contracts.html#index-19)
* [**base path**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-7), [\[1\]](https://docs.soliditylang.org/en/latest/using-the-compiler.html#index-1)
* [**base slot**](https://docs.soliditylang.org/en/latest/contracts.html#index-8)
* [blind auction](https://docs.soliditylang.org/en/latest/solidity-by-example.html#index-1)
* [blobhash](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-4)
* [**block**](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-5), [\[1\]](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-4), [\[2\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-3)
 * [basefee](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-4), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-3)
 * [blobbasefee](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-4), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-3)
 * [chainid](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-4)
 * [coinbase](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-4)
 * [difficulty](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-4)
 * [gaslimit](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-4)
 * [number](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-4), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-3)
 * [prevrandao](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-4)
 * [timestamp](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-4), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-3)
* [block (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.block)
* [blockhash](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-4)
* [**bool**](https://docs.soliditylang.org/en/latest/types.html#index-2)
* [boolean-literal (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.booleanLiteral)
* [break](https://docs.soliditylang.org/en/latest/control-structures.html#index-1)
* [break-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.breakStatement)
* [Bugs](https://docs.soliditylang.org/en/latest/bugs.html#index-0)
* [byte array](https://docs.soliditylang.org/en/latest/types.html#index-7)
* [**bytes**](https://docs.soliditylang.org/en/latest/types.html#index-18), [\[1\]](https://docs.soliditylang.org/en/latest/types.html#index-12)
 * [concat](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-2)
* [bytes members](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-5)
* [**bytes-concat**](https://docs.soliditylang.org/en/latest/types.html#index-19)
* [bytes32](https://docs.soliditylang.org/en/latest/types.html#index-7)
## C
* [**C3 linearization**](https://docs.soliditylang.org/en/latest/contracts.html#index-24)
* [call](https://docs.soliditylang.org/en/latest/types.html#index-5), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-9)
* [call-argument-list (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.callArgumentList)
* [callcode](https://docs.soliditylang.org/en/latest/contracts.html#index-27), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-9)
* [**cast**](https://docs.soliditylang.org/en/latest/types.html#index-32)
* [catch-clause (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.catchClause)
* [checked](https://docs.soliditylang.org/en/latest/control-structures.html#index-7)
* [cleanup](https://docs.soliditylang.org/en/latest/ir-breaking-changes.html#index-3)
* [codehash](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-9)
* [coding style](https://docs.soliditylang.org/en/latest/style-guide.html#index-0)
* [coin](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-3)
* [coinbase](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-3)
* [**commandline compiler**](https://docs.soliditylang.org/en/latest/using-the-compiler.html#index-0)
* [**comment**](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-9)
* [common subexpression elimination](https://docs.soliditylang.org/en/latest/internals/optimizer.html#index-0)
* [compile target](https://docs.soliditylang.org/en/latest/using-the-compiler.html#index-4)
* compiler
 * [commandline](https://docs.soliditylang.org/en/latest/using-the-compiler.html#index-0)
* [**compound operators**](https://docs.soliditylang.org/en/latest/types.html#index-29)
* [**constant**](https://docs.soliditylang.org/en/latest/contracts.html#index-7), [\[1\]](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-11)
* [constant propagation](https://docs.soliditylang.org/en/latest/internals/optimizer.html#index-0)
* [constant-variable-declaration (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.constantVariableDeclaration)
* [**constructor**](https://docs.soliditylang.org/en/latest/contracts.html#index-22), [\[1\]](https://docs.soliditylang.org/en/latest/contracts.html#index-1)
 * [arguments](https://docs.soliditylang.org/en/latest/contracts.html#index-2)
* [constructor-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.constructorDefinition)
* [continue](https://docs.soliditylang.org/en/latest/control-structures.html#index-1)
* [continue-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.continueStatement)
* [**contract**](https://docs.soliditylang.org/en/latest/contracts.html#index-0), [\[1\]](https://docs.soliditylang.org/en/latest/structure-of-a-contract.html#index-0)
 * [**abstract**](https://docs.soliditylang.org/en/latest/contracts.html#index-25), [\[1\]](https://docs.soliditylang.org/en/latest/contracts.html#index-23)
 * [**base**](https://docs.soliditylang.org/en/latest/contracts.html#index-19)
 * [**creation**](https://docs.soliditylang.org/en/latest/contracts.html#index-1)
 * [**interface**](https://docs.soliditylang.org/en/latest/contracts.html#index-26)
 * [modular](https://docs.soliditylang.org/en/latest/solidity-by-example.html#index-3)
 * [**precompiled**](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-17)
* [contract creation](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-15)
* [**contract type**](https://docs.soliditylang.org/en/latest/types.html#index-6)
* [contract verification](https://docs.soliditylang.org/en/latest/metadata.html#index-0)
* [contract-body-element (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.contractBodyElement)
* [contract-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.contractDefinition)
* contracts
 * [creating](https://docs.soliditylang.org/en/latest/control-structures.html#index-3)
* [creationCode](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-11)
* [cryptography](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-8)
* [**custom storage layout**](https://docs.soliditylang.org/en/latest/contracts.html#index-8)
* [custom type](https://docs.soliditylang.org/en/latest/types.html#index-14)
## D
* [data](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-3)
* [data-location (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.dataLocation)
* [**days**](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-2)
* [deactivate](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-16)
* [decimal-number (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer.DecimalNumber)
* [declarations](https://docs.soliditylang.org/en/latest/control-structures.html#index-6)
* [default value](https://docs.soliditylang.org/en/latest/control-structures.html#index-6)
* [delegatecall](https://docs.soliditylang.org/en/latest/contracts.html#index-27), [\[1\]](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-13), [\[2\]](https://docs.soliditylang.org/en/latest/types.html#index-5), [\[3\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-9)
* [**delete**](https://docs.soliditylang.org/en/latest/types.html#index-30)
* [**denomination**](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-0)
 * [**ether**](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-1)
 * [**time**](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-2)
* [**deriving**](https://docs.soliditylang.org/en/latest/contracts.html#index-19)
* [difficulty](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-3)
* [**direct import**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-5)
* [dirty bits](https://docs.soliditylang.org/en/latest/ir-breaking-changes.html#index-3)
* [do-while-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.doWhileStatement)
* [do/while](https://docs.soliditylang.org/en/latest/control-structures.html#index-1)
* [double-quoted-printable (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer.DoubleQuotedPrintable)
* [dynamic array](https://docs.soliditylang.org/en/latest/contracts.html#index-10)
## E
* [ecrecover](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-8)
* [elementary-type-name (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.elementaryTypeName)
* [else](https://docs.soliditylang.org/en/latest/control-structures.html#index-1)
* [emit-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.emitStatement)
* [empty-string-literal (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer.EmptyStringLiteral)
* [encode](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-3)
* [encoding](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-4)
* [enum](https://docs.soliditylang.org/en/latest/structure-of-a-contract.html#index-0), [\[1\]](https://docs.soliditylang.org/en/latest/types.html#index-13)
* [enum-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.enumDefinition)
* [**error**](https://docs.soliditylang.org/en/latest/contracts.html#index-18), [\[1\]](https://docs.soliditylang.org/en/latest/abi-spec.html#index-2)
* [error-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.errorDefinition)
* [error-parameter (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.errorParameter)
* [**errors**](https://docs.soliditylang.org/en/latest/control-structures.html#index-8)
* [escape-sequence (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer.EscapeSequence)
* [escrow](https://docs.soliditylang.org/en/latest/solidity-by-example.html#index-2)
* [**ether**](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-1)
* [**ethereum virtual machine**](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-6)
* evaluation order
 * [**expression**](https://docs.soliditylang.org/en/latest/ir-breaking-changes.html#index-0)
 * [**function arguments**](https://docs.soliditylang.org/en/latest/ir-breaking-changes.html#index-1)
* [**event**](https://docs.soliditylang.org/en/latest/contracts.html#index-16), [\[1\]](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-2), [\[2\]](https://docs.soliditylang.org/en/latest/structure-of-a-contract.html#index-0)
 * [**anonymous**](https://docs.soliditylang.org/en/latest/contracts.html#index-16)
 * [**indexed**](https://docs.soliditylang.org/en/latest/contracts.html#index-16)
 * [**topic**](https://docs.soliditylang.org/en/latest/contracts.html#index-16)
* [event-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.eventDefinition)
* [event-parameter (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.eventParameter)
* [**evm**](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-6)
* [**EVM version**](https://docs.soliditylang.org/en/latest/using-the-compiler.html#index-4)
* [**evmasm**](https://docs.soliditylang.org/en/latest/assembly.html#index-0), [**\[1\]**](https://docs.soliditylang.org/en/latest/yul.html#index-0)
* [**exception**](https://docs.soliditylang.org/en/latest/control-structures.html#index-8)
* [expression (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.expression)
* [expression-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.expressionStatement)
* [external](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-10), [\[1\]](https://docs.soliditylang.org/en/latest/contracts.html#index-3)
## F
* [**fallback function**](https://docs.soliditylang.org/en/latest/contracts.html#index-14)
* [fallback-function-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.fallbackFunctionDefinition)
* [**false**](https://docs.soliditylang.org/en/latest/types.html#index-2)
* [file://](https://docs.soliditylang.org/en/latest/path-resolution.html#index-10)
* [filesystem path](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-8)
* [**finney**](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-1)
* [**fixed**](https://docs.soliditylang.org/en/latest/types.html#index-4)
* [**fixed point number**](https://docs.soliditylang.org/en/latest/types.html#index-4)
* [fixed-bytes (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer.FixedBytes)
* [for](https://docs.soliditylang.org/en/latest/control-structures.html#index-1)
* [for-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.forStatement)
* [function](https://docs.soliditylang.org/en/latest/structure-of-a-contract.html#index-0)
 * [**call**](https://docs.soliditylang.org/en/latest/control-structures.html#index-2), [\[1\]](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-12)
 * [external](https://docs.soliditylang.org/en/latest/control-structures.html#index-2)
 * [fallback](https://docs.soliditylang.org/en/latest/contracts.html#index-14)
 * [**free**](https://docs.soliditylang.org/en/latest/contracts.html#index-9), [\[1\]](https://docs.soliditylang.org/en/latest/contracts.html#index-30)
 * [**getter**](https://docs.soliditylang.org/en/latest/contracts.html#index-4)
 * [internal](https://docs.soliditylang.org/en/latest/control-structures.html#index-2)
 * [**modifier**](https://docs.soliditylang.org/en/latest/contracts.html#index-5), [\[1\]](https://docs.soliditylang.org/en/latest/common-patterns.html#index-2), [\[2\]](https://docs.soliditylang.org/en/latest/common-patterns.html#index-4), [\[3\]](https://docs.soliditylang.org/en/latest/structure-of-a-contract.html#index-0)
 * [pure](https://docs.soliditylang.org/en/latest/contracts.html#index-12)
 * [receive](https://docs.soliditylang.org/en/latest/contracts.html#index-13)
 * [view](https://docs.soliditylang.org/en/latest/contracts.html#index-11)
* [function parameter](https://docs.soliditylang.org/en/latest/control-structures.html#index-0)
* [function pointers](https://docs.soliditylang.org/en/latest/ir-breaking-changes.html#index-2)
* [**function type**](https://docs.soliditylang.org/en/latest/types.html#index-15)
* [function-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.functionDefinition)
* [function-type-name (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.functionTypeName)
* [**functions**](https://docs.soliditylang.org/en/latest/contracts.html#index-9)
## G
* [**gas**](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-9), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-3)
* [**gas price**](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-9), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-3)
* [gasleft](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-5)
* getter
 * [**function**](https://docs.soliditylang.org/en/latest/contracts.html#index-4)
* [goto](https://docs.soliditylang.org/en/latest/control-structures.html#index-1)
* [**gwei**](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-1)
## H
* [hex-number (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer.HexNumber)
* [hex-string (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer.HexString)
* [hex-string-literal (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.hexStringLiteral)
* [**Host Filesystem Loader**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-1)
* [**hours**](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-2)
## I
* [identifier (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer.Identifier), [\[1\]](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.identifier)
* [identifier-path (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.identifierPath)
* [if](https://docs.soliditylang.org/en/latest/control-structures.html#index-1)
* [if-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.ifStatement)
* [**import**](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-7)
 * [direct](https://docs.soliditylang.org/en/latest/path-resolution.html#index-5)
 * [**path**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-4), [\[1\]](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-8)
 * [**relative**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-6)
 * [**remapping**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-9)
* [**import callback**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-1), [\[1\]](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-8)
* [import-directive (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.importDirective)
* [**include paths**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-7), [\[1\]](https://docs.soliditylang.org/en/latest/using-the-compiler.html#index-1)
* [indexed](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-11)
* [**inheritance**](https://docs.soliditylang.org/en/latest/contracts.html#index-19)
 * [**multiple**](https://docs.soliditylang.org/en/latest/contracts.html#index-24)
* [inheritance list](https://docs.soliditylang.org/en/latest/contracts.html#index-23)
* [inheritance-specifier (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.inheritanceSpecifier)
* inline
 * [**arrays**](https://docs.soliditylang.org/en/latest/types.html#index-21)
* [inline-array-expression (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.inlineArrayExpression)
* [**installing**](https://docs.soliditylang.org/en/latest/installing-solidity.html#index-0)
* [**instruction**](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-11)
* [**int**](https://docs.soliditylang.org/en/latest/types.html#index-3)
* [**integer**](https://docs.soliditylang.org/en/latest/types.html#index-3), [\[1\]](https://docs.soliditylang.org/en/latest/types.html#index-9)
* [**interface contract**](https://docs.soliditylang.org/en/latest/contracts.html#index-26)
* [interface-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.interfaceDefinition)
* [internal](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-10), [\[1\]](https://docs.soliditylang.org/en/latest/contracts.html#index-3)
* [**iterable mappings**](https://docs.soliditylang.org/en/latest/types.html#index-27)
* [iulia](https://docs.soliditylang.org/en/latest/yul.html#index-0)
## J
* [julia](https://docs.soliditylang.org/en/latest/yul.html#index-0)
## K
* [keccak256](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-8)
## L
* [**layout at**](https://docs.soliditylang.org/en/latest/contracts.html#index-8)
* [length](https://docs.soliditylang.org/en/latest/types.html#index-22)
* [**library**](https://docs.soliditylang.org/en/latest/contracts.html#index-27), [\[1\]](https://docs.soliditylang.org/en/latest/contracts.html#index-30), [\[2\]](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-13)
* [library-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.libraryDefinition)
* [**license**](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-0)
* [**linearization**](https://docs.soliditylang.org/en/latest/contracts.html#index-24)
* [**linker**](https://docs.soliditylang.org/en/latest/using-the-compiler.html#index-2)
* literal
 * [**address**](https://docs.soliditylang.org/en/latest/types.html#index-8), [\[1\]](https://docs.soliditylang.org/en/latest/types.html#index-35)
 * [**array**](https://docs.soliditylang.org/en/latest/types.html#index-21)
 * [**conversion**](https://docs.soliditylang.org/en/latest/types.html#index-33)
 * [**hexadecimal**](https://docs.soliditylang.org/en/latest/types.html#index-12), [\[1\]](https://docs.soliditylang.org/en/latest/types.html#index-34)
 * [hexadecimal number](https://docs.soliditylang.org/en/latest/types.html#index-33)
 * [**in Yul**](https://docs.soliditylang.org/en/latest/yul.html#index-1)
 * [**rational**](https://docs.soliditylang.org/en/latest/types.html#index-9), [\[1\]](https://docs.soliditylang.org/en/latest/types.html#index-33)
 * [**string**](https://docs.soliditylang.org/en/latest/types.html#index-10), [\[1\]](https://docs.soliditylang.org/en/latest/types.html#index-34)
 * [**unicode**](https://docs.soliditylang.org/en/latest/types.html#index-11)
* [literal (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.literal)
* [literal-with-sub-denomination (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.literalWithSubDenomination)
* [location](https://docs.soliditylang.org/en/latest/types.html#index-16)
* [log](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-14)
* [lvalue](https://docs.soliditylang.org/en/latest/types.html#index-29)
## M
* [**mapping**](https://docs.soliditylang.org/en/latest/types.html#index-26), [\[1\]](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#index-0), [\[2\]](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-1)
* [mapping-key-type (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.mappingKeyType)
* [mapping-type (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.mappingType)
* [**memory**](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-10), [\[1\]](https://docs.soliditylang.org/en/latest/types.html#index-16)
* [**message call**](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-12)
* [metadata](https://docs.soliditylang.org/en/latest/metadata.html#index-0)
* [**minutes**](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-2)
* [modifier-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.modifierDefinition)
* [modifier-invocation (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.modifierInvocation)
* [modifiers](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-11)
* [modular contract](https://docs.soliditylang.org/en/latest/solidity-by-example.html#index-3)
* [module](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-7)
* [msg](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-3)
 * [data](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-5)
 * [sender](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-5)
 * [sig](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-5)
 * [value](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-5)
* [mulmod](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-8)
## N
* [natspec](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-9)
* [**new**](https://docs.soliditylang.org/en/latest/control-structures.html#index-3), [\[1\]](https://docs.soliditylang.org/en/latest/types.html#index-20)
* [non-empty-string-literal (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer.NonEmptyStringLiteral)
* [number](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-3)
* [number-literal (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.numberLiteral)
## O
* [open auction](https://docs.soliditylang.org/en/latest/solidity-by-example.html#index-1)
* [**operator**](https://docs.soliditylang.org/en/latest/types.html#index-28)
 * [**precedence**](https://docs.soliditylang.org/en/latest/types.html#index-31), [\[1\]](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-0)
 * [**user-defined**](https://docs.soliditylang.org/en/latest/contracts.html#index-30)
* [optimiser](https://docs.soliditylang.org/en/latest/internals/optimizer.html#index-0)
* [optimizer](https://docs.soliditylang.org/en/latest/internals/optimizer.html#index-0)
* [origin](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-3)
* [**overload**](https://docs.soliditylang.org/en/latest/contracts.html#index-15)
* [override-specifier (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.overrideSpecifier)
* overriding
 * [**function**](https://docs.soliditylang.org/en/latest/contracts.html#index-20)
 * [**modifier**](https://docs.soliditylang.org/en/latest/contracts.html#index-21)
## P
* [packed](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-4)
* [**parameter**](https://docs.soliditylang.org/en/latest/control-structures.html#index-0)
 * [function](https://docs.soliditylang.org/en/latest/control-structures.html#index-0)
 * [input](https://docs.soliditylang.org/en/latest/control-structures.html#index-0)
 * [output](https://docs.soliditylang.org/en/latest/control-structures.html#index-0)
* [parameter-list (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.parameterList)
* [path (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.path)
* [payable](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-11)
* [pop](https://docs.soliditylang.org/en/latest/types.html#index-22)
* [**pragma**](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-1)
 * [**abicoder**](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-3)
 * [**ABIEncoderV2**](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-5), [\[1\]](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-3)
 * [**experimental**](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-4)
 * [**SMTChecker**](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-6)
 * [**version**](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-2)
* [pragma-token (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer.PragmaToken)
* [**precompiled contracts**](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-17)
* [**precompiles**](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-17)
* [prevrandao](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-3)
* [private](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-10), [\[1\]](https://docs.soliditylang.org/en/latest/contracts.html#index-3)
* [public](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-10), [\[1\]](https://docs.soliditylang.org/en/latest/contracts.html#index-3)
* [purchase](https://docs.soliditylang.org/en/latest/solidity-by-example.html#index-2)
* [pure](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-11)
* [**pure function**](https://docs.soliditylang.org/en/latest/contracts.html#index-12)
* [push](https://docs.soliditylang.org/en/latest/types.html#index-22)
## R
* [rational number](https://docs.soliditylang.org/en/latest/types.html#index-9)
* [**receive**](https://docs.soliditylang.org/en/latest/contracts.html#index-13)
* [**receive ether function**](https://docs.soliditylang.org/en/latest/contracts.html#index-13)
* [receive-function-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.receiveFunctionDefinition)
* [**reference type**](https://docs.soliditylang.org/en/latest/types.html#index-16)
* [**relative import**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-6)
* remapping
 * [**context**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-9)
 * [**import**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-9)
 * [**prefix**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-9)
 * [**target**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-9), [\[1\]](https://docs.soliditylang.org/en/latest/path-resolution.html#index-8)
* [Remix IDE](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-8), [\[1\]](https://docs.soliditylang.org/en/latest/path-resolution.html#index-10)
* [remote purchase](https://docs.soliditylang.org/en/latest/solidity-by-example.html#index-2)
* [**require**](https://docs.soliditylang.org/en/latest/control-structures.html#index-8), [\[1\]](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-6), [\[2\]](https://docs.soliditylang.org/en/latest/contracts.html#index-18), [\[3\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-7)
* [return](https://docs.soliditylang.org/en/latest/control-structures.html#index-0), [\[1\]](https://docs.soliditylang.org/en/latest/control-structures.html#index-1)
* [return array](https://docs.soliditylang.org/en/latest/contracts.html#index-10)
* [return string](https://docs.soliditylang.org/en/latest/contracts.html#index-10)
* [return struct](https://docs.soliditylang.org/en/latest/contracts.html#index-10)
* [return variable](https://docs.soliditylang.org/en/latest/control-structures.html#index-0)
* [return-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.returnStatement)
* [**revert**](https://docs.soliditylang.org/en/latest/control-structures.html#index-8), [\[1\]](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-6), [\[2\]](https://docs.soliditylang.org/en/latest/contracts.html#index-18), [\[3\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-7)
* [revert-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.revertStatement)
* [ripemd160](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-8)
* [runtimeCode](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-11)
## S
* [**safe math**](https://docs.soliditylang.org/en/latest/control-structures.html#index-7)
* [safemath](https://docs.soliditylang.org/en/latest/control-structures.html#index-7)
* [**scoping**](https://docs.soliditylang.org/en/latest/control-structures.html#index-6)
* [**seconds**](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-2)
* selector
 * [**of a function**](https://docs.soliditylang.org/en/latest/abi-spec.html#index-1), [\[1\]](https://docs.soliditylang.org/en/latest/assembly.html#index-1)
 * [**of a library function**](https://docs.soliditylang.org/en/latest/contracts.html#index-29)
 * [**of an error**](https://docs.soliditylang.org/en/latest/contracts.html#index-18), [\[1\]](https://docs.soliditylang.org/en/latest/abi-spec.html#index-2)
 * [**of an event**](https://docs.soliditylang.org/en/latest/contracts.html#index-17)
* [**selfdestruct**](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-16), [\[1\]](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-8), [\[2\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-10)
* [send](https://docs.soliditylang.org/en/latest/types.html#index-5), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-9)
* [sender](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-3)
* [set](https://docs.soliditylang.org/en/latest/contracts.html#index-28)
* [sha256](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-8)
* [signed-integer-type (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer.SignedIntegerType)
* [single-quoted-printable (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer.SingleQuotedPrintable)
* [**solc**](https://docs.soliditylang.org/en/latest/using-the-compiler.html#index-0)
* [SolidityLexer (Antlr4 lexer grammar)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer)
* [SolidityParser (Antlr4 parser grammar)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser)
* [source file](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-7)
* [source mappings](https://docs.soliditylang.org/en/latest/internals/source_mappings.html#index-0)
* [source unit](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-7)
* [**source unit name**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-0), [\[1\]](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-8)
* [source-unit (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.sourceUnit)
* [spdx](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-0)
* [**stack**](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-10)
* [standard input](https://docs.soliditylang.org/en/latest/path-resolution.html#index-3)
* [**standard JSON**](https://docs.soliditylang.org/en/latest/using-the-compiler.html#index-5), [\[1\]](https://docs.soliditylang.org/en/latest/path-resolution.html#index-2)
* [state machine](https://docs.soliditylang.org/en/latest/common-patterns.html#index-3)
* [state variable](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#index-0), [\[1\]](https://docs.soliditylang.org/en/latest/structure-of-a-contract.html#index-0)
* [state-mutability (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.stateMutability)
* [state-variable-declaration (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.stateVariableDeclaration)
* [statement (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.statement)
* [staticcall](https://docs.soliditylang.org/en/latest/types.html#index-5), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-9)
* [stdin](https://docs.soliditylang.org/en/latest/path-resolution.html#index-3)
* [**storage**](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-10), [\[1\]](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#index-0), [\[2\]](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-7), [\[3\]](https://docs.soliditylang.org/en/latest/types.html#index-16)
* [**storage layout specifier**](https://docs.soliditylang.org/en/latest/contracts.html#index-8)
* [**string**](https://docs.soliditylang.org/en/latest/types.html#index-18), [\[1\]](https://docs.soliditylang.org/en/latest/contracts.html#index-10), [\[2\]](https://docs.soliditylang.org/en/latest/types.html#index-10)
 * [concat](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-2)
* [string members](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-6)
* [**string-concat**](https://docs.soliditylang.org/en/latest/types.html#index-19)
* [string-literal (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.stringLiteral)
* [**struct**](https://docs.soliditylang.org/en/latest/types.html#index-25), [\[1\]](https://docs.soliditylang.org/en/latest/contracts.html#index-10), [\[2\]](https://docs.soliditylang.org/en/latest/structure-of-a-contract.html#index-0), [\[3\]](https://docs.soliditylang.org/en/latest/types.html#index-16)
* [struct-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.structDefinition)
* [struct-member (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.structMember)
* [style](https://docs.soliditylang.org/en/latest/style-guide.html#index-0)
* [sub-denomination (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer.SubDenomination)
* [**subcurrency**](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-0)
* [super](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-8), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-10)
* [switch](https://docs.soliditylang.org/en/latest/control-structures.html#index-1)
* [symbol-aliases (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.symbolAliases)
* [**szabo**](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-1)
## T
* [this](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-8), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-10)
* [**throw**](https://docs.soliditylang.org/en/latest/control-structures.html#index-8)
* [timestamp](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-3)
* [tload](https://docs.soliditylang.org/en/latest/contracts.html#index-6)
* [**transaction**](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-8), [\[1\]](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-4)
* [transfer](https://docs.soliditylang.org/en/latest/types.html#index-5), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-9)
* [**transient**](https://docs.soliditylang.org/en/latest/contracts.html#index-6)
* [**transient storage**](https://docs.soliditylang.org/en/latest/contracts.html#index-6), [**\[1\]**](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#index-10), [\[2\]](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#index-0)
* [**true**](https://docs.soliditylang.org/en/latest/types.html#index-2)
* [try-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.tryStatement)
* [tstore](https://docs.soliditylang.org/en/latest/contracts.html#index-6)
* [tuple-expression (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.tupleExpression)
* tx
 * [gasprice](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-5)
 * [origin](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-5)
* [type](https://docs.soliditylang.org/en/latest/types.html#index-0), [\[1\]](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-11)
 * [**contract**](https://docs.soliditylang.org/en/latest/types.html#index-6)
 * [**conversion**](https://docs.soliditylang.org/en/latest/types.html#index-32)
 * [creationCode](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-9)
 * [**function**](https://docs.soliditylang.org/en/latest/types.html#index-15)
 * [interfaceId](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-9)
 * [max](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-9)
 * [min](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-9)
 * [name](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-9)
 * [**reference**](https://docs.soliditylang.org/en/latest/types.html#index-16)
 * [runtimeCode](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-9)
 * [**struct**](https://docs.soliditylang.org/en/latest/types.html#index-25)
 * [**value**](https://docs.soliditylang.org/en/latest/types.html#index-1)
* [type-name (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.typeName)
## U
* [**ufixed**](https://docs.soliditylang.org/en/latest/types.html#index-4)
* [**uint**](https://docs.soliditylang.org/en/latest/types.html#index-3)
* [unchecked](https://docs.soliditylang.org/en/latest/control-structures.html#index-7)
* [unchecked-block (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.uncheckedBlock)
* [unicode-string-literal (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer.UnicodeStringLiteral), [\[1\]](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.unicodeStringLiteral)
* [unsigned-integer-type (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer.UnsignedIntegerType)
* [**UnusedStoreEliminator**](https://docs.soliditylang.org/en/latest/internals/optimizer.html#index-1)
* [**user defined value type**](https://docs.soliditylang.org/en/latest/types.html#index-14)
* [user-definable-operator (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.userDefinableOperator)
* [user-defined-value-type-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.userDefinedValueTypeDefinition)
* [**using for**](https://docs.soliditylang.org/en/latest/contracts.html#index-30), [\[1\]](https://docs.soliditylang.org/en/latest/contracts.html#index-28)
* [using-aliases (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.usingAliases)
* [using-directive (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.usingDirective)
## V
* [value](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-3)
* [**value type**](https://docs.soliditylang.org/en/latest/types.html#index-1)
* variable
 * [return](https://docs.soliditylang.org/en/latest/control-structures.html#index-0)
* [variable-declaration (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.variableDeclaration)
* [variable-declaration-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.variableDeclarationStatement)
* [variable-declaration-tuple (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.variableDeclarationTuple)
* [variably sized array](https://docs.soliditylang.org/en/latest/contracts.html#index-10)
* [**VFS**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-0)
* [view](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-11)
* [**view function**](https://docs.soliditylang.org/en/latest/contracts.html#index-11)
* [**virtual filesystem**](https://docs.soliditylang.org/en/latest/path-resolution.html#index-0), [\[1\]](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#index-8)
* [**visibility**](https://docs.soliditylang.org/en/latest/contracts.html#index-3), [\[1\]](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-10)
 * [(Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.visibility)
* [voting](https://docs.soliditylang.org/en/latest/solidity-by-example.html#index-0)
## W
* [**weeks**](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-2)
* [**wei**](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-1)
* [while](https://docs.soliditylang.org/en/latest/control-structures.html#index-1)
* [while-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.whileStatement)
* [withdrawal](https://docs.soliditylang.org/en/latest/common-patterns.html#index-0)
## Y
* [**years**](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#index-2)
* [**yul**](https://docs.soliditylang.org/en/latest/yul.html#index-0)
* [yul-assignment (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.yulAssignment)
* [yul-block (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.yulBlock)
* [yul-boolean (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.yulBoolean)
* [yul-decimal-number (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer.YulDecimalNumber)
* [yul-evm-builtin (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer.YulEVMBuiltin)
* [yul-expression (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.yulExpression)
* [yul-for-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.yulForStatement)
* [yul-function-call (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.yulFunctionCall)
* [yul-function-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.yulFunctionDefinition)
* [yul-hex-number (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer.YulHexNumber)
* [yul-identifier (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer.YulIdentifier)
* [yul-if-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.yulIfStatement)
* [yul-literal (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.yulLiteral)
* [yul-path (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.yulPath)
* [yul-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.yulStatement)
* [yul-string-literal (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityLexer.YulStringLiteral)
* [yul-switch-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.yulSwitchStatement)
* [yul-variable-declaration (Antlr4 production rule)](https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.yulVariableDeclaration)

# [Solidity IR-based Codegen Changes — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/ir-breaking-changes.html) 
 _https://docs.soliditylang.org/en/v0.8.30/ir-breaking-changes.html_

Solidity can generate EVM bytecode in two different ways: Either directly from Solidity to EVM opcodes (“old codegen”) or through an intermediate representation (“IR”) in Yul (“new codegen” or “IR-based codegen”).
The IR-based code generator was introduced with an aim to not only allow code generation to be more transparent and auditable but also to enable more powerful optimization passes that span across functions.
You can enable it on the command-line using `--via-ir` or with the option `{"viaIR": true}` in standard-json and we encourage everyone to try it out!
For several reasons, there are tiny semantic differences between the old and the IR-based code generator, mostly in areas where we would not expect people to rely on this behavior anyway. This section highlights the main differences between the old and the IR-based codegen.
## Semantic Only Changes[](#semantic-only-changes "Link to this heading")
This section lists the changes that are semantic-only, thus potentially hiding new and different behavior in existing code.
* The order of state variable initialization has changed in case of inheritance.
 
 The order used to be:
 
 * All state variables are zero-initialized at the beginning.
 
 * Evaluate base constructor arguments from most derived to most base contract.
 
 * Initialize all state variables in the whole inheritance hierarchy from most base to most derived.
 
 * Run the constructor, if present, for all contracts in the linearized hierarchy from most base to most derived.
 
 
 New order:
 
 * All state variables are zero-initialized at the beginning.
 
 * Evaluate base constructor arguments from most derived to most base contract.
 
 * For every contract in order from most base to most derived in the linearized hierarchy:
 
 > 1. Initialize state variables.
 > 
 > 2. Run the constructor (if present).
 > 
 
 
 This causes differences in contracts where the initial value of a state variable relies on the result of the constructor in another contract:
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjE7Cgpjb250cmFjdCBBIHsKICAgIHVpbnQgeDsKICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgIHggPSA0MjsKICAgIH0KICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgdmlldyByZXR1cm5zKHVpbnQyNTYpIHsKICAgICAgICByZXR1cm4geDsKICAgIH0KfQpjb250cmFjdCBCIGlzIEEgewogICAgdWludCBwdWJsaWMgeSA9IGYoKTsKfQ==)
 
 // SPDX-License-Identifier: GPL-3.0
 pragma solidity \>=0.7.1;
 
 contract A {
 uint x;
 constructor() {
 x \= 42;
 }
 function f() public view returns(uint256) {
 return x;
 }
 }
 contract B is A {
 uint public y \= f();
 }
 
 Previously, `y` would be set to 0. This is due to the fact that we would first initialize state variables: First, `x` is set to 0, and when initializing `y`, `f()` would return 0 causing `y` to be 0 as well. With the new rules, `y` will be set to 42. We first initialize `x` to 0, then call A’s constructor which sets `x` to 42. Finally, when initializing `y`, `f()` returns 42 causing `y` to be 42.
 
* When storage structs are deleted, every storage slot that contains a member of the struct is set to zero entirely. Formerly, padding space was left untouched. Consequently, if the padding space within a struct is used to store data (e.g. in the context of a contract upgrade), you have to be aware that `delete` will now also clear the added member (while it wouldn’t have been cleared in the past).
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjE7Cgpjb250cmFjdCBDIHsKICAgIHN0cnVjdCBTIHsKICAgICAgICB1aW50NjQgeTsKICAgICAgICB1aW50NjQgejsKICAgIH0KICAgIFMgczsKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIC8vIC4uLgogICAgICAgIGRlbGV0ZSBzOwogICAgICAgIC8vIHMgb2NjdXBpZXMgb25seSBmaXJzdCAxNiBieXRlcyBvZiB0aGUgMzIgYnl0ZXMgc2xvdAogICAgICAgIC8vIGRlbGV0ZSB3aWxsIHdyaXRlIHplcm8gdG8gdGhlIGZ1bGwgc2xvdAogICAgfQp9)
 
 // SPDX-License-Identifier: GPL-3.0
 pragma solidity \>=0.7.1;
 
 contract C {
 struct S {
 uint64 y;
 uint64 z;
 }
 S s;
 function f() public {
 // ...
 delete s;
 // s occupies only first 16 bytes of the 32 bytes slot
 // delete will write zero to the full slot
 }
 }
 
 We have the same behavior for implicit delete, for example when array of structs is shortened.
 
* Function modifiers are implemented in a slightly different way regarding function parameters and return variables. This especially has an effect if the placeholder `_;` is evaluated multiple times in a modifier. In the old code generator, each function parameter and return variable has a fixed slot on the stack. If the function is run multiple times because `_;` is used multiple times or used in a loop, then a change to the function parameter’s or return variable’s value is visible in the next execution of the function. The new code generator implements modifiers using actual functions and passes function parameters on. This means that multiple evaluations of a function’s body will get the same values for the parameters, and the effect on return variables is that they are reset to their default (zero) value for each execution.
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjA7CmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50IGEpIHB1YmxpYyBwdXJlIG1vZCgpIHJldHVybnMgKHVpbnQgcikgewogICAgICAgIHIgPSBhKys7CiAgICB9CiAgICBtb2RpZmllciBtb2QoKSB7IF87IF87IH0KfQ==)
 
 // SPDX-License-Identifier: GPL-3.0
 pragma solidity \>=0.7.0;
 contract C {
 function f(uint a) public pure mod() returns (uint r) {
 r \= a++;
 }
 modifier mod() { \_; \_; }
 }
 
 If you execute `f(0)` in the old code generator, it will return `1`, while it will return `0` when using the new code generator.
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBib29sIGFjdGl2ZSA9IHRydWU7CiAgICBtb2RpZmllciBtb2QoKQogICAgewogICAgICAgIF87CiAgICAgICAgYWN0aXZlID0gZmFsc2U7CiAgICAgICAgXzsKICAgIH0KICAgIGZ1bmN0aW9uIGZvbygpIGV4dGVybmFsIG1vZCgpIHJldHVybnMgKHVpbnQgcmV0KQogICAgewogICAgICAgIGlmIChhY3RpdmUpCiAgICAgICAgICAgIHJldCA9IDE7IC8vIFNhbWUgYXMgYGByZXR1cm4gMWBgCiAgICB9Cn0=)
 
 // SPDX-License-Identifier: GPL-3.0
 pragma solidity \>=0.7.1 <0.9.0;
 
 contract C {
 bool active \= true;
 modifier mod()
 {
 \_;
 active \= false;
 \_;
 }
 function foo() external mod() returns (uint ret)
 {
 if (active)
 ret \= 1; // Same as \`\`return 1\`\`
 }
 }
 
 The function `C.foo()` returns the following values:
 
 * Old code generator: `1` as the return variable is initialized to `0` only once before the first `_;` evaluation and then overwritten by the `return 1;`. It is not initialized again for the second `_;` evaluation and `foo()` does not explicitly assign it either (due to `active == false`), thus it keeps its first value.
 
 * New code generator: `0` as all parameters, including return parameters, will be re-initialized before each `_;` evaluation.
 
* For the old code generator, the evaluation order of expressions is unspecified. For the new code generator, we try to evaluate in source order (left to right), but do not guarantee it. This can lead to semantic differences.
 
 For example:
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjE7CmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gcHJlaW5jcl91OCh1aW50OCBhKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50OCkgewogICAgICAgIHJldHVybiArK2EgKyBhOwogICAgfQp9)
 
 // SPDX-License-Identifier: GPL-3.0
 pragma solidity \>=0.8.1;
 contract C {
 function preincr\_u8(uint8 a) public pure returns (uint8) {
 return ++a + a;
 }
 }
 
 The function `preincr_u8(1)` returns the following values:
 
 * Old code generator: `3` (`1 + 2`) but the return value is unspecified in general
 
 * New code generator: `4` (`2 + 2`) but the return value is not guaranteed
 
 
 On the other hand, function argument expressions are evaluated in the same order by both code generators with the exception of the global functions `addmod` and `mulmod`. For example:
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjE7CmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gYWRkKHVpbnQ4IGEsIHVpbnQ4IGIpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQ4KSB7CiAgICAgICAgcmV0dXJuIGEgKyBiOwogICAgfQogICAgZnVuY3Rpb24gZyh1aW50OCBhLCB1aW50OCBiKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50OCkgewogICAgICAgIHJldHVybiBhZGQoKythICsgKytiLCBhICsgYik7CiAgICB9Cn0=)
 
 // SPDX-License-Identifier: GPL-3.0
 pragma solidity \>=0.8.1;
 contract C {
 function add(uint8 a, uint8 b) public pure returns (uint8) {
 return a + b;
 }
 function g(uint8 a, uint8 b) public pure returns (uint8) {
 return add(++a + ++b, a + b);
 }
 }
 
 The function `g(1, 2)` returns the following values:
 
 * Old code generator: `10` (`add(2 + 3, 2 + 3)`) but the return value is unspecified in general
 
 * New code generator: `10` but the return value is not guaranteed
 
 
 The arguments to the global functions `addmod` and `mulmod` are evaluated right-to-left by the old code generator and left-to-right by the new code generator. For example:
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjE7CmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQyNTYgYU1vZCwgdWludDI1NiBtTW9kKSB7CiAgICAgICAgdWludDI1NiB4ID0gMzsKICAgICAgICAvLyBPbGQgY29kZSBnZW46IGFkZC9tdWxtb2QoNSwgNCwgMykKICAgICAgICAvLyBOZXcgY29kZSBnZW46IGFkZC9tdWxtb2QoNCwgNSwgNSkKICAgICAgICBhTW9kID0gYWRkbW9kKCsreCwgKyt4LCB4KTsKICAgICAgICBtTW9kID0gbXVsbW9kKCsreCwgKyt4LCB4KTsKICAgIH0KfQ==)
 
 // SPDX-License-Identifier: GPL-3.0
 pragma solidity \>=0.8.1;
 contract C {
 function f() public pure returns (uint256 aMod, uint256 mMod) {
 uint256 x \= 3;
 // Old code gen: add/mulmod(5, 4, 3)
 // New code gen: add/mulmod(4, 5, 5)
 aMod \= addmod(++x, ++x, x);
 mMod \= mulmod(++x, ++x, x);
 }
 }
 
 The function `f()` returns the following values:
 
 * Old code generator: `aMod = 0` and `mMod = 2`
 
 * New code generator: `aMod = 4` and `mMod = 0`
 
* The new code generator imposes a hard limit of `type(uint64).max` (`0xffffffffffffffff`) for the free memory pointer. Allocations that would increase its value beyond this limit revert. The old code generator does not have this limit.
 
 For example:
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID4wLjguMDsKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKCkgcHVibGljIHsKICAgICAgICB1aW50W10gbWVtb3J5IGFycjsKICAgICAgICAvLyBhbGxvY2F0aW9uIHNpemU6IDU3NjQ2MDc1MjMwMzQyMzQ4MQogICAgICAgIC8vIGFzc3VtZXMgZnJlZU1lbVB0ciBwb2ludHMgdG8gMHg4MCBpbml0aWFsbHkKICAgICAgICB1aW50IHNvbFl1bE1heEFsbG9jYXRpb25CZWZvcmVNZW1QdHJPdmVyZmxvdyA9ICh0eXBlKHVpbnQ2NCkubWF4IC0gMHg4MCAtIDMxKSAvIDMyOwogICAgICAgIC8vIGZyZWVNZW1QdHIgb3ZlcmZsb3dzIFVJTlQ2NF9NQVgKICAgICAgICBhcnIgPSBuZXcgdWludFtdKHNvbFl1bE1heEFsbG9jYXRpb25CZWZvcmVNZW1QdHJPdmVyZmxvdyk7CiAgICB9Cn0=)
 
 // SPDX-License-Identifier: GPL-3.0
 pragma solidity \>0.8.0;
 contract C {
 function f() public {
 uint\[\] memory arr;
 // allocation size: 576460752303423481
 // assumes freeMemPtr points to 0x80 initially
 uint solYulMaxAllocationBeforeMemPtrOverflow \= (type(uint64).max \- 0x80 \- 31) / 32;
 // freeMemPtr overflows UINT64\_MAX
 arr \= new uint\[\](solYulMaxAllocationBeforeMemPtrOverflow);
 }
 }
 
 The function `f()` behaves as follows:
 
 * Old code generator: runs out of gas while zeroing the array contents after the large memory allocation
 
 * New code generator: reverts due to free memory pointer overflow (does not run out of gas)
 
## Internals[](#internals "Link to this heading")
### Internal function pointers[](#internal-function-pointers "Link to this heading")
The old code generator uses code offsets or tags for values of internal function pointers. This is especially complicated since these offsets are different at construction time and after deployment and the values can cross this border via storage. Because of that, both offsets are encoded at construction time into the same value (into different bytes).
In the new code generator, function pointers use internal IDs that are allocated in sequence. Since calls via jumps are not possible, calls through function pointers always have to use an internal dispatch function that uses the `switch` statement to select the right function.
The ID `0` is reserved for uninitialized function pointers which then cause a panic in the dispatch function when called.
In the old code generator, internal function pointers are initialized with a special function that always causes a panic. This causes a storage write at construction time for internal function pointers in storage.
Note
The compiler is free to omit internal functions that are never explicitly referenced by name. As a consequence, assigning to a function type variable in inline assembly does not guarantee that the assigned value will be included in the internal dispatch. The function must also be explicitly referenced elsewhere in the code.
### Cleanup[](#cleanup "Link to this heading")
The old code generator only performs cleanup before an operation whose result could be affected by the values of the dirty bits. The new code generator performs cleanup after any operation that can result in dirty bits. The hope is that the optimizer will be powerful enough to eliminate redundant cleanup operations.
For example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjE7CmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50OCBhKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IHIxLCB1aW50IHIyKQogICAgewogICAgICAgIGEgPSB+YTsKICAgICAgICBhc3NlbWJseSB7CiAgICAgICAgICAgIHIxIDo9IGEKICAgICAgICB9CiAgICAgICAgcjIgPSBhOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.1;
contract C {
 function f(uint8 a) public pure returns (uint r1, uint r2)
 {
 a \= ~a;
 assembly {
 r1 := a
 }
 r2 \= a;
 }
}
The function `f(1)` returns the following values:
* Old code generator: (`fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe`, `00000000000000000000000000000000000000000000000000000000000000fe`)
 
* New code generator: (`00000000000000000000000000000000000000000000000000000000000000fe`, `00000000000000000000000000000000000000000000000000000000000000fe`)
 
Note that, unlike the new code generator, the old code generator does not perform a cleanup after the bit-not assignment (`a = ~a`). This results in different values being assigned (within the inline assembly block) to return value `r1` between the old and new code generators. However, both code generators perform a cleanup before the new value of `a` is assigned to `r2`.

# [NatSpec Formatı — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/natspec-format.html) 
 _https://docs.soliditylang.org/tr/latest/natspec-format.html_

Solidity sözleşmeleri, fonksiyonlar, dönüş değişkenleri ve daha fazlası için zengin dokümantasyon sağlamak üzere özel bir yorum biçimi kullanabilir. Bu özel form Ethereum Doğal Dil Belirtim Formatı( Ethereum Natural Language Specification Format) (NatSpec) olarak adlandırılır.
Not
NatSpec, [Doxygen](https://en.wikipedia.org/wiki/Doxygen)’den esinlenmiştir. Doxygen tarzı yorumlar ve etiketler kullansa da, Doxygen ile olan sıkı uyumluluğunu sürdürme niyeti yoktur. Lütfen aşağıda listelenen desteklenmiş etiketleri dikkatlice inceleyin.
Bu dokümantasyon, geliştirici odaklı mesajlar ve son kullanıcıya yönelik mesajlar olarak bölümlere ayrılmıştır. Bu mesajlar son kullanıcıya (insan) sözleşme ile etkileşime gireceği (örneğin bir işlem imzalayacağı) zaman gösterilebilir.
Solidity sözleşmelerinin tüm genel arayüzler (ABI’deki her şey) için NatSpec kullanılarak tamamen açıklanması önerilir.
NatSpec, akıllı sözleşme yazarının kullanacağı ve Solidity derleyicisi tarafından anlaşılan yorumlar için biçimlendirme içerir. Ayrıca bu yorumları makine tarafından okunabilir bir biçime dönüştüren Solidity derleyicisinin çıktısı da aşağıda detaylı olarak açıklanmıştır.
NatSpec, üçüncü taraf araçlar tarafından kullanılan ek açıklamaları da içerebilir. Bunlar büyük olasılıkla `@custom:<name>` etiketi aracılığıyla gerçekleştirilir ve iyi bir kullanım örneği analiz ve doğrulama araçlarıdır.
## Dokümantasyon Örneği[](#dokumantasyon-ornegi "Permalink to this heading")
Dokümantasyon, Doxygen notasyon formatı kullanılarak her `contract` , `interface` , `library` , `function` ve `event` üzerine eklenir. Bir `public` durum değişkeni, NatSpec’in kullanım amaçları doğrultusunda bir `fonksiyon` a eşdeğerdir.
* Solidity için tek veya çok satırlı yorumlar için `//` veya `/**` ve `*/` ile sonlandırmayı tercih edebilirsiniz.
 
* Vyper için, iç içeriğe yalın yorumlarla girintili `"""` kullanın. Vyper belgelerine <[https://vyper.readthedocs.io/en/latest/natspec.html](https://vyper.readthedocs.io/en/latest/natspec.html)\>\`\_\_ bakınız.
 
Aşağıdaki örnekte, mevcut tüm etiketler kullanılarak bir sözleşme ve bir fonksiyon gösterilmektedir.
Not
Solidity derleyicisi, etiketleri yalnızca external veya public olmaları durumunda yorumlamaktadır. Internal ve private fonksiyonlarınız için benzer yorumlar kullanabilirsiniz, ancak bunlar çözümlenmeyecektir.
Bu özellik belki gelecekte değişebilir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjIgPCAwLjkuMDsKCi8vLyBAdGl0bGUgQcSfYcOnbGFyIGnDp2luIGJpciBzaW3DvGxhdMO2cgovLy8gQGF1dGhvciBMYXJyeSBBLiBHYXJkbmVyCi8vLyBAbm90aWNlIEJ1IHPDtnpsZcWfbWV5aSB5YWxuxLF6Y2EgZW4gc2FkZSBzaW11bGFzeW9ubGFyIGnDp2luIGt1bGxhbmFiaWxpcnNpbml6Ci8vLyBAZGV2IFTDvG0gZm9ua3NpeW9uIMOnYcSfcsSxbGFyxLEgxZ91IGFuZGEgeWFuIGV0a2lsZXIgb2xtYWRhbiB1eWd1bGFubWFrdGFkxLFyCi8vLyBAY3VzdG9tOmV4cGVyaW1lbnRhbCBCdSBkZW5leXNlbCBiaXIgc8O2emxlxZ9tZWRpci4KY29udHJhY3QgVHJlZSB7CiAgICAvLy8gQG5vdGljZSBDYW5sxLEgYcSfYcOnbGFyIGnDp2luIGHEn2HDpyB5YcWfxLFuxLEgecSxbCBvbGFyYWsgaGVzYXBsYXnEsW4sIMO8c3Qgc2F5xLF5YSB5dXZhcmxhecSxbgogICAgLy8vIEBkZXYgQWxleGFuZHIgTi4gVGV0ZWFyaW5nIGFsZ29yaXRtYXPEsSBkb8SfcnVsdcSfdSBhcnTEsXJhYmlsaXIKICAgIC8vLyBAcGFyYW0gcmluZ3MgRGVuZHJva3Jvbm9sb2ppayDDtnJuZWt0ZW4gZWxkZSBlZGlsZW4gaGFsa2Egc2F5xLFzxLEKICAgIC8vLyBAcmV0dXJuIFnEsWwgY2luc2luZGVuIHlhxZ8sIGvEsXNtaSB5xLFsbGFyIGnDp2luIHl1dmFybGFuxLFyCiAgICBmdW5jdGlvbiBhZ2UodWludDI1NiByaW5ncykgZXh0ZXJuYWwgdmlydHVhbCBwdXJlIHJldHVybnMgKHVpbnQyNTYpIHsKICAgICAgICByZXR1cm4gcmluZ3MgKyAxOwogICAgfQoKICAgIC8vLyBAbm90aWNlIEHEn2FjxLFuIHNhaGlwIG9sZHXEn3UgeWFwcmFrIG1pa3RhcsSxbsSxIGTDtm5kw7xyw7xyLgogICAgLy8vIEBkZXYgWWFsbsSxemNhIHNhYml0IGJpciBzYXnEsSBkw7ZuZMO8csO8ci4KICAgIGZ1bmN0aW9uIGxlYXZlcygpIGV4dGVybmFsIHZpcnR1YWwgcHVyZSByZXR1cm5zKHVpbnQyNTYpIHsKICAgICAgICByZXR1cm4gMjsKICAgIH0KfQoKY29udHJhY3QgUGxhbnQgewogICAgZnVuY3Rpb24gbGVhdmVzKCkgZXh0ZXJuYWwgdmlydHVhbCBwdXJlIHJldHVybnModWludDI1NikgewogICAgICAgIHJldHVybiAzOwogICAgfQp9Cgpjb250cmFjdCBLdW1xdWF0VHJlZSBpcyBUcmVlLCBQbGFudCB7CiAgICBmdW5jdGlvbiBhZ2UodWludDI1NiByaW5ncykgZXh0ZXJuYWwgb3ZlcnJpZGUgcHVyZSByZXR1cm5zICh1aW50MjU2KSB7CiAgICAgICAgcmV0dXJuIHJpbmdzICsgMjsKICAgIH0KCiAgICAvLy8gQnUgc3Blc2lmaWsgYcSfYcOnIHTDvHLDvG7DvG4gc2FoaXAgb2xkdcSfdSB5YXByYWsgbWlrdGFyxLFuxLEgZMO2bmTDvHLDvHIKICAgIC8vLyBAaW5oZXJpdGRvYyBUcmVlCiAgICBmdW5jdGlvbiBsZWF2ZXMoKSBleHRlcm5hbCBvdmVycmlkZShUcmVlLCBQbGFudCkgcHVyZSByZXR1cm5zKHVpbnQyNTYpIHsKICAgICAgICByZXR1cm4gMzsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.2 < 0.9.0;
/// @title Ağaçlar için bir simülatör
/// @author Larry A. Gardner
/// @notice Bu sözleşmeyi yalnızca en sade simulasyonlar için kullanabilirsiniz
/// @dev Tüm fonksiyon çağrıları şu anda yan etkiler olmadan uygulanmaktadır
/// @custom:experimental Bu deneysel bir sözleşmedir.
contract Tree {
 /// @notice Canlı ağaçlar için ağaç yaşını yıl olarak hesaplayın, üst sayıya yuvarlayın
 /// @dev Alexandr N. Tetearing algoritması doğruluğu artırabilir
 /// @param rings Dendrokronolojik örnekten elde edilen halka sayısı
 /// @return Yıl cinsinden yaş, kısmi yıllar için yuvarlanır
 function age(uint256 rings) external virtual pure returns (uint256) {
 return rings + 1;
 }
 /// @notice Ağacın sahip olduğu yaprak miktarını döndürür.
 /// @dev Yalnızca sabit bir sayı döndürür.
 function leaves() external virtual pure returns(uint256) {
 return 2;
 }
}
contract Plant {
 function leaves() external virtual pure returns(uint256) {
 return 3;
 }
}
contract KumquatTree is Tree, Plant {
 function age(uint256 rings) external override pure returns (uint256) {
 return rings + 2;
 }
 /// Bu spesifik ağaç türünün sahip olduğu yaprak miktarını döndürür
 /// @inheritdoc Tree
 function leaves() external override(Tree, Plant) pure returns(uint256) {
 return 3;
 }
}
## Tags[](#tags "Permalink to this heading")
Tüm etiketler opsiyoneldir. Aşağıdaki tabloda her bir NatSpec etiketinin amacı ve nerede kullanılabileceği açıklanmaktadır. Özel bir durum olarak, hiçbir etiket kullanılmazsa Solidity derleyicisi bir `///` veya `/**` yorumunu `@notice` ile etiketlenmiş gibi yorumlayacaktır.
Etiket
Bağlam
`@title`
Sözleşmeyi/arayüzü tanımlaması gereken bir başlık
contract, library, interface
`@author`
Yazarın adı
contract, library, interface
`@notice`
Son kullanıcıya bunun ne işe yaradığını açıklayın
contract, library, interface, function, public state variable, event
`@dev`
Bir geliştiriciye ekstra ayrıntıları açıklayın
contract, library, interface, function, state variable, event
`@param`
Tıpkı Doxygen’de olduğu gibi bir parametreyi belgeler (parametre adının ardından gelmelidir)
function, event
`@return`
Bir sözleşmenin fonksiyonunun dönüş değişkenlerini belgeler
function, public state variable
`@inheritdoc`
Temel fonksiyondaki tüm eksik etiketleri kopyalar (ardından sözleşme adı gelmelidir)
function, public state variable
`@custom:...`
Özel etiket, semantiği uygulama tanımlıdır
everywhere
Fonksiyonunuz `(int quotient, int remainder)` gibi birden fazla değer döndürüyorsa, `@param` ifadeleriyle aynı formatta birden fazla `@return` ifadesi kullanın.
Özel etiketler `@custom:` ile başlar ve ardından bir veya daha fazla küçük harf veya kısa çizgi gelmelidir. Ancak kısa çizgi ile başlayamaz. Her yerde kullanılabilirler ve geliştirici belgelerinin bir parçasıdırlar.
### Dinamik İfade Biçimleri[](#dinamik-ifade-bicimleri "Permalink to this heading")
Solidity derleyicisi, NatSpec belgelerini Solidity kaynak kodunuzdan bu kılavuzda açıklandığı gibi JSON çıktısına aktaracaktır. Bu JSON çıktısının kullanıcısı, örneğin son kullanıcı istemci yazılımı, bunu son kullanıcıya doğrudan sunabilir veya bazı ön işlemler uygulayabilir.
Örneğin, bazı istemci yazılımları render edecektir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8vIEBub3RpY2UgVGhpcyBmdW5jdGlvbiB3aWxsIG11bHRpcGx5IGBhYCBieSA3)
/// @notice This function will multiply \`a\` by 7
son kullanıcıya:
This function will multiply 10 by 7
eğer bir fonksiyon çağrılıyorsa ve `a` girdisine 10 değeri atanmışsa.
Bu dinamik ifadelerin belirtilmesi Solidity dokümantasyonunun kapsamı dışındadır ve bu konuda daha fazla bilgiyi [the radspec project](https://github.com/aragon/radspec) adresinden edinebilirsiniz.
### Kalıtım Notları[](#kalitim-notlari "Permalink to this heading")
NatSpec içermeyen fonksiyonlar otomatik olarak temel fonksiyonlarının dokümantasyonunu devralacaktır. Bununla ilgili istisnalar şunlardır:
* Parametre adları farklı olduğunda.
 
* Birden fazla temel fonksiyon olduğunda.
 
* Kalıtım için hangi sözleşmenin kullanılması gerektiğini belirten açık bir `@inheritdoc` etiketi olduğunda.
 
## Dokümantasyon Çıktısı[](#dokumantasyon-ciktisi "Permalink to this heading")
Derleyici tarafından çözümlendiğinde, yukarıdaki örnekteki gibi belgeler iki farklı JSON dosyası üretecektir. Biri son kullanıcı tarafından bir fonksiyon çalıştırıldığında bildirim olarak tüketilmek üzere, diğeri ise geliştirici tarafından kullanılmak üzere tasarlanmıştır.
Yukarıdaki sözleşme `ex1.sol` olarak kaydedilirse, belgeleri kullanarak oluşturabilirsiniz:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=c29sYyAtLXVzZXJkb2MgLS1kZXZkb2MgZXgxLnNvbA==)
solc \--userdoc \--devdoc ex1.sol
Çıktı aşağıda verilmiştir.
Not
Solidity 0.6.11 sürümünden itibaren NatSpec çıktısı ayrıca bir `version` ve bir `kind` alanı içerir. Şu anda `version` `1` olarak ayarlanmıştır ve `kind` `user` veya `dev` alanlarından biri olmalıdır. Gelecekte, eski sürümleri kullanımdan kaldırarak yeni sürümlerin tanıtılması mümkündür.
### Kullanıcı Dokümantasyonu[](#kullanici-dokumantasyonu "Permalink to this heading")
Yukarıdaki dokümantasyon çıktı olarak aşağıdaki kullanıcı dokümantasyonu JSON dosyasını üretecektir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=ewogICJ2ZXJzaW9uIiA6IDEsCiAgImtpbmQiIDogInVzZXIiLAogICJtZXRob2RzIiA6CiAgewogICAgImFnZSh1aW50MjU2KSIgOgogICAgewogICAgICAibm90aWNlIiA6ICJDYWxjdWxhdGUgdHJlZSBhZ2UgaW4geWVhcnMsIHJvdW5kZWQgdXAsIGZvciBsaXZlIHRyZWVzIgogICAgfQogIH0sCiAgIm5vdGljZSIgOiAiWW91IGNhbiB1c2UgdGhpcyBjb250cmFjdCBmb3Igb25seSB0aGUgbW9zdCBiYXNpYyBzaW11bGF0aW9uIgp9)
{
 "version" : 1,
 "kind" : "user",
 "methods" :
 {
 "age(uint256)" :
 {
 "notice" : "Calculate tree age in years, rounded up, for live trees"
 }
 },
 "notice" : "You can use this contract for only the most basic simulation"
}
Metodları bulmak için anahtarın sadece fonksiyonun adı değil, [Contract ABI](https://docs.soliditylang.org/tr/latest/abi-spec.html#abi-function-selector) da tanımlandığı gibi fonksiyonun kanonik imzası olduğunu unutmayın.
### Geliştirici Dokümantasyonu[](#gelistirici-dokumantasyonu "Permalink to this heading")
Kullanıcı dokümantasyon dosyasının yanı sıra, bir geliştirici dokümantasyon JSON dosyası da üretilmeli ve aşağıdaki gibi görünmelidir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=ewogICJ2ZXJzaW9uIiA6IDEsCiAgImtpbmQiIDogImRldiIsCiAgImF1dGhvciIgOiAiTGFycnkgQS4gR2FyZG5lciIsCiAgImRldGFpbHMiIDogIkFsbCBmdW5jdGlvbiBjYWxscyBhcmUgY3VycmVudGx5IGltcGxlbWVudGVkIHdpdGhvdXQgc2lkZSBlZmZlY3RzIiwKICAiY3VzdG9tOmV4cGVyaW1lbnRhbCIgOiAiVGhpcyBpcyBhbiBleHBlcmltZW50YWwgY29udHJhY3QuIiwKICAibWV0aG9kcyIgOgogIHsKICAgICJhZ2UodWludDI1NikiIDoKICAgIHsKICAgICAgImRldGFpbHMiIDogIlRoZSBBbGV4YW5kciBOLiBUZXRlYXJpbmcgYWxnb3JpdGhtIGNvdWxkIGluY3JlYXNlIHByZWNpc2lvbiIsCiAgICAgICJwYXJhbXMiIDoKICAgICAgewogICAgICAgICJyaW5ncyIgOiAiVGhlIG51bWJlciBvZiByaW5ncyBmcm9tIGRlbmRyb2Nocm9ub2xvZ2ljYWwgc2FtcGxlIgogICAgICB9LAogICAgICAicmV0dXJuIiA6ICJhZ2UgaW4geWVhcnMsIHJvdW5kZWQgdXAgZm9yIHBhcnRpYWwgeWVhcnMiCiAgICB9CiAgfSwKICAidGl0bGUiIDogIkEgc2ltdWxhdG9yIGZvciB0cmVlcyIKfQ==)
{
 "version" : 1,
 "kind" : "dev",
 "author" : "Larry A. Gardner",
 "details" : "All function calls are currently implemented without side effects",
 "custom:experimental" : "This is an experimental contract.",
 "methods" :
 {
 "age(uint256)" :
 {
 "details" : "The Alexandr N. Tetearing algorithm could increase precision",
 "params" :
 {
 "rings" : "The number of rings from dendrochronological sample"
 },
 "return" : "age in years, rounded up for partial years"
 }
 },
 "title" : "A simulator for trees"
}

# [Structure of a Contract — Solidity 0.4.26 documentation](https://docs.soliditylang.org/en/v0.4.26/structure-of-a-contract.html) 
 _https://docs.soliditylang.org/en/v0.4.26/structure-of-a-contract.html_

Contracts in Solidity are similar to classes in object-oriented languages. Each contract can contain declarations of [State Variables](#structure-state-variables), [Functions](#structure-functions), [Function Modifiers](#structure-function-modifiers), [Events](#structure-events), [Struct Types](#structure-struct-types) and [Enum Types](#structure-enum-types). Furthermore, contracts can inherit from other contracts.
## State Variables[¶](#state-variables "Permalink to this headline")
State variables are values which are permanently stored in contract storage.
pragma solidity ^0.4.0;
contract SimpleStorage {
 uint storedData; // State variable
 // ...
}
See the [Types](https://docs.soliditylang.org/en/v0.4.26/types.html#types) section for valid state variable types and [Visibility and Getters](https://docs.soliditylang.org/en/v0.4.26/contracts.html#visibility-and-getters) for possible choices for visibility.
## Functions[¶](#functions "Permalink to this headline")
Functions are the executable units of code within a contract.
pragma solidity ^0.4.0;
contract SimpleAuction {
 function bid() public payable { // Function
 // ...
 }
}
[Function Calls](https://docs.soliditylang.org/en/v0.4.26/control-structures.html#function-calls) can happen internally or externally and have different levels of visibility ([Visibility and Getters](https://docs.soliditylang.org/en/v0.4.26/contracts.html#visibility-and-getters)) towards other contracts.
## Function Modifiers[¶](#function-modifiers "Permalink to this headline")
Function modifiers can be used to amend the semantics of functions in a declarative way (see [Function Modifiers](https://docs.soliditylang.org/en/v0.4.26/contracts.html#modifiers) in contracts section).
pragma solidity ^0.4.22;
contract Purchase {
 address public seller;
 modifier onlySeller() { // Modifier
 require(
 msg.sender \== seller,
 "Only seller can call this."
 );
 \_;
 }
 function abort() public onlySeller { // Modifier usage
 // ...
 }
}
## Events[¶](#events "Permalink to this headline")
Events are convenience interfaces with the EVM logging facilities.
pragma solidity ^0.4.21;
contract SimpleAuction {
 event HighestBidIncreased(address bidder, uint amount); // Event
 function bid() public payable {
 // ...
 emit HighestBidIncreased(msg.sender, msg.value); // Triggering event
 }
}
See [Events](https://docs.soliditylang.org/en/v0.4.26/contracts.html#events) in contracts section for information on how events are declared and can be used from within a dapp.
## Struct Types[¶](#struct-types "Permalink to this headline")
Structs are custom defined types that can group several variables (see [Structs](https://docs.soliditylang.org/en/v0.4.26/types.html#structs) in types section).
pragma solidity ^0.4.0;
contract Ballot {
 struct Voter { // Struct
 uint weight;
 bool voted;
 address delegate;
 uint vote;
 }
}
## Enum Types[¶](#enum-types "Permalink to this headline")
Enums can be used to create custom types with a finite set of ‘constant values’ (see [Enums](https://docs.soliditylang.org/en/v0.4.26/types.html#enums) in types section).
pragma solidity ^0.4.0;
contract Purchase {
 enum State { Created, Locked, Inactive } // Enum
}

# [Ressources — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/resources.html) 
 _https://docs.soliditylang.org/fr/latest/resources.html_

[Solidity](https://docs.soliditylang.org/fr/latest/index.html)
## Ressources générales[](#ressources-generales "Lien permanent vers cette rubrique")
* [Ethereum.org Developer Portal](https://ethereum.org/en/developers/)
 
* [Ethereum StackExchange](https://ethereum.stackexchange.com/)
 
* [Solidity Portal](https://soliditylang.org/)
 
* [Solidity Changelog](https://github.com/ethereum/solidity/blob/develop/Changelog.md)
 
* [Solidity Source Code sur GitHub](https://github.com/ethereum/solidity/)
 
* [Solidity Chat des utilisateurs de langues](https://matrix.to/#/#ethereum_solidity:gitter.im)
 
* [Solidity Chat des développeurs de compilateurs](https://matrix.to/#/#ethereum_solidity-dev:gitter.im)
 
* [Awesome Solidity](https://github.com/bkrem/awesome-solidity)
 
* [Solidity par Example](https://solidity-by-example.org/)
 
## Environnements de développement intégrés (Ethereum)[](#environnements-de-developpement-integres-ethereum "Lien permanent vers cette rubrique")
> * [Brownie](https://eth-brownie.readthedocs.io/en/stable/)
> 
> Cadre de développement et de test basé sur Python pour les contrats intelligents ciblant la machine virtuelle Ethereum.
> 
> * [Dapp](https://dapp.tools/)
> 
> Outil pour construire, tester et déployer des contrats intelligents à partir de la ligne de commande.
> 
> * [Embark](https://framework.embarklabs.io/)
> 
> Plateforme de développeurs pour la création et le déploiement d’applications décentralisées.
> 
> * [Hardhat](https://hardhat.org/)
> 
> Environnement de développement Ethereum avec réseau Ethereum local, fonctions de débogage et écosystème de plugins.
> 
> * [Remix](https://remix.ethereum.org/)
> 
> IDE basé sur un navigateur avec compilateur intégré et environnement d’exécution Solidity sans composants côté serveur.
> 
> * [Scaffold-ETH](https://github.com/austintgriffith/scaffold-eth)
> 
> Pile de développement Ethereum axée sur des itérations rapides du produit.
> 
> * [Truffle](https://www.trufflesuite.com/truffle)
> 
> Cadre de développement Ethereum.
> 
## Intégrations de l’éditeur[](#integrations-de-l-editeur "Lien permanent vers cette rubrique")
* Atom
 
 > * [Etheratom](https://github.com/0mkara/etheratom)
 > 
 > Plugin pour l’éditeur Atom qui propose la coloration syntaxique, la compilation et un environnement d’exécution (compatible avec les nœuds Backend et VM).
 > 
 > * [Atom Solidity Linter](https://atom.io/packages/linter-solidity)
 > 
 > Plugin pour l’éditeur Atom qui fournit le linting Solidity.
 > 
 > * [Atom Solium Linter](https://atom.io/packages/linter-solium)
 > 
 > Linter Solidity configurable pour Atom utilisant Solium (maintenant Ethlint) comme base.
 > 
 
* Emacs
 
 > * [Emacs Solidity](https://github.com/ethereum/emacs-solidity/)
 > 
 > Plugin pour l’éditeur Emacs fournissant la coloration syntaxique et le signalement des erreurs de compilation.
 > 
 
* IntelliJ
 
 > * [IntelliJ IDEA plugin](https://plugins.jetbrains.com/plugin/9475-intellij-solidity)
 > 
 > Plugin Solidity pour IntelliJ IDEA (et tous les autres IDE de JetBrains)
 > 
 
* Sublime
 
 > * [Package for SublimeText - Solidity language syntax](https://packagecontrol.io/packages/Ethereum/)
 > 
 > Coloration syntaxique Solidity pour l’éditeur SublimeText.
 > 
 
* Vim
 
 > * [Vim Solidity](https://github.com/tomlion/vim-solidity/)
 > 
 > Plugin pour l’éditeur Vim fournissant une coloration syntaxique.
 > 
 > * [Vim Syntastic](https://github.com/vim-syntastic/syntastic)
 > 
 > Plugin pour l’éditeur Vim permettant de vérifier la compilation.
 > 
 
* Visual Studio Code
 
 > * [Visual Studio Code extension](https://juan.blanco.ws/solidity-contracts-in-visual-studio-code/)
 > 
 > Plugin Solidity pour Microsoft Visual Studio Code qui comprend la coloration syntaxique et le compilateur Solidity.
 > 
 
## Outils Solidity[](#outils-solidity "Lien permanent vers cette rubrique")
* [ABI to Solidity interface converter](https://gist.github.com/chriseth/8f533d133fa0c15b0d6eaf3ec502c82b)
 
 Un script pour générer des interfaces de contrat à partir de l’ABI d’un contrat intelligent.
 
* [abi-to-sol](https://github.com/gnidan/abi-to-sol)
 
 Outil permettant de générer une source d’interface Solidity à partir d’un JSON ABI donné.
 
* [Doxity](https://github.com/DigixGlobal/doxity)
 
 Générateur de documentation pour Solidity.
 
* [Ethlint](https://github.com/duaraghav8/Ethlint)
 
 Linter pour identifier et corriger les problèmes de style et de sécurité dans Solidity.
 
* [evmdis](https://github.com/Arachnid/evmdis)
 
 EVM Disassembler qui effectue une analyse statique sur le bytecode pour fournir un niveau d’abstraction plus élevé que les opérations EVM brutes.
 
* [EVM Lab](https://github.com/ethereum/evmlab/)
 
 Ensemble d’outils riches pour interagir avec l’EVM. Comprend une VM, une API Etherchain et un visualiseur de traces avec affichage du coût du gaz.
 
* [hevm](https://github.com/dapphub/dapptools/tree/master/src/hevm#readme)
 
 Débogueur EVM et moteur d’exécution symbolique.
 
* [leafleth](https://github.com/clemlak/leafleth)
 
 Un générateur de documentation pour les smart-contracts de Solidity.
 
* [PIET](https://piet.slock.it/)
 
 Un outil pour développer, auditer et utiliser les contrats intelligents Solidity à travers une interface graphique simple.
 
* [sol2uml](https://www.npmjs.com/package/sol2uml)
 
 Générateur de diagrammes de classe en langage de modélisation unifié (UML) pour les contrats Solidity.
 
* [solc-select](https://github.com/crytic/solc-select)
 
 A script to quickly switch between Solidity compiler versions.
 
* [Solidity prettier plugin](https://github.com/prettier-solidity/prettier-plugin-solidity)
 
 Un plugin Prettier pour Solidity.
 
* [Solidity REPL](https://github.com/raineorshine/solidity-repl)
 
 Essayez Solidity instantanément avec une console Solidity en ligne de commande.
 
* [solgraph](https://github.com/raineorshine/solgraph)
 
 Visualisez le flux de contrôle Solidity et mettez en évidence les vulnérabilités potentielles en matière de sécurité.
 
* [Solhint](https://github.com/protofire/solhint)
 
 Linter Solidity qui fournit la sécurité, un guide de style et des règles de bonnes pratiques pour la validation des contrats intelligents.
 
* [Sūrya](https://github.com/ConsenSys/surya/)
 
 Outil utilitaire pour les systèmes de contrats intelligents, offrant un certain nombre de sorties visuelles et des informations sur la structure des contrats. Il permet également d’interroger le graphe des appels de fonction.
 
* [Universal Mutator](https://github.com/agroce/universalmutator)
 
 Un outil pour la génération de mutations, avec des règles configurables et le support de Solidity et Vyper.
 
## Analyseurs et grammaires Solidity tiers[](#analyseurs-et-grammaires-solidity-tiers "Lien permanent vers cette rubrique")
* [Solidity Parser for JavaScript](https://github.com/solidity-parser/parser)
 
 Un analyseur Solidity pour JS construit à partir d’une grammaire ANTLR4 robuste.

# [Contract ABI Specification — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/abi-spec.html) 
 _https://docs.soliditylang.org/en/latest/abi-spec.html_

## Basic Design[](#basic-design "Link to this heading")
The Contract Application Binary Interface (ABI) is the standard way to interact with contracts in the Ethereum ecosystem, both from outside the blockchain and for contract-to-contract interaction. Data is encoded according to its type, as described in this specification. The encoding is not self describing and thus requires a schema in order to decode.
We assume that the interface functions of a contract are strongly typed, known at compilation time and static. We assume that all contracts will have the interface definitions of any contracts they call available at compile-time.
This specification does not address contracts whose interface is dynamic or otherwise known only at run-time. Also, the ABI specification for libraries is [slightly different](https://docs.soliditylang.org/en/latest/contracts.html#library-selectors).
## Function Selector[](#function-selector "Link to this heading")
The first four bytes of the call data for a function call specifies the function to be called. It is the first (left, high-order in big-endian) four bytes of the Keccak-256 hash of the signature of the function. The signature is defined as the canonical expression of the basic prototype without data location specifier, i.e. the function name with the parenthesised list of parameter types. Parameter types are split by a single comma — no spaces are used.
Note
The return type of a function is not part of this signature. In [Solidity’s function overloading](https://docs.soliditylang.org/en/latest/contracts.html#overload-function) return types are not considered. The reason is to keep function call resolution context-independent. The [JSON description of the ABI](#abi-json) however contains both inputs and outputs.
## Argument Encoding[](#argument-encoding "Link to this heading")
Starting from the fifth byte, the encoded arguments follow. This encoding is also used in other places, e.g. the return values and also event arguments are encoded in the same way, without the four bytes specifying the function.
## Types[](#types "Link to this heading")
Note that the library ABIs can take types different than below e.g. for non-storage structs. See [library selectors](https://docs.soliditylang.org/en/latest/contracts.html#library-selectors) for details.
The following elementary types exist:
* `uint<M>`: unsigned integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`. e.g. `uint32`, `uint8`, `uint256`.
 
* `int<M>`: two’s complement signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`.
 
* `address`: equivalent to `uint160`, except for the assumed interpretation and language typing. For computing the function selector, `address` is used.
 
* `uint`, `int`: synonyms for `uint256`, `int256` respectively. For computing the function selector, `uint256` and `int256` have to be used.
 
* `bool`: equivalent to `uint8` restricted to the values 0 and 1. For computing the function selector, `bool` is used.
 
* `fixed<M>x<N>`: signed fixed-point decimal number of `M` bits, `8 <= M <= 256`, `M % 8 == 0`, and `0 < N <= 80`, which denotes the value `v` as `v / (10 ** N)`.
 
* `ufixed<M>x<N>`: unsigned variant of `fixed<M>x<N>`.
 
* `fixed`, `ufixed`: synonyms for `fixed128x18`, `ufixed128x18` respectively. For computing the function selector, `fixed128x18` and `ufixed128x18` have to be used.
 
* `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`.
 
* `function`: an address (20 bytes) followed by a function selector (4 bytes). Encoded identical to `bytes24`.
 
The following (fixed-size) array type exists:
* `<type>[M]`: a fixed-length array of `M` elements, `M >= 0`, of the given type.
 
 Note
 
 While this ABI specification can express fixed-length arrays with zero elements, they’re not supported by the compiler.
 
The following non-fixed-size types exist:
* `bytes`: dynamic sized byte sequence.
 
* `string`: dynamic sized unicode string assumed to be UTF-8 encoded.
 
* `<type>[]`: a variable-length array of elements of the given type.
 
Types can be combined to a tuple by enclosing them inside parentheses, separated by commas:
* `(T1,T2,...,Tn)`: tuple consisting of the types `T1`, …, `Tn`, `n >= 0`
 
It is possible to form tuples of tuples, arrays of tuples and so on. It is also possible to form zero-tuples (where `n == 0`).
### Mapping Solidity to ABI types[](#mapping-solidity-to-abi-types "Link to this heading")
Solidity supports all the types presented above with the same names with the exception of tuples. On the other hand, some Solidity types are not supported by the ABI. The following table shows on the left column Solidity types that are not part of the ABI, and on the right column the ABI types that represent them.
Warning
Before version `0.8.0` enums could have more than 256 members and were represented by the smallest integer type just big enough to hold the value of any member.
## Design Criteria for the Encoding[](#design-criteria-for-the-encoding "Link to this heading")
The encoding is designed to have the following properties, which are especially useful if some arguments are nested arrays:
1. The number of reads necessary to access a value is at most the depth of the value inside the argument array structure, i.e. four reads are needed to retrieve `a_i[k][l][r]`. In a previous version of the ABI, the number of reads scaled linearly with the total number of dynamic parameters in the worst case.
 
2. The data of a variable or an array element is not interleaved with other data and it is relocatable, i.e. it only uses relative “addresses”.
 
## Formal Specification of the Encoding[](#formal-specification-of-the-encoding "Link to this heading")
We distinguish static and dynamic types. Static types are encoded in-place and dynamic types are encoded at a separately allocated location after the current block.
**Definition:** The following types are called “dynamic”:
* `bytes`
 
* `string`
 
* `T[]` for any `T`
 
* `T[k]` for any dynamic `T` and any `k >= 0`
 
* `(T1,...,Tk)` if `Ti` is dynamic for some `1 <= i <= k`
 
All other types are called “static”.
**Definition:** `len(a)` is the number of bytes in a binary string `a`. The type of `len(a)` is assumed to be `uint256`.
We define `enc`, the actual encoding, as a mapping of values of the ABI types to binary strings such that `len(enc(X))` depends on the value of `X` if and only if the type of `X` is dynamic.
**Definition:** For any ABI value `X`, we recursively define `enc(X)`, depending on the type of `X` being
* `(T1,...,Tk)` for `k >= 0` and any types `T1`, …, `Tk`
 
 `enc(X) = head(X(1)) ... head(X(k)) tail(X(1)) ... tail(X(k))`
 
 where `X = (X(1), ..., X(k))` and `head` and `tail` are defined for `Ti` as follows:
 
 if `Ti` is static:
 
 > `head(X(i)) = enc(X(i))` and `tail(X(i)) = ""` (the empty string)
 
 otherwise, i.e. if `Ti` is dynamic:
 
 > `head(X(i)) = enc(len( head(X(1)) ... head(X(k)) tail(X(1)) ... tail(X(i-1)) ))` `tail(X(i)) = enc(X(i))`
 
 Note that in the dynamic case, `head(X(i))` is well-defined since the lengths of the head parts only depend on the types and not the values. The value of `head(X(i))` is the offset of the beginning of `tail(X(i))` relative to the start of `enc(X)`.
 
* `T[k]` for any `T` and `k`:
 
 `enc(X) = enc((X[0], ..., X[k-1]))`
 
 i.e. it is encoded as if it were a tuple with `k` elements of the same type.
 
* `T[]` where `X` has `k` elements (`k` is assumed to be of type `uint256`):
 
 `enc(X) = enc(k) enc((X[0], ..., X[k-1]))`
 
 i.e. it is encoded as if it were a tuple with `k` elements of the same type (resp. an array of static size `k`), prefixed with the number of elements.
 
* `bytes`, of length `k` (which is assumed to be of type `uint256`):
 
 `enc(X) = enc(k) pad_right(X)`, i.e. the number of bytes is encoded as a `uint256` followed by the actual value of `X` as a byte sequence, followed by the minimum number of zero-bytes such that `len(enc(X))` is a multiple of 32.
 
* `string`:
 
 `enc(X) = enc(enc_utf8(X))`, i.e. `X` is UTF-8 encoded and this value is interpreted as of `bytes` type and encoded further. Note that the length used in this subsequent encoding is the number of bytes of the UTF-8 encoded string, not its number of characters.
 
* `uint<M>`: `enc(X)` is the big-endian encoding of `X`, padded on the higher-order (left) side with zero-bytes such that the length is 32 bytes.
 
* `address`: as in the `uint160` case
 
* `int<M>`: `enc(X)` is the big-endian two’s complement encoding of `X`, padded on the higher-order (left) side with `0xff` bytes for negative `X` and with zero-bytes for non-negative `X` such that the length is 32 bytes.
 
* `bool`: as in the `uint8` case, where `1` is used for `true` and `0` for `false`
 
* `fixed<M>x<N>`: `enc(X)` is `enc(X * 10**N)` where `X * 10**N` is interpreted as a `int256`.
 
* `fixed`: as in the `fixed128x18` case
 
* `ufixed<M>x<N>`: `enc(X)` is `enc(X * 10**N)` where `X * 10**N` is interpreted as a `uint256`.
 
* `ufixed`: as in the `ufixed128x18` case
 
* `bytes<M>`: `enc(X)` is the sequence of bytes in `X` padded with trailing zero-bytes to a length of 32 bytes.
 
Note that for any `X`, `len(enc(X))` is a multiple of 32.
## Function Selector and Argument Encoding[](#function-selector-and-argument-encoding "Link to this heading")
All in all, a call to the function `f` with parameters `a_1, ..., a_n` is encoded as
> `function_selector(f) enc((a_1, ..., a_n))`
and the return values `v_1, ..., v_k` of `f` are encoded as
> `enc((v_1, ..., v_k))`
i.e. the values are combined into a tuple and encoded.
## Examples[](#examples "Link to this heading")
Given the contract:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEZvbyB7CiAgICBmdW5jdGlvbiBiYXIoYnl0ZXMzWzJdIG1lbW9yeSkgcHVibGljIHB1cmUge30KICAgIGZ1bmN0aW9uIGJheih1aW50MzIgeCwgYm9vbCB5KSBwdWJsaWMgcHVyZSByZXR1cm5zIChib29sIHIpIHsgciA9IHggPiAzMiB8fCB5OyB9CiAgICBmdW5jdGlvbiBzYW0oYnl0ZXMgbWVtb3J5LCBib29sLCB1aW50W10gbWVtb3J5KSBwdWJsaWMgcHVyZSB7fQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract Foo {
 function bar(bytes3\[2\] memory) public pure {}
 function baz(uint32 x, bool y) public pure returns (bool r) { r \= x \> 32 || y; }
 function sam(bytes memory, bool, uint\[\] memory) public pure {}
}
Thus, for our `Foo` example, if we wanted to call `bar` with the argument `["abc", "def"]`, we would pass 68 bytes total, broken down into:
* `0xfce353f6`: the Method ID. This is derived from the signature `bar(bytes3[2])`.
 
* `0x6162630000000000000000000000000000000000000000000000000000000000`: the first part of the first parameter, a `bytes3` value `"abc"` (left-aligned).
 
* `0x6465660000000000000000000000000000000000000000000000000000000000`: the second part of the first parameter, a `bytes3` value `"def"` (left-aligned).
 
In total:
0xfce353f661626300000000000000000000000000000000000000000000000000000000006465660000000000000000000000000000000000000000000000000000000000
If we wanted to call `baz` with the parameters `69` and `true`, we would pass 68 bytes total, which can be broken down into:
* `0xcdcd77c0`: the Method ID. This is derived as the first 4 bytes of the Keccak hash of the ASCII form of the signature `baz(uint32,bool)`.
 
* `0x0000000000000000000000000000000000000000000000000000000000000045`: the first parameter, a uint32 value `69` padded to 32 bytes
 
* `0x0000000000000000000000000000000000000000000000000000000000000001`: the second parameter - boolean `true`, padded to 32 bytes
 
In total:
0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001
It returns a single `bool`. If, for example, it were to return `false`, its output would be the single byte array `0x0000000000000000000000000000000000000000000000000000000000000000`, a single bool.
If we wanted to call `sam` with the arguments `"dave"`, `true` and `[1,2,3]`, we would pass 292 bytes total, broken down into:
* `0xa5643bf2`: the Method ID. This is derived from the signature `sam(bytes,bool,uint256[])`. Note that `uint` is replaced with its canonical representation `uint256`.
 
* `0x0000000000000000000000000000000000000000000000000000000000000060`: the location of the data part of the first parameter (dynamic type), measured in bytes from the start of the arguments block. In this case, `0x60`.
 
* `0x0000000000000000000000000000000000000000000000000000000000000001`: the second parameter: boolean true.
 
* `0x00000000000000000000000000000000000000000000000000000000000000a0`: the location of the data part of the third parameter (dynamic type), measured in bytes. In this case, `0xa0`.
 
* `0x0000000000000000000000000000000000000000000000000000000000000004`: the data part of the first argument, it starts with the length of the byte array in elements, in this case, 4.
 
* `0x6461766500000000000000000000000000000000000000000000000000000000`: the contents of the first argument: the UTF-8 (equal to ASCII in this case) encoding of `"dave"`, padded on the right to 32 bytes.
 
* `0x0000000000000000000000000000000000000000000000000000000000000003`: the data part of the third argument, it starts with the length of the array in elements, in this case, 3.
 
* `0x0000000000000000000000000000000000000000000000000000000000000001`: the first entry of the third parameter.
 
* `0x0000000000000000000000000000000000000000000000000000000000000002`: the second entry of the third parameter.
 
* `0x0000000000000000000000000000000000000000000000000000000000000003`: the third entry of the third parameter.
 
In total:
0xa5643bf20000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003
## Use of Dynamic Types[](#use-of-dynamic-types "Link to this heading")
A call to a function with the signature `f(uint256,uint32[],bytes10,bytes)` with values `(0x123, [0x456, 0x789], "1234567890", "Hello, world!")` is encoded in the following way:
We take the first four bytes of `keccak("f(uint256,uint32[],bytes10,bytes)")`, i.e. `0x8be65246`. Then we encode the head parts of all four arguments. For the static types `uint256` and `bytes10`, these are directly the values we want to pass, whereas for the dynamic types `uint32[]` and `bytes`, we use the offset in bytes to the start of their data area, measured from the start of the value encoding (i.e. not counting the first four bytes containing the hash of the function signature). These are:
* `0x0000000000000000000000000000000000000000000000000000000000000123` (`0x123` padded to 32 bytes)
 
* `0x0000000000000000000000000000000000000000000000000000000000000080` (offset to start of data part of second parameter, 4\*32 bytes, exactly the size of the head part)
 
* `0x3132333435363738393000000000000000000000000000000000000000000000` (`"1234567890"` padded to 32 bytes on the right)
 
* `0x00000000000000000000000000000000000000000000000000000000000000e0` (offset to start of data part of fourth parameter = offset to start of data part of first dynamic parameter + size of data part of first dynamic parameter = 4\*32 + 3\*32 (see below))
 
After this, the data part of the first dynamic argument, `[0x456, 0x789]` follows:
* `0x0000000000000000000000000000000000000000000000000000000000000002` (number of elements of the array, 2)
 
* `0x0000000000000000000000000000000000000000000000000000000000000456` (first element)
 
* `0x0000000000000000000000000000000000000000000000000000000000000789` (second element)
 
Finally, we encode the data part of the second dynamic argument, `"Hello, world!"`:
* `0x000000000000000000000000000000000000000000000000000000000000000d` (number of elements (bytes in this case): 13)
 
* `0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000` (`"Hello, world!"` padded to 32 bytes on the right)
 
All together, the encoding is (newline after function selector and each 32-bytes for clarity):
0x8be65246
 0000000000000000000000000000000000000000000000000000000000000123
 0000000000000000000000000000000000000000000000000000000000000080
 3132333435363738393000000000000000000000000000000000000000000000
 00000000000000000000000000000000000000000000000000000000000000e0
 0000000000000000000000000000000000000000000000000000000000000002
 0000000000000000000000000000000000000000000000000000000000000456
 0000000000000000000000000000000000000000000000000000000000000789
 000000000000000000000000000000000000000000000000000000000000000d
 48656c6c6f2c20776f726c642100000000000000000000000000000000000000
Let us apply the same principle to encode the data for a function with a signature `g(uint256[][],string[])` with values `([[1, 2], [3]], ["one", "two", "three"])` but start from the most atomic parts of the encoding:
First we encode the length and data of the first embedded dynamic array `[1, 2]` of the first root array `[[1, 2], [3]]`:
* `0x0000000000000000000000000000000000000000000000000000000000000002` (number of elements in the first array, 2; the elements themselves are `1` and `2`)
 
* `0x0000000000000000000000000000000000000000000000000000000000000001` (first element)
 
* `0x0000000000000000000000000000000000000000000000000000000000000002` (second element)
 
Then we encode the length and data of the second embedded dynamic array `[3]` of the first root array `[[1, 2], [3]]`:
* `0x0000000000000000000000000000000000000000000000000000000000000001` (number of elements in the second array, 1; the element is `3`)
 
* `0x0000000000000000000000000000000000000000000000000000000000000003` (first element)
 
Then we need to find the offsets `a` and `b` for their respective dynamic arrays `[1, 2]` and `[3]`. To calculate the offsets we can take a look at the encoded data of the first root array `[[1, 2], [3]]` enumerating each line in the encoding:
0 - a - offset of \[1, 2\]
1 - b - offset of \[3\]
2 - 0000000000000000000000000000000000000000000000000000000000000002 - count for \[1, 2\]
3 - 0000000000000000000000000000000000000000000000000000000000000001 - encoding of 1
4 - 0000000000000000000000000000000000000000000000000000000000000002 - encoding of 2
5 - 0000000000000000000000000000000000000000000000000000000000000001 - count for \[3\]
6 - 0000000000000000000000000000000000000000000000000000000000000003 - encoding of 3
Offset `a` points to the start of the content of the array `[1, 2]` which is line 2 (64 bytes); thus `a = 0x0000000000000000000000000000000000000000000000000000000000000040`.
Offset `b` points to the start of the content of the array `[3]` which is line 5 (160 bytes); thus `b = 0x00000000000000000000000000000000000000000000000000000000000000a0`.
Then we encode the embedded strings of the second root array:
* `0x0000000000000000000000000000000000000000000000000000000000000003` (number of characters in word `"one"`)
 
* `0x6f6e650000000000000000000000000000000000000000000000000000000000` (utf8 representation of word `"one"`)
 
* `0x0000000000000000000000000000000000000000000000000000000000000003` (number of characters in word `"two"`)
 
* `0x74776f0000000000000000000000000000000000000000000000000000000000` (utf8 representation of word `"two"`)
 
* `0x0000000000000000000000000000000000000000000000000000000000000005` (number of characters in word `"three"`)
 
* `0x7468726565000000000000000000000000000000000000000000000000000000` (utf8 representation of word `"three"`)
 
In parallel to the first root array, since strings are dynamic elements we need to find their offsets `c`, `d` and `e`:
0 - c - offset for "one"
1 - d - offset for "two"
2 - e - offset for "three"
3 - 0000000000000000000000000000000000000000000000000000000000000003 - count for "one"
4 - 6f6e650000000000000000000000000000000000000000000000000000000000 - encoding of "one"
5 - 0000000000000000000000000000000000000000000000000000000000000003 - count for "two"
6 - 74776f0000000000000000000000000000000000000000000000000000000000 - encoding of "two"
7 - 0000000000000000000000000000000000000000000000000000000000000005 - count for "three"
8 - 7468726565000000000000000000000000000000000000000000000000000000 - encoding of "three"
Offset `c` points to the start of the content of the string `"one"` which is line 3 (96 bytes); thus `c = 0x0000000000000000000000000000000000000000000000000000000000000060`.
Offset `d` points to the start of the content of the string `"two"` which is line 5 (160 bytes); thus `d = 0x00000000000000000000000000000000000000000000000000000000000000a0`.
Offset `e` points to the start of the content of the string `"three"` which is line 7 (224 bytes); thus `e = 0x00000000000000000000000000000000000000000000000000000000000000e0`.
Note that the encodings of the embedded elements of the root arrays are not dependent on each other and have the same encodings for a function with a signature `g(string[],uint256[][])`.
Then we encode the length of the first root array:
* `0x0000000000000000000000000000000000000000000000000000000000000002` (number of elements in the first root array, 2; the elements themselves are `[1, 2]` and `[3]`)
 
Then we encode the length of the second root array:
* `0x0000000000000000000000000000000000000000000000000000000000000003` (number of strings in the second root array, 3; the strings themselves are `"one"`, `"two"` and `"three"`)
 
Finally we find the offsets `f` and `g` for their respective root dynamic arrays `[[1, 2], [3]]` and `["one", "two", "three"]`, and assemble parts in the correct order:
0x2289b18c - function signature
 0 - f - offset of \[\[1, 2\], \[3\]\]
 1 - g - offset of \["one", "two", "three"\]
 2 - 0000000000000000000000000000000000000000000000000000000000000002 - count for \[\[1, 2\], \[3\]\]
 3 - 0000000000000000000000000000000000000000000000000000000000000040 - offset of \[1, 2\]
 4 - 00000000000000000000000000000000000000000000000000000000000000a0 - offset of \[3\]
 5 - 0000000000000000000000000000000000000000000000000000000000000002 - count for \[1, 2\]
 6 - 0000000000000000000000000000000000000000000000000000000000000001 - encoding of 1
 7 - 0000000000000000000000000000000000000000000000000000000000000002 - encoding of 2
 8 - 0000000000000000000000000000000000000000000000000000000000000001 - count for \[3\]
 9 - 0000000000000000000000000000000000000000000000000000000000000003 - encoding of 3
10 - 0000000000000000000000000000000000000000000000000000000000000003 - count for \["one", "two", "three"\]
11 - 0000000000000000000000000000000000000000000000000000000000000060 - offset for "one"
12 - 00000000000000000000000000000000000000000000000000000000000000a0 - offset for "two"
13 - 00000000000000000000000000000000000000000000000000000000000000e0 - offset for "three"
14 - 0000000000000000000000000000000000000000000000000000000000000003 - count for "one"
15 - 6f6e650000000000000000000000000000000000000000000000000000000000 - encoding of "one"
16 - 0000000000000000000000000000000000000000000000000000000000000003 - count for "two"
17 - 74776f0000000000000000000000000000000000000000000000000000000000 - encoding of "two"
18 - 0000000000000000000000000000000000000000000000000000000000000005 - count for "three"
19 - 7468726565000000000000000000000000000000000000000000000000000000 - encoding of "three"
Offset `f` points to the start of the content of the array `[[1, 2], [3]]` which is line 2 (64 bytes); thus `f = 0x0000000000000000000000000000000000000000000000000000000000000040`.
Offset `g` points to the start of the content of the array `["one", "two", "three"]` which is line 10 (320 bytes); thus `g = 0x0000000000000000000000000000000000000000000000000000000000000140`.
## Events[](#events "Link to this heading")
Events are an abstraction of the Ethereum logging/event-watching protocol. Log entries provide the contract’s address, a series of up to four topics and some arbitrary length binary data. Events leverage the existing function ABI in order to interpret this (together with an interface spec) as a properly typed structure.
Given an event name and series of event parameters, we split them into two sub-series: those which are indexed and those which are not. Those which are indexed, which may number up to 3 (for non-anonymous events) or 4 (for anonymous ones), are used alongside the Keccak hash of the event signature to form the topics of the log entry. Those which are not indexed form the byte array of the event.
In effect, a log entry using this ABI is described as:
* `address`: the address of the contract (intrinsically provided by Ethereum);
 
* `topics[0]`: `keccak(EVENT_NAME+"("+EVENT_ARGS.map(canonical_type_of).join(",")+")")` (`canonical_type_of` is a function that simply returns the canonical type of a given argument, e.g. for `uint indexed foo`, it would return `uint256`). This value is only present in `topics[0]` if the event is not declared as `anonymous`;
 
* `topics[n]`: `abi_encode(EVENT_INDEXED_ARGS[n - 1])` if the event is not declared as `anonymous` or `abi_encode(EVENT_INDEXED_ARGS[n])` if it is (`EVENT_INDEXED_ARGS` is the series of `EVENT_ARGS` that are indexed);
 
* `data`: ABI encoding of `EVENT_NON_INDEXED_ARGS` (`EVENT_NON_INDEXED_ARGS` is the series of `EVENT_ARGS` that are not indexed, `abi_encode` is the ABI encoding function used for returning a series of typed values from a function, as described above).
 
For all types of length at most 32 bytes, the `EVENT_INDEXED_ARGS` array contains the value directly, padded or sign-extended (for signed integers) to 32 bytes, just as for regular ABI encoding. However, for all “complex” types or types of dynamic length, including all arrays, `string`, `bytes` and structs, `EVENT_INDEXED_ARGS` will contain the _Keccak hash_ of a special in-place encoded value (see [Encoding of Indexed Event Parameters](#indexed-event-encoding)), rather than the encoded value directly. This allows applications to efficiently query for values of dynamic-length types (by setting the hash of the encoded value as the topic), but leaves applications unable to decode indexed values they have not queried for. For dynamic-length types, application developers face a trade-off between fast search for predetermined values (if the argument is indexed) and legibility of arbitrary values (which requires that the arguments not be indexed). Developers may overcome this tradeoff and achieve both efficient search and arbitrary legibility by defining events with two arguments — one indexed, one not — intended to hold the same value.
## Errors[](#errors "Link to this heading")
In case of a failure inside a contract, the contract can use a special opcode to abort execution and revert all state changes. In addition to these effects, descriptive data can be returned to the caller. This descriptive data is the encoding of an error and its arguments in the same way as data for a function call.
As an example, let us consider the following contract whose `transfer` function always reverts with a custom error of “insufficient balance”:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IFRlc3RUb2tlbiB7CiAgICBlcnJvciBJbnN1ZmZpY2llbnRCYWxhbmNlKHVpbnQyNTYgYXZhaWxhYmxlLCB1aW50MjU2IHJlcXVpcmVkKTsKICAgIGZ1bmN0aW9uIHRyYW5zZmVyKGFkZHJlc3MgLyp0byovLCB1aW50IGFtb3VudCkgcHVibGljIHB1cmUgewogICAgICAgIHJldmVydCBJbnN1ZmZpY2llbnRCYWxhbmNlKDAsIGFtb3VudCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract TestToken {
 error InsufficientBalance(uint256 available, uint256 required);
 function transfer(address /\*to\*/, uint amount) public pure {
 revert InsufficientBalance(0, amount);
 }
}
The return data would be encoded in the same way as the function call `InsufficientBalance(0, amount)` to the function `InsufficientBalance(uint256,uint256)`, i.e. `0xcf479181`, `uint256(0)`, `uint256(amount)`.
The error selectors `0x00000000` and `0xffffffff` are reserved for future use.
Warning
Never trust error data. The error data by default bubbles up through the chain of external calls, which means that a contract may receive an error not defined in any of the contracts it calls directly. Furthermore, any contract can fake any error by returning data that matches an error signature, even if the error is not defined anywhere.
## JSON[](#json "Link to this heading")
The JSON format for a contract’s interface is given by an array of function, event and error descriptions. A function description is a JSON object with the fields:
* `type`: `"function"`, `"constructor"`, `"receive"` (the [“receive Ether” function](https://docs.soliditylang.org/en/latest/contracts.html#receive-ether-function)) or `"fallback"` (the [“default” function](https://docs.soliditylang.org/en/latest/contracts.html#fallback-function));
 
* `name`: the name of the function;
 
* `inputs`: an array of objects, each of which contains:
 
 * `name`: the name of the parameter.
 
 * `type`: the canonical type of the parameter (more below).
 
 * `components`: used for tuple types (more below).
 
* `outputs`: an array of objects similar to `inputs`.
 
* `stateMutability`: a string with one of the following values: `pure` ([specified to not read blockchain state](https://docs.soliditylang.org/en/latest/contracts.html#pure-functions)), `view` ([specified to not modify the blockchain state](https://docs.soliditylang.org/en/latest/contracts.html#view-functions)), `nonpayable` (function does not accept Ether - the default) and `payable` (function accepts Ether).
 
Constructor, receive, and fallback never have `name` or `outputs`. Receive and fallback do not have `inputs` either.
Note
Sending non-zero Ether to non-payable function will revert the transaction.
Note
The state mutability `nonpayable` is reflected in Solidity by not specifying a state mutability modifier at all.
An event description is a JSON object with fairly similar fields:
* `type`: always `"event"`
 
* `name`: the name of the event.
 
* `inputs`: an array of objects, each of which contains:
 
 * `name`: the name of the parameter.
 
 * `type`: the canonical type of the parameter (more below).
 
 * `components`: used for tuple types (more below).
 
 * `indexed`: `true` if the field is part of the log’s topics, `false` if it is one of the log’s data segments.
 
* `anonymous`: `true` if the event was declared as `anonymous`.
 
Errors look as follows:
* `type`: always `"error"`
 
* `name`: the name of the error.
 
* `inputs`: an array of objects, each of which contains:
 
 * `name`: the name of the parameter.
 
 * `type`: the canonical type of the parameter (more below).
 
 * `components`: used for tuple types (more below).
 
Note
There can be multiple errors with the same name and even with identical signature in the JSON array; for example, if the errors originate from different files in the smart contract or are referenced from another smart contract. For the ABI, only the name of the error itself is relevant and not where it is defined.
For example,
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCgpjb250cmFjdCBUZXN0IHsKICAgIGNvbnN0cnVjdG9yKCkgeyBiID0gaGV4IjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyIjsgfQogICAgZXZlbnQgRXZlbnQodWludCBpbmRleGVkIGEsIGJ5dGVzMzIgYik7CiAgICBldmVudCBFdmVudDIodWludCBpbmRleGVkIGEsIGJ5dGVzMzIgYik7CiAgICBlcnJvciBJbnN1ZmZpY2llbnRCYWxhbmNlKHVpbnQyNTYgYXZhaWxhYmxlLCB1aW50MjU2IHJlcXVpcmVkKTsKICAgIGZ1bmN0aW9uIGZvbyh1aW50IGEpIHB1YmxpYyB7IGVtaXQgRXZlbnQoYSwgYik7IH0KICAgIGJ5dGVzMzIgYjsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract Test {
 constructor() { b \= hex"12345678901234567890123456789012"; }
 event Event(uint indexed a, bytes32 b);
 event Event2(uint indexed a, bytes32 b);
 error InsufficientBalance(uint256 available, uint256 required);
 function foo(uint a) public { emit Event(a, b); }
 bytes32 b;
}
would result in the JSON:
\[{
"type":"error",
"inputs": \[{"name":"available","type":"uint256"},{"name":"required","type":"uint256"}\],
"name":"InsufficientBalance"
}, {
"type":"event",
"inputs": \[{"name":"a","type":"uint256","indexed":true},{"name":"b","type":"bytes32","indexed":false}\],
"name":"Event"
}, {
"type":"event",
"inputs": \[{"name":"a","type":"uint256","indexed":true},{"name":"b","type":"bytes32","indexed":false}\],
"name":"Event2"
}, {
"type":"function",
"inputs": \[{"name":"a","type":"uint256"}\],
"name":"foo",
"outputs": \[\]
}\]
### Handling tuple types[](#handling-tuple-types "Link to this heading")
Despite the fact that names are intentionally not part of the ABI encoding, they do make a lot of sense to be included in the JSON to enable displaying it to the end user. The structure is nested in the following way:
An object with members `name`, `type` and potentially `components` describes a typed variable. The canonical type is determined until a tuple type is reached and the string description up to that point is stored in `type` prefix with the word `tuple`, i.e. it will be `tuple` followed by a sequence of `[]` and `[k]` with integers `k`. The components of the tuple are then stored in the member `components`, which is of an array type and has the same structure as the top-level object except that `indexed` is not allowed there.
As an example, the code
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjUgPDAuOS4wOwpwcmFnbWEgYWJpY29kZXIgdjI7Cgpjb250cmFjdCBUZXN0IHsKICAgIHN0cnVjdCBTIHsgdWludCBhOyB1aW50W10gYjsgVFtdIGM7IH0KICAgIHN0cnVjdCBUIHsgdWludCB4OyB1aW50IHk7IH0KICAgIGZ1bmN0aW9uIGYoUyBtZW1vcnksIFQgbWVtb3J5LCB1aW50KSBwdWJsaWMgcHVyZSB7fQogICAgZnVuY3Rpb24gZygpIHB1YmxpYyBwdXJlIHJldHVybnMgKFMgbWVtb3J5LCBUIG1lbW9yeSwgdWludCkge30KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.5 <0.9.0;
pragma abicoder v2;
contract Test {
 struct S { uint a; uint\[\] b; T\[\] c; }
 struct T { uint x; uint y; }
 function f(S memory, T memory, uint) public pure {}
 function g() public pure returns (S memory, T memory, uint) {}
}
would result in the JSON:
\[
 {
 "name": "f",
 "type": "function",
 "inputs": \[
 {
 "name": "s",
 "type": "tuple",
 "components": \[
 {
 "name": "a",
 "type": "uint256"
 },
 {
 "name": "b",
 "type": "uint256\[\]"
 },
 {
 "name": "c",
 "type": "tuple\[\]",
 "components": \[
 {
 "name": "x",
 "type": "uint256"
 },
 {
 "name": "y",
 "type": "uint256"
 }
 \]
 }
 \]
 },
 {
 "name": "t",
 "type": "tuple",
 "components": \[
 {
 "name": "x",
 "type": "uint256"
 },
 {
 "name": "y",
 "type": "uint256"
 }
 \]
 },
 {
 "name": "a",
 "type": "uint256"
 }
 \],
 "outputs": \[\]
 }
\]
## Strict Encoding Mode[](#strict-encoding-mode "Link to this heading")
Strict encoding mode is the mode that leads to exactly the same encoding as defined in the formal specification above. This means that offsets have to be as small as possible while still not creating overlaps in the data areas, and thus no gaps are allowed.
Usually, ABI decoders are written in a straightforward way by just following offset pointers, but some decoders might enforce strict mode. The Solidity ABI decoder currently does not enforce strict mode, but the encoder always creates data in strict mode.
## Non-standard Packed Mode[](#non-standard-packed-mode "Link to this heading")
Through `abi.encodePacked()`, Solidity supports a non-standard packed mode where:
* types shorter than 32 bytes are concatenated directly, without padding or sign extension
 
* dynamic types are encoded in-place and without the length.
 
* array elements are padded, but still encoded in-place
 
Furthermore, structs as well as nested arrays are not supported.
As an example, the encoding of `int16(-1), bytes1(0x42), uint16(0x03), string("Hello, world!")` results in:
0xffff42000348656c6c6f2c20776f726c6421
 ^^^^ int16(-1)
 ^^ bytes1(0x42)
 ^^^^ uint16(0x03)
 ^^^^^^^^^^^^^^^^^^^^^^^^^^ string("Hello, world!") without a length field
More specifically:
* During the encoding, everything is encoded in-place. This means that there is no distinction between head and tail, as in the ABI encoding, and the length of an array is not encoded.
 
* The direct arguments of `abi.encodePacked` are encoded without padding, as long as they are not arrays (or `string` or `bytes`).
 
* The encoding of an array is the concatenation of the encoding of its elements **with** padding.
 
* Dynamically-sized types like `string`, `bytes` or `uint[]` are encoded without their length field.
 
* The encoding of `string` or `bytes` does not apply padding at the end, unless it is part of an array or struct (then it is padded to a multiple of 32 bytes).
 
In general, the encoding is ambiguous as soon as there are two dynamically-sized elements, because of the missing length field.
If padding is needed, explicit type conversions can be used: `abi.encodePacked(uint16(0x12)) == hex"0012"`.
Since packed encoding is not used when calling functions, there is no special support for prepending a function selector. Since the encoding is ambiguous, there is no decoding function.
Warning
If you use `keccak256(abi.encodePacked(a, b))` and both `a` and `b` are dynamic types, it is easy to craft collisions in the hash value by moving parts of `a` into `b` and vice-versa. More specifically, `abi.encodePacked("a", "bc") == abi.encodePacked("ab", "c")`. If you use `abi.encodePacked` for signatures, authentication or data integrity, make sure to always use the same types and check that at most one of them is dynamic. Unless there is a compelling reason, `abi.encode` should be preferred.
## Encoding of Indexed Event Parameters[](#encoding-of-indexed-event-parameters "Link to this heading")
Indexed event parameters that are not value types, i.e. arrays and structs are not stored directly but instead a Keccak-256 hash of an encoding is stored. This encoding is defined as follows:
* the encoding of a `bytes` and `string` value is just the string contents without any padding or length prefix.
 
* the encoding of a struct is the concatenation of the encoding of its members, always padded to a multiple of 32 bytes (even `bytes` and `string`).
 
* the encoding of an array (both dynamically- and statically-sized) is the concatenation of the encoding of its elements, always padded to a multiple of 32 bytes (even `bytes` and `string`) and without any length prefix
 
In the above, as usual, a negative number is padded by sign extension and not zero padded. `bytesNN` types are padded on the right while `uintNN` / `intNN` are padded on the left.
Warning
The encoding of a struct is ambiguous if it contains more than one dynamically-sized array. Because of that, always re-check the event data and do not rely on the search result based on the indexed parameters alone.

# [Mise en page d’un fichier source Solidity — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/layout-of-source-files.html) 
 _https://docs.soliditylang.org/fr/latest/layout-of-source-files.html_

Les fichiers sources peuvent contenir un nombre arbitraire de [définitions des contrats](https://docs.soliditylang.org/fr/latest/structure-of-a-contract.html#contract-structure), directives d’importation, [directives pragmatiques](#pragma) et [struct](https://docs.soliditylang.org/fr/latest/types.html#structs), [enum](https://docs.soliditylang.org/fr/latest/types.html#enums), [function](https://docs.soliditylang.org/fr/latest/contracts.html#functions), [error](https://docs.soliditylang.org/fr/latest/contracts.html#errors) et [constant variable](https://docs.soliditylang.org/fr/latest/contracts.html#constants) définitions.
## Identificateur de licence SPDX[](#index-0 "Lien permanent vers cette rubrique")
La confiance dans les contrats intelligents peut être mieux établie si leur code source est disponible. Puisque la mise à disposition du code source touche toujours à des problèmes juridiques en ce qui concerne le droit d’auteur, le compilateur Solidity encourage l’utilisation d’identifiants de licence [SPDX lisibles par machine](https://spdx.org/). Chaque fichier source doit commencer par un commentaire indiquant sa licence :
`// SPDX-License-Identifier: MIT`
Le compilateur ne valide pas que la licence fait partie de la [liste autorisée par SPDX](https://spdx.org/licenses/), mais il inclut la chaîne fournie dans les [métadonnées du code source](https://docs.soliditylang.org/fr/latest/metadata.html#metadata).
Si vous ne voulez pas spécifier une licence ou si le code source n’est pas pas open-source, veuillez utiliser la valeur spéciale `UNLICENSED`.
Le fait de fournir ce commentaire ne vous libère bien sûr pas des autres obligations liées à la licence, comme l’obligation de mentionner un en-tête de licence spécifique dans chaque fichier source ou le détenteur du droit d’auteur original.
Le commentaire est reconnu par le compilateur à n’importe quel endroit du fichier, mais il est recommandé de le placer en haut du fichier.
Plus d’informations sur la façon d’utiliser les identifiants de licence SPDX peuvent être trouvées sur le site web de [SPDX](https://spdx.org/ids-how).
## Pragmas[](#pragmas "Lien permanent vers cette rubrique")
Le mot-clé `pragma` est utilisé pour activer certaines fonctionnalités du compilateur ou des vérifications. Une directive pragma est toujours locale à un fichier source. vous devez ajouter la directive pragma à tous vos fichiers si vous voulez l’activer dans l’ensemble de votre projet. Si vous [import](#import) un autre fichier, la directive pragma de ce fichier ne s’applique pas automatiquement au fichier d’importation.
### Pragma de version[](#pragma-de-version "Lien permanent vers cette rubrique")
Les fichiers sources peuvent (et doivent) être annotés avec un pragma de version pour rejeter la compilation avec de futures versions du compilateur qui pourraient introduire des changements incompatibles. Nous essayons de limiter ces changements au strict minimum et de les introduire de manière à ce que les changements sémantiques nécessitent aussi dans la syntaxe, mais cela n’est pas toujours possible. Pour cette raison, il est toujours une bonne idée de lire le journal des modifications, au moins pour les versions qui contiennent des des changements de rupture. Ces versions ont toujours des versions de la forme `0.x.0` ou `x.0.0`.
Le pragma de version est utilisé comme suit : `pragma solidity ^0.5.2;`
Un fichier source avec la ligne ci-dessus ne compile pas avec un compilateur antérieur à la version 0.5.2, et il ne fonctionne pas non plus avec un compilateur à partir de la version 0.6.0 (cette deuxième condition est ajoutée en utilisant `^`). Parce que il n’y aura pas de changements de rupture jusqu’à la version `0.6.0`, vous pouvez être sûr que votre code compile comme vous l’aviez prévu. La version exacte du compilateur n’est pas fixée, de sorte que les versions de correction de bogues sont toujours possibles.
Il est possible de spécifier des règles plus complexes pour la version du compilateur, celles-ci suivent la même syntaxe que celle utilisée par [npm](https://docs.npmjs.com/cli/v6/using-npm/semver).
Note
L’utilisation du pragma version _ne change pas_ la version du compilateur. Il ne permet pas non plus d’activer ou de désactiver des fonctionnalités du compilateur. Il indique simplement au compilateur de vérifier si sa version correspond à celle requise par le pragma. Si elle ne correspond pas, le compilateur émet une une erreur.
### Pragma du codeur ABI[](#pragma-du-codeur-abi "Lien permanent vers cette rubrique")
En utilisant `pragma abicoder v1` ou `pragma abicoder v2`, vous pouvez choisir entre les deux implémentations du codeur et du décodeur ABI.
Le nouveau codeur ABI (v2) est capable de coder et de décoder tableaux et structs. Il peut produire un code moins optimal et n’a pas été testé autant que l’ancien codeur, mais est considéré comme non expérimental à partir de Solidity 0.6.0. Vous devez toujours explicitement l’activer en utilisant `pragma abicoder v2;`. Puisqu’il sera activé par défaut à partir de Solidity 0.8.0, il existe une option pour sélectionner l’ancien codeur en utilisant `pragma abicoder v1;`.
L’ensemble des types supportés par le nouveau codeur est un sur-ensemble strict de ceux supportés par l’ancien. Les contrats qui l’utilisent peuvent interagir avec ceux qui ne l’utilisent pas sans limitations. L’inverse n’est possible que dans la mesure où le contrat non-`abicoder v2` n’essaie pas de faire des appels qui nécessiteraient de décoder des types uniquement supportés par le nouvel encodeur. Le compilateur peut détecter cela et émettra une erreur. Il suffit d’activer « abicoder v2 » pour votre contrat pour que l’erreur disparaisse.
Note
Ce pragma s’applique à tout le code défini dans le fichier où il est activé, quel que soit l’endroit où ce code se retrouve finalement. Cela signifie qu’un contrat dont le fichier source est sélectionné pour être compilé avec le codeur ABI v1 peut toujours contenir du code qui utilise le nouveau codeur en l’héritant d’un autre contrat. Ceci est autorisé si les nouveaux types sont uniquement utilisés en interne et non dans les signatures de fonctions externes.
Note
Jusqu’à Solidity 0.7.4, il était possible de sélectionner le codeur ABI v2 en utilisant `pragma experimental ABIEncoderV2`, mais il n’était pas possible de sélectionner explicitement le codeur v1 parce qu’il était par défaut.
### Pragma expérimental[](#pragma-experimental "Lien permanent vers cette rubrique")
Le deuxième pragma est le pragma expérimental. Il peut être utilisé pour activer des fonctionnalités du compilateur ou du langage qui ne sont pas encore activées par défaut. Les pragmes expérimentaux suivants sont actuellement supportés :
#### ABIEncoderV2[](#abiencoderv2 "Lien permanent vers cette rubrique")
Parce que le codeur ABI v2 n’est plus considéré comme expérimental, il peut être sélectionné via `pragma abicoder v2` (voir ci-dessus) depuis Solidity 0.7.4.
#### SMTChecker[](#smtchecker "Lien permanent vers cette rubrique")
Ce composant doit être activé lorsque le compilateur Solidity est construit, et n’est donc pas disponible dans tous les binaires Solidity. Les [instructions de construction](https://docs.soliditylang.org/fr/latest/installing-solidity.html#smt-solvers-build) expliquent comment activer cette option. Elle est activée pour les versions PPA d’Ubuntu dans la plupart des versions, mais pas pour les images Docker, les binaires Windows ou les binaires Linux construits de manière statique. Elle peut être activée pour solc-js via l’option [smtCallback](https://github.com/ethereum/solc-js#example-usage-with-smtsolver-callback) si vous avez un solveur SMT installé localement et que vous exécutez solc-js via node (et non via le navigateur).
Si vous utilisez `pragma experimental SMTChecker;`, alors vous obtenez des [avertissements de sécurité](https://docs.soliditylang.org/fr/latest/smtchecker.html#formal-verification) supplémentaires qui sont obtenus en interrogeant un solveur SMT. Ce composant ne prend pas encore en charge toutes les fonctionnalités du langage Solidity et produit probablement de nombreux avertissements. S’il signale des fonctionnalités non supportées, l’analyse n’est peut-être pas entièrement solide.
## Importation d’autres fichiers sources[](#importation-d-autres-fichiers-sources "Lien permanent vers cette rubrique")
### Syntaxe et sémantique[](#syntaxe-et-semantique "Lien permanent vers cette rubrique")
Solidity prend en charge des déclarations d’importation pour aider à modulariser votre code. Ils sont similaires à celles disponibles en JavaScript (à partir de ES6). Cependant, Solidity ne supporte pas le concept de l”[exportation par défaut](https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export#Description).
Au niveau global, vous pouvez utiliser des déclarations d’importation de la forme suivante :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=aW1wb3J0ICJmaWxlbmFtZSI7)
La partie `filename` est appelée un « chemin d’importation ». Cette déclaration importe tous les symboles globaux de « nom de fichier » (et les symboles qui y sont importés) dans la portée globale actuelle (différent de ES6 mais compatible avec Solidity). L’utilisation de cette forme n’est pas recommandée, car elle pollue l’espace de noms de manière imprévisible. Si vous ajoutez de nouveaux éléments de haut niveau à l’intérieur de « filename », ils apparaissent automatiquement dans tous les fichiers qui importent de la sorte depuis « nom de fichier ». Il est préférable d’importer des symboles spécifiques de manière explicite.
L’exemple suivant crée un nouveau symbole global `symbolName` dont les membres sont tous les symboles globaux de « filename ». les symboles globaux de « nom\_de\_fichier » :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=aW1wb3J0ICogYXMgc3ltYm9sTmFtZSBmcm9tICJmaWxlbmFtZSI7)
import \* as symbolName from "filename";
ce qui a pour conséquence que tous les symboles globaux sont disponibles dans le format `symbolName.symbol`.
Une variante de cette syntaxe qui ne fait pas partie de ES6, mais qui peut être utile, est la suivante :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=aW1wb3J0ICJmaWxlbmFtZSIgYXMgc3ltYm9sTmFtZTs=)
import "filename" as symbolName;
qui est équivalent à `import * as symbolName from "filename";`.
S’il y a une collision de noms, vous pouvez renommer les symboles pendant l’importation. Par exemple, le code ci-dessous crée de nouveaux symboles globaux `alias` et `symbol2` qui font référence à `symbol1` et `symbole2` à l’intérieur de « filename », respectivement.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=aW1wb3J0IHtzeW1ib2wxIGFzIGFsaWFzLCBzeW1ib2wyfSBmcm9tICJmaWxlbmFtZSI7)
import {symbol1 as alias, symbol2} from "filename";
### Importation de chemins[](#importation-de-chemins "Lien permanent vers cette rubrique")
Afin de pouvoir supporter des constructions reproductibles sur toutes les plateformes, le compilateur Solidity doit faire abstraction des détails du système de fichiers dans lequel les fichiers sources sont stockés. Pour cette raison, les chemins d’importation ne se réfèrent pas directement aux fichiers dans le système de fichiers hôte. Au lieu de cela, le compilateur maintient une base de données interne (_système de fichiers virtuel_ ou _VFS_ en abrégé) dans laquelle chaque unité source se voit attribuer un _nom d’unité source_ unique qui est un identifiant opaque et non structuré. Le chemin d’importation spécifié dans une instruction d’importation est traduit en un nom d’unité source et utilisé pour trouver l’unité source correspondante dans cette base de données.
En utilisant l’API [Standard JSON](https://docs.soliditylang.org/fr/latest/using-the-compiler.html#compiler-api), il est possible de fournir directement les noms et le contenu de tous les fichiers sources comme une partie de l’entrée du compilateur. Dans ce cas, les noms des unités sources sont vraiment arbitraires. Si, par contre, vous voulez que le compilateur trouve et charge automatiquement le code source dans le VFS, vos noms d’unité source doivent être structurés de manière à rendre possible un [import callback](https://docs.soliditylang.org/fr/latest/path-resolution.html#import-callback) de les localiser. Lorsque vous utilisez le compilateur en ligne de commande, le callback d’importation par défaut ne supporte que le chargement du code source depuis le système de fichiers de l’hôte, ce qui signifie que les noms de vos unités sources doivent être des chemins. Certains environnements fournissent des callbacks personnalisés qui sont plus polyvalents. Par exemple l’IDE [Remix](https://remix.ethereum.org/) en fournit une qui vous permet [d’importer des fichiers à partir d’URL HTTP, IPFS et Swarm ou de vous référer directement à des paquets dans le registre NPM.](https://remix-ide.readthedocs.io/en/latest/import.html).
Pour une description complète du système de fichiers virtuel et de la logique de résolution de chemin utilisée par le compilateur, voir [Résolution de chemin](https://docs.soliditylang.org/fr/latest/path-resolution.html#path-resolution).

# [Yul — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/yul.html) 
 _https://docs.soliditylang.org/en/latest/yul.html_

Yul (previously also called JULIA or IULIA) is an intermediate language that can be compiled to bytecode for different backends.
It can be used in stand-alone mode and for “inline assembly” inside Solidity. The compiler uses Yul as an intermediate language in the IR-based code generator (“new codegen” or “IR-based codegen”). Yul is a good target for high-level optimisation stages that can benefit all target platforms equally.
## Motivation and High-level Description[](#motivation-and-high-level-description "Link to this heading")
The design of Yul tries to achieve several goals:
1. Programs written in Yul should be readable, even if the code is generated by a compiler from Solidity or another high-level language.
 
2. Control flow should be easy to understand to help in manual inspection, formal verification and optimization.
 
3. The translation from Yul to bytecode should be as straightforward as possible.
 
4. Yul should be suitable for whole-program optimization.
 
In order to achieve the first and second goal, Yul provides high-level constructs like `for` loops, `if` and `switch` statements and function calls. These should be sufficient for adequately representing the control flow for assembly programs. Therefore, no explicit statements for `SWAP`, `DUP`, `JUMPDEST`, `JUMP` and `JUMPI` are provided, because the first two obfuscate the data flow and the last two obfuscate control flow. Furthermore, functional statements of the form `mul(add(x, y), 7)` are preferred over pure opcode statements like `7 y x add mul` because in the first form, it is much easier to see which operand is used for which opcode.
Even though it was designed for stack machines, Yul does not expose the complexity of the stack itself. The programmer or auditor should not have to worry about the stack.
The third goal is achieved by compiling the higher level constructs to bytecode in a very regular way. The only non-local operation performed by the assembler is name lookup of user-defined identifiers (functions, variables, …) and cleanup of local variables from the stack.
To avoid confusions between concepts like values and references, Yul is statically typed. At the same time, there is a default type (usually the integer word of the target machine) that can always be omitted to help readability.
To keep the language simple and flexible, Yul does not have any built-in operations, functions or types in its pure form. These are added together with their semantics when specifying a dialect of Yul, which allows specializing Yul to the requirements of different target platforms and feature sets.
Currently, there is only one specified dialect of Yul. This dialect uses the EVM opcodes as builtin functions (see below) and defines only the type `u256`, which is the native 256-bit type of the EVM. Because of that, we will not provide types in the examples below.
## Simple Example[](#simple-example "Link to this heading")
The following example program is written in the EVM dialect and computes exponentiation. It can be compiled using `solc --strict-assembly`. The builtin functions `mul` and `div` compute product and division, respectively.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.31&code=ewogICAgZnVuY3Rpb24gcG93ZXIoYmFzZSwgZXhwb25lbnQpIC0+IHJlc3VsdAogICAgewogICAgICAgIHN3aXRjaCBleHBvbmVudAogICAgICAgIGNhc2UgMCB7IHJlc3VsdCA6PSAxIH0KICAgICAgICBjYXNlIDEgeyByZXN1bHQgOj0gYmFzZSB9CiAgICAgICAgZGVmYXVsdAogICAgICAgIHsKICAgICAgICAgICAgcmVzdWx0IDo9IHBvd2VyKG11bChiYXNlLCBiYXNlKSwgZGl2KGV4cG9uZW50LCAyKSkKICAgICAgICAgICAgc3dpdGNoIG1vZChleHBvbmVudCwgMikKICAgICAgICAgICAgICAgIGNhc2UgMSB7IHJlc3VsdCA6PSBtdWwoYmFzZSwgcmVzdWx0KSB9CiAgICAgICAgfQogICAgfQp9)
{
 function power(base, exponent) \-> result
 {
 switch exponent
 case 0 { result := 1 }
 case 1 { result := base }
 default
 {
 result := power(mul(base, base), div(exponent, 2))
 switch mod(exponent, 2)
 case 1 { result := mul(base, result) }
 }
 }
}
It is also possible to implement the same function using a for-loop instead of with recursion. Here, `lt(a, b)` computes whether `a` is less than `b`.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.31&code=ewogICAgZnVuY3Rpb24gcG93ZXIoYmFzZSwgZXhwb25lbnQpIC0+IHJlc3VsdAogICAgewogICAgICAgIHJlc3VsdCA6PSAxCiAgICAgICAgZm9yIHsgbGV0IGkgOj0gMCB9IGx0KGksIGV4cG9uZW50KSB7IGkgOj0gYWRkKGksIDEpIH0KICAgICAgICB7CiAgICAgICAgICAgIHJlc3VsdCA6PSBtdWwocmVzdWx0LCBiYXNlKQogICAgICAgIH0KICAgIH0KfQ==)
{
 function power(base, exponent) \-> result
 {
 result := 1
 for { let i := 0 } lt(i, exponent) { i := add(i, 1) }
 {
 result := mul(result, base)
 }
 }
}
At the [end of the section](#erc20yul), a complete implementation of the ERC-20 standard can be found.
## Stand-Alone Usage[](#stand-alone-usage "Link to this heading")
You can use Yul in its stand-alone form in the EVM dialect using the Solidity compiler. This will use the [Yul object notation](#yul-object) so that it is possible to refer to code as data to deploy contracts. This Yul mode is available for the commandline compiler (use `--strict-assembly`) and for the [standard-json interface](https://docs.soliditylang.org/en/latest/using-the-compiler.html#compiler-api):
{
 "language": "Yul",
 "sources": { "input.yul": { "content": "{ sstore(0, 1) }" } },
 "settings": {
 "outputSelection": { "\*": { "\*": \["\*"\], "": \[ "\*" \] } },
 "optimizer": { "enabled": true, "details": { "yul": true } }
 }
}
Warning
Yul is in active development and bytecode generation is only fully implemented for the EVM dialect of Yul with EVM 1.0 as target.
## Informal Description of Yul[](#informal-description-of-yul "Link to this heading")
In the following, we will talk about each individual aspect of the Yul language. In examples, we will use the default EVM dialect.
### Syntax[](#syntax "Link to this heading")
Yul parses comments, literals and identifiers in the same way as Solidity, so you can e.g. use `//` and `/* */` to denote comments. There is one exception: Identifiers in Yul can contain dots: `.`.
Yul can specify “objects” that consist of code, data and sub-objects. Please see [Yul Objects](#yul-object) below for details on that. In this section, we are only concerned with the code part of such an object. This code part always consists of a curly-braces delimited block. Most tools support specifying just a code block where an object is expected.
Inside a code block, the following elements can be used (see the later sections for more details):
* literals, e.g. `0x123`, `42` or `"abc"` (strings up to 32 characters)
 
* calls to builtin functions, e.g. `add(1, mload(0))`
 
* variable declarations, e.g. `let x := 7`, `let x := add(y, 3)` or `let x` (initial value of 0 is assigned)
 
* identifiers (variables), e.g. `add(3, x)`
 
* assignments, e.g. `x := add(y, 3)`
 
* blocks where local variables are scoped inside, e.g. `{ let x := 3 { let y := add(x, 1) } }`
 
* if statements, e.g. `if lt(a, b) { sstore(0, 1) }`
 
* switch statements, e.g. `switch mload(0) case 0 { revert() } default { mstore(0, 1) }`
 
* for loops, e.g. `for { let i := 0} lt(i, 10) { i := add(i, 1) } { mstore(i, 7) }`
 
* function definitions, e.g. `function f(a, b) -> c { c := add(a, b) }`
 
Multiple syntactical elements can follow each other simply separated by whitespace, i.e. there is no terminating `;` or newline required.
### Literals[](#literals "Link to this heading")
As literals, you can use:
* Integer constants in decimal or hexadecimal notation.
 
* ASCII strings (e.g. `"abc"`), which may contain hex escapes `\xNN` and Unicode escapes `\uNNNN` where `N` are hexadecimal digits.
 
* Hex strings (e.g. `hex"616263"`).
 
In the EVM dialect of Yul, literals represent 256-bit words as follows:
* Decimal or hexadecimal constants must be less than `2**256`. They represent the 256-bit word with that value as an unsigned integer in big endian encoding.
 
* An ASCII string is first viewed as a byte sequence, by viewing a non-escape ASCII character as a single byte whose value is the ASCII code, an escape `\xNN` as single byte with that value, and an escape `\uNNNN` as the UTF-8 sequence of bytes for that code point. The byte sequence must not exceed 32 bytes. The byte sequence is padded with zeros on the right to reach 32 bytes in length; in other words, the string is stored left-aligned. The padded byte sequence represents a 256-bit word whose most significant 8 bits are the ones from the first byte, i.e. the bytes are interpreted in big endian form.
 
* A hex string is first viewed as a byte sequence, by viewing each pair of contiguous hex digits as a byte. The byte sequence must not exceed 32 bytes (i.e. 64 hex digits), and is treated as above.
 
When compiling for the EVM, this will be translated into an appropriate `PUSHi` instruction. In the following example, `3` and `2` are added resulting in 5 and then the bitwise `and` with the string “abc” is computed. The final value is assigned to a local variable called `x`.
The 32-byte limit above does not apply to string literals passed to builtin functions that require literal arguments (e.g. `setimmutable` or `loadimmutable`). Those strings never end up in the generated bytecode.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.31&code=bGV0IHggOj0gYW5kKCJhYmMiLCBhZGQoMywgMikp)
let x := and("abc", add(3, 2))
Unless it is the default type, the type of a literal has to be specified after a colon:
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.31&code=Ly8gVGhpcyB3aWxsIG5vdCBjb21waWxlICh1MzIgYW5kIHUyNTYgdHlwZSBub3QgaW1wbGVtZW50ZWQgeWV0KQpsZXQgeCA6PSBhbmQoImFiYyI6dTMyLCBhZGQoMzp1MjU2LCAyOnUyNTYpKQ==)
// This will not compile (u32 and u256 type not implemented yet)
let x := and("abc":u32, add(3:u256, 2:u256))
### Function Calls[](#function-calls "Link to this heading")
Both built-in and user-defined functions (see below) can be called in the same way as shown in the previous example. If the function returns a single value, it can be directly used inside an expression again. If it returns multiple values, they have to be assigned to local variables.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.31&code=ZnVuY3Rpb24gZih4LCB5KSAtPiBhLCBiIHsgLyogLi4uICovIH0KbXN0b3JlKDB4ODAsIGFkZChtbG9hZCgweDgwKSwgMykpCi8vIEhlcmUsIHRoZSB1c2VyLWRlZmluZWQgZnVuY3Rpb24gYGZgIHJldHVybnMgdHdvIHZhbHVlcy4KbGV0IHgsIHkgOj0gZigxLCBtbG9hZCgwKSk=)
function f(x, y) \-> a, b { /\* ... \*/ }
mstore(0x80, add(mload(0x80), 3))
// Here, the user-defined function \`f\` returns two values.
let x, y := f(1, mload(0))
For built-in functions of the EVM, functional expressions can be directly translated to a stream of opcodes: You just read the expression from right to left to obtain the opcodes. In the case of the second line in the example, this is `PUSH1 3 PUSH1 0x80 MLOAD ADD PUSH1 0x80 MSTORE`.
For calls to user-defined functions, the arguments are also put on the stack from right to left and this is the order in which argument lists are evaluated. The return values, though, are expected on the stack from left to right, i.e. in this example, `y` is on top of the stack and `x` is below it.
### Variable Declarations[](#variable-declarations "Link to this heading")
You can use the `let` keyword to declare variables. A variable is only visible inside the `{...}`\-block it was defined in. When compiling to the EVM, a new stack slot is created that is reserved for the variable and automatically removed again when the end of the block is reached. You can provide an initial value for the variable. If you do not provide a value, the variable will be initialized to zero.
Since variables are stored on the stack, they do not directly influence memory or storage, but they can be used as pointers to memory or storage locations in the built-in functions `mstore`, `mload`, `sstore` and `sload`. Future dialects might introduce specific types for such pointers.
When a variable is referenced, its current value is copied. For the EVM, this translates to a `DUP` instruction.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.31&code=ewogICAgbGV0IHplcm8gOj0gMAogICAgbGV0IHYgOj0gY2FsbGRhdGFsb2FkKHplcm8pCiAgICB7CiAgICAgICAgbGV0IHkgOj0gYWRkKHNsb2FkKHYpLCAxKQogICAgICAgIHYgOj0geQogICAgfSAvLyB5IGlzICJkZWFsbG9jYXRlZCIgaGVyZQogICAgc3N0b3JlKHYsIHplcm8pCn0gLy8gdiBhbmQgemVybyBhcmUgImRlYWxsb2NhdGVkIiBoZXJl)
{
 let zero := 0
 let v := calldataload(zero)
 {
 let y := add(sload(v), 1)
 v := y
 } // y is "deallocated" here
 sstore(v, zero)
} // v and zero are "deallocated" here
If the declared variable should have a type different from the default type, you denote that following a colon. You can also declare multiple variables in one statement when you assign from a function call that returns multiple values.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.31&code=Ly8gVGhpcyB3aWxsIG5vdCBjb21waWxlICh1MzIgYW5kIHUyNTYgdHlwZSBub3QgaW1wbGVtZW50ZWQgeWV0KQp7CiAgICBsZXQgemVybzp1MzIgOj0gMDp1MzIKICAgIGxldCB2OnUyNTYsIHQ6dTMyIDo9IGYoKQogICAgbGV0IHgsIHkgOj0gZygpCn0=)
// This will not compile (u32 and u256 type not implemented yet)
{
 let zero:u32 := 0:u32
 let v:u256, t:u32 := f()
 let x, y := g()
}
Depending on the optimiser settings, the compiler can free the stack slots already after the variable has been used for the last time, even though it is still in scope.
### Assignments[](#assignments "Link to this heading")
Variables can be assigned to after their definition using the `:=` operator. It is possible to assign multiple variables at the same time. For this, the number and types of the values have to match. If you want to assign the values returned from a function that has multiple return parameters, you have to provide multiple variables. The same variable may not occur multiple times on the left-hand side of an assignment, e.g. `x, x := f()` is invalid.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.31&code=bGV0IHYgOj0gMAovLyByZS1hc3NpZ24gdgp2IDo9IDIKbGV0IHQgOj0gYWRkKHYsIDIpCmZ1bmN0aW9uIGYoKSAtPiBhLCBiIHsgfQovLyBhc3NpZ24gbXVsdGlwbGUgdmFsdWVzCnYsIHQgOj0gZigp)
let v := 0
// re-assign v
v := 2
let t := add(v, 2)
function f() \-> a, b { }
// assign multiple values
v, t := f()
### If[](#if "Link to this heading")
The if statement can be used for conditionally executing code. No “else” block can be defined. Consider using “switch” instead (see below) if you need multiple alternatives.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.31&code=aWYgbHQoY2FsbGRhdGFzaXplKCksIDQpIHsgcmV2ZXJ0KDAsIDApIH0=)
if lt(calldatasize(), 4) { revert(0, 0) }
The curly braces for the body are required.
### Switch[](#switch "Link to this heading")
You can use a switch statement as an extended version of the if statement. It takes the value of an expression and compares it to several literal constants. The branch corresponding to the matching constant is taken. Contrary to other programming languages, for safety reasons, control flow does not continue from one case to the next. There can be a fallback or default case called `default` which is taken if none of the literal constants matches.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.31&code=ewogICAgbGV0IHggOj0gMAogICAgc3dpdGNoIGNhbGxkYXRhbG9hZCg0KQogICAgY2FzZSAwIHsKICAgICAgICB4IDo9IGNhbGxkYXRhbG9hZCgweDI0KQogICAgfQogICAgZGVmYXVsdCB7CiAgICAgICAgeCA6PSBjYWxsZGF0YWxvYWQoMHg0NCkKICAgIH0KICAgIHNzdG9yZSgwLCBkaXYoeCwgMikpCn0=)
{
 let x := 0
 switch calldataload(4)
 case 0 {
 x := calldataload(0x24)
 }
 default {
 x := calldataload(0x44)
 }
 sstore(0, div(x, 2))
}
The list of cases is not enclosed by curly braces, but the body of a case does require them.
### Loops[](#loops "Link to this heading")
Yul supports for-loops which consist of a header containing an initializing part, a condition, a post-iteration part and a body. The condition has to be an expression, while the other three are blocks. If the initializing part declares any variables at the top level, the scope of these variables extends to all other parts of the loop.
The `break` and `continue` statements can be used in the body to exit the loop or skip to the post-part, respectively.
The following example computes the sum of an area in memory.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.31&code=ewogICAgbGV0IHggOj0gMAogICAgZm9yIHsgbGV0IGkgOj0gMCB9IGx0KGksIDB4MTAwKSB7IGkgOj0gYWRkKGksIDB4MjApIH0gewogICAgICAgIHggOj0gYWRkKHgsIG1sb2FkKGkpKQogICAgfQp9)
{
 let x := 0
 for { let i := 0 } lt(i, 0x100) { i := add(i, 0x20) } {
 x := add(x, mload(i))
 }
}
For loops can also be used as a replacement for while loops: Simply leave the initialization and post-iteration parts empty.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.31&code=ewogICAgbGV0IHggOj0gMAogICAgbGV0IGkgOj0gMAogICAgZm9yIHsgfSBsdChpLCAweDEwMCkgeyB9IHsgICAgIC8vIHdoaWxlKGkgPCAweDEwMCkKICAgICAgICB4IDo9IGFkZCh4LCBtbG9hZChpKSkKICAgICAgICBpIDo9IGFkZChpLCAweDIwKQogICAgfQp9)
{
 let x := 0
 let i := 0
 for { } lt(i, 0x100) { } { // while(i < 0x100)
 x := add(x, mload(i))
 i := add(i, 0x20)
 }
}
### Function Declarations[](#function-declarations "Link to this heading")
Yul allows the definition of functions. These should not be confused with functions in Solidity since they are never part of an external interface of a contract and are part of a namespace separate from the one for Solidity functions.
For the EVM, Yul functions take their arguments (and a return PC) from the stack and also put the results onto the stack. User-defined functions and built-in functions are called in exactly the same way.
Functions can be defined anywhere and are visible in the block they are declared in. Inside a function, you cannot access local variables defined outside of that function.
Functions declare parameters and return variables, similar to Solidity. To return a value, you assign it to the return variable(s).
If you call a function that returns multiple values, you have to assign them to multiple variables using `a, b := f(x)` or `let a, b := f(x)`.
The `leave` statement can be used to exit the current function. It works like the `return` statement in other languages just that it does not take a value to return, it just exits the functions and the function will return whatever values are currently assigned to the return variable(s).
Note that the EVM dialect has a built-in function called `return` that quits the full execution context (internal message call) and not just the current yul function.
The following example implements the power function by square-and-multiply.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.31&code=ewogICAgZnVuY3Rpb24gcG93ZXIoYmFzZSwgZXhwb25lbnQpIC0+IHJlc3VsdCB7CiAgICAgICAgc3dpdGNoIGV4cG9uZW50CiAgICAgICAgY2FzZSAwIHsgcmVzdWx0IDo9IDEgfQogICAgICAgIGNhc2UgMSB7IHJlc3VsdCA6PSBiYXNlIH0KICAgICAgICBkZWZhdWx0IHsKICAgICAgICAgICAgcmVzdWx0IDo9IHBvd2VyKG11bChiYXNlLCBiYXNlKSwgZGl2KGV4cG9uZW50LCAyKSkKICAgICAgICAgICAgc3dpdGNoIG1vZChleHBvbmVudCwgMikKICAgICAgICAgICAgICAgIGNhc2UgMSB7IHJlc3VsdCA6PSBtdWwoYmFzZSwgcmVzdWx0KSB9CiAgICAgICAgfQogICAgfQp9)
{
 function power(base, exponent) \-> result {
 switch exponent
 case 0 { result := 1 }
 case 1 { result := base }
 default {
 result := power(mul(base, base), div(exponent, 2))
 switch mod(exponent, 2)
 case 1 { result := mul(base, result) }
 }
 }
}
## Specification of Yul[](#specification-of-yul "Link to this heading")
This chapter describes Yul code formally. Yul code is usually placed inside Yul objects, which are explained in their own chapter.
Block = '{' Statement\* '}'
Statement =
 Block |
 FunctionDefinition |
 VariableDeclaration |
 Assignment |
 If |
 Expression |
 Switch |
 ForLoop |
 BreakContinue |
 Leave
FunctionDefinition =
 'function' Identifier '(' TypedIdentifierList? ')'
 ( '->' TypedIdentifierList )? Block
VariableDeclaration =
 'let' TypedIdentifierList ( ':=' Expression )?
Assignment =
 IdentifierList ':=' Expression
Expression =
 FunctionCall | Identifier | Literal
If =
 'if' Expression Block
Switch =
 'switch' Expression ( Case+ Default? | Default )
Case =
 'case' Literal Block
Default =
 'default' Block
ForLoop =
 'for' Block Expression Block Block
BreakContinue =
 'break' | 'continue'
Leave = 'leave'
FunctionCall =
 Identifier '(' ( Expression ( ',' Expression )\* )? ')'
Identifier = \[a-zA-Z\_$\] \[a-zA-Z\_$0-9.\]\*
IdentifierList = Identifier ( ',' Identifier)\*
TypeName = Identifier
TypedIdentifierList = Identifier ( ':' TypeName )? ( ',' Identifier ( ':' TypeName )? )\*
Literal =
 (NumberLiteral | StringLiteral | TrueLiteral | FalseLiteral) ( ':' TypeName )?
NumberLiteral = HexNumber | DecimalNumber
StringLiteral = '"' (\[^"\\r\\n\\\\\] | '\\\\' .)\* '"'
TrueLiteral = 'true'
FalseLiteral = 'false'
HexNumber = '0x' \[0-9a-fA-F\]+
DecimalNumber = \[0-9\]+
### Restrictions on the Grammar[](#restrictions-on-the-grammar "Link to this heading")
Apart from those directly imposed by the grammar, the following restrictions apply:
Switches must have at least one case (including the default case). All case values need to have the same type and distinct values. If all possible values of the expression type are covered, a default case is not allowed (i.e. a switch with a `bool` expression that has both a true and a false case do not allow a default case).
Every expression evaluates to zero or more values. Identifiers and Literals evaluate to exactly one value and function calls evaluate to a number of values equal to the number of return variables of the function called.
In variable declarations and assignments, the right-hand-side expression (if present) has to evaluate to a number of values equal to the number of variables on the left-hand-side. This is the only situation where an expression evaluating to more than one value is allowed. The same variable name cannot occur more than once in the left-hand-side of an assignment or variable declaration.
Expressions that are also statements (i.e. at the block level) have to evaluate to zero values.
In all other situations, expressions have to evaluate to exactly one value.
A `continue` or `break` statement can only be used inside the body of a for-loop, as follows. Consider the innermost loop that contains the statement. The loop and the statement must be in the same function, or both must be at the top level. The statement must be in the loop’s body block; it cannot be in the loop’s initialization block or update block. It is worth emphasizing that this restriction applies just to the innermost loop that contains the `continue` or `break` statement: this innermost loop, and therefore the `continue` or `break` statement, may appear anywhere in an outer loop, possibly in an outer loop’s initialization block or update block. For example, the following is legal, because the `break` occurs in the body block of the inner loop, despite also occurring in the update block of the outer loop:
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.31&code=Zm9yIHt9IHRydWUgeyBmb3Ige30gdHJ1ZSB7fSB7IGJyZWFrIH0gfQp7Cn0=)
for {} true { for {} true {} { break } }
{
}
The condition part of the for-loop has to evaluate to exactly one value.
The `leave` statement can only be used inside a function.
Functions cannot be defined anywhere inside for loop init blocks.
Literals cannot be larger than their type. The largest type defined is 256-bit wide.
During assignments and function calls, the types of the respective values have to match. There is no implicit type conversion. Type conversion in general can only be achieved if the dialect provides an appropriate built-in function that takes a value of one type and returns a value of a different type.
### Scoping Rules[](#scoping-rules "Link to this heading")
Scopes in Yul are tied to Blocks (exceptions are functions and the for loop as explained below) and all declarations (`FunctionDefinition`, `VariableDeclaration`) introduce new identifiers into these scopes.
Identifiers are visible in the block they are defined in (including all sub-nodes and sub-blocks): Functions are visible in the whole block (even before their definitions) while variables are only visible starting from the statement after the `VariableDeclaration`.
In particular, variables cannot be referenced in the right hand side of their own variable declaration. Functions can be referenced already before their declaration (if they are visible).
As an exception to the general scoping rule, the scope of the “init” part of the for-loop (the first block) extends across all other parts of the for loop. This means that variables (and functions) declared in the init part (but not inside a block inside the init part) are visible in all other parts of the for-loop.
Identifiers declared in the other parts of the for loop respect the regular syntactical scoping rules.
This means a for-loop of the form `for { I... } C { P... } { B... }` is equivalent to `{ I... for {} C { P... } { B... } }`.
The parameters and return parameters of functions are visible in the function body and their names have to be distinct.
Inside functions, it is not possible to reference a variable that was declared outside of that function.
Shadowing is disallowed, i.e. you cannot declare an identifier at a point where another identifier with the same name is also visible, even if it is not possible to reference it because it was declared outside the current function.
### Formal Specification[](#formal-specification "Link to this heading")
We formally specify Yul by providing an evaluation function E overloaded on the various nodes of the AST. As builtin functions can have side effects, E takes two state objects and the AST node and returns two new state objects and a variable number of other values. The two state objects are the global state object (which in the context of the EVM is the memory, storage and state of the blockchain) and the local state object (the state of local variables, i.e. a segment of the stack in the EVM).
If the AST node is a statement, E returns the two state objects and a “mode”, which is used for the `break`, `continue` and `leave` statements. If the AST node is an expression, E returns the two state objects and as many values as the expression evaluates to.
The exact nature of the global state is unspecified for this high level description. The local state `L` is a mapping of identifiers `i` to values `v`, denoted as `L[i] = v`.
For an identifier `v`, let `$v` be the name of the identifier.
We will use a destructuring notation for the AST nodes.
E(G, L, <{St1, ..., Stn}>: Block) =
 let G1, L1, mode = E(G, L, St1, ..., Stn)
 let L2 be a restriction of L1 to the identifiers of L
 G1, L2, mode
E(G, L, St1, ..., Stn: Statement) =
 if n is zero:
 G, L, regular
 else:
 let G1, L1, mode = E(G, L, St1)
 if mode is regular then
 E(G1, L1, St2, ..., Stn)
 otherwise
 G1, L1, mode
E(G, L, FunctionDefinition) =
 G, L, regular
E(G, L, <let var\_1, ..., var\_n := rhs>: VariableDeclaration) =
 E(G, L, <var\_1, ..., var\_n := rhs>: Assignment)
E(G, L, <let var\_1, ..., var\_n>: VariableDeclaration) =
 let L1 be a copy of L where L1\[$var\_i\] = 0 for i = 1, ..., n
 G, L1, regular
E(G, L, <var\_1, ..., var\_n := rhs>: Assignment) =
 let G1, L1, v1, ..., vn = E(G, L, rhs)
 let L2 be a copy of L1 where L2\[$var\_i\] = vi for i = 1, ..., n
 G1, L2, regular
E(G, L, <for { i1, ..., in } condition post body>: ForLoop) =
 if n >= 1:
 let G1, L1, mode = E(G, L, i1, ..., in)
 // mode has to be regular or leave due to the syntactic restrictions
 if mode is leave then
 G1, L1 restricted to variables of L, leave
 otherwise
 let G2, L2, mode = E(G1, L1, for {} condition post body)
 G2, L2 restricted to variables of L, mode
 else:
 let G1, L1, v = E(G, L, condition)
 if v is false:
 G1, L1, regular
 else:
 let G2, L2, mode = E(G1, L, body)
 if mode is break:
 G2, L2, regular
 otherwise if mode is leave:
 G2, L2, leave
 else:
 G3, L3, mode = E(G2, L2, post)
 if mode is leave:
 G3, L3, leave
 otherwise
 E(G3, L3, for {} condition post body)
E(G, L, break: BreakContinue) =
 G, L, break
E(G, L, continue: BreakContinue) =
 G, L, continue
E(G, L, leave: Leave) =
 G, L, leave
E(G, L, <if condition body>: If) =
 let G0, L0, v = E(G, L, condition)
 if v is true:
 E(G0, L0, body)
 else:
 G0, L0, regular
E(G, L, <switch condition case l1:t1 st1 ... case ln:tn stn>: Switch) =
 E(G, L, switch condition case l1:t1 st1 ... case ln:tn stn default {})
E(G, L, <switch condition case l1:t1 st1 ... case ln:tn stn default st'>: Switch) =
 let G0, L0, v = E(G, L, condition)
 // i = 1 .. n
 // Evaluate literals, context doesn't matter
 let \_, \_, v1 = E(G0, L0, l1)
 ...
 let \_, \_, vn = E(G0, L0, ln)
 if there exists smallest i such that vi = v:
 E(G0, L0, sti)
 else:
 E(G0, L0, st')
E(G, L, <name>: Identifier) =
 G, L, L\[$name\]
E(G, L, <fname(arg1, ..., argn)>: FunctionCall) =
 G1, L1, vn = E(G, L, argn)
 ...
 G(n-1), L(n-1), v2 = E(G(n-2), L(n-2), arg2)
 Gn, Ln, v1 = E(G(n-1), L(n-1), arg1)
 Let <function fname (param1, ..., paramn) -> ret1, ..., retm block>
 be the function of name $fname visible at the point of the call.
 Let L' be a new local state such that
 L'\[$parami\] = vi and L'\[$reti\] = 0 for all i.
 Let G'', L'', mode = E(Gn, L', block)
 G'', Ln, L''\[$ret1\], ..., L''\[$retm\]
E(G, L, l: StringLiteral) = G, L, str(l),
 where str is the string evaluation function,
 which for the EVM dialect is defined in the section 'Literals' above
E(G, L, n: HexNumber) = G, L, hex(n)
 where hex is the hexadecimal evaluation function,
 which turns a sequence of hexadecimal digits into their big endian value
E(G, L, n: DecimalNumber) = G, L, dec(n),
 where dec is the decimal evaluation function,
 which turns a sequence of decimal digits into their big endian value
### EVM Dialect[](#evm-dialect "Link to this heading")
The default dialect of Yul currently is the EVM dialect for the currently selected version of the EVM. The only type available in this dialect is `u256`, the 256-bit native type of the Ethereum Virtual Machine. Since it is the default type of this dialect, it can be omitted.
The following table lists all builtin functions (depending on the EVM version) and provides a short description of the semantics of the function / opcode. This document does not want to be a full description of the Ethereum virtual machine. Please refer to a different document if you are interested in the precise semantics.
Opcodes marked with `-` do not return a result and all others return exactly one value. Opcodes marked with `F`, `H`, `B`, `C`, `I`, `L`, `P` and `N` are present since Frontier, Homestead, Byzantium, Constantinople, Istanbul, London, Paris or Cancun respectively.
In the following, `mem[a...b)` signifies the bytes of memory starting at position `a` up to but not including position `b`, `storage[p]` signifies the storage contents at slot `p`, and similarly, `transientStorage[p]` signifies the transient storage contents at slot `p`.
Since Yul manages local variables and control-flow, opcodes that interfere with these features are not available. This includes the `dup` and `swap` instructions as well as `jump` instructions, labels and the `push` instructions.
Instruction
Explanation
stop()
\-
F
stop execution, identical to return(0, 0)
add(x, y)
F
x + y
sub(x, y)
F
x - y
mul(x, y)
F
x \* y
div(x, y)
F
x / y or 0 if y == 0
sdiv(x, y)
F
x / y, for signed numbers in two’s complement, 0 if y == 0
mod(x, y)
F
x % y, 0 if y == 0
smod(x, y)
F
x % y, for signed numbers in two’s complement, 0 if y == 0
exp(x, y)
F
x to the power of y
not(x)
F
bitwise “not” of x (every bit of x is negated)
lt(x, y)
F
1 if x < y, 0 otherwise
gt(x, y)
F
1 if x > y, 0 otherwise
slt(x, y)
F
1 if x < y, 0 otherwise, for signed numbers in two’s complement
sgt(x, y)
F
1 if x > y, 0 otherwise, for signed numbers in two’s complement
eq(x, y)
F
1 if x == y, 0 otherwise
iszero(x)
F
1 if x == 0, 0 otherwise
and(x, y)
F
bitwise “and” of x and y
or(x, y)
F
bitwise “or” of x and y
xor(x, y)
F
bitwise “xor” of x and y
byte(n, x)
F
nth byte of x, where the most significant byte is the 0th byte
shl(x, y)
C
logical shift left y by x bits
shr(x, y)
C
logical shift right y by x bits
sar(x, y)
C
signed arithmetic shift right y by x bits
addmod(x, y, m)
F
(x + y) % m with arbitrary precision arithmetic, 0 if m == 0
mulmod(x, y, m)
F
(x \* y) % m with arbitrary precision arithmetic, 0 if m == 0
signextend(i, x)
F
sign extend from (i\*8+7)th bit counting from least significant
keccak256(p, n)
F
keccak(mem\[p…(p+n)))
pop(x)
\-
F
discard value x
mload(p)
F
mem\[p…(p+32))
mstore(p, v)
\-
F
mem\[p…(p+32)) := v
mstore8(p, v)
\-
F
mem\[p\] := v & 0xff (only modifies a single byte)
sload(p)
F
storage\[p\]
sstore(p, v)
\-
F
storage\[p\] := v
tload(p)
N
transientStorage\[p\]
tstore(p, v)
\-
N
transientStorage\[p\] := v
msize()
F
size of memory, i.e. largest accessed memory index
gas()
F
gas still available to execution
address()
F
address of the current contract / execution context
balance(a)
F
wei balance at address a
selfbalance()
I
equivalent to balance(address()), but cheaper
caller()
F
call sender (excluding `delegatecall`)
callvalue()
F
wei sent together with the current call
calldataload(p)
F
call data starting from position p (32 bytes)
calldatasize()
F
size of call data in bytes
calldatacopy(t, f, s)
\-
F
copy s bytes from calldata at position f to mem at position t
codesize()
F
size of the code of the current contract / execution context
codecopy(t, f, s)
\-
F
copy s bytes from code at position f to mem at position t
extcodesize(a)
F
size of the code at address a
extcodecopy(a, t, f, s)
\-
F
like codecopy(t, f, s) but take code at address a
returndatasize()
B
size of the last returndata
returndatacopy(t, f, s)
\-
B
copy s bytes from returndata at position f to mem at position t
mcopy(t, f, s)
\-
N
copy s bytes from mem at position f to mem at position t
extcodehash(a)
C
code hash of address a
create(v, p, n)
F
create new contract with code mem\[p…(p+n)) and send v wei and return the new address; returns 0 on error
create2(v, p, n, s)
C
create new contract with code mem\[p…(p+n)) at address keccak256(0xff . this . s . keccak256(mem\[p…(p+n))) and send v wei and return the new address, where `0xff` is a 1 byte value, `this` is the current contract’s address as a 20 byte value and `s` is a big-endian 256-bit value; returns 0 on error
call(g, a, v, in, insize, out, outsize)
F
call contract at address a with input mem\[in…(in+insize)) providing g gas and v wei and output area mem\[out…(out+outsize)) returning 0 on error (eg. out of gas) and 1 on success [See more](#yul-call-return-area)
callcode(g, a, v, in, insize, out, outsize)
F
identical to `call` but only use the code from a and stay in the context of the current contract otherwise [See more](#yul-call-return-area)
delegatecall(g, a, in, insize, out, outsize)
H
identical to `callcode` but also keep `caller` and `callvalue` [See more](#yul-call-return-area)
staticcall(g, a, in, insize, out, outsize)
B
identical to `call(g, a, 0, in, insize, out, outsize)` but do not allow state modifications [See more](#yul-call-return-area)
return(p, s)
\-
F
end execution, return data mem\[p…(p+s))
revert(p, s)
\-
B
end execution, revert state changes, return data mem\[p…(p+s))
selfdestruct(a)
\-
F
end execution, destroy current contract and send funds to a (deprecated)
invalid()
\-
F
end execution with invalid instruction
log0(p, s)
\-
F
log data mem\[p…(p+s))
log1(p, s, t1)
\-
F
log data mem\[p…(p+s)) with topic t1
log2(p, s, t1, t2)
\-
F
log data mem\[p…(p+s)) with topics t1, t2
log3(p, s, t1, t2, t3)
\-
F
log data mem\[p…(p+s)) with topics t1, t2, t3
log4(p, s, t1, t2, t3, t4)
\-
F
log data mem\[p…(p+s)) with topics t1, t2, t3, t4
chainid()
I
ID of the executing chain (EIP-1344)
basefee()
L
current block’s base fee (EIP-3198 and EIP-1559)
blobbasefee()
N
current block’s blob base fee (EIP-7516 and EIP-4844)
origin()
F
transaction sender
gasprice()
F
gas price of the transaction
blockhash(b)
F
hash of block nr b - only for last 256 blocks excluding current
blobhash(i)
N
versioned hash of transaction’s i-th blob, 0 if blob does not exist
coinbase()
F
current mining beneficiary
timestamp()
F
timestamp of the current block in seconds since the epoch
number()
F
current block number
difficulty()
F
difficulty of the current block (see note below)
prevrandao()
P
randomness provided by the beacon chain (see note below)
gaslimit()
F
block gas limit of the current block
Note
The `call*` instructions use the `out` and `outsize` parameters to define an area in memory where the return or failure data is placed. This area is written to depending on how many bytes the called contract returns. If it returns more data, only the first `outsize` bytes are written. You can access the rest of the data using the `returndatacopy` opcode. If it returns less data, then the remaining bytes are not touched at all. You need to use the `returndatasize` opcode to check which part of this memory area contains the return data. The remaining bytes will retain their values as of before the call.
Note
The `difficulty()` instruction is disallowed in EVM version >= Paris. With the Paris network upgrade the semantics of the instruction that was previously called `difficulty` have been changed and the instruction was renamed to `prevrandao`. It can now return arbitrary values in the full 256-bit range, whereas the highest recorded difficulty value within Ethash was ~54 bits. This change is described in [EIP-4399](https://eips.ethereum.org/EIPS/eip-4399). Please note that irrelevant to which EVM version is selected in the compiler, the semantics of instructions depend on the final chain of deployment.
Warning
From version 0.8.18 and up, the use of `selfdestruct` in both Solidity and Yul will trigger a deprecation warning, since the `SELFDESTRUCT` opcode will eventually undergo breaking changes in behavior as stated in [EIP-6049](https://eips.ethereum.org/EIPS/eip-6049).
In some internal dialects, there are additional functions:
#### datasize, dataoffset, datacopy[](#datasize-dataoffset-datacopy "Link to this heading")
The functions `datasize(x)`, `dataoffset(x)` and `datacopy(t, f, l)` are used to access other parts of a Yul object.
`datasize` and `dataoffset` can only take string literals (the names of other objects) as arguments and return the size and offset in the data area, respectively. For the EVM, the `datacopy` function is equivalent to `codecopy`.
#### setimmutable, loadimmutable[](#setimmutable-loadimmutable "Link to this heading")
The functions `setimmutable(offset, "name", value)` and `loadimmutable("name")` are used for the immutable mechanism in Solidity and do not nicely map to pure Yul. The call to `setimmutable(offset, "name", value)` assumes that the runtime code of the contract containing the given named immutable was copied to memory at offset `offset` and will write `value` to all positions in memory (relative to `offset`) that contain the placeholder that was generated for calls to `loadimmutable("name")` in the runtime code.
#### linkersymbol[](#linkersymbol "Link to this heading")
The function `linkersymbol("library_id")` is a placeholder for an address literal to be substituted by the linker. Its first and only argument must be a string literal and uniquely represents the address to be inserted. Identifiers can be arbitrary but when the compiler produces Yul code from Solidity sources, it uses a library name qualified with the name of the source unit that defines that library. To link the code with a particular library address, the same identifier must be provided to the `--libraries` option on the command-line.
For example this code
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.31&code=bGV0IGEgOj0gbGlua2Vyc3ltYm9sKCJmaWxlLnNvbDpNYXRoIik=)
let a := linkersymbol("file.sol:Math")
is equivalent to
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.31&code=bGV0IGEgOj0gMHgxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkw)
let a := 0x1234567890123456789012345678901234567890
when the linker is invoked with `--libraries "file.sol:Math=0x1234567890123456789012345678901234567890` option.
See [Using the Commandline Compiler](https://docs.soliditylang.org/en/latest/using-the-compiler.html#commandline-compiler) for details about the Solidity linker.
#### memoryguard[](#memoryguard "Link to this heading")
This function is available in the EVM dialect with objects. The caller of `let ptr := memoryguard(size)` (where `size` has to be a literal number) promises that they only use memory in either the range `[0, size)` or the unbounded range starting at `ptr`.
Since the presence of a `memoryguard` call indicates that all memory access adheres to this restriction, it allows the optimizer to perform additional optimization steps, for example the stack limit evader, which attempts to move stack variables that would otherwise be unreachable to memory.
The Yul optimizer promises to only use the memory range `[size, ptr)` for its purposes. If the optimizer does not need to reserve any memory, it holds that `ptr == size`.
`memoryguard` can be called multiple times, but needs to have the same literal as argument within one Yul subobject. If at least one `memoryguard` call is found in a subobject, the additional optimiser steps will be run on it.
#### verbatim[](#verbatim "Link to this heading")
The set of `verbatim...` builtin functions lets you create bytecode for opcodes that are not known to the Yul compiler. It also allows you to create bytecode sequences that will not be modified by the optimizer.
The functions are `verbatim_<n>i_<m>o("<data>", ...)`, where
* `n` is a decimal between 0 and 99 that specifies the number of input stack slots / variables
 
* `m` is a decimal between 0 and 99 that specifies the number of output stack slots / variables
 
* `data` is a string literal that contains the sequence of bytes
 
If you for example want to define a function that multiplies the input by two, without the optimizer touching the constant two, you can use
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.31&code=bGV0IHggOj0gY2FsbGRhdGFsb2FkKDApCmxldCBkb3VibGUgOj0gdmVyYmF0aW1fMWlfMW8oaGV4IjYwMDIwMiIsIHgp)
let x := calldataload(0)
let double := verbatim\_1i\_1o(hex"600202", x)
This code will result in a `dup1` opcode to retrieve `x` (the optimizer might directly reuse result of the `calldataload` opcode, though) directly followed by `600202`. The code is assumed to consume the copied value of `x` and produce the result on the top of the stack. The compiler then generates code to allocate a stack slot for `double` and store the result there.
As with all opcodes, the arguments are arranged on the stack with the leftmost argument on the top, while the return values are assumed to be laid out such that the rightmost variable is at the top of the stack.
Since `verbatim` can be used to generate arbitrary opcodes or even opcodes unknown to the Solidity compiler, care has to be taken when using `verbatim` together with the optimizer. Even when the optimizer is switched off, the code generator has to determine the stack layout, which means that e.g. using `verbatim` to modify the stack height can lead to undefined behavior.
The following is a non-exhaustive list of restrictions on verbatim bytecode that are not checked by the compiler. Violations of these restrictions can result in undefined behavior.
* Control-flow should not jump into or out of verbatim blocks, but it can jump within the same verbatim block. In particular, reverting or returning from the block is _not_ allowed.
 
* Stack contents apart from the input and output parameters should not be accessed.
 
* The stack height difference should be exactly `m - n` (output slots minus input slots).
 
* Verbatim bytecode cannot make any assumptions about the surrounding bytecode. All required parameters have to be passed in as stack variables.
 
The optimizer does not analyze verbatim bytecode and always assumes that it modifies all aspects of state and thus can only do very few optimizations across `verbatim` function calls.
The optimizer treats verbatim bytecode as an opaque block of code. It will not split it but might move, duplicate or combine it with identical verbatim bytecode blocks. If a verbatim bytecode block is unreachable by the control-flow, it can be removed.
Warning
During discussions about whether or not EVM improvements might break existing smart contracts, features inside `verbatim` cannot receive the same consideration as those used by the Solidity compiler itself.
Note
To avoid confusion, all identifiers starting with the string `verbatim` are reserved and cannot be used for user-defined identifiers.
## Specification of Yul Object[](#specification-of-yul-object "Link to this heading")
Yul objects are used to group named code and data sections. The functions `datasize`, `dataoffset` and `datacopy` can be used to access these sections from within code. Hex strings can be used to specify data in hex encoding, regular strings in native encoding. For code, `datacopy` will access its assembled binary representation.
Object = 'object' StringLiteral '{' Code ( Object | Data )\* '}'
Code = 'code' Block
Data = 'data' StringLiteral ( HexLiteral | StringLiteral )
HexLiteral = 'hex' ('"' (\[0-9a-fA-F\]{2})\* '"' | '\\'' (\[0-9a-fA-F\]{2})\* '\\'')
StringLiteral = '"' (\[^"\\r\\n\\\\\] | '\\\\' .)\* '"'
Above, `Block` refers to `Block` in the Yul code grammar explained in the previous chapter.
Note
An object with a name that ends in `_deployed` is treated as deployed code by the Yul optimizer. The only consequence of this is a different gas cost heuristic in the optimizer.
Note
Data objects or sub-objects whose names contain a `.` can be defined but it is not possible to access them through `datasize`, `dataoffset` or `datacopy` because `.` is used as a separator to access objects inside another object.
Note
The data object called `".metadata"` has a special meaning: It cannot be accessed from code and is always appended to the very end of the bytecode, regardless of its position in the object.
Other data objects with special significance might be added in the future, but their names will always start with a `.`.
An example Yul Object is shown below:
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.31&code=Ly8gQSBjb250cmFjdCBjb25zaXN0cyBvZiBhIHNpbmdsZSBvYmplY3Qgd2l0aCBzdWItb2JqZWN0cyByZXByZXNlbnRpbmcKLy8gdGhlIGNvZGUgdG8gYmUgZGVwbG95ZWQgb3Igb3RoZXIgY29udHJhY3RzIGl0IGNhbiBjcmVhdGUuCi8vIFRoZSBzaW5nbGUgImNvZGUiIG5vZGUgaXMgdGhlIGV4ZWN1dGFibGUgY29kZSBvZiB0aGUgb2JqZWN0LgovLyBFdmVyeSAob3RoZXIpIG5hbWVkIG9iamVjdCBvciBkYXRhIHNlY3Rpb24gaXMgc2VyaWFsaXplZCBhbmQKLy8gbWFkZSBhY2Nlc3NpYmxlIHRvIHRoZSBzcGVjaWFsIGJ1aWx0LWluIGZ1bmN0aW9ucyBkYXRhY29weSAvIGRhdGFvZmZzZXQgLyBkYXRhc2l6ZQovLyBUaGUgY3VycmVudCBvYmplY3QsIHN1Yi1vYmplY3RzIGFuZCBkYXRhIGl0ZW1zIGluc2lkZSB0aGUgY3VycmVudCBvYmplY3QKLy8gYXJlIGluIHNjb3BlLgpvYmplY3QgIkNvbnRyYWN0MSIgewogICAgLy8gVGhpcyBpcyB0aGUgY29uc3RydWN0b3IgY29kZSBvZiB0aGUgY29udHJhY3QuCiAgICBjb2RlIHsKICAgICAgICBmdW5jdGlvbiBhbGxvY2F0ZShzaXplKSAtPiBwdHIgewogICAgICAgICAgICBwdHIgOj0gbWxvYWQoMHg0MCkKICAgICAgICAgICAgLy8gTm90ZSB0aGF0IFNvbGlkaXR5IGdlbmVyYXRlZCBJUiBjb2RlIHJlc2VydmVzIG1lbW9yeSBvZmZzZXQgYGAweDYwYGAgYXMgd2VsbCwgYnV0IGEgcHVyZSBZdWwgb2JqZWN0IGlzIGZyZWUgdG8gdXNlIG1lbW9yeSBhcyBpdCBjaG9vc2VzLgogICAgICAgICAgICBpZiBpc3plcm8ocHRyKSB7IHB0ciA6PSAweDYwIH0KICAgICAgICAgICAgbXN0b3JlKDB4NDAsIGFkZChwdHIsIHNpemUpKQogICAgICAgIH0KCiAgICAgICAgLy8gZmlyc3QgY3JlYXRlICJDb250cmFjdDIiCiAgICAgICAgbGV0IHNpemUgOj0gZGF0YXNpemUoIkNvbnRyYWN0MiIpCiAgICAgICAgbGV0IG9mZnNldCA6PSBhbGxvY2F0ZShzaXplKQogICAgICAgIC8vIFRoaXMgd2lsbCB0dXJuIGludG8gY29kZWNvcHkgZm9yIEVWTQogICAgICAgIGRhdGFjb3B5KG9mZnNldCwgZGF0YW9mZnNldCgiQ29udHJhY3QyIiksIHNpemUpCiAgICAgICAgLy8gY29uc3RydWN0b3IgcGFyYW1ldGVyIGlzIGEgc2luZ2xlIG51bWJlciAweDEyMzQKICAgICAgICBtc3RvcmUoYWRkKG9mZnNldCwgc2l6ZSksIDB4MTIzNCkKICAgICAgICBwb3AoY3JlYXRlKDAsIG9mZnNldCwgYWRkKHNpemUsIDMyKSkpCgogICAgICAgIC8vIG5vdyByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0ICh0aGUgY3VycmVudGx5CiAgICAgICAgLy8gZXhlY3V0aW5nIGNvZGUgaXMgdGhlIGNvbnN0cnVjdG9yIGNvZGUpCiAgICAgICAgc2l6ZSA6PSBkYXRhc2l6ZSgiQ29udHJhY3QxX2RlcGxveWVkIikKICAgICAgICBvZmZzZXQgOj0gYWxsb2NhdGUoc2l6ZSkKICAgICAgICAvLyBUaGlzIHdpbGwgdHVybiBpbnRvIGEgY29kZWNvcHkgZm9yIEVWTQogICAgICAgIGRhdGFjb3B5KG9mZnNldCwgZGF0YW9mZnNldCgiQ29udHJhY3QxX2RlcGxveWVkIiksIHNpemUpCiAgICAgICAgcmV0dXJuKG9mZnNldCwgc2l6ZSkKICAgIH0KCiAgICBkYXRhICJUYWJsZTIiIGhleCI0MTIzIgoKICAgIG9iamVjdCAiQ29udHJhY3QxX2RlcGxveWVkIiB7CiAgICAgICAgY29kZSB7CiAgICAgICAgICAgIGZ1bmN0aW9uIGFsbG9jYXRlKHNpemUpIC0+IHB0ciB7CiAgICAgICAgICAgICAgICBwdHIgOj0gbWxvYWQoMHg0MCkKICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBTb2xpZGl0eSBnZW5lcmF0ZWQgSVIgY29kZSByZXNlcnZlcyBtZW1vcnkgb2Zmc2V0IGBgMHg2MGBgIGFzIHdlbGwsIGJ1dCBhIHB1cmUgWXVsIG9iamVjdCBpcyBmcmVlIHRvIHVzZSBtZW1vcnkgYXMgaXQgY2hvb3Nlcy4KICAgICAgICAgICAgICAgIGlmIGlzemVybyhwdHIpIHsgcHRyIDo9IDB4NjAgfQogICAgICAgICAgICAgICAgbXN0b3JlKDB4NDAsIGFkZChwdHIsIHNpemUpKQogICAgICAgICAgICB9CgogICAgICAgICAgICAvLyBydW50aW1lIGNvZGUKCiAgICAgICAgICAgIG1zdG9yZSgwLCAiSGVsbG8sIFdvcmxkISIpCiAgICAgICAgICAgIHJldHVybigwLCAweDIwKQogICAgICAgIH0KICAgIH0KCiAgICAvLyBFbWJlZGRlZCBvYmplY3QuIFVzZSBjYXNlIGlzIHRoYXQgdGhlIG91dHNpZGUgaXMgYSBmYWN0b3J5IGNvbnRyYWN0LAogICAgLy8gYW5kIENvbnRyYWN0MiBpcyB0aGUgY29kZSB0byBiZSBjcmVhdGVkIGJ5IHRoZSBmYWN0b3J5CiAgICBvYmplY3QgIkNvbnRyYWN0MiIgewogICAgICAgIGNvZGUgewogICAgICAgICAgICAvLyBjb2RlIGhlcmUgLi4uCiAgICAgICAgfQoKICAgICAgICBvYmplY3QgIkNvbnRyYWN0Ml9kZXBsb3llZCIgewogICAgICAgICAgICBjb2RlIHsKICAgICAgICAgICAgICAgIC8vIGNvZGUgaGVyZSAuLi4KICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgZGF0YSAiVGFibGUxIiBoZXgiNDEyMyIKICAgIH0KfQ==)
// A contract consists of a single object with sub-objects representing
// the code to be deployed or other contracts it can create.
// The single "code" node is the executable code of the object.
// Every (other) named object or data section is serialized and
// made accessible to the special built-in functions datacopy / dataoffset / datasize
// The current object, sub-objects and data items inside the current object
// are in scope.
object "Contract1" {
 // This is the constructor code of the contract.
 code {
 function allocate(size) \-> ptr {
 ptr := mload(0x40)
 // Note that Solidity generated IR code reserves memory offset \`\`0x60\`\` as well, but a pure Yul object is free to use memory as it chooses.
 if iszero(ptr) { ptr := 0x60 }
 mstore(0x40, add(ptr, size))
 }
 // first create "Contract2"
 let size := datasize("Contract2")
 let offset := allocate(size)
 // This will turn into codecopy for EVM
 datacopy(offset, dataoffset("Contract2"), size)
 // constructor parameter is a single number 0x1234
 mstore(add(offset, size), 0x1234)
 pop(create(0, offset, add(size, 32)))
 // now return the runtime object (the currently
 // executing code is the constructor code)
 size := datasize("Contract1\_deployed")
 offset := allocate(size)
 // This will turn into a codecopy for EVM
 datacopy(offset, dataoffset("Contract1\_deployed"), size)
 return(offset, size)
 }
 data "Table2" hex"4123"
 object "Contract1\_deployed" {
 code {
 function allocate(size) \-> ptr {
 ptr := mload(0x40)
 // Note that Solidity generated IR code reserves memory offset \`\`0x60\`\` as well, but a pure Yul object is free to use memory as it chooses.
 if iszero(ptr) { ptr := 0x60 }
 mstore(0x40, add(ptr, size))
 }
 // runtime code
 mstore(0, "Hello, World!")
 return(0, 0x20)
 }
 }
 // Embedded object. Use case is that the outside is a factory contract,
 // and Contract2 is the code to be created by the factory
 object "Contract2" {
 code {
 // code here ...
 }
 object "Contract2\_deployed" {
 code {
 // code here ...
 }
 }
 data "Table1" hex"4123"
 }
}
## Yul Optimizer[](#yul-optimizer "Link to this heading")
The Yul optimizer operates on Yul code and uses the same language for input, output and intermediate states. This allows for easy debugging and verification of the optimizer.
Please refer to the general [optimizer documentation](https://docs.soliditylang.org/en/latest/internals/optimizer.html#optimizer) for more details about the different optimization stages and how to use the optimizer.
If you want to use Solidity in stand-alone Yul mode, you activate the optimizer using `--optimize` and optionally specify the [expected number of contract executions](https://docs.soliditylang.org/en/latest/internals/optimizer.html#optimizer-parameter-runs) with `--optimize-runs`:
solc \--strict-assembly \--optimize \--optimize-runs 200
In Solidity mode, the Yul optimizer is activated together with the regular optimizer.
### Optimization Step Sequence[](#optimization-step-sequence "Link to this heading")
Detailed information regarding the optimization sequence as well as a list of abbreviations is available in the [optimizer docs](https://docs.soliditylang.org/en/latest/internals/optimizer.html#optimizer-steps).
## Complete ERC20 Example[](#complete-erc20-example "Link to this heading")
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.31&code=b2JqZWN0ICJUb2tlbiIgewogICAgY29kZSB7CiAgICAgICAgLy8gU3RvcmUgdGhlIGNyZWF0b3IgaW4gc2xvdCB6ZXJvLgogICAgICAgIHNzdG9yZSgwLCBjYWxsZXIoKSkKCiAgICAgICAgLy8gRGVwbG95IHRoZSBjb250cmFjdAogICAgICAgIGRhdGFjb3B5KDAsIGRhdGFvZmZzZXQoInJ1bnRpbWUiKSwgZGF0YXNpemUoInJ1bnRpbWUiKSkKICAgICAgICByZXR1cm4oMCwgZGF0YXNpemUoInJ1bnRpbWUiKSkKICAgIH0KICAgIG9iamVjdCAicnVudGltZSIgewogICAgICAgIGNvZGUgewogICAgICAgICAgICAvLyBQcm90ZWN0aW9uIGFnYWluc3Qgc2VuZGluZyBFdGhlcgogICAgICAgICAgICByZXF1aXJlKGlzemVybyhjYWxsdmFsdWUoKSkpCgogICAgICAgICAgICAvLyBEaXNwYXRjaGVyCiAgICAgICAgICAgIHN3aXRjaCBzZWxlY3RvcigpCiAgICAgICAgICAgIGNhc2UgMHg3MGEwODIzMSAvKiAiYmFsYW5jZU9mKGFkZHJlc3MpIiAqLyB7CiAgICAgICAgICAgICAgICByZXR1cm5VaW50KGJhbGFuY2VPZihkZWNvZGVBc0FkZHJlc3MoMCkpKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGNhc2UgMHgxODE2MGRkZCAvKiAidG90YWxTdXBwbHkoKSIgKi8gewogICAgICAgICAgICAgICAgcmV0dXJuVWludCh0b3RhbFN1cHBseSgpKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGNhc2UgMHhhOTA1OWNiYiAvKiAidHJhbnNmZXIoYWRkcmVzcyx1aW50MjU2KSIgKi8gewogICAgICAgICAgICAgICAgdHJhbnNmZXIoZGVjb2RlQXNBZGRyZXNzKDApLCBkZWNvZGVBc1VpbnQoMSkpCiAgICAgICAgICAgICAgICByZXR1cm5UcnVlKCkKICAgICAgICAgICAgfQogICAgICAgICAgICBjYXNlIDB4MjNiODcyZGQgLyogInRyYW5zZmVyRnJvbShhZGRyZXNzLGFkZHJlc3MsdWludDI1NikiICovIHsKICAgICAgICAgICAgICAgIHRyYW5zZmVyRnJvbShkZWNvZGVBc0FkZHJlc3MoMCksIGRlY29kZUFzQWRkcmVzcygxKSwgZGVjb2RlQXNVaW50KDIpKQogICAgICAgICAgICAgICAgcmV0dXJuVHJ1ZSgpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgY2FzZSAweDA5NWVhN2IzIC8qICJhcHByb3ZlKGFkZHJlc3MsdWludDI1NikiICovIHsKICAgICAgICAgICAgICAgIGFwcHJvdmUoZGVjb2RlQXNBZGRyZXNzKDApLCBkZWNvZGVBc1VpbnQoMSkpCiAgICAgICAgICAgICAgICByZXR1cm5UcnVlKCkKICAgICAgICAgICAgfQogICAgICAgICAgICBjYXNlIDB4ZGQ2MmVkM2UgLyogImFsbG93YW5jZShhZGRyZXNzLGFkZHJlc3MpIiAqLyB7CiAgICAgICAgICAgICAgICByZXR1cm5VaW50KGFsbG93YW5jZShkZWNvZGVBc0FkZHJlc3MoMCksIGRlY29kZUFzQWRkcmVzcygxKSkpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgY2FzZSAweDQwYzEwZjE5IC8qICJtaW50KGFkZHJlc3MsdWludDI1NikiICovIHsKICAgICAgICAgICAgICAgIG1pbnQoZGVjb2RlQXNBZGRyZXNzKDApLCBkZWNvZGVBc1VpbnQoMSkpCiAgICAgICAgICAgICAgICByZXR1cm5UcnVlKCkKICAgICAgICAgICAgfQogICAgICAgICAgICBkZWZhdWx0IHsKICAgICAgICAgICAgICAgIHJldmVydCgwLCAwKQogICAgICAgICAgICB9CgogICAgICAgICAgICBmdW5jdGlvbiBtaW50KGFjY291bnQsIGFtb3VudCkgewogICAgICAgICAgICAgICAgcmVxdWlyZShjYWxsZWRCeU93bmVyKCkpCgogICAgICAgICAgICAgICAgbWludFRva2VucyhhbW91bnQpCiAgICAgICAgICAgICAgICBhZGRUb0JhbGFuY2UoYWNjb3VudCwgYW1vdW50KQogICAgICAgICAgICAgICAgZW1pdFRyYW5zZmVyKDAsIGFjY291bnQsIGFtb3VudCkKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiB0cmFuc2Zlcih0bywgYW1vdW50KSB7CiAgICAgICAgICAgICAgICBleGVjdXRlVHJhbnNmZXIoY2FsbGVyKCksIHRvLCBhbW91bnQpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gYXBwcm92ZShzcGVuZGVyLCBhbW91bnQpIHsKICAgICAgICAgICAgICAgIHJldmVydElmWmVyb0FkZHJlc3Moc3BlbmRlcikKICAgICAgICAgICAgICAgIHNldEFsbG93YW5jZShjYWxsZXIoKSwgc3BlbmRlciwgYW1vdW50KQogICAgICAgICAgICAgICAgZW1pdEFwcHJvdmFsKGNhbGxlcigpLCBzcGVuZGVyLCBhbW91bnQpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gdHJhbnNmZXJGcm9tKGZyb20sIHRvLCBhbW91bnQpIHsKICAgICAgICAgICAgICAgIGRlY3JlYXNlQWxsb3dhbmNlQnkoZnJvbSwgY2FsbGVyKCksIGFtb3VudCkKICAgICAgICAgICAgICAgIGV4ZWN1dGVUcmFuc2Zlcihmcm9tLCB0bywgYW1vdW50KQogICAgICAgICAgICB9CgogICAgICAgICAgICBmdW5jdGlvbiBleGVjdXRlVHJhbnNmZXIoZnJvbSwgdG8sIGFtb3VudCkgewogICAgICAgICAgICAgICAgcmV2ZXJ0SWZaZXJvQWRkcmVzcyh0bykKICAgICAgICAgICAgICAgIGRlZHVjdEZyb21CYWxhbmNlKGZyb20sIGFtb3VudCkKICAgICAgICAgICAgICAgIGFkZFRvQmFsYW5jZSh0bywgYW1vdW50KQogICAgICAgICAgICAgICAgZW1pdFRyYW5zZmVyKGZyb20sIHRvLCBhbW91bnQpCiAgICAgICAgICAgIH0KCgogICAgICAgICAgICAvKiAtLS0tLS0tLS0tIGNhbGxkYXRhIGRlY29kaW5nIGZ1bmN0aW9ucyAtLS0tLS0tLS0tLSAqLwogICAgICAgICAgICBmdW5jdGlvbiBzZWxlY3RvcigpIC0+IHMgewogICAgICAgICAgICAgICAgcyA6PSBkaXYoY2FsbGRhdGFsb2FkKDApLCAweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCkKICAgICAgICAgICAgfQoKICAgICAgICAgICAgZnVuY3Rpb24gZGVjb2RlQXNBZGRyZXNzKG9mZnNldCkgLT4gdiB7CiAgICAgICAgICAgICAgICB2IDo9IGRlY29kZUFzVWludChvZmZzZXQpCiAgICAgICAgICAgICAgICBpZiBpc3plcm8oaXN6ZXJvKGFuZCh2LCBub3QoMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmKSkpKSB7CiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0KDAsIDApCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gZGVjb2RlQXNVaW50KG9mZnNldCkgLT4gdiB7CiAgICAgICAgICAgICAgICBsZXQgcG9zIDo9IGFkZCg0LCBtdWwob2Zmc2V0LCAweDIwKSkKICAgICAgICAgICAgICAgIGlmIGx0KGNhbGxkYXRhc2l6ZSgpLCBhZGQocG9zLCAweDIwKSkgewogICAgICAgICAgICAgICAgICAgIHJldmVydCgwLCAwKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdiA6PSBjYWxsZGF0YWxvYWQocG9zKQogICAgICAgICAgICB9CiAgICAgICAgICAgIC8qIC0tLS0tLS0tLS0gY2FsbGRhdGEgZW5jb2RpbmcgZnVuY3Rpb25zIC0tLS0tLS0tLS0gKi8KICAgICAgICAgICAgZnVuY3Rpb24gcmV0dXJuVWludCh2KSB7CiAgICAgICAgICAgICAgICBtc3RvcmUoMCwgdikKICAgICAgICAgICAgICAgIHJldHVybigwLCAweDIwKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIHJldHVyblRydWUoKSB7CiAgICAgICAgICAgICAgICByZXR1cm5VaW50KDEpCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8qIC0tLS0tLS0tIGV2ZW50cyAtLS0tLS0tLS0tICovCiAgICAgICAgICAgIGZ1bmN0aW9uIGVtaXRUcmFuc2Zlcihmcm9tLCB0bywgYW1vdW50KSB7CiAgICAgICAgICAgICAgICBsZXQgc2lnbmF0dXJlSGFzaCA6PSAweGRkZjI1MmFkMWJlMmM4OWI2OWMyYjA2OGZjMzc4ZGFhOTUyYmE3ZjE2M2M0YTExNjI4ZjU1YTRkZjUyM2IzZWYKICAgICAgICAgICAgICAgIGVtaXRFdmVudChzaWduYXR1cmVIYXNoLCBmcm9tLCB0bywgYW1vdW50KQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGVtaXRBcHByb3ZhbChmcm9tLCBzcGVuZGVyLCBhbW91bnQpIHsKICAgICAgICAgICAgICAgIGxldCBzaWduYXR1cmVIYXNoIDo9IDB4OGM1YmUxZTVlYmVjN2Q1YmQxNGY3MTQyN2QxZTg0ZjNkZDAzMTRjMGY3YjIyOTFlNWIyMDBhYzhjN2MzYjkyNQogICAgICAgICAgICAgICAgZW1pdEV2ZW50KHNpZ25hdHVyZUhhc2gsIGZyb20sIHNwZW5kZXIsIGFtb3VudCkKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBlbWl0RXZlbnQoc2lnbmF0dXJlSGFzaCwgaW5kZXhlZDEsIGluZGV4ZWQyLCBub25JbmRleGVkKSB7CiAgICAgICAgICAgICAgICBtc3RvcmUoMCwgbm9uSW5kZXhlZCkKICAgICAgICAgICAgICAgIGxvZzMoMCwgMHgyMCwgc2lnbmF0dXJlSGFzaCwgaW5kZXhlZDEsIGluZGV4ZWQyKQogICAgICAgICAgICB9CgogICAgICAgICAgICAvKiAtLS0tLS0tLSBzdG9yYWdlIGxheW91dCAtLS0tLS0tLS0tICovCiAgICAgICAgICAgIGZ1bmN0aW9uIG93bmVyUG9zKCkgLT4gcCB7IHAgOj0gMCB9CiAgICAgICAgICAgIGZ1bmN0aW9uIHRvdGFsU3VwcGx5UG9zKCkgLT4gcCB7IHAgOj0gMSB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGFjY291bnRUb1N0b3JhZ2VPZmZzZXQoYWNjb3VudCkgLT4gb2Zmc2V0IHsKICAgICAgICAgICAgICAgIG9mZnNldCA6PSBhZGQoMHgxMDAwLCBhY2NvdW50KQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGFsbG93YW5jZVN0b3JhZ2VPZmZzZXQoYWNjb3VudCwgc3BlbmRlcikgLT4gb2Zmc2V0IHsKICAgICAgICAgICAgICAgIG9mZnNldCA6PSBhY2NvdW50VG9TdG9yYWdlT2Zmc2V0KGFjY291bnQpCiAgICAgICAgICAgICAgICBtc3RvcmUoMCwgb2Zmc2V0KQogICAgICAgICAgICAgICAgbXN0b3JlKDB4MjAsIHNwZW5kZXIpCiAgICAgICAgICAgICAgICBvZmZzZXQgOj0ga2VjY2FrMjU2KDAsIDB4NDApCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8qIC0tLS0tLS0tIHN0b3JhZ2UgYWNjZXNzIC0tLS0tLS0tLS0gKi8KICAgICAgICAgICAgZnVuY3Rpb24gb3duZXIoKSAtPiBvIHsKICAgICAgICAgICAgICAgIG8gOj0gc2xvYWQob3duZXJQb3MoKSkKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiB0b3RhbFN1cHBseSgpIC0+IHN1cHBseSB7CiAgICAgICAgICAgICAgICBzdXBwbHkgOj0gc2xvYWQodG90YWxTdXBwbHlQb3MoKSkKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBtaW50VG9rZW5zKGFtb3VudCkgewogICAgICAgICAgICAgICAgc3N0b3JlKHRvdGFsU3VwcGx5UG9zKCksIHNhZmVBZGQodG90YWxTdXBwbHkoKSwgYW1vdW50KSkKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBiYWxhbmNlT2YoYWNjb3VudCkgLT4gYmFsIHsKICAgICAgICAgICAgICAgIGJhbCA6PSBzbG9hZChhY2NvdW50VG9TdG9yYWdlT2Zmc2V0KGFjY291bnQpKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFRvQmFsYW5jZShhY2NvdW50LCBhbW91bnQpIHsKICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgOj0gYWNjb3VudFRvU3RvcmFnZU9mZnNldChhY2NvdW50KQogICAgICAgICAgICAgICAgc3N0b3JlKG9mZnNldCwgc2FmZUFkZChzbG9hZChvZmZzZXQpLCBhbW91bnQpKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGRlZHVjdEZyb21CYWxhbmNlKGFjY291bnQsIGFtb3VudCkgewogICAgICAgICAgICAgICAgbGV0IG9mZnNldCA6PSBhY2NvdW50VG9TdG9yYWdlT2Zmc2V0KGFjY291bnQpCiAgICAgICAgICAgICAgICBsZXQgYmFsIDo9IHNsb2FkKG9mZnNldCkKICAgICAgICAgICAgICAgIHJlcXVpcmUobHRlKGFtb3VudCwgYmFsKSkKICAgICAgICAgICAgICAgIHNzdG9yZShvZmZzZXQsIHN1YihiYWwsIGFtb3VudCkpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gYWxsb3dhbmNlKGFjY291bnQsIHNwZW5kZXIpIC0+IGFtb3VudCB7CiAgICAgICAgICAgICAgICBhbW91bnQgOj0gc2xvYWQoYWxsb3dhbmNlU3RvcmFnZU9mZnNldChhY2NvdW50LCBzcGVuZGVyKSkKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBzZXRBbGxvd2FuY2UoYWNjb3VudCwgc3BlbmRlciwgYW1vdW50KSB7CiAgICAgICAgICAgICAgICBzc3RvcmUoYWxsb3dhbmNlU3RvcmFnZU9mZnNldChhY2NvdW50LCBzcGVuZGVyKSwgYW1vdW50KQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGRlY3JlYXNlQWxsb3dhbmNlQnkoYWNjb3VudCwgc3BlbmRlciwgYW1vdW50KSB7CiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0IDo9IGFsbG93YW5jZVN0b3JhZ2VPZmZzZXQoYWNjb3VudCwgc3BlbmRlcikKICAgICAgICAgICAgICAgIGxldCBjdXJyZW50QWxsb3dhbmNlIDo9IHNsb2FkKG9mZnNldCkKICAgICAgICAgICAgICAgIHJlcXVpcmUobHRlKGFtb3VudCwgY3VycmVudEFsbG93YW5jZSkpCiAgICAgICAgICAgICAgICBzc3RvcmUob2Zmc2V0LCBzdWIoY3VycmVudEFsbG93YW5jZSwgYW1vdW50KSkKICAgICAgICAgICAgfQoKICAgICAgICAgICAgLyogLS0tLS0tLS0tLSB1dGlsaXR5IGZ1bmN0aW9ucyAtLS0tLS0tLS0tICovCiAgICAgICAgICAgIGZ1bmN0aW9uIGx0ZShhLCBiKSAtPiByIHsKICAgICAgICAgICAgICAgIHIgOj0gaXN6ZXJvKGd0KGEsIGIpKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGd0ZShhLCBiKSAtPiByIHsKICAgICAgICAgICAgICAgIHIgOj0gaXN6ZXJvKGx0KGEsIGIpKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIHNhZmVBZGQoYSwgYikgLT4gciB7CiAgICAgICAgICAgICAgICByIDo9IGFkZChhLCBiKQogICAgICAgICAgICAgICAgaWYgb3IobHQociwgYSksIGx0KHIsIGIpKSB7IHJldmVydCgwLCAwKSB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gY2FsbGVkQnlPd25lcigpIC0+IGNibyB7CiAgICAgICAgICAgICAgICBjYm8gOj0gZXEob3duZXIoKSwgY2FsbGVyKCkpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gcmV2ZXJ0SWZaZXJvQWRkcmVzcyhhZGRyKSB7CiAgICAgICAgICAgICAgICByZXF1aXJlKGFkZHIpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gcmVxdWlyZShjb25kaXRpb24pIHsKICAgICAgICAgICAgICAgIGlmIGlzemVybyhjb25kaXRpb24pIHsgcmV2ZXJ0KDAsIDApIH0KICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH0KfQ==)
object "Token" {
 code {
 // Store the creator in slot zero.
 sstore(0, caller())
 // Deploy the contract
 datacopy(0, dataoffset("runtime"), datasize("runtime"))
 return(0, datasize("runtime"))
 }
 object "runtime" {
 code {
 // Protection against sending Ether
 require(iszero(callvalue()))
 // Dispatcher
 switch selector()
 case 0x70a08231 /\* "balanceOf(address)" \*/ {
 returnUint(balanceOf(decodeAsAddress(0)))
 }
 case 0x18160ddd /\* "totalSupply()" \*/ {
 returnUint(totalSupply())
 }
 case 0xa9059cbb /\* "transfer(address,uint256)" \*/ {
 transfer(decodeAsAddress(0), decodeAsUint(1))
 returnTrue()
 }
 case 0x23b872dd /\* "transferFrom(address,address,uint256)" \*/ {
 transferFrom(decodeAsAddress(0), decodeAsAddress(1), decodeAsUint(2))
 returnTrue()
 }
 case 0x095ea7b3 /\* "approve(address,uint256)" \*/ {
 approve(decodeAsAddress(0), decodeAsUint(1))
 returnTrue()
 }
 case 0xdd62ed3e /\* "allowance(address,address)" \*/ {
 returnUint(allowance(decodeAsAddress(0), decodeAsAddress(1)))
 }
 case 0x40c10f19 /\* "mint(address,uint256)" \*/ {
 mint(decodeAsAddress(0), decodeAsUint(1))
 returnTrue()
 }
 default {
 revert(0, 0)
 }
 function mint(account, amount) {
 require(calledByOwner())
 mintTokens(amount)
 addToBalance(account, amount)
 emitTransfer(0, account, amount)
 }
 function transfer(to, amount) {
 executeTransfer(caller(), to, amount)
 }
 function approve(spender, amount) {
 revertIfZeroAddress(spender)
 setAllowance(caller(), spender, amount)
 emitApproval(caller(), spender, amount)
 }
 function transferFrom(from, to, amount) {
 decreaseAllowanceBy(from, caller(), amount)
 executeTransfer(from, to, amount)
 }
 function executeTransfer(from, to, amount) {
 revertIfZeroAddress(to)
 deductFromBalance(from, amount)
 addToBalance(to, amount)
 emitTransfer(from, to, amount)
 }
 /\* ---------- calldata decoding functions ----------- \*/
 function selector() \-> s {
 s := div(calldataload(0), 0x100000000000000000000000000000000000000000000000000000000)
 }
 function decodeAsAddress(offset) \-> v {
 v := decodeAsUint(offset)
 if iszero(iszero(and(v, not(0xffffffffffffffffffffffffffffffffffffffff)))) {
 revert(0, 0)
 }
 }
 function decodeAsUint(offset) \-> v {
 let pos := add(4, mul(offset, 0x20))
 if lt(calldatasize(), add(pos, 0x20)) {
 revert(0, 0)
 }
 v := calldataload(pos)
 }
 /\* ---------- calldata encoding functions ---------- \*/
 function returnUint(v) {
 mstore(0, v)
 return(0, 0x20)
 }
 function returnTrue() {
 returnUint(1)
 }
 /\* -------- events ---------- \*/
 function emitTransfer(from, to, amount) {
 let signatureHash := 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
 emitEvent(signatureHash, from, to, amount)
 }
 function emitApproval(from, spender, amount) {
 let signatureHash := 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925
 emitEvent(signatureHash, from, spender, amount)
 }
 function emitEvent(signatureHash, indexed1, indexed2, nonIndexed) {
 mstore(0, nonIndexed)
 log3(0, 0x20, signatureHash, indexed1, indexed2)
 }
 /\* -------- storage layout ---------- \*/
 function ownerPos() \-> p { p := 0 }
 function totalSupplyPos() \-> p { p := 1 }
 function accountToStorageOffset(account) \-> offset {
 offset := add(0x1000, account)
 }
 function allowanceStorageOffset(account, spender) \-> offset {
 offset := accountToStorageOffset(account)
 mstore(0, offset)
 mstore(0x20, spender)
 offset := keccak256(0, 0x40)
 }
 /\* -------- storage access ---------- \*/
 function owner() \-> o {
 o := sload(ownerPos())
 }
 function totalSupply() \-> supply {
 supply := sload(totalSupplyPos())
 }
 function mintTokens(amount) {
 sstore(totalSupplyPos(), safeAdd(totalSupply(), amount))
 }
 function balanceOf(account) \-> bal {
 bal := sload(accountToStorageOffset(account))
 }
 function addToBalance(account, amount) {
 let offset := accountToStorageOffset(account)
 sstore(offset, safeAdd(sload(offset), amount))
 }
 function deductFromBalance(account, amount) {
 let offset := accountToStorageOffset(account)
 let bal := sload(offset)
 require(lte(amount, bal))
 sstore(offset, sub(bal, amount))
 }
 function allowance(account, spender) \-> amount {
 amount := sload(allowanceStorageOffset(account, spender))
 }
 function setAllowance(account, spender, amount) {
 sstore(allowanceStorageOffset(account, spender), amount)
 }
 function decreaseAllowanceBy(account, spender, amount) {
 let offset := allowanceStorageOffset(account, spender)
 let currentAllowance := sload(offset)
 require(lte(amount, currentAllowance))
 sstore(offset, sub(currentAllowance, amount))
 }
 /\* ---------- utility functions ---------- \*/
 function lte(a, b) \-> r {
 r := iszero(gt(a, b))
 }
 function gte(a, b) \-> r {
 r := iszero(lt(a, b))
 }
 function safeAdd(a, b) \-> r {
 r := add(a, b)
 if or(lt(r, a), lt(r, b)) { revert(0, 0) }
 }
 function calledByOwner() \-> cbo {
 cbo := eq(owner(), caller())
 }
 function revertIfZeroAddress(addr) {
 require(addr)
 }
 function require(condition) {
 if iszero(condition) { revert(0, 0) }
 }
 }
 }
}

# [Solidity v0.6.0 Breaking Changes — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/060-breaking-changes.html) 
 _https://docs.soliditylang.org/en/v0.8.30/060-breaking-changes.html_

This section highlights the main breaking changes introduced in Solidity version 0.6.0, along with the reasoning behind the changes and how to update affected code. For the full list check [the release changelog](https://github.com/ethereum/solidity/releases/tag/v0.6.0).
## Changes the Compiler Might not Warn About[](#changes-the-compiler-might-not-warn-about "Link to this heading")
This section lists changes where the behavior of your code might change without the compiler telling you about it.
* The resulting type of an exponentiation is the type of the base. It used to be the smallest type that can hold both the type of the base and the type of the exponent, as with symmetric operations. Additionally, signed types are allowed for the base of the exponentiation.
 
## Explicitness Requirements[](#explicitness-requirements "Link to this heading")
This section lists changes where the code now needs to be more explicit, but the semantics do not change. For most of the topics the compiler will provide suggestions.
* Functions can now only be overridden when they are either marked with the `virtual` keyword or defined in an interface. Functions without implementation outside an interface have to be marked `virtual`. When overriding a function or modifier, the new keyword `override` must be used. When overriding a function or modifier defined in multiple parallel bases, all bases must be listed in parentheses after the keyword like so: `override(Base1, Base2)`.
 
* Member-access to `length` of arrays is now always read-only, even for storage arrays. It is no longer possible to resize storage arrays by assigning a new value to their length. Use `push()`, `push(value)` or `pop()` instead, or assign a full array, which will of course overwrite the existing content. The reason behind this is to prevent storage collisions of gigantic storage arrays.
 
* The new keyword `abstract` can be used to mark contracts as abstract. It has to be used if a contract does not implement all its functions. Abstract contracts cannot be created using the `new` operator, and it is not possible to generate bytecode for them during compilation.
 
* Libraries have to implement all their functions, not only the internal ones.
 
* The names of variables declared in inline assembly may no longer end in `_slot` or `_offset`.
 
* Variable declarations in inline assembly may no longer shadow any declaration outside the inline assembly block. If the name contains a dot, its prefix up to the dot may not conflict with any declaration outside the inline assembly block.
 
* In inline assembly, opcodes that do not take arguments are now represented as “built-in functions” instead of standalone identifiers. So `gas` is now `gas()`.
 
* State variable shadowing is now disallowed. A derived contract can only declare a state variable `x`, if there is no visible state variable with the same name in any of its bases.
 
## Semantic and Syntactic Changes[](#semantic-and-syntactic-changes "Link to this heading")
This section lists changes where you have to modify your code and it does something else afterwards.
* Conversions from external function types to `address` are now disallowed. Instead external function types have a member called `address`, similar to the existing `selector` member.
 
* The function `push(value)` for dynamic storage arrays does not return the new length anymore (it returns nothing).
 
* The unnamed function commonly referred to as “fallback function” was split up into a new fallback function that is defined using the `fallback` keyword and a receive ether function defined using the `receive` keyword.
 
 * If present, the receive ether function is called whenever the call data is empty (whether or not ether is received). This function is implicitly `payable`.
 
 * The new fallback function is called when no other function matches (if the receive ether function does not exist then this includes calls with empty call data). You can make this function `payable` or not. If it is not `payable` then transactions not matching any other function which send value will revert. You should only need to implement the new fallback function if you are following an upgrade or proxy pattern.
 
## New Features[](#new-features "Link to this heading")
This section lists things that were not possible prior to Solidity 0.6.0 or were more difficult to achieve.
* The [try/catch statement](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#try-catch) allows you to react on failed external calls.
 
* `struct` and `enum` types can be declared at file level.
 
* Array slices can be used for calldata arrays, for example `abi.decode(msg.data[4:], (uint, uint))` is a low-level way to decode the function call payload.
 
* Natspec supports multiple return parameters in developer documentation, enforcing the same naming check as `@param`.
 
* Yul and Inline Assembly have a new statement called `leave` that exits the current function.
 
* Conversions from `address` to `address payable` are now possible via `payable(x)`, where `x` must be of type `address`.
 
## Interface Changes[](#interface-changes "Link to this heading")
This section lists changes that are unrelated to the language itself, but that have an effect on the interfaces of the compiler. These may change the way how you use the compiler on the command-line, how you use its programmable interface, or how you analyze the output produced by it.
### New Error Reporter[](#new-error-reporter "Link to this heading")
A new error reporter was introduced, which aims at producing more accessible error messages on the command-line. It is enabled by default, but passing `--old-reporter` falls back to the deprecated old error reporter.
### Metadata Hash Options[](#metadata-hash-options "Link to this heading")
The compiler now appends the [IPFS](https://ipfs.io/) hash of the metadata file to the end of the bytecode by default (for details, see documentation on [contract metadata](https://docs.soliditylang.org/en/v0.8.30/metadata.html)). Before 0.6.0, the compiler appended the [Swarm](https://ethersphere.github.io/swarm-home/) hash by default, and in order to still support this behavior, the new command-line option `--metadata-hash` was introduced. It allows you to select the hash to be produced and appended, by passing either `ipfs` or `swarm` as value to the `--metadata-hash` command-line option. Passing the value `none` completely removes the hash.
These changes can also be used via the [Standard JSON Interface](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#compiler-api) and effect the metadata JSON generated by the compiler.
The recommended way to read the metadata is to read the last two bytes to determine the length of the CBOR encoding and perform a proper decoding on that data block as explained in the [metadata section](https://docs.soliditylang.org/en/v0.8.30/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode).
### Yul Optimizer[](#yul-optimizer "Link to this heading")
Together with the legacy bytecode optimizer, the [Yul](https://docs.soliditylang.org/en/v0.8.30/yul.html) optimizer is now enabled by default when you call the compiler with `--optimize`. It can be disabled by calling the compiler with `--no-optimize-yul`. This mostly affects code that uses ABI coder v2.
### C API Changes[](#c-api-changes "Link to this heading")
The client code that uses the C API of `libsolc` is now in control of the memory used by the compiler. To make this change consistent, `solidity_free` was renamed to `solidity_reset`, the functions `solidity_alloc` and `solidity_free` were added and `solidity_compile` now returns a string that must be explicitly freed via `solidity_free()`.
## How to update your code[](#how-to-update-your-code "Link to this heading")
This section gives detailed instructions on how to update prior code for every breaking change.
* Change `address(f)` to `f.address` for `f` being of external function type.
 
* Replace `function () external [payable] { ... }` by either `receive() external payable { ... }`, `fallback() external [payable] { ... }` or both. Prefer using a `receive` function only, whenever possible.
 
* Change `uint length = array.push(value)` to `array.push(value);`. The new length can be accessed via `array.length`.
 
* Change `array.length++` to `array.push()` to increase, and use `pop()` to decrease the length of a storage array.
 
* For every named return parameter in a function’s `@dev` documentation define a `@return` entry which contains the parameter’s name as the first word. E.g. if you have function `f()` defined like `function f() public returns (uint value)` and a `@dev` annotating it, document its return parameters like so: `@return value The return value.`. You can mix named and un-named return parameters documentation so long as the notices are in the order they appear in the tuple return type.
 
* Choose unique identifiers for variable declarations in inline assembly that do not conflict with declarations outside the inline assembly block.
 
* Add `virtual` to every non-interface function you intend to override. Add `virtual` to all functions without implementation outside interfaces. For single inheritance, add `override` to every overriding function. For multiple inheritance, add `override(A, B, ..)`, where you list all contracts that define the overridden function in the parentheses. When multiple bases define the same function, the inheriting contract must override all conflicting functions.
 
* In inline assembly, add `()` to all opcodes that do not otherwise accept an argument. For example, change `pc` to `pc()`, and `gas` to `gas()`.

# [Influences de la langue — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/language-influences.html) 
 _https://docs.soliditylang.org/fr/latest/language-influences.html_

[Solidity](https://docs.soliditylang.org/fr/latest/index.html)
Solidity est un [langage à virgule flottante](https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Curly-bracket_languages) qui a été influencé et inspiré par plusieurs langages de programmation bien connus.
Solidity est le plus profondément influencé par le C++, mais a également emprunté des concepts à des langages comme Python, JavaScript, et autres.
L’influence du C++ est visible dans la syntaxe des déclarations de variables, les boucles for, le concept de surcharge des fonctions, les conversions de type implicites et explicites et de nombreux autres détails.
Aux premiers jours du langage, Solidity était en partie influencé par JavaScript. Cela était dû à la détermination de la portée des variables au niveau des fonctions et à l’utilisation du mot-clé « var ». L’influence de JavaScript a été réduite à partir de la version 0.4.0. Maintenant, la principale similitude restante avec JavaScript est que les fonctions sont définies en utilisant le mot-clé `function`. Solidity prend également en charge la syntaxe et la sémantique de l’importation qui qui sont similaires à celles disponibles en JavaScript. En dehors de ces points, Solidity ressemble à la plupart des autres langages à accolades et n’a plus d’influence majeure de JavaScript.
Python a également influencé Solidity. Les modificateurs de Solidity ont été ajoutés en essayant de modéliser les décorateurs de Python avec plus d’efficacité. les décorateurs de Python avec une fonctionnalité beaucoup plus restreinte. De plus, l’héritage multiple, la linéarisation C3, et le mot-clé « super » sont tirés de Python, ainsi que la sémantique générale de l’assignation et des types de référence.

# [Solidity 合约示例 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/solidity-by-example.html) 
 _https://docs.soliditylang.org/zh-cn/latest/solidity-by-example.html_

## 投票合约[](#voting "此标题的永久链接")
下面的合约相当复杂，但展示了Solidity的很多特性。 它实现了一个投票合约。当然， 电子投票的主要问题是如何将投票权分配给正确的人以及如何防止人为操纵。 我们不会在这里解决所有的问题，但至少我们会展示如何进行委托投票， 与此同时，使计票是 **自动且完全透明的。**
我们的想法是为每张选票创建一份合约， 为每个选项提供一个简称。 然后，作为合约的创造者——即主席， 将给予每个地址单独的投票权。
地址后面的人可以选择自己投票，或者委托给他们信任的人来投票。
在投票时间结束时， `winningProposal()` 将返回拥有最大票数的提案。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwovLy8gQHRpdGxlIOWnlOaJmOaKleelqApjb250cmFjdCBCYWxsb3QgewogICAgLy8g6L+Z5aOw5piO5LqG5LiA5Liq5paw55qE5aSN5p2C57G75Z6L77yM55So5LqO56iN5ZCO5Y+Y6YeP44CCCiAgICAvLyDlroPnlKjmnaXooajnpLrkuIDkuKrpgInmsJHjgIIKICAgIHN0cnVjdCBWb3RlciB7CiAgICAgICAgdWludCB3ZWlnaHQ7IC8vIOiuoeelqOeahOadg+mHjQogICAgICAgIGJvb2wgdm90ZWQ7ICAvLyDoi6XkuLrnnJ/vvIzku6Pooajor6Xkurrlt7LmipXnpagKICAgICAgICBhZGRyZXNzIGRlbGVnYXRlOyAvLyDooqvlp5TmiZjkuroKICAgICAgICB1aW50IHZvdGU7ICAgLy8g5oqV56Wo5o+Q5qGI55qE57Si5byVCiAgICB9CgogICAgLy8g5o+Q5qGI55qE57G75Z6LCiAgICBzdHJ1Y3QgUHJvcG9zYWwgewogICAgICAgIGJ5dGVzMzIgbmFtZTsgICAvLyDnroDnp7DvvIjmnIDplb8zMuS4quWtl+iKgu+8iQogICAgICAgIHVpbnQgdm90ZUNvdW50OyAvLyDlvpfnpajmlbAKICAgIH0KCiAgICBhZGRyZXNzIHB1YmxpYyBjaGFpcnBlcnNvbjsKICAgIC8vIOi/meWjsOaYjuS6huS4gOS4queKtuaAgeWPmOmHj++8jOS4uuavj+S4quWPr+iDveeahOWcsOWdgOWtmOWCqOS4gOS4qiBgVm90ZXJg44CCCiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gVm90ZXIpIHB1YmxpYyB2b3RlcnM7CgogICAgLy8g5LiA5LiqIGBQcm9wb3NhbGAg57uT5p6E57G75Z6L55qE5Yqo5oCB5pWw57uE44CCCiAgICBQcm9wb3NhbFtdIHB1YmxpYyBwcm9wb3NhbHM7CgogICAgLy8vIOS4uiBgcHJvcG9zYWxOYW1lc2Ag5Lit55qE5q+P5Liq5o+Q5qGI77yM5Yib5bu65LiA5Liq5paw55qE77yI5oqV56Wo77yJ6KGo5YazCiAgICBjb25zdHJ1Y3RvcihieXRlczMyW10gbWVtb3J5IHByb3Bvc2FsTmFtZXMpIHsKICAgICAgICBjaGFpcnBlcnNvbiA9IG1zZy5zZW5kZXI7CiAgICAgICAgdm90ZXJzW2NoYWlycGVyc29uXS53ZWlnaHQgPSAxOwoKICAgICAgICAvLyDlr7nkuo7mj5DkvpvnmoTmr4/kuKrmj5DmoYjlkI3np7DvvIwKICAgICAgICAvLyDliJvlu7rkuIDkuKrmlrDnmoQgUHJvcG9zYWwg5a+56LGh5bm25oqK5a6D5re75Yqg5Yiw5pWw57uE55qE5pyr5bC+44CCCiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgcHJvcG9zYWxOYW1lcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAvLyBgUHJvcG9zYWwoey4uLn0pYCDliJvlu7rkuIDkuKrkuLTml7YgUHJvcG9zYWwg5a+56LGhCiAgICAgICAgICAgIC8vIGBwcm9wb3NhbHMucHVzaCguLi4pYCDlsIblhbbmt7vliqDliLAgYHByb3Bvc2Fsc2Ag55qE5pyr5bC+CiAgICAgICAgICAgIHByb3Bvc2Fscy5wdXNoKFByb3Bvc2FsKHsKICAgICAgICAgICAgICAgIG5hbWU6IHByb3Bvc2FsTmFtZXNbaV0sCiAgICAgICAgICAgICAgICB2b3RlQ291bnQ6IDAKICAgICAgICAgICAgfSkpOwogICAgICAgIH0KICAgIH0KCiAgICAvLyDnu5nkuoggYHZvdGVyYCDlnKjov5nlvKDpgInnpajkuIrmipXnpajnmoTmnYPliKnjgIIKICAgIC8vIOWPquaciSBgY2hhaXJwZXJzb25gIOWPr+S7peiwg+eUqOivpeWHveaVsOOAggogICAgZnVuY3Rpb24gZ2l2ZVJpZ2h0VG9Wb3RlKGFkZHJlc3Mgdm90ZXIpIGV4dGVybmFsIHsKICAgICAgICAvLyDoi6UgYHJlcXVpcmVgIOeahOesrOS4gOS4quWPguaVsOeahOiuoeeul+e7k+aenOS4uiBgZmFsc2Vg77yMCiAgICAgICAgLy8g5YiZ57uI5q2i5omn6KGM77yM5pKk6ZSA5omA5pyJ5a+554q25oCB5ZKM5Lul5aSq5biB5L2Z6aKd55qE5pS55Yqo44CCCiAgICAgICAgLy8g5Zyo5pen54mI55qEIEVWTSDkuK3ov5nmm77nu4/kvJrmtojogJfmiYDmnInnh4PmlpnvvIzkvYbnjrDlnKjkuI3kvJrkuobjgIIKICAgICAgICAvLyDkvb/nlKggYHJlcXVpcmVgIOadpeajgOafpeWHveaVsOaYr+WQpuiiq+ato+ehruWcsOiwg+eUqO+8jOmAmuW4uOaYr+S4quWlveS4u+aEj+OAggogICAgICAgIC8vIOaCqOS5n+WPr+S7peWcqCBgcmVxdWlyZWAg55qE56ys5LqM5Liq5Y+C5pWw5Lit5o+Q5L6b5LiA5Liq5a+56ZSZ6K+v5oOF5Ya155qE6Kej6YeK44CCCiAgICAgICAgcmVxdWlyZSgKICAgICAgICAgICAgbXNnLnNlbmRlciA9PSBjaGFpcnBlcnNvbiwKICAgICAgICAgICAgIk9ubHkgY2hhaXJwZXJzb24gY2FuIGdpdmUgcmlnaHQgdG8gdm90ZS4iCiAgICAgICAgKTsKICAgICAgICByZXF1aXJlKAogICAgICAgICAgICAhdm90ZXJzW3ZvdGVyXS52b3RlZCwKICAgICAgICAgICAgIlRoZSB2b3RlciBhbHJlYWR5IHZvdGVkLiIKICAgICAgICApOwogICAgICAgIHJlcXVpcmUodm90ZXJzW3ZvdGVyXS53ZWlnaHQgPT0gMCk7CiAgICAgICAgdm90ZXJzW3ZvdGVyXS53ZWlnaHQgPSAxOwogICAgfQoKICAgIC8vLyDmiormgqjnmoTmipXnpajlp5TmiZjnu5nmipXnpajogIUgYHRvYOOAggogICAgZnVuY3Rpb24gZGVsZWdhdGUoYWRkcmVzcyB0bykgZXh0ZXJuYWwgewogICAgICAgIC8vIOaMh+WumuW8leeUqAogICAgICAgIFZvdGVyIHN0b3JhZ2Ugc2VuZGVyID0gdm90ZXJzW21zZy5zZW5kZXJdOwogICAgICAgIHJlcXVpcmUoc2VuZGVyLndlaWdodCAhPSAwLCAiWW91IGhhdmUgbm8gcmlnaHQgdG8gdm90ZSIpOwogICAgICAgIHJlcXVpcmUoIXNlbmRlci52b3RlZCwgIllvdSBhbHJlYWR5IHZvdGVkLiIpOwoKICAgICAgICByZXF1aXJlKHRvICE9IG1zZy5zZW5kZXIsICJTZWxmLWRlbGVnYXRpb24gaXMgZGlzYWxsb3dlZC4iKTsKCiAgICAgICAgLy8g5aeU5omY5piv5Y+v5Lul5Lyg6YCS55qE77yM5Y+q6KaB6KKr5aeU5omY6ICFIGB0b2Ag5Lmf6K6+572u5LqG5aeU5omY44CCCiAgICAgICAgLy8g5LiA6Iis5p2l6K+077yM6L+Z5qC355qE5b6q546v5aeU5omY5piv6Z2e5bi45Y2x6Zmp55qE77yM5Zug5Li65aaC5p6c5Lyg6YCS55qE6ZO+5p2h5aSq6ZW/77yMCiAgICAgICAgLy8g5Y+v6IO96ZyA6KaB5raI6ICX55qE54eD5paZ5bCx5Lya6LaF6L+H5LiA5Liq5Yy65Z2X5Lit55qE5Y+v55So5pWw6YeP44CCCiAgICAgICAgLy8g6L+Z56eN5oOF5Ya15LiL77yM5aeU5omY5LiN5Lya6KKr5omn6KGM44CCCiAgICAgICAgLy8g5L2G5Zyo5YW25LuW5oOF5Ya15LiL77yM5aaC5p6c5b2i5oiQ6Zet546v77yM5YiZ5Lya5a+86Ie05ZCI57qm5a6M5YWo6KKrICLljaHkvY8i44CCCiAgICAgICAgd2hpbGUgKHZvdGVyc1t0b10uZGVsZWdhdGUgIT0gYWRkcmVzcygwKSkgewogICAgICAgICAgICB0byA9IHZvdGVyc1t0b10uZGVsZWdhdGU7CgogICAgICAgICAgICAvLyDkuI3lhYHorrjpl63njq/lp5TmiZgKICAgICAgICAgICAgcmVxdWlyZSh0byAhPSBtc2cuc2VuZGVyLCAiRm91bmQgbG9vcCBpbiBkZWxlZ2F0aW9uLiIpOwogICAgICAgIH0KCiAgICAgICAgVm90ZXIgc3RvcmFnZSBkZWxlZ2F0ZV8gPSB2b3RlcnNbdG9dOwoKICAgICAgICAvLyDmipXnpajogIXkuI3og73lsIbmipXnpajmnYPlp5TmiZjnu5nkuI3og73mipXnpajnmoTotKbmiLfjgIIKICAgICAgICByZXF1aXJlKGRlbGVnYXRlXy53ZWlnaHQgPj0gMSk7CgogICAgICAgIC8vIOeUseS6jiBgc2VuZGVyYCDmmK/kuIDkuKrlvJXnlKjvvIwKICAgICAgICAvLyDlm6DmraTov5nkvJrkv67mlLkgYHZvdGVyc1ttc2cuc2VuZGVyXWDjgIIKICAgICAgICBzZW5kZXIudm90ZWQgPSB0cnVlOwogICAgICAgIHNlbmRlci5kZWxlZ2F0ZSA9IHRvOwoKICAgICAgICBpZiAoZGVsZWdhdGVfLnZvdGVkKSB7CiAgICAgICAgICAgIC8vIOiLpeiiq+WnlOaJmOiAheW3sue7j+aKlei/h+elqOS6hu+8jOebtOaOpeWinuWKoOW+l+elqOaVsOOAggogICAgICAgICAgICBwcm9wb3NhbHNbZGVsZWdhdGVfLnZvdGVdLnZvdGVDb3VudCArPSBzZW5kZXIud2VpZ2h0OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8vIOiLpeiiq+WnlOaJmOiAhei/mOayoeaKleelqO+8jOWinuWKoOWnlOaJmOiAheeahOadg+mHjeOAggogICAgICAgICAgICBkZWxlZ2F0ZV8ud2VpZ2h0ICs9IHNlbmRlci53ZWlnaHQ7CiAgICAgICAgfQogICAgfQoKICAgIC8vLyDmiormgqjnmoTnpago5YyF5ous5aeU5omY57uZ5oKo55qE56WoKe+8jAogICAgLy8vIOaKlee7meaPkOahiCBgcHJvcG9zYWxzW3Byb3Bvc2FsXS5uYW1lYOOAggogICAgZnVuY3Rpb24gdm90ZSh1aW50IHByb3Bvc2FsKSBleHRlcm5hbCB7CiAgICAgICAgVm90ZXIgc3RvcmFnZSBzZW5kZXIgPSB2b3RlcnNbbXNnLnNlbmRlcl07CiAgICAgICAgcmVxdWlyZShzZW5kZXIud2VpZ2h0ICE9IDAsICJIYXMgbm8gcmlnaHQgdG8gdm90ZSIpOwogICAgICAgIHJlcXVpcmUoIXNlbmRlci52b3RlZCwgIkFscmVhZHkgdm90ZWQuIik7CiAgICAgICAgc2VuZGVyLnZvdGVkID0gdHJ1ZTsKICAgICAgICBzZW5kZXIudm90ZSA9IHByb3Bvc2FsOwoKICAgICAgICAvLyDlpoLmnpwgYHByb3Bvc2FsYCDotoXov4fkuobmlbDnu4TnmoTojIPlm7TvvIwKICAgICAgICAvLyDliJnkvJroh6rliqjmipvlh7rlvILluLjvvIzlubbmgaLlpI3miYDmnInnmoTmlLnliqjjgIIKICAgICAgICBwcm9wb3NhbHNbcHJvcG9zYWxdLnZvdGVDb3VudCArPSBzZW5kZXIud2VpZ2h0OwogICAgfQoKICAgIC8vLyBAZGV2IOe7k+WQiOS5i+WJjeaJgOacieaKleelqOeahOaDheWGteS4i++8jOiuoeeul+WHuuiOt+iDnOeahOaPkOahiOOAggogICAgZnVuY3Rpb24gd2lubmluZ1Byb3Bvc2FsKCkgcHVibGljIHZpZXcKICAgICAgICAgICAgcmV0dXJucyAodWludCB3aW5uaW5nUHJvcG9zYWxfKQogICAgewogICAgICAgIHVpbnQgd2lubmluZ1ZvdGVDb3VudCA9IDA7CiAgICAgICAgZm9yICh1aW50IHAgPSAwOyBwIDwgcHJvcG9zYWxzLmxlbmd0aDsgcCsrKSB7CiAgICAgICAgICAgIGlmIChwcm9wb3NhbHNbcF0udm90ZUNvdW50ID4gd2lubmluZ1ZvdGVDb3VudCkgewogICAgICAgICAgICAgICAgd2lubmluZ1ZvdGVDb3VudCA9IHByb3Bvc2Fsc1twXS52b3RlQ291bnQ7CiAgICAgICAgICAgICAgICB3aW5uaW5nUHJvcG9zYWxfID0gcDsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH0KCiAgICAvLyDosIPnlKggYHdpbm5pbmdQcm9wb3NhbCgpYCDlh73mlbDku6Xojrflj5bmj5DmoYjmlbDnu4TkuK3ojrfog5zogIXnmoTntKLlvJXvvIwKICAgIC8vIOW5tuS7peatpOi/lOWbnuiOt+iDnOiAheeahOWQjeensOOAggogICAgZnVuY3Rpb24gd2lubmVyTmFtZSgpIGV4dGVybmFsIHZpZXcKICAgICAgICAgICAgcmV0dXJucyAoYnl0ZXMzMiB3aW5uZXJOYW1lXykKICAgIHsKICAgICAgICB3aW5uZXJOYW1lXyA9IHByb3Bvc2Fsc1t3aW5uaW5nUHJvcG9zYWwoKV0ubmFtZTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
/// @title 委托投票
contract Ballot {
 // 这声明了一个新的复杂类型，用于稍后变量。
 // 它用来表示一个选民。
 struct Voter {
 uint weight; // 计票的权重
 bool voted; // 若为真，代表该人已投票
 address delegate; // 被委托人
 uint vote; // 投票提案的索引
 }
 // 提案的类型
 struct Proposal {
 bytes32 name; // 简称（最长32个字节）
 uint voteCount; // 得票数
 }
 address public chairperson;
 // 这声明了一个状态变量，为每个可能的地址存储一个 \`Voter\`。
 mapping(address \=> Voter) public voters;
 // 一个 \`Proposal\` 结构类型的动态数组。
 Proposal\[\] public proposals;
 /// 为 \`proposalNames\` 中的每个提案，创建一个新的（投票）表决
 constructor(bytes32\[\] memory proposalNames) {
 chairperson \= msg.sender;
 voters\[chairperson\].weight \= 1;
 // 对于提供的每个提案名称，
 // 创建一个新的 Proposal 对象并把它添加到数组的末尾。
 for (uint i \= 0; i < proposalNames.length; i++) {
 // \`Proposal({...})\` 创建一个临时 Proposal 对象
 // \`proposals.push(...)\` 将其添加到 \`proposals\` 的末尾
 proposals.push(Proposal({
 name: proposalNames\[i\],
 voteCount: 0
 }));
 }
 }
 // 给予 \`voter\` 在这张选票上投票的权利。
 // 只有 \`chairperson\` 可以调用该函数。
 function giveRightToVote(address voter) external {
 // 若 \`require\` 的第一个参数的计算结果为 \`false\`，
 // 则终止执行，撤销所有对状态和以太币余额的改动。
 // 在旧版的 EVM 中这曾经会消耗所有燃料，但现在不会了。
 // 使用 \`require\` 来检查函数是否被正确地调用，通常是个好主意。
 // 您也可以在 \`require\` 的第二个参数中提供一个对错误情况的解释。
 require(
 msg.sender \== chairperson,
 "Only chairperson can give right to vote."
 );
 require(
 !voters\[voter\].voted,
 "The voter already voted."
 );
 require(voters\[voter\].weight \== 0);
 voters\[voter\].weight \= 1;
 }
 /// 把您的投票委托给投票者 \`to\`。
 function delegate(address to) external {
 // 指定引用
 Voter storage sender \= voters\[msg.sender\];
 require(sender.weight != 0, "You have no right to vote");
 require(!sender.voted, "You already voted.");
 require(to != msg.sender, "Self-delegation is disallowed.");
 // 委托是可以传递的，只要被委托者 \`to\` 也设置了委托。
 // 一般来说，这样的循环委托是非常危险的，因为如果传递的链条太长，
 // 可能需要消耗的燃料就会超过一个区块中的可用数量。
 // 这种情况下，委托不会被执行。
 // 但在其他情况下，如果形成闭环，则会导致合约完全被 "卡住"。
 while (voters\[to\].delegate != address(0)) {
 to \= voters\[to\].delegate;
 // 不允许闭环委托
 require(to != msg.sender, "Found loop in delegation.");
 }
 Voter storage delegate\_ \= voters\[to\];
 // 投票者不能将投票权委托给不能投票的账户。
 require(delegate\_.weight \>= 1);
 // 由于 \`sender\` 是一个引用，
 // 因此这会修改 \`voters\[msg.sender\]\`。
 sender.voted \= true;
 sender.delegate \= to;
 if (delegate\_.voted) {
 // 若被委托者已经投过票了，直接增加得票数。
 proposals\[delegate\_.vote\].voteCount += sender.weight;
 } else {
 // 若被委托者还没投票，增加委托者的权重。
 delegate\_.weight += sender.weight;
 }
 }
 /// 把您的票(包括委托给您的票)，
 /// 投给提案 \`proposals\[proposal\].name\`。
 function vote(uint proposal) external {
 Voter storage sender \= voters\[msg.sender\];
 require(sender.weight != 0, "Has no right to vote");
 require(!sender.voted, "Already voted.");
 sender.voted \= true;
 sender.vote \= proposal;
 // 如果 \`proposal\` 超过了数组的范围，
 // 则会自动抛出异常，并恢复所有的改动。
 proposals\[proposal\].voteCount += sender.weight;
 }
 /// @dev 结合之前所有投票的情况下，计算出获胜的提案。
 function winningProposal() public view
 returns (uint winningProposal\_)
 {
 uint winningVoteCount \= 0;
 for (uint p \= 0; p < proposals.length; p++) {
 if (proposals\[p\].voteCount \> winningVoteCount) {
 winningVoteCount \= proposals\[p\].voteCount;
 winningProposal\_ \= p;
 }
 }
 }
 // 调用 \`winningProposal()\` 函数以获取提案数组中获胜者的索引，
 // 并以此返回获胜者的名称。
 function winnerName() external view
 returns (bytes32 winnerName\_)
 {
 winnerName\_ \= proposals\[winningProposal()\].name;
 }
}
### 可能的优化[](#id2 "此标题的永久链接")
当前，为了把投票权分配给所有参与者，需要执行很多交易。 此外，如果两个或更多的提案有相同的票数， `winningProposal()` 无法登记平局。 您能想出一个办法来解决这些问题吗？
## 盲拍（秘密竞价）[](#index-1 "此标题的永久链接")
在本节中，我们将展示如何轻松地在以太坊上创建一个盲拍的合约。 我们将从一个公开拍卖开始，每个人都可以看到出价， 然后将此合约扩展到盲拍合约， 在竞标期结束之前无法看到实际出价。
### 简单的公开拍卖[](#simple-auction "此标题的永久链接")
下面这个简单的拍卖合约的总体思路是，每个人都可以在竞标期间发送他们的竞标。 竞标已经包括发送的资金，例如以太币，以便将竞标者与他们的竞标绑定。 如果最高出价被提高，之前的最高出价者就会拿回他们的以太币。 竞价期结束后，受益人需要手动调用合约， 才能收到他们的以太币 - 合约不能自己激活接收。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKY29udHJhY3QgU2ltcGxlQXVjdGlvbiB7CiAgICAvLyDmi43ljZbnmoTlj4LmlbDjgIIKICAgIC8vIOaXtumXtOaYryB1bml4IOeahOe7neWvueaXtumXtOaIs++8iOiHqjE5NzAtMDEtMDHku6XmnaXnmoTnp5LmlbDvvIkKICAgIC8vIOaIluS7peenkuS4uuWNleS9jeeahOaXtumXtOauteOAggogICAgYWRkcmVzcyBwYXlhYmxlIHB1YmxpYyBiZW5lZmljaWFyeTsKICAgIHVpbnQgcHVibGljIGF1Y3Rpb25FbmRUaW1lOwoKICAgIC8vIOaLjeWNlueahOW9k+WJjeeKtuaAgeOAggogICAgYWRkcmVzcyBwdWJsaWMgaGlnaGVzdEJpZGRlcjsKICAgIHVpbnQgcHVibGljIGhpZ2hlc3RCaWQ7CgogICAgLy8g5YWB6K645Y+W5Zue5Lul5YmN55qE56ue5qCH44CCCiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gdWludCkgcGVuZGluZ1JldHVybnM7CgogICAgLy8g5ouN5Y2W57uT5p2f5ZCO6K6+5Li6IGB0cnVlYO+8jOWwhuemgeatouaJgOacieeahOWPmOabtAogICAgLy8g6buY6K6k5Yid5aeL5YyW5Li6IGBmYWxzZWDjgIIKICAgIGJvb2wgZW5kZWQ7CgogICAgLy8g5Y+Y5YyW5pe25bCG5Lya5Y+R5Ye655qE5LqL5Lu244CCCiAgICBldmVudCBIaWdoZXN0QmlkSW5jcmVhc2VkKGFkZHJlc3MgYmlkZGVyLCB1aW50IGFtb3VudCk7CiAgICBldmVudCBBdWN0aW9uRW5kZWQoYWRkcmVzcyB3aW5uZXIsIHVpbnQgYW1vdW50KTsKCiAgICAvLyDmj4/ov7DlpLHotKXnmoTplJnor6/kv6Hmga/jgIIKCiAgICAvLyDkuInmlpznur/nmoTms6jph4rmmK/miYDosJPnmoQgbmF0c3BlYyDms6jph4rjgIIKICAgIC8vIOW9k+eUqOaIt+iiq+imgeaxguehruiupOS4gOS4quS6pOaYk+aIluaYvuekuuS4gOS4qumUmeivr+aXtu+8jOWug+S7rOWwhuiiq+aYvuekuuOAggoKICAgIC8vLyDnq57mi43lt7Lnu4/nu5PmnZ/jgIIKICAgIGVycm9yIEF1Y3Rpb25BbHJlYWR5RW5kZWQoKTsKICAgIC8vLyDlt7Lnu4/mnInkuIDkuKrmm7Tpq5jnmoTmiJbnm7jnrYnnmoTlh7rku7fjgIIKICAgIGVycm9yIEJpZE5vdEhpZ2hFbm91Z2godWludCBoaWdoZXN0QmlkKTsKICAgIC8vLyDnq57mi43ov5jmsqHmnInnu5PmnZ/jgIIKICAgIGVycm9yIEF1Y3Rpb25Ob3RZZXRFbmRlZCgpOwogICAgLy8vIOWHveaVsCBhdWN0aW9uRW5kIOW3sue7j+iiq+iwg+eUqOOAggogICAgZXJyb3IgQXVjdGlvbkVuZEFscmVhZHlDYWxsZWQoKTsKCiAgICAvLy8g5Lul5Y+X55uK6ICF5Zyw5Z2AIGBiZW5lZmljaWFyeUFkZHJlc3NgIOWIm+W7uuS4gOS4queugOWNleeahOaLjeWNlu+8jAogICAgLy8vIOaLjeWNluaXtumVv+S4uiBgX2JpZGRpbmdUaW1lYOOAggogICAgY29uc3RydWN0b3IoCiAgICAgICAgdWludCBiaWRkaW5nVGltZSwKICAgICAgICBhZGRyZXNzIHBheWFibGUgYmVuZWZpY2lhcnlBZGRyZXNzCiAgICApIHsKICAgICAgICBiZW5lZmljaWFyeSA9IGJlbmVmaWNpYXJ5QWRkcmVzczsKICAgICAgICBhdWN0aW9uRW5kVGltZSA9IGJsb2NrLnRpbWVzdGFtcCArIGJpZGRpbmdUaW1lOwogICAgfQoKICAgIC8vLyDlr7nmi43ljZbov5vooYzlh7rku7fvvIzlhbfkvZPnmoTlh7rku7fpmo/kuqTmmJPkuIDotbflj5HpgIHjgIIKICAgIC8vLyDlpoLmnpzmsqHmnInlnKjmi43ljZbkuK3og5zlh7rvvIzliJnov5Tov5jlh7rku7fjgIIKICAgIGZ1bmN0aW9uIGJpZCgpIGV4dGVybmFsIHBheWFibGUgewogICAgICAgIC8vIOWPguaVsOS4jeaYr+W/heimgeeahOOAguWboOS4uuaJgOacieeahOS/oeaBr+W3sue7j+WMheWQq+WcqOS6huS6pOaYk+S4reOAggogICAgICAgIC8vIOWFs+mUruWtlyBgcGF5YWJsZWAg5piv5Ye95pWw6IO95aSf5o6l5pS25Lul5aSq5biB55qE5b+F6KaB5p2h5Lu244CCCgogICAgICAgIC8vIOWmguaenOaLjeWNluW3sue7k+adn++8jOaSpOmUgOWHveaVsOeahOiwg+eUqOOAggogICAgICAgIGlmIChibG9jay50aW1lc3RhbXAgPiBhdWN0aW9uRW5kVGltZSkKICAgICAgICAgICAgcmV2ZXJ0IEF1Y3Rpb25BbHJlYWR5RW5kZWQoKTsKCiAgICAgICAgLy8g5aaC5p6c5Ye65Lu35LiN6auY77yM5bCx5oqK5Lul5aSq5biB6L+U6L+Y5Zue5Y67CiAgICAgICAgLy/vvIhyZXZlcnTor63lj6XlsIbmgaLlpI3ov5nkuKrlh73mlbDmiafooYzkuK3nmoTmiYDmnInlj5jljJbvvIwKICAgICAgICAvLyDljIXmi6zlroPlt7Lnu4/mlLbliLDku6XlpKrluIHvvInjgIIKICAgICAgICBpZiAobXNnLnZhbHVlIDw9IGhpZ2hlc3RCaWQpCiAgICAgICAgICAgIHJldmVydCBCaWROb3RIaWdoRW5vdWdoKGhpZ2hlc3RCaWQpOwoKICAgICAgICBpZiAoaGlnaGVzdEJpZCAhPSAwKSB7CiAgICAgICAgICAgIC8vIOeugOWNleWcsOS9v+eUqCBoaWdoZXN0QmlkZGVyLnNlbmQoaGlnaGVzdEJpZCkKICAgICAgICAgICAgLy8g6L+U6L+Y5Lul5aSq5biB5pe277yM5piv5pyJ5a6J5YWo6aOO6Zmp55qE77yMCiAgICAgICAgICAgIC8vIOWboOS4uuWug+WPr+iDveaJp+ihjOS4gOS4quS4jeWPl+S/oeS7u+eahOWQiOe6puOAggogICAgICAgICAgICAvLyDorqnmjqXmlLbmlrnoh6rlt7Hlj5bku6XlpKrluIHmgLvmmK/mr5TovoPlronlhajnmoTjgIIKICAgICAgICAgICAgcGVuZGluZ1JldHVybnNbaGlnaGVzdEJpZGRlcl0gKz0gaGlnaGVzdEJpZDsKICAgICAgICB9CiAgICAgICAgaGlnaGVzdEJpZGRlciA9IG1zZy5zZW5kZXI7CiAgICAgICAgaGlnaGVzdEJpZCA9IG1zZy52YWx1ZTsKICAgICAgICBlbWl0IEhpZ2hlc3RCaWRJbmNyZWFzZWQobXNnLnNlbmRlciwgbXNnLnZhbHVlKTsKICAgIH0KCiAgICAvLy8g5pKk5Zue5Ye65Lu36L+H6auY55qE56ue5qCH44CCCiAgICBmdW5jdGlvbiB3aXRoZHJhdygpIGV4dGVybmFsIHJldHVybnMgKGJvb2wpIHsKICAgICAgICB1aW50IGFtb3VudCA9IHBlbmRpbmdSZXR1cm5zW21zZy5zZW5kZXJdOwogICAgICAgIGlmIChhbW91bnQgPiAwKSB7CiAgICAgICAgICAgIC8vIOWwhuWFtuiuvue9ruS4ujDmmK/lvojph43opoHnmoTvvIwKICAgICAgICAgICAgLy8g5Zug5Li65o6l5pS26ICF5Y+v5Lul5ZyoIGBzZW5kYCDov5Tlm57kuYvliY3lho3mrKHosIPnlKjov5nkuKrlh73mlbAKICAgICAgICAgICAgLy8g5L2c5Li65o6l5pS26LCD55So55qE5LiA6YOo5YiG44CCCiAgICAgICAgICAgIHBlbmRpbmdSZXR1cm5zW21zZy5zZW5kZXJdID0gMDsKCiAgICAgICAgICAgIC8vIG1zZy5zZW5kZXIg5LiN5bGe5LqOIGBhZGRyZXNzIHBheWFibGVgIOexu+Wei++8jAogICAgICAgICAgICAvLyDlv4Xpobvkvb/nlKggYHBheWFibGUobXNnLnNlbmRlcilgIOaYjuehrui9rOaNou+8jAogICAgICAgICAgICAvLyDku6Xkvr/kvb/nlKjmiJDlkZjlh73mlbAgYHNlbmQoKWDjgIIKICAgICAgICAgICAgaWYgKCFwYXlhYmxlKG1zZy5zZW5kZXIpLnNlbmQoYW1vdW50KSkgewogICAgICAgICAgICAgICAgLy8g6L+Z6YeM5LiN6ZyA5oqb5Ye65byC5bi477yM5Y+q6ZyA6YeN572u5pyq5LuY5qy+CiAgICAgICAgICAgICAgICBwZW5kaW5nUmV0dXJuc1ttc2cuc2VuZGVyXSA9IGFtb3VudDsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICAvLy8g57uT5p2f5ouN5Y2W77yM5bm25oqK5pyA6auY55qE5Ye65Lu35Y+R6YCB57uZ5Y+X55uK5Lq644CCCiAgICBmdW5jdGlvbiBhdWN0aW9uRW5kKCkgZXh0ZXJuYWwgewogICAgICAgIC8vIOWvueS6juWPr+S4juWFtuS7luWQiOe6puS6pOS6kueahOWHveaVsO+8iOaEj+WRs+edgOWug+S8muiwg+eUqOWFtuS7luWHveaVsOaIluWPkemAgeS7peWkquW4ge+8ie+8jAogICAgICAgIC8vIOS4gOS4quWlveeahOaMh+WvvOaWuemSiOaYr+WwhuWFtue7k+aehOWIhuS4uuS4ieS4qumYtuaute+8mgogICAgICAgIC8vIDEuIOajgOafpeadoeS7tgogICAgICAgIC8vIDIuIOaJp+ihjOWKqOS9nCAo5Y+v6IO95Lya5pS55Y+Y5p2h5Lu2KQogICAgICAgIC8vIDMuIOS4juWFtuS7luWQiOe6puS6pOS6kgogICAgICAgIC8vIOWmguaenOi/meS6m+mYtuauteebuOa3t+WQiO+8jOWFtuS7lueahOWQiOe6puWPr+iDveS8muWbnuiwg+W9k+WJjeWQiOe6puW5tuS/ruaUueeKtuaAge+8jAogICAgICAgIC8vIOaIluiAheWvvOiHtOafkOS6m+aViOaenO+8iOavlOWmguaUr+S7mOS7peWkquW4ge+8ieWkmuasoeeUn+aViOOAggogICAgICAgIC8vIOWmguaenOWQiOe6puWGheiwg+eUqOeahOWHveaVsOWMheWQq+S6huS4juWklumDqOWQiOe6pueahOS6pOS6ku+8jAogICAgICAgIC8vIOWImeWug+S5n+S8muiiq+iupOS4uuaYr+S4juWklumDqOWQiOe6puacieS6pOS6kueahOOAggoKICAgICAgICAvLyAxLiDmnaHku7YKICAgICAgICBpZiAoYmxvY2sudGltZXN0YW1wIDwgYXVjdGlvbkVuZFRpbWUpCiAgICAgICAgICAgIHJldmVydCBBdWN0aW9uTm90WWV0RW5kZWQoKTsKICAgICAgICBpZiAoZW5kZWQpCiAgICAgICAgICAgIHJldmVydCBBdWN0aW9uRW5kQWxyZWFkeUNhbGxlZCgpOwoKICAgICAgICAvLyAyLiDlvbHlk40KICAgICAgICBlbmRlZCA9IHRydWU7CiAgICAgICAgZW1pdCBBdWN0aW9uRW5kZWQoaGlnaGVzdEJpZGRlciwgaGlnaGVzdEJpZCk7CgogICAgICAgIC8vIDMuIOS6pOS6kgogICAgICAgIGJlbmVmaWNpYXJ5LnRyYW5zZmVyKGhpZ2hlc3RCaWQpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract SimpleAuction {
 // 拍卖的参数。
 // 时间是 unix 的绝对时间戳（自1970-01-01以来的秒数）
 // 或以秒为单位的时间段。
 address payable public beneficiary;
 uint public auctionEndTime;
 // 拍卖的当前状态。
 address public highestBidder;
 uint public highestBid;
 // 允许取回以前的竞标。
 mapping(address \=> uint) pendingReturns;
 // 拍卖结束后设为 \`true\`，将禁止所有的变更
 // 默认初始化为 \`false\`。
 bool ended;
 // 变化时将会发出的事件。
 event HighestBidIncreased(address bidder, uint amount);
 event AuctionEnded(address winner, uint amount);
 // 描述失败的错误信息。
 // 三斜线的注释是所谓的 natspec 注释。
 // 当用户被要求确认一个交易或显示一个错误时，它们将被显示。
 /// 竞拍已经结束。
 error AuctionAlreadyEnded();
 /// 已经有一个更高的或相等的出价。
 error BidNotHighEnough(uint highestBid);
 /// 竞拍还没有结束。
 error AuctionNotYetEnded();
 /// 函数 auctionEnd 已经被调用。
 error AuctionEndAlreadyCalled();
 /// 以受益者地址 \`beneficiaryAddress\` 创建一个简单的拍卖，
 /// 拍卖时长为 \`\_biddingTime\`。
 constructor(
 uint biddingTime,
 address payable beneficiaryAddress
 ) {
 beneficiary \= beneficiaryAddress;
 auctionEndTime \= block.timestamp + biddingTime;
 }
 /// 对拍卖进行出价，具体的出价随交易一起发送。
 /// 如果没有在拍卖中胜出，则返还出价。
 function bid() external payable {
 // 参数不是必要的。因为所有的信息已经包含在了交易中。
 // 关键字 \`payable\` 是函数能够接收以太币的必要条件。
 // 如果拍卖已结束，撤销函数的调用。
 if (block.timestamp \> auctionEndTime)
 revert AuctionAlreadyEnded();
 // 如果出价不高，就把以太币返还回去
 //（revert语句将恢复这个函数执行中的所有变化，
 // 包括它已经收到以太币）。
 if (msg.value <= highestBid)
 revert BidNotHighEnough(highestBid);
 if (highestBid != 0) {
 // 简单地使用 highestBidder.send(highestBid)
 // 返还以太币时，是有安全风险的，
 // 因为它可能执行一个不受信任的合约。
 // 让接收方自己取以太币总是比较安全的。
 pendingReturns\[highestBidder\] += highestBid;
 }
 highestBidder \= msg.sender;
 highestBid \= msg.value;
 emit HighestBidIncreased(msg.sender, msg.value);
 }
 /// 撤回出价过高的竞标。
 function withdraw() external returns (bool) {
 uint amount \= pendingReturns\[msg.sender\];
 if (amount \> 0) {
 // 将其设置为0是很重要的，
 // 因为接收者可以在 \`send\` 返回之前再次调用这个函数
 // 作为接收调用的一部分。
 pendingReturns\[msg.sender\] \= 0;
 // msg.sender 不属于 \`address payable\` 类型，
 // 必须使用 \`payable(msg.sender)\` 明确转换，
 // 以便使用成员函数 \`send()\`。
 if (!payable(msg.sender).send(amount)) {
 // 这里不需抛出异常，只需重置未付款
 pendingReturns\[msg.sender\] \= amount;
 return false;
 }
 }
 return true;
 }
 /// 结束拍卖，并把最高的出价发送给受益人。
 function auctionEnd() external {
 // 对于可与其他合约交互的函数（意味着它会调用其他函数或发送以太币），
 // 一个好的指导方针是将其结构分为三个阶段：
 // 1. 检查条件
 // 2. 执行动作 (可能会改变条件)
 // 3. 与其他合约交互
 // 如果这些阶段相混合，其他的合约可能会回调当前合约并修改状态，
 // 或者导致某些效果（比如支付以太币）多次生效。
 // 如果合约内调用的函数包含了与外部合约的交互，
 // 则它也会被认为是与外部合约有交互的。
 // 1. 条件
 if (block.timestamp < auctionEndTime)
 revert AuctionNotYetEnded();
 if (ended)
 revert AuctionEndAlreadyCalled();
 // 2. 影响
 ended \= true;
 emit AuctionEnded(highestBidder, highestBid);
 // 3. 交互
 beneficiary.transfer(highestBid);
 }
}
### 盲拍（秘密竞拍）[](#id5 "此标题的永久链接")
之前的公开拍卖接下来将被扩展为盲目拍卖。 盲拍的好处是，在竞价期即将结束时没有时间压力。 在一个透明的计算平台上创建一个盲拍可能听起来是一个矛盾，但加密技术可以实现它。
在 **竞标期间**，竞标者实际上并没有发送他们的出价， 而只是发送一个哈希版本的出价。 由于目前几乎不可能找到两个（足够长的）值， 其哈希值是相等的，因此竞标者可通过该方式提交报价。 在竞标结束后， 竞标者必须公开他们的出价：他们发送未加密的值， 合约检查出价的哈希值是否与竞标期间提供的值相同。
另一个挑战是如何使拍卖同时做到 **绑定和秘密** ： 唯一能阻止竞标者在赢得拍卖后不支付以太币的方式是，让他们将以太币和竞标一起发出。 但由于资金转移在以太坊中不能被隐藏，因此任何人都可以看到转移的资金。
下面的合约通过接受任何大于最高出价的值来解决这个问题。 当然，因为这只能在揭示阶段进行检查，有些出价可能是 **无效** 的， 而这是有目的的（它甚至提供了一个明确的标志，以便在高价值的转移中进行无效的出价）： 竞标者可以通过设置几个或高或低的无效出价来迷惑竞争对手。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKY29udHJhY3QgQmxpbmRBdWN0aW9uIHsKICAgIHN0cnVjdCBCaWQgewogICAgICAgIGJ5dGVzMzIgYmxpbmRlZEJpZDsKICAgICAgICB1aW50IGRlcG9zaXQ7CiAgICB9CgogICAgYWRkcmVzcyBwYXlhYmxlIHB1YmxpYyBiZW5lZmljaWFyeTsKICAgIHVpbnQgcHVibGljIGJpZGRpbmdFbmQ7CiAgICB1aW50IHB1YmxpYyByZXZlYWxFbmQ7CiAgICBib29sIHB1YmxpYyBlbmRlZDsKCiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gQmlkW10pIHB1YmxpYyBiaWRzOwoKICAgIGFkZHJlc3MgcHVibGljIGhpZ2hlc3RCaWRkZXI7CiAgICB1aW50IHB1YmxpYyBoaWdoZXN0QmlkOwoKICAgIC8vIOWFgeiuuOWPluWbnuS7peWJjeeahOernuagh+OAggogICAgbWFwcGluZyhhZGRyZXNzID0+IHVpbnQpIHBlbmRpbmdSZXR1cm5zOwoKICAgIGV2ZW50IEF1Y3Rpb25FbmRlZChhZGRyZXNzIHdpbm5lciwgdWludCBoaWdoZXN0QmlkKTsKCiAgICAvLyDmj4/ov7DlpLHotKXnmoTplJnor6/kv6Hmga/jgIIKCiAgICAvLy8g6K+l5Ye95pWw6KKr6L+H5pep6LCD55So44CCCiAgICAvLy8g5ZyoIGB0aW1lYCDml7bpl7Tlho3or5XkuIDmrKHjgIIKICAgIGVycm9yIFRvb0Vhcmx5KHVpbnQgdGltZSk7CiAgICAvLy8g6K+l5Ye95pWw6KKr6L+H5pma6LCD55So44CCCiAgICAvLy8g5a6D5LiN6IO95ZyoIGB0aW1lYCDml7bpl7TkuYvlkI7ooqvosIPnlKjjgIIKICAgIGVycm9yIFRvb0xhdGUodWludCB0aW1lKTsKICAgIC8vLyDlh73mlbAgYXVjdGlvbkVuZCDlt7Lnu4/ooqvosIPnlKjjgIIKICAgIGVycm9yIEF1Y3Rpb25FbmRBbHJlYWR5Q2FsbGVkKCk7CgogICAgLy8g5L2/55SoIOS/rumlsOespu+8iG1vZGlmaWVy77yJIOWPr+S7peabtOS+v+aNt+eahOagoemqjOWHveaVsOeahOWFpeWPguOAggogICAgLy8gYG9ubHlCZWZvcmVgIOS8muiiq+eUqOS6juWQjumdoueahCBgYmlkYCDlh73mlbDvvJoKICAgIC8vIOaWsOeahOWHveaVsOS9k+aYr+eUsSBtb2RpZmllciDmnKzouqvnmoTlh73mlbDkvZPvvIzlhbbkuK1gX2Dooqvml6fnmoTlh73mlbDkvZPmiYDlj5bku6PjgIIKICAgIG1vZGlmaWVyIG9ubHlCZWZvcmUodWludCB0aW1lKSB7CiAgICAgICAgaWYgKGJsb2NrLnRpbWVzdGFtcCA+PSB0aW1lKSByZXZlcnQgVG9vTGF0ZSh0aW1lKTsKICAgICAgICBfOwogICAgfQogICAgbW9kaWZpZXIgb25seUFmdGVyKHVpbnQgdGltZSkgewogICAgICAgIGlmIChibG9jay50aW1lc3RhbXAgPD0gdGltZSkgcmV2ZXJ0IFRvb0Vhcmx5KHRpbWUpOwogICAgICAgIF87CiAgICB9CgogICAgY29uc3RydWN0b3IoCiAgICAgICAgdWludCBiaWRkaW5nVGltZSwKICAgICAgICB1aW50IHJldmVhbFRpbWUsCiAgICAgICAgYWRkcmVzcyBwYXlhYmxlIGJlbmVmaWNpYXJ5QWRkcmVzcwogICAgKSB7CiAgICAgICAgYmVuZWZpY2lhcnkgPSBiZW5lZmljaWFyeUFkZHJlc3M7CiAgICAgICAgYmlkZGluZ0VuZCA9IGJsb2NrLnRpbWVzdGFtcCArIGJpZGRpbmdUaW1lOwogICAgICAgIHJldmVhbEVuZCA9IGJpZGRpbmdFbmQgKyByZXZlYWxUaW1lOwogICAgfQoKICAgIC8vLyDlj6/ku6XpgJrov4cgYF9ibGluZGVkQmlkYCA9IGtlY2NhazI1Nih2YWx1ZSwgZmFrZSwgc2VjcmV0KQogICAgLy8vIOiuvue9ruS4gOS4quebsuaLjeOAggogICAgLy8vIOWPquacieWcqOWHuuS7t+aKq+mcsumYtuauteiiq+ato+ehruaKq+mcsu+8jOW3suWPkemAgeeahOS7peWkquW4geaJjeS8muiiq+mAgOi/mOOAggogICAgLy8vIOWmguaenOS4juWHuuS7t+S4gOi1t+WPkemAgeeahOS7peWkquW4geiHs+WwkeS4uiAidmFsdWUiIOS4lCAiZmFrZSIg5LiN5Li655yf77yM5YiZ5Ye65Lu35pyJ5pWI44CCCiAgICAvLy8g5bCGICJmYWtlIiDorr7nva7kuLogdHJ1ZSDvvIwKICAgIC8vLyDnhLblkI7lj5HpgIHmu6HotrPorqLph5Hph5Hpop3kvYblj4jkuI3kuI7lh7rku7fnm7jlkIznmoTph5Hpop3mmK/pmpDol4/lrp7pmYXlh7rku7fnmoTmlrnms5XjgIIKICAgIC8vLyDlkIzkuIDkuKrlnLDlnYDlj6/ku6XmlL7nva7lpJrkuKrlh7rku7fjgIIKICAgIGZ1bmN0aW9uIGJpZChieXRlczMyIGJsaW5kZWRCaWQpCiAgICAgICAgZXh0ZXJuYWwKICAgICAgICBwYXlhYmxlCiAgICAgICAgb25seUJlZm9yZShiaWRkaW5nRW5kKQogICAgewogICAgICAgIGJpZHNbbXNnLnNlbmRlcl0ucHVzaChCaWQoewogICAgICAgICAgICBibGluZGVkQmlkOiBibGluZGVkQmlkLAogICAgICAgICAgICBkZXBvc2l0OiBtc2cudmFsdWUKICAgICAgICB9KSk7CiAgICB9CgogICAgLy8vIOaKq+mcsuS9oOeahOebsuaLjeWHuuS7t+OAggogICAgLy8vIOWvueS6juaJgOacieato+ehruaKq+mcsueahOaXoOaViOWHuuS7t+S7peWPiumZpOacgOmrmOWHuuS7t+S7peWklueahOaJgOacieWHuuS7t++8jOaCqOmDveWwhuiOt+W+l+mAgOasvuOAggogICAgZnVuY3Rpb24gcmV2ZWFsKAogICAgICAgIHVpbnRbXSBjYWxsZGF0YSB2YWx1ZXMsCiAgICAgICAgYm9vbFtdIGNhbGxkYXRhIGZha2VzLAogICAgICAgIGJ5dGVzMzJbXSBjYWxsZGF0YSBzZWNyZXRzCiAgICApCiAgICAgICAgZXh0ZXJuYWwKICAgICAgICBvbmx5QWZ0ZXIoYmlkZGluZ0VuZCkKICAgICAgICBvbmx5QmVmb3JlKHJldmVhbEVuZCkKICAgIHsKICAgICAgICB1aW50IGxlbmd0aCA9IGJpZHNbbXNnLnNlbmRlcl0ubGVuZ3RoOwogICAgICAgIHJlcXVpcmUodmFsdWVzLmxlbmd0aCA9PSBsZW5ndGgpOwogICAgICAgIHJlcXVpcmUoZmFrZXMubGVuZ3RoID09IGxlbmd0aCk7CiAgICAgICAgcmVxdWlyZShzZWNyZXRzLmxlbmd0aCA9PSBsZW5ndGgpOwoKICAgICAgICB1aW50IHJlZnVuZDsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICAgICAgICBCaWQgc3RvcmFnZSBiaWRUb0NoZWNrID0gYmlkc1ttc2cuc2VuZGVyXVtpXTsKICAgICAgICAgICAgKHVpbnQgdmFsdWUsIGJvb2wgZmFrZSwgYnl0ZXMzMiBzZWNyZXQpID0KICAgICAgICAgICAgICAgICAgICAodmFsdWVzW2ldLCBmYWtlc1tpXSwgc2VjcmV0c1tpXSk7CiAgICAgICAgICAgIGlmIChiaWRUb0NoZWNrLmJsaW5kZWRCaWQgIT0ga2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQodmFsdWUsIGZha2UsIHNlY3JldCkpKSB7CiAgICAgICAgICAgICAgICAvLyDlh7rku7fmnKrog73mraPnoa7miqvpnLLjgIIKICAgICAgICAgICAgICAgIC8vIOS4jei/lOi/mOiuoumHkeOAggogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmVmdW5kICs9IGJpZFRvQ2hlY2suZGVwb3NpdDsKICAgICAgICAgICAgaWYgKCFmYWtlICYmIGJpZFRvQ2hlY2suZGVwb3NpdCA+PSB2YWx1ZSkgewogICAgICAgICAgICAgICAgaWYgKHBsYWNlQmlkKG1zZy5zZW5kZXIsIHZhbHVlKSkKICAgICAgICAgICAgICAgICAgICByZWZ1bmQgLT0gdmFsdWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8g5L2/5Y+R6YCB6ICF5LiN5Y+v6IO95YaN5qyh6K6k6aKG5ZCM5LiA56yU6K6i6YeR44CCCiAgICAgICAgICAgIGJpZFRvQ2hlY2suYmxpbmRlZEJpZCA9IGJ5dGVzMzIoMCk7CiAgICAgICAgfQogICAgICAgIHBheWFibGUobXNnLnNlbmRlcikudHJhbnNmZXIocmVmdW5kKTsKICAgIH0KCiAgICAvLy8g5pKk5Zue5Ye65Lu36L+H6auY55qE56ue5qCH44CCCiAgICBmdW5jdGlvbiB3aXRoZHJhdygpIGV4dGVybmFsIHsKICAgICAgICB1aW50IGFtb3VudCA9IHBlbmRpbmdSZXR1cm5zW21zZy5zZW5kZXJdOwogICAgICAgIGlmIChhbW91bnQgPiAwKSB7CiAgICAgICAgICAgIC8vIOi/memHjOW+iOmHjeimge+8jOmmluWFiOimgeiuvumbtuWAvOOAggogICAgICAgICAgICAvLyDlm6DkuLrvvIzkvZzkuLrmjqXmlLbosIPnlKjnmoTkuIDpg6jliIbvvIwKICAgICAgICAgICAgLy8g5o6l5pS26ICF5Y+v5Lul5ZyoIGB0cmFuc2ZlcmAg6L+U5Zue5LmL5YmN6YeN5paw6LCD55So6K+l5Ye95pWw44CCCiAgICAgICAgICAgIC8v77yI5Y+v5p+l55yL5LiK6Z2i5YWz5LqOIOadoeS7tiAtPiDlvbHlk40gLT4g5Lqk5LqSIOeahOagh+azqO+8iQogICAgICAgICAgICBwZW5kaW5nUmV0dXJuc1ttc2cuc2VuZGVyXSA9IDA7CgogICAgICAgICAgICBwYXlhYmxlKG1zZy5zZW5kZXIpLnRyYW5zZmVyKGFtb3VudCk7CiAgICAgICAgfQogICAgfQoKICAgIC8vLyDnu5PmnZ/mi43ljZbvvIzlubbmiormnIDpq5jnmoTlh7rku7flj5HpgIHnu5nlj5fnm4rkurrjgIIKICAgIGZ1bmN0aW9uIGF1Y3Rpb25FbmQoKQogICAgICAgIGV4dGVybmFsCiAgICAgICAgb25seUFmdGVyKHJldmVhbEVuZCkKICAgIHsKICAgICAgICBpZiAoZW5kZWQpIHJldmVydCBBdWN0aW9uRW5kQWxyZWFkeUNhbGxlZCgpOwogICAgICAgIGVtaXQgQXVjdGlvbkVuZGVkKGhpZ2hlc3RCaWRkZXIsIGhpZ2hlc3RCaWQpOwogICAgICAgIGVuZGVkID0gdHJ1ZTsKICAgICAgICBiZW5lZmljaWFyeS50cmFuc2ZlcihoaWdoZXN0QmlkKTsKICAgIH0KCiAgICAvLyDov5nmmK/kuIDkuKogImludGVybmFsIiDlh73mlbDvvIwKICAgIC8vIOaEj+WRs+edgOWug+WPquiDveWcqOacrOWQiOe6pu+8iOaIlue7p+aJv+WQiOe6pu+8ieWGheiiq+iwg+eUqOOAggogICAgZnVuY3Rpb24gcGxhY2VCaWQoYWRkcmVzcyBiaWRkZXIsIHVpbnQgdmFsdWUpIGludGVybmFsCiAgICAgICAgICAgIHJldHVybnMgKGJvb2wgc3VjY2VzcykKICAgIHsKICAgICAgICBpZiAodmFsdWUgPD0gaGlnaGVzdEJpZCkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIGlmIChoaWdoZXN0QmlkZGVyICE9IGFkZHJlc3MoMCkpIHsKICAgICAgICAgICAgLy8g6L+U6L+Y5LmL5YmN55qE5pyA6auY5Ye65Lu3CiAgICAgICAgICAgIHBlbmRpbmdSZXR1cm5zW2hpZ2hlc3RCaWRkZXJdICs9IGhpZ2hlc3RCaWQ7CiAgICAgICAgfQogICAgICAgIGhpZ2hlc3RCaWQgPSB2YWx1ZTsKICAgICAgICBoaWdoZXN0QmlkZGVyID0gYmlkZGVyOwogICAgICAgIHJldHVybiB0cnVlOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract BlindAuction {
 struct Bid {
 bytes32 blindedBid;
 uint deposit;
 }
 address payable public beneficiary;
 uint public biddingEnd;
 uint public revealEnd;
 bool public ended;
 mapping(address \=> Bid\[\]) public bids;
 address public highestBidder;
 uint public highestBid;
 // 允许取回以前的竞标。
 mapping(address \=> uint) pendingReturns;
 event AuctionEnded(address winner, uint highestBid);
 // 描述失败的错误信息。
 /// 该函数被过早调用。
 /// 在 \`time\` 时间再试一次。
 error TooEarly(uint time);
 /// 该函数被过晚调用。
 /// 它不能在 \`time\` 时间之后被调用。
 error TooLate(uint time);
 /// 函数 auctionEnd 已经被调用。
 error AuctionEndAlreadyCalled();
 // 使用 修饰符（modifier） 可以更便捷的校验函数的入参。
 // \`onlyBefore\` 会被用于后面的 \`bid\` 函数：
 // 新的函数体是由 modifier 本身的函数体，其中\`\_\`被旧的函数体所取代。
 modifier onlyBefore(uint time) {
 if (block.timestamp \>= time) revert TooLate(time);
 \_;
 }
 modifier onlyAfter(uint time) {
 if (block.timestamp <= time) revert TooEarly(time);
 \_;
 }
 constructor(
 uint biddingTime,
 uint revealTime,
 address payable beneficiaryAddress
 ) {
 beneficiary \= beneficiaryAddress;
 biddingEnd \= block.timestamp + biddingTime;
 revealEnd \= biddingEnd + revealTime;
 }
 /// 可以通过 \`\_blindedBid\` = keccak256(value, fake, secret)
 /// 设置一个盲拍。
 /// 只有在出价披露阶段被正确披露，已发送的以太币才会被退还。
 /// 如果与出价一起发送的以太币至少为 "value" 且 "fake" 不为真，则出价有效。
 /// 将 "fake" 设置为 true ，
 /// 然后发送满足订金金额但又不与出价相同的金额是隐藏实际出价的方法。
 /// 同一个地址可以放置多个出价。
 function bid(bytes32 blindedBid)
 external
 payable
 onlyBefore(biddingEnd)
 {
 bids\[msg.sender\].push(Bid({
 blindedBid: blindedBid,
 deposit: msg.value
 }));
 }
 /// 披露你的盲拍出价。
 /// 对于所有正确披露的无效出价以及除最高出价以外的所有出价，您都将获得退款。
 function reveal(
 uint\[\] calldata values,
 bool\[\] calldata fakes,
 bytes32\[\] calldata secrets
 )
 external
 onlyAfter(biddingEnd)
 onlyBefore(revealEnd)
 {
 uint length \= bids\[msg.sender\].length;
 require(values.length \== length);
 require(fakes.length \== length);
 require(secrets.length \== length);
 uint refund;
 for (uint i \= 0; i < length; i++) {
 Bid storage bidToCheck \= bids\[msg.sender\]\[i\];
 (uint value, bool fake, bytes32 secret) \=
 (values\[i\], fakes\[i\], secrets\[i\]);
 if (bidToCheck.blindedBid != keccak256(abi.encodePacked(value, fake, secret))) {
 // 出价未能正确披露。
 // 不返还订金。
 continue;
 }
 refund += bidToCheck.deposit;
 if (!fake && bidToCheck.deposit \>= value) {
 if (placeBid(msg.sender, value))
 refund \-= value;
 }
 // 使发送者不可能再次认领同一笔订金。
 bidToCheck.blindedBid \= bytes32(0);
 }
 payable(msg.sender).transfer(refund);
 }
 /// 撤回出价过高的竞标。
 function withdraw() external {
 uint amount \= pendingReturns\[msg.sender\];
 if (amount \> 0) {
 // 这里很重要，首先要设零值。
 // 因为，作为接收调用的一部分，
 // 接收者可以在 \`transfer\` 返回之前重新调用该函数。
 //（可查看上面关于 条件 -> 影响 -> 交互 的标注）
 pendingReturns\[msg.sender\] \= 0;
 payable(msg.sender).transfer(amount);
 }
 }
 /// 结束拍卖，并把最高的出价发送给受益人。
 function auctionEnd()
 external
 onlyAfter(revealEnd)
 {
 if (ended) revert AuctionEndAlreadyCalled();
 emit AuctionEnded(highestBidder, highestBid);
 ended \= true;
 beneficiary.transfer(highestBid);
 }
 // 这是一个 "internal" 函数，
 // 意味着它只能在本合约（或继承合约）内被调用。
 function placeBid(address bidder, uint value) internal
 returns (bool success)
 {
 if (value <= highestBid) {
 return false;
 }
 if (highestBidder != address(0)) {
 // 返还之前的最高出价
 pendingReturns\[highestBidder\] += highestBid;
 }
 highestBid \= value;
 highestBidder \= bidder;
 return true;
 }
}
## 安全的远程购买[](#index-2 "此标题的永久链接")
目前，远程购买商品需要多方相互信任。最简单的关系涉及一个卖家和一个买家。 买方希望从卖方那里收到一件物品，卖方希望得到金钱，例如以太币，作为回报。 这里面有问题的部分是的运输。没有办法确定物品是否到达买方手中。
有多种方法来解决这个问题，但都有这样或那样的不足之处。 在下面的例子中，双方都要把两倍价值于物品的资金放入合约中作为托管。 只要发生这种情况，以太币就会一直锁在合约里面，直到买方确认收到物品。 之后，买方会得到退回的资金（他们押金的一半），卖方得到三倍的资金（他们的押金加上物品的价值）。 这背后的想法是，双方都有动力去解决这个问题，否则他们的以太币就会被永远锁定。
这个合约当然不能解决问题，但它概述了如何在合约内使用类似状态机的构造。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKY29udHJhY3QgUHVyY2hhc2UgewogICAgdWludCBwdWJsaWMgdmFsdWU7CiAgICBhZGRyZXNzIHBheWFibGUgcHVibGljIHNlbGxlcjsKICAgIGFkZHJlc3MgcGF5YWJsZSBwdWJsaWMgYnV5ZXI7CgogICAgZW51bSBTdGF0ZSB7IENyZWF0ZWQsIExvY2tlZCwgUmVsZWFzZSwgSW5hY3RpdmUgfQogICAgLy8g54q25oCB5Y+Y6YeP55qE6buY6K6k5YC85piv56ys5LiA5Liq5oiQ5ZGY77yMYFN0YXRlLmNyZWF0ZWRg44CCCiAgICBTdGF0ZSBwdWJsaWMgc3RhdGU7CgogICAgbW9kaWZpZXIgY29uZGl0aW9uKGJvb2wgY29uZGl0aW9uXykgewogICAgICAgIHJlcXVpcmUoY29uZGl0aW9uXyk7CiAgICAgICAgXzsKICAgIH0KCiAgICAvLy8g5Y+q5pyJ5Lmw5pa55Y+v5Lul6LCD55So6L+Z5Liq5Ye95pWw44CCCiAgICBlcnJvciBPbmx5QnV5ZXIoKTsKICAgIC8vLyDlj6rmnInljZbmlrnlj6/ku6XosIPnlKjov5nkuKrlh73mlbDjgIIKICAgIGVycm9yIE9ubHlTZWxsZXIoKTsKICAgIC8vLyDlnKjlvZPliY3nirbmgIHkuIvkuI3og73osIPnlKjor6Xlh73mlbDjgIIKICAgIGVycm9yIEludmFsaWRTdGF0ZSgpOwogICAgLy8vIOaPkOS+m+eahOWAvOW/hemhu+aYr+WBtuaVsOOAggogICAgZXJyb3IgVmFsdWVOb3RFdmVuKCk7CgogICAgbW9kaWZpZXIgb25seUJ1eWVyKCkgewogICAgICAgIGlmIChtc2cuc2VuZGVyICE9IGJ1eWVyKQogICAgICAgICAgICByZXZlcnQgT25seUJ1eWVyKCk7CiAgICAgICAgXzsKICAgIH0KCiAgICBtb2RpZmllciBvbmx5U2VsbGVyKCkgewogICAgICAgIGlmIChtc2cuc2VuZGVyICE9IHNlbGxlcikKICAgICAgICAgICAgcmV2ZXJ0IE9ubHlTZWxsZXIoKTsKICAgICAgICBfOwogICAgfQoKICAgIG1vZGlmaWVyIGluU3RhdGUoU3RhdGUgc3RhdGVfKSB7CiAgICAgICAgaWYgKHN0YXRlICE9IHN0YXRlXykKICAgICAgICAgICAgcmV2ZXJ0IEludmFsaWRTdGF0ZSgpOwogICAgICAgIF87CiAgICB9CgogICAgZXZlbnQgQWJvcnRlZCgpOwogICAgZXZlbnQgUHVyY2hhc2VDb25maXJtZWQoKTsKICAgIGV2ZW50IEl0ZW1SZWNlaXZlZCgpOwogICAgZXZlbnQgU2VsbGVyUmVmdW5kZWQoKTsKCiAgICAvLyDnoa7kv50gYG1zZy52YWx1ZWAg5piv5LiA5Liq5YG25pWw44CCCiAgICAvLyDlpoLmnpzmmK/lpYfmlbDvvIzpmaTms5XkvJrmiKrmlq3jgIIKICAgIC8vIOmAmui/h+S5mOazleajgOafpeWug+S4jeaYr+S4gOS4quWlh+aVsOOAggogICAgY29uc3RydWN0b3IoKSBwYXlhYmxlIHsKICAgICAgICBzZWxsZXIgPSBwYXlhYmxlKG1zZy5zZW5kZXIpOwogICAgICAgIHZhbHVlID0gbXNnLnZhbHVlIC8gMjsKICAgICAgICBpZiAoKDIgKiB2YWx1ZSkgIT0gbXNnLnZhbHVlKQogICAgICAgICAgICByZXZlcnQgVmFsdWVOb3RFdmVuKCk7CiAgICB9CgogICAgLy8vIOe7iOatoui0reS5sOW5tuaUtuWbnuS7peWkquW4geOAggogICAgLy8vIOWPquiDveeUseWNluaWueWcqOWQiOe6puiiq+mUgeWumuWJjeiwg+eUqOOAggogICAgZnVuY3Rpb24gYWJvcnQoKQogICAgICAgIGV4dGVybmFsCiAgICAgICAgb25seVNlbGxlcgogICAgICAgIGluU3RhdGUoU3RhdGUuQ3JlYXRlZCkKICAgIHsKICAgICAgICBlbWl0IEFib3J0ZWQoKTsKICAgICAgICBzdGF0ZSA9IFN0YXRlLkluYWN0aXZlOwogICAgICAgIC8vIOaIkeS7rOWcqOi/memHjOebtOaOpeS9v+eUqCBgdHJhbnNmZXJg44CCCiAgICAgICAgLy8g5a6D5Y+v5Lul5a6J5YWo5Zyw6YeN5YWl44CCCiAgICAgICAgLy8g5Zug5Li65a6D5piv6L+Z5Liq5Ye95pWw5Lit55qE5pyA5ZCO5LiA5qyh6LCD55So77yMCiAgICAgICAgLy8g6ICM5LiU5oiR5Lus5bey57uP5pS55Y+Y5LqG54q25oCB44CCCiAgICAgICAgc2VsbGVyLnRyYW5zZmVyKGFkZHJlc3ModGhpcykuYmFsYW5jZSk7CiAgICB9CgogICAgLy8vIOS5sOaWueehruiupOi0reS5sOOAggogICAgLy8vIOS6pOaYk+W/hemhu+WMheaLrCBgMiAqIHZhbHVlYCDku6XlpKrluIHjgIIKICAgIC8vLyBFdGhlciDlsIbooqvplIHkvY/vvIznm7TliLDosIPnlKggY29uZmlybVJlY2VpdmVk44CCCiAgICBmdW5jdGlvbiBjb25maXJtUHVyY2hhc2UoKQogICAgICAgIGV4dGVybmFsCiAgICAgICAgaW5TdGF0ZShTdGF0ZS5DcmVhdGVkKQogICAgICAgIGNvbmRpdGlvbihtc2cudmFsdWUgPT0gKDIgKiB2YWx1ZSkpCiAgICAgICAgcGF5YWJsZQogICAgewogICAgICAgIGVtaXQgUHVyY2hhc2VDb25maXJtZWQoKTsKICAgICAgICBidXllciA9IHBheWFibGUobXNnLnNlbmRlcik7CiAgICAgICAgc3RhdGUgPSBTdGF0ZS5Mb2NrZWQ7CiAgICB9CgogICAgLy8vIOehruiupOaCqO+8iOS5sOaWue+8ieW3sue7j+aUtuWIsOS6huivpeeJqeWTgeOAggogICAgLy8vIOi/meWwhumHiuaUvumUgeWumueahOS7peWkquW4geOAggogICAgZnVuY3Rpb24gY29uZmlybVJlY2VpdmVkKCkKICAgICAgICBleHRlcm5hbAogICAgICAgIG9ubHlCdXllcgogICAgICAgIGluU3RhdGUoU3RhdGUuTG9ja2VkKQogICAgewogICAgICAgIGVtaXQgSXRlbVJlY2VpdmVkKCk7CiAgICAgICAgLy8g6aaW5YWI5pS55Y+Y54q25oCB5piv5b6I6YeN6KaB55qE77yM5ZCm5YiZ55qE6K+d77yMCiAgICAgICAgLy8g5LiL6Z2i5L2/55SoIGBzZW5kYCDosIPnlKjnmoTlkIjnuqblj6/ku6XlnKjov5nph4zlho3mrKHosIPnlKjjgIIKICAgICAgICBzdGF0ZSA9IFN0YXRlLlJlbGVhc2U7CgogICAgICAgIGJ1eWVyLnRyYW5zZmVyKHZhbHVlKTsKICAgIH0KCiAgICAvLy8g6K+l5Yqf6IO95Li65Y2W5a626YCA5qy+77yMCiAgICAvLy8g5Y2z6YCA6L+Y5Y2W5a626ZSB5a6a55qE6LWE6YeR44CCCiAgICBmdW5jdGlvbiByZWZ1bmRTZWxsZXIoKQogICAgICAgIGV4dGVybmFsCiAgICAgICAgb25seVNlbGxlcgogICAgICAgIGluU3RhdGUoU3RhdGUuUmVsZWFzZSkKICAgIHsKICAgICAgICBlbWl0IFNlbGxlclJlZnVuZGVkKCk7CiAgICAgICAgLy8g6aaW5YWI5pS55Y+Y54q25oCB5piv5b6I6YeN6KaB55qE77yM5ZCm5YiZ55qE6K+d77yMCiAgICAgICAgLy8g5LiL6Z2i5L2/55SoIGBzZW5kYCDosIPnlKjnmoTlkIjnuqblj6/ku6XlnKjov5nph4zlho3mrKHosIPnlKjjgIIKICAgICAgICBzdGF0ZSA9IFN0YXRlLkluYWN0aXZlOwoKICAgICAgICBzZWxsZXIudHJhbnNmZXIoMyAqIHZhbHVlKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract Purchase {
 uint public value;
 address payable public seller;
 address payable public buyer;
 enum State { Created, Locked, Release, Inactive }
 // 状态变量的默认值是第一个成员，\`State.created\`。
 State public state;
 modifier condition(bool condition\_) {
 require(condition\_);
 \_;
 }
 /// 只有买方可以调用这个函数。
 error OnlyBuyer();
 /// 只有卖方可以调用这个函数。
 error OnlySeller();
 /// 在当前状态下不能调用该函数。
 error InvalidState();
 /// 提供的值必须是偶数。
 error ValueNotEven();
 modifier onlyBuyer() {
 if (msg.sender != buyer)
 revert OnlyBuyer();
 \_;
 }
 modifier onlySeller() {
 if (msg.sender != seller)
 revert OnlySeller();
 \_;
 }
 modifier inState(State state\_) {
 if (state != state\_)
 revert InvalidState();
 \_;
 }
 event Aborted();
 event PurchaseConfirmed();
 event ItemReceived();
 event SellerRefunded();
 // 确保 \`msg.value\` 是一个偶数。
 // 如果是奇数，除法会截断。
 // 通过乘法检查它不是一个奇数。
 constructor() payable {
 seller \= payable(msg.sender);
 value \= msg.value / 2;
 if ((2 \* value) != msg.value)
 revert ValueNotEven();
 }
 /// 终止购买并收回以太币。
 /// 只能由卖方在合约被锁定前调用。
 function abort()
 external
 onlySeller
 inState(State.Created)
 {
 emit Aborted();
 state \= State.Inactive;
 // 我们在这里直接使用 \`transfer\`。
 // 它可以安全地重入。
 // 因为它是这个函数中的最后一次调用，
 // 而且我们已经改变了状态。
 seller.transfer(address(this).balance);
 }
 /// 买方确认购买。
 /// 交易必须包括 \`2 \* value\` 以太币。
 /// Ether 将被锁住，直到调用 confirmReceived。
 function confirmPurchase()
 external
 inState(State.Created)
 condition(msg.value \== (2 \* value))
 payable
 {
 emit PurchaseConfirmed();
 buyer \= payable(msg.sender);
 state \= State.Locked;
 }
 /// 确认您（买方）已经收到了该物品。
 /// 这将释放锁定的以太币。
 function confirmReceived()
 external
 onlyBuyer
 inState(State.Locked)
 {
 emit ItemReceived();
 // 首先改变状态是很重要的，否则的话，
 // 下面使用 \`send\` 调用的合约可以在这里再次调用。
 state \= State.Release;
 buyer.transfer(value);
 }
 /// 该功能为卖家退款，
 /// 即退还卖家锁定的资金。
 function refundSeller()
 external
 onlySeller
 inState(State.Release)
 {
 emit SellerRefunded();
 // 首先改变状态是很重要的，否则的话，
 // 下面使用 \`send\` 调用的合约可以在这里再次调用。
 state \= State.Inactive;
 seller.transfer(3 \* value);
 }
}
## 微支付通道[](#id7 "此标题的永久链接")
在这一节中，我们将学习如何建立一个支付通道的实施实例。 它使用加密签名，使以太币在同一当事人之间的重复转移变得安全、即时，并且没有交易费用。 对于这个例子，我们需要了解如何签名和验证签名，并设置支付通道。
### 创建和验证签名[](#id8 "此标题的永久链接")
想象一下，Alice想发送一些以太给Bob， 即Alice是发送方，Bob是接收方。
Alice 只需要在链下发送经过加密签名的信息 (例如通过电子邮件)给Bob，它类似于写支票。
Alice和Bob使用签名来授权交易，这在以太坊的智能合约中是可以实现的。 Alice将建立一个简单的智能合约，让她传输以太币，但她不会自己调用一个函数来启动付款， 而是让Bob来做，从而支付交易费用。
该合约将按以下方式运作：
> 1. Alice部署了 `ReceiverPays` 合约，附加了足够的以太币来支付将要进行的付款。
> 
> 2. Alice通过用她的私钥签署一个消息来授权付款。
> 
> 3. Alice将经过加密签名的信息发送给Bob。该信息不需要保密（后面会解释），而且发送机制也不重要。
> 
> 4. Bob通过向智能合约发送签名的信息来索取他的付款，合约验证了信息的真实性，然后释放资金。
> 
#### 创建签名[](#id9 "此标题的永久链接")
Alice不需要与以太坊网络交互来签署交易，这个过程是完全离线的。 在本教程中，我们将使用 [web3.js](https://github.com/web3/web3.js) 和 [MetaMask](https://metamask.io/) 在浏览器中签署信息。 使用 [EIP-712](https://github.com/ethereum/EIPs/pull/712) 中描述的方法， 因为它提供了许多其他安全优势。
/// 先进行哈希运算使事情变得更容易
var hash \= web3.utils.sha3("message to sign");
web3.eth.personal.sign(hash, web3.eth.defaultAccount, function () { console.log("Signed"); });
备注
`web3.eth.personal.sign` 把信息的长度加到签名数据中。 由于我们先进行哈希运算，消息的长度总是正好是32字节， 因此这个长度前缀总是相同的。
#### 签署内容[](#id10 "此标题的永久链接")
对于履行付款的合约，签署的信息必须包括：
> 1. 收件人的钱包地址。
> 
> 2. 要转移的金额。
> 
> 3. 重放攻击的保护。
> 
重放攻击是指一个已签署的信息被重复使用，以获得对第二次交易的授权。 为了避免重放攻击，我们使用与以太坊交易本身相同的技术， 即所谓的nonce，它是一个账户发送的交易数量。 智能合约会检查一个nonce是否被多次使用。
另一种类型的重放攻击可能发生在所有者部署 `ReceiverPays` 合约时， 先进行了一些支付，然后销毁该合约。后来， 他们决定再次部署 `RecipientPays` 合约， 但新的合约不知道以前合约中使用的nonces，所以攻击者可以再次使用旧的信息。
Alice可以通过在消息中包含合约的地址来防止这种攻击， 并且只有包含合约地址本身的消息才会被接受。 您可以在本节末尾的完整合约的 `claimPayment()` 函数的前两行找到这个例子。
#### 组装参数[](#id11 "此标题的永久链接")
既然我们已经确定了要在签名信息中包含哪些信息， 我们准备把信息放在一起，进行哈希运算，然后签名。 简单起见，我们把数据连接起来。 [ethereumjs-abi](https://github.com/ethereumjs/ethereumjs-abi) 库提供了一个名为 `soliditySHA3` 的函数， 模仿Solidity的 `keccak256` 函数应用于使用 `abi.encodePacked` 编码的参数的行为。 这里有一个JavaScript函数，为 `ReceiverPays` 的例子创建了适当的签名。
// recipient， 是应该被支付的地址。
// amount，单位是 wei, 指定应该发送多少ether。
// nonce， 可以是任何唯一的数字，以防止重放攻击。
// contractAddress， 用于防止跨合约的重放攻击。
function signPayment(recipient, amount, nonce, contractAddress, callback) {
 var hash \= "0x" + abi.soliditySHA3(
 \["address", "uint256", "uint256", "address"\],
 \[recipient, amount, nonce, contractAddress\]
 ).toString("hex");
 web3.eth.personal.sign(hash, web3.eth.defaultAccount, callback);
}
#### 在Solidity中恢复信息签名者[](#id12 "此标题的永久链接")
一般来说，ECDSA的签名由两个参数组成， `r` 和 `s`。 以太坊的签名包括第三个参数 `v` ，您可以用它来验证是哪个账户的私钥被用来签署信息， 以及作为交易的发送者。Solidity 提供了一个内置函数 [ecrecover](https://docs.soliditylang.org/zh-cn/latest/units-and-global-variables.html#mathematical-and-cryptographic-functions)， 它接受一个消息以及 `r`, `s` 和 `v` 参数，然后返回用于签署该消息的地址。
#### 提取签名参数[](#id13 "此标题的永久链接")
web3.js 产生的签名是 `r`, `s` 和 `v` 的拼接的， 所以第一步是把这些参数分开。您可以在客户端这样做， 但在智能合约内这样做意味着你只需要发送一个签名参数而不是三个。 将一个字节数组分割成它的组成部分是很麻烦的， 所以我们在 `splitSignature` 函数中使用 [inline assembly](https://docs.soliditylang.org/zh-cn/latest/assembly.html) 完成这项工作（本节末尾的完整合约中的第三个函数）。
#### 计算信息哈希值[](#id14 "此标题的永久链接")
智能合约需要确切地知道哪些参数用于签名， 因此它必须通过参数重新创建消息，并使用该消息进行签名验证。 在 `claimPayment` 函数中，函数 `prefixed` 和 `recoverSigner` 做了这件事。
#### 完整的合约[](#id15 "此标题的永久链接")
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwovLyDov5nlsIbmiqXlkYrkuIDkuKrnlLHkuo7lup/lvIPnmoQgc2VsZmRlc3RydWN0IOiAjOS6p+eUn+eahOitpuWRigpjb250cmFjdCBSZWNlaXZlclBheXMgewogICAgYWRkcmVzcyBvd25lciA9IG1zZy5zZW5kZXI7CgogICAgbWFwcGluZyh1aW50MjU2ID0+IGJvb2wpIHVzZWROb25jZXM7CgogICAgY29uc3RydWN0b3IoKSBwYXlhYmxlIHt9CgogICAgZnVuY3Rpb24gY2xhaW1QYXltZW50KHVpbnQyNTYgYW1vdW50LCB1aW50MjU2IG5vbmNlLCBieXRlcyBtZW1vcnkgc2lnbmF0dXJlKSBleHRlcm5hbCB7CiAgICAgICAgcmVxdWlyZSghdXNlZE5vbmNlc1tub25jZV0pOwogICAgICAgIHVzZWROb25jZXNbbm9uY2VdID0gdHJ1ZTsKCiAgICAgICAgLy8g6L+Z5bCG6YeN5paw5Yib5bu65Zyo5a6i5oi356uv5LiK562+5ZCN55qE5L+h5oGv44CCCiAgICAgICAgYnl0ZXMzMiBtZXNzYWdlID0gcHJlZml4ZWQoa2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQobXNnLnNlbmRlciwgYW1vdW50LCBub25jZSwgdGhpcykpKTsKCiAgICAgICAgcmVxdWlyZShyZWNvdmVyU2lnbmVyKG1lc3NhZ2UsIHNpZ25hdHVyZSkgPT0gb3duZXIpOwoKICAgICAgICBwYXlhYmxlKG1zZy5zZW5kZXIpLnRyYW5zZmVyKGFtb3VudCk7CiAgICB9CgogICAgLy8vIOmUgOavgeWQiOe6puW5tuaUtuWbnuWJqeS9meeahOi1hOmHkeOAggogICAgZnVuY3Rpb24gc2h1dGRvd24oKSBleHRlcm5hbCB7CiAgICAgICAgcmVxdWlyZShtc2cuc2VuZGVyID09IG93bmVyKTsKICAgICAgICBzZWxmZGVzdHJ1Y3QocGF5YWJsZShtc2cuc2VuZGVyKSk7CiAgICB9CgogICAgLy8vIOetvuWQjeaWueazleOAggogICAgZnVuY3Rpb24gc3BsaXRTaWduYXR1cmUoYnl0ZXMgbWVtb3J5IHNpZykKICAgICAgICBpbnRlcm5hbAogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50OCB2LCBieXRlczMyIHIsIGJ5dGVzMzIgcykKICAgIHsKICAgICAgICByZXF1aXJlKHNpZy5sZW5ndGggPT0gNjUpOwoKICAgICAgICBhc3NlbWJseSB7CiAgICAgICAgICAgIC8vIOWJjTMy5Liq5a2X6IqC77yM5Zyo6ZW/5bqm5YmN57yA5LmL5ZCO44CCCiAgICAgICAgICAgIHIgOj0gbWxvYWQoYWRkKHNpZywgMzIpKQogICAgICAgICAgICAvLyDnrKzkuozkuKozMuWtl+iKguOAggogICAgICAgICAgICBzIDo9IG1sb2FkKGFkZChzaWcsIDY0KSkKICAgICAgICAgICAgLy8g5pyA5ZCO5LiA5Liq5a2X6IqC77yI5LiL5LiA5LiqMzLlrZfoioLnmoTnrKzkuIDkuKrlrZfoioLvvInjgIIKICAgICAgICAgICAgdiA6PSBieXRlKDAsIG1sb2FkKGFkZChzaWcsIDk2KSkpCiAgICAgICAgfQoKICAgICAgICByZXR1cm4gKHYsIHIsIHMpOwogICAgfQoKICAgIGZ1bmN0aW9uIHJlY292ZXJTaWduZXIoYnl0ZXMzMiBtZXNzYWdlLCBieXRlcyBtZW1vcnkgc2lnKQogICAgICAgIGludGVybmFsCiAgICAgICAgcHVyZQogICAgICAgIHJldHVybnMgKGFkZHJlc3MpCiAgICB7CiAgICAgICAgKHVpbnQ4IHYsIGJ5dGVzMzIgciwgYnl0ZXMzMiBzKSA9IHNwbGl0U2lnbmF0dXJlKHNpZyk7CgogICAgICAgIHJldHVybiBlY3JlY292ZXIobWVzc2FnZSwgdiwgciwgcyk7CiAgICB9CgogICAgLy8vIOaehOW7uuS4gOS4quWJjee8gOWTiOW4jOWAvO+8jOS7peaooeS7vyBldGhfc2lnbiDnmoTooYzkuLrjgIIKICAgIGZ1bmN0aW9uIHByZWZpeGVkKGJ5dGVzMzIgaGFzaCkgaW50ZXJuYWwgcHVyZSByZXR1cm5zIChieXRlczMyKSB7CiAgICAgICAgcmV0dXJuIGtlY2NhazI1NihhYmkuZW5jb2RlUGFja2VkKCJceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XG4zMiIsIGhhc2gpKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
// 这将报告一个由于废弃的 selfdestruct 而产生的警告
contract ReceiverPays {
 address owner \= msg.sender;
 mapping(uint256 \=> bool) usedNonces;
 constructor() payable {}
 function claimPayment(uint256 amount, uint256 nonce, bytes memory signature) external {
 require(!usedNonces\[nonce\]);
 usedNonces\[nonce\] \= true;
 // 这将重新创建在客户端上签名的信息。
 bytes32 message \= prefixed(keccak256(abi.encodePacked(msg.sender, amount, nonce, this)));
 require(recoverSigner(message, signature) \== owner);
 payable(msg.sender).transfer(amount);
 }
 /// 销毁合约并收回剩余的资金。
 function shutdown() external {
 require(msg.sender \== owner);
 selfdestruct(payable(msg.sender));
 }
 /// 签名方法。
 function splitSignature(bytes memory sig)
 internal
 pure
 returns (uint8 v, bytes32 r, bytes32 s)
 {
 require(sig.length \== 65);
 assembly {
 // 前32个字节，在长度前缀之后。
 r := mload(add(sig, 32))
 // 第二个32字节。
 s := mload(add(sig, 64))
 // 最后一个字节（下一个32字节的第一个字节）。
 v := byte(0, mload(add(sig, 96)))
 }
 return (v, r, s);
 }
 function recoverSigner(bytes32 message, bytes memory sig)
 internal
 pure
 returns (address)
 {
 (uint8 v, bytes32 r, bytes32 s) \= splitSignature(sig);
 return ecrecover(message, v, r, s);
 }
 /// 构建一个前缀哈希值，以模仿 eth\_sign 的行为。
 function prefixed(bytes32 hash) internal pure returns (bytes32) {
 return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));
 }
}
### 编写一个简单的支付通道合约[](#id16 "此标题的永久链接")
Alice现在建立了一个简单但完整的支付通道的实现。 支付通道使用加密签名来安全、即时地重复转移以太币， 并且没有交易费用。
#### 什么是支付通道？[](#id17 "此标题的永久链接")
支付通道允许参与者在不使用交易的情况下重复转移以太币。 这意味着，你可以避免与交易相关的延迟和费用。 我们将探讨两方（Alice和Bob）之间一个简单的单向支付通道。它涉及三个步骤：
> 1. Alice用以太币为智能合约提供资金。这就 “打开” 了支付通道。
> 
> 2. Alice签署信息，说明欠接收者多少以太币。这个步骤对每一笔付款都要重复进行。
> 
> 3. Bob “关闭” 支付通道，取出他的那部分以太币，并将剩余部分发回给发送方。
> 
备注
只有步骤1和3需要以太坊交易，意味着步骤2中发送方可以通过链下方法（如电子邮件） 向接收方发送加密签名的信息。这意味着只需要两个交易就可以支持任何数量的转移。
Bob保证会收到他的资金，因为智能合约托管了以太币， 并兑现了一个有效的签名信息。智能合约也强制执行超时， 所以即使接收者拒绝关闭通道，Alice也能保证最终收回她的资金。 由支付通道的参与者决定保持通道的开放时间。对于一个短暂的交易， 如向网吧支付每分钟的网络访问费，支付通道可以保持有限的开放时间。 另一方面，对于经常性的支付，如向雇员支付每小时的工资， 支付渠道可能会保持开放几个月或几年。
#### 开通支付渠道[](#id18 "此标题的永久链接")
为了开通支付通道，Alice部署了智能合约， 添加了要托管的以太币，并指定了预期接收者和通道存在的最长时间。 这就是本节末尾合约中的函数 `SimplePaymentChannel`。
#### 进行支付[](#id19 "此标题的永久链接")
Alice通过向Bob发送签名信息进行支付。 这一步骤完全在以太坊网络之外进行。 消息由发送方加密签名，然后直接传送给接收方。
每条信息包括以下信息：
> * 智能合约的地址，用于防止跨合约重放攻击。
> 
> * 到目前为止，欠接收方的以太币的总金额。
> 
一个支付通道只关闭一次，就是在一系列转账结束后。 正因为如此，所发送的签名信息中只有一个能被赎回。 这就是为什么每条签名信息都指定了一个累计的以太币欠款总额， 而不是单个小额支付的金额。接收方自然会选择最新的签名信息来赎回， 因为那是总额最高的签名信息。每个签名信息的nonce不再需要了， 因为智能合约只兑现一个签名信息。 智能合约的地址仍然被用来防止一个支付渠道的签名信息被用于另一个渠道。
下面是经过修改的JavaScript代码，用于对上一节中的信息进行加密签名：
function constructPaymentMessage(contractAddress, amount) {
 return abi.soliditySHA3(
 \["address", "uint256"\],
 \[contractAddress, amount\]
 );
}
function signMessage(message, callback) {
 web3.eth.personal.sign(
 "0x" + message.toString("hex"),
 web3.eth.defaultAccount,
 callback
 );
}
// contractAddress， 是用来防止跨合约的重放攻击。
// amount，单位是wei，指定了应该发送多少以太。
function signPayment(contractAddress, amount, callback) {
 var message \= constructPaymentMessage(contractAddress, amount);
 signMessage(message, callback);
}
#### 关闭支付通道[](#id20 "此标题的永久链接")
当Bob准备好接收他的资金时， 是时候通过调用智能合约上的 `close` 函数关闭支付通道了。 关闭通道会向接收者支付欠他们的以太币，并销毁合约， 将任何剩余的以太币送回给Alice。 为了关闭通道，Bob需要提供一个由Alice签名的信息。
智能合约必须验证该消息是否包含发送者的有效签名。 进行这种验证的过程与接收者使用签名的过程相同。 Solidity函数 `isValidSignature` 和 `recoverSigner` 的工作方式 与上一节中的JavaScript对应函数一样，而后者的函数是从 `ReceiverPays` 合约中借用的。
只有支付通道的接收者可以调用 `close` 函数， 他们自然会传递最新的支付信息，因为该信息带有最高的欠款总额。 如果允许发送者调用这个函数，他们可以提供一个金额较低的签名消息， 骗取接收者的欠款。
该函数会验证签名的信息与给定的参数是否相符。 如果一切正常，接收者就会收到他们的那部分以太币， 而剩下的以太币将通过 `selfdestruct` 发送给发送者。 您可以在完整的合约中看到 `close` 函数。
#### 通道到期[](#id21 "此标题的永久链接")
Bob可以在任何时候关闭支付通道，但如果他们没有这样做， Alice需要一个方法来收回她的托管资金。在合约部署的时候，设置了一个 _到期时间_。 一旦达到这个时间，Alice可以调用 `claimTimeout` 来收回她的资金。 您可以在完整的合约中看到 `claimTimeout` 函数。
在这个函数被调用后，Bob不能再接收任何以太。 所以Bob必须在过期前关闭通道，这一点很重要。
#### 完整的合约[](#id22 "此标题的永久链接")
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwovLyDov5nlsIbmiqXlkYrkuIDkuKrnlLHkuo7lup/lvIPnmoQgc2VsZmRlc3RydWN0IOiAjOS6p+eUn+eahOitpuWRigpjb250cmFjdCBTaW1wbGVQYXltZW50Q2hhbm5lbCB7CiAgICBhZGRyZXNzIHBheWFibGUgcHVibGljIHNlbmRlcjsgICAgICAvLyDlj5HpgIHku5jmrL7nmoTotKbmiLfjgIIKICAgIGFkZHJlc3MgcGF5YWJsZSBwdWJsaWMgcmVjaXBpZW50OyAgIC8vIOaOpeaUtuS7mOasvueahOi0puaIt+OAggogICAgdWludDI1NiBwdWJsaWMgZXhwaXJhdGlvbjsgIC8vIOi2heaXtuaXtumXtO+8jOS7pemYsuaOpeaUtuiAheawuOS4jeWFs+mXreaUr+S7mOmAmumBk+OAggoKICAgIGNvbnN0cnVjdG9yIChhZGRyZXNzIHBheWFibGUgcmVjaXBpZW50QWRkcmVzcywgdWludDI1NiBkdXJhdGlvbikKICAgICAgICBwYXlhYmxlCiAgICB7CiAgICAgICAgc2VuZGVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsKICAgICAgICByZWNpcGllbnQgPSByZWNpcGllbnRBZGRyZXNzOwogICAgICAgIGV4cGlyYXRpb24gPSBibG9jay50aW1lc3RhbXAgKyBkdXJhdGlvbjsKICAgIH0KCiAgICAvLy8g5o6l5pS26ICF5Y+v5Lul5Zyo5Lu75L2V5pe25YCZ6YCa6L+H5o+Q5L6b5Y+R6YCB6ICF562+5ZCN55qE6YeR6aKd5p2l5YWz6Zet6YCa6YGT77yMCiAgICAvLy8g5o6l5pS26ICF5bCG6I635b6X6K+l6YeR6aKd77yM5YW25L2Z6YOo5YiG5bCG6L+U5Zue5Y+R6YCB6ICF44CCCiAgICBmdW5jdGlvbiBjbG9zZSh1aW50MjU2IGFtb3VudCwgYnl0ZXMgbWVtb3J5IHNpZ25hdHVyZSkgZXh0ZXJuYWwgewogICAgICAgIHJlcXVpcmUobXNnLnNlbmRlciA9PSByZWNpcGllbnQpOwogICAgICAgIHJlcXVpcmUoaXNWYWxpZFNpZ25hdHVyZShhbW91bnQsIHNpZ25hdHVyZSkpOwoKICAgICAgICByZWNpcGllbnQudHJhbnNmZXIoYW1vdW50KTsKICAgICAgICBzZWxmZGVzdHJ1Y3Qoc2VuZGVyKTsKICAgIH0KCiAgICAvLy8g5Y+R6YCB6ICF5Y+v5Lul5Zyo5Lu75L2V5pe25YCZ5bu26ZW/5Yiw5pyf5pe26Ze044CCCiAgICBmdW5jdGlvbiBleHRlbmQodWludDI1NiBuZXdFeHBpcmF0aW9uKSBleHRlcm5hbCB7CiAgICAgICAgcmVxdWlyZShtc2cuc2VuZGVyID09IHNlbmRlcik7CiAgICAgICAgcmVxdWlyZShuZXdFeHBpcmF0aW9uID4gZXhwaXJhdGlvbik7CgogICAgICAgIGV4cGlyYXRpb24gPSBuZXdFeHBpcmF0aW9uOwogICAgfQoKICAgIC8vLyDlpoLmnpzovr7liLDotoXml7bml7bpl7TogIzmjqXmlLbogIXmsqHmnInlhbPpl63pgJrpgZPvvIwKICAgIC8vLyDpgqPkuYjku6XlpKrlsLHkvJrooqvph4rmlL7lm57nu5nlj5HpgIHogIXjgIIKICAgIGZ1bmN0aW9uIGNsYWltVGltZW91dCgpIGV4dGVybmFsIHsKICAgICAgICByZXF1aXJlKGJsb2NrLnRpbWVzdGFtcCA+PSBleHBpcmF0aW9uKTsKICAgICAgICBzZWxmZGVzdHJ1Y3Qoc2VuZGVyKTsKICAgIH0KCiAgICBmdW5jdGlvbiBpc1ZhbGlkU2lnbmF0dXJlKHVpbnQyNTYgYW1vdW50LCBieXRlcyBtZW1vcnkgc2lnbmF0dXJlKQogICAgICAgIGludGVybmFsCiAgICAgICAgdmlldwogICAgICAgIHJldHVybnMgKGJvb2wpCiAgICB7CiAgICAgICAgYnl0ZXMzMiBtZXNzYWdlID0gcHJlZml4ZWQoa2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQodGhpcywgYW1vdW50KSkpOwoKICAgICAgICAvLyDmo4Dmn6Xnrb7lkI3mmK/lkKbmnaXoh6rku5jmrL7mlrnjgIIKICAgICAgICByZXR1cm4gcmVjb3ZlclNpZ25lcihtZXNzYWdlLCBzaWduYXR1cmUpID09IHNlbmRlcjsKICAgIH0KCiAgICAvLy8g5LiL6Z2i55qE5omA5pyJ5Yqf6IO95piv5Y+W6IeqICfliJvlu7rlkozpqozor4Hnrb7lkI0nIOeahOeroOiKguOAggoKICAgIGZ1bmN0aW9uIHNwbGl0U2lnbmF0dXJlKGJ5dGVzIG1lbW9yeSBzaWcpCiAgICAgICAgaW50ZXJuYWwKICAgICAgICBwdXJlCiAgICAgICAgcmV0dXJucyAodWludDggdiwgYnl0ZXMzMiByLCBieXRlczMyIHMpCiAgICB7CiAgICAgICAgcmVxdWlyZShzaWcubGVuZ3RoID09IDY1KTsKCiAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICAvLyDliY0zMuS4quWtl+iKgu+8jOWcqOmVv+W6puWJjee8gOS5i+WQjuOAggogICAgICAgICAgICByIDo9IG1sb2FkKGFkZChzaWcsIDMyKSkKICAgICAgICAgICAgLy8g56ys5LqM5LiqMzLlrZfoioLjgIIKICAgICAgICAgICAgcyA6PSBtbG9hZChhZGQoc2lnLCA2NCkpCiAgICAgICAgICAgIC8vIOacgOWQjuS4gOS4quWtl+iKgu+8iOS4i+S4gOS4qjMy5a2X6IqC55qE56ys5LiA5Liq5a2X6IqC77yJ44CCCiAgICAgICAgICAgIHYgOj0gYnl0ZSgwLCBtbG9hZChhZGQoc2lnLCA5NikpKQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuICh2LCByLCBzKTsKICAgIH0KCiAgICBmdW5jdGlvbiByZWNvdmVyU2lnbmVyKGJ5dGVzMzIgbWVzc2FnZSwgYnl0ZXMgbWVtb3J5IHNpZykKICAgICAgICBpbnRlcm5hbAogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zIChhZGRyZXNzKQogICAgewogICAgICAgICh1aW50OCB2LCBieXRlczMyIHIsIGJ5dGVzMzIgcykgPSBzcGxpdFNpZ25hdHVyZShzaWcpOwoKICAgICAgICByZXR1cm4gZWNyZWNvdmVyKG1lc3NhZ2UsIHYsIHIsIHMpOwogICAgfQoKICAgIC8vLyDmnoTlu7rkuIDkuKrliY3nvIDlk4jluIzlgLzvvIzku6XmqKHku79ldGhfc2lnbueahOihjOS4uuOAggogICAgZnVuY3Rpb24gcHJlZml4ZWQoYnl0ZXMzMiBoYXNoKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKGJ5dGVzMzIpIHsKICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQoIlx4MTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcbjMyIiwgaGFzaCkpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
// 这将报告一个由于废弃的 selfdestruct 而产生的警告
contract SimplePaymentChannel {
 address payable public sender; // 发送付款的账户。
 address payable public recipient; // 接收付款的账户。
 uint256 public expiration; // 超时时间，以防接收者永不关闭支付通道。
 constructor (address payable recipientAddress, uint256 duration)
 payable
 {
 sender \= payable(msg.sender);
 recipient \= recipientAddress;
 expiration \= block.timestamp + duration;
 }
 /// 接收者可以在任何时候通过提供发送者签名的金额来关闭通道，
 /// 接收者将获得该金额，其余部分将返回发送者。
 function close(uint256 amount, bytes memory signature) external {
 require(msg.sender \== recipient);
 require(isValidSignature(amount, signature));
 recipient.transfer(amount);
 selfdestruct(sender);
 }
 /// 发送者可以在任何时候延长到期时间。
 function extend(uint256 newExpiration) external {
 require(msg.sender \== sender);
 require(newExpiration \> expiration);
 expiration \= newExpiration;
 }
 /// 如果达到超时时间而接收者没有关闭通道，
 /// 那么以太就会被释放回给发送者。
 function claimTimeout() external {
 require(block.timestamp \>= expiration);
 selfdestruct(sender);
 }
 function isValidSignature(uint256 amount, bytes memory signature)
 internal
 view
 returns (bool)
 {
 bytes32 message \= prefixed(keccak256(abi.encodePacked(this, amount)));
 // 检查签名是否来自付款方。
 return recoverSigner(message, signature) \== sender;
 }
 /// 下面的所有功能是取自 '创建和验证签名' 的章节。
 function splitSignature(bytes memory sig)
 internal
 pure
 returns (uint8 v, bytes32 r, bytes32 s)
 {
 require(sig.length \== 65);
 assembly {
 // 前32个字节，在长度前缀之后。
 r := mload(add(sig, 32))
 // 第二个32字节。
 s := mload(add(sig, 64))
 // 最后一个字节（下一个32字节的第一个字节）。
 v := byte(0, mload(add(sig, 96)))
 }
 return (v, r, s);
 }
 function recoverSigner(bytes32 message, bytes memory sig)
 internal
 pure
 returns (address)
 {
 (uint8 v, bytes32 r, bytes32 s) \= splitSignature(sig);
 return ecrecover(message, v, r, s);
 }
 /// 构建一个前缀哈希值，以模仿eth\_sign的行为。
 function prefixed(bytes32 hash) internal pure returns (bytes32) {
 return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));
 }
}
备注
函数 `splitSignature` 并没有使用所有的安全检查。 真正的实现应该使用更严格的测试库，例如openzepplin的 [这个版本](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol) 的这个代码。
#### 验证付款[](#id24 "此标题的永久链接")
不同与上一节，支付通道中的信息不会马上被兑换。 接收者会跟踪最新的信息，并在关闭支付通道的时候赎回它。 这意味着接收者对每条信息进行自行验证是至关重要的。 否则就不能保证接收者最终能够得到付款。
接收者应使用以下程序验证每条信息：
> 1. 验证签名信息中的合约地址是否与支付通道相符。
> 
> 2. 验证新的总额是否为预期的数额。
> 
> 3. 确认新的总额不超过代管的以太币数额。
> 
> 4. 验证签名是否有效，是否来自于支付通道的发送方。
> 
我们将使用 [ethereumjs-util](https://github.com/ethereumjs/ethereumjs-util) 库来编写这个验证。最后一步可以用多种方式完成，我们使用JavaScript。 下面的代码借用了上面 **JavaScript代码** 中加密签名的 `constructPaymentMessage` 函数。
// 这模拟了eth\_sign 的JSON-RPC构建前缀的方法。
function prefixed(hash) {
 return ethereumjs.ABI.soliditySHA3(
 \["string", "bytes32"\],
 \["\\x19Ethereum Signed Message:\\n32", hash\]
 );
}
function recoverSigner(message, signature) {
 var split \= ethereumjs.Util.fromRpcSig(signature);
 var publicKey \= ethereumjs.Util.ecrecover(message, split.v, split.r, split.s);
 var signer \= ethereumjs.Util.pubToAddress(publicKey).toString("hex");
 return signer;
}
function isValidSignature(contractAddress, amount, signature, expectedSigner) {
 var message \= prefixed(constructPaymentMessage(contractAddress, amount));
 var signer \= recoverSigner(message, signature);
 return signer.toLowerCase() \==
 ethereumjs.Util.stripHexPrefix(expectedSigner).toLowerCase();
}
## 模块化合约[](#index-3 "此标题的永久链接")
用模块化的方法来构建您的合约，可以帮助减少复杂性，提高可读性， 这将有助于在开发和代码审查中发现错误和漏洞。 如果您单独指定且控制每个模块的行为，您必须考虑的相互作用只是模块之间的相互作用， 而不是合约的其他每个灵活模块函数。 在下面的例子中，合约使用 `Balances` [库](https://docs.soliditylang.org/zh-cn/latest/contracts.html#libraries) 的 `move` 方法 来检查地址之间发送的余额是否符合您的期望。通过这种方式， `Balances` 库提供了一个独立的组件， 可以正确地跟踪账户的余额。 很容易验证 `Balances` 库永远不会产生负的余额或溢出， 所有余额的总和在合约的有效期内是一个不变的量。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKbGlicmFyeSBCYWxhbmNlcyB7CiAgICBmdW5jdGlvbiBtb3ZlKG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50MjU2KSBzdG9yYWdlIGJhbGFuY2VzLCBhZGRyZXNzIGZyb20sIGFkZHJlc3MgdG8sIHVpbnQgYW1vdW50KSBpbnRlcm5hbCB7CiAgICAgICAgcmVxdWlyZShiYWxhbmNlc1tmcm9tXSA+PSBhbW91bnQpOwogICAgICAgIHJlcXVpcmUoYmFsYW5jZXNbdG9dICsgYW1vdW50ID49IGJhbGFuY2VzW3RvXSk7CiAgICAgICAgYmFsYW5jZXNbZnJvbV0gLT0gYW1vdW50OwogICAgICAgIGJhbGFuY2VzW3RvXSArPSBhbW91bnQ7CiAgICB9Cn0KCmNvbnRyYWN0IFRva2VuIHsKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50MjU2KSBiYWxhbmNlczsKICAgIHVzaW5nIEJhbGFuY2VzIGZvciAqOwogICAgbWFwcGluZyhhZGRyZXNzID0+IG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50MjU2KSkgYWxsb3dlZDsKCiAgICBldmVudCBUcmFuc2ZlcihhZGRyZXNzIGZyb20sIGFkZHJlc3MgdG8sIHVpbnQgYW1vdW50KTsKICAgIGV2ZW50IEFwcHJvdmFsKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3Mgc3BlbmRlciwgdWludCBhbW91bnQpOwoKICAgIGZ1bmN0aW9uIHRyYW5zZmVyKGFkZHJlc3MgdG8sIHVpbnQgYW1vdW50KSBleHRlcm5hbCByZXR1cm5zIChib29sIHN1Y2Nlc3MpIHsKICAgICAgICBiYWxhbmNlcy5tb3ZlKG1zZy5zZW5kZXIsIHRvLCBhbW91bnQpOwogICAgICAgIGVtaXQgVHJhbnNmZXIobXNnLnNlbmRlciwgdG8sIGFtb3VudCk7CiAgICAgICAgcmV0dXJuIHRydWU7CgogICAgfQoKICAgIGZ1bmN0aW9uIHRyYW5zZmVyRnJvbShhZGRyZXNzIGZyb20sIGFkZHJlc3MgdG8sIHVpbnQgYW1vdW50KSBleHRlcm5hbCByZXR1cm5zIChib29sIHN1Y2Nlc3MpIHsKICAgICAgICByZXF1aXJlKGFsbG93ZWRbZnJvbV1bbXNnLnNlbmRlcl0gPj0gYW1vdW50KTsKICAgICAgICBhbGxvd2VkW2Zyb21dW21zZy5zZW5kZXJdIC09IGFtb3VudDsKICAgICAgICBiYWxhbmNlcy5tb3ZlKGZyb20sIHRvLCBhbW91bnQpOwogICAgICAgIGVtaXQgVHJhbnNmZXIoZnJvbSwgdG8sIGFtb3VudCk7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICB9CgogICAgZnVuY3Rpb24gYXBwcm92ZShhZGRyZXNzIHNwZW5kZXIsIHVpbnQgdG9rZW5zKSBleHRlcm5hbCByZXR1cm5zIChib29sIHN1Y2Nlc3MpIHsKICAgICAgICByZXF1aXJlKGFsbG93ZWRbbXNnLnNlbmRlcl1bc3BlbmRlcl0gPT0gMCwgIiIpOwogICAgICAgIGFsbG93ZWRbbXNnLnNlbmRlcl1bc3BlbmRlcl0gPSB0b2tlbnM7CiAgICAgICAgZW1pdCBBcHByb3ZhbChtc2cuc2VuZGVyLCBzcGVuZGVyLCB0b2tlbnMpOwogICAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICAgIGZ1bmN0aW9uIGJhbGFuY2VPZihhZGRyZXNzIHRva2VuT3duZXIpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAodWludCBiYWxhbmNlKSB7CiAgICAgICAgcmV0dXJuIGJhbGFuY2VzW3Rva2VuT3duZXJdOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
library Balances {
 function move(mapping(address \=> uint256) storage balances, address from, address to, uint amount) internal {
 require(balances\[from\] \>= amount);
 require(balances\[to\] + amount \>= balances\[to\]);
 balances\[from\] \-= amount;
 balances\[to\] += amount;
 }
}
contract Token {
 mapping(address \=> uint256) balances;
 using Balances for \*;
 mapping(address \=> mapping(address \=> uint256)) allowed;
 event Transfer(address from, address to, uint amount);
 event Approval(address owner, address spender, uint amount);
 function transfer(address to, uint amount) external returns (bool success) {
 balances.move(msg.sender, to, amount);
 emit Transfer(msg.sender, to, amount);
 return true;
 }
 function transferFrom(address from, address to, uint amount) external returns (bool success) {
 require(allowed\[from\]\[msg.sender\] \>= amount);
 allowed\[from\]\[msg.sender\] \-= amount;
 balances.move(from, to, amount);
 emit Transfer(from, to, amount);
 return true;
 }
 function approve(address spender, uint tokens) external returns (bool success) {
 require(allowed\[msg.sender\]\[spender\] \== 0, "");
 allowed\[msg.sender\]\[spender\] \= tokens;
 emit Approval(msg.sender, spender, tokens);
 return true;
 }
 function balanceOf(address tokenOwner) external view returns (uint balance) {
 return balances\[tokenOwner\];
 }
}

# [Birimler ve Global Olarak Kullanılabilir Değişkenler — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/units-and-global-variables.html) 
 _https://docs.soliditylang.org/tr/latest/units-and-global-variables.html_

## Ether Birimleri[](#ether-birimleri "Permalink to this heading")
Bir değişmez sayı, Ether’in bir alt para birimini belirtmek için `wei`, `gwei` veya `ether` son ekini alabilir; burada son eki olmayan Ether sayılarının Wei olduğu varsayılır.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=YXNzZXJ0KDEgd2VpID09IDEpOwphc3NlcnQoMSBnd2VpID09IDFlOSk7CmFzc2VydCgxIGV0aGVyID09IDFlMTgpOw==)
assert(1 wei \== 1);
assert(1 gwei \== 1e9);
assert(1 ether \== 1e18);
Alt isim ekinin(“e”) tek etkisi, onluk bir kuvvetle çarpmadır. .. note:: 0.7.0 sürümünde “finney” ve “szabo” adları kaldırılmıştır.
## Zaman Birimleri[](#zaman-birimleri "Permalink to this heading")
Gerçek sayılardan sonra gelen `saniye`, `dakika`, `saat`, `gün` ve `hafta` gibi son ekler, saniyelerin temel birim olduğu zaman birimlerini belirtmek için kullanılabilir. Ve ayrıca birimler aşağıdaki şekilde olduğu gibi basitçe ele alınır:
* `1 == 1 saniye`
 
* `1 dakika == 60 saniye`
 
* `1 saat == 60 dakika`
 
* `1 gün == 24 saat`
 
* `1 hafta == 7 gün`
 
Bu birimleri kullanarak takvim hesaplamaları yapıyorsanız dikkatli olun, çünkü her yıl 365 güne eşit değildir ve [“artık saniyeler”](https://en.wikipedia.org/wiki/Leap_second) nedeniyle her gün bile 24 saat değildir. “Artık saniyelerin” tahmin edilememesi nedeniyle, tam bir takvim kütüphanesinin harici bir oracle tarafından güncellenmesi gerekir.
Not
Yukarıdaki nedenlerden dolayı `years` soneki 0.5.0 sürümünde kaldırılmıştır.
Bu son ekler değişkenlere uygulanamaz. Örneğin, bir fonksiyon parametresini gün olarak yorumlamak istiyorsanız, aşağıdaki şekilde yapabilirsiniz:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=ZnVuY3Rpb24gZih1aW50IHN0YXJ0LCB1aW50IGRheXNBZnRlcikgcHVibGljIHsKICAgIGlmIChibG9jay50aW1lc3RhbXAgPj0gc3RhcnQgKyBkYXlzQWZ0ZXIgKiAxIGRheXMpIHsKICAgICAgLy8gLi4uCiAgICB9Cn0=)
function f(uint start, uint daysAfter) public {
 if (block.timestamp \>= start + daysAfter \* 1 days) {
 // ...
 }
}
## Özel Değişkenler ve Fonksiyonlar[](#ozel-degiskenler-ve-fonksiyonlar "Permalink to this heading")
Global ad alanında her zaman var olan özel değişkenler ve işlevler vardır ve bunlar çoğunlukla blok zinciri hakkında bilgi sağlamak için kullanılır. Veya bunlara ek olarak genel kullanım amaçlı yardımcı fonksiyonlar da bulunmaktadır.
### Blok ve İşlem Özellikleri[](#blok-ve-islem-ozellikleri "Permalink to this heading")
* `blockhash(uint blockNumber) returns (bytes32)`: `blocknumber` en son 256 bloktan biri olduğunda verilen bloğun hash\`ini döndürür, aksi takdirde sıfır döndürür
 
* `block.basefee` (`uint`): mevcut bloğun baz ücreti ([EIP-3198](https://eips.ethereum.org/EIPS/eip-3198) ve [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559))
 
* `block.chainid` (`uint`): mevcut bloğun zincir kimliği
 
* `block.coinbase` (`address payable`): mevcut blok madencisinin adresi
 
* `block.difficulty` (`uint`): mevcut blok zorluğu
 
* `block.gaslimit` (`uint`): mevcut blok gas sınırı
 
* `block.number` (`uint`): mevcut blok numarası
 
* `block.timestamp` (`uint`): unix döneminden bu yana saniye biçimindeki mevcut blok zaman bilgisi
 
* `gasleft() returns (uint256)`: kalan gas
 
* `msg.data` (`bytes calldata`): bütün calldata
 
* `msg.sender` (`address`): mesajın göndericisi (mevcut çağırma için)
 
* `msg.sig` (`bytes4`): calldata’nın ilk 4 byte değeri (yani fonksiyon tanımlayıcısı)
 
* `msg.value` (`uint`): mesaj ile birlikte gönderilen wei miktarı
 
* `tx.gasprice` (`uint`): işlemin gas fiyatı
 
* `tx.origin` (`address`): işlemin göndericisi (tam çağrı zinciri)
 
Not
`msg.sender` ve `msg.value` dahil olmak üzere `msg` öğesinin tüm üyelerinin değerleri her **harici** işlev çağrısı için değişebilir. Buna kütüphane fonksiyonlarına yapılan çağrılar da dahildir.
Not
Sözleşmeler, bir bloğa dahil edilen bir işlem bağlamında değil de zincir dışı değerlendirildiğinde, “block.\*” ve “tx.\*” ifadelerinin herhangi bir belirli blok veya işlemden gelen değerleri ifade ettiğini varsaymamalısınız. Bu değerler, sözleşmeyi yürüten ESM uygulaması tarafından sağlanır ve isteğe bağlı olabilir.
Not
Ne yaptığınızı bilmiyorsanız, rasgelelik kaynağı olarak `block.timestamp` veya `blockhash`’e güvenmeyin.
Hem zaman bilgisi hem de blok hash’i madenciler tarafından bir dereceye kadar etkilenebilir. Madencilik topluluğunda bulunan kötü aktörler, örneğin seçilen bir hash üzerinde bir kumarhane ödeme fonksiyonu çalıştırabilir ve herhangi bir para almazlarsa farklı bir hash’i çözmeyi yeniden deneyebilirler.
Mevcut blok zaman bilgisi, son bloğun zaman bilgisinden kesinlikle daha büyük olmalıdır. Ancak kabul edilebilecek tek garanti zaman bilgisi, standart zincirdeki iki ardışık bloğun zaman bilgileri arasında bir yerde olmasıdır.
Not
Ölçeklenebilirlik nedeniyle blok hash’leri tüm bloklar için mevcut değildir. Yalnızca en son 256 bloğun hash’lerine erişebilirsiniz, bunun dışındaki tüm değerler sıfır olacaktır.
Not
Daha önce `blockhash` işlevi `block.blockhash` olarak biliniyordu, bu işlev 0.4.22 sürümünde kullanımdan kaldırılmış ve 0.5.0 sürümünde tamamen kaldırılmıştır.
Not
Daha önce `gasleft` işlevi `msg.gas` olarak biliniyordu, bu işlev 0.4.21 sürümünde kullanımdan kaldırılmış ve 0.5.0 sürümünde tamamen kaldırılmıştır.
Not
0.7.0 sürümünde `now` takma adı (`block.timestamp` için) kaldırıldı.
### ABI Şifreleme ve Şifreyi Çözme Fonksiyonları[](#abi-sifreleme-ve-sifreyi-cozme-fonksiyonlari "Permalink to this heading")
* `abi.decode(bytes memory encodedData, (...)) returns (...)`: ABI verilen verinin şifresini çözerken, tipler ikinci argüman olarak parantez içinde verilir. Örneğin: `(uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))`
 
* `abi.encode(...) returns (bytes memory)`: ABI verilen argümanları şifreler
 
* `abi.encodePacked(...) returns (bytes memory)`: Verilen argümanların [paketlenmiş şifreleme](https://docs.soliditylang.org/tr/latest/abi-spec.html#abi-packed-mode) işlemini gerçekleştirir. Paketli şifrelemenin belirsiz olabileceğine dikkat edin!
 
* `abi.encodeWithSelector(bytes4 selector, ...) returns (bytes memory)`: ABI, verilen bağımsız değişkenleri ikinciden başlayarak şifreler ve verilen dört baytlık seçicinin önüne ekler.
 
* `abi.encodeWithSignature(string memory signature, ...) returns (bytes memory)`: Şuna eşdeğerdir `abi.encodeWithSelector(bytes4(keccak256(bytes(signature))), ...)`
 
* `abi.encodeCall(function functionPointer, (...)) returns (bytes memory)`: ABI, `functionPointer` çağrısını veri grupları içinde bulunan argümanlarla şifreler. Tam bir tür denetimi gerçekleştirerek türlerin fonksiyon imzasıyla eşleşmesini sağlar. Sonuç `abi.encodeWithSelector(functionPointer.selector, (...))` değerine eşittir
 
Not
Bu şifreleme fonksiyonları, harici bir fonksiyonu çağırmadan harici fonksiyon çağrıları için veri oluşturmak amacıyla kullanılabilir. Ayrıca, `keccak256(abi.encodePacked(a, b))` yapılandırılmış verilerin hashini hesaplamanın bir yoludur (ancak farklı fonksiyon parametre türleri kullanarak bir “hash çakışması” oluşturmanın mümkün olduğunu unutmayın).
Şifreleme ile ilgili ayrıntılar için [ABI](https://docs.soliditylang.org/tr/latest/abi-spec.html#abi) ve [sıkıca paketlenmiş şifreleme](https://docs.soliditylang.org/tr/latest/abi-spec.html#abi-packed-mode) hakkındaki belgelere bakabilirsiniz.
### Byte Üyeleri[](#byte-uyeleri "Permalink to this heading")
* `bytes.concat(...) returns (bytes memory)`: [Değişken sayıda bayt ve bytes1, …, bytes32 argümanlarını bir bayt dizisine birleştirir](https://docs.soliditylang.org/tr/latest/types.html#bytes-concat)
 
### String Üyeleri[](#string-uyeleri "Permalink to this heading")
* `string.concat(...) returns (string memory)`: [Değişken sayıda string argümanını tek bir string dizisinde birleştirir](https://docs.soliditylang.org/tr/latest/types.html#string-concat)
 
### Hata İşleme[](#hata-isleme "Permalink to this heading")
Hata işleme ve hangi fonksiyonun ne zaman kullanılacağı hakkında daha fazla bilgi için [assert ve require](https://docs.soliditylang.org/tr/latest/control-structures.html#assert-and-require) bölümüne bakın.
`assert(bool condition)`
Panik hatasına ve dolayısıyla koşul karşılanmazsa durum değişikliğinin tersine dönmesine neden olur - dahili hatalar için kullanılır.
`require(bool condition)`
koşul karşılanmazsa geri döner - girişlerdeki veya harici bileşenlerdeki hatalar için kullanılır.
`require(bool condition, string memory message)`
koşul karşılanmazsa geri döner - girişlerdeki veya harici bileşenlerdeki hatalar için kullanılır. Ayrıca bir hata mesajı da sağlar.
`revert()`
yürütmeyi iptal eder ve durum değişikliklerini geri alır
`revert(string memory reason)`
açıklayıcı bir string sağlayarak yürütmeyi iptal eder ve durum değişikliklerini geri alır
### Matematiksel ve Kriptografik Fonksiyonlar[](#matematiksel-ve-kriptografik-fonksiyonlar "Permalink to this heading")
`addmod(uint x, uint y, uint k) returns (uint)`
toplama işleminin isteğe bağlı kesinlikte gerçekleştirildiği ve `2**256``da kapsamadığı ``(x + y) % k` değerini hesaplar. Sürüm 0.5.0’den başlayarak “k!= 0” olduğunu iddia eder.
`mulmod(uint x, uint y, uint k) returns (uint)`
çarpmanın isteğe bağlı kesinlikte gerçekleştirildiği ve `2**256` değerinde kapsamadığı `(x * y) % k` değerini hesaplar. Sürüm 0.5.0’dan başlayarak `k != 0` olduğunu iddia eder.
`keccak256(bytes memory) returns (bytes32)`
girdinin Keccak-256 hash’ini hesaplar
Not
Eskiden `keccak256` için `sha3` adında bir takma ad vardı, ancak bu ad 0.5.0 sürümünde kaldırıldı.
`sha256(bytes memory) returns (bytes32)`
girdinin SHA-256 hash’ini hesaplar
`ripemd160(bytes memory) returns (bytes20)`
girdinin RIPEMD-160 hash’ini hesaplar
`ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)`
eliptik eğri imzasından açık anahtarla ilişkili adresi kurtarır veya hata durumunda sıfır döndürür. Fonksiyon parametreleri imzanın ECDSA değerlerine karşılık gelir:
* `r` = imzanın ilk 32 byte’ı
 
* `s` = imzanın ikinci 32 byte’ı
 
* `v` = imzanın son 1 byte’ı
 
`ecrecover` yalnızca bir `address` döndürür, `address payable` döndürmez. Kurtarılan adrese para aktarmanız gerekirse, dönüştürme için [address payable](https://docs.soliditylang.org/tr/latest/types.html#address) bölümüne bakabilirsiniz.
Daha fazla ayrıntı için [örnek kullanım](https://ethereum.stackexchange.com/questions/1777/workflow-on-signing-a-string-with-private-key-followed-by-signature-verificatio) bölümünü okuyun.
Uyarı
Eğer `ecrecover` kullanıyorsanız, geçerli bir imzanın ilgili özel anahtarın (private key) bilinmesini gerektirmeden farklı bir geçerli imzaya dönüştürülebileceğini unutmayın. Homestead hard fork’unda bu sorun \_transaction\_ signatures için düzeltildi (bkz. [EIP-2](https://eips.ethereum.org/EIPS/eip-2#specification)), ancak ecrecover fonksiyonu değişmeden kaldı.
İmzaların benzersiz olmasını istemediğiniz veya bunları öğeleri tanımlamak için kullanmadığınız sürece bu genellikle bir sorun değildir. OpenZeppelin, bu sorun olmadan `ecrecover` için bir wrapper olarak kullanabileceğiniz bir [ECDSA yardımcı kütüphanesine](https://docs.openzeppelin.com/contracts/2.x/api/cryptography#ECDSA) sahiptir.
Not
Bir _özel blok zincirinde_ `sha256`, `ripemd160` veya `ecrecover` çalıştırırken, Out-of-Gas (Bitmiş Gas) ile karşılaşabilirsiniz. Bunun nedeni, bu fonksiyonların “önceden derlenmiş sözleşmeler” olarak uygulanması ve yalnızca ilk mesajı aldıktan sonra gerçekten var olmalarıdır (sözleşme kodları sabit kodlanmış olsa da). Mevcut olmayan sözleşmelere gönderilen mesajlar daha pahalıdır ve bu nedenle yürütme sırasında Out-of-Gas (Bitmiş Gas) hatasıyla karşılaşabilir. Bu sorun için geçici bir çözüm, gerçek sözleşmelerinizde kullanmadan önce her bir sözleşmeye Wei (örneğin 1) göndermektir. Bu sorun, ana veya test ağında bir geçerli değildir.
### Adres Tipleri Üyeleri[](#adres-tipleri-uyeleri "Permalink to this heading")
`<address>.balance` (`uint256`)
Wei biçimindeki [Adresler](https://docs.soliditylang.org/tr/latest/types.html#address) bakiyesi
`<address>.code` (`bytes memory`)
ref:address adresindeki kod (boş olabilir)
`<address>.codehash` (`bytes32`)
ref:address kod hash’i
`<address payable>.transfer(uint256 amount)`
verilen Wei miktarını [Adresler](https://docs.soliditylang.org/tr/latest/types.html#address) ‘ine gönderir, başarısız olması durumunda geri döner, 2300 gas ücreti iletir, ayarlanabilir değildir
`<address payable>.send(uint256 amount) returns (bool)`
verilen Wei miktarını [Adresler](https://docs.soliditylang.org/tr/latest/types.html#address) ‘ine gönderir, başarısız olması durumunda `false` döndürür, 2300 gas ücreti iletir, ayarlanabilir değildir
`<address>.call(bytes memory) returns (bool, bytes memory)`
verilen yük ile düşük seviyeli `CALL` yayınlar, başarı koşulu ve dönüş verisi döndürür, mevcut tüm gas’ı iletir, ayarlanabilirdir
`<address>.delegatecall(bytes memory) returns (bool, bytes memory)`
verilen yük ile düşük seviyeli `DELEGATECALL` yayınlar, başarı koşulu ve dönüş verisi döndürür, mevcut tüm gazı iletir, ayarlanabilirdir
`<address>.staticcall(bytes memory) returns (bool, bytes memory)`
verilen yük ile düşük seviyeli `STATICCALL` yayınlar, başarı koşulunu ve dönüş verilerini döndürür, mevcut tüm gazı iletir, ayarlanabilirdir
Daha fazla bilgi için [Adresler](https://docs.soliditylang.org/tr/latest/types.html#address) ile ilgili bölüme bakın.
Uyarı
Başka bir sözleşme fonksiyonunu çalıştırırken mümkün olduğunca `.call()` kullanmaktan kaçınmalısınız, çünkü bu tür denetimi, fonksiyon varlığı denetimini ve argüman paketlemeyi atlar.
Uyarı
`send` kullanmanın bazı tehlikeleri vardır: Çağrı yığını derinliği 1024 ise transfer başarısız olur (bu her zaman çağıran kişi tarafından zorlanabilir) ve ayrıca alıcının gas’ı biterse de başarısız olur. Bu nedenle, güvenli Ether transferleri yapmak için, her zaman `send` dönüş değerini kontrol edin, `transfer` kullanın veya daha da iyisi: Alıcının parayı çektiği bir model kullanın.
Uyarı
ESM’nin mevcut olmayan bir sözleşmeye yapılan bir çağrının her zaman başarılı olacağını düşünmesi nedeniyle, Solidity harici çağrılar gerçekleştirirken `extcodesize` işlem kodunu kullanarak ekstra bir kontrol yapar. Bu, çağrılmak üzere olan sözleşmenin ya gerçekten var olmasını (kod içermesini) ya da bir istisnanın ortaya çıkmasını sağlar.
Sözleşme örnekleri yerine adresler üzerinde çalışan düşük seviyeli çağrılar (yani `.call()`, `.delegatecall()`, `.staticcall()`, `.send()` ve `.transfer()`) Bu kontrolü **içermezler**, bu da onları gas açısından daha ucuz ama aynı zamanda daha az güvenli hale getirir.
Not
0.5.0 sürümünden önce, Solidity adres üyelerine bir sözleşme örneği tarafından erişilmesine izin veriyordu, örnek vermek gerekirse `this.balance`. Bu fonksiyon artık yasaklanmıştır ve adrese yönelik olarak açık bir dönüşüm yapılmalıdır: `address(this).balance`.
Not
Durum değişkenlerine düşük seviyeli bir “delegatecall” yoluyla erişiliyorsa eğer, çağrılan sözleşmenin çağıran sözleşme tarafından depolama değişkenlerine adıyla doğru şekilde erişebilmesi için iki sözleşmenin depolama düzeninin aynı hizada olması gerekir. Üst düzey kütüphanelerde olduğu gibi depolama işaretçilerinin(pointer) fonksiyon argümanları olarak aktarılması durumunda bu durum elbette geçerli değildir.
Not
0.5.0 sürümünden önce, `.call`, `.delegatecall` ve `.staticcall` yalnızca başarı koşulunu döndürüyordu, dönüş verisini döndürmüyordu.
Not
0.5.0 sürümünden önce, `delegatecall` ile benzer ancak biraz farklı anlamlara sahip `callcode` adlı bir üye de bulunmaktaydı.
### Sözleşme İle İlgili[](#sozlesme-ile-ilgili "Permalink to this heading")
`this` (mevcut sözleşmenin türü)
mevcut sözleşme, açıkça [Adresler](https://docs.soliditylang.org/tr/latest/types.html#address)’ine dönüştürülebilir
`selfdestruct(ödenebilir alıcı adresi)`
Mevcut sözleşmeyi yok eder, fonlarını verilen [Adresler](https://docs.soliditylang.org/tr/latest/types.html#address) e gönderir ve yürütür. `selfdestruct`’ın ESM’den miras kalan bazı özelliklere sahip olduğunu unutmayın:
* alıcı sözleşmenin alma(receive) fonksiyonu yürütülmez.
 
* sözleşme sadece işlemin sonunda gerçekten yok edilir ve `revert` bu yok edilme işlemini “geri alabilir”.
 
Ayrıca, geçerli sözleşmenin tüm fonksiyonları, geçerli fonksiyon da dahil olmak üzere doğrudan çağrılabilir.
Not
0.5.0 sürümünden önce, `selfdestruct` ile aynı semantiğe sahip `suicide` adlı bir fonksiyon bulunmaktaydı.
### Type Bilgileri[](#type-bilgileri "Permalink to this heading")
`type(X)` ifadesi `X` türü hakkında bilgi almak için kullanılabilir. Şu anda, bu özellik için sınırlı bir destek bulunmaktadır (`X` bir sözleşme veya tamsayı türü olabilir), ancak gelecekte genişletilebilir.
Aşağıdaki özellikler bir sözleşme tipi(type) `C` için kullanılabilir:
`type(C).name`
Sözleşmenin ismi.
`type(C).creationCode`
Sözleşmenin oluşturma bayt kodunu içeren bellek bayt dizisi. Bu, özellikle `create2` işlem kodu kullanılarak özel oluşturma rutinleri oluşturmak için satır içi derlemede kullanılabilir. Bu özelliğe sözleşmenin kendisinden veya türetilmiş herhangi bir sözleşmeden **erişilemez**. Bytecode’un çağrı bölgesisin bytecode’una dahil edilmesine neden olur ve bu nedenle bunun gibi döngüsel referanslar mümkün değildir.
`type(C).runtimeCode`
Sözleşmenin çalışma zamanı bayt kodunu içeren bellek bayt dizisi. Bu, genellikle `C` yapıcısı tarafından dağıtılan koddur. Eğer `C``nin inline assembly kullanan bir kurucusu varsa, bu gerçekte dağıtılan bytecode'dan farklı olabilir. Ayrıca, kütüphanelerin normal çağrılara karşı koruma sağlamak için dağıtım sırasında çalışma zamanı bayt kodlarını değiştirdiklerini unutmayın. Bu özellik için de ``.creationCode` ile aynı kısıtlamalar geçerlidir.
Yukarıdaki özelliklere ek olarak, bir arayüz tipi `I` için aşağıdaki özellikler kullanılabilir:
`type(I).interfaceId`:
Verilen `I` arayüzünün ```EIP-165 <https://eips.ethereum.org/EIPS/eip-165>`_ arayüz tanımlayıcısını içeren bir ``bytes4``` değeri. Bu tanımlayıcı, miras alınan tüm fonksiyonlar hariç olmak üzere, arayüzün kendi içinde tanımlanan tüm fonksiyon seçicilerinin `XOR` ‘u olarak tanımlanır.
Aşağıdaki özellikler `T` tamsayı(integer) türü için kullanılabilir:
`type(T).min`
`T` tipi tarafından temsil edilebilen en küçük değer.
`type(T).max`
`T` tipi tarafından temsil edilebilen en büyük değer.
## Reserved Keywords[](#reserved-keywords "Permalink to this heading")
These keywords are reserved in Solidity. They might become part of the syntax in the future:
`after`, `alias`, `apply`, `auto`, `byte`, `case`, `copyof`, `default`, `define`, `final`, `implements`, `in`, `inline`, `let`, `macro`, `match`, `mutable`, `null`, `of`, `partial`, `promise`, `reference`, `relocatable`, `sealed`, `sizeof`, `static`, `supports`, `switch`, `typedef`, `typeof`, `var`.

# [Solidity — Solidity 0.4.26 documentation](https://docs.soliditylang.org/en/v0.4.26/index.html) 
 _https://docs.soliditylang.org/en/v0.4.26/index.html_

[
](https://docs.soliditylang.org/en/v0.4.26/_images/logo.svg)
Solidity is a contract-oriented, high-level language for implementing smart contracts. It was influenced by C++, Python and JavaScript and is designed to target the Ethereum Virtual Machine (EVM).
Solidity is statically typed, supports inheritance, libraries and complex user-defined types among other features.
As you will see, it is possible to create contracts for voting, crowdfunding, blind auctions, multi-signature wallets and more.
Note
The best way to try out Solidity right now is using [Remix](https://remix.ethereum.org/) (it can take a while to load, please be patient). Remix is a web browser based IDE that allows you to write Solidity smart contracts, then deploy and run the smart contracts.
Warning
Since software is written by humans, it can have bugs. Thus, also smart contracts should be created following well-known best-practices in software development. This includes code review, testing, audits and correctness proofs. Also note that users are sometimes more confident in code than its authors. Finally, blockchains have their own things to watch out for, so please take a look at the section [Security Considerations](https://docs.soliditylang.org/en/v0.4.26/security-considerations.html#security-considerations).
## Translations[¶](#translations "Permalink to this headline")
This documentation is translated into several languages by community volunteers, but the English version stands as a reference.
* [Simplified Chinese](http://solidity-cn.readthedocs.io/) (in progress)
* [Spanish](https://solidity-es.readthedocs.io/)
* [Russian](https://github.com/ethereum/wiki/wiki/%5BRussian%5D-%D0%A0%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE-%D0%BF%D0%BE-Solidity) (rather outdated)
* [Korean](http://solidity-kr.readthedocs.io/) (in progress)
## Available Solidity Integrations[¶](#available-solidity-integrations "Permalink to this headline")
* [Remix](https://remix.ethereum.org/)
 
 Browser-based IDE with integrated compiler and Solidity runtime environment without server-side components.
 
* [IntelliJ IDEA plugin](https://plugins.jetbrains.com/plugin/9475-intellij-solidity)
 
 Solidity plugin for IntelliJ IDEA (and all other JetBrains IDEs)
 
* [Visual Studio Extension](https://visualstudiogallery.msdn.microsoft.com/96221853-33c4-4531-bdd5-d2ea5acc4799/)
 
 Solidity plugin for Microsoft Visual Studio that includes the Solidity compiler.
 
* [Package for SublimeText — Solidity language syntax](https://packagecontrol.io/packages/Ethereum/)
 
 Solidity syntax highlighting for SublimeText editor.
 
* [Etheratom](https://github.com/0mkara/etheratom)
 
 Plugin for the Atom editor that features syntax highlighting, compilation and a runtime environment (Backend node & VM compatible).
 
* [Atom Solidity Linter](https://atom.io/packages/linter-solidity)
 
 Plugin for the Atom editor that provides Solidity linting.
 
* [Atom Solium Linter](https://atom.io/packages/linter-solium)
 
 Configurable Solidty linter for Atom using Solium as a base.
 
* [Solium](https://github.com/duaraghav8/Solium/)
 
 Linter to identify and fix style and security issues in Solidity.
 
* [Solhint](https://github.com/protofire/solhint)
 
 Solidity linter that provides security, style guide and best practice rules for smart contract validation.
 
* [Visual Studio Code extension](http://juan.blanco.ws/solidity-contracts-in-visual-studio-code/)
 
 Solidity plugin for Microsoft Visual Studio Code that includes syntax highlighting and the Solidity compiler.
 
* [Emacs Solidity](https://github.com/ethereum/emacs-solidity/)
 
 Plugin for the Emacs editor providing syntax highlighting and compilation error reporting.
 
* [Vim Solidity](https://github.com/tomlion/vim-solidity/)
 
 Plugin for the Vim editor providing syntax highlighting.
 
* [Vim Syntastic](https://github.com/scrooloose/syntastic)
 
 Plugin for the Vim editor providing compile checking.
 
Discontinued:
* [Mix IDE](https://github.com/ethereum/mix/)
 
 Qt based IDE for designing, debugging and testing solidity smart contracts.
 
* [Ethereum Studio](https://live.ether.camp/)
 
 Specialized web IDE that also provides shell access to a complete Ethereum environment.

# [Akıllı Sözleşmeler — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/contracts.html) 
 _https://docs.soliditylang.org/tr/latest/contracts.html_

Solidity’deki akıllı sözleşmeler nesne yönelimli programlama dillerine benzerdir. State değişkenlerinde kalıcı data içerirler ve fonksiyonlar bu değişkenlerin değerini değiştirebilir. Başka bir akıllı sözleşmedeki fonksiyonu çağırmak bir EVM fonksiyon çağrısı gerçekleştirir ve burada çağıran akıllı sözleşmenin state değişkenlerine erişilemez. Akıllı sözleşmede herhangi bir şeyin yaşanmasını istiyorsanız o akıllı sözleşmenin herhangi bir fonksiyonunu çağırmanız gerekir. Çünkü Ethereum’da “cron” konsepti yoktur, yani akıllı sözleşmeler kendi başlarına bir şeyler yapamaz. Dışarıdan tetiklenmeleri gerekir.
## Akıllı Sözleşme Oluşturma[](#akilli-sozlesme-olusturma "Permalink to this heading")
Akıllı sözleşmeler iki şekilde oluşturulabilir; “dışarıdan” bir Ethereum transactionı ile veya Solidity kullanarak direkt başka bir akıllı sözleşme içerisinde.
[Remix](https://remix.ethereum.org/) gibi IDE’ler oluşturma aşamasını kullanıcı arayüzü kullanarak kolayca gerçekleştirmenize yardımcı olur.
Programlama ile akıllı sözleşme oluşturmanın bir yolu ise [web3.js](https://github.com/ethereum/web3.js) gibi bir JavaScript API kullanımıdır. Akıllı sözleşme oluşturmaya yarayan [web3.eth.Contract](https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract) isimli bir methodu vardır.
Bir akıllı sözleşme oluşturulduğu zaman [constructor](#constructor) isimli bir fonksiyon sadece bir kere olmak üzere çalıştırılır. Bundan sonra bu fonksiyona erişim mümkün değildir.
Constructor kullanmak zorunlu değildir. Bir akıllı sözleşmede sadece bir adet constructor olabilir ve overloading yapılması mümkün değildir.
Constructor çalıştırıldıktan sonra akıllı sözleşme kodunun son hali blok zincirinde saklanır. Bu kod bütün public ve external fonksiyonları içerir. Deploy edilen kod constructor fonksiyonu ve sadece constructor içerisinde çağrılan internal fonksiyonları içermez.
Özünde constructor parametreleri [ABI encoded](https://docs.soliditylang.org/tr/latest/abi-spec.html#abi) olarak akıllı sözleşme kodunun sonuna eklenir (bytecode halinin), ama eğer `web3.js` kullanıyorsanız bunu umursamanıza gerek yok. Çünkü o sizin için bu işlemleri gerçekleştiriyor.
Eğer bir akıllı sözleşme başka bir akıllı sözleşme oluşturmak istiyorsa, oluşturmak istediği akıllı sözleşmenin kaynak kodunu (ve binary halini) bilmelidir. Bu demektir ki döngüsel olarak akıllı sözleşme oluşturmak mümkün değildir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCgpjb250cmFjdCBPd25lZFRva2VuIHsKICAgIC8vIGBUb2tlbkNyZWF0b3JgIGHFn2HEn8SxZGEgYmVsaXJ0aWxtacWfIGJpciBha8SxbGzEsSBzw7Z6bGXFn21lIHRpcGlkaXIuCiAgICAvLyBZZW5pIGJpciBha8SxbGzEsSBzw7Z6bGXFn21lIG9sdcWfdHVybWFrIGnDp2luIGt1bGxhbsSxbG1hZMSxxJ/EsSBzw7xyZWNlCiAgICAvLyByZWZlcmFucyBldG1la3RlIHNvcnVuIHlva3R1ci4KICAgIFRva2VuQ3JlYXRvciBjcmVhdG9yOwogICAgYWRkcmVzcyBvd25lcjsKICAgIGJ5dGVzMzIgbmFtZTsKCiAgICAvLyBCdXJhc8SxIGNvbnN0cnVjdG9yIGZvbmtzaXlvbnVtdXouIEJ1cmFkYQogICAgLy8gYmVsaXJ0aWxlbiBpc2ltIHZlIGFrxLFsbMSxIHPDtnpsZcWfbWV5aSBvbHXFn3R1cmFuIGFkcmVzCiAgICAvLyBha8SxbGzEsSBzw7Z6bGXFn21lZGUga2F5ZGVkaWxpci4KICAgIGNvbnN0cnVjdG9yKGJ5dGVzMzIgbmFtZV8pIHsKICAgICAgICAvLyBTdGF0ZSBkZcSfacWfa2VubGVyaW5lIGlzaW1sZXJpIGt1bGxhbsSxbGFyYWsKICAgICAgICAvLyBlcmnFn2lsaXIuIGB0aGlzLm93bmVyYCDFn2VrbGluZGUgYmlyIGt1bGxhbsSxbQogICAgICAgIC8vIGlsZSBkZcSfaWwuIEZvbmtzaXlvbmxhcmEgZGlyZWt0IG9sYXJhayBrZW5kaQogICAgICAgIC8vIGlzaW1sZXJpbmkga3VsbGFuYXJhayB2ZXlhIGB0aGlzLmZgIMWfZWtsaW5kZQogICAgICAgIC8vIGJpciBrdWxsYW7EsW0gaWxlIGVyacWfZWJpbGlyaXouIEFuY2FrIGlraW5jaQogICAgICAgIC8vIMWfZWtpbGRla2kga3VsbGFuxLFtIGV4dGVybmFsIG9sYXJhayAoZMSxxZ9hcsSxZGFuKQogICAgICAgIC8vIGJpciBnw7Zyw7zFnyBzYcSfbGFyLiDDlnplbGxpa2xlIGNvbnN0cnVjdG9ybGFyZGEsCiAgICAgICAgLy8gZm9ua3NpeW9ubGFyYSBleHRlcm5hbCBvbGFyYWsgZXJpxZ9tZW1lbGlzaW5pei4KICAgICAgICAvLyDDh8O8bmvDvCBvIGZvbmtzaXlvbmxhciBoZW7DvHogb2x1xZ90dXJ1bG1hZMSxLCB5YW5pCiAgICAgICAgLy8gZXJpxZ9pbGViaWxpciBkZcSfaWwuCiAgICAgICAgLy8gRGFoYSBmYXpsYXPEsSBpw6dpbiBiaXIgc29ucmFraSBiw7Zsw7xtZSBiYWthYmlsaXJzaW5pei4KICAgICAgICBvd25lciA9IG1zZy5zZW5kZXI7CgogICAgICAgIC8vIEJ1cmFkYSBgYWRkcmVzc2AgdGlwaW5kZW4gYFRva2VuQ3JlYXRvcmAgdGlwaW5lCiAgICAgICAgLy8gYmlyIGV4cGxpY2l0IChhw6fEsWspIGTDtm7DvMWfw7xtIHNhxJ9sYXLEsXogdmUgYnUgZm9ua3NpeW9udQogICAgICAgIC8vIMOnYcSfxLFyYW4gYWvEsWxsxLEgc8O2emxlxZ9tZW5pbiBiaXIgYFRva2VuQ3JlYXRvcmAgb2xkdcSfdW51IHZhcnNheWFyxLF6LgogICAgICAgIC8vIEJ1bnUgZG/En3J1bGFtYW7EsW4gZ2Vyw6dlayBiaXIgecO2bnRlbWkgYnVsdW5tYW1ha3RhLgogICAgICAgIC8vIEJ1IGnFn2xlbSB5ZW5pIGJpciBha8SxbGzEsSBzw7Z6bGXFn21lIG9sdcWfdHVybWF6LgogICAgICAgIGNyZWF0b3IgPSBUb2tlbkNyZWF0b3IobXNnLnNlbmRlcik7CiAgICAgICAgbmFtZSA9IG5hbWVfOwogICAgfQoKICAgIGZ1bmN0aW9uIGNoYW5nZU5hbWUoYnl0ZXMzMiBuZXdOYW1lKSBwdWJsaWMgewogICAgICAgIC8vIFNhZGVjZSBgY3JlYXRvcmAgYG5hbWVgIGRlxJ9pxZ9rZW5pbmkgZGXEn2nFn3RpcmViaWxpci4KICAgICAgICAvLyBBa8SxbGzEsSBzw7Z6bGXFn21lbmluIGFkcmVzaW5pIGV4cGxpY2l0IGJpciBkw7Zuw7zFn8O8bSBpbGUKICAgICAgICAvLyBlbGRlIGVkZWJpbGlyIHZlIGthcsWfxLFsYcWfdMSxcm1hbcSxesSxIHlhcGFiaWxpcml6LgogICAgICAgIGlmIChtc2cuc2VuZGVyID09IGFkZHJlc3MoY3JlYXRvcikpCiAgICAgICAgICAgIG5hbWUgPSBuZXdOYW1lOwogICAgfQoKICAgIGZ1bmN0aW9uIHRyYW5zZmVyKGFkZHJlc3MgbmV3T3duZXIpIHB1YmxpYyB7CiAgICAgICAgLy8gU2FkZWNlIMWfdSBhbmtpIGBvd25lcmAgdG9rZW4gdHJhbnNmZXJpIGdlcsOnZWtsZcWfdGlyZWJpbGlyLgogICAgICAgIGlmIChtc2cuc2VuZGVyICE9IG93bmVyKSByZXR1cm47CgogICAgICAgIC8vIGBjcmVhdG9yYCBhZHJlc2luZGVraSBha8SxbGzEsSBzw7Z6bGXFn21lbmluIGJpciBmb25rc2l5b251bnUKICAgICAgICAvLyBrdWxsYW5hcmFrLCBpxZ9sZW1pbiBnZXLDp2VrbGXFn3RpcmlsZWJpbGlybGnEn2luaQogICAgICAgIC8vIGtvbnRyb2wgZWRlYmlsaXIuIEXEn2VyIGJ1IGnFn2xlbSBoYXRhIHZlcmlyc2UKICAgICAgICAvLyAow7ZybmXEn2luLCBvdXQtb2YtZ2FzIChnYXrEsW4gdMO8a2VubWVzaSkpLAogICAgICAgIC8vIGnFn2xlbSBidXJhZGEgc29uIGJ1bHVyLgogICAgICAgIGlmIChjcmVhdG9yLmlzVG9rZW5UcmFuc2Zlck9LKG93bmVyLCBuZXdPd25lcikpCiAgICAgICAgICAgIG93bmVyID0gbmV3T3duZXI7CiAgICB9Cn0KCgpjb250cmFjdCBUb2tlbkNyZWF0b3IgewogICAgZnVuY3Rpb24gY3JlYXRlVG9rZW4oYnl0ZXMzMiBuYW1lKQogICAgICAgIHB1YmxpYwogICAgICAgIHJldHVybnMgKE93bmVkVG9rZW4gdG9rZW5BZGRyZXNzKQogICAgewogICAgICAgIC8vIFllbmkgYmlyIGBUb2tlbmAgYWvEsWxsxLEgc8O2emxlxZ9tZXlpIG9sdcWfdHVydXIgdmUgYWRyZXNpbmkgcmV0dXJuIGVkZXIuCiAgICAgICAgLy8gSmF2YVNjcmlwdCB0YXJhZsSxbmRhIHJldHVybiB0aXBpIGBhZGRyZXNzYCB0aXBpZGlyLgogICAgICAgIHJldHVybiBuZXcgT3duZWRUb2tlbihuYW1lKTsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGFuZ2VOYW1lKE93bmVkVG9rZW4gdG9rZW5BZGRyZXNzLCBieXRlczMyIG5hbWUpIHB1YmxpYyB7CiAgICAgICAgLy8gYHRva2VuQWRkcmVzc2AgaXNpbWxpIHBhcmFtZXRyZW5pbiB0aXBpCiAgICAgICAgLy8gYGFkZHJlc3NgIHRpcGluZGVuZGlyLgogICAgICAgIHRva2VuQWRkcmVzcy5jaGFuZ2VOYW1lKG5hbWUpOwogICAgfQoKICAgIC8vIEJpciB0cmFuc2ZlcmluIGdlcsOnZWtsZcWfaXAgZ2Vyw6dla2xlxZ9tZXllY2XEn2luaSBiZWxpcmxlcgogICAgZnVuY3Rpb24gaXNUb2tlblRyYW5zZmVyT0soYWRkcmVzcyBjdXJyZW50T3duZXIsIGFkZHJlc3MgbmV3T3duZXIpCiAgICAgICAgcHVibGljCiAgICAgICAgcHVyZQogICAgICAgIHJldHVybnMgKGJvb2wgb2spCiAgICB7CiAgICAgICAgLy8gS2V5ZmkgYmlyIGtvxZ91bCBpbGUgacWfbGVtaW4gZ2Vyw6dla2xlxZ9pcCBnZXLDp2VrbGXFn21leWVjZcSfaW5pCiAgICAgICAgLy8gYmVsaXJsZXIgdmUgc29udWN1IHJldHVybiBlZGVyLgogICAgICAgIHJldHVybiBrZWNjYWsyNTYoYWJpLmVuY29kZVBhY2tlZChjdXJyZW50T3duZXIsIG5ld093bmVyKSlbMF0gPT0gMHg3ZjsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.22 <0.9.0;
contract OwnedToken {
 // \`TokenCreator\` aşağıda belirtilmiş bir akıllı sözleşme tipidir.
 // Yeni bir akıllı sözleşme oluşturmak için kullanılmadığı sürece
 // referans etmekte sorun yoktur.
 TokenCreator creator;
 address owner;
 bytes32 name;
 // Burası constructor fonksiyonumuz. Burada
 // belirtilen isim ve akıllı sözleşmeyi oluşturan adres
 // akıllı sözleşmede kaydedilir.
 constructor(bytes32 name\_) {
 // State değişkenlerine isimleri kullanılarak
 // erişilir. \`this.owner\` şeklinde bir kullanım
 // ile değil. Fonksiyonlara direkt olarak kendi
 // isimlerini kullanarak veya \`this.f\` şeklinde
 // bir kullanım ile erişebiliriz. Ancak ikinci
 // şekildeki kullanım external olarak (dışarıdan)
 // bir görüş sağlar. Özellikle constructorlarda,
 // fonksiyonlara external olarak erişmemelisiniz.
 // Çünkü o fonksiyonlar henüz oluşturulmadı, yani
 // erişilebilir değil.
 // Daha fazlası için bir sonraki bölüme bakabilirsiniz.
 owner \= msg.sender;
 // Burada \`address\` tipinden \`TokenCreator\` tipine
 // bir explicit (açık) dönüşüm sağlarız ve bu fonksiyonu
 // çağıran akıllı sözleşmenin bir \`TokenCreator\` olduğunu varsayarız.
 // Bunu doğrulamanın gerçek bir yöntemi bulunmamakta.
 // Bu işlem yeni bir akıllı sözleşme oluşturmaz.
 creator \= TokenCreator(msg.sender);
 name \= name\_;
 }
 function changeName(bytes32 newName) public {
 // Sadece \`creator\` \`name\` değişkenini değiştirebilir.
 // Akıllı sözleşmenin adresini explicit bir dönüşüm ile
 // elde edebilir ve karşılaştırmamızı yapabiliriz.
 if (msg.sender \== address(creator))
 name \= newName;
 }
 function transfer(address newOwner) public {
 // Sadece şu anki \`owner\` token transferi gerçekleştirebilir.
 if (msg.sender != owner) return;
 // \`creator\` adresindeki akıllı sözleşmenin bir fonksiyonunu
 // kullanarak, işlemin gerçekleştirilebilirliğini
 // kontrol edebilir. Eğer bu işlem hata verirse
 // (örneğin, out-of-gas (gazın tükenmesi)),
 // işlem burada son bulur.
 if (creator.isTokenTransferOK(owner, newOwner))
 owner \= newOwner;
 }
}
contract TokenCreator {
 function createToken(bytes32 name)
 public
 returns (OwnedToken tokenAddress)
 {
 // Yeni bir \`Token\` akıllı sözleşmeyi oluşturur ve adresini return eder.
 // JavaScript tarafında return tipi \`address\` tipidir.
 return new OwnedToken(name);
 }
 function changeName(OwnedToken tokenAddress, bytes32 name) public {
 // \`tokenAddress\` isimli parametrenin tipi
 // \`address\` tipindendir.
 tokenAddress.changeName(name);
 }
 // Bir transferin gerçekleşip gerçekleşmeyeceğini belirler
 function isTokenTransferOK(address currentOwner, address newOwner)
 public
 pure
 returns (bool ok)
 {
 // Keyfi bir koşul ile işlemin gerçekleşip gerçekleşmeyeceğini
 // belirler ve sonucu return eder.
 return keccak256(abi.encodePacked(currentOwner, newOwner))\[0\] \== 0x7f;
 }
}
## Görünürlük ve Getter Fonksiyonlar[](#gorunurluk-ve-getter-fonksiyonlar "Permalink to this heading")
### Durum Değişkenlerinde Görünürlük[](#durum-degiskenlerinde-gorunurluk "Permalink to this heading")
`public`
Public durum değişkenleri internallerden sadece bir açıdan farklıdır, o da derleyicinin direkt olarak bir [getter fonksiyon](#getter-functions) oluşturmasıdır. Bu şekilde diğer akıllı sözleşmeler bu değerlere erişebilir. Aynı fonksiyon içerisinde external erişim sağlandığında (örneğin, `this.x`) getter fonksiyonu çağrılırken, internal erişimde (örneğin, `x`) değer direkt olarak storage’den alınır. Setter fonksiyonlar derleyici tarafından tanımlanmaz. Bu yüzden siz kendiniz bir setter fonksiyon eklemediyseniz diğer fonksiyonlar bu değişkeni değiştiremez.
`internal`
Internal durum değişkenleri sadece tanımlandıkları akıllı sözleşmeler ve o akıllı sözleşmelerden türetilen (inherited) akıllı sözleşmeler tarafından erişebilir durumdadır. External erişim mümkün değildir. Bütün durum değişkenlerinin default hali internal’dir.
`private`
Private durum değişkenlerine sadece tanımlandıkları akıllı sözleşmeden erişim mümkündür. Internal’den farklı olarak türetilen akıllı sözleşmelerden de erişilemez.
Uyarı
Bir şeyi `private` veya `internal` yapmak sadece diğer akıllı sözleşmelerin o bilgiye erişimini veya değiştirilmesini engeller. Ama bu bilgiler blok zinciri dışından erişilebilir durumdadır.
### Fonksiyonlarda Görünürlük[](#fonksiyonlarda-gorunurluk "Permalink to this heading")
Solidity iki tip fonksiyon çağrısı bilir: gerçek bir EVM mesaj çağrısı yapan external’lar ve bu çağrıyı yapmayan internal’lar. Ayrıca internal fonksiyonlar türetilen fonksiyonlardan erişilemez hale de getirilebilir. Bu da ortaya dört çeşit fonksiyon görünürlüğü çıkarır.
`external`
External fonksiyonlar akıllı sözleşme interface’inin bir parçasıdır, bu da demektir ki diğer akıllı sözleşmeler ve transactionlar tarafından çağrılabilirler. Bir `f` external fonksiyonu internal olarak çağrılamaz (yani, `f()` işe yaramaz, ama `this.f()` çalışır).
`public`
Public fonksiyonlar akıllı sözleşme interface’inin bir parçasıdır ve internal olarak veya mesaj çağrıları ile kullanılabilirler.
`internal`
Internal fonksiyonlar sadece tanımlandıkları akıllı sözleşmeden veya o akıllı sözleşmeden türetilen akıllı sözleşmeler tarafından erişilebilir. External olarak erişim mümkün değildir. ABI kullanılarak external olarak erişilemese bile mapping ve storage referanslarını parametre olarak alabilirler.
`private`
Private fonksiyonlar internaller gibidir ama bunlara türetilen fonksiyonlardan da erişim mümkün değildir.
Uyarı
Bir şeyi `private` veya `internal` yapmak sadece diğer akıllı sözleşmelerin o bilgiye erişimini veya değiştirilmesini engeller. Ama bu bilgiler blok zinciri dışından erişilebilir durumdadır.
Görünürlük parametreleri durum değişkenleri için değişkenin tipinden sonra yazılırken fonksiyonlarda parametreler ve return tanımının arasına yazılır.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50IGEpIHByaXZhdGUgcHVyZSByZXR1cm5zICh1aW50IGIpIHsgcmV0dXJuIGEgKyAxOyB9CiAgICBmdW5jdGlvbiBzZXREYXRhKHVpbnQgYSkgaW50ZXJuYWwgeyBkYXRhID0gYTsgfQogICAgdWludCBwdWJsaWMgZGF0YTsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 function f(uint a) private pure returns (uint b) { return a + 1; }
 function setData(uint a) internal { data \= a; }
 uint public data;
}
Aşağıdaki örnekte, `D`, `c.getData()` çağrısı yapabilir ve `data` değerini elde eder, ama `f` fonksiyonunu çağıramaz. `E` akıllı sözleşmeleri ise `C` akıllı sözleşmesinden türetildiği için `compute` fonksiyonunu çağırabilir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludCBwcml2YXRlIGRhdGE7CgogICAgZnVuY3Rpb24gZih1aW50IGEpIHByaXZhdGUgcHVyZSByZXR1cm5zKHVpbnQgYikgeyByZXR1cm4gYSArIDE7IH0KICAgIGZ1bmN0aW9uIHNldERhdGEodWludCBhKSBwdWJsaWMgeyBkYXRhID0gYTsgfQogICAgZnVuY3Rpb24gZ2V0RGF0YSgpIHB1YmxpYyB2aWV3IHJldHVybnModWludCkgeyByZXR1cm4gZGF0YTsgfQogICAgZnVuY3Rpb24gY29tcHV0ZSh1aW50IGEsIHVpbnQgYikgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7IHJldHVybiBhICsgYjsgfQp9CgovLyBCdSBha8SxbGzEsSBzw7Z6bGXFn21lIGRlcmxlbmVtZXosIGhhdGEgdmVyaXIKY29udHJhY3QgRCB7CiAgICBmdW5jdGlvbiByZWFkRGF0YSgpIHB1YmxpYyB7CiAgICAgICAgQyBjID0gbmV3IEMoKTsKICAgICAgICB1aW50IGxvY2FsID0gYy5mKDcpOyAvLyBoYXRhOiBgZmAgZ8O2csO8bsO8ciBkZcSfaWwKICAgICAgICBjLnNldERhdGEoMyk7CiAgICAgICAgbG9jYWwgPSBjLmdldERhdGEoKTsKICAgICAgICBsb2NhbCA9IGMuY29tcHV0ZSgzLCA1KTsgLy8gaGF0YTogYGNvbXB1dGVgIGfDtnLDvG7DvHIgZGXEn2lsCiAgICB9Cn0KCmNvbnRyYWN0IEUgaXMgQyB7CiAgICBmdW5jdGlvbiBnKCkgcHVibGljIHsKICAgICAgICBDIGMgPSBuZXcgQygpOwogICAgICAgIHVpbnQgdmFsID0gY29tcHV0ZSgzLCA1KTsgLy8gaW50ZXJuYWwgZm9ua3NpeW9uYSB0w7xyZXRpbGVuIGZvbmtzaXlvbiBzYXllc2luZGUgZXJpxZ9pbSBzYcSfbGFuYWJpbGlyCiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 uint private data;
 function f(uint a) private pure returns(uint b) { return a + 1; }
 function setData(uint a) public { data \= a; }
 function getData() public view returns(uint) { return data; }
 function compute(uint a, uint b) internal pure returns (uint) { return a + b; }
}
// Bu akıllı sözleşme derlenemez, hata verir
contract D {
 function readData() public {
 C c \= new C();
 uint local \= c.f(7); // hata: \`f\` görünür değil
 c.setData(3);
 local \= c.getData();
 local \= c.compute(3, 5); // hata: \`compute\` görünür değil
 }
}
contract E is C {
 function g() public {
 C c \= new C();
 uint val \= compute(3, 5); // internal fonksiyona türetilen fonksiyon sayesinde erişim sağlanabilir
 }
}
### Getter Fonksiyonlar[](#getter-fonksiyonlar "Permalink to this heading")
Derleyici bütün **public** durum değişkenleri için getter fonksiyonu oluşturur. Örneğin aşağıdaki akıllı sözleşme için, derleyici `data` adında bir fonksiyon üretir. Bu fonksiyon hiçbir parametre almaz ve `uint` tipinde bir değişken return eder. Return edilen değer ise `data` değişkeninde saklanan değerdir. Durum değişkenleri tanımlandıkları yerde initialize edilebilir (initialize, bir değişkenin ilk defa tanımlanması olarak çevrilebilir).
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludCBwdWJsaWMgZGF0YSA9IDQyOwp9Cgpjb250cmFjdCBDYWxsZXIgewogICAgQyBjID0gbmV3IEMoKTsKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGMuZGF0YSgpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 uint public data \= 42;
}
contract Caller {
 C c \= new C();
 function f() public view returns (uint) {
 return c.data();
 }
}
Getter fonksiyonların görünürlüğü external’dir. Eğer internal olarak erişim sağlandıysa (`this.` olmadan), bu bir durum değişkenine erişim anlamına gelir. Eğer external olarak erişildiyse (`this.` kullanarak), bu getter fonksiyonuna erişim anlamına gelir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50IHB1YmxpYyBkYXRhOwogICAgZnVuY3Rpb24geCgpIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgZGF0YSA9IDM7IC8vIGludGVybmFsIGVyacWfaW0KICAgICAgICByZXR1cm4gdGhpcy5kYXRhKCk7IC8vIGV4dGVybmFsIGVyacWfaW0KICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract C {
 uint public data;
 function x() public returns (uint) {
 data \= 3; // internal erişim
 return this.data(); // external erişim
 }
}
Eğer bir `public` görünürlüğe sahip dizi tipinden bir durum değişkenine sahipseniz, getter fonksiyonunu kullanarak sadece tek bir elemana erişim sağlayabilirsiniz. Bu mekanizma tüm diziyi return ederken oluşan yüksek gaz ücretlerinden sıyrılmak için kurulmuştur. Hangi elemanın return edileceğini belirtmek için parametreleri kullanabilirsiniz (örneğin, `myArray(0)`). Eğer bütün diziyi tek bir fonksiyon ile elde etmeniz gerekiyorsa, bunun için aşağıdaki gibi bir fonksiyon yazmanız gerekir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IGFycmF5RXhhbXBsZSB7CiAgICAvLyBwdWJsaWMgZHVydW0gZGXEn2nFn2tlbmkKICAgIHVpbnRbXSBwdWJsaWMgbXlBcnJheTsKCiAgICAvLyBEZXJsZXlpY2kgdGFyYWbEsW5kYW4gdGFuxLFtbGFuYW4gZ2V0dGVyIGZvbmtzaXlvbnUKICAgIC8qCiAgICBmdW5jdGlvbiBteUFycmF5KHVpbnQgaSkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBteUFycmF5W2ldOwogICAgfQogICAgKi8KCiAgICAvLyBCw7x0w7xuIGFycmF5J2kgcmV0dXJuIGVkZW4gZm9ua3NpeW9uCiAgICBmdW5jdGlvbiBnZXRBcnJheSgpIHB1YmxpYyB2aWV3IHJldHVybnMgKHVpbnRbXSBtZW1vcnkpIHsKICAgICAgICByZXR1cm4gbXlBcnJheTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract arrayExample {
 // public durum değişkeni
 uint\[\] public myArray;
 // Derleyici tarafından tanımlanan getter fonksiyonu
 /\*
 function myArray(uint i) public view returns (uint) {
 return myArray\[i\];
 }
 \*/
 // Bütün array'i return eden fonksiyon
 function getArray() public view returns (uint\[\] memory) {
 return myArray;
 }
}
Artık tüm dizine erişmek için her bir aramayı tek bir öğeye döndüren `myArray(i)` yerine `getArray()` kullanabilirsiniz.
Sıradaki örnek biraz daha karmaşık.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQ29tcGxleCB7CiAgICBzdHJ1Y3QgRGF0YSB7CiAgICAgICAgdWludCBhOwogICAgICAgIGJ5dGVzMyBiOwogICAgICAgIG1hcHBpbmcgKHVpbnQgPT4gdWludCkgbWFwOwogICAgICAgIHVpbnRbM10gYzsKICAgICAgICB1aW50W10gZDsKICAgICAgICBieXRlcyBlOwogICAgfQogICAgbWFwcGluZyAodWludCA9PiBtYXBwaW5nKGJvb2wgPT4gRGF0YVtdKSkgcHVibGljIGRhdGE7Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract Complex {
 struct Data {
 uint a;
 bytes3 b;
 mapping (uint \=> uint) map;
 uint\[3\] c;
 uint\[\] d;
 bytes e;
 }
 mapping (uint \=> mapping(bool \=> Data\[\])) public data;
}
Derleyici bize aşağıdaki gibi bir getter fonksiyonu oluşturur. Struct’daki mapping’ler ve diziler (byte dizileri istisnadır) gözardı edilmiştir. Çünkü getter fonksiyonlarında onların spesifik bir elemanına uygun bir şekilde erişim mümkün değildir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=ZnVuY3Rpb24gZGF0YSh1aW50IGFyZzEsIGJvb2wgYXJnMiwgdWludCBhcmczKQogICAgcHVibGljCiAgICByZXR1cm5zICh1aW50IGEsIGJ5dGVzMyBiLCBieXRlcyBtZW1vcnkgZSkKewogICAgYSA9IGRhdGFbYXJnMV1bYXJnMl1bYXJnM10uYTsKICAgIGIgPSBkYXRhW2FyZzFdW2FyZzJdW2FyZzNdLmI7CiAgICBlID0gZGF0YVthcmcxXVthcmcyXVthcmczXS5lOwp9)
function data(uint arg1, bool arg2, uint arg3)
 public
 returns (uint a, bytes3 b, bytes memory e)
{
 a \= data\[arg1\]\[arg2\]\[arg3\].a;
 b \= data\[arg1\]\[arg2\]\[arg3\].b;
 e \= data\[arg1\]\[arg2\]\[arg3\].e;
}
## Fonksiyon Modifier’ları[](#fonksiyon-modifier-lari "Permalink to this heading")
Modifier’lar fonksiyonların tanımlandığı şekillerinden farklı davranmalarını sağlamak için kullanılabilir. Örneğin, bir fonksiyonun çalıştırılmasından hemen önce bir koşulun kontrolünü gerçekleştirebilirsiniz.
Modifier’lar akıllı sözleşmelerin türetilebilen özelliklerindendir. Bu yüzden türetilmiş bir akıllı sözleşme bir modifier’ı eğer `virtual` olarak belirtilmişse onu override edebilir. Daha fazla bilgi için [Modifier Overriding](#modifier-overriding) kısmına bakabilirsiniz.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwoKICAgIC8vIEJ1IGFrxLFsbMSxIHPDtnpsZcWfbWUgc2FkZWNlIGJpciB0YW5lIG1vZGlmaWVyIHRhbsSxbWxhciB2ZSBvbnUgZGEga3VsbGFubcSxeW9yLgogICAgLy8gVGFuxLFtbGFuYW4gbW9kaWZpZXIgdMO8cmV0aWxlbiBmb25rc2l5b25kYSBrdWxsYW7EsWxhY2FrdMSxci4KICAgIC8vIEZvbmtzaXlvbiBpw6dlcmlzaW5kZWtpIGtvZGxhcsSxbiBrdWxsYW7EsWxhY2HEn8SxIHllcgogICAgLy8gYF87YCDFn2VrbGluZGUgbW9kaWZpZXIgacOnZXJpc2luZGUgYmVsaXJ0aWxpci4KICAgIC8vIFlhbmkgYF87YCBnw7ZyZMO8xJ/DvG7DvHogeWVyZGUgbyBtb2RpZmllcifEsW4ga3VsbGFuxLFsZMSxxJ/EsSBmb25rc2l5b251bgogICAgLy8gacOnZXJpc2luZGVraSBrb2RsYXIgeWF6xLFsbcSxxZ8gZ2liaSBkw7zFn8O8bmViaWxpcnNpbml6LgogICAgLy8gQnUgbW9kaWZpZXIgZWtsZW5kacSfaSBmb25rc2l5b251IHNhZGVjZSBha8SxbGzEsSBzw7Z6bGXFn21leWkgb2x1xZ90dXJhbgogICAgLy8ga2nFn2luaW4gw6dhxJ/EsXJtYXPEsW7EsSBzYcSfbGFyLiBEacSfZXIgZXJpxZ9pbWxlcmRlIGlzZSBpxZ9sZW1pIHJldmVydCBlZGVyLgogICAgbW9kaWZpZXIgb25seU93bmVyIHsKICAgICAgICByZXF1aXJlKAogICAgICAgICAgICBtc2cuc2VuZGVyID09IG93bmVyLAogICAgICAgICAgICAiT25seSBvd25lciBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uLiIKICAgICAgICApOwogICAgICAgIF87CiAgICB9Cn0KCmNvbnRyYWN0IGRlc3RydWN0aWJsZSBpcyBvd25lZCB7CiAgICAvLyBCdSBha8SxbGzEsSBzw7Z6bGXFn21lIHTDvHJldGlsZGnEn2kgYG93bmVkYCBmb25rc2l5b251bmRha2kKICAgIC8vIGBvbmx5T3duZXJgIG1vZGlmaWVyJ8SxbsSxIGBkZXN0cm95YCBmb25rc2l5b251bmEgZWtsZXIuCiAgICAvLyBCw7Z5bGVjZSBgZGVzdHJveWAgZm9ua3NpeW9udW51IHNhZGVjZSBgb3duZXJgIMOnYcSfxLFyYWJpbGlyLgogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyBvbmx5T3duZXIgewogICAgICAgIHNlbGZkZXN0cnVjdChvd25lcik7CiAgICB9Cn0KCmNvbnRyYWN0IHByaWNlZCB7CiAgICAvLyBNb2RpZmllcidsYXIgcGFyYW1ldHJlIGFsYWJpbGlyOgogICAgbW9kaWZpZXIgY29zdHModWludCBwcmljZSkgewogICAgICAgIGlmIChtc2cudmFsdWUgPj0gcHJpY2UpIHsKICAgICAgICAgICAgXzsKICAgICAgICB9CiAgICB9Cn0KCmNvbnRyYWN0IFJlZ2lzdGVyIGlzIHByaWNlZCwgZGVzdHJ1Y3RpYmxlIHsKICAgIG1hcHBpbmcgKGFkZHJlc3MgPT4gYm9vbCkgcmVnaXN0ZXJlZEFkZHJlc3NlczsKICAgIHVpbnQgcHJpY2U7CgogICAgY29uc3RydWN0b3IodWludCBpbml0aWFsUHJpY2UpIHsgcHJpY2UgPSBpbml0aWFsUHJpY2U7IH0KCiAgICAvLyBCdXJhZGFraSBgcGF5YWJsZWAgc8O2emPDvMSfw7wgZGUgb2xkdWvDp2Egw7ZuZW1saWRpci4KICAgIC8vIEXEn2VyIGJ1IGZvbmtzaXlvbiBgcGF5YWJsZWAgb2xtYXpzYSBrZW5kaXNpbmUgZ2VsZW4gYsO8dMO8bgogICAgLy8gZXRoZXJsZXJpIHJlZGRlZGVyLgogICAgZnVuY3Rpb24gcmVnaXN0ZXIoKSBwdWJsaWMgcGF5YWJsZSBjb3N0cyhwcmljZSkgewogICAgICAgIHJlZ2lzdGVyZWRBZGRyZXNzZXNbbXNnLnNlbmRlcl0gPSB0cnVlOwogICAgfQoKICAgIGZ1bmN0aW9uIGNoYW5nZVByaWNlKHVpbnQgcHJpY2VfKSBwdWJsaWMgb25seU93bmVyIHsKICAgICAgICBwcmljZSA9IHByaWNlXzsKICAgIH0KfQoKY29udHJhY3QgTXV0ZXggewogICAgYm9vbCBsb2NrZWQ7CiAgICBtb2RpZmllciBub1JlZW50cmFuY3koKSB7CiAgICAgICAgcmVxdWlyZSgKICAgICAgICAgICAgIWxvY2tlZCwKICAgICAgICAgICAgIlJlZW50cmFudCBjYWxsLiIKICAgICAgICApOwogICAgICAgIGxvY2tlZCA9IHRydWU7CiAgICAgICAgXzsKICAgICAgICBsb2NrZWQgPSBmYWxzZTsKICAgIH0KCiAgICAvLy8gQnUgZm9ua3NpeW9uIGJpciBtdXRleCBpbGUga29ydW5tYWt0YWTEsXIuCiAgICAvLy8gWWFuaSwgYnUgYWvEsWxsxLEgc8O2emxlxZ9tZSByZS1lbnRyYW5jeSDDp2HEn3LEsWxhcsSxbmEga2FyxZ/EsSB6YWFmaXlldGxpIGRlxJ9pbGRpci4KICAgIC8vLyBgcmV0dXJuIDdgIGZvbmtzaXlvbnVuIGJpdHRpxJ9pbmkgYmVsaXJ0c2UgZGUgaGVuw7x6IG1vZGlmaWVyJ8SxbcSxesSxbiBpxZ9pIGJpdG1lZGkuCiAgICAvLy8gYGxvY2tlZCA9IGZhbHNlO2Agc2F0xLFyxLEgcmV0dXJuIGlmYWRlbWl6ZGVuIHNvbnJhIMOnYWzEscWfxLFyLgogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBub1JlZW50cmFuY3kgcmV0dXJucyAodWludCkgewogICAgICAgIChib29sIHN1Y2Nlc3MsKSA9IG1zZy5zZW5kZXIuY2FsbCgiIik7CiAgICAgICAgcmVxdWlyZShzdWNjZXNzKTsKICAgICAgICByZXR1cm4gNzsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.1 <0.9.0;
contract owned {
 constructor() { owner \= payable(msg.sender); }
 address payable owner;
 // Bu akıllı sözleşme sadece bir tane modifier tanımlar ve onu da kullanmıyor.
 // Tanımlanan modifier türetilen fonksiyonda kullanılacaktır.
 // Fonksiyon içerisindeki kodların kullanılacağı yer
 // \`\_;\` şeklinde modifier içerisinde belirtilir.
 // Yani \`\_;\` gördüğünüz yerde o modifier'ın kullanıldığı fonksiyonun
 // içerisindeki kodlar yazılmış gibi düşünebilirsiniz.
 // Bu modifier eklendiği fonksiyonu sadece akıllı sözleşmeyi oluşturan
 // kişinin çağırmasını sağlar. Diğer erişimlerde ise işlemi revert eder.
 modifier onlyOwner {
 require(
 msg.sender \== owner,
 "Only owner can call this function."
 );
 \_;
 }
}
contract destructible is owned {
 // Bu akıllı sözleşme türetildiği \`owned\` fonksiyonundaki
 // \`onlyOwner\` modifier'ını \`destroy\` fonksiyonuna ekler.
 // Böylece \`destroy\` fonksiyonunu sadece \`owner\` çağırabilir.
 function destroy() public onlyOwner {
 selfdestruct(owner);
 }
}
contract priced {
 // Modifier'lar parametre alabilir:
 modifier costs(uint price) {
 if (msg.value \>= price) {
 \_;
 }
 }
}
contract Register is priced, destructible {
 mapping (address \=> bool) registeredAddresses;
 uint price;
 constructor(uint initialPrice) { price \= initialPrice; }
 // Buradaki \`payable\` sözcüğü de oldukça önemlidir.
 // Eğer bu fonksiyon \`payable\` olmazsa kendisine gelen bütün
 // etherleri reddeder.
 function register() public payable costs(price) {
 registeredAddresses\[msg.sender\] \= true;
 }
 function changePrice(uint price\_) public onlyOwner {
 price \= price\_;
 }
}
contract Mutex {
 bool locked;
 modifier noReentrancy() {
 require(
 !locked,
 "Reentrant call."
 );
 locked \= true;
 \_;
 locked \= false;
 }
 /// Bu fonksiyon bir mutex ile korunmaktadır.
 /// Yani, bu akıllı sözleşme re-entrancy çağrılarına karşı zaafiyetli değildir.
 /// \`return 7\` fonksiyonun bittiğini belirtse de henüz modifier'ımızın işi bitmedi.
 /// \`locked = false;\` satırı return ifademizden sonra çalışır.
 function f() public noReentrancy returns (uint) {
 (bool success,) \= msg.sender.call("");
 require(success);
 return 7;
 }
}
Eğer `C` akıllı sözleşmesindeki `m` modifier’ına erişmek istiyorsanız, `C.m` şeklinde erişebilirsiniz. Modifier’lar sadece tanımlandıkları akıllı sözleşmede veya türetilen bir akıllı sözleşmede kullanılabilir. Modifier’lar kütüphanelerde de tanımlanabilir. Ancak kullanımları o kütüphanenin fonksiyonlarıyla kısıtlıdır. Yani tanımlandıkları kütüphane dışında kullanılamazlar.
Bir fonksiyona birden fazla modifier tanımlanabilir. Bunu gerçekleştirmek için her bir modifier isminden sonra bir boşluk bırakılmalıdır. Modifier’lar tanımlandıkları sıraya göre çalışacaktır.
Modifier’lar eklendikleri fonksiyonların parametrelerine veya return değerlerine kendi başlarına erişemezler. Eğer bir parametreyi bir modifier’da kullanmak istiyorsanız, o modifier’ı eklediğiniz yerde parametreyi de vermelisiniz. Fonksiyon çağırma yapısına benzer bir şekilde kullanılırlar.
Modifier’daki veya fonksiyon’daki return işlemi sadece o yazıldığı modifier’dan veya fonksiyon’dan çıkmaya yarar. Program akışı `_` işaretinin olduğu yerden çalışmaya devam eder.
Uyarı
Daha önceki Solidity versiyonlarında modifier’a sahip fonksiyonlarda `return` ifadesi farklı bir şekilde davranış sergiler.
Açık bir şekilde `return;` ifadesinin yer aldığı bir modifier, fonksiyonun return edeceği değerle alakalı değildir. Modifier’lar fonksiyon içerisindeki kodları hiç çalıştırmamayı da tercih edebilirler. Bu durumda return değerleri [default değerlerine](https://docs.soliditylang.org/tr/latest/control-structures.html#default-value) eşitlenebilir. Böylelikle, fonksiyonun hiç bir kodu yokmuş gibi bir davranış sergilenir.
`_` sembolü bir modifier’da birden fazla kez kullanılabilir. Her bir kullanım, fonksiyon içerisindeki kodla değiştirilecektir. Yani, `_` gördüğünüz her yerde, eklenen fonksiyonun kodlarının bulunduğunu düşünebilirsiniz.
Modifier’lar parametre alabildiği için, bir fonksiyondaki bütün parametreler istenilen modifier’a gönderilebilir. Modifier’da tanımlanan semboller, fonksiyonlarda görülemez (override ile değiştirilebilir).
## Constant ve Immutable State Değişkenleri[](#constant-ve-immutable-state-degiskenleri "Permalink to this heading")
State değişkenleri `constant` veya `immutable` olarak tanımlanabilir. Her iki durumda da akıllı sözleşme kurulduktan sonra (constructor çalıştıktan sonra) bu tür değişkenler değiştirilemez. `constant` compile-time’da (kodun içerisinde) tanımlı olması gerekirken, `immutable` değişkenler constructor içerisinde de tanımlanabilir.
`constant` değişkenleri akıllı sözleşmelerin dışarısında (dosya seviyesinde) da tanımlayabiliriz.
Derleyici bu tür değişkenler için storage’de slot ayırmaz. Çünkü bu değişkenlerin kullanıldığı her yer, belirlenmiş değerle değiştirilir.
Normal state değişkenleriyle karşılaştırıldığında, constant ve immutable değişkenler çok daha az gaz harcar. Constant değişkenlerde, kullanıldıkları her yere karşılığında verilen değer kopyalanıp yapıştırılır. Bu, lokal optimizasyon olarak kullanılır. Immutable değişkenlerde ise, akıllı sözleşmenin kurulum anında (construction time) karşılık gelen değeri belirlenir ve kullanıldığı her yere kopyalanıp yapıştırılır. Bu değerler 32 byte’dan daha az yer kaplasa bile 32 byte’lık bir alanda muhafaza edilir. Bu sebepten ötürü, bazı durumlarda constant değerler kullanmak, immutable değerleri kullanmaktan daha ucuz olabilir.
Şu anda constant ve immutable bütün tipler için uygulanamamaktadır. Desteklenen tipler [strings](https://docs.soliditylang.org/tr/latest/types.html#strings) (sadece constant) ve [değer tipleridir](https://docs.soliditylang.org/tr/latest/types.html#value-types).
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjQ7Cgp1aW50IGNvbnN0YW50IFggPSAzMioqMjIgKyA4OwoKY29udHJhY3QgQyB7CiAgICBzdHJpbmcgY29uc3RhbnQgVEVYVCA9ICJhYmMiOwogICAgYnl0ZXMzMiBjb25zdGFudCBNWV9IQVNIID0ga2VjY2FrMjU2KCJhYmMiKTsKICAgIHVpbnQgaW1tdXRhYmxlIGRlY2ltYWxzOwogICAgdWludCBpbW11dGFibGUgbWF4QmFsYW5jZTsKICAgIGFkZHJlc3MgaW1tdXRhYmxlIG93bmVyID0gbXNnLnNlbmRlcjsKCiAgICBjb25zdHJ1Y3Rvcih1aW50IGRlY2ltYWxzXywgYWRkcmVzcyByZWYpIHsKICAgICAgICBkZWNpbWFscyA9IGRlY2ltYWxzXzsKICAgICAgICAvLyBJbW11dGFibGUgdGFuxLFtbGFtYWxhcsSxbmRhIGJsb2sgemluY2lyaW5kZW4gdmVyaSBkZSBva3VuYWJpbGlyLgogICAgICAgIG1heEJhbGFuY2UgPSByZWYuYmFsYW5jZTsKICAgIH0KCiAgICBmdW5jdGlvbiBpc0JhbGFuY2VUb29IaWdoKGFkZHJlc3Mgb3RoZXIpIHB1YmxpYyB2aWV3IHJldHVybnMgKGJvb2wpIHsKICAgICAgICByZXR1cm4gb3RoZXIuYmFsYW5jZSA+IG1heEJhbGFuY2U7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.4;
uint constant X \= 32\*\*22 + 8;
contract C {
 string constant TEXT \= "abc";
 bytes32 constant MY\_HASH \= keccak256("abc");
 uint immutable decimals;
 uint immutable maxBalance;
 address immutable owner \= msg.sender;
 constructor(uint decimals\_, address ref) {
 decimals \= decimals\_;
 // Immutable tanımlamalarında blok zincirinden veri de okunabilir.
 maxBalance \= ref.balance;
 }
 function isBalanceTooHigh(address other) public view returns (bool) {
 return other.balance \> maxBalance;
 }
}
### Constant[](#constant "Permalink to this heading")
`constant` değişkenlerin değerleri derleme anında (compile-time) sabit olmalı ve değişkenin tanımlandığı konumda belirtilmelidir. Herhangi bir storage’e erişim, blok zinciri verisi (örneğin, `block.timestamp`, `address(this).balance` veya `block.number`) veya çalıştırma verisi (`msg.value` veya `gasleft()`) veya başka akıllı sözleşmelere yapılan external çağrılara izin verilmez. Kullanılacak memory’i belirleme konusunda yan etki oluşturacak tanımalamalara izin verilirken, başka memory objeleri üzerinde yan etki oluşturan tanımlamalara izin verilmez. Built-in fonksiyonlarından `keccak256`, `sha256`, `ripemd160`, `ecrecover`, `addmod` ve `mulmod` fonksiyonlarının kullanımına izin verilmiştir (`keccak256` başka akıllı sözleşmeleri çağırsa da, bir istisnadır).
Memory belirleyicisi üzerinde yan etkiye izin verilmesinin sebebi, karmaşık yapılarında kurulabilinmesi gereksinimidir (örneğin, lookup-table). Bu özellikler henüz tamamen kullanılabilir değildir.
### Immutable[](#immutable "Permalink to this heading")
`immutable` olarak tanımlanan değişkenler `constant` olarak tanımlananlara göre biraz daha az kısıtlanmıştır: Immutable değişkenler akıllı sözleşmenin constructor fonksiyonunda keyfi bir değere atanabilir. Sadece bir kere tanımlanabilirler ve tanımlandıktan sonra istenilen anda sahip oldukları değer okunabilir.
Derleyici tarafından oluşturulmuş akıllı sözleşmenin creation code’u, runtime code’u return etmeden önce bütün immutable referanslarını tanımlanan değerle değiştirir. Bu yüzden immutable değişken kullandığınız bir akıllı sözleşme için, compiler’ın oluşturduğu runtime code ile blok zincirinde saklanan runtime code’u karşılaştırdığınızda farklı sonuçlar alırsınız.
Not
Tanımlandıkları satırda direkt olarak değerleri atanan immutable değişkenler akıllı sözleşmenin constructor fonksiyonu çalıştıktan sonra initialize edilmiş olarak düşünülür. Bu demek oluyor ki başka bir immutable değişkenin değerini kullanan bir immutable değişkenin değerini direkt olarak atayamazsınız. Bunu ancak constructor içerisinde yapabilirsiniz.
Bu state değişkenlerini ilk defa tanımlama sırasının farklı bir şekilde yorumlanmasını engellemek amacıyla konulmuş bir önleyicidir, özellikle de türetme (inheritance) konusunda.
## Fonksiyonlar[](#fonksiyonlar "Permalink to this heading")
Fonksiyonlar akıllı sözleşmelerin içerisinde veya dışarısında tanımlanabilir.
Akıllı sözleşmelerin dışarısında tanımlanan fonksiyonlara “özgür fonksiyonlar” denir ve her zaman `internal` [görünürlüktedirler](#visibility-and-getters). Kodları, o fonksiyonları kullanan her bir akıllı sözleşmeye eklenir, tıpkı internal kütüphane fonksiyonları gibi.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKZnVuY3Rpb24gc3VtKHVpbnRbXSBtZW1vcnkgYXJyKSBwdXJlIHJldHVybnMgKHVpbnQgcykgewogICAgZm9yICh1aW50IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKQogICAgICAgIHMgKz0gYXJyW2ldOwp9Cgpjb250cmFjdCBBcnJheUV4YW1wbGUgewogICAgYm9vbCBmb3VuZDsKICAgIGZ1bmN0aW9uIGYodWludFtdIG1lbW9yeSBhcnIpIHB1YmxpYyB7CiAgICAgICAgLy8gQnVyYWRhIMO2emfDvHIgYmlyIGZvbmtzaXlvbiBpbnRlcm5hbCBvbGFyYWsgw6dhxJ9yxLFsxLF5b3IuCiAgICAgICAgLy8gRGVybGV5aWNpIGBzdW1gIGZvbmtzaXlvbnVudSBidSBha8SxbGzEsSBzw7Z6bGXFn21lbmluIGtvZGxhcsSxIGFyYXPEsW5hIGVrbGV5ZWNlay4KICAgICAgICB1aW50IHMgPSBzdW0oYXJyKTsKICAgICAgICByZXF1aXJlKHMgPj0gMTApOwogICAgICAgIGZvdW5kID0gdHJ1ZTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.1 <0.9.0;
function sum(uint\[\] memory arr) pure returns (uint s) {
 for (uint i \= 0; i < arr.length; i++)
 s += arr\[i\];
}
contract ArrayExample {
 bool found;
 function f(uint\[\] memory arr) public {
 // Burada özgür bir fonksiyon internal olarak çağrılıyor.
 // Derleyici \`sum\` fonksiyonunu bu akıllı sözleşmenin kodları arasına ekleyecek.
 uint s \= sum(arr);
 require(s \>= 10);
 found \= true;
 }
}
Not
Akıllı sözleşme dışında tanımlanan bir fonksiyon her zaman o akıllı sözleşmenin içeriği ile birlikte çalıştırılırlar. Hâlâ diğer akıllı sözleşmeleri çağırabilir, onlara Ether gönderebilir ve kendilerini çağıran akıllı sözleşmeleri yok edebilirler. Akıllı sözleşme içerisinde tanımlanan bir fonksiyon ile özgür bir fonksiyonun arasındaki en temel farklar özgür fonksiyonların `this` değişkenine erişimi olmaması, ve de kendi alanlarında (scope) bulunmayan storage değişkenlerine ve fonksiyonlara direkt erişime sahip olmamalarıdır.
### Fonksiyon Parametreleri ve Return Parametreleri[](#fonksiyon-parametreleri-ve-return-parametreleri "Permalink to this heading")
Fonksiyonlar tipi belirtilmiş parametreler alabilir ve diğer birçok programlama dilinin aksine keyfi sayıda değişkeni return edebilirler.
#### Fonksiyon Parametreleri[](#fonksiyon-parametreleri "Permalink to this heading")
Fonksiyon parametreleri değişkenlerle aynı şekilde tanımlanırlar. Ayrıca kullanılmayan parametreler gözardı edilebilirler.
Örneğin, eğer akıllı sözleşmenizdeki bir fonksiyonun iki adet integer değişkeni parametre olarak almasını isterseniz, aşağıdaki gibi bir yapı kullanabilirsiniz:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICB1aW50IHN1bTsKICAgIGZ1bmN0aW9uIHRha2VyKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgewogICAgICAgIHN1bSA9IGEgKyBiOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract Simple {
 uint sum;
 function taker(uint a, uint b) public {
 sum \= a + b;
 }
}
Fonksiyon parametreleri herhangi bir lokal değişken olarak kullanılaiblir ve ayrıca lokal değişkenlere atanabilirler.
Not
Bir [external fonksiyon](https://docs.soliditylang.org/tr/latest/control-structures.html#external-function-calls) çok boyutlu bir diziyi parametre olarak alamazlar. Bu özelliği eğer ABI coder v2’yi kaynak kodunuzda `pragma abicoder v2;` bu şekilde aktifleştirdiyseniz kullanabilirsiniz.
Bir [internal fonksiyon](https://docs.soliditylang.org/tr/latest/control-structures.html#external-function-calls) o özelliği aktifleştirmeden de çok boyutlu bir diziyi parametre olarak alabilir.
#### Return Değişkenleri[](#return-degiskenleri "Permalink to this heading")
Fonksiyon return değişkenleri aynı şekilde `returns` sözcüğünden sonra tanımlanır.
Örneğin, iki adet sonucu return etmek istediğinizi düşünün: fonksiyon parametresi olarak verilmiş iki adet integer’ın toplamı ve çarpımı. Şu şekilde bir kod işinizi görecektir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICBmdW5jdGlvbiBhcml0aG1ldGljKHVpbnQgYSwgdWludCBiKQogICAgICAgIHB1YmxpYwogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50IHN1bSwgdWludCBwcm9kdWN0KQogICAgewogICAgICAgIHN1bSA9IGEgKyBiOwogICAgICAgIHByb2R1Y3QgPSBhICogYjsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract Simple {
 function arithmetic(uint a, uint b)
 public
 pure
 returns (uint sum, uint product)
 {
 sum \= a + b;
 product \= a \* b;
 }
}
Return değişkenlerinin tipleri gözardı edilebilirler. Return değişkenleri herhangi bir lokal değişken olarak kullanılabilirler. Bu değişkenler direkt olarak [default değerine](https://docs.soliditylang.org/tr/latest/control-structures.html#default-value) eşitlenir ve değiştirilene kadar bu değere eşit olurlar.
İsterseniz yukarıdaki gibi açık bir şekilde return değişkenlerinin değerlerini verebilir veya aşağıdaki gibi direkt olarak `return` ifadesini kullanabilirsiniz (ister tek, isterseniz de [çoklu return](#multi-return)):
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICBmdW5jdGlvbiBhcml0aG1ldGljKHVpbnQgYSwgdWludCBiKQogICAgICAgIHB1YmxpYwogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50IHN1bSwgdWludCBwcm9kdWN0KQogICAgewogICAgICAgIHJldHVybiAoYSArIGIsIGEgKiBiKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract Simple {
 function arithmetic(uint a, uint b)
 public
 pure
 returns (uint sum, uint product)
 {
 return (a + b, a \* b);
 }
}
Eğer fonksiyondan çıkmak için erkenden `return` kullanmanak istiyorsanız, bütün return değişkenlerini vermeniz gerekir.
Not
Bazı tipleri internal olmayan fonksiyonlardan return edemezsiniz, örneğin, çok boyutlu dinamik boyutlu diziler ve structlar. Eğer ABI coder v2’yi `pragma abicoder v2;` şeklinde kodunuza eklerseniz daha fazla tip kullanılabilir olacaktır, ancak `mapping` tipi hâlâ bir akıllı sözleşme içerisinde sınırlıdır ve onları transfer edemezsiniz.
#### Çoklu Değer Return Etme[](#coklu-deger-return-etme "Permalink to this heading")
Bir fonksiyonda birden fazla değişkeni return etmek istiyorsanız `return (v0, v1, ..., vn)` şeklinde bir ifade kullanabilirsiniz. Return değişkeni sayısı ve tipleri, bir [implicit dönüşümden](https://docs.soliditylang.org/tr/latest/types.html#types-conversion-elementary-types) sonra belirtilen değerlerle eşleşmelidir.
### State Değişkenliği[](#state-degiskenligi "Permalink to this heading")
#### View Fonksiyonlar[](#view-fonksiyonlar "Permalink to this heading")
`view` ile tanımlanan fonksiyonlar state’te herhangi bir değişikliği yapamaz, sadece state’deki değerleri okuyabilirler.
Not
Eğer derleyicinin EVM target kısmı Byzantium veya daha yenisi (default) ise `view` fonksiyonlar çağrıldığında `STATICCALL` opcode’u kullanılır ve bu opcode state’i değişmemeye zorlar. Kütüphanelerdeki `view` fonksiyonlarında ise `DELEGATECALL` kullanılır. Çünkü `DELEGATECALL` ve `STATICCALL` opcode’larından kombine edilmiş bir opcode bulunmamaktadır. Bu demek oluyor ki `view` fonksiyonlar state değişikliğini önlemek için run-time kontrollerine sahip değildirler. Bunun kötü bir güvenlik etkisi olmamalıdır. Çünkü kütüphane kodu genellikle derlenirken bilinir ve statik kontrol edici (static checker) compile-time kontrollerini gerçekleştirir.
Aşağıdaki ifadeler state değişikliğini temsil eder:
1. State değişkenlerine yazmak.
 
2. [Event yayınlama](#events).
 
3. [Başka akıllı sözleşmeler oluşturma](https://docs.soliditylang.org/tr/latest/control-structures.html#creating-contracts).
 
4. `selfdestruct` kullanmak.
 
5. Ether göndermek.
 
6. `view` veya `pure` olarak belirtilmeyen bir fonksiyon çağırmak.
 
7. Low-level çağrılar kullanmak.
 
8. Belirli opcode’ları kullanan inline assembly kullanmak.
 
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgKiAoYiArIDQyKSArIGJsb2NrLnRpbWVzdGFtcDsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
contract C {
 function f(uint a, uint b) public view returns (uint) {
 return a \* (b + 42) + block.timestamp;
 }
}
Not
Versiyon 0.5.0 öncesinde fonksiyonlarda `constant` sözcüğü şu anki `view` için kullanılırdı, ancak artık kullanılmıyor.
Not
Getter fonksiyonlar otomatik olarak `view` görünürlüğüne sahip olur.
Not
Versiyon 0.5.0 öncesinde derleyici `view` için `STATICCALL` opcode’unu kullanmazdı. Bu, `view` fonksiyonlarda yanlış explicit tip dönüşümlerini kullanarak state değişikliği yapılmasına izin verdi. `STATICCALL` opcode’unu `view` fonksiyonlar için kullanarak EVM seviyesinde state değişikliklerinin yapılmasının önüne geçildi.
#### Pure Fonksiyonlar[](#pure-fonksiyonlar "Permalink to this heading")
Fonksiyonlar `pure` olarak tanımlanabilir ve bu şekilde tanımlanan fonksiyonlar state’i okuyamaz ve değişiklik yapamaz. Pure fonksiyonlar içerisinde `immutable` değişkenler okuyabilir durumdadır.
Not
Eğer derleyicinin EVM target kısmı Byzantium veya daha yeni (default) ise, `STATICCALL` opcode’u kullanılır. Bu opcode state’in okunmadığına dair garanti vermez ama en azından değiştirilmediğine dair bir garanti verir.
Yukarıda state’i değiştiren ifadeleri açıklamışken, state’i okuduğu düşünülen ifadeleri de aşağıda bulabilirsiniz:
1. State değişkenlerini okumak.
 
2. `address(this).balance` veya `<address>.balance` değişkenlerine erişmek.
 
3. `block`, `tx` veya `msg` değişkenlerinin herhangi bir üyesine erişmek (`msg.sig` ve `msg.data` istisnadır).
 
4. `pure` olmayan herhangi bir fonksiyonu çağırmak.
 
5. Belirli opcode’ları kullanan inline assembly kullanmak.
 
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgKiAoYiArIDQyKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
contract C {
 function f(uint a, uint b) public pure returns (uint) {
 return a \* (b + 42);
 }
}
Pure fonksiyonlar `revert()` ve `require()` ifadelerini kullanarak [hata oluşması](https://docs.soliditylang.org/tr/latest/control-structures.html#assert-and-require) durumunda potansiyel state değişikliğini engelleyebilirler.
State değişikliğini revert etmek bir “state değişikliği” olarak düşünülmez.
Bir state değişikliğini revert etmek bir “state değişikliği” olarak kabul edilmez, çünkü yalnızca daha önce kodda `view` veya `pure` kısıtlamaya sahip olmayan state’de yapılan değişiklikler revert edilir ve bu kodun `revert`’i yakalama ve aktarmama seçeneği vardır.
Bu davranış `STATICCALL` için de geçerlidir.
Uyarı
EVM seviyesinde fonksiyonların state’den okuma yapmasını engellemek mümkün değildir, sadece yazma engellenebilir (yani, EVM seviyesinde sadece `view` zorunlu kılınabilir, `pure` kılınamaz).
Not
Versiyon 0.5.0 öncesinde derleyici `pure` için `STATICCALL` opcode’unu kullanmazdı. Bu, `pure` fonksiyonlarda yanlış explicit tip dönüşümlerini kullanarak state değişikliği yapılmasına izin verdi. `STATICCALL` opcode’unu `pure` fonksiyonlar için kullanarak EVM seviyesinde state değişikliklerinin yapılmasının önüne geçildi.
Not
Versiyon 0.4.17 öncesinde derleyici `pure` fonksiyonların state’i okuması durumunda hata vermezdi. Bu, sözleşme türleri arasında geçersiz açık dönüşümler yaparak atlatılabilen ve bir tür denetim olan derleme zamanı yüzünden kaynaklanmaktaydı. Çünkü derleyici, sözleşme türünün durum değiştirme işlemleri yapmadığını doğrulayabilir, fakat çalışma zamanında çağrılacak olan sözleşmenin gerçekten bu türden olup olmadığını kontrol edemez.
### Özel Fonksiyonlar[](#ozel-fonksiyonlar "Permalink to this heading")
#### Receive Ether Fonksiyonu[](#receive-ether-fonksiyonu "Permalink to this heading")
Bİr akıllı sözleşme sadece bir adet `receive` fonksiyonuna sahip olabilir. Bu fonksiyon şu şekilde tanımlanır: `receive() external payable { ... }` (function sözcüğü olmadan). Bu fonksiyon parametre alamaz, hiçbir şey return edemez, görünürlüğü `external` olmalı ve ayrıca `payable` olarak tanımlanmalıdır. Bir receive fonksiyonu virtual olabilir, override edilebilir ve modifier’lara sahip olabilir.
Receive fonksiyonu akıllı sözleşmemize gelen boş bir calldata’sı bulunan çağrılarda çalıştırılır. Bu fonksiyon, akıllı sözleşmemize direkt Ether transferi gerçekleştirildiğinde (`.send()` veya `.transfer()` kullanılarak) çalıştırılır. Eğer bu fonksiyon tanımlı değil ama payable bir [fallback fonksiyon](#fallback-function) tanımlı ise, direkt Ether transferlerinde bu fallback fonksiyonu çalıştırılır. Eğer akıllı sözleşme ne bir receive fonksiyonu, ne de bir payable fallback fonksiyonu tanımlamamışsa, akıllı sözleşmemiz direkt Ether transflerlerini kabul edemez, kendisine ether gönderildiğinde bir hata verir.
En kötü durumda `receive` fonksiyonu 2300 adet gazın mevcut olduğunu varsayabilir (örneğin `send` veya `transfer` kullanımında), geriye ise sadece log işlemleri gibi basit işlemler için gaz kalır. Aşağıdaki işlemler 2300 gazdan daha fazlasını harcar:
* Storage’e yazmak
 
* Akıllı sözleşme oluşturmak
 
* Yüksek miktarda gaz harcayan bir external fonksiyonun çağrılması
 
* Ether gönderimi
 
Uyarı
Bir akıllı sözleşmede direkt olarak Ether gönderirken (bir fonksiyon çağrısı olmadan, yani gönderenin `send` veya `transfer` kullandığı durumda) eğer akıllı sözleşme bir receive fonksiyonu veya bir payable fallback fonksiyonu tanımlamamışsa, bir hata oluşur ve Etherler gönderene iade edilir (bu durum Solidity 0.4.0 öncesinde farklıydı). Eğer akıllı sözleşmenizin direkt Ether transferlerini kabul etmesini istiyorsanız, bir receive fonksiyonu tanımlayın (Ether kabulu için payable fallback fonksiyonunun kullanımını tavsiye etmiyoruz, çünkü fallback fonksiyonu interface karışıklığı yaşandığında kullanıcıya hata vermeyecektir).
Uyarı
Bir akıllı sözleşme receive fonksiyonu olmadan da Ether kabul edebilir; _coinbase transaction_ (diğer adıyla _miner block reward_) veya `selfdestruct` kullanılırken hedef adres olarak verilmesi halinde akıllı sözleşme Etherleri kabul etmek zorundadır.
Bir akıllı sözleşme bu gibi durumlardaki Ether transferlerine herhangi bir tepki veremez ve dolayısıyla bunları reddedemez. Bu EVM’in tasarım tercihlerinden biridir ve Solidity bunu es geçemez.
Bu ayrıca demek oluyor ki `address(this).balance` değişkenindeki değer sizin kendi hesaplamanızla (örneğin, receive fonksiyonunda her gelen miktarı hesaplamanız halinde) farklı olabilir.
Aşağıdaki Sink akıllı sözleşmesi `receive` kullanımına bir örnektir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKLy8gQnUgYWvEsWxsxLEgc8O2emxlxZ9tZXllIGfDtm5kZXJpbGVuIEV0aGVybGVyaSBnZXJpIGFsbWFuxLFuIGhpw6diaXIKLy8geW9sdSB5b2t0dXIuCmNvbnRyYWN0IFNpbmsgewogICAgZXZlbnQgUmVjZWl2ZWQoYWRkcmVzcywgdWludCk7CiAgICByZWNlaXZlKCkgZXh0ZXJuYWwgcGF5YWJsZSB7CiAgICAgICAgZW1pdCBSZWNlaXZlZChtc2cuc2VuZGVyLCBtc2cudmFsdWUpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
// Bu akıllı sözleşmeye gönderilen Etherleri geri almanın hiçbir
// yolu yoktur.
contract Sink {
 event Received(address, uint);
 receive() external payable {
 emit Received(msg.sender, msg.value);
 }
}
#### Fallback Fonksiyonu[](#fallback-fonksiyonu "Permalink to this heading")
Bir akıllı sözleşme sadece bir adet `fallback` fonksiyonuna sahip olabilir. Bu fonksiyon şu iki şekilde tanımlanabilir: `fallback () external [payable]` veya `fallback (bytes calldata input) external [payable] returns (bytes memory output)` (ikisi de `function` sözcüğü olmadan kullanılıyor). Bu fonksiyon `external` görünürlüğe sahip olmalıdır. Bir fallback fonksiyonu virtual olabilir, override edilebilir ve modifier’lara sahip olabilir.
Fallback fonksiyonu bir çağrıda gönderilen fonksiyon imzasının (function signature) akıllı sözleşmedeki herhangi bir fonksiyon ile eşleşmediği durumda çalıştırılır, yani, eğer kullanıcının çalıştırmak istediği fonksiyon akıllı sözleşmede yoksa, fallback fonksiyonu çalıştırılır. Bir diğer kullanım alanı ise direkt Ether gönderimlerinde eğer akıllı sözleşmede [receive Ether fonksiyonu](#receive-ether-function) yoksa ve fallback fonksiyonumuz `payable` ise, fallback fonksiyonu çalıştırılır.
Eğer yukarıda gösterdiğimiz iki kullanım şeklinden `input` kullanılanı kullanmak isterseniz, `input` akıllı sözleşmeye gönderilen tüm data, `msg.data`, olacaktır. Ayrıca `output` ile de data return edebilir. Return edilen data ABI-encoded olmayacaktır, onun yerine herhangi bir düzenleme olmadan (hatta padding bile olmadan) return edilecektir.
En kötü durumda, eğer bir payable fallback fonksiyonu receive fonksiyonun da yerine kullanıldıysa, sadece 2300 adet gaz ile işlemini tamamlayabilir ([receive Ether fonksiyonu](#receive-ether-function)).
Diğer herhangi bir fonksiyon gibi fallback fonksiyonu da yeterli gaza sahip olduğu sürece çok karmaşık işlemleri yürütebilir.
Uyarı
Bir `payable` fallback fonksiyonu ayrıca direkt Ether transferlerinde de, eğer [receive Ether fonksiyonu](#receive-ether-function) kullanılmadıysa, çalıştırılabilir. Eğer payable fallback fonksiyonuna spesifik bir kullanım için ihtiyacınız yoksa, receive fonksiyonunu kullanmanızı tavsiye ederiz.
Not
Eğer input verisini decode etmek istiyorsanız, ilk dört byte’ı fonksiyon imzası için kullanabilir ve kalan kısmı `abi.decode` kullanarak ABI-encoded veriyi decode edebilirsiniz: `(c, d) = abi.decode(input[4:], (uint256, uint256));` Şunu unutmayın ki, bu bir son çaredir. Eğer yapabiliyorsanız daha uygun bir fonksiyon kullanmaya çalışın.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKY29udHJhY3QgVGVzdCB7CiAgICB1aW50IHg7CiAgICAvLyBCdSBha8SxbGzEsSBzw7Z6bGXFn21leWUgZ2VsZW4gYsO8dMO8biBtZXNhaiDDp2HEn3LEsWxhcsSxbsSxCiAgICAvLyBidSBmb25rc2l5b24ga2FyxZ/EsWxhciAoYWvEsWxsxLEgc8O2emxlxZ9tZWRlIGJhxZ9rYSBiaXIKICAgIC8vIGZvbmtzaXlvbiBidWx1bm1hZMSxxJ/EsSBpw6dpbikuCiAgICAvLyBGb25rc2l5b24gcGF5YWJsZSBvbGFyYWsgYmVsaXJ0aWxtZWRpxJ9pIGnDp2luCiAgICAvLyBFdGhlciBnw7ZuZGVyaW1sZXJpbmRlIGhhdGEgYWzEsW5hY2FrdMSxci4KICAgIGZhbGxiYWNrKCkgZXh0ZXJuYWwgeyB4ID0gMTsgfQp9Cgpjb250cmFjdCBUZXN0UGF5YWJsZSB7CiAgICB1aW50IHg7CiAgICB1aW50IHk7CiAgICAvLyBCdSBha8SxbGzEsSBzw7Z6bGXFn21leWUgZ2VsZW4gZGlyZWt0IEV0aGVyIGfDtm5kZXJpbWxlcmkgZMSxxZ/EsW5kYWtpIGLDvHTDvG4gbWVzYWpsYXLEsQogICAgLy8gYnUgZm9ua3NpeW9uIGthcsWfxLFsYXlhY2FrdMSxciAocmVjZWl2ZSBkxLHFn8SxbmRhIGJhxZ9rYSBiaXIgZm9ua3NpeW9uCiAgICAvLyBidWx1bm1hbWFrdGEpLiBDYWxsZGF0YXPEsSBib8WfIG9sbWF5YW4gYsO8dMO8biDDp2HEn3LEsWxhcsSxIGJ1IGZvbmtzaXlvbgogICAgLy8ga2FyxZ/EsWxhciAow6dhxJ9yxLEgaWxlIGJpcmxpa3RlIEV0aGVyIGfDtm5kZXJpbHNlIGJpbGUpLgogICAgZmFsbGJhY2soKSBleHRlcm5hbCBwYXlhYmxlIHsgeCA9IDE7IHkgPSBtc2cudmFsdWU7IH0KCiAgICAvLyBCdSBmb25rc2l5b24gc2FkZWNlIGRpcmVrdCBFdGhlciBnw7ZuZGVyaW1sZXJpIGnDp2luIGt1bGxhbsSxbMSxciwgeWFuaSwKICAgIC8vIGJvxZ8gYmlyIGNhbGxkYXRhIHZlIEV0aGVyIGfDtm5kZXJpbGVuIMOnYcSfcsSxbGFyxLEgYnUgZm9ua3NpeW9uIGthcsWfxLFsYXIuCiAgICByZWNlaXZlKCkgZXh0ZXJuYWwgcGF5YWJsZSB7IHggPSAyOyB5ID0gbXNnLnZhbHVlOyB9Cn0KCmNvbnRyYWN0IENhbGxlciB7CiAgICBmdW5jdGlvbiBjYWxsVGVzdChUZXN0IHRlc3QpIHB1YmxpYyByZXR1cm5zIChib29sKSB7CiAgICAgICAgKGJvb2wgc3VjY2VzcywpID0gYWRkcmVzcyh0ZXN0KS5jYWxsKGFiaS5lbmNvZGVXaXRoU2lnbmF0dXJlKCJub25FeGlzdGluZ0Z1bmN0aW9uKCkiKSk7CiAgICAgICAgcmVxdWlyZShzdWNjZXNzKTsKICAgICAgICAvLyB0ZXN0LngnaW4gPT0gMSBvbG1hc8SxbmEgbmVkZW4gb2x1ci4KCiAgICAgICAgLy8gYWRkcmVzcyh0ZXN0KSBkaXJla3Qgb2xhcmFrIGBgc2VuZGBgIGt1bGxhbsSxbcSxbmEgaXppbiB2ZXJtZXouCiAgICAgICAgLy8gYGBzZW5kYGAgZm9ua3NpeW9udW51IMOnYcSfxLFyYWJpbG1layBpw6dpbiBiaWxlIGBgYWRkcmVzcyBwYXlhYmxlYGAKICAgICAgICAvLyB0aXBpbmUgZMO2bsO8xZ90w7xybWUgZ2VyZWttZWt0ZWRpci4KICAgICAgICBhZGRyZXNzIHBheWFibGUgdGVzdFBheWFibGUgPSBwYXlhYmxlKGFkZHJlc3ModGVzdCkpOwoKICAgICAgICAvLyBFxJ9lciBiaXJpIGJ1cmFkYSBkYSBvbGR1xJ91IGdpYmkgcGF5YWJsZSBmYWxsYmFjayBmb25rc2l5b251IG9sbWF5YW4gYmlyCiAgICAgICAgLy8gYWvEsWxsxLEgc8O2emxlxZ9tZXllIGV0aGVyIGfDtm5kZXJtZXllIMOnYWzEscWfxLFyc2EsIGhhdGEgYWxhY2FrdMSxci4KICAgICAgICAvLyBEb2xhecSxc8SxeWxhIGJ1cmFkYSBgYGZhbHNlYGAgcmV0dXJuIGVkaWxpci4KICAgICAgICByZXR1cm4gdGVzdFBheWFibGUuc2VuZCgyIGV0aGVyKTsKICAgIH0KCiAgICBmdW5jdGlvbiBjYWxsVGVzdFBheWFibGUoVGVzdFBheWFibGUgdGVzdCkgcHVibGljIHJldHVybnMgKGJvb2wpIHsKICAgICAgICAoYm9vbCBzdWNjZXNzLCkgPSBhZGRyZXNzKHRlc3QpLmNhbGwoYWJpLmVuY29kZVdpdGhTaWduYXR1cmUoIm5vbkV4aXN0aW5nRnVuY3Rpb24oKSIpKTsKICAgICAgICByZXF1aXJlKHN1Y2Nlc3MpOwogICAgICAgIC8vIHRlc3QueCA9PSAxIG9sdXIgdmUgdGVzdC55IDAgb2x1ci4KICAgICAgICAoc3VjY2VzcywpID0gYWRkcmVzcyh0ZXN0KS5jYWxse3ZhbHVlOiAxfShhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgibm9uRXhpc3RpbmdGdW5jdGlvbigpIikpOwogICAgICAgIHJlcXVpcmUoc3VjY2Vzcyk7CiAgICAgICAgLy8gdGVzdC54ID09IDEgb2x1ciB2ZSB0ZXN0LnkgMSBvbHVyLgoKICAgICAgICAvLyBFxJ9lciBiaXJpIGHFn2HEn8SxZGFraSBnaWJpIFRlc3RQYXlhYmxlIGFrxLFsbMSxIHPDtnpsZcWfbWVzaW5lIEV0aGVyIGfDtm5kZXJpcnNlLCByZWNlaXZlIGZvbmtzaXlvbnUgw6dhbMSxxZ/EsXIuCiAgICAgICAgLy8gWXVrYXLEsWRhIHRhbsSxbWxhZMSxxJ/EsW3EsXogcmVjZWl2ZSBmb25rc2l5b251IHN0b3JhZ2UnZSB5YXpkxLHEn8SxIGnDp2luIDIzMDAnZGVuIGRhaGEgZmF6bGEKICAgICAgICAvLyBnYXogaGFyY2FubWFzxLFuYSBzZWJlcCBvbHVyLiBPIHnDvHpkZW4gYGBzZW5kYGAgdmUgYGB0cmFuc2ZlcmBgIGt1bGxhbsSxbGFtYXouCiAgICAgICAgLy8gT25sYXLEsW4geWVyaW5lIGxvdy1sZXZlbCBjYWxsIGt1bGxhbm1hbMSxecSxei4KICAgICAgICAoc3VjY2VzcywpID0gYWRkcmVzcyh0ZXN0KS5jYWxse3ZhbHVlOiAyIGV0aGVyfSgiIik7CiAgICAgICAgcmVxdWlyZShzdWNjZXNzKTsKICAgICAgICAvLyB0ZXN0LngnaW4gPT0gMiB2ZSB0ZXN0LnknbmluIDIgRXRoZXIgb2xtYXPEsXlsYSBzb251w6dsYW7EsXIuCgogICAgICAgIHJldHVybiB0cnVlOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.2 <0.9.0;
contract Test {
 uint x;
 // Bu akıllı sözleşmeye gelen bütün mesaj çağrılarını
 // bu fonksiyon karşılar (akıllı sözleşmede başka bir
 // fonksiyon bulunmadığı için).
 // Fonksiyon payable olarak belirtilmediği için
 // Ether gönderimlerinde hata alınacaktır.
 fallback() external { x \= 1; }
}
contract TestPayable {
 uint x;
 uint y;
 // Bu akıllı sözleşmeye gelen direkt Ether gönderimleri dışındaki bütün mesajları
 // bu fonksiyon karşılayacaktır (receive dışında başka bir fonksiyon
 // bulunmamakta). Calldatası boş olmayan bütün çağrıları bu fonksiyon
 // karşılar (çağrı ile birlikte Ether gönderilse bile).
 fallback() external payable { x \= 1; y \= msg.value; }
 // Bu fonksiyon sadece direkt Ether gönderimleri için kullanılır, yani,
 // boş bir calldata ve Ether gönderilen çağrıları bu fonksiyon karşılar.
 receive() external payable { x \= 2; y \= msg.value; }
}
contract Caller {
 function callTest(Test test) public returns (bool) {
 (bool success,) \= address(test).call(abi.encodeWithSignature("nonExistingFunction()"));
 require(success);
 // test.x'in == 1 olmasına neden olur.
 // address(test) direkt olarak \`\`send\`\` kullanımına izin vermez.
 // \`\`send\`\` fonksiyonunu çağırabilmek için bile \`\`address payable\`\`
 // tipine dönüştürme gerekmektedir.
 address payable testPayable \= payable(address(test));
 // Eğer biri burada da olduğu gibi payable fallback fonksiyonu olmayan bir
 // akıllı sözleşmeye ether göndermeye çalışırsa, hata alacaktır.
 // Dolayısıyla burada \`\`false\`\` return edilir.
 return testPayable.send(2 ether);
 }
 function callTestPayable(TestPayable test) public returns (bool) {
 (bool success,) \= address(test).call(abi.encodeWithSignature("nonExistingFunction()"));
 require(success);
 // test.x == 1 olur ve test.y 0 olur.
 (success,) \= address(test).call{value: 1}(abi.encodeWithSignature("nonExistingFunction()"));
 require(success);
 // test.x == 1 olur ve test.y 1 olur.
 // Eğer biri aşağıdaki gibi TestPayable akıllı sözleşmesine Ether gönderirse, receive fonksiyonu çalışır.
 // Yukarıda tanımladığımız receive fonksiyonu storage'e yazdığı için 2300'den daha fazla
 // gaz harcanmasına sebep olur. O yüzden \`\`send\`\` ve \`\`transfer\`\` kullanılamaz.
 // Onların yerine low-level call kullanmalıyız.
 (success,) \= address(test).call{value: 2 ether}("");
 require(success);
 // test.x'in == 2 ve test.y'nin 2 Ether olmasıyla sonuçlanır.
 return true;
 }
}
### Fonksiyon Overloading[](#fonksiyon-overloading "Permalink to this heading")
Bir akıllı sözleşme aynı isimde fakat farklı parametre tiplerine sahip fonksiyonlara sahip olabilir. Bu işlem “overloading” olarak adlandırılır ve ayrıca türetilen fonksiyonlar için de geçerlidir. Aşağıdaki örnek `A` akıllı sözleşmesindeki `f` fonksiyonları ile overloading’i gösterir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEEgewogICAgZnVuY3Rpb24gZih1aW50IHZhbHVlKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IG91dCkgewogICAgICAgIG91dCA9IHZhbHVlOwogICAgfQoKICAgIGZ1bmN0aW9uIGYodWludCB2YWx1ZSwgYm9vbCByZWFsbHkpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQgb3V0KSB7CiAgICAgICAgaWYgKHJlYWxseSkKICAgICAgICAgICAgb3V0ID0gdmFsdWU7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract A {
 function f(uint value) public pure returns (uint out) {
 out \= value;
 }
 function f(uint value, bool really) public pure returns (uint out) {
 if (really)
 out \= value;
 }
}
Overload edilmiş fonksiyonlar external interface’de de göründüğü için iki fonksiyonun aldığı parametreler external tiplerine göre karşılaştırılır. Yani, örneğin aşağıdaki fonksiyonlardan biri parametre olarak akıllı sözleşme aldığını belirtmiş. Ancak external interface’de bu, bir akıllı sözleşme değil, adres olarak görünür. O yüzden bu akıllı sözleşme compile edilemez.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCi8vIENvbXBpbGUgZWRpbGVtZXoKY29udHJhY3QgQSB7CiAgICBmdW5jdGlvbiBmKEIgdmFsdWUpIHB1YmxpYyBwdXJlIHJldHVybnMgKEIgb3V0KSB7CiAgICAgICAgb3V0ID0gdmFsdWU7CiAgICB9CgogICAgZnVuY3Rpb24gZihhZGRyZXNzIHZhbHVlKSBwdWJsaWMgcHVyZSByZXR1cm5zIChhZGRyZXNzIG91dCkgewogICAgICAgIG91dCA9IHZhbHVlOwogICAgfQp9Cgpjb250cmFjdCBCIHsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
// Compile edilemez
contract A {
 function f(B value) public pure returns (B out) {
 out \= value;
 }
 function f(address value) public pure returns (address out) {
 out \= value;
 }
}
contract B {
}
Yukarıdaki iki `f` fonksiyonu da ABI’leri aracılığı ile address tipinden bir parametre kabul ediyor, her ne kadar Solidity içerisinde farklı tipler kabul etseler de.
#### Overload Ayrıştırma ve Parametre Eşleştirme[](#overload-ayristirma-ve-parametre-eslestirme "Permalink to this heading")
Overload edilmiş fonksiyonlar, geçerli kapsamdaki fonksiyon tanımlamalarını fonksiyon çağrısında sağlanan parametrelerle eşleştirerek seçilir. Tüm parametreler implicit olarak beklenen türlere dönüştürülebiliyorsa, fonksiyon overload adayı olarak seçilir. Tam olarak bir aday yoksa, çözümleme başarısız olur.
Not
Overload ayrıştırma için return parametreleri dikkate alınmaz.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEEgewogICAgZnVuY3Rpb24gZih1aW50OCB2YWwpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQ4IG91dCkgewogICAgICAgIG91dCA9IHZhbDsKICAgIH0KCiAgICBmdW5jdGlvbiBmKHVpbnQyNTYgdmFsKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50MjU2IG91dCkgewogICAgICAgIG91dCA9IHZhbDsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract A {
 function f(uint8 val) public pure returns (uint8 out) {
 out \= val;
 }
 function f(uint256 val) public pure returns (uint256 out) {
 out \= val;
 }
}
`f(50)` çağrısını yaptığımızda bir hata alırız. Bunun sebebi `50` sayısının hem `uint8` hem de `uint256` tipinde de kullanılabilmesidir. Ama eğer `f(256)` çağrısını gerçekleştirirsek `256` sayısı direkt olarak `f(uint256)` bu şekilde tanımlanan fonksiyona gönderilir. Çünkü `256` `uint8` olarak gösterilemez.
## Eventler[](#eventler "Permalink to this heading")
Solidity eventleri EVM’nin loglama işlevinin üzerine bir soyutlama verir. Uygulamalar Ethereum clientlarının RPC arayüzüne abone olarak bu eventleri dinleyebilirler.
Eventler akıllı sözleşmelerin türetilebilen üyeleridir. Çağrıldıklarında işlemlerin log kısmında - blok zincirindeki özel bir veri yapısı - depolanırlar. Bu eventler çağrıldıkları akıllı sözleşmenin adresi ile özdeşleştirilir ve işlemin bulunduğu blok erişilebilir olduğu sürece bu eventlere de erişilebilir (şu anda bu süre sonsuza kadardır ancak Serenity ile bu değişebilir). Log ve event verisi akıllı sözleşme tarafından erişilebilir değildir (eventi oluşturan akıllı sözleşme için bile bu geçerlidir).
Loglar için bir Merkle proof talep etmek mümkündür, bu nedenle external bir varlık böyle bir kanıtla bir akıllı sözleşme sağlarsa, logun blok zinciri içinde gerçekten var olup olmadığını kontrol edebilir. Sözleşme yalnızca son 256 blok hashini görebildiği için blok başlıkları sağlamanız gerekir.
Logun veri kısmı yerine [“topics”](https://docs.soliditylang.org/tr/latest/abi-spec.html#abi-events) olarak bilinen özel bir veri yapısına ekleyen en fazla üç parametreye `indexed` özniteliği ekleyebilirsiniz. Bir topic yalnızca tek bir kelimeyi (32 byte) tutabilir, bu nedenle indekslenmiş bir argüman için bir referans tipi kullanırsanız, bunun yerine değerin Keccak-256 hashi topic olarak saklanır.
`indexed` olmadan kullanılan bütün parametreler logun veri kısmına [ABI-encoded](https://docs.soliditylang.org/tr/latest/abi-spec.html#abi) olarak saklanır.
Topicler eventleri aramanıza izin verir, örneğin belirli eventler için bir blok dizisini filtrelerken. Ayrıca eventleri yayınlandıkları akıllı sözleşmede göre de filtreleyebilirsiniz.
Örneğin aşağıdaki kod web3.js’in `subscribe("logs")` [methodunu](https://web3js.readthedocs.io/en/1.0/web3-eth-subscribe.html#subscribe-logs) kullanarak logları belirli bir adrese göre filtreleme işlemi yapmıştır:
var options \= {
 fromBlock: 0,
 address: web3.eth.defaultAccount,
 topics: \["0x0000000000000000000000000000000000000000000000000000000000000000", null, null\]
};
web3.eth.subscribe('logs', options, function (error, result) {
 if (!error)
 console.log(result);
})
 .on("data", function (log) {
 console.log(log);
 })
 .on("changed", function (log) {
});
Eventin imzasının hashi, etkinliği anonim belirteçle bildirmeniz dışında, topiclerden biridir. Bu, belirli anonim eventleri ada göre filtrelemenin mümkün olmadığı, yalnızca akıllı sözleşme adresine göre filtreleyebileceğiniz anlamına gelir. Anonim eventlerin avantajı, deploy etmenin ve çağırmanın daha ucuz olmasıdır. Ayrıca, üç yerine dört indexed değişken bildirmenize olanak tanır.
Not
İşlem logları değişken türünü değil, yalnızca olay verilerini sakladığından, verileri doğru bir şekilde yorumlamak için hangi parametrenin dizine eklendiği ve eventin anonim olup olmadığı dahil olmak üzere olayın türünü bilmeniz gerekir. Özellikle, anonim bir event kullanarak başka bir eventin imzasını “sahte” yapmak mümkündür.
### Eventlerin Üyeleri[](#eventlerin-uyeleri "Permalink to this heading")
* `event.selector`: Anonim olmayan eventlerde `bytes32` tipindeki bir değerdir ve eventin imzasının hashini içerir `keccak256`.
 
### Örnek[](#ornek "Permalink to this heading")
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIxIDwwLjkuMDsKCmNvbnRyYWN0IENsaWVudFJlY2VpcHQgewogICAgZXZlbnQgRGVwb3NpdCgKICAgICAgICBhZGRyZXNzIGluZGV4ZWQgZnJvbSwKICAgICAgICBieXRlczMyIGluZGV4ZWQgaWQsCiAgICAgICAgdWludCB2YWx1ZQogICAgKTsKCiAgICBmdW5jdGlvbiBkZXBvc2l0KGJ5dGVzMzIgaWQpIHB1YmxpYyBwYXlhYmxlIHsKICAgICAgICAvLyBFdmVudGxlciBgZW1pdGAgc8O2emPDvMSfw7wgdmUgc29ucmFzxLFuZGEKICAgICAgICAvLyBldmVudGluIGlzbWkgdmUgcGFyYW1ldHJlbGVyaSAodmFyc2EpIHBhcmFudGV6CiAgICAgICAgLy8gacOnZXJpc2luZSBrb251bGFyYWsgeWF5xLFubGFuxLFyLgogICAgICAgIC8vIEJ1IMWfZWtpbGRla2kgaGVyaGFuZ2kgYmlyIMOnYcSfxLFybWEgacWfbGVtaQogICAgICAgIC8vIChpw6cgacOnZSBvbHNhIGJpbGUpIGBEZXBvc2l0YCBpbGUgZmlsdHJlbGVtZQogICAgICAgIC8vIHlhcGFyYWsgSmF2YVNjcmlwdCBBUEkgdGFyYWbEsW5kYW4geWFrYWxhbmFiaWxpci4KICAgICAgICBlbWl0IERlcG9zaXQobXNnLnNlbmRlciwgaWQsIG1zZy52YWx1ZSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.21 <0.9.0;
contract ClientReceipt {
 event Deposit(
 address indexed from,
 bytes32 indexed id,
 uint value
 );
 function deposit(bytes32 id) public payable {
 // Eventler \`emit\` sözcüğü ve sonrasında
 // eventin ismi ve parametreleri (varsa) parantez
 // içerisine konularak yayınlanır.
 // Bu şekildeki herhangi bir çağırma işlemi
 // (iç içe olsa bile) \`Deposit\` ile filtreleme
 // yaparak JavaScript API tarafından yakalanabilir.
 emit Deposit(msg.sender, id, msg.value);
 }
}
JavaScript API kullanımı ise şu şekildedir:
var abi \= /\* derleyici tarafından üretilen ABI \*/;
var ClientReceipt \= web3.eth.contract(abi);
var clientReceipt \= ClientReceipt.at("0x1234...ab67" /\* adres \*/);
var depositEvent \= clientReceipt.Deposit();
// değişiklikleri izle
depositEvent.watch(function(error, result){
 // sonuç, \`Deposit\` çağrısına verilen indekslenmemiş
 // argümanları ve topicleri içerir.
 if (!error)
 console.log(result);
});
// veya bir callback fonksiyonu ile direkt olarak dinlemeye başlayabilirsiniz
var depositEvent \= clientReceipt.Deposit(function(error, result) {
 if (!error)
 console.log(result);
});
Yukarıdaki kod şu şekilde bir çıktı verir (trim edilmiş hali ile):
{
 "returnValues": {
 "from": "0x1111…FFFFCCCC",
 "id": "0x50…sd5adb20",
 "value": "0x420042"
 },
 "raw": {
 "data": "0x7f…91385",
 "topics": \["0xfd4…b4ead7", "0x7f…1a91385"\]
 }
}
### Eventleri Anlamak İçin Ekstra Kaynaklar[](#eventleri-anlamak-icin-ekstra-kaynaklar "Permalink to this heading")
* [Javascript documentation](https://github.com/ethereum/web3.js/blob/1.x/docs/web3-eth-contract.rst#events)
 
* [Example usage of events](https://github.com/ethchange/smart-exchange/blob/master/lib/contracts/SmartExchange.sol)
 
* [How to access them in js](https://github.com/ethchange/smart-exchange/blob/master/lib/exchange_transactions.js)
 
## Hata ve Geri Alma Durumları[](#hata-ve-geri-alma-durumlari "Permalink to this heading")
Solidity’de hatalar gaz-verimli ve kullanışlı bir şekilde kullanıcılara bir işlemin neden başarısız olduğunu söylemeyi sağlar. Akıllı sözleşmenin içerisinde veya dışarısında tanımlanabilirler (interface ve kütüphaneler de dahil).
[Revert ifadesi](https://docs.soliditylang.org/tr/latest/control-structures.html#revert-statement) ile kullanılmalıdır. Bu ifade anlık çağrıda yapılan bütün değişiklikleri geri alır ve işlemi çağıran kişiye bir hata gönderir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCi8vLyBUcmFuc2ZlciBpw6dpbiB5ZXRlcnNpeiBiYWtpeWUuIGByZXF1aXJlZGAga2FkYXIgYmFraXllCi8vLyBvbG1hbMSxeWtlbiwgYGF2YWlsYWJsZWAga2FkYXIgYmFraXllIG1ldmN1dHR1ci4KLy8vIEBwYXJhbSBhdmFpbGFibGUsIGt1bGxhbsSxbGFiaWxpciBiYWtpeWUuCi8vLyBAcGFyYW0gcmVxdWlyZWQsIHRyYW5zZmVyIGVkaWxtZWsgaXN0ZW5lbiBtaWt0YXIuCmVycm9yIEluc3VmZmljaWVudEJhbGFuY2UodWludDI1NiBhdmFpbGFibGUsIHVpbnQyNTYgcmVxdWlyZWQpOwoKY29udHJhY3QgVGVzdFRva2VuIHsKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50KSBiYWxhbmNlOwogICAgZnVuY3Rpb24gdHJhbnNmZXIoYWRkcmVzcyB0bywgdWludDI1NiBhbW91bnQpIHB1YmxpYyB7CiAgICAgICAgaWYgKGFtb3VudCA+IGJhbGFuY2VbbXNnLnNlbmRlcl0pCiAgICAgICAgICAgIHJldmVydCBJbnN1ZmZpY2llbnRCYWxhbmNlKHsKICAgICAgICAgICAgICAgIGF2YWlsYWJsZTogYmFsYW5jZVttc2cuc2VuZGVyXSwKICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBhbW91bnQKICAgICAgICAgICAgfSk7CiAgICAgICAgYmFsYW5jZVttc2cuc2VuZGVyXSAtPSBhbW91bnQ7CiAgICAgICAgYmFsYW5jZVt0b10gKz0gYW1vdW50OwogICAgfQogICAgLy8gLi4uCn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
/// Transfer için yetersiz bakiye. \`required\` kadar bakiye
/// olmalıyken, \`available\` kadar bakiye mevcuttur.
/// @param available, kullanılabilir bakiye.
/// @param required, transfer edilmek istenen miktar.
error InsufficientBalance(uint256 available, uint256 required);
contract TestToken {
 mapping(address \=> uint) balance;
 function transfer(address to, uint256 amount) public {
 if (amount \> balance\[msg.sender\])
 revert InsufficientBalance({
 available: balance\[msg.sender\],
 required: amount
 });
 balance\[msg.sender\] \-= amount;
 balance\[to\] += amount;
 }
 // ...
}
Hatalar overload veya override edilemez ama türetilebilirler. Alanları farklı olduğu sürece aynı hata birden fazla kere tanımlanabilir. Hata örnekleri sadece `revert` ifadesi kullanılarak üretilebilir.
Hata, daha sonra zincir dışı bileşene geri dönmek veya onu [try/catch ifadesiyle](https://docs.soliditylang.org/tr/latest/control-structures.html#try-catch). yakalamak için geri alma işlemiyle işlemi çağırana veri iletir. Bir hatanın yalnızca harici bir aramadan geldiğinde yakalanabileceğini, dahili aramalarda veya aynı işlevin içinde gerçekleşen geri dönüşlerin yakalanamayacağını unutmayın.
Herhangi bir parametre sağlamazsanız, hata yalnızca dört bayt veriye ihtiyaç duyar ve zincirde depolanmayan hatanın ardındaki nedenleri daha fazla açıklamak için [NatSpec’i](https://docs.soliditylang.org/tr/latest/natspec-format.html#natspec) yukarıdaki gibi kullanabilirsiniz. Bu, bunu aynı zamanda çok ucuz ve kullanışlı bir hata raporlama özelliği yapar.
Daha spesifik olarak, bir hata örneği, aynı ad ve türdeki bir işleve yapılan bir işlev çağrısıyla aynı şekilde ABI ile kodlanır ve daha sonra geri alma işlem kodunda dönüş verileri olarak kullanılır. Bu, verilerin 4 baytlık bir fonksiyon selector’ünün ve ardından [ABI-encoded](https://docs.soliditylang.org/tr/latest/abi-spec.html#abi) verilerden oluştuğu anlamına gelir. Selector, hata türünün imzasının keccak256 hash’inin ilk dört baytından oluşur.
Not
Bir sözleşmenin aynı adı taşıyan farklı hatalarla veya hatta işlemi çağıran tarafından ayırt edilemeyen farklı yerlerde tanımlanan hatalarla geri dönmesi mümkündür. Dışarıdan, yani ABI için, tanımlandığı sözleşme veya dosya değil, yalnızca hatanın adı önemlidir.
`require(condition, "description");` ifadesi ile `if (!condition) revert Error("description")` ifadesi eğer hata `error Error(string)` bu şekilde tanımlanmışsa, aynı işi yapar. `Error` tipinin bir built-in tipi olduğunu ve kullanıcı tarafından tanımlanamayacağını unutmayın.
Benzer olarak bir `assert` ile tespit edilen bir başarısızlık, yine bir built-in tipi olan `Panic(uint256)` ile geri alınacaktır.
Not
Hata verileri sadece bir başarısızlığı işaret etmek için kullanılmalıdır, kontrol akışı için kullanılmamalıdır. Bunun nedeni, dahili çağrıların geri alınan verilerinin, varsayılan olarak harici çağrılar zinciri boyunca geri yayılmasıdır. Bu, bir iç çağrının, kendisini çağıran sözleşmeden gelmiş gibi görünen verileri “sahte” hale getirebileceği anlamına gelir.
### Hataların Üyeleri[](#hatalarin-uyeleri "Permalink to this heading")
* `error.selector`: Hatanın selector’ünü içeren `bytes4` dört baytlık bir değer.
 
## Kalıtım[](#kalitim "Permalink to this heading")
Solidity polimorfizm dahil birçok kalıtım yöntemini destekler.
Polimorfizm, bir fonksiyon çağrısının (dahili ve harici), kalıtım hiyerarşisinde aynı fonksiyona sahip birden fazla akıllı sözleşmenin olması durumunda, ilk türetilen akıllı sözleşmenin fonksiyonunun çalıştırılmasına verilen isimdir. Bu, `virtual` ve `override` anahtar sözcükleri kullanılarak hiyerarşideki her işlevde açıkça etkinleştirilmelidir. Daha fazla ayrıntı için [Function Overriding’e](#function-overriding) bakın.
Kalıtım hiyerarşisinden bir fonksiyonu çağırmak isterseniz; `ContractName.functionName()` bu şekilde çağırabilirsiniz. Veya kalıtım hiyerarşisinde bir üst akıllı sözleşmede bulunan bir fonksiyonu çağırmak isterseniz de; `super.functionName()` kullanabilirsiniz.
Bir akıllı sözleşme başka bir akıllı sözleşmeyi türettiğinde, blockchainde sadece bir adet akıllı sözleşme oluşturulur ve tüm ana akıllı sözleşmelerden gelen kodlar oluşturulan akıllı sözleşmeye eklenir. Bu demek oluyorki ana akıllı sözleşmelerin fonksiyonlarına yapılan bütün internal çağrılar sadece internal fonksiyon çağrılarını kullanırlar (`super.f(..)` sadece JUMP opcode’unu kullanacaktır, mesaj çağrısı yapmayacaktır).
Durum değişkeni gölgeleme bir hata olarak kabul edilir. Bir türetilen akıllı sözleşme sadece ve sadece eğer türettiği akıllı sözleşmelerden hiçbiri `x` isminde bir değişkeni kullanmıyorsa bu isimde bir değişken tanımlayabilir.
Genel kalıtım sistemi [Python’a](https://docs.python.org/3/tutorial/classes.html#inheritance) oldukça benzer, özellikle de çoklu kalıtım konusunda, fakat ayrıca bazı [farklılıklar](#multi-inheritance) da bulunmaktadır
Aşağıdaki örnekte detaylar açıklanmıştır.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKCmNvbnRyYWN0IE93bmVkIHsKICAgIGNvbnN0cnVjdG9yKCkgeyBvd25lciA9IHBheWFibGUobXNnLnNlbmRlcik7IH0KICAgIGFkZHJlc3MgcGF5YWJsZSBvd25lcjsKfQoKCi8vIGBpc2Aga3VsbGFuYXJhayBiYcWfa2EgYmlyIGFrxLFsbMSxIHPDtnpsZcWfbWV5aSB0w7xyZXRlYmlsaXJpei4KLy8gVMO8cmV0aWxlbiBha8SxbGzEsSBzw7Z6bGXFn21lbGVyIHByaXZhdGUgb2xtYXlhbiBiw7x0w7xuIMO8eWVsZXJlCi8vIGVyacWfZWJpbGlyLCBpbnRlcm5hbCBmb25rc2l5b25sYXIgdmUgZHVydW0gZGXEn2nFn2tlbmxlcmkKLy8gZGFoaWwuIEJ1bmxhcmEgZXh0ZXJuYWwgb2xhcmFrIGB0aGlzYCBrdWxsYW7EsWxhcmFrIGRhIGVyacWfaWxlbWV6Lgpjb250cmFjdCBEZXN0cnVjdGlibGUgaXMgT3duZWQgewogICAgLy8gYHZpcnR1YWxgIHPDtnpjw7zEn8O8IGJ1IGZvbmtzaXlvbnVuLCB0w7xyZXRpbGVuCiAgICAvLyBha8SxbGzEsSBzw7Z6bGXFn21lbGVyZGUgZGXEn2nFn3RpcmlsZWJpbGVjZcSfaW5pIGJlbGlydGlyICgib3ZlcnJpZGluZyIpLgogICAgZnVuY3Rpb24gZGVzdHJveSgpIHZpcnR1YWwgcHVibGljIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgc2VsZmRlc3RydWN0KG93bmVyKTsKICAgIH0KfQoKCi8vIEFic3RyYWN0IGFrxLFsbMSxIHPDtnpsZcWfbWVsZXIgc2FkZWNlIGRlcmxleWljaXllIGludGVyZmFjZSdpCi8vIGJpbGRpcm1layBpw6dpbiBrdWxsYW7EsWzEsXIuIEZvbmtzaXlvbnVuIGtvZGxhcsSxbsSxbiBvbG1hZMSxxJ/EsW5hCi8vIGRpa2thdCBlZGluLiBFxJ9lciBiaXIgYWvEsWxsxLEgc8O2emxlxZ9tZSBiw7x0w7xuIGZvbmtzaXlvbmxhcsSxbsSxbiBpw6dlcmnEn2luaQovLyBidWx1bmR1cm1henNhLCBzYWRlY2UgaW50ZXJmYWNlIG9sYXJhayBkYSBrdWxsYW7EsWxhYmlsaXIuCmFic3RyYWN0IGNvbnRyYWN0IENvbmZpZyB7CiAgICBmdW5jdGlvbiBsb29rdXAodWludCBpZCkgcHVibGljIHZpcnR1YWwgcmV0dXJucyAoYWRkcmVzcyBhZHIpOwp9CgoKYWJzdHJhY3QgY29udHJhY3QgTmFtZVJlZyB7CiAgICBmdW5jdGlvbiByZWdpc3RlcihieXRlczMyIG5hbWUpIHB1YmxpYyB2aXJ0dWFsOwogICAgZnVuY3Rpb24gdW5yZWdpc3RlcigpIHB1YmxpYyB2aXJ0dWFsOwp9CgoKLy8gw4dva2x1IHTDvHJldGltIGRlIG3DvG1rw7xuZMO8ci4gYE93bmVkYCBha8SxbGzEsSBzw7Z6bGXFn21lc2luaW4KLy8gYXlyxLFjYSBgRGVzdHJ1Y3RpYmxlYCBha8SxbGzEsSBzw7Z6bGXFn21lc2luaW4gYW5hIGFrxLFsbMSxIHPDtnpsZcWfbWVsZXJpbmRlbgovLyBiaXJpIG9sZHXEn3VudSB1bnV0bWF5xLFuLiBBbmNhayBgT3duZWRgIGFrxLFsbMSxIHPDtnpsZcWfbWVzaW5pbgovLyBzYWRlY2UgYmlyIGFkZXQgw7ZybmXEn2kgdmFyZMSxciAoQysrJ2Rha2kgc2FuYWwga2FsxLF0xLFtIGdpYmkpLgpjb250cmFjdCBOYW1lZCBpcyBPd25lZCwgRGVzdHJ1Y3RpYmxlIHsKICAgIGNvbnN0cnVjdG9yKGJ5dGVzMzIgbmFtZSkgewogICAgICAgIENvbmZpZyBjb25maWcgPSBDb25maWcoMHhENWY5RDhEOTQ4ODZFNzBiMDZFNDc0YzNmQjE0RmQ0M0UyZjIzOTcwKTsKICAgICAgICBOYW1lUmVnKGNvbmZpZy5sb29rdXAoMSkpLnJlZ2lzdGVyKG5hbWUpOwogICAgfQoKICAgIC8vIEZvbmtzaXlvbmxhciBiYcWfa2EgYmlyIGZvbmtzaXlvbiB0YXJhZsSxbmRhbiBheW7EsSBpc2ltIHZlIGF5bsSxCiAgICAvLyBzYXnEsWRhL3RpcHRlIGdpcmRpIGlsZSBvdmVycmlkZSBlZGlsZWJpbGlyLiBFxJ9lciBvdmVycmlkZSBlZGVuCiAgICAvLyBmb25rc2l5b24gZmFya2zEsSBzYXnEsWRhIMOnxLFrdMSxIHZlcml5b3JzYSwgYnUgb3J0YXlhIGJpciBoYXRhIMOnxLFrYXLEsXIuCiAgICAvLyBIZW0geWVyZWwgaGVtIGRlIG1lc2FqLXRhYmFubMSxIGZvbmtzaXlvbiDDp2HEn3LEsWxhcsSxIGJ1IG92ZXJyaWRlIGnFn2xlbWxlcmluaQogICAgLy8gaGVzYWJhIGthdGFyLiBFxJ9lciBiaXIgZm9ua3NpeW9udSBvdmVycmlkZSBldG1layBpc3RpeW9yc2FuxLF6CiAgICAvLyBgb3ZlcnJpZGVgIHPDtnpjw7zEn8O8bsO8IGt1bGxhbm1hayB6b3J1bmRhc8SxbsSxei4gQXlyxLFjYSBmb25rc2l5b251bnV6dW4KICAgIC8vIHRla3JhcmRhbiBvdmVycmlkZSBlZGlsZWJpbGlyIG9sbWFzxLFuxLEgaXN0aXlvcnNhbsSxeiwgdGVrcmFyZGFuCiAgICAvLyBgdmlydHVhbGAgb2xhcmFrIGJlbGlybGVtZWxpc2luaXouCiAgICBmdW5jdGlvbiBkZXN0cm95KCkgcHVibGljIHZpcnR1YWwgb3ZlcnJpZGUgewogICAgICAgIGlmIChtc2cuc2VuZGVyID09IG93bmVyKSB7CiAgICAgICAgICAgIENvbmZpZyBjb25maWcgPSBDb25maWcoMHhENWY5RDhEOTQ4ODZFNzBiMDZFNDc0YzNmQjE0RmQ0M0UyZjIzOTcwKTsKICAgICAgICAgICAgTmFtZVJlZyhjb25maWcubG9va3VwKDEpKS51bnJlZ2lzdGVyKCk7CiAgICAgICAgICAgIC8vIE92ZXJyaWRlIGVkaWxtacWfIGJpciBmb25rc2l5b251IHNwZXNpZmlrIG9sYXJhawogICAgICAgICAgICAvLyDDp2HEn8Sxcm1hayBtw7xta8O8bmTDvHIuCiAgICAgICAgICAgIERlc3RydWN0aWJsZS5kZXN0cm95KCk7CiAgICAgICAgfQogICAgfQp9CgoKLy8gRcSfZXIgYmlyIGNvbnN0cnVjdG9yIHBhcmFtZXRyZSBhbMSxeW9yc2EsIGJ1Ci8vIGJhxZ9sxLFrdGEgdmV5YSBkZcSfacWfdGlyaWNpLcOnYcSfxLFybWEtc3RpbGkgaWxlCi8vIHTDvHJldGlsZW4gYWvEsWxsxLEgc8O2emxlxZ9tZXNpbmluIGNvbnN0cnVjdG9yJ8SxbmRhCi8vIHZlcmlsbWVsaWRpciAoYcWfYcSfxLF5YSBiYWvEsW4pLgpjb250cmFjdCBQcmljZUZlZWQgaXMgT3duZWQsIERlc3RydWN0aWJsZSwgTmFtZWQoIkdvbGRGZWVkIikgewogICAgZnVuY3Rpb24gdXBkYXRlSW5mbyh1aW50IG5ld0luZm8pIHB1YmxpYyB7CiAgICAgICAgaWYgKG1zZy5zZW5kZXIgPT0gb3duZXIpIGluZm8gPSBuZXdJbmZvOwogICAgfQoKICAgIC8vIEJ1cmFkYSBzYWRlY2UgYG92ZXJyaWRlYCB5YXrEsXlvcnV6LCBgdmlydHVhbGAgeWF6bcSxeW9ydXouCiAgICAvLyBCdSwgYFByaWNlRmVlZGAgYWvEsWxsxLEgc8O2emxlxZ9tZXNpbmRlbiB0w7xyZXRpbGVuIGFrxLFsbMSxIHPDtnpsZcWfbWVsZXJpbgogICAgLy8gYXJ0xLFrIGBkZXN0cm95YCBmb25rc2l5b251bnUgb3ZlcnJpZGUgZWRlbWV5ZWNla2xlcmkgYW5sYW3EsW5hIGdlbGl5b3IuCiAgICBmdW5jdGlvbiBkZXN0cm95KCkgcHVibGljIG92ZXJyaWRlKERlc3RydWN0aWJsZSwgTmFtZWQpIHsgTmFtZWQuZGVzdHJveSgpOyB9CiAgICBmdW5jdGlvbiBnZXQoKSBwdWJsaWMgdmlldyByZXR1cm5zKHVpbnQgcikgeyByZXR1cm4gaW5mbzsgfQoKICAgIHVpbnQgaW5mbzsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Owned {
 constructor() { owner \= payable(msg.sender); }
 address payable owner;
}
// \`is\` kullanarak başka bir akıllı sözleşmeyi türetebiliriz.
// Türetilen akıllı sözleşmeler private olmayan bütün üyelere
// erişebilir, internal fonksiyonlar ve durum değişkenleri
// dahil. Bunlara external olarak \`this\` kullanılarak da erişilemez.
contract Destructible is Owned {
 // \`virtual\` sözcüğü bu fonksiyonun, türetilen
 // akıllı sözleşmelerde değiştirilebileceğini belirtir ("overriding").
 function destroy() virtual public {
 if (msg.sender \== owner) selfdestruct(owner);
 }
}
// Abstract akıllı sözleşmeler sadece derleyiciye interface'i
// bildirmek için kullanılır. Fonksiyonun kodlarının olmadığına
// dikkat edin. Eğer bir akıllı sözleşme bütün fonksiyonlarının içeriğini
// bulundurmazsa, sadece interface olarak da kullanılabilir.
abstract contract Config {
 function lookup(uint id) public virtual returns (address adr);
}
abstract contract NameReg {
 function register(bytes32 name) public virtual;
 function unregister() public virtual;
}
// Çoklu türetim de mümkündür. \`Owned\` akıllı sözleşmesinin
// ayrıca \`Destructible\` akıllı sözleşmesinin ana akıllı sözleşmelerinden
// biri olduğunu unutmayın. Ancak \`Owned\` akıllı sözleşmesinin
// sadece bir adet örneği vardır (C++'daki sanal kalıtım gibi).
contract Named is Owned, Destructible {
 constructor(bytes32 name) {
 Config config \= Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
 NameReg(config.lookup(1)).register(name);
 }
 // Fonksiyonlar başka bir fonksiyon tarafından aynı isim ve aynı
 // sayıda/tipte girdi ile override edilebilir. Eğer override eden
 // fonksiyon farklı sayıda çıktı veriyorsa, bu ortaya bir hata çıkarır.
 // Hem yerel hem de mesaj-tabanlı fonksiyon çağrıları bu override işlemlerini
 // hesaba katar. Eğer bir fonksiyonu override etmek istiyorsanız
 // \`override\` sözcüğünü kullanmak zorundasınız. Ayrıca fonksiyonunuzun
 // tekrardan override edilebilir olmasını istiyorsanız, tekrardan
 // \`virtual\` olarak belirlemelisiniz.
 function destroy() public virtual override {
 if (msg.sender \== owner) {
 Config config \= Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
 NameReg(config.lookup(1)).unregister();
 // Override edilmiş bir fonksiyonu spesifik olarak
 // çağırmak mümkündür.
 Destructible.destroy();
 }
 }
}
// Eğer bir constructor parametre alıyorsa, bu
// başlıkta veya değiştirici-çağırma-stili ile
// türetilen akıllı sözleşmesinin constructor'ında
// verilmelidir (aşağıya bakın).
contract PriceFeed is Owned, Destructible, Named("GoldFeed") {
 function updateInfo(uint newInfo) public {
 if (msg.sender \== owner) info \= newInfo;
 }
 // Burada sadece \`override\` yazıyoruz, \`virtual\` yazmıyoruz.
 // Bu, \`PriceFeed\` akıllı sözleşmesinden türetilen akıllı sözleşmelerin
 // artık \`destroy\` fonksiyonunu override edemeyecekleri anlamına geliyor.
 function destroy() public override(Destructible, Named) { Named.destroy(); }
 function get() public view returns(uint r) { return info; }
 uint info;
}
Yukarıdaki `Destructible.destroy()` fonksiyon çağrımızın bazı problemlere yol açtığını aşağıdaki örnekte görebilirsiniz.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwp9Cgpjb250cmFjdCBEZXN0cnVjdGlibGUgaXMgb3duZWQgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyB2aXJ0dWFsIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgc2VsZmRlc3RydWN0KG93bmVyKTsKICAgIH0KfQoKY29udHJhY3QgQmFzZTEgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIGRvIGNsZWFudXAgMSAqLyBEZXN0cnVjdGlibGUuZGVzdHJveSgpOyB9Cn0KCmNvbnRyYWN0IEJhc2UyIGlzIERlc3RydWN0aWJsZSB7CiAgICBmdW5jdGlvbiBkZXN0cm95KCkgcHVibGljIHZpcnR1YWwgb3ZlcnJpZGUgeyAvKiBkbyBjbGVhbnVwIDIgKi8gRGVzdHJ1Y3RpYmxlLmRlc3Ryb3koKTsgfQp9Cgpjb250cmFjdCBGaW5hbCBpcyBCYXNlMSwgQmFzZTIgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyBvdmVycmlkZShCYXNlMSwgQmFzZTIpIHsgQmFzZTIuZGVzdHJveSgpOyB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract owned {
 constructor() { owner \= payable(msg.sender); }
 address payable owner;
}
contract Destructible is owned {
 function destroy() public virtual {
 if (msg.sender \== owner) selfdestruct(owner);
 }
}
contract Base1 is Destructible {
 function destroy() public virtual override { /\* do cleanup 1 \*/ Destructible.destroy(); }
}
contract Base2 is Destructible {
 function destroy() public virtual override { /\* do cleanup 2 \*/ Destructible.destroy(); }
}
contract Final is Base1, Base2 {
 function destroy() public override(Base1, Base2) { Base2.destroy(); }
}
`Final.destroy()` çağrısı `Base2.destroy` fonksiyonunu çağıracak. Çünkü yaptığımız son override’da böyle belirtti. Ancak bu fonksiyon `Base1.destroy` fonksiyonunu bypass eder.
A call to `Final.destroy()` will call `Base2.destroy` because we specify it explicitly in the final override, but this function will bypass `Base1.destroy`. Bunu aşmanın yolu `super` kelimesini kullanmaktır:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwp9Cgpjb250cmFjdCBEZXN0cnVjdGlibGUgaXMgb3duZWQgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHZpcnR1YWwgcHVibGljIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgc2VsZmRlc3RydWN0KG93bmVyKTsKICAgIH0KfQoKY29udHJhY3QgQmFzZTEgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIGRvIGNsZWFudXAgMSAqLyBzdXBlci5kZXN0cm95KCk7IH0KfQoKCmNvbnRyYWN0IEJhc2UyIGlzIERlc3RydWN0aWJsZSB7CiAgICBmdW5jdGlvbiBkZXN0cm95KCkgcHVibGljIHZpcnR1YWwgb3ZlcnJpZGUgeyAvKiBkbyBjbGVhbnVwIDIgKi8gc3VwZXIuZGVzdHJveSgpOyB9Cn0KCmNvbnRyYWN0IEZpbmFsIGlzIEJhc2UxLCBCYXNlMiB7CiAgICBmdW5jdGlvbiBkZXN0cm95KCkgcHVibGljIG92ZXJyaWRlKEJhc2UxLCBCYXNlMikgeyBzdXBlci5kZXN0cm95KCk7IH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract owned {
 constructor() { owner \= payable(msg.sender); }
 address payable owner;
}
contract Destructible is owned {
 function destroy() virtual public {
 if (msg.sender \== owner) selfdestruct(owner);
 }
}
contract Base1 is Destructible {
 function destroy() public virtual override { /\* do cleanup 1 \*/ super.destroy(); }
}
contract Base2 is Destructible {
 function destroy() public virtual override { /\* do cleanup 2 \*/ super.destroy(); }
}
contract Final is Base1, Base2 {
 function destroy() public override(Base1, Base2) { super.destroy(); }
}
`Base2` , `super` işlevini çağırırsa, bu işlevi temel sözleşmelerinden birinde çağırmaz. Bunun yerine, son kalıtım grafiğindeki bir sonraki temel sözleşmede bu işlevi çağırır, bu nedenle `Base1.destroy()` u çağırır (son kalıtım dizisinin – en türetilmiş sözleşmeyle başlayarak şöyle olduğuna dikkat edin: Final, Base2, Base1, Destructible, owned). super kullanılırken çağrılan asıl işlev, türü bilinmesine rağmen kullanıldığı sınıf bağlamında bilinmemektedir. Bu, sıradan sanal yöntem araması için benzerdir.
### Fonksiyon Override Etme[](#fonksiyon-override-etme "Permalink to this heading")
Temel fonksiyonlar `virtual` olarak işaretlenmişse, davranışlarını değiştirmek için override edilebilirler. Override eden fonksiyon `override` olarak belirlenmelidir. Override edilen fonksiyonun görünürlüğü `external`’dan `public`’e dönüştürülebilir. Değişebilirlik ise daha fazla kısıtlandırılmış bir yapıya dönüştürülebilir: `nonpayable`, `view` ve `pure` tarafından override edilebilir. `view` ise `pure` tarafından override edilebilir. `payable` bir istisna olarak diğer değişebilirlik türlerine dönüştürülemez.
Aşağıdaki örnek değişebilirliği ve görünürlüğü değiştirmeyi açıklıyor:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZQp7CiAgICBmdW5jdGlvbiBmb28oKSB2aXJ0dWFsIGV4dGVybmFsIHZpZXcge30KfQoKY29udHJhY3QgTWlkZGxlIGlzIEJhc2Uge30KCmNvbnRyYWN0IEluaGVyaXRlZCBpcyBNaWRkbGUKewogICAgZnVuY3Rpb24gZm9vKCkgb3ZlcnJpZGUgcHVibGljIHB1cmUge30KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Base
{
 function foo() virtual external view {}
}
contract Middle is Base {}
contract Inherited is Middle
{
 function foo() override public pure {}
}
Çoklu kalıtım için, aynı işlevi tanımlayan en çok türetilmiş temel sözleşmeler, `override` anahtar sözcüğünden sonra açıkça belirtilmelidir. Başka bir deyişle, aynı işlevi tanımlayan ve henüz başka bir temel sözleşme tarafından geçersiz kılınmamış tüm temel sözleşmeleri belirtmeniz gerekir (miras grafiği boyunca bir yolda). Ek olarak, bir sözleşme aynı işlevi birden çok (ilgisiz) temelden devralırsa, bunu açıkça geçersiz kılması gerekir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEKewogICAgZnVuY3Rpb24gZm9vKCkgdmlydHVhbCBwdWJsaWMge30KfQoKY29udHJhY3QgQmFzZTIKewogICAgZnVuY3Rpb24gZm9vKCkgdmlydHVhbCBwdWJsaWMge30KfQoKY29udHJhY3QgSW5oZXJpdGVkIGlzIEJhc2UxLCBCYXNlMgp7CiAgICAvLyBmb28oKSBmb25rc2l5b251bmEgc2FoaXAgYmlyZGVuIGZhemxhIHRlbWVsIGFrxLFsbMSxIHPDtnpsZcWfbWVzaSB0w7xyZXRpci4KICAgIC8vIEJ1IHnDvHpkZW4gb3ZlcnJpZGUgZXRtZWsgacOnaW4gYcOnxLFrw6dhIGJlbGlydG1lbGl5aXouCiAgICBmdW5jdGlvbiBmb28oKSBwdWJsaWMgb3ZlcnJpZGUoQmFzZTEsIEJhc2UyKSB7fQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract Base1
{
 function foo() virtual public {}
}
contract Base2
{
 function foo() virtual public {}
}
contract Inherited is Base1, Base2
{
 // foo() fonksiyonuna sahip birden fazla temel akıllı sözleşmesi türetir.
 // Bu yüzden override etmek için açıkça belirtmeliyiz.
 function foo() public override(Base1, Base2) {}
}
Fonksiyon, ortak bir temel sözleşmede tanımlanmışsa veya ortak bir temel sözleşmede diğer tüm işlevleri zaten override eden benzersiz bir işlev varsa, açık bir override belirteci gerekli değildir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQSB7IGZ1bmN0aW9uIGYoKSBwdWJsaWMgcHVyZXt9IH0KY29udHJhY3QgQiBpcyBBIHt9CmNvbnRyYWN0IEMgaXMgQSB7fQovLyBBw6fEsWvDp2Egb3ZlcnJpZGUgZ2VyZWttZW1la3RlZGlyLgpjb250cmFjdCBEIGlzIEIsIEMge30=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract A { function f() public pure{} }
contract B is A {}
contract C is A {}
// Açıkça override gerekmemektedir.
contract D is B, C {}
Daha resmi olarak, imza için tüm override etme yollarının parçası olan bir temel sözleşme varsa, birden çok tabandan devralınan bir fonksiyonu (doğrudan veya dolaylı olarak) override etme gerekli değildir ve (1) bu taban fonksiyonu uygular ve mevcut akıllı sözleşmeden tabana giden hiçbir yol bu imzaya sahip bir fonksiyondan bahsetmez veya (2) bu taban fonksiyonu yerine getirmiyor ve mevcut akıllı sözleşmeden o tabana kadar olan tüm yollarda fonksiyondan en fazla bir kez söz ediliyor.
Bu anlamda, bir imza için override etme yolu, söz konusu akıllı sözleşmede başlayan ve override etmeyen bu imzaya sahip bir işlevden bahseden bir akıllı sözleşmede sona eren miras grafiği boyunca bir yoldur.
Override eden bir fonksiyonu `virtual` olarak işaretlemezseniz, türetilmiş sözleşmeler artık bu fonksiyonun davranışını değiştiremez.
Not
`private` görünürlüğe sahip fonksiyonlar `virtual` olamaz.
Not
Interface dışında olup da kodu olmayan fonksiyonlar `virtual` olarak işaretlenmelidir. Interface içerisindeki bütün fonksiyonlar otomatikmen `virtual` olarak düşünülür.
Not
Solidity 0.8.8 itibari ile bir interface fonksiyonunu override ederken `override` sözcüğünü kullanmanıza gerek kalmıyor, birden fazla temel akıllı sözleşmede tanımlanan fonksiyonlar dışında.
Public durum değişkenleri parametre ve dönüş tipleri uyuştuğu zaman bir external fonksiyonu override edebilir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQQp7CiAgICBmdW5jdGlvbiBmKCkgZXh0ZXJuYWwgdmlldyB2aXJ0dWFsIHJldHVybnModWludCkgeyByZXR1cm4gNTsgfQp9Cgpjb250cmFjdCBCIGlzIEEKewogICAgdWludCBwdWJsaWMgb3ZlcnJpZGUgZjsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract A
{
 function f() external view virtual returns(uint) { return 5; }
}
contract B is A
{
 uint public override f;
}
Not
Public durum değişkenleri external fonksiyonları override edebilirken, kendileri override edilemez.
### Modifier Override Etme[](#modifier-override-etme "Permalink to this heading")
Fonksiyon modifier’ları birbirlerini override edebilirler. Bu aynı [fonksiyon override etmedeki](#function-overriding) gibidir (modifierlarda overload etme olmamakla istisnası ile). `virtual` sözcüğü override edilecek modifier’da kullanılmalı ve override eden modifier’da ise `override` sözcüğü kullanılmalıdır.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZQp7CiAgICBtb2RpZmllciBmb28oKSB2aXJ0dWFsIHtfO30KfQoKY29udHJhY3QgSW5oZXJpdGVkIGlzIEJhc2UKewogICAgbW9kaWZpZXIgZm9vKCkgb3ZlcnJpZGUge187fQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract Base
{
 modifier foo() virtual {\_;}
}
contract Inherited is Base
{
 modifier foo() override {\_;}
}
Çoklu kalıtım durumumnda bütün temel akıllı sözleşmeler açıkça override edilme durumunu belirtmelidir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEKewogICAgbW9kaWZpZXIgZm9vKCkgdmlydHVhbCB7Xzt9Cn0KCmNvbnRyYWN0IEJhc2UyCnsKICAgIG1vZGlmaWVyIGZvbygpIHZpcnR1YWwge187fQp9Cgpjb250cmFjdCBJbmhlcml0ZWQgaXMgQmFzZTEsIEJhc2UyCnsKICAgIG1vZGlmaWVyIGZvbygpIG92ZXJyaWRlKEJhc2UxLCBCYXNlMikge187fQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract Base1
{
 modifier foo() virtual {\_;}
}
contract Base2
{
 modifier foo() virtual {\_;}
}
contract Inherited is Base1, Base2
{
 modifier foo() override(Base1, Base2) {\_;}
}
### Constructor’lar[](#constructor-lar "Permalink to this heading")
Constructor isteğe bağlı olarak tanımlanan özel fonksiyonlardan biridir ve `constructor` sözcüğü ile tanımlanır. Bu fonksiyon akıllı sözleşme oluşumu sırasında çalıştırılır ve akıllı sözleşme başlatma kodunuz burada bulunmaktadır.
Constructor kodu çalıştırılmadan önce durum değişkenleri eğer aynı satırda tanımladıysanız gerekli değer atamalarını veya tanımlamadıysanız [default değerlerini](https://docs.soliditylang.org/tr/latest/control-structures.html#default-value) alırlar.
Constructor çalıştırıldıktan sonra kodun son hali blockchain’e yüklenir. Bu işlemin ücreti ise lineer bir şekilde olup kodun uzunluğuna bağımlıdır. Bu kod dışarıdan erişilebilecek ve bir fonksiyon tarafından erişilen bütün fonksiyonları içerir. Constructor kodunu veya sadece constructor tarafından erişilen internal fonksiyonları içermez.
Eğer constructor yoksa, default constructor çalıştırılır `constructor() {}`. Örneğin:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgQSB7CiAgICB1aW50IHB1YmxpYyBhOwoKICAgIGNvbnN0cnVjdG9yKHVpbnQgYV8pIHsKICAgICAgICBhID0gYV87CiAgICB9Cn0KCmNvbnRyYWN0IEIgaXMgQSgxKSB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
abstract contract A {
 uint public a;
 constructor(uint a\_) {
 a \= a\_;
 }
}
contract B is A(1) {
 constructor() {}
}
Constructor’larda internal parametreleri kullanabilirsiniz (örneğin, storage pointer’ları). Bu durumda akıllı sözleşme [abstract](#abstract-contract) olarak işaretlenmelidir. Çünkü bu parametrelere dışarıdan geçerli değerler atanamaz, ancak yalnızca türetilmiş sözleşmelerin constructor’ları aracılığıyla atanır.
Uyarı
Versiyon 0.4.22 öncesinde constructor’lar akıllı sözleşme ile aynı isme sahip fonksiyonlar olarak kullanılırdı. Ancak bu yazılış biçiminin Versiyon 0.5.0 sonrasında kullanımına izin verilmemektedir.
Uyarı
Versiyon 0.7.0 öncesinde constructor’ların görünürlüğünü `internal` veya `public` olarak belirtmek zorundaydınız.
### Temel Constructor’lar için Argümanlar[](#temel-constructor-lar-icin-argumanlar "Permalink to this heading")
Tüm temel akıllı sözleşmelerin constructor’ları, aşağıda açıklanan doğrusallaştırma kurallarına göre çağrılacaktır. Temel akıllı sözleşmelerin argümanları varsa, türetilmiş akıllı sözleşmelerin hepsini belirtmesi gerekir. Bu iki şekilde yapılabilir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZSB7CiAgICB1aW50IHg7CiAgICBjb25zdHJ1Y3Rvcih1aW50IHhfKSB7IHggPSB4XzsgfQp9CgovLyBEaXJla3Qga2FsxLF0xLFtIGxpc3Rlc2luZGUgYmVsaXJ0bWUuLi4KY29udHJhY3QgRGVyaXZlZDEgaXMgQmFzZSg3KSB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0KCi8vIHZleWEgIm1vZGlmaWVyIiBzdGlsaW5kZSBiZWxpcnRtZS4uLgpjb250cmFjdCBEZXJpdmVkMiBpcyBCYXNlIHsKICAgIGNvbnN0cnVjdG9yKHVpbnQgeSkgQmFzZSh5ICogeSkge30KfQoKLy8gdmV5YSBhYnN0cmFjdCBvbGFyYWsgYmVsaXJ0aW4uLi4KYWJzdHJhY3QgY29udHJhY3QgRGVyaXZlZDMgaXMgQmFzZSB7Cn0KCi8vIHZlIGJpciBzb25yYWtpIGNvbnRyYWN0xLFuIG9udSBiYcWfbGF0bWFzxLFuxLEgc2HEn2xhecSxbi4KY29udHJhY3QgRGVyaXZlZEZyb21EZXJpdmVkIGlzIERlcml2ZWQzIHsKICAgIGNvbnN0cnVjdG9yKCkgQmFzZSgxMCArIDEwKSB7fQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Base {
 uint x;
 constructor(uint x\_) { x \= x\_; }
}
// Direkt kalıtım listesinde belirtme...
contract Derived1 is Base(7) {
 constructor() {}
}
// veya "modifier" stilinde belirtme...
contract Derived2 is Base {
 constructor(uint y) Base(y \* y) {}
}
// veya abstract olarak belirtin...
abstract contract Derived3 is Base {
}
// ve bir sonraki contractın onu başlatmasını sağlayın.
contract DerivedFromDerived is Derived3 {
 constructor() Base(10 + 10) {}
}
Bir yol doğrudan kalıtım listesindedir (`is Base(7)`). Diğeri, türetilmiş constructor’ın bir parçası olarak bir modifier’ın çağrılma biçimindedir (`Base(y * y)`). Bunu yapmanın ilk yolu, constructor argümanının sabit olması ve akıllı sözleşmenin davranışını tanımlaması veya tanımlaması durumunda daha uygundur. Temel constructor argümanları türetilmiş akıllı sözleşmenin argümanlarına bağlıysa, ikinci yol kullanılmalıdır. Argümanlar ya kalıtım listesinde ya da türetilmiş constructor’da değiştirici-tarzda verilmelidir. Argümanları her iki yerde de belirtmek bir hatadır.
Türetilmiş bir akıllı sözleşme, temel akıllı sözleşmelerin tüm constructorları için argümanları belirtmiyorsa, özet olarak bildirilmelidir. Bu durumda, ondan başka bir akıllı sözleşme türetildiğinde, diğer akıllı sözleşmenin miras listesi veya constructor’ı, parametreleri belirtilmemiş tüm temel sınıflar için gerekli parametreleri sağlamalıdır (aksi takdirde, diğer akıllı sözleşme da soyut olarak bildirilmelidir). Örneğin, yukarıdaki kod parçacığında, bkz. `Derived3` ve `DerivedFromDerived`.
### Çoklu Kalıtım ve Doğrusallaştırma[](#coklu-kalitim-ve-dogrusallastirma "Permalink to this heading")
Çoklu kalıtıma izin veren diller birkaç problemle uğraşmak zorundadır. Bunlardan bir tanesi [Elmas Problemi’dir](https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem). Solidity Python’a benzer olarak “[C3 Linearization](https://en.wikipedia.org/wiki/C3_linearization)” kullanarak directed acyclic graph’da (DAG) spesifik bir sırayı zorlar. Bu, istenen monotonluk özelliği ile sonuçlanır, ancak bazı kalıtım grafiklerine izin vermez. Özellikle `is` yönergesinde temel sınıfların veriliş sırası önemlidir: Doğrudan temel sözleşmeleri “en temele benzeyen”den “en çok türetilene” doğru sıralamalısınız. Bu sıralamanın Python’da kullanılanın tersi olduğuna dikkat edin.
Bunu açıklamanın bir başka basitleştirici yolu, farklı akıllı sözleşmelerde birden çok kez tanımlanan bir fonksiyon çağrıldığında, verilen tabanların sağdan sola (Python’da soldan sağa) derinlemesine ilk olarak aranması ve ilk eşleşmede durdurulmasıdır. . Bir temel akıllı sözleşme zaten aranmışsa, atlanır.
Aşağıdaki kodda Solidity “Linearization of inheritance graph impossible” hatası verecektir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgWCB7fQpjb250cmFjdCBBIGlzIFgge30KLy8gQnUgZGVybGVuZW1legpjb250cmFjdCBDIGlzIEEsIFgge30=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract X {}
contract A is X {}
// Bu derlenemez
contract C is A, X {}
Bunun sebebi `C` akıllı sözleşmesinin `X` akıllı sözleşmesinin `A` akıllı sözleşmesini override etmesini istemesidir (`A, X` sırası ile bunu belirtiyor), ancak `A` akıllı sözleşmesinin kendisi `X` akıllı sözleşmesini override etmeyi talep eder ki bu çözülemeyecek bir çelişkidir.
Benzersiz bir override olmadan birden çok tabandan devralınan bir fonksiyonu açıkça override etmek gerektiğinden, pratikte C3 doğrusallaştırması çok önemli değildir.
Kalıtım doğrusallaştırmasının özellikle önemli olduğu ve belki de o kadar net olmadığı bir alan, miras hiyerarşisinde birden çok constructor olduğu zamandır. Constructor’lar, argümanlarının devralınan akıllı sözleşmenin constructor’ında sağlandığı sıraya bakılmaksızın her zaman doğrusallaştırılmış sırada yürütülür. Örneğin:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEgewogICAgY29uc3RydWN0b3IoKSB7fQp9Cgpjb250cmFjdCBCYXNlMiB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0KCi8vIENvbnN0cnVjdG9yJ2xhciBhxZ9hxJ/EsWRha2kgc8SxcmEgaWxlIMOnYWzEscWfxLFyOgovLyAgMSAtIEJhc2UxCi8vICAyIC0gQmFzZTIKLy8gIDMgLSBEZXJpdmVkMQpjb250cmFjdCBEZXJpdmVkMSBpcyBCYXNlMSwgQmFzZTIgewogICAgY29uc3RydWN0b3IoKSBCYXNlMSgpIEJhc2UyKCkge30KfQoKLy8gQ29uc3RydWN0b3InbGFyIGHFn2HEn8SxZGFraSBzxLFyYSBpbGUgw6dhbMSxxZ/EsXI6Ci8vICAxIC0gQmFzZTIKLy8gIDIgLSBCYXNlMQovLyAgMyAtIERlcml2ZWQyCmNvbnRyYWN0IERlcml2ZWQyIGlzIEJhc2UyLCBCYXNlMSB7CiAgICBjb25zdHJ1Y3RvcigpIEJhc2UyKCkgQmFzZTEoKSB7fQp9CgovLyBDb25zdHJ1Y3RvcnMgYXJlIHN0aWxsIGV4ZWN1dGVkIGluIHRoZSBmb2xsb3dpbmcgb3JkZXI6Ci8vICAxIC0gQmFzZTIKLy8gIDIgLSBCYXNlMQovLyAgMyAtIERlcml2ZWQzCmNvbnRyYWN0IERlcml2ZWQzIGlzIEJhc2UyLCBCYXNlMSB7CiAgICBjb25zdHJ1Y3RvcigpIEJhc2UxKCkgQmFzZTIoKSB7fQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Base1 {
 constructor() {}
}
contract Base2 {
 constructor() {}
}
// Constructor'lar aşağıdaki sıra ile çalışır:
// 1 - Base1
// 2 - Base2
// 3 - Derived1
contract Derived1 is Base1, Base2 {
 constructor() Base1() Base2() {}
}
// Constructor'lar aşağıdaki sıra ile çalışır:
// 1 - Base2
// 2 - Base1
// 3 - Derived2
contract Derived2 is Base2, Base1 {
 constructor() Base2() Base1() {}
}
// Constructors are still executed in the following order:
// 1 - Base2
// 2 - Base1
// 3 - Derived3
contract Derived3 is Base2, Base1 {
 constructor() Base1() Base2() {}
}
### Farklı Türden Aynı İsme Sahip Üyeleri Türetme[](#farkli-turden-ayni-isme-sahip-uyeleri-turetme "Permalink to this heading")
Bir akıllı sözleşmede aşağıdaki çiftlerden herhangi birinin miras nedeniyle aynı ada sahip olması bir hatadır:
* bir fonksiyon ve bir modifier
 
* bir fonksiyon ve bir event
 
* bir event ve bir modifier
 
İstisna olarak, bir durum değişkeninin getirici fonksiyonu bir external fonksiyonu override edebilir.
## Abstract Akıllı Sözleşmeler[](#abstract-akilli-sozlesmeler "Permalink to this heading")
Sözleşmeler, işlevlerinden en az biri uygulanmadığında veya bütün temel sözleme yapıcılar için argüman sağlamadığında abstract olarak işaretlenmelidir. Bu durumlardan herhangi biri geçerli değilse bile bir akıllı sözleşme abstract olarak işaretlenebilir. Örneğin bir akıllı sözleşmenin direkt olarak oluşturulmasını istemediğiniz durumlarda bunu gerçekleştirebilirsiniz. Abstract akıllı sözleşmeler [Interface’ler](#interfaces) oldukça benzerdir ancak interface’ler çok daha kısıtlı bir yapıdadır.
Aşağıdaki örnekte belirtildiği gibi, Abstract akıllı sözleşmeler `abstract` olarak işaretlenerek belirtilir. Aşağıdaki akıllı sözleşmenin abstract olarak tanımlanması gerektiğine dikkat edin. Çünkü `utterance()` fonksiyonu tanımlanıp kodları yazılmamıştır (`{ }` arasında kod bulunmamakta).
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgRmVsaW5lIHsKICAgIGZ1bmN0aW9uIHV0dGVyYW5jZSgpIHB1YmxpYyB2aXJ0dWFsIHJldHVybnMgKGJ5dGVzMzIpOwp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
abstract contract Feline {
 function utterance() public virtual returns (bytes32);
}
Bu tip abstract akıllı sözleşmeler direkt olarak örneklendirilemez. Bu, abstract sözleşmenin kendisi tanımlanmış tüm işlevleri yerine getiriyorsa da geçerlidir. Abstract bir akıllı sözleşmenin temel sınıf olarak kullanımı aşağıda gösterilmiştir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgRmVsaW5lIHsKICAgIGZ1bmN0aW9uIHV0dGVyYW5jZSgpIHB1YmxpYyBwdXJlIHZpcnR1YWwgcmV0dXJucyAoYnl0ZXMzMik7Cn0KCmNvbnRyYWN0IENhdCBpcyBGZWxpbmUgewogICAgZnVuY3Rpb24gdXR0ZXJhbmNlKCkgcHVibGljIHB1cmUgb3ZlcnJpZGUgcmV0dXJucyAoYnl0ZXMzMikgeyByZXR1cm4gIm1pYW93IjsgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
abstract contract Feline {
 function utterance() public pure virtual returns (bytes32);
}
contract Cat is Feline {
 function utterance() public pure override returns (bytes32) { return "miaow"; }
}
Bir akıllı sözleşme bir abstract akıllı sözleşmeden türetiliyorsa ve abstract akıllı sözleşmedeki bütün kodu yazılmamış fonksiyonların kodunu yazmıyorsa, o akıllı sözleşme da abstract olarak belirtilmelidir.
Kodu olmayan bir fonksiyonun [Fonksiyon Tipinden](https://docs.soliditylang.org/tr/latest/types.html#function-types) farklı olduğuna dikkat edin, her ne kadar yazılışları oldukça benzer olsa da.
Kodu olmayan bir fonksiyona örnek olarak (fonksiyon tanımlaması):
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=ZnVuY3Rpb24gZm9vKGFkZHJlc3MpIGV4dGVybmFsIHJldHVybnMgKGFkZHJlc3MpOw==)
function foo(address) external returns (address);
Türü bir fonksiyon türü olan bir değişken bildirimi örneği:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=ZnVuY3Rpb24oYWRkcmVzcykgZXh0ZXJuYWwgcmV0dXJucyAoYWRkcmVzcykgZm9vOw==)
function(address) external returns (address) foo;
Abstract akıllı sözleşmeler, daha iyi genişletilebilirlik ve kendi kendine belgeleme sağlayarak ve [Template yöntemi](https://en.wikipedia.org/wiki/Template_method_pattern) gibi kalıpları kolaylaştırarak ve kod tekrarını ortadan kaldırarak bir akıllı sözleşmenin tanımını uygulamasından ayırır. Abstract akıllı sözleşmeler, bir arabirimdeki yöntemleri tanımlamanın yararlı olduğu şekilde yararlıdır. Abstract akıllı sözleşmenin tasarımcısının “her çocuğum bu yöntemi uygulamalı” demesinin bir yoludur.
Not
Abstract akıllı sözleşmeler kodu yazılmış bir virtual fonksiyonu kodu yazılmamış bir fonksiyon ile override edemezler.
## Interface’ler[](#interface-ler "Permalink to this heading")
Interface’ler abstract akıllı sözleşmelere benzerler ama onlardan farklı olarak hiçbir fonksiyonunun kodu yazılamaz. Daha fazla kısıtlama vardır:
* Diğer akıllı sözleşmelerden miras alamazken, diğer interface’lerden alabilirler.
 
* Interface’deki bütün fonksiyonlar external olmalıdır, akıllı sözleşmede public olsalar dahi.
 
* Constructor tanımlayamazlar.
 
* Durum değişkeni tanımlayamazlar.
 
* Modifier tanımlayamazlar.
 
Bu kısıtlamalardan bazıları ilerleyen zamanlarda kaldırılabilir.
Interface’ler kabaca akıllı sözleşme ABI’sinin temsil edebileciği ile kısıtlıdır. Bu yüzden ABI ve interface arasındaki dönüşümler bilgi kaybı yaşanmadan gerçekleştirilebilmelidir.
Interface’ler kendi anahtar sözcükleri ile tanımlanırlar:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKaW50ZXJmYWNlIFRva2VuIHsKICAgIGVudW0gVG9rZW5UeXBlIHsgRnVuZ2libGUsIE5vbkZ1bmdpYmxlIH0KICAgIHN0cnVjdCBDb2luIHsgc3RyaW5nIG9idmVyc2U7IHN0cmluZyByZXZlcnNlOyB9CiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIHJlY2lwaWVudCwgdWludCBhbW91bnQpIGV4dGVybmFsOwp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.2 <0.9.0;
interface Token {
 enum TokenType { Fungible, NonFungible }
 struct Coin { string obverse; string reverse; }
 function transfer(address recipient, uint amount) external;
}
Akıllı sözleşmeler diğer akıllı sözleşmelerden miras alabildikleri gibi diğer interface’lerden de alabilirler.
Interface’lerdeki bütün fonksiyonlar gizlici `virtual` olarak işaretlenmiş haldedir ve onları override ederken `override` kelimesine gerek yoktur. Bu, otomatik olarak override eden bir fonksiyonun yeniden override edilebileceği anlamına gelmez - bu yalnızca override eden fonksiyon `virtual` olarak işaretlenmişse mümkündür.
Interface’ler diğer interfacelerden miras alabilirler, normal kalıtım kuralında olduğu gibi.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKaW50ZXJmYWNlIFBhcmVudEEgewogICAgZnVuY3Rpb24gdGVzdCgpIGV4dGVybmFsIHJldHVybnMgKHVpbnQyNTYpOwp9CgppbnRlcmZhY2UgUGFyZW50QiB7CiAgICBmdW5jdGlvbiB0ZXN0KCkgZXh0ZXJuYWwgcmV0dXJucyAodWludDI1Nik7Cn0KCmludGVyZmFjZSBTdWJJbnRlcmZhY2UgaXMgUGFyZW50QSwgUGFyZW50QiB7CiAgICAvLyBFYmV2ZW55IGFubGFtbGFyxLFuxLFuIHV5dW1sdSBvbGR1xJ91bnUgaWRkaWEKICAgIC8vIGV0bWVrIGnDp2luIHRlc3QgeWVuaWRlbiB0YW7EsW1sYW5tYWzEsWTEsXIuCiAgICBmdW5jdGlvbiB0ZXN0KCkgZXh0ZXJuYWwgb3ZlcnJpZGUoUGFyZW50QSwgUGFyZW50QikgcmV0dXJucyAodWludDI1Nik7Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.2 <0.9.0;
interface ParentA {
 function test() external returns (uint256);
}
interface ParentB {
 function test() external returns (uint256);
}
interface SubInterface is ParentA, ParentB {
 // Ebeveny anlamlarının uyumlu olduğunu iddia
 // etmek için test yeniden tanımlanmalıdır.
 function test() external override(ParentA, ParentB) returns (uint256);
}
Interface’lerde tanımlanan tiplere ve diğer akıllı sözleşme benzeri yapılara diğer akıllı sözleşmelerden erişilebilir: `Token.TokenType` veya `Token.Coin`.
## Kütüphaneler[](#kutuphaneler "Permalink to this heading")
Kütüphaneler akıllı sözleşmelere benzerler, ama onların amacı sadece bir kere deploy edilip daha sonrasında ihtiyaç duyulması halinde `DELEGATECALL` ile çağrılmalarıdır (Homestead’a kadar `CALLCODE` kullanılırdı). Bu demek oluyor ki kütüphane fonksiyonları çağrıldığında, onların kodu çağıran akıllı sözleşmenin içeriği ile çalıştırılıyor, mesela `this` sözcüğü çağıran akıllı sözleşmeyi işaret eder ve özellikle storage olarak çağıran akıllı sözleşmenin storage kısmı kullanılır. Bir kütüphane izole edilmiş bir kaynak kodu parçası olduğundan, yalnızca açıkça sağlanmışlarsa çağrı sözleşmesinin durum değişkenlerine erişebilir (aksi takdirde bunları adlandırmanın hiçbir yolu yoktur). Kütüphane fonksiyonları yalnızca durumu değiştirmedikleri takdirde (yani `view` veya `pure` fonksiyonlarsa) doğrudan (yani `DELEGATECALL` kullanılmadan) çağrılabilir, çünkü kütüphanelerin durumsuz olduğu varsayılır. Özellikle, bir kütüphaneyi yok etmek mümkün değildir.
Not
0.4.20 sürümüne kadar, Solidity’nin tip sistemini atlayarak kütüphaneleri yok etmek mümkündü. Bu sürümden başlayarak, kütüphaneler, durumu değiştiren fonksiyonların doğrudan çağrılmasına izin vermeyen bir [mekanizma](#call-protection) içerir (yani `DELEGATECALL` olmadan).
Kütüphaneler, onları kullanan akıllı sözleşmelerin zımni temel akıllı sözleşmeleri olarak görülebilir. Miras hiyerarşisinde açıkça görünmezler, ancak kütüphane fonksiyonlarına yapılan çağrılar, açık temel akıllı sözleşmelerin fonksiyonlarına yapılan çağrılara benzer (L.f() gibi nitelikli erişim kullanarak). Tabii ki, dahili fonksiyonlara yapılan çağrılar dahili çağrı kuralını kullanır; bu, tüm dahili türlerin iletilebileceği ve bellekte depolanan türlerin kopyalanmadan referans olarak iletileceği anlamına gelir. Bunu EVM’de gerçekleştirmek için, bir akıllı sözleşmeden çağrılan dahili kütüphane fonksiyonlarının ve buradan çağrılan tüm fonksiyonların kodu derleme zamanında çağrı akıllı sözleşmesine dahil edilecek ve bir `DELEGATECALL` yerine normal bir JUMP çağrısı kullanılacaktır.
Not
Public fonksiyonlar söz konusu olduğunda miras analojisi bozulur. L.f() ile bir genel kütüphane fonksiyonunun çağrılması, harici bir çağrıyla sonuçlanır (kesin olarak `DELEGATECALL`). Buna karşılık, A mevcut akıllı sözleşmesinin temel akıllı sözleşmesi olduğunda, A.f() dahili bir çağrıdır.
Aşağıdaki örnek, kütüphanelerin nasıl kullanılacağını gösterir (ancak manuel bir yöntem kullanarak, bir kümeyi uygulamak için daha gelişmiş bir örnek için kullanmayı kontrol ettiğinizden emin olun).
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKCi8vIMOHYcSfcsSxIGFrxLFsbMSxIHPDtnpsZcWfbWVzaW5kZSB2ZXJpbGVyaW5pIHR1dG1hawovLyBpw6dpbiBrdWxsYW7EsWxhY2FrIHllbmkgYmlyIHN0cnVjdCB2ZXJpIHTDvHLDvCB0YW7EsW1sxLF5b3J1ei4Kc3RydWN0IERhdGEgewogICAgbWFwcGluZyh1aW50ID0+IGJvb2wpIGZsYWdzOwp9CgpsaWJyYXJ5IFNldCB7CiAgICAvLyDEsGxrIHBhcmFtZXRyZW5pbiAiZGVwb2xhbWEgcmVmZXJhbnPEsSIgdMO8csO8bmRlCiAgICAvLyBvbGR1xJ91bnUgdmUgYnUgbmVkZW5sZSDDp2HEn3LEsW7EsW4gYmlyIHBhcsOnYXPEsQogICAgLy8gb2xhcmFrIGnDp2VyacSfaW5pbiBkZcSfaWwsIHlhbG7EsXpjYSBkZXBvbGFtYQogICAgLy8gYWRyZXNpbmluIGlsZXRpbGRpxJ9pbmkgdW51dG1hecSxbi4KICAgIC8vIEJ1LCBrw7x0w7xwaGFuZSBmb25rc2l5b25sYXLEsW7EsW4gw7Z6ZWwgYmlyIMO2emVsbGnEn2lkaXIuCiAgICAvLyBGb25rc2l5b24sIG8gbmVzbmVuaW4gYmlyIHnDtm50ZW1pIG9sYXJhayBnw7Zyw7xsZWJpbGl5b3JzYSwKICAgIC8vIGlsayBwYXJhbWV0cmV5aSAnc2VsZicgb2xhcmFrIGFkbGFuZMSxcm1hayBkZXlpbXNlbGRpci4KICAgIGZ1bmN0aW9uIGluc2VydChEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgICAgICBwdWJsaWMKICAgICAgICByZXR1cm5zIChib29sKQogICAgewogICAgICAgIGlmIChzZWxmLmZsYWdzW3ZhbHVlXSkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyB6YXRlbiBvcmFkYQogICAgICAgIHNlbGYuZmxhZ3NbdmFsdWVdID0gdHJ1ZTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiByZW1vdmUoRGF0YSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICAgICAgcHVibGljCiAgICAgICAgcmV0dXJucyAoYm9vbCkKICAgIHsKICAgICAgICBpZiAoIXNlbGYuZmxhZ3NbdmFsdWVdKQogICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG9yYWRhIGRlxJ9pbAogICAgICAgIHNlbGYuZmxhZ3NbdmFsdWVdID0gZmFsc2U7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICB9CgogICAgZnVuY3Rpb24gY29udGFpbnMoRGF0YSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICAgICAgcHVibGljCiAgICAgICAgdmlldwogICAgICAgIHJldHVybnMgKGJvb2wpCiAgICB7CiAgICAgICAgcmV0dXJuIHNlbGYuZmxhZ3NbdmFsdWVdOwogICAgfQp9CgoKY29udHJhY3QgQyB7CiAgICBEYXRhIGtub3duVmFsdWVzOwoKICAgIGZ1bmN0aW9uIHJlZ2lzdGVyKHVpbnQgdmFsdWUpIHB1YmxpYyB7CiAgICAgICAgLy8gIkluc3RhbmNlIiBnZcOnZXJsaSBha8SxbGzEsSBzw7Z6bGXFn21lIG9sYWNhxJ/EsW5kYW4sCiAgICAgICAgLy8ga8O8dMO8cGhhbmUgZm9ua3NpeW9ubGFyxLEga8O8dMO8cGhhbmVuaW4gYmVsaXJsaQogICAgICAgIC8vIGJpciDDtnJuZcSfaSBvbG1hZGFuIMOnYcSfcsSxbGFiaWxpci4KICAgICAgICByZXF1aXJlKFNldC5pbnNlcnQoa25vd25WYWx1ZXMsIHZhbHVlKSk7CiAgICB9CiAgICAvLyBCdSBzw7Z6bGXFn21lZGUgYXlyxLFjYSBkaXJla3Qgb2xhcmFrIGtub3duVmFsdWVzLmZsYWdzIGRlxJ9pxZ9rZW5pbmUgZGUgZXJpxZ9lYmlsaXJpei4KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
// Çağrı akıllı sözleşmesinde verilerini tutmak
// için kullanılacak yeni bir struct veri türü tanımlıyoruz.
struct Data {
 mapping(uint \=> bool) flags;
}
library Set {
 // İlk parametrenin "depolama referansı" türünde
 // olduğunu ve bu nedenle çağrının bir parçası
 // olarak içeriğinin değil, yalnızca depolama
 // adresinin iletildiğini unutmayın.
 // Bu, kütüphane fonksiyonlarının özel bir özelliğidir.
 // Fonksiyon, o nesnenin bir yöntemi olarak görülebiliyorsa,
 // ilk parametreyi 'self' olarak adlandırmak deyimseldir.
 function insert(Data storage self, uint value)
 public
 returns (bool)
 {
 if (self.flags\[value\])
 return false; // zaten orada
 self.flags\[value\] \= true;
 return true;
 }
 function remove(Data storage self, uint value)
 public
 returns (bool)
 {
 if (!self.flags\[value\])
 return false; // orada değil
 self.flags\[value\] \= false;
 return true;
 }
 function contains(Data storage self, uint value)
 public
 view
 returns (bool)
 {
 return self.flags\[value\];
 }
}
contract C {
 Data knownValues;
 function register(uint value) public {
 // "Instance" geçerli akıllı sözleşme olacağından,
 // kütüphane fonksiyonları kütüphanenin belirli
 // bir örneği olmadan çağrılabilir.
 require(Set.insert(knownValues, value));
 }
 // Bu sözleşmede ayrıca direkt olarak knownValues.flags değişkenine de erişebiliriz.
}
Elbette kütüphaneleri kullanmak için bu yolu izlemeniz gerekmez: struct veri türleri tanımlamadan da kullanılabilirler. Fonksiyonlar ayrıca herhangi bir depolama referans parametresi olmadan da çalışırlar ve herhangi bir pozisyonda birden fazla depolama referans parametresine sahip olabilirler.
`Set.contains`, `Set.insert` ve `Set.remove` çağrılarının hepsi harici çağrı olarak derlenir (`DELEGATECALL`). Eğer kütüphaneleri kullanacaksanız gerçekten bir harici fonksiyon çağrısı yaptığınızı unutmayın. `msg.sender`, `msg.value` ve `this` çağrı boyunca kendi değerlerini koruyacaktır (Homestead öncesi `CALLCODE` yüzünden `msg.sender` ve `msg.value` değişiyordu).
Aşağıdaki örnek, harici fonksiyon çağrılarının ek yükü olmadan özel türleri uygulamak için [bellekte depolanan türlerin](https://docs.soliditylang.org/tr/latest/types.html#data-location) ve kütüphanelerdeki dahili fonksiyonların nasıl kullanılacağını gösterir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMDsKCnN0cnVjdCBiaWdpbnQgewogICAgdWludFtdIGxpbWJzOwp9CgpsaWJyYXJ5IEJpZ0ludCB7CiAgICBmdW5jdGlvbiBmcm9tVWludCh1aW50IHgpIGludGVybmFsIHB1cmUgcmV0dXJucyAoYmlnaW50IG1lbW9yeSByKSB7CiAgICAgICAgci5saW1icyA9IG5ldyB1aW50W10oMSk7CiAgICAgICAgci5saW1ic1swXSA9IHg7CiAgICB9CgogICAgZnVuY3Rpb24gYWRkKGJpZ2ludCBtZW1vcnkgYSwgYmlnaW50IG1lbW9yeSBiKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKGJpZ2ludCBtZW1vcnkgcikgewogICAgICAgIHIubGltYnMgPSBuZXcgdWludFtdKG1heChhLmxpbWJzLmxlbmd0aCwgYi5saW1icy5sZW5ndGgpKTsKICAgICAgICB1aW50IGNhcnJ5ID0gMDsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCByLmxpbWJzLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICAgIHVpbnQgbGltYkEgPSBsaW1iKGEsIGkpOwogICAgICAgICAgICB1aW50IGxpbWJCID0gbGltYihiLCBpKTsKICAgICAgICAgICAgdW5jaGVja2VkIHsKICAgICAgICAgICAgICAgIHIubGltYnNbaV0gPSBsaW1iQSArIGxpbWJCICsgY2Fycnk7CgogICAgICAgICAgICAgICAgaWYgKGxpbWJBICsgbGltYkIgPCBsaW1iQSB8fCAobGltYkEgKyBsaW1iQiA9PSB0eXBlKHVpbnQpLm1heCAmJiBjYXJyeSA+IDApKQogICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gMTsKICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICBjYXJyeSA9IDA7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKGNhcnJ5ID4gMCkgewogICAgICAgICAgICAvLyDDp29rIGvDtnTDvCwgYmlyIGxpbWIgZWtsZW1lbGl5aXoKICAgICAgICAgICAgdWludFtdIG1lbW9yeSBuZXdMaW1icyA9IG5ldyB1aW50W10oci5saW1icy5sZW5ndGggKyAxKTsKICAgICAgICAgICAgdWludCBpOwogICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgci5saW1icy5sZW5ndGg7ICsraSkKICAgICAgICAgICAgICAgIG5ld0xpbWJzW2ldID0gci5saW1ic1tpXTsKICAgICAgICAgICAgbmV3TGltYnNbaV0gPSBjYXJyeTsKICAgICAgICAgICAgci5saW1icyA9IG5ld0xpbWJzOwogICAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiBsaW1iKGJpZ2ludCBtZW1vcnkgYSwgdWludCBpbmRleCkgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGluZGV4IDwgYS5saW1icy5sZW5ndGggPyBhLmxpbWJzW2luZGV4XSA6IDA7CiAgICB9CgogICAgZnVuY3Rpb24gbWF4KHVpbnQgYSwgdWludCBiKSBwcml2YXRlIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBhID4gYiA/IGEgOiBiOwogICAgfQp9Cgpjb250cmFjdCBDIHsKICAgIHVzaW5nIEJpZ0ludCBmb3IgYmlnaW50OwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgcHVyZSB7CiAgICAgICAgYmlnaW50IG1lbW9yeSB4ID0gQmlnSW50LmZyb21VaW50KDcpOwogICAgICAgIGJpZ2ludCBtZW1vcnkgeSA9IEJpZ0ludC5mcm9tVWludCh0eXBlKHVpbnQpLm1heCk7CiAgICAgICAgYmlnaW50IG1lbW9yeSB6ID0geC5hZGQoeSk7CiAgICAgICAgYXNzZXJ0KHoubGltYigxKSA+IDApOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;
struct bigint {
 uint\[\] limbs;
}
library BigInt {
 function fromUint(uint x) internal pure returns (bigint memory r) {
 r.limbs \= new uint\[\](1);
 r.limbs\[0\] \= x;
 }
 function add(bigint memory a, bigint memory b) internal pure returns (bigint memory r) {
 r.limbs \= new uint\[\](max(a.limbs.length, b.limbs.length));
 uint carry \= 0;
 for (uint i \= 0; i < r.limbs.length; ++i) {
 uint limbA \= limb(a, i);
 uint limbB \= limb(b, i);
 unchecked {
 r.limbs\[i\] \= limbA + limbB + carry;
 if (limbA + limbB < limbA || (limbA + limbB \== type(uint).max && carry \> 0))
 carry \= 1;
 else
 carry \= 0;
 }
 }
 if (carry \> 0) {
 // çok kötü, bir limb eklemeliyiz
 uint\[\] memory newLimbs \= new uint\[\](r.limbs.length + 1);
 uint i;
 for (i \= 0; i < r.limbs.length; ++i)
 newLimbs\[i\] \= r.limbs\[i\];
 newLimbs\[i\] \= carry;
 r.limbs \= newLimbs;
 }
 }
 function limb(bigint memory a, uint index) internal pure returns (uint) {
 return index < a.limbs.length ? a.limbs\[index\] : 0;
 }
 function max(uint a, uint b) private pure returns (uint) {
 return a \> b ? a : b;
 }
}
contract C {
 using BigInt for bigint;
 function f() public pure {
 bigint memory x \= BigInt.fromUint(7);
 bigint memory y \= BigInt.fromUint(type(uint).max);
 bigint memory z \= x.add(y);
 assert(z.limb(1) \> 0);
 }
}
Bir kütüphanenin adresini, kütüphane tipini `address` tipine çevirerek, yani `address(LibraryName)` kullanarak elde etmek mümkündür.
Derleyici kütüphanenin konuşlandırılacağı adresi bilmediğinden, derlenmiş onaltılık kod `__$30bbc0abd4d6364515865950d3e0d10953$__` biçiminde yer tutucular içerecektir. Yer tutucu, tam nitelikli kütüphane adının keccak256 hashinin hex kodlamasının 34 karakterlik bir önekidir; bu, örneğin kütüphane `bigint.sol` isimli bir dosyada ve `libraries/` isimli bir dizinde bulunuyorsa şu şekilde gösterilir `libraries/bigint.sol:BigInt`. Bu tür bayt kodu eksiktir ve dağıtılmamalıdır. Yer tutucuların gerçek adreslerle değiştirilmesi gerekir. Bunu, kütüphane derlenirken bunları derleyiciye ileterek veya önceden derlenmiş bir ikili dosyayı güncellemek için bağlayıcıyı kullanarak yapabilirsiniz. Bağlama için komut satırı derleyicisinin nasıl kullanılacağı hakkında bilgi için [Kütüphane Bağlantıları (Library Linking)](https://docs.soliditylang.org/tr/latest/using-the-compiler.html#library-linking) konusuna bakın.
Akıllı sözleşmelerle kıyaslandığında, kütüphaneler aşağıdaki şekillerde kısıtlanmışlardır:
* durum değişkenleri olamaz
 
* miras veremezler veya alamazlar
 
* Ether kabul edemezler
 
* yok edilemezler
 
(Bunlar ilerleyen zamanlarda kaldırılabilirler.)
### Function Signatures and Selectors in Libraries[](#function-signatures-and-selectors-in-libraries "Permalink to this heading")
Public veya external kütüphane fonksiyonlarına harici çağrılar mümkün olsa da, bu tür çağrılar için çağrı kuralının Solidity’nin içinde olduğu ve normal [contract ABI](https://docs.soliditylang.org/tr/latest/abi-spec.html#abi) için belirtilenle aynı olmadığı kabul edilir. External kütüphane fonksiyonları, örneğin özyinelemeli yapılar ve depolama işaretçileri gibi external kütüphane fonksiyonlarından daha fazla bağımsız değişken türünü destekler. Bu nedenle, 4 baytlık seçiciyi hesaplamak için kullanılan fonksiyon imzaları, bir internal adlandırma şemasının ardından hesaplanır ve ABI akıllı sözleşmesinde desteklenmeyen türdeki bağımsız değişkenler bir dahili kodlama kullanır.
İmzalardaki türler için aşağıdaki tanımlayıcılar kullanılır:
* Değer tipleri, storage olmayan `string` ve storage olmayan `bytes` tipleri akıllı sözleşme ABI’sinde aynı tanımlayıcıları kullanır.
 
* Storage olmayan array tipleri de akıllı sözleşme ABI’sindeki genel görüşü kabul eder, yani dinamik arrayler için `<type>[]` ve fixed-size arrayler için `<type>[M]` kullanılır.
 
* Storage olmayan structlar tam isimleri ile referans edilir, yani `contract C { struct S { ... } }` için `C.S`.
 
* Storage pointer mappingleri de `mapping(<keyType> => <valueType>) storage` kullanır. Burada `<keyType>` ve `<valueType>` sırasıyla mappingdeki anahtar ve değer tipleridir.
 
* Diğer storage pointer tipleri de kendi storage olmayan tiplerinin tanımlayıcılarını kullanırlar, ama bir boşluk ile `storage` eklenmiş halleri ile.
 
Argüman encode’lama da sıradan akıllı sözleşme ABI’si gibidir, storage pointerları hariç, işaret ettikleri storage slotuna atıfta bulunan bir `uint256` değeri olarak kodlanmıştır.
Akıllı sözleşme ABI’sine benzer bir şekilde, selector, imzanın Keccak256-hashinin ilk dört baytından oluşur. Değeri, `.selector` üyesi kullanılarak Solidity’den şu şekilde elde edilebilir:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjE0IDwwLjkuMDsKCmxpYnJhcnkgTCB7CiAgICBmdW5jdGlvbiBmKHVpbnQyNTYpIGV4dGVybmFsIHt9Cn0KCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZygpIHB1YmxpYyBwdXJlIHJldHVybnMgKGJ5dGVzNCkgewogICAgICAgIHJldHVybiBMLmYuc2VsZWN0b3I7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.14 <0.9.0;
library L {
 function f(uint256) external {}
}
contract C {
 function g() public pure returns (bytes4) {
 return L.f.selector;
 }
}
### Kütüphaneler İçin Çağrı Koruması[](#kutuphaneler-icin-cagri-korumasi "Permalink to this heading")
Girişte belirtildiği gibi, bir kütüphanenin kodu `DELEGATECALL` veya `CALLCODE` yerine bir `CALL` kullanılarak yürütülürse, bir `view` veya `pure` fonksiyon çağrılmadığı sürece geri dönecektir.
EVM, bir akıllı sözleşmenin `CALL` kullanılarak çağrılıp çağrılmadığını tespit etmek için doğrudan bir yol sağlamaz, ancak bir sözleşme, “nerede” çalıştığını bulmak için `ADDRESS` işlem kodunu kullanabilir. Oluşturulan kod, arama modunu belirlemek için bu adresi yapım sırasında kullanılan adresle karşılaştırır.
Daha spesifik olarak, bir kütüphanenin çalışma zamanı kodu her zaman derleme zamanında 20 bayt sıfır olan bir push komutuyla başlar. Dağıtım kodu çalıştığında, bu sabit bellekte geçerli adresle değiştirilir ve bu değiştirilmiş kod sözleşmede saklanır. Çalışma zamanında, bu, dağıtım zamanı adresinin yığına gönderilecek ilk sabit olmasına neden olur ve dağıtıcı kodu, herhangi bir görünüm olmayan ve saf olmayan işlev için geçerli adresi bu sabitle karşılaştırır.
Bu, bir kitaplık için zincirde depolanan gerçek kodun derleyici tarafından bildirilen koddan farklıdır. `deployedBytecode`.
## Using For[](#using-for "Permalink to this heading")
`using A for B;` yönergesi, (`A`) fonksiyonlarını herhangi bir türe (`B`) üye fonksiyonlar olarak eklemek için kullanılabilir. Bu fonksiyonlar, çağrıldıkları nesneyi ilk parametreleri olarak alırlar (Python’daki `self` değişkeni gibi).
Dosya seviyesinde veya bir akıllı sözleşme içerisinde, akıllı sözleşme seviyesinde, geçerlidir.
İlk kısım, `A`, aşağıdakilerden biri olabilir:
* dosya seviyesindeki fonksiyonların bir listesi veya kütüphane fonksiyonları (`using {f, g, h, L.t} for uint;`) - sadece o fonksiyonlar eklenecektir.
 
* kütüphanenin adı (`using L for uint;`) - bütün fonksiyonlar (public ve internallerin hepsi) tipe eklenir.
 
Dosya seviyesinde, ikinci kısım, `B`, açık bir tip olmalıdır (veri konumu belirtici olmadan). Akıllı sözleşmenin içerisinde, ayrıca şu ifadeyi de kullanabilirsiniz `using L for *;`, böylece `L` kütüphanesinin bütün fonksiyonları _bütün_ tiplere eklenmiş olur.
Bir kütüphane belirtirseniz, kütüphanedeki tüm fonksiyonlar, ilk parametrenin türü nesnenin türüyle eşleşmese bile eklenir. Fonksiyonun çağrıldığı noktada tip kontrol edilir ve fonksiyon aşırı yük çözünürlüğü gerçekleştirilir.
Eğer bir fonksiyon listesi kullanırsanız (`using {f, g, h, L.t} for uint;`), ardından gelen tip (`uint`) o kütüphanedeki bütün fonksiyonların ilk parametrelerine gizlice dönüştürülebilir olmalıdır. Bu kontrol, fonksiyonların hiçbiri çağrılmasa bile gerçekleştirilir.
`using A for B;` direktifi, tüm fonksiyonları dahil olmak üzere yalnızca mevcut kapsamda (sözleşme veya mevcut modül/kaynak birim) etkindir ve kullanıldığı sözleşme veya modül dışında hiçbir etkisi yoktur.
Yönerge dosya düzeyinde kullanıldığında ve aynı dosyada dosya düzeyinde tanımlanmış kullanıcı tanımlı bir türe uygulandığında, sonuna `global` sözcüğü eklenebilir. Bu, yalnızca using ifadesinin kapsamında değil, türün kullanılabilir olduğu her yerde (diğer dosyalar dahil) işlevlerin türe eklenmesi etkisine sahip olacaktır.
[Kütüphaneler](#libraries) bölümünde yazdığımız bir örneği dosya seviyesindeki fonksiyonlarla yeniden yazalım:
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTM7CgpzdHJ1Y3QgRGF0YSB7IG1hcHBpbmcodWludCA9PiBib29sKSBmbGFnczsgfQovLyDFnmltZGkgw7ZybmXEn2UgZm9ua3NpeW9ubGFyxLEgZWtsaXlvcnV6LgovLyBFa2xlbmVuIGZvbmtzaXlvbmxhciBtb2TDvGwgYm95dW5hIGt1bGxhbsSxbGFiaWxpci4KLy8gRcSfZXIgbW9kw7xsw7wgYmHFn2thIGJpciBkb3N5YWRhbiBla2xlcnNlbml6Ci8vIHVzaW5nIHnDtm5lcmdlc2luaSBvcmFkYSB5ZW5pZGVuIGt1bGxhbm1hbMSxc8SxbsSxejoKLy8gICBpbXBvcnQgImZsYWdzLnNvbCIgYXMgRmxhZ3M7Ci8vICAgdXNpbmcge0ZsYWdzLmluc2VydCwgRmxhZ3MucmVtb3ZlLCBGbGFncy5jb250YWluc30KLy8gICAgIGZvciBGbGFncy5EYXRhOwp1c2luZyB7aW5zZXJ0LCByZW1vdmUsIGNvbnRhaW5zfSBmb3IgRGF0YTsKCmZ1bmN0aW9uIGluc2VydChEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgIHJldHVybnMgKGJvb2wpCnsKICAgIGlmIChzZWxmLmZsYWdzW3ZhbHVlXSkKICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGFscmVhZHkgdGhlcmUKICAgIHNlbGYuZmxhZ3NbdmFsdWVdID0gdHJ1ZTsKICAgIHJldHVybiB0cnVlOwp9CgpmdW5jdGlvbiByZW1vdmUoRGF0YSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICByZXR1cm5zIChib29sKQp7CiAgICBpZiAoIXNlbGYuZmxhZ3NbdmFsdWVdKQogICAgICAgIHJldHVybiBmYWxzZTsgLy8gbm90IHRoZXJlCiAgICBzZWxmLmZsYWdzW3ZhbHVlXSA9IGZhbHNlOwogICAgcmV0dXJuIHRydWU7Cn0KCmZ1bmN0aW9uIGNvbnRhaW5zKERhdGEgc3RvcmFnZSBzZWxmLCB1aW50IHZhbHVlKQogICAgdmlldwogICAgcmV0dXJucyAoYm9vbCkKewogICAgcmV0dXJuIHNlbGYuZmxhZ3NbdmFsdWVdOwp9CgoKY29udHJhY3QgQyB7CiAgICBEYXRhIGtub3duVmFsdWVzOwoKICAgIGZ1bmN0aW9uIHJlZ2lzdGVyKHVpbnQgdmFsdWUpIHB1YmxpYyB7CiAgICAgICAgLy8gQnVyYWRhLCBEYXRhIHTDvHLDvG5kZWtpIHTDvG0gZGXEn2nFn2tlbmxlcmluIGthcsWfxLFsxLFrCiAgICAgICAgLy8gZ2VsZW4gw7x5ZSBpxZ9sZXZsZXJpIHZhcmTEsXIuIEHFn2HEn8SxZGFraSBpxZ9sZXYgw6dhxJ9yxLFzxLEsCiAgICAgICAgLy8gYFNldC5pbnNlcnQoa25vd25WYWx1ZXMsIHZhbHVlKWAgaWxlIGF5bsSxZMSxci4KICAgICAgICByZXF1aXJlKGtub3duVmFsdWVzLmluc2VydCh2YWx1ZSkpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.13;
struct Data { mapping(uint \=> bool) flags; }
// Şimdi örneğe fonksiyonları ekliyoruz.
// Eklenen fonksiyonlar modül boyuna kullanılabilir.
// Eğer modülü başka bir dosyadan eklerseniz
// using yönergesini orada yeniden kullanmalısınız:
// import "flags.sol" as Flags;
// using {Flags.insert, Flags.remove, Flags.contains}
// for Flags.Data;
using {insert, remove, contains} for Data;
function insert(Data storage self, uint value)
 returns (bool)
{
 if (self.flags\[value\])
 return false; // already there
 self.flags\[value\] \= true;
 return true;
}
function remove(Data storage self, uint value)
 returns (bool)
{
 if (!self.flags\[value\])
 return false; // not there
 self.flags\[value\] \= false;
 return true;
}
function contains(Data storage self, uint value)
 view
 returns (bool)
{
 return self.flags\[value\];
}
contract C {
 Data knownValues;
 function register(uint value) public {
 // Burada, Data türündeki tüm değişkenlerin karşılık
 // gelen üye işlevleri vardır. Aşağıdaki işlev çağrısı,
 // \`Set.insert(knownValues, value)\` ile aynıdır.
 require(knownValues.insert(value));
 }
}
Yerleşik türleri bu şekilde genişletmek de mümkündür. Bu örnekte bir kütüphane kullanacağız.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.15&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTM7CgpsaWJyYXJ5IFNlYXJjaCB7CiAgICBmdW5jdGlvbiBpbmRleE9mKHVpbnRbXSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICAgICAgcHVibGljCiAgICAgICAgdmlldwogICAgICAgIHJldHVybnMgKHVpbnQpCiAgICB7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykKICAgICAgICAgICAgaWYgKHNlbGZbaV0gPT0gdmFsdWUpIHJldHVybiBpOwogICAgICAgIHJldHVybiB0eXBlKHVpbnQpLm1heDsKICAgIH0KfQp1c2luZyBTZWFyY2ggZm9yIHVpbnRbXTsKCmNvbnRyYWN0IEMgewogICAgdWludFtdIGRhdGE7CgogICAgZnVuY3Rpb24gYXBwZW5kKHVpbnQgdmFsdWUpIHB1YmxpYyB7CiAgICAgICAgZGF0YS5wdXNoKHZhbHVlKTsKICAgIH0KCiAgICBmdW5jdGlvbiByZXBsYWNlKHVpbnQgZnJvbSwgdWludCB0bykgcHVibGljIHsKICAgICAgICAvLyBCdSwga8O8dMO8cGhhbmUgacWfbGV2IMOnYcSfcsSxc8SxbsSxIGdlcsOnZWtsZcWfdGlyaXIKICAgICAgICB1aW50IGluZGV4ID0gZGF0YS5pbmRleE9mKGZyb20pOwogICAgICAgIGlmIChpbmRleCA9PSB0eXBlKHVpbnQpLm1heCkKICAgICAgICAgICAgZGF0YS5wdXNoKHRvKTsKICAgICAgICBlbHNlCiAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gdG87CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.13;
library Search {
 function indexOf(uint\[\] storage self, uint value)
 public
 view
 returns (uint)
 {
 for (uint i \= 0; i < self.length; i++)
 if (self\[i\] \== value) return i;
 return type(uint).max;
 }
}
using Search for uint\[\];
contract C {
 uint\[\] data;
 function append(uint value) public {
 data.push(value);
 }
 function replace(uint from, uint to) public {
 // Bu, kütüphane işlev çağrısını gerçekleştirir
 uint index \= data.indexOf(from);
 if (index \== type(uint).max)
 data.push(to);
 else
 data\[index\] \= to;
 }
}
Tüm harici kütüphane çağrılarının gerçek EVM fonksiyon çağrıları olduğunu unutmayın. Bu, bellek veya değer türlerini geçerseniz, `self` değişken durumunda bile bir kopyanın gerçekleştirileceği anlamına gelir. Kopyalama yapılmayacak tek durum, depolama referans değişkenlerinin kullanıldığı veya dahili kütüphane fonksiyonlarının çağrıldığı durumlardır.

# [Contribution — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/contributing.html) 
 _https://docs.soliditylang.org/fr/latest/contributing.html_

L’aide est toujours la bienvenue et il existe de nombreuses possibilités de contribuer à Solidity.
En particulier, nous apprécions le soutien dans les domaines suivants :
* Signaler les problèmes.
 
* Corriger et répondre aux problèmes de [Solidity’s GitHub issues.](https://github.com/ethereum/solidity/issues), en particulier ceux marqués comme [« good first issue »](https://github.com/ethereum/solidity/labels/good%20first%20issue) qui sont destinés à servir de problèmes d’introduction pour les contributeurs externes.
 
* Améliorer la documentation.
 
* Traduire la documentation dans plus de langues.
 
* Répondre aux questions des autres utilisateurs sur [StackExchange](https://ethereum.stackexchange.com/) et le [Solidity Gitter Chat](https://gitter.im/ethereum/solidity).
 
* S’impliquer dans le processus de conception du langage en proposant des changements de langage ou de nouvelles fonctionnalités sur le forum [Solidity](https://forum.soliditylang.org/) et en fournissant des commentaires.
 
Pour commencer, vous pouvez essayer [Construire à partir de la source](https://docs.soliditylang.org/fr/latest/installing-solidity.html#building-from-source) afin de vous familiariser avec les composants de Solidity et le processus de construction. En outre, il peut être utile de vous familiariser avec l’écriture de contrats intelligents dans Solidity.
Veuillez noter que ce projet est publié avec un [Code de conduite du contributeur](https://raw.githubusercontent.com/ethereum/solidity/develop/CODE_OF_CONDUCT.md). En participant à ce projet - dans les problèmes, les demandes de pull, ou les canaux Gitter - vous acceptez de respecter ses termes.
## Appels de l’équipe[](#appels-de-l-equipe "Lien permanent vers cette rubrique")
Si vous avez des problèmes ou des demandes de pull à discuter, ou si vous êtes intéressé à entendre ce sur quoi l’équipe et les contributeurs travaillent, vous pouvez rejoindre nos appels d’équipe publics :
* Les lundis à 15h CET/CEST.
 
* Les mercredis à 14h CET/CEST.
 
Les deux appels ont lieu sur [Jitsi](https://meet.ethereum.org/solidity).
## Flux de travail pour les demandes de Pull[](#flux-de-travail-pour-les-demandes-de-pull "Lien permanent vers cette rubrique")
Pour contribuer, merci de vous détacher de la branche `develop` et d’y faire vos modifications ici. Vos messages de commit doivent détailler _pourquoi_ vous avez fait votre changement en plus de _ce que vous avez fait (sauf si c’est un changement minuscule)_.
Si vous avez besoin de retirer des changements de la branche `develop` après avoir fait votre fork (par (par exemple, pour résoudre des conflits de fusion potentiels), évitez d’utiliser `git merge` et à la place, `git rebase` votre branche. Cela nous aidera à revoir votre changement plus facilement.
De plus, si vous écrivez une nouvelle fonctionnalité, veuillez vous assurer que vous ajoutez des tests appropriés sous `test/` (voir ci-dessous).
Cependant, si vous effectuez un changement plus important, veuillez consulter le [canal Gitter du développement de Solidity](https://gitter.im/ethereum/solidity-dev) (différent de celui mentionné ci-dessus, celui-ci est axé sur le développement du compilateur et du langage plutôt que sur l’utilisation du langage) en premier lieu.
Les nouvelles fonctionnalités et les corrections de bogues doivent être ajoutées au fichier `Changelog.md` : veuillez suivre le style des entrées précédentes, le cas échéant.
Enfin, veillez à respecter le [\`\`](#id1)style de codage <[https://github.com/ethereum/solidity/blob/develop/CODING\_STYLE.md](https://github.com/ethereum/solidity/blob/develop/CODING_STYLE.md)\>\`\_ pour ce projet. De plus, même si nous effectuons des tests CI, veuillez tester votre code et assurez-vous qu’il se construit localement avant de soumettre une demande de pull.
Merci pour votre aide !
## Exécution des tests du compilateur[](#execution-des-tests-du-compilateur "Lien permanent vers cette rubrique")
### Conditions préalables[](#conditions-prealables "Lien permanent vers cette rubrique")
Pour exécuter tous les tests du compilateur, vous pouvez vouloir installer facultativement quelques dépendances ([evmone](https://github.com/ethereum/evmone/releases), [libz3](https://github.com/Z3Prover/z3), et [libhera](https://github.com/ewasm/hera)).
Sur macOS, certains des scripts de test attendent que GNU coreutils soit installé. Ceci peut être accompli plus facilement en utilisant Homebrew : `brew install coreutils`.
### Exécution des tests[](#execution-des-tests "Lien permanent vers cette rubrique")
Solidity inclut différents types de tests, la plupart d’entre eux étant regroupés dans l’application `Boost C++ Test Framework`. [Boost C++ Test Framework](https://www.boost.org/doc/libs/release/libs/test/doc/html/index.html) application `soltest`. Exécuter `build/test/soltest` ou son wrapper `scripts/soltest.sh` est suffisant pour la plupart des modifications.
Le script ./scripts/tests.sh\` exécute automatiquement la plupart des tests Solidity, y compris ceux inclus dans le [Boost C++ Test Framework](https://www.boost.org/doc/libs/release/libs/test/doc/html/index.html) l’application `soltest` (ou son enveloppe `scripts/soltest.sh`), ainsi que les tests en ligne de commande et les tests de compilation.
Le système de test essaie automatiquement de découvrir l’emplacement du [evmone](https://github.com/ethereum/evmone/releases) pour exécuter les tests sémantiques.
La bibliothèque `evmone` doit être située dans le répertoire `deps` ou `deps/lib` relativement au répertoire de travail actuel, à son parent ou au parent de son parent. Alternativement, un emplacement explicite pour l’objet partagé `evmone` peut être spécifié via la variable d’environnement `ETH_EVMONE`.
`evmone` est principalement nécessaire pour l’exécution de tests sémantiques et de gaz. Si vous ne l’avez pas installé, vous pouvez ignorer ces tests en passant l’option `--no-semantic-tests` à `scripts/soltest.sh`.
L’exécution des tests Ewasm est désactivée par défaut et peut être explicitement activée via `./scripts/soltest.sh --ewasm` et nécessite que [hera](https://github.com/ewasm/hera) soit trouvé par `soltest.sh`. Pour être trouvé par `soltest`. Le mécanisme de localisation de la bibliothèque `hera` est le même que pour `evmone`, sauf que la variable permettant de spécifier un emplacement explicite est appelée `ETH_HERA`.
Les bibliothèques `evmone` et ```hera`' doivent toutes deux se terminer par l'extension de fichier avec l'extension ``.so``` sur Linux, `.dll` sur les systèmes Windows et `.dylib` sur macOS.
Pour exécuter les tests SMT, la bibliothèque `libz3` doit être installée et localisable par `cmake` pendant l’étape de configuration du compilateur.
Si la bibliothèque `libz3` n’est pas installée sur votre système, vous devriez désactiver les tests SMT en exportant `SMT_FLAGS=--no-smt` avant de lancer `./scripts/tests.sh` ou de en exécutant ./scripts/soltest.sh –no-smt\`. Ces tests sont `libsolidity/smtCheckerTests` et `libsolidity/smtCheckerTestsJSON`.
Note
Pour obtenir une liste de tous les tests unitaires exécutés par Soltest, exécutez `./build/test/soltest --list_content=HRF`.
Pour obtenir des résultats plus rapides, vous pouvez exécuter un sous-ensemble de tests ou des tests spécifiques.
Pour exécuter un sous-ensemble de tests, vous pouvez utiliser des filtres : `./scripts/soltest.sh -t TestSuite/TestName`, où `TestName` peut être un joker `*`.
Ou, par exemple, pour exécuter tous les tests pour le désambiguïsateur yul : `./scripts/soltest.sh -t "yulOptimizerTests/disambiguator/*" --no-smt`.
`./build/test/soltest --help` a une aide étendue sur toutes les options disponibles.
Voir en particulier :
* [show\_progress (-p)](https://www.boost.org/doc/libs/release/libs/test/doc/html/boost_test/utf_reference/rt_param_reference/show_progress.html) pour montrer l’achèvement du test,
 
* [run\_test (-t)](https://www.boost.org/doc/libs/release/libs/test/doc/html/boost_test/utf_reference/rt_param_reference/run_test.html) pour exécuter des cas de tests spécifiques, et
 
* [report-level (-r)](https://www.boost.org/doc/libs/release/libs/test/doc/html/boost_test/utf_reference/rt_param_reference/report_level.html) donner un rapport plus détaillé.
 
Note
Ceux qui travaillent dans un environnement Windows et qui veulent exécuter les jeux de base ci-dessus sans libz3. En utilisant Git Bash, vous utilisez : `./build/test/Release/soltest.exe -- --no-smt`. Si vous exécutez ceci dans une Invite de Commande simple, utilisez : `./build/test/Release/soltest.exe -- --no-smt`.
Si vous voulez déboguer à l’aide de GDB, assurez-vous que vous construisez différemment de ce qui est « habituel ». Par exemple, vous pouvez exécuter la commande suivante dans votre dossier `build` : .. code-block:: bash
> cmake -DCMAKE\_BUILD\_TYPE=Debug .. make
Cela crée des symboles de sorte que lorsque vous déboguez un test en utilisant le drapeau `--debug`, vous avez accès aux fonctions et aux variables avec lesquelles vous pouvez casser ou imprimer.
Le CI exécute des tests supplémentaires (y compris `solc-js` et le test de frameworks Solidity tiers) qui nécessitent la compilation de la cible Emscripten.
### Écrire et exécuter des tests de syntaxe[](#ecrire-et-executer-des-tests-de-syntaxe "Lien permanent vers cette rubrique")
Les tests de syntaxe vérifient que le compilateur génère les messages d’erreur corrects pour le code invalide et accepte correctement le code valide. Ils sont stockés dans des fichiers individuels à l’intérieur du dossier `tests/libsolidity/syntaxTests`. Ces fichiers doivent contenir des annotations, indiquant le(s) résultat(s) attendu(s) du test respectif. La suite de tests les compile et les vérifie par rapport aux attentes données.
Par exemple : `./test/libsolidity/syntaxTests/double_stateVariable_declaration.sol`
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Y29udHJhY3QgdGVzdCB7CiAgICB1aW50MjU2IHZhcmlhYmxlOwogICAgdWludDEyOCB2YXJpYWJsZTsKfQovLyAtLS0tCi8vIERlY2xhcmF0aW9uRXJyb3I6ICgzNi01Mik6IElkZW50aWZpYW50IGTDqWrDoCBkw6ljbGFyw6ku)
contract test {
 uint256 variable;
 uint128 variable;
}
// ----
// DeclarationError: (36-52): Identifiant déjà déclaré.
Un test de syntaxe doit contenir au moins le contrat testé lui-même, suivi du séparateur `// ----`. Les commentaires qui suivent le séparateur sont utilisés pour décrire les erreurs ou les avertissements attendus du compilateur. La fourchette de numéros indique l’emplacement dans le code source où l’erreur s’est produite. Si vous voulez que le contrat compile sans aucune erreur ou avertissement, vous pouvez omettre le séparateur et les commentaires qui le suivent.
Dans l’exemple ci-dessus, la variable d’état `variable` a été déclarée deux fois, ce qui n’est pas autorisé. Il en résulte un `DeclarationError` indiquant que l’identifiant a déjà été déclaré.
L’outil `isoltest` est utilisé pour ces tests et vous pouvez le trouver sous `./build/test/tools/`. C’est un outil interactif qui permet d’éditer les contrats défaillants en utilisant votre éditeur de texte préféré. Essayons de casser ce test en supprimant la deuxième déclaration de `variable` :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Y29udHJhY3QgdGVzdCB7CiAgICB1aW50MjU2IHZhcmlhYmxlOwp9Ci8vIC0tLS0KLy8gRGVjbGFyYXRpb25FcnJvcjogKDM2LTUyKTogSWRlbnRpZmlhbnQgZMOpasOgIGTDqWNsYXLDqS4=)
contract test {
 uint256 variable;
}
// ----
// DeclarationError: (36-52): Identifiant déjà déclaré.
Lancer `./build/test/tools/isoltest` à nouveau entraîne un échec du test :
syntaxTests/double\_stateVariable\_declaration.sol: FAIL
 Contract:
 contract test {
 uint256 variable;
 }
 Expected result:
 DeclarationError: (36-52): Identifiant déjà déclaré.
 Obtained result:
 Success
`isoltest` imprime le résultat attendu à côté du résultat obtenu, et fournit aussi un moyen de modifier, de mettre à jour ou d’ignorer le fichier de contrat actuel, ou de quitter l’application.
Il offre plusieurs options pour les tests qui échouent :
* `edit` : `isoltest` essaie d’ouvrir le contrat dans un éditeur pour que vous puissiez l’ajuster. Il utilise soit l’éditeur donné sur la ligne de commande (comme `isoltest --editor /path/to/editor`), dans la variable d’environnement `EDITOR` ou juste `/usr/bin/editor` (dans cet ordre).
 
* `update` : Met à jour les attentes pour le contrat en cours de test. Cela met à jour les annotations en supprimant les attentes non satisfaites et en ajoutant les attentes manquantes. Le test est ensuite exécuté à nouveau.
 
* `skip` : Ignore l’exécution de ce test particulier.
 
* `quit'' : Quitte ``isoltest`.
 
Toutes ces options s’appliquent au contrat en cours, à l’exception de `quit` qui arrête l’ensemble du processus de test.
La mise à jour automatique du test ci-dessus le change en
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Y29udHJhY3QgdGVzdCB7CiAgICB1aW50MjU2IHZhcmlhYmxlOwp9Ci8vIC0tLS0=)
contract test {
 uint256 variable;
}
// ----
et relancez le test. Il passe à nouveau :
Ré-exécution du cas de test...
syntaxTests/double\_stateVariable\_declaration.sol: OK
Note
Choisissez un nom pour le fichier du contrat qui explique ce qu’il teste, par exemple « double\_variable\_declaration.sol ». Ne mettez pas plus d’un contrat dans un seul fichier, sauf si vous testez l’héritage ou les appels croisés de contrats. Chaque fichier doit tester un aspect de votre nouvelle fonctionnalité.
## Exécution du Fuzzer via AFL[](#execution-du-fuzzer-via-afl "Lien permanent vers cette rubrique")
Le fuzzing est une technique qui consiste à exécuter des programmes sur des entrées plus ou moins aléatoires afin de trouver des états d’exécution exceptionnels (défauts de segmentation, exceptions, etc.). Les fuzzers modernes sont intelligents et effectuent une recherche dirigée à l’intérieur de l’entrée. Nous avons un binaire spécialisé appelé `solfuzzer` qui prend le code source comme entrée et échoue chaque fois qu’il rencontre une erreur interne du compilateur, un défaut de segmentation ou similaire. mais n’échoue pas si, par exemple, le code contient une erreur. De cette façon, les outils de fuzzing peuvent trouver des problèmes internes dans le compilateur.
Nous utilisons principalement [AFL](https://lcamtuf.coredump.cx/afl/) pour le fuzzing. Vous devez télécharger et installer les paquets AFL depuis vos dépôts (afl, afl-clang) ou les construire manuellement. Ensuite, construisez Solidity (ou juste le binaire `solfuzzer`) avec AFL comme compilateur :
cd build
＃ if needed
make clean
cmake .. -DCMAKE\_C\_COMPILER\=path/to/afl-gcc -DCMAKE\_CXX\_COMPILER\=path/to/afl-g++
make solfuzzer
À ce stade, vous devriez pouvoir voir un message similaire à celui qui suit :
Scanning dependencies of target solfuzzer
\[ 98%\] Building CXX object test/tools/CMakeFiles/solfuzzer.dir/fuzzer.cpp.o
afl-cc 2.52b by <lcamtuf@google.com>
afl-as 2.52b by <lcamtuf@google.com>
\[+\] Instrumented 1949 locations (64-bit, non-hardened mode, ratio 100%).
\[100%\] Linking CXX executable solfuzzer
Si les messages d’instrumentation n’apparaissent pas, essayez de changer les drapeaux cmake pointant vers les binaires clang de l’AFL :
＃ si l'échec précédent
make clean
cmake .. -DCMAKE_C_COMPILER=path/to/afl-clang -DCMAKE_CXX_COMPILER=path/to/afl-clang++
make solfuzzer
Sinon, lors de l’exécution, le fuzzer s’arrête avec une erreur disant que le binaire n’est pas instrumenté :
afl-fuzz 2.52b by <lcamtuf@google.com>
... (truncated messages)
\[\*\] Validating target binary...
\[-\] Looks like the target binary is not instrumented! The fuzzer depends on
 compile-time instrumentation to isolate interesting test cases while
 mutating the input data. For more information, and for tips on how to
 instrument binaries, please see /usr/share/doc/afl-doc/docs/README.
 When source code is not available, you may be able to leverage QEMU
 mode support. Consult the README for tips on how to enable this.
 (It is also possible to use afl-fuzz as a traditional, "dumb" fuzzer.
 For that, you can use the -n option - but expect much worse results.)
\[-\] PROGRAM ABORT : No instrumentation detected
 Location : check\_binary(), afl-fuzz.c:6920
Ensuite, vous avez besoin de quelques fichiers sources d’exemple. Cela permet au fuzzer de trouver des erreurs plus facilement. Vous pouvez soit copier certains fichiers des tests de syntaxe, soit extraire des fichiers de test de la documentation ou des autres tests :
mkdir /tmp/test\_cases
cd /tmp/test\_cases
＃ extract from tests:
path/to/solidity/scripts/isolate\_tests.py path/to/solidity/test/libsolidity/SolidityEndToEndTest.cpp
＃ extract from documentation:
path/to/solidity/scripts/isolate\_tests.py path/to/solidity/docs
La documentation de l’AFL indique que le corpus (les fichiers d’entrée initiaux) ne doit pas être trop volumineux. Les fichiers eux-mêmes ne devraient pas être plus grands que 1 kB et il devrait y avoir au maximum un fichier d’entrée par fonctionnalité, donc mieux vaut commencer avec un petit nombre de fichiers. Il existe également un outil appelé `afl-cmin` qui peut couper les fichiers d’entrée qui ont pour résultat un comportement similaire du binaire.
Maintenant, lancez le fuzzer (le `-m` étend la taille de la mémoire à 60 Mo) :
afl-fuzz -m 60 -i /tmp/test\_cases -o /tmp/fuzzer\_reports -- /path/to/solfuzzer
Le fuzzer crée des fichiers sources qui conduisent à des échecs dans `/tmp/fuzzer_reports`. Il trouve souvent de nombreux fichiers sources similaires qui produisent la même erreur. Vous pouvez utiliser l’outil `scripts/uniqueErrors.sh` pour filtrer les erreurs uniques.
## Moustaches[](#moustaches "Lien permanent vers cette rubrique")
_Whiskers_ est un système de modélisation de chaînes de caractères similaire à [Mustache](https://mustache.github.io/). Il est utilisé par le compilateur à divers endroits pour faciliter la lisibilité, et donc la maintenabilité et la vérifiabilité, du code.
La syntaxe présente une différence par rapport à Mustache. Les marqueurs de template {{\` et `}}` sont remplacés par `<` et `>` afin de faciliter l’analyse et d’éviter les conflits avec yul\`. (Les symboles <\` et \>\` sont invalides dans l’assemblage en ligne, tandis que `{` et `}` sont utilisés pour délimiter les blocs). Une autre limitation est que les listes ne sont résolues qu’à une seule profondeur et qu’elles ne sont pas récursives. Cela peut changer dans le futur.
Une spécification approximative est la suivante :
Toute occurrence de `<name>` est remplacée par la valeur de la variable fournie `name` sans aucun échappement et sans remplacement itératif. Une zone peut être délimitée par ```<#name>...</name>`. Elle est remplacée par autant de concaténations de son contenu qu'il y avait d'ensembles de variables fournis au système de modèles, en remplaçant chaque fois les éléments ``<inner>``` par leur valeur respective. Les variables de haut niveau peuvent également être utilisées à l’intérieur de ces zones.
Il existe également des conditionnels de la forme `<?name>...<!name>...</name>`, où les remplacements de modèles se poursuivent récursivement dans le premier ou le second segment, en fonction de la valeur du paramètre booléen `name`. Si ```<?+name>...<!+name>...</+name>` est utilisé, alors la vérification consiste à savoir si le paramètre chaîne de caractères ``name``` est non vide.
## Guide de style de la documentation[](#guide-de-style-de-la-documentation "Lien permanent vers cette rubrique")
Dans la section suivante, vous trouverez des recommandations de style spécifiquement axées sur la documentation des contributions à Solidity.
### Langue anglaise[](#langue-anglaise "Lien permanent vers cette rubrique")
Utilisez l’anglais, avec une préférence pour l’orthographe anglaise britannique, sauf si vous utilisez des noms de projets ou de marques. Essayez de réduire l’utilisation de l’argot et les références locales, en rendant votre langage aussi clair que possible pour tous les lecteurs. Vous trouverez ci-dessous quelques références pour vous aider :
* [L’anglais technique simplifié](https://en.wikipedia.org/wiki/Simplified_Technical_English).
 
* [Anglais international](https://en.wikipedia.org/wiki/International_English)
 
* [L’orthographe de l’anglais britannique](https://en.oxforddictionaries.com/spelling/british-and-spelling)
 
Note
Bien que la documentation officielle de Solidity soit écrite en anglais, il existe des traductions contribuées par la communauté dans d’autres langues. dans d’autres langues sont disponibles. Veuillez vous référer au [guide de traduction](https://github.com/solidity-docs/translation-guide) pour savoir comment contribuer aux traductions de la communauté.
### Cas de titre pour les en-têtes[](#cas-de-titre-pour-les-en-tetes "Lien permanent vers cette rubrique")
Utilisez la casse des titres <[https://titlecase.com](https://titlecase.com/)\>\`\_ pour les titres. Cela signifie qu’il faut mettre en majuscule tous les mots principaux dans titres, mais pas les articles, les conjonctions et les prépositions, sauf s’ils commencent le titre.
Par exemple, les exemples suivants sont tous corrects :
* Title Case for Headings.
 
* Pour les titres, utilisez la casse du titre.
 
* Noms de variables locales et d’État.
 
* Ordre de mise en page.
 
### Développer les contractions[](#developper-les-contractions "Lien permanent vers cette rubrique")
Utilisez des contractions développées pour les mots, par exemple :
* « Do not » au lieu de « Don’t ».
 
* Can not » au lieu de « Can’t ».
 
### Voix active et passive[](#voix-active-et-passive "Lien permanent vers cette rubrique")
La voix active est généralement recommandée pour la documentation de type tutoriel car elle car elle aide le lecteur à comprendre qui ou quoi effectue une tâche. Cependant, comme la documentation de Solidity est un mélange de tutoriels et de contenu de référence, la voix passive est parfois plus appropriée.
En résumé :
* Utilisez la voix passive pour les références techniques, par exemple la définition du langage et les éléments internes de la VM Ethereum.
 
* Utilisez la voix active pour décrire des recommandations sur la façon d’appliquer un aspect de Solidity.
 
Par exemple, le texte ci-dessous est à la voix passive car il spécifie un aspect de Solidity :
> Les fonctions peuvent être déclarées « pures », auquel cas elles promettent de ne pas lire ou de modifier l’état.
Par exemple, le texte ci-dessous est à la voix active car il traite d’une application de Solidity :
> Lorsque vous invoquez le compilateur, vous pouvez spécifier comment découvrir le premier élément d’un chemin, ainsi que les remappages de préfixes de chemin.
### Termes courants[](#termes-courants "Lien permanent vers cette rubrique")
* « Paramètres de fonction » et « variables de retour », et non pas paramètres d’entrée et de sortie.
 
### Exemples de code[](#exemples-de-code "Lien permanent vers cette rubrique")
Un processus CI teste tous les exemples de code formatés en blocs de code qui commencent par  » pragma solidity « ,  » contrat « ,  » bibliothèque  » ou  » interface « . ou  » interface  » en utilisant le script  » ./test/cmdlineTests.sh  » lorsque vous créez un PR. Si vous ajoutez de nouveaux exemples de code, assurez-vous qu’ils fonctionnent et passent les tests avant de créer le PR.
Assurez-vous que tous les exemples de code commencent par une version de `pragma` qui couvre la plus grande partie où le code du contrat est valide. Par exemple, `pragma solidity >=0.4.0 <0.9.0;`.
### Exécution des Tests de Documentation[](#execution-des-tests-de-documentation "Lien permanent vers cette rubrique")
Assurez-vous que vos contributions passent nos tests de documentation en exécutant `./scripts/docs.sh` qui installe les dépendances nécessaires à la documentation et vérifie les problèmes éventuels. Nécessaires à la documentation et vérifie l’absence de problèmes tels que des liens brisés ou des problèmes de syntaxe.
## Conception du langage Solidity[](#conception-du-langage-solidity "Lien permanent vers cette rubrique")
Pour vous impliquer activement dans le processus de conception du langage et partager vos idées concernant l’avenir de Solidity, veuillez rejoindre le [forum Solidity](https://forum.soliditylang.org/).
Le forum Solidity sert de lieu pour proposer et discuter de nouvelles fonctionnalités du langage et de leur mise en œuvre dans les premiers stades de l’idéation ou des modifications de fonctionnalités existantes.
Dès que les propositions deviennent plus tangibles, leur implémentation sera également discutée dans le dépôt [Solidity GitHub](https://github.com/ethereum/solidity) sous la forme de questions.
En plus du forum et des discussions sur les problèmes, nous organisons régulièrement des appels de discussion sur la conception du langage dans lesquels des sujets, questions ou implémentations de fonctionnalités sélectionnés sont débattus en détail. L’invitation à ces appels est partagée via le forum.
Nous partageons également des enquêtes de satisfaction et d’autres contenus pertinents pour la conception des langues sur le forum.
Si vous voulez savoir où en est l’équipe en termes d’implémentation de nouvelles fonctionnalités, vous pouvez suivre le statut de l’implémentation dans le projet [Solidity Github](https://github.com/ethereum/solidity/projects/43). Les questions dans le backlog de conception nécessitent une spécification plus approfondie et seront soit discutées dans un appel de conception de langue ou dans un appel d’équipe régulier. Vous pouvez voir les changements à venir pour la prochaine version de rupture en passant de la branche par défaut (develop) à la [breaking branch](https://github.com/ethereum/solidity/tree/breaking).
Pour les cas particuliers et les questions, vous pouvez nous contacter via le canal [Solidity-dev Gitter](https://gitter.im/ethereum/solidity-dev), un chatroom dédié aux conversations autour du compilateur Solidity et du développement du langage.
Nous sommes heureux d’entendre vos réflexions sur la façon dont nous pouvons améliorer le processus de conception du langage pour qu’il soit encore plus collaboratif et transparent.

# [undefined](undefined) 
 _undefined_

undefined

# [Contributing — Solidity 0.4.26 documentation](https://docs.soliditylang.org/en/v0.4.26/contributing.html) 
 _https://docs.soliditylang.org/en/v0.4.26/contributing.html_

Help is always appreciated!
To get started, you can try [Building from Source](https://docs.soliditylang.org/en/v0.4.26/installing-solidity.html#building-from-source) in order to familiarize yourself with the components of Solidity and the build process. Also, it may be useful to become well-versed at writing smart-contracts in Solidity.
In particular, we need help in the following areas:
* Improving the documentation
* Responding to questions from other users on [StackExchange](https://ethereum.stackexchange.com/) and the [Solidity Gitter](https://gitter.im/ethereum/solidity)
* Fixing and responding to [Solidity’s GitHub issues](https://github.com/ethereum/solidity/issues), especially those tagged as [up-for-grabs](https://github.com/ethereum/solidity/issues?q=is%3Aopen+is%3Aissue+label%3Aup-for-grabs) which are meant as introductory issues for external contributors.
## How to Report Issues[¶](#how-to-report-issues "Permalink to this headline")
To report an issue, please use the [GitHub issues tracker](https://github.com/ethereum/solidity/issues). When reporting issues, please mention the following details:
* Which version of Solidity you are using
* What was the source code (if applicable)
* Which platform are you running on
* How to reproduce the issue
* What was the result of the issue
* What the expected behaviour is
Reducing the source code that caused the issue to a bare minimum is always very helpful and sometimes even clarifies a misunderstanding.
## Workflow for Pull Requests[¶](#workflow-for-pull-requests "Permalink to this headline")
In order to contribute, please fork off of the `develop` branch and make your changes there. Your commit messages should detail _why_ you made your change in addition to _what_ you did (unless it is a tiny change).
If you need to pull in any changes from `develop` after making your fork (for example, to resolve potential merge conflicts), please avoid using `git merge` and instead, `git rebase` your branch.
Additionally, if you are writing a new feature, please ensure you write appropriate Boost test cases and place them under `test/`.
However, if you are making a larger change, please consult with the [Solidity Development Gitter channel](https://gitter.im/ethereum/solidity-dev) (different from the one mentioned above, this on is focused on compiler and language development instead of language use) first.
Finally, please make sure you respect the [coding style](https://raw.githubusercontent.com/ethereum/solidity/develop/CODING_STYLE.md) for this project. Also, even though we do CI testing, please test your code and ensure that it builds locally before submitting a pull request.
Thank you for your help!
## Running the compiler tests[¶](#running-the-compiler-tests "Permalink to this headline")
Solidity includes different types of tests. They are included in the application called `soltest`. Some of them require the `cpp-ethereum` client in testing mode, some others require `libz3` to be installed.
`soltest` reads test contracts that are annotated with expected results stored in `./test/libsolidity/syntaxTests`. In order for soltest to find these tests the root test directory has to be specified using the `--testpath` command line option, e.g. `./build/test/soltest -- --testpath ./test`.
To disable the z3 tests, use `./build/test/soltest -- --no-smt --testpath ./test` and to run a subset of the tests that do not require `cpp-ethereum`, use `./build/test/soltest -- --no-ipc --testpath ./test`.
For all other tests, you need to install [cpp-ethereum](https://github.com/ethereum/cpp-ethereum/releases/download/solidityTester/eth) and run it in testing mode: `eth --test -d /tmp/testeth`.
Then you run the actual tests: `./build/test/soltest -- --ipcpath /tmp/testeth/geth.ipc --testpath ./test`.
To run a subset of tests, filters can be used: `soltest -t TestSuite/TestName -- --ipcpath /tmp/testeth/geth.ipc --testpath ./test`, where `TestName` can be a wildcard `*`.
Alternatively, there is a testing script at `scripts/test.sh` which executes all tests and runs `cpp-ethereum` automatically if it is in the path (but does not download it).
Travis CI even runs some additional tests (including `solc-js` and testing third party Solidity frameworks) that require compiling the Emscripten target.
### Writing and running syntax tests[¶](#writing-and-running-syntax-tests "Permalink to this headline")
As mentioned above, syntax tests are stored in individual contracts. These files must contain annotations, stating the expected result(s) of the respective test. The test suite will compile and check them against the given expectations.
Example: `./test/libsolidity/syntaxTests/double_stateVariable_declaration.sol`
contract test {
 uint256 variable;
 uint128 variable;
}
// ----
// DeclarationError: Identifier already declared.
A syntax test must contain at least the contract under test itself, followed by the seperator `----`. The additional comments above are used to describe the expected compiler errors or warnings. This section can be empty in case that the contract should compile without any errors or warnings.
In the above example, the state variable `variable` was declared twice, which is not allowed. This will result in a `DeclarationError` stating that the identifer was already declared.
The tool that is being used for those tests is called `isoltest` and can be found under `./test/tools/`. It is an interactive tool which allows editing of failing contracts using your prefered text editor. Let’s try to break this test by removing the second declaration of `variable`:
contract test {
 uint256 variable;
}
// ----
// DeclarationError: Identifier already declared.
Running `./test/isoltest` again will result in a test failure:
syntaxTests/double\_stateVariable\_declaration.sol: FAIL
 Contract:
 contract test {
 uint256 variable;
 }
 Expected result:
 DeclarationError: Identifier already declared.
 Obtained result:
 Success
which prints the expected result next to the obtained result, but also provides a way to change edit / update / skip the current contract or to even quit. `isoltest` offers several options for failing tests:
* edit: `isoltest` will try to open the editor that was specified before using `isoltest --editor /path/to/editor`. If no path was set, this will result in a runtime error. In case an editor was specified, this will open it such that the contract can be adjusted.
* update: Updates the contract under test. This will either remove the annotation which contains the exception not met or will add missing expectations. The test will then be run again.
* skip: Skips the execution of this particular test.
* quit: Quits `isoltest`.
Automatically updating the test above will change it to
contract test {
 uint256 variable;
}
// ----
and re-run the test. It will now pass again:
Re\-running test case...
syntaxTests/double\_stateVariable\_declaration.sol: OK
Note
Please choose a name for the contract file, that is self-explainatory in the sense of what is been tested, e.g. `double_variable_declaration.sol`. Do not put more than one contract into a single file. `isoltest` is currently not able to recognize them individually.
## Running the Fuzzer via AFL[¶](#running-the-fuzzer-via-afl "Permalink to this headline")
Fuzzing is a technique that runs programs on more or less random inputs to find exceptional execution states (segmentation faults, exceptions, etc). Modern fuzzers are clever and do a directed search inside the input. We have a specialized binary called `solfuzzer` which takes source code as input and fails whenever it encounters an internal compiler error, segmentation fault or similar, but does not fail if e.g. the code contains an error. This way, internal problems in the compiler can be found by fuzzing tools.
We mainly use [AFL](http://lcamtuf.coredump.cx/afl/) for fuzzing. You need to download and build AFL manually. Next, build Solidity (or just the `solfuzzer` binary) with AFL as your compiler:
cd build
＃ if needed
make clean
cmake .. \-DCMAKE\_C\_COMPILER\=path/to/afl\-gcc \-DCMAKE\_CXX\_COMPILER\=path/to/afl\-g++
make solfuzzer
Next, you need some example source files. This will make it much easer for the fuzzer to find errors. You can either copy some files from the syntax tests or extract test files from the documentation or the other tests:
mkdir /tmp/test\_cases
cd /tmp/test\_cases
＃ extract from tests:
path/to/solidity/scripts/isolate\_tests.py path/to/solidity/test/libsolidity/SolidityEndToEndTest.cpp
＃ extract from documentation:
path/to/solidity/scripts/isolate\_tests.py path/to/solidity/docs docs
The AFL documentation states that the corpus (the initial input files) should not be too large. The files themselves should not be larger than 1 kB and there should be at most one input file per functionality, so better start with a small number of input files. There is also a tool called `afl-cmin` that can trim input files that result in similar behaviour of the binary.
Now run the fuzzer (the `-m` extends the size of memory to 60 MB):
afl\-fuzz \-m 60 \-i /tmp/test\_cases \-o /tmp/fuzzer\_reports \-- /path/to/solfuzzer
The fuzzer will create source files that lead to failures in `/tmp/fuzzer_reports`. Often it finds many similar source files that produce the same error. You can use the tool `scripts/uniqueErrors.sh` to filter out the unique errors.
## Whiskers[¶](#whiskers "Permalink to this headline")
_Whiskers_ is a templating system similar to [Mustache](https://mustache.github.io/). It is used by the compiler in various places to aid readability, and thus maintainability and verifiability, of the code.
The syntax comes with a substantial difference to Mustache: the template markers `{{` and `}}` are replaced by `<` and `>` in order to aid parsing and avoid conflicts with [Inline Assembly](https://docs.soliditylang.org/en/v0.4.26/assembly.html#inline-assembly) (The symbols `<` and `>` are invalid in inline assembly, while `{` and `}` are used to delimit blocks). Another limitation is that lists are only resolved one depth and they will not recurse. This may change in the future.
A rough specification is the following:
Any occurrence of `<name>` is replaced by the string-value of the supplied variable `name` without any escaping and without iterated replacements. An area can be delimited by `<#name>...</name>`. It is replaced by as many concatenations of its contents as there were sets of variables supplied to the template system, each time replacing any `<inner>` items by their respective value. Top-level variables can also be used inside such areas.

# [Solidity 源文件结构 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html) 
 _https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html_

源文件可以包含任意数量的 [contract 定义](https://docs.soliditylang.org/zh-cn/latest/structure-of-a-contract.html#contract-structure), [import](#import) 指令, [pragma](#pragma) 指令和 [using for](https://docs.soliditylang.org/zh-cn/latest/contracts.html#using-for) 指令 和 [struct](https://docs.soliditylang.org/zh-cn/latest/types.html#structs), [enum](https://docs.soliditylang.org/zh-cn/latest/types.html#enums), [function](https://docs.soliditylang.org/zh-cn/latest/contracts.html#functions), [error](https://docs.soliditylang.org/zh-cn/latest/contracts.html#errors) 以及 [constant 变量](https://docs.soliditylang.org/zh-cn/latest/contracts.html#constants) 的定义。
## SPDX 许可标识符[](#spdx "此标题的永久链接")
如果智能合约的源代码是公开的，就可以更好地建立对智能合约的信任。 由于提供源代码总是涉及到版权方面的法律问题， Solidity 编译器鼓励使用机器可读的 [SPDX 许可标识符](https://spdx.org/) 。 每个源文件都应该以一个注释开始，表明其许可证
`// SPDX-License-Identifier: MIT`
编译器不会验证许可证是否属于 [SPDX许可的列表](https://spdx.org/licenses/)， 但它确实包括在 [字节码元数据（bytecode metadata）](https://docs.soliditylang.org/zh-cn/latest/metadata.html#metadata) 提供的字符串中。
如果您不想指定一个许可，或者源代码不是开源的， 请使用特殊值 `UNLICENSED`。请注意， `UNLICENSED` （不允许使用， 不存在于SPDX许可证列表中）与 `UNLICENSE` （授予所有人所有权利）不同。 Solidity 遵循 [npm 的推荐](https://docs.npmjs.com/cli/v7/configuring-npm/package-json#license)。
提供这个注释并不能使您摆脱与许可有关的其他义务， 如必须在每个源文件中提到特定的许可头或原始版权人。
编译器可以在文件的任何位置识别该注释， 但建议把它放在文件的顶部。
关于如何使用 SPDX 许可证标识的更多信息可以在 [SPDX 网站](https://spdx.dev/learn/handling-license-info/#how) 中找到。
## 编译指示[](#pragma "此标题的永久链接")
`pragma` 关键字用于启用某些编译器特性或检查。 一个 pragma 指令始终是源文件的本地指令， 所以如果您想在整个项目中使用 pragma 指令， 您必须在您的所有文件中添加这个指令。 如果您 [import](#import) 另一个文件， 该文件的 pragma 指令 _不会_ 自动应用于导入文件。
### 版本编译指示[](#version-pragma "此标题的永久链接")
源文件可以（而且应该）用版本 pragma 指令来注释， 以拒绝用未来的编译器版本进行编译，因为这可能会引入不兼容的变化。 我们力图把这类变更做到尽可能小， 我们需要以一种当修改语义时必须同步修改语法的方式引入变更， 当然这有时候也难以做到。正因为如此， 至少在包含重大变化的版本中，通读一下更新日志总是一个好主意。 这些版本总是有 `0.x.0` 或 `x.0.0` 形式的版本。
版本编译指示使用如下： `pragma solidity ^0.5.2;`
带有上述代码的源文件在 0.5.2 版本之前的编译器上不能编译， 在 0.6.0 版本之后的编译器上也不能工作（这第二个条件是通过使用 `^` 添加的）。 因为在 `0.6.0` 版本之前不会有任何重大的变化， 所以您可以确信您的代码是按照您的预期编译的。 上面例子中不固定编译器的具体版本号，因此编译器的补丁版也可以使用。
可以为编译器版本指定更复杂的规则， 这些规则与 [npm](https://docs.npmjs.com/cli/v6/using-npm/semver) 使用相同的语法。
备注
使用版本 pragma 指令 _不会_ 改变编译器的版本。 它也 _不会_ 启用或禁用编译器的功能。 它只是指示编译器检查它的版本是否与编译指示所要求的版本一致。 如果不匹配，编译器会发出一个错误。
### ABI编码编译指示[](#abi "此标题的永久链接")
通过使用 `pragma abicoder v1` 或 `pragma abicoder v2` ， 您可以选择ABI编码器和解码器的两种实现。
新的 ABI 编码器（v2）能够对任意嵌套的数组和结构进行编码和解码。 除了支持更多的类型外，它还涉及更广泛的验证和安全检查， 这可能导致更高的燃料成本，但也提高了安全性。 从 Solidity 0.6.0 开始，它被认为是非实验性的， 并且从 Solidity 0.8.0 开始，它被默认启用。 旧的 ABI 编码器仍然可以使用 `pragma abicoder v1;` 来选择。
新编码器所支持的类型集是旧编码器所支持的类型的一个严格超集。 使用新编码器的合约可以与不使用新编码器的合约进行交互，没有任何限制。 只有当非 `abicoder v2` 的合约不试图进行需要解码新编码器支持的类型的调用时， 才有可能出现相反的情况。 编译器可以检测到这一点，并会发出一个错误。 只要为您的合约启用 `abicoder v2` ，就足以使错误消失。
备注
这个编译指示适用于激活它的文件中定义的所有代码， 无论这些代码最终在哪里结束。这意味着， 一个合约的源文件被选择用 ABI 编码器v1编译， 它仍然可以包含通过从另一个合约继承来使用新编码器的代码。 如果新类型只在内部使用，而不是在外部函数签名中使用， 这是被允许的。
备注
到 Solidity 0.7.4 为止，可以通过使用 `pragma experimental ABIEncoderV2` 来选择 ABI 编码器v2，但不可能明确选择编码器v1，因为它是默认的。
### 实验性编译指示[](#experimental-pragma "此标题的永久链接")
第二个编译指示是实验性的编译指示。 它可以用来启用编译器或语言中尚未默认启用的功能。 目前支持以下实验性编译指示：
#### ABI 编码器 V2[](#abi-v2 "此标题的永久链接")
因为 ABI 编码器v2不再被认为是实验性的， 它可以通过 `pragma abicoder v2` （请见上文）从 Solidity 0.7.4 开始选择。
#### SMT检查器[](#smt "此标题的永久链接")
这个组件必须在构建 Solidity 编译器时被启用， 因此它不是在所有 Solidity 二进制文件中都可用。 [构建说明](https://docs.soliditylang.org/zh-cn/latest/installing-solidity.html#smt-solvers-build) 解释了如何激活这个选项。 它在大多数版本中为 Ubuntu PPA 版本激活， 但不用于 Docker 镜像、Windows 二进制文件或静态构建的 Linux 二进制文件。 如果您在本地安装了SMT检查器并通过节点（而不是通过浏览器）运行 solc-js， 可以通过 [smtCallback](https://github.com/ethereum/solc-js#example-usagewith-smtsolver-callback) 为 solc-js 激活它。
如果您使用 `pragma experimental SMTChecker;`， 那么您会得到额外的 [安全警告](https://docs.soliditylang.org/zh-cn/latest/smtchecker.html#formal-verification)。 这些警告是通过查询SMT求解器获得的。 该组件还不支持 Solidity 语言的所有功能，可能会输出许多警告。 如果它报告不支持的功能，那么分析可能不完全正确。
## 导入其他源文件[](#import "此标题的永久链接")
### 语法与语义[](#id9 "此标题的永久链接")
Solidity 支持导入语句，以帮助模块化您的代码， 这些语句与 JavaScript 中可用的语句相似(从ES6开始)。 然而，Solidity 并不支持 [默认导出](https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export#description) 的概念。
在全局层面，您可以使用以下形式的导入语句：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=aW1wb3J0ICJmaWxlbmFtZSI7)
`filename` 部分被称为 _导入路径_。 该语句将所有来自 “filename” 的全局符号（以及在那里导入的符号） 导入到当前的全局范围（与ES6中不同，但对Solidity来说是向后兼容的）。 这种形式不建议使用，因为它不可预测地污染了命名空间。 如果您在 “filename” 里面添加新的顶层项目， 它们会自动出现在所有像这样从 “filename” 导入的文件中。 最好是明确地导入特定的符号。
下面的例子创建了一个新的全局符号 `symbolName`，其成员均来自 `"filename"` 中全局符号；
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=aW1wb3J0ICogYXMgc3ltYm9sTmFtZSBmcm9tICJmaWxlbmFtZSI7)
import \* as symbolName from "filename";
这意味着所有全局符号以 `symbolName.symbol` 的格式提供。
另一种语法不属于 ES6，但可能是有用的：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=aW1wb3J0ICJmaWxlbmFtZSIgYXMgc3ltYm9sTmFtZTs=)
import "filename" as symbolName;
这条语句等同于 `import * as symbolName from "filename";`。
如果有命名冲突，您可以在导入的同时重命名符号。 例如，下面的代码创建了新的全局符号 `alias` 和 `symbol2`， 它们分别从 `"filename"` 里面引用 `symbol1` 和 `symbol2`。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=aW1wb3J0IHtzeW1ib2wxIGFzIGFsaWFzLCBzeW1ib2wyfSBmcm9tICJmaWxlbmFtZSI7)
import {symbol1 as alias, symbol2} from "filename";
### 导入路径[](#index-8 "此标题的永久链接")
为了能够在所有平台上支持可重复的构建， Solidity 编译器必须抽象出存储源文件的文件系统的细节。 由于这个原因，导入路径并不直接指向主机文件系统中的文件。 相反，编译器维护一个内部数据库（ _虚拟文件系统_ 或简称 _VFS_ ）， 每个源单元被分配一个唯一的 _源单元名称_， 这是一个不透明的、非结构化的标识。 在导入语句中指定的导入路径被转译成源单元名称，并用于在这个数据库中找到相应的源单元。
使用 [标准 JSON](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#compiler-api) API， 可以直接提供所有源文件的名称和内容作为编译器输入的一部分。 在这种情况下，源单元的名称确实是任意的。 然而，如果您想让编译器自动查找并将源代码加载到VFS中， 您的源单元名称需要以一种结构化的方式，使 [回调引用](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#import-callback) 能够定位它们。 当使用命令行编译器时，默认的回调引用只支持从主机文件系统加载源代码， 这意味着您的源单元名称必须是路径。一些环境提供了自定义的回调，其用途更广。 例如， [Remix IDE](https://remix.ethereum.org/) 提供了一个可以让您 [从HTTP、IPFS和Swarm URL导入文件，或者直接引用NPM注册表中的包](https://remix-ide.readthedocs.io/en/latest/import.html)。
关于虚拟文件系统和编译器使用的路径解析逻辑的完整描述，请参见 [路径解析](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#path-resolution)。
## 注释[](#index-9 "此标题的永久链接")
可以使用单行注释（ `//` ）和多行注释（ `/*...*/` ）
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8g6L+Z5piv5LiA5Liq5Y2V6KGM5rOo6YeK44CCCgovKgrov5nmmK/kuIDkuKoK5aSa6KGM5rOo6YeK44CCCiov)
// 这是一个单行注释。
/\*
这是一个
多行注释。
\*/
备注
单行注释由 UTF-8 编码中的任何单码行结束符（LF、VF、FF、CR、NEL、LS 或 PS）结束。 终结符在注释之后仍然是源代码的一部分， 所以如果它不是一个 ASCII 符号（这些是 NEL、LS 和 PS），将导致解析器错误。
此外，还有一种注释叫做 NatSpec 注释，在 [格式指南](https://docs.soliditylang.org/zh-cn/latest/style-guide.html#style-guide-natspec) 中详细说明。 它们用三斜线（ `///` ）或双星号块（ `/** ... */` ）来写， 它们应该直接用在函数声明或语句的上方。

# [NatSpec Format — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/natspec-format.html) 
 _https://docs.soliditylang.org/en/latest/natspec-format.html_

Solidity contracts can use a special form of comments to provide rich documentation for functions, return variables and more. This special form is named the Ethereum Natural Language Specification Format (NatSpec).
Note
NatSpec was inspired by [Doxygen](https://en.wikipedia.org/wiki/Doxygen). While it uses Doxygen-style comments and tags, there is no intention to keep strict compatibility with Doxygen. Please carefully examine the supported tags listed below.
This documentation is segmented into developer-focused messages and end-user-facing messages. These messages may be shown to the end user (the human) at the time that they will interact with the contract (i.e. sign a transaction).
It is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI).
NatSpec includes the formatting for comments that the smart contract author will use, and which are understood by the Solidity compiler. Also detailed below is output of the Solidity compiler, which extracts these comments into a machine-readable format.
NatSpec may also include annotations used by third-party tools. These are most likely accomplished via the `@custom:<name>` tag, and a good use case is analysis and verification tools.
## Documentation Example[](#documentation-example "Link to this heading")
Documentation is inserted above each `contract`, `interface`, `library`, `function`, `enum`, `enum` value and `event` using the Doxygen notation format. A `public` state variable is equivalent to a `function` for the purposes of NatSpec.
* For Solidity you may choose `///` for single or multi-line comments, or `/**` and ending with `*/`.
 
* For Vyper, use `"""` indented to the inner contents with bare comments. See the [Vyper documentation](https://docs.vyperlang.org/en/latest/natspec.html).
 
The following example shows a contract and a function using all available tags.
Note
The Solidity compiler only interprets tags if they are external or public. You are welcome to use similar comments for your internal and private functions, but those will not be parsed.
This may change in the future.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjIgPCAwLjkuMDsKCi8vLyBAdGl0bGUgQSBzaW11bGF0b3IgZm9yIHRyZWVzCi8vLyBAYXV0aG9yIExhcnJ5IEEuIEdhcmRuZXIKLy8vIEBub3RpY2UgWW91IGNhbiB1c2UgdGhpcyBjb250cmFjdCBmb3Igb25seSB0aGUgbW9zdCBiYXNpYyBzaW11bGF0aW9uCi8vLyBAZGV2IEFsbCBmdW5jdGlvbiBjYWxscyBhcmUgY3VycmVudGx5IGltcGxlbWVudGVkIHdpdGhvdXQgc2lkZSBlZmZlY3RzCi8vLyBAY3VzdG9tOmV4cGVyaW1lbnRhbCBUaGlzIGlzIGFuIGV4cGVyaW1lbnRhbCBjb250cmFjdC4KY29udHJhY3QgVHJlZSB7CiAgICAvLy8gQG5vdGljZSBDYWxjdWxhdGUgdHJlZSBhZ2UgaW4geWVhcnMsIHJvdW5kZWQgdXAsIGZvciBsaXZlIHRyZWVzCiAgICAvLy8gQGRldiBUaGUgQWxleGFuZHIgTi4gVGV0ZWFyaW5nIGFsZ29yaXRobSBjb3VsZCBpbmNyZWFzZSBwcmVjaXNpb24KICAgIC8vLyBAcGFyYW0gcmluZ3MgVGhlIG51bWJlciBvZiByaW5ncyBmcm9tIGRlbmRyb2Nocm9ub2xvZ2ljYWwgc2FtcGxlCiAgICAvLy8gQHJldHVybiBBZ2UgaW4geWVhcnMsIHJvdW5kZWQgdXAgZm9yIHBhcnRpYWwgeWVhcnMKICAgIC8vLyBAcmV0dXJuIE5hbWUgb2YgdGhlIHRyZWUKICAgIGZ1bmN0aW9uIGFnZSh1aW50MjU2IHJpbmdzKSBleHRlcm5hbCB2aXJ0dWFsIHB1cmUgcmV0dXJucyAodWludDI1Niwgc3RyaW5nIG1lbW9yeSkgewogICAgICAgIHJldHVybiAocmluZ3MgKyAxLCAidHJlZSIpOwogICAgfQoKICAgIC8vLyBAbm90aWNlIFJldHVybnMgdGhlIGFtb3VudCBvZiBsZWF2ZXMgdGhlIHRyZWUgaGFzLgogICAgLy8vIEBkZXYgUmV0dXJucyBvbmx5IGEgZml4ZWQgbnVtYmVyLgogICAgZnVuY3Rpb24gbGVhdmVzKCkgZXh0ZXJuYWwgdmlydHVhbCBwdXJlIHJldHVybnModWludDI1NikgewogICAgICAgIHJldHVybiAyOwogICAgfQp9Cgpjb250cmFjdCBQbGFudCB7CiAgICBmdW5jdGlvbiBsZWF2ZXMoKSBleHRlcm5hbCB2aXJ0dWFsIHB1cmUgcmV0dXJucyh1aW50MjU2KSB7CiAgICAgICAgcmV0dXJuIDM7CiAgICB9Cn0KCmNvbnRyYWN0IEt1bXF1YXRUcmVlIGlzIFRyZWUsIFBsYW50IHsKICAgIGZ1bmN0aW9uIGFnZSh1aW50MjU2IHJpbmdzKSBleHRlcm5hbCBvdmVycmlkZSBwdXJlIHJldHVybnMgKHVpbnQyNTYsIHN0cmluZyBtZW1vcnkpIHsKICAgICAgICByZXR1cm4gKHJpbmdzICsgMiwgIkt1bXF1YXQiKTsKICAgIH0KCiAgICAvLy8gUmV0dXJuIHRoZSBhbW91bnQgb2YgbGVhdmVzIHRoYXQgdGhpcyBzcGVjaWZpYyBraW5kIG9mIHRyZWUgaGFzCiAgICAvLy8gQGluaGVyaXRkb2MgVHJlZQogICAgZnVuY3Rpb24gbGVhdmVzKCkgZXh0ZXJuYWwgb3ZlcnJpZGUoVHJlZSwgUGxhbnQpIHB1cmUgcmV0dXJucyh1aW50MjU2KSB7CiAgICAgICAgcmV0dXJuIDM7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.2 < 0.9.0;
/// @title A simulator for trees
/// @author Larry A. Gardner
/// @notice You can use this contract for only the most basic simulation
/// @dev All function calls are currently implemented without side effects
/// @custom:experimental This is an experimental contract.
contract Tree {
 /// @notice Calculate tree age in years, rounded up, for live trees
 /// @dev The Alexandr N. Tetearing algorithm could increase precision
 /// @param rings The number of rings from dendrochronological sample
 /// @return Age in years, rounded up for partial years
 /// @return Name of the tree
 function age(uint256 rings) external virtual pure returns (uint256, string memory) {
 return (rings + 1, "tree");
 }
 /// @notice Returns the amount of leaves the tree has.
 /// @dev Returns only a fixed number.
 function leaves() external virtual pure returns(uint256) {
 return 2;
 }
}
contract Plant {
 function leaves() external virtual pure returns(uint256) {
 return 3;
 }
}
contract KumquatTree is Tree, Plant {
 function age(uint256 rings) external override pure returns (uint256, string memory) {
 return (rings + 2, "Kumquat");
 }
 /// Return the amount of leaves that this specific kind of tree has
 /// @inheritdoc Tree
 function leaves() external override(Tree, Plant) pure returns(uint256) {
 return 3;
 }
}
## Tags[](#tags "Link to this heading")
All tags are optional. The following table explains the purpose of each NatSpec tag and where it may be used. As a special case, if no tags are used then the Solidity compiler will interpret a `///` or `/**` comment in the same way as if it were tagged with `@notice`.
Tag
Context
`@title`
A title that should describe the contract/interface
contract, library, interface, struct, enum, enum values
`@author`
The name of the author
contract, library, interface, struct, enum, enum values
`@notice`
Explain to an end user what this does
contract, library, interface, function, public state variable, event, struct, enum, enum values error
`@dev`
Explain to a developer any extra details
contract, library, interface, function, state variable, event, struct, enum, enum values, error
`@param`
Documents a parameter just like in Doxygen (must be followed by parameter name)
function, event, enum values, error
`@return`
Documents the return variables of a contract’s function
function, enum, enum values, public state variable
`@inheritdoc`
Copies all missing tags from the base function (must be followed by the contract name)
function, enum, enum values, public state variable
`@custom:...`
Custom tag, semantics is application-defined
everywhere
If your function returns multiple values, like `(int quotient, int remainder)` then use multiple `@return` statements in the same format as the `@param` statements.
Custom tags start with `@custom:` and must be followed by one or more lowercase letters or hyphens. It cannot start with a hyphen however. They can be used everywhere and are part of the developer documentation.
### Dynamic expressions[](#dynamic-expressions "Link to this heading")
The Solidity compiler will pass through NatSpec documentation from your Solidity source code to the JSON output as described in this guide. The consumer of this JSON output, for example the end-user client software, may present this to the end-user directly or it may apply some pre-processing.
For example, some client software will render:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8vIEBub3RpY2UgVGhpcyBmdW5jdGlvbiB3aWxsIG11bHRpcGx5IGBhYCBieSA3)
/// @notice This function will multiply \`a\` by 7
to the end-user as:
This function will multiply 10 by 7
if a function is being called and the input `a` is assigned a value of 10.
### Inheritance Notes[](#inheritance-notes "Link to this heading")
Functions without NatSpec will automatically inherit the documentation of their base function. Exceptions to this are:
* When the parameter names are different.
 
* When there is more than one base function.
 
* When there is an explicit `@inheritdoc` tag which specifies which contract should be used to inherit.
 
## Documentation Output[](#documentation-output "Link to this heading")
When parsed by the compiler, documentation such as the one from the above example will produce two different JSON files. One is meant to be consumed by the end user as a notice when a function is executed and the other to be used by the developer.
If the above contract is saved as `ex1.sol` then you can generate the documentation using:
solc \--userdoc \--devdoc ex1.sol
And the output is below.
Note
Starting Solidity version 0.6.11 the NatSpec output also contains a `version` and a `kind` field. Currently the `version` is set to `1` and `kind` must be one of `user` or `dev`. In the future it is possible that new versions will be introduced, deprecating older ones.
### User Documentation[](#user-documentation "Link to this heading")
The above documentation will produce the following user documentation JSON file as output for the `Tree` contract:
{
 "version" : 1,
 "kind" : "user",
 "methods" :
 {
 "age(uint256)" :
 {
 "notice" : "Calculate tree age in years, rounded up, for live trees"
 },
 "leaves()" :
 {
 "notice" : "Returns the amount of leaves the tree has."
 }
 },
 "notice" : "You can use this contract for only the most basic simulation"
}
Note that the key by which to find the methods is the function’s canonical signature as defined in the [Contract ABI](https://docs.soliditylang.org/en/latest/abi-spec.html#abi-function-selector) and not simply the function’s name.
### Developer Documentation[](#developer-documentation "Link to this heading")
Apart from the user documentation file, a developer documentation JSON file should also be produced and should look like this:
{
 "version" : 1,
 "kind" : "dev",
 "author" : "Larry A. Gardner",
 "details" : "All function calls are currently implemented without side effects",
 "custom:experimental" : "This is an experimental contract.",
 "methods" :
 {
 "age(uint256)" :
 {
 "details" : "The Alexandr N. Tetearing algorithm could increase precision",
 "params" :
 {
 "rings" : "The number of rings from dendrochronological sample"
 },
 "returns" : {
 "\_0" : "Age in years, rounded up for partial years",
 "\_1" : "Name of the tree"
 }
 },
 "leaves()" :
 {
 "details" : "Returns only a fixed number."
 }
 },
 "title" : "A simulator for trees"
}

# [Contract ABI Specification — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html) 
 _https://docs.soliditylang.org/en/v0.8.30/abi-spec.html_

## Basic Design[](#basic-design "Link to this heading")
The Contract Application Binary Interface (ABI) is the standard way to interact with contracts in the Ethereum ecosystem, both from outside the blockchain and for contract-to-contract interaction. Data is encoded according to its type, as described in this specification. The encoding is not self describing and thus requires a schema in order to decode.
We assume that the interface functions of a contract are strongly typed, known at compilation time and static. We assume that all contracts will have the interface definitions of any contracts they call available at compile-time.
This specification does not address contracts whose interface is dynamic or otherwise known only at run-time. Also, the ABI specification for libraries is [slightly different](https://docs.soliditylang.org/en/v0.8.30/contracts.html#library-selectors).
## Function Selector[](#function-selector "Link to this heading")
The first four bytes of the call data for a function call specifies the function to be called. It is the first (left, high-order in big-endian) four bytes of the Keccak-256 hash of the signature of the function. The signature is defined as the canonical expression of the basic prototype without data location specifier, i.e. the function name with the parenthesised list of parameter types. Parameter types are split by a single comma — no spaces are used.
Note
The return type of a function is not part of this signature. In [Solidity’s function overloading](https://docs.soliditylang.org/en/v0.8.30/contracts.html#overload-function) return types are not considered. The reason is to keep function call resolution context-independent. The [JSON description of the ABI](#abi-json) however contains both inputs and outputs.
## Argument Encoding[](#argument-encoding "Link to this heading")
Starting from the fifth byte, the encoded arguments follow. This encoding is also used in other places, e.g. the return values and also event arguments are encoded in the same way, without the four bytes specifying the function.
## Types[](#types "Link to this heading")
Note that the library ABIs can take types different than below e.g. for non-storage structs. See [library selectors](https://docs.soliditylang.org/en/v0.8.30/contracts.html#library-selectors) for details.
The following elementary types exist:
* `uint<M>`: unsigned integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`. e.g. `uint32`, `uint8`, `uint256`.
 
* `int<M>`: two’s complement signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`.
 
* `address`: equivalent to `uint160`, except for the assumed interpretation and language typing. For computing the function selector, `address` is used.
 
* `uint`, `int`: synonyms for `uint256`, `int256` respectively. For computing the function selector, `uint256` and `int256` have to be used.
 
* `bool`: equivalent to `uint8` restricted to the values 0 and 1. For computing the function selector, `bool` is used.
 
* `fixed<M>x<N>`: signed fixed-point decimal number of `M` bits, `8 <= M <= 256`, `M % 8 == 0`, and `0 < N <= 80`, which denotes the value `v` as `v / (10 ** N)`.
 
* `ufixed<M>x<N>`: unsigned variant of `fixed<M>x<N>`.
 
* `fixed`, `ufixed`: synonyms for `fixed128x18`, `ufixed128x18` respectively. For computing the function selector, `fixed128x18` and `ufixed128x18` have to be used.
 
* `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`.
 
* `function`: an address (20 bytes) followed by a function selector (4 bytes). Encoded identical to `bytes24`.
 
The following (fixed-size) array type exists:
* `<type>[M]`: a fixed-length array of `M` elements, `M >= 0`, of the given type.
 
 Note
 
 While this ABI specification can express fixed-length arrays with zero elements, they’re not supported by the compiler.
 
The following non-fixed-size types exist:
* `bytes`: dynamic sized byte sequence.
 
* `string`: dynamic sized unicode string assumed to be UTF-8 encoded.
 
* `<type>[]`: a variable-length array of elements of the given type.
 
Types can be combined to a tuple by enclosing them inside parentheses, separated by commas:
* `(T1,T2,...,Tn)`: tuple consisting of the types `T1`, …, `Tn`, `n >= 0`
 
It is possible to form tuples of tuples, arrays of tuples and so on. It is also possible to form zero-tuples (where `n == 0`).
### Mapping Solidity to ABI types[](#mapping-solidity-to-abi-types "Link to this heading")
Solidity supports all the types presented above with the same names with the exception of tuples. On the other hand, some Solidity types are not supported by the ABI. The following table shows on the left column Solidity types that are not part of the ABI, and on the right column the ABI types that represent them.
Warning
Before version `0.8.0` enums could have more than 256 members and were represented by the smallest integer type just big enough to hold the value of any member.
## Design Criteria for the Encoding[](#design-criteria-for-the-encoding "Link to this heading")
The encoding is designed to have the following properties, which are especially useful if some arguments are nested arrays:
1. The number of reads necessary to access a value is at most the depth of the value inside the argument array structure, i.e. four reads are needed to retrieve `a_i[k][l][r]`. In a previous version of the ABI, the number of reads scaled linearly with the total number of dynamic parameters in the worst case.
 
2. The data of a variable or an array element is not interleaved with other data and it is relocatable, i.e. it only uses relative “addresses”.
 
## Formal Specification of the Encoding[](#formal-specification-of-the-encoding "Link to this heading")
We distinguish static and dynamic types. Static types are encoded in-place and dynamic types are encoded at a separately allocated location after the current block.
**Definition:** The following types are called “dynamic”:
* `bytes`
 
* `string`
 
* `T[]` for any `T`
 
* `T[k]` for any dynamic `T` and any `k >= 0`
 
* `(T1,...,Tk)` if `Ti` is dynamic for some `1 <= i <= k`
 
All other types are called “static”.
**Definition:** `len(a)` is the number of bytes in a binary string `a`. The type of `len(a)` is assumed to be `uint256`.
We define `enc`, the actual encoding, as a mapping of values of the ABI types to binary strings such that `len(enc(X))` depends on the value of `X` if and only if the type of `X` is dynamic.
**Definition:** For any ABI value `X`, we recursively define `enc(X)`, depending on the type of `X` being
* `(T1,...,Tk)` for `k >= 0` and any types `T1`, …, `Tk`
 
 `enc(X) = head(X(1)) ... head(X(k)) tail(X(1)) ... tail(X(k))`
 
 where `X = (X(1), ..., X(k))` and `head` and `tail` are defined for `Ti` as follows:
 
 if `Ti` is static:
 
 > `head(X(i)) = enc(X(i))` and `tail(X(i)) = ""` (the empty string)
 
 otherwise, i.e. if `Ti` is dynamic:
 
 > `head(X(i)) = enc(len( head(X(1)) ... head(X(k)) tail(X(1)) ... tail(X(i-1)) ))` `tail(X(i)) = enc(X(i))`
 
 Note that in the dynamic case, `head(X(i))` is well-defined since the lengths of the head parts only depend on the types and not the values. The value of `head(X(i))` is the offset of the beginning of `tail(X(i))` relative to the start of `enc(X)`.
 
* `T[k]` for any `T` and `k`:
 
 `enc(X) = enc((X[0], ..., X[k-1]))`
 
 i.e. it is encoded as if it were a tuple with `k` elements of the same type.
 
* `T[]` where `X` has `k` elements (`k` is assumed to be of type `uint256`):
 
 `enc(X) = enc(k) enc((X[0], ..., X[k-1]))`
 
 i.e. it is encoded as if it were a tuple with `k` elements of the same type (resp. an array of static size `k`), prefixed with the number of elements.
 
* `bytes`, of length `k` (which is assumed to be of type `uint256`):
 
 `enc(X) = enc(k) pad_right(X)`, i.e. the number of bytes is encoded as a `uint256` followed by the actual value of `X` as a byte sequence, followed by the minimum number of zero-bytes such that `len(enc(X))` is a multiple of 32.
 
* `string`:
 
 `enc(X) = enc(enc_utf8(X))`, i.e. `X` is UTF-8 encoded and this value is interpreted as of `bytes` type and encoded further. Note that the length used in this subsequent encoding is the number of bytes of the UTF-8 encoded string, not its number of characters.
 
* `uint<M>`: `enc(X)` is the big-endian encoding of `X`, padded on the higher-order (left) side with zero-bytes such that the length is 32 bytes.
 
* `address`: as in the `uint160` case
 
* `int<M>`: `enc(X)` is the big-endian two’s complement encoding of `X`, padded on the higher-order (left) side with `0xff` bytes for negative `X` and with zero-bytes for non-negative `X` such that the length is 32 bytes.
 
* `bool`: as in the `uint8` case, where `1` is used for `true` and `0` for `false`
 
* `fixed<M>x<N>`: `enc(X)` is `enc(X * 10**N)` where `X * 10**N` is interpreted as a `int256`.
 
* `fixed`: as in the `fixed128x18` case
 
* `ufixed<M>x<N>`: `enc(X)` is `enc(X * 10**N)` where `X * 10**N` is interpreted as a `uint256`.
 
* `ufixed`: as in the `ufixed128x18` case
 
* `bytes<M>`: `enc(X)` is the sequence of bytes in `X` padded with trailing zero-bytes to a length of 32 bytes.
 
Note that for any `X`, `len(enc(X))` is a multiple of 32.
## Function Selector and Argument Encoding[](#function-selector-and-argument-encoding "Link to this heading")
All in all, a call to the function `f` with parameters `a_1, ..., a_n` is encoded as
> `function_selector(f) enc((a_1, ..., a_n))`
and the return values `v_1, ..., v_k` of `f` are encoded as
> `enc((v_1, ..., v_k))`
i.e. the values are combined into a tuple and encoded.
## Examples[](#examples "Link to this heading")
Given the contract:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEZvbyB7CiAgICBmdW5jdGlvbiBiYXIoYnl0ZXMzWzJdIG1lbW9yeSkgcHVibGljIHB1cmUge30KICAgIGZ1bmN0aW9uIGJheih1aW50MzIgeCwgYm9vbCB5KSBwdWJsaWMgcHVyZSByZXR1cm5zIChib29sIHIpIHsgciA9IHggPiAzMiB8fCB5OyB9CiAgICBmdW5jdGlvbiBzYW0oYnl0ZXMgbWVtb3J5LCBib29sLCB1aW50W10gbWVtb3J5KSBwdWJsaWMgcHVyZSB7fQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract Foo {
 function bar(bytes3\[2\] memory) public pure {}
 function baz(uint32 x, bool y) public pure returns (bool r) { r \= x \> 32 || y; }
 function sam(bytes memory, bool, uint\[\] memory) public pure {}
}
Thus, for our `Foo` example, if we wanted to call `bar` with the argument `["abc", "def"]`, we would pass 68 bytes total, broken down into:
* `0xfce353f6`: the Method ID. This is derived from the signature `bar(bytes3[2])`.
 
* `0x6162630000000000000000000000000000000000000000000000000000000000`: the first part of the first parameter, a `bytes3` value `"abc"` (left-aligned).
 
* `0x6465660000000000000000000000000000000000000000000000000000000000`: the second part of the first parameter, a `bytes3` value `"def"` (left-aligned).
 
In total:
0xfce353f661626300000000000000000000000000000000000000000000000000000000006465660000000000000000000000000000000000000000000000000000000000
If we wanted to call `baz` with the parameters `69` and `true`, we would pass 68 bytes total, which can be broken down into:
* `0xcdcd77c0`: the Method ID. This is derived as the first 4 bytes of the Keccak hash of the ASCII form of the signature `baz(uint32,bool)`.
 
* `0x0000000000000000000000000000000000000000000000000000000000000045`: the first parameter, a uint32 value `69` padded to 32 bytes
 
* `0x0000000000000000000000000000000000000000000000000000000000000001`: the second parameter - boolean `true`, padded to 32 bytes
 
In total:
0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001
It returns a single `bool`. If, for example, it were to return `false`, its output would be the single byte array `0x0000000000000000000000000000000000000000000000000000000000000000`, a single bool.
If we wanted to call `sam` with the arguments `"dave"`, `true` and `[1,2,3]`, we would pass 292 bytes total, broken down into:
* `0xa5643bf2`: the Method ID. This is derived from the signature `sam(bytes,bool,uint256[])`. Note that `uint` is replaced with its canonical representation `uint256`.
 
* `0x0000000000000000000000000000000000000000000000000000000000000060`: the location of the data part of the first parameter (dynamic type), measured in bytes from the start of the arguments block. In this case, `0x60`.
 
* `0x0000000000000000000000000000000000000000000000000000000000000001`: the second parameter: boolean true.
 
* `0x00000000000000000000000000000000000000000000000000000000000000a0`: the location of the data part of the third parameter (dynamic type), measured in bytes. In this case, `0xa0`.
 
* `0x0000000000000000000000000000000000000000000000000000000000000004`: the data part of the first argument, it starts with the length of the byte array in elements, in this case, 4.
 
* `0x6461766500000000000000000000000000000000000000000000000000000000`: the contents of the first argument: the UTF-8 (equal to ASCII in this case) encoding of `"dave"`, padded on the right to 32 bytes.
 
* `0x0000000000000000000000000000000000000000000000000000000000000003`: the data part of the third argument, it starts with the length of the array in elements, in this case, 3.
 
* `0x0000000000000000000000000000000000000000000000000000000000000001`: the first entry of the third parameter.
 
* `0x0000000000000000000000000000000000000000000000000000000000000002`: the second entry of the third parameter.
 
* `0x0000000000000000000000000000000000000000000000000000000000000003`: the third entry of the third parameter.
 
In total:
0xa5643bf20000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003
## Use of Dynamic Types[](#use-of-dynamic-types "Link to this heading")
A call to a function with the signature `f(uint256,uint32[],bytes10,bytes)` with values `(0x123, [0x456, 0x789], "1234567890", "Hello, world!")` is encoded in the following way:
We take the first four bytes of `keccak("f(uint256,uint32[],bytes10,bytes)")`, i.e. `0x8be65246`. Then we encode the head parts of all four arguments. For the static types `uint256` and `bytes10`, these are directly the values we want to pass, whereas for the dynamic types `uint32[]` and `bytes`, we use the offset in bytes to the start of their data area, measured from the start of the value encoding (i.e. not counting the first four bytes containing the hash of the function signature). These are:
* `0x0000000000000000000000000000000000000000000000000000000000000123` (`0x123` padded to 32 bytes)
 
* `0x0000000000000000000000000000000000000000000000000000000000000080` (offset to start of data part of second parameter, 4\*32 bytes, exactly the size of the head part)
 
* `0x3132333435363738393000000000000000000000000000000000000000000000` (`"1234567890"` padded to 32 bytes on the right)
 
* `0x00000000000000000000000000000000000000000000000000000000000000e0` (offset to start of data part of fourth parameter = offset to start of data part of first dynamic parameter + size of data part of first dynamic parameter = 4\*32 + 3\*32 (see below))
 
After this, the data part of the first dynamic argument, `[0x456, 0x789]` follows:
* `0x0000000000000000000000000000000000000000000000000000000000000002` (number of elements of the array, 2)
 
* `0x0000000000000000000000000000000000000000000000000000000000000456` (first element)
 
* `0x0000000000000000000000000000000000000000000000000000000000000789` (second element)
 
Finally, we encode the data part of the second dynamic argument, `"Hello, world!"`:
* `0x000000000000000000000000000000000000000000000000000000000000000d` (number of elements (bytes in this case): 13)
 
* `0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000` (`"Hello, world!"` padded to 32 bytes on the right)
 
All together, the encoding is (newline after function selector and each 32-bytes for clarity):
0x8be65246
 0000000000000000000000000000000000000000000000000000000000000123
 0000000000000000000000000000000000000000000000000000000000000080
 3132333435363738393000000000000000000000000000000000000000000000
 00000000000000000000000000000000000000000000000000000000000000e0
 0000000000000000000000000000000000000000000000000000000000000002
 0000000000000000000000000000000000000000000000000000000000000456
 0000000000000000000000000000000000000000000000000000000000000789
 000000000000000000000000000000000000000000000000000000000000000d
 48656c6c6f2c20776f726c642100000000000000000000000000000000000000
Let us apply the same principle to encode the data for a function with a signature `g(uint256[][],string[])` with values `([[1, 2], [3]], ["one", "two", "three"])` but start from the most atomic parts of the encoding:
First we encode the length and data of the first embedded dynamic array `[1, 2]` of the first root array `[[1, 2], [3]]`:
* `0x0000000000000000000000000000000000000000000000000000000000000002` (number of elements in the first array, 2; the elements themselves are `1` and `2`)
 
* `0x0000000000000000000000000000000000000000000000000000000000000001` (first element)
 
* `0x0000000000000000000000000000000000000000000000000000000000000002` (second element)
 
Then we encode the length and data of the second embedded dynamic array `[3]` of the first root array `[[1, 2], [3]]`:
* `0x0000000000000000000000000000000000000000000000000000000000000001` (number of elements in the second array, 1; the element is `3`)
 
* `0x0000000000000000000000000000000000000000000000000000000000000003` (first element)
 
Then we need to find the offsets `a` and `b` for their respective dynamic arrays `[1, 2]` and `[3]`. To calculate the offsets we can take a look at the encoded data of the first root array `[[1, 2], [3]]` enumerating each line in the encoding:
0 - a - offset of \[1, 2\]
1 - b - offset of \[3\]
2 - 0000000000000000000000000000000000000000000000000000000000000002 - count for \[1, 2\]
3 - 0000000000000000000000000000000000000000000000000000000000000001 - encoding of 1
4 - 0000000000000000000000000000000000000000000000000000000000000002 - encoding of 2
5 - 0000000000000000000000000000000000000000000000000000000000000001 - count for \[3\]
6 - 0000000000000000000000000000000000000000000000000000000000000003 - encoding of 3
Offset `a` points to the start of the content of the array `[1, 2]` which is line 2 (64 bytes); thus `a = 0x0000000000000000000000000000000000000000000000000000000000000040`.
Offset `b` points to the start of the content of the array `[3]` which is line 5 (160 bytes); thus `b = 0x00000000000000000000000000000000000000000000000000000000000000a0`.
Then we encode the embedded strings of the second root array:
* `0x0000000000000000000000000000000000000000000000000000000000000003` (number of characters in word `"one"`)
 
* `0x6f6e650000000000000000000000000000000000000000000000000000000000` (utf8 representation of word `"one"`)
 
* `0x0000000000000000000000000000000000000000000000000000000000000003` (number of characters in word `"two"`)
 
* `0x74776f0000000000000000000000000000000000000000000000000000000000` (utf8 representation of word `"two"`)
 
* `0x0000000000000000000000000000000000000000000000000000000000000005` (number of characters in word `"three"`)
 
* `0x7468726565000000000000000000000000000000000000000000000000000000` (utf8 representation of word `"three"`)
 
In parallel to the first root array, since strings are dynamic elements we need to find their offsets `c`, `d` and `e`:
0 - c - offset for "one"
1 - d - offset for "two"
2 - e - offset for "three"
3 - 0000000000000000000000000000000000000000000000000000000000000003 - count for "one"
4 - 6f6e650000000000000000000000000000000000000000000000000000000000 - encoding of "one"
5 - 0000000000000000000000000000000000000000000000000000000000000003 - count for "two"
6 - 74776f0000000000000000000000000000000000000000000000000000000000 - encoding of "two"
7 - 0000000000000000000000000000000000000000000000000000000000000005 - count for "three"
8 - 7468726565000000000000000000000000000000000000000000000000000000 - encoding of "three"
Offset `c` points to the start of the content of the string `"one"` which is line 3 (96 bytes); thus `c = 0x0000000000000000000000000000000000000000000000000000000000000060`.
Offset `d` points to the start of the content of the string `"two"` which is line 5 (160 bytes); thus `d = 0x00000000000000000000000000000000000000000000000000000000000000a0`.
Offset `e` points to the start of the content of the string `"three"` which is line 7 (224 bytes); thus `e = 0x00000000000000000000000000000000000000000000000000000000000000e0`.
Note that the encodings of the embedded elements of the root arrays are not dependent on each other and have the same encodings for a function with a signature `g(string[],uint256[][])`.
Then we encode the length of the first root array:
* `0x0000000000000000000000000000000000000000000000000000000000000002` (number of elements in the first root array, 2; the elements themselves are `[1, 2]` and `[3]`)
 
Then we encode the length of the second root array:
* `0x0000000000000000000000000000000000000000000000000000000000000003` (number of strings in the second root array, 3; the strings themselves are `"one"`, `"two"` and `"three"`)
 
Finally we find the offsets `f` and `g` for their respective root dynamic arrays `[[1, 2], [3]]` and `["one", "two", "three"]`, and assemble parts in the correct order:
0x2289b18c - function signature
 0 - f - offset of \[\[1, 2\], \[3\]\]
 1 - g - offset of \["one", "two", "three"\]
 2 - 0000000000000000000000000000000000000000000000000000000000000002 - count for \[\[1, 2\], \[3\]\]
 3 - 0000000000000000000000000000000000000000000000000000000000000040 - offset of \[1, 2\]
 4 - 00000000000000000000000000000000000000000000000000000000000000a0 - offset of \[3\]
 5 - 0000000000000000000000000000000000000000000000000000000000000002 - count for \[1, 2\]
 6 - 0000000000000000000000000000000000000000000000000000000000000001 - encoding of 1
 7 - 0000000000000000000000000000000000000000000000000000000000000002 - encoding of 2
 8 - 0000000000000000000000000000000000000000000000000000000000000001 - count for \[3\]
 9 - 0000000000000000000000000000000000000000000000000000000000000003 - encoding of 3
10 - 0000000000000000000000000000000000000000000000000000000000000003 - count for \["one", "two", "three"\]
11 - 0000000000000000000000000000000000000000000000000000000000000060 - offset for "one"
12 - 00000000000000000000000000000000000000000000000000000000000000a0 - offset for "two"
13 - 00000000000000000000000000000000000000000000000000000000000000e0 - offset for "three"
14 - 0000000000000000000000000000000000000000000000000000000000000003 - count for "one"
15 - 6f6e650000000000000000000000000000000000000000000000000000000000 - encoding of "one"
16 - 0000000000000000000000000000000000000000000000000000000000000003 - count for "two"
17 - 74776f0000000000000000000000000000000000000000000000000000000000 - encoding of "two"
18 - 0000000000000000000000000000000000000000000000000000000000000005 - count for "three"
19 - 7468726565000000000000000000000000000000000000000000000000000000 - encoding of "three"
Offset `f` points to the start of the content of the array `[[1, 2], [3]]` which is line 2 (64 bytes); thus `f = 0x0000000000000000000000000000000000000000000000000000000000000040`.
Offset `g` points to the start of the content of the array `["one", "two", "three"]` which is line 10 (320 bytes); thus `g = 0x0000000000000000000000000000000000000000000000000000000000000140`.
## Events[](#events "Link to this heading")
Events are an abstraction of the Ethereum logging/event-watching protocol. Log entries provide the contract’s address, a series of up to four topics and some arbitrary length binary data. Events leverage the existing function ABI in order to interpret this (together with an interface spec) as a properly typed structure.
Given an event name and series of event parameters, we split them into two sub-series: those which are indexed and those which are not. Those which are indexed, which may number up to 3 (for non-anonymous events) or 4 (for anonymous ones), are used alongside the Keccak hash of the event signature to form the topics of the log entry. Those which are not indexed form the byte array of the event.
In effect, a log entry using this ABI is described as:
* `address`: the address of the contract (intrinsically provided by Ethereum);
 
* `topics[0]`: `keccak(EVENT_NAME+"("+EVENT_ARGS.map(canonical_type_of).join(",")+")")` (`canonical_type_of` is a function that simply returns the canonical type of a given argument, e.g. for `uint indexed foo`, it would return `uint256`). This value is only present in `topics[0]` if the event is not declared as `anonymous`;
 
* `topics[n]`: `abi_encode(EVENT_INDEXED_ARGS[n - 1])` if the event is not declared as `anonymous` or `abi_encode(EVENT_INDEXED_ARGS[n])` if it is (`EVENT_INDEXED_ARGS` is the series of `EVENT_ARGS` that are indexed);
 
* `data`: ABI encoding of `EVENT_NON_INDEXED_ARGS` (`EVENT_NON_INDEXED_ARGS` is the series of `EVENT_ARGS` that are not indexed, `abi_encode` is the ABI encoding function used for returning a series of typed values from a function, as described above).
 
For all types of length at most 32 bytes, the `EVENT_INDEXED_ARGS` array contains the value directly, padded or sign-extended (for signed integers) to 32 bytes, just as for regular ABI encoding. However, for all “complex” types or types of dynamic length, including all arrays, `string`, `bytes` and structs, `EVENT_INDEXED_ARGS` will contain the _Keccak hash_ of a special in-place encoded value (see [Encoding of Indexed Event Parameters](#indexed-event-encoding)), rather than the encoded value directly. This allows applications to efficiently query for values of dynamic-length types (by setting the hash of the encoded value as the topic), but leaves applications unable to decode indexed values they have not queried for. For dynamic-length types, application developers face a trade-off between fast search for predetermined values (if the argument is indexed) and legibility of arbitrary values (which requires that the arguments not be indexed). Developers may overcome this tradeoff and achieve both efficient search and arbitrary legibility by defining events with two arguments — one indexed, one not — intended to hold the same value.
## Errors[](#errors "Link to this heading")
In case of a failure inside a contract, the contract can use a special opcode to abort execution and revert all state changes. In addition to these effects, descriptive data can be returned to the caller. This descriptive data is the encoding of an error and its arguments in the same way as data for a function call.
As an example, let us consider the following contract whose `transfer` function always reverts with a custom error of “insufficient balance”:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCmNvbnRyYWN0IFRlc3RUb2tlbiB7CiAgICBlcnJvciBJbnN1ZmZpY2llbnRCYWxhbmNlKHVpbnQyNTYgYXZhaWxhYmxlLCB1aW50MjU2IHJlcXVpcmVkKTsKICAgIGZ1bmN0aW9uIHRyYW5zZmVyKGFkZHJlc3MgLyp0byovLCB1aW50IGFtb3VudCkgcHVibGljIHB1cmUgewogICAgICAgIHJldmVydCBJbnN1ZmZpY2llbnRCYWxhbmNlKDAsIGFtb3VudCk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract TestToken {
 error InsufficientBalance(uint256 available, uint256 required);
 function transfer(address /\*to\*/, uint amount) public pure {
 revert InsufficientBalance(0, amount);
 }
}
The return data would be encoded in the same way as the function call `InsufficientBalance(0, amount)` to the function `InsufficientBalance(uint256,uint256)`, i.e. `0xcf479181`, `uint256(0)`, `uint256(amount)`.
The error selectors `0x00000000` and `0xffffffff` are reserved for future use.
Warning
Never trust error data. The error data by default bubbles up through the chain of external calls, which means that a contract may receive an error not defined in any of the contracts it calls directly. Furthermore, any contract can fake any error by returning data that matches an error signature, even if the error is not defined anywhere.
## JSON[](#json "Link to this heading")
The JSON format for a contract’s interface is given by an array of function, event and error descriptions. A function description is a JSON object with the fields:
* `type`: `"function"`, `"constructor"`, `"receive"` (the [“receive Ether” function](https://docs.soliditylang.org/en/v0.8.30/contracts.html#receive-ether-function)) or `"fallback"` (the [“default” function](https://docs.soliditylang.org/en/v0.8.30/contracts.html#fallback-function));
 
* `name`: the name of the function;
 
* `inputs`: an array of objects, each of which contains:
 
 * `name`: the name of the parameter.
 
 * `type`: the canonical type of the parameter (more below).
 
 * `components`: used for tuple types (more below).
 
* `outputs`: an array of objects similar to `inputs`.
 
* `stateMutability`: a string with one of the following values: `pure` ([specified to not read blockchain state](https://docs.soliditylang.org/en/v0.8.30/contracts.html#pure-functions)), `view` ([specified to not modify the blockchain state](https://docs.soliditylang.org/en/v0.8.30/contracts.html#view-functions)), `nonpayable` (function does not accept Ether - the default) and `payable` (function accepts Ether).
 
Constructor, receive, and fallback never have `name` or `outputs`. Receive and fallback do not have `inputs` either.
Note
Sending non-zero Ether to non-payable function will revert the transaction.
Note
The state mutability `nonpayable` is reflected in Solidity by not specifying a state mutability modifier at all.
An event description is a JSON object with fairly similar fields:
* `type`: always `"event"`
 
* `name`: the name of the event.
 
* `inputs`: an array of objects, each of which contains:
 
 * `name`: the name of the parameter.
 
 * `type`: the canonical type of the parameter (more below).
 
 * `components`: used for tuple types (more below).
 
 * `indexed`: `true` if the field is part of the log’s topics, `false` if it is one of the log’s data segments.
 
* `anonymous`: `true` if the event was declared as `anonymous`.
 
Errors look as follows:
* `type`: always `"error"`
 
* `name`: the name of the error.
 
* `inputs`: an array of objects, each of which contains:
 
 * `name`: the name of the parameter.
 
 * `type`: the canonical type of the parameter (more below).
 
 * `components`: used for tuple types (more below).
 
Note
There can be multiple errors with the same name and even with identical signature in the JSON array; for example, if the errors originate from different files in the smart contract or are referenced from another smart contract. For the ABI, only the name of the error itself is relevant and not where it is defined.
For example,
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCgpjb250cmFjdCBUZXN0IHsKICAgIGNvbnN0cnVjdG9yKCkgeyBiID0gaGV4IjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyIjsgfQogICAgZXZlbnQgRXZlbnQodWludCBpbmRleGVkIGEsIGJ5dGVzMzIgYik7CiAgICBldmVudCBFdmVudDIodWludCBpbmRleGVkIGEsIGJ5dGVzMzIgYik7CiAgICBlcnJvciBJbnN1ZmZpY2llbnRCYWxhbmNlKHVpbnQyNTYgYXZhaWxhYmxlLCB1aW50MjU2IHJlcXVpcmVkKTsKICAgIGZ1bmN0aW9uIGZvbyh1aW50IGEpIHB1YmxpYyB7IGVtaXQgRXZlbnQoYSwgYik7IH0KICAgIGJ5dGVzMzIgYjsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract Test {
 constructor() { b \= hex"12345678901234567890123456789012"; }
 event Event(uint indexed a, bytes32 b);
 event Event2(uint indexed a, bytes32 b);
 error InsufficientBalance(uint256 available, uint256 required);
 function foo(uint a) public { emit Event(a, b); }
 bytes32 b;
}
would result in the JSON:
\[{
"type":"error",
"inputs": \[{"name":"available","type":"uint256"},{"name":"required","type":"uint256"}\],
"name":"InsufficientBalance"
}, {
"type":"event",
"inputs": \[{"name":"a","type":"uint256","indexed":true},{"name":"b","type":"bytes32","indexed":false}\],
"name":"Event"
}, {
"type":"event",
"inputs": \[{"name":"a","type":"uint256","indexed":true},{"name":"b","type":"bytes32","indexed":false}\],
"name":"Event2"
}, {
"type":"function",
"inputs": \[{"name":"a","type":"uint256"}\],
"name":"foo",
"outputs": \[\]
}\]
### Handling tuple types[](#handling-tuple-types "Link to this heading")
Despite the fact that names are intentionally not part of the ABI encoding, they do make a lot of sense to be included in the JSON to enable displaying it to the end user. The structure is nested in the following way:
An object with members `name`, `type` and potentially `components` describes a typed variable. The canonical type is determined until a tuple type is reached and the string description up to that point is stored in `type` prefix with the word `tuple`, i.e. it will be `tuple` followed by a sequence of `[]` and `[k]` with integers `k`. The components of the tuple are then stored in the member `components`, which is of an array type and has the same structure as the top-level object except that `indexed` is not allowed there.
As an example, the code
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjUgPDAuOS4wOwpwcmFnbWEgYWJpY29kZXIgdjI7Cgpjb250cmFjdCBUZXN0IHsKICAgIHN0cnVjdCBTIHsgdWludCBhOyB1aW50W10gYjsgVFtdIGM7IH0KICAgIHN0cnVjdCBUIHsgdWludCB4OyB1aW50IHk7IH0KICAgIGZ1bmN0aW9uIGYoUyBtZW1vcnksIFQgbWVtb3J5LCB1aW50KSBwdWJsaWMgcHVyZSB7fQogICAgZnVuY3Rpb24gZygpIHB1YmxpYyBwdXJlIHJldHVybnMgKFMgbWVtb3J5LCBUIG1lbW9yeSwgdWludCkge30KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.5 <0.9.0;
pragma abicoder v2;
contract Test {
 struct S { uint a; uint\[\] b; T\[\] c; }
 struct T { uint x; uint y; }
 function f(S memory, T memory, uint) public pure {}
 function g() public pure returns (S memory, T memory, uint) {}
}
would result in the JSON:
\[
 {
 "name": "f",
 "type": "function",
 "inputs": \[
 {
 "name": "s",
 "type": "tuple",
 "components": \[
 {
 "name": "a",
 "type": "uint256"
 },
 {
 "name": "b",
 "type": "uint256\[\]"
 },
 {
 "name": "c",
 "type": "tuple\[\]",
 "components": \[
 {
 "name": "x",
 "type": "uint256"
 },
 {
 "name": "y",
 "type": "uint256"
 }
 \]
 }
 \]
 },
 {
 "name": "t",
 "type": "tuple",
 "components": \[
 {
 "name": "x",
 "type": "uint256"
 },
 {
 "name": "y",
 "type": "uint256"
 }
 \]
 },
 {
 "name": "a",
 "type": "uint256"
 }
 \],
 "outputs": \[\]
 }
\]
## Strict Encoding Mode[](#strict-encoding-mode "Link to this heading")
Strict encoding mode is the mode that leads to exactly the same encoding as defined in the formal specification above. This means that offsets have to be as small as possible while still not creating overlaps in the data areas, and thus no gaps are allowed.
Usually, ABI decoders are written in a straightforward way by just following offset pointers, but some decoders might enforce strict mode. The Solidity ABI decoder currently does not enforce strict mode, but the encoder always creates data in strict mode.
## Non-standard Packed Mode[](#non-standard-packed-mode "Link to this heading")
Through `abi.encodePacked()`, Solidity supports a non-standard packed mode where:
* types shorter than 32 bytes are concatenated directly, without padding or sign extension
 
* dynamic types are encoded in-place and without the length.
 
* array elements are padded, but still encoded in-place
 
Furthermore, structs as well as nested arrays are not supported.
As an example, the encoding of `int16(-1), bytes1(0x42), uint16(0x03), string("Hello, world!")` results in:
0xffff42000348656c6c6f2c20776f726c6421
 ^^^^ int16(-1)
 ^^ bytes1(0x42)
 ^^^^ uint16(0x03)
 ^^^^^^^^^^^^^^^^^^^^^^^^^^ string("Hello, world!") without a length field
More specifically:
* During the encoding, everything is encoded in-place. This means that there is no distinction between head and tail, as in the ABI encoding, and the length of an array is not encoded.
 
* The direct arguments of `abi.encodePacked` are encoded without padding, as long as they are not arrays (or `string` or `bytes`).
 
* The encoding of an array is the concatenation of the encoding of its elements **with** padding.
 
* Dynamically-sized types like `string`, `bytes` or `uint[]` are encoded without their length field.
 
* The encoding of `string` or `bytes` does not apply padding at the end, unless it is part of an array or struct (then it is padded to a multiple of 32 bytes).
 
In general, the encoding is ambiguous as soon as there are two dynamically-sized elements, because of the missing length field.
If padding is needed, explicit type conversions can be used: `abi.encodePacked(uint16(0x12)) == hex"0012"`.
Since packed encoding is not used when calling functions, there is no special support for prepending a function selector. Since the encoding is ambiguous, there is no decoding function.
Warning
If you use `keccak256(abi.encodePacked(a, b))` and both `a` and `b` are dynamic types, it is easy to craft collisions in the hash value by moving parts of `a` into `b` and vice-versa. More specifically, `abi.encodePacked("a", "bc") == abi.encodePacked("ab", "c")`. If you use `abi.encodePacked` for signatures, authentication or data integrity, make sure to always use the same types and check that at most one of them is dynamic. Unless there is a compelling reason, `abi.encode` should be preferred.
## Encoding of Indexed Event Parameters[](#encoding-of-indexed-event-parameters "Link to this heading")
Indexed event parameters that are not value types, i.e. arrays and structs are not stored directly but instead a Keccak-256 hash of an encoding is stored. This encoding is defined as follows:
* the encoding of a `bytes` and `string` value is just the string contents without any padding or length prefix.
 
* the encoding of a struct is the concatenation of the encoding of its members, always padded to a multiple of 32 bytes (even `bytes` and `string`).
 
* the encoding of an array (both dynamically- and statically-sized) is the concatenation of the encoding of its elements, always padded to a multiple of 32 bytes (even `bytes` and `string`) and without any length prefix
 
In the above, as usual, a negative number is padded by sign extension and not zero padded. `bytesNN` types are padded on the right while `uintNN` / `intNN` are padded on the left.
Warning
The encoding of a struct is ambiguous if it contains more than one dynamically-sized array. Because of that, always re-check the event data and do not rely on the search result based on the indexed parameters alone.

# [Contract Metadata — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/metadata.html) 
 _https://docs.soliditylang.org/en/latest/metadata.html_

The Solidity compiler automatically generates a JSON file. The file contains two kinds of information about the compiled contract:
* How to interact with the contract: ABI, and NatSpec documentation.
 
* How to reproduce the compilation and verify a deployed contract: compiler version, compiler settings, and source files used.
 
The compiler appends by default the IPFS hash of the metadata file to the end of the runtime bytecode (not necessarily the creation bytecode) of each contract, so that, if published, you can retrieve the file in an authenticated way without having to resort to a centralized data provider. The other available options are the Swarm hash and not appending the metadata hash to the bytecode. These can be configured via the [Standard JSON Interface](https://docs.soliditylang.org/en/latest/using-the-compiler.html#compiler-api).
You have to publish the metadata file to IPFS, Swarm, or another service so that others can access it. You create the file by using the `solc --metadata` command together with the `--output-dir` parameter. Without the parameter, the metadata will be written to standard output. The metadata contains IPFS and Swarm references to the source code, so you have to upload all source files in addition to the metadata file. For IPFS, the hash contained in the CID returned by `ipfs add` (not the direct sha2-256 hash of the file) shall match with the one contained in the bytecode.
The metadata file has the following format. The example below is presented in a human-readable way. Properly formatted metadata should use quotes correctly, reduce whitespace to a minimum, and sort the keys of all objects in alphabetical order to arrive at a canonical formatting. Comments are not permitted and are used here only for explanatory purposes.
{
 // Required: Details about the compiler, contents are specific
 // to the language.
 "compiler": {
 // Optional: Hash of the compiler binary which produced this output
 "keccak256": "0x123...",
 // Required for Solidity: Version of the compiler
 "version": "0.8.2+commit.661d1103"
 },
 // Required: Source code language, basically selects a "sub-version"
 // of the specification
 "language": "Solidity",
 // Required: Generated information about the contract.
 "output": {
 // Required: ABI definition of the contract. See "Contract ABI Specification"
 "abi": \[/\* ... \*/\],
 // Required: NatSpec developer documentation of the contract. See https://docs.soliditylang.org/en/latest/natspec-format.html for details.
 "devdoc": {
 // Contents of the @author NatSpec field of the contract
 "author": "John Doe",
 // Contents of the @dev NatSpec field of the contract
 "details": "Interface of the ERC20 standard as defined in the EIP. See https://eips.ethereum.org/EIPS/eip-20 for details",
 "errors": {
 "MintToZeroAddress()" : {
 "details": "Cannot mint to zero address"
 }
 },
 "events": {
 "Transfer(address,address,uint256)": {
 "details": "Emitted when \`value\` tokens are moved from one account (\`from\`) toanother (\`to\`).",
 "params": {
 "from": "The sender address",
 "to": "The receiver address",
 "value": "The token amount"
 }
 }
 },
 "kind": "dev",
 "methods": {
 "transfer(address,uint256)": {
 // Contents of the @dev NatSpec field of the method
 "details": "Returns a boolean value indicating whether the operation succeeded. Must be called by the token holder address",
 // Contents of the @param NatSpec fields of the method
 "params": {
 "\_value": "The amount tokens to be transferred",
 "\_to": "The receiver address"
 },
 // Contents of the @return NatSpec field.
 "returns": {
 // Return var name (here "success") if exists. "\_0" as key if return var is unnamed
 "success": "a boolean value indicating whether the operation succeeded"
 }
 }
 },
 "stateVariables": {
 "owner": {
 // Contents of the @dev NatSpec field of the state variable
 "details": "Must be set during contract creation. Can then only be changed by the owner"
 }
 },
 // Contents of the @title NatSpec field of the contract
 "title": "MyERC20: an example ERC20",
 "version": 1 // NatSpec version
 },
 // Required: NatSpec user documentation of the contract. See "NatSpec Format"
 "userdoc": {
 "errors": {
 "ApprovalCallerNotOwnerNorApproved()": \[
 {
 "notice": "The caller must own the token or be an approved operator."
 }
 \]
 },
 "events": {
 "Transfer(address,address,uint256)": {
 "notice": "\`\_value\` tokens have been moved from \`from\` to \`to\`"
 }
 },
 "kind": "user",
 "methods": {
 "transfer(address,uint256)": {
 "notice": "Transfers \`\_value\` tokens to address \`\_to\`"
 }
 },
 "version": 1 // NatSpec version
 }
 },
 // Required: Compiler settings.
 // Reflects the settings in the JSON input during compilation, except:
 // - Different format: "libraries" field
 // - Added field in metadata.settings: "compilationTarget"
 // - Not in metadata.settings: "stopAfter", "debug.debugInfo", "outputSelection"
 // See the standard JSON input's "settings" field docs for the rest.
 "settings": {
 // Required for Solidity: File path and the name of the contract or library this
 // metadata is created for. This field is not present in the standard JSON input settings.
 "compilationTarget": {
 "myDirectory/myFile.sol": "MyContract"
 },
 // Required for Solidity: Addresses for libraries used.
 // Note that metadata has a different format for "libraries" field than the standard JSON input.
 // metadata format = { "MyLib.sol:MyLib": "0x123123..." }
 // standard JSON input format = { "MyLib.sol": { "MyLib": "0x123123..." } }
 "libraries": {
 "MyLib.sol:MyLib": "0x123123..."
 },
 // ...
 // ...
 // ...
 // The rest of the fields and their defaults same as in std JSON input.
 },
 // Required: Compilation source files/source units, keys are file paths
 "sources": {
 "settable": {
 // Required (unless "url" is used): literal contents of the source file
 "content": "contract settable is owned { uint256 private x = 0; function set(uint256 \_x) public { if (msg.sender == owner) x = \_x; } }",
 // Required: keccak256 hash of the source file
 "keccak256": "0x234..."
 },
 "myDirectory/myFile.sol": {
 // Required: keccak256 hash of the source file
 "keccak256": "0x123...",
 // Optional: SPDX license identifier as given in the source file
 "license": "MIT",
 // Required (unless "content" is used, see above): Sorted URL(s)
 // to the source file, protocol is more or less arbitrary, but an
 // IPFS URL is recommended
 "urls": \[ "bzz-raw://7d7a...", "dweb:/ipfs/QmN..." \]
 }
 },
 // Required: The version of the metadata format
 "version": 1
}
Warning
Since the bytecode of the resulting contract contains the metadata hash by default, any change to the metadata might result in a change of the bytecode. This includes changes to a filename or path, and since the metadata includes a hash of all the sources used, a single whitespace change results in different metadata, and different bytecode.
Note
The ABI definition above has no fixed order. It can change with compiler versions. Starting from Solidity version 0.5.12, though, the array maintains a certain order.
## Encoding of the Metadata Hash in the Bytecode[](#encoding-of-the-metadata-hash-in-the-bytecode "Link to this heading")
The compiler currently by default appends the [IPFS hash (in CID v0)](https://docs.ipfs.tech/concepts/content-addressing/#version-0-v0) of the canonical metadata file and the compiler version to the end of the bytecode. Optionally, a Swarm hash instead of the IPFS, or an experimental flag is used. Below are all the possible fields:
{
 "ipfs": "<metadata hash>",
 // If "bytecodeHash" was "bzzr1" in compiler settings not "ipfs" but "bzzr1"
 "bzzr1": "<metadata hash>",
 // Previous versions were using "bzzr0" instead of "bzzr1"
 "bzzr0": "<metadata hash>",
 // If any experimental features that affect code generation are used
 "experimental": true,
 "solc": "<compiler version>"
}
Because we might support other ways to retrieve the metadata file in the future, this information is stored [CBOR](https://tools.ietf.org/html/rfc7049)\-encoded. The last two bytes in the bytecode indicate the length of the CBOR encoded information. By looking at this length, the relevant part of the bytecode can be decoded with a CBOR decoder.
Check the [Metadata Playground](https://playground.sourcify.dev/) to see it in action.
Whereas release builds of solc use a 3 byte encoding of the version as shown above (one byte each for major, minor and patch version number), pre-release builds will instead use a complete version string including commit hash and build date.
The commandline flag `--no-cbor-metadata` can be used to skip metadata from getting appended at the end of the deployed bytecode. Equivalently, the boolean field `settings.metadata.appendCBOR` in Standard JSON input can be set to false.
Note
The CBOR mapping can also contain other keys, so it is better to fully decode the data by looking at the end of the bytecode for the CBOR length, and to use a proper CBOR parser. Do not rely on it starting with `0xa264` or `0xa2 0x64 'i' 'p' 'f' 's'`.
## Usage for Automatic Interface Generation and NatSpec[](#usage-for-automatic-interface-generation-and-natspec "Link to this heading")
The metadata is used in the following way: A component that wants to interact with a contract (e.g. a wallet) retrieves the code of the contract. It decodes the CBOR encoded section containing the IPFS/Swarm hash of the metadata file. With that hash, the metadata file is retrieved. That file is JSON-decoded into a structure like above.
The component can then use the ABI to automatically generate a rudimentary user interface for the contract.
Furthermore, the wallet can use the NatSpec user documentation to display a human-readable confirmation message to the user whenever they interact with the contract, together with requesting authorization for the transaction signature.
For additional information, read [Ethereum Natural Language Specification (NatSpec) format](https://docs.soliditylang.org/en/latest/natspec-format.html).
## Usage for Source Code Verification[](#usage-for-source-code-verification "Link to this heading")
If pinned/published, it is possible to retrieve the metadata of the contract from IPFS/Swarm. The metadata file also contains the URLs or the IPFS hashes of the source files, as well as the compilation settings, i.e. everything needed to reproduce a compilation.
With this information it is then possible to verify the source code of a contract by reproducing the compilation, and comparing the bytecode from the compilation with the bytecode of the deployed contract.
This automatically verifies the metadata since its hash is part of the bytecode, as well as the source codes, because their hashes are part of the metadata. Any change in the files or settings would result in a different metadata hash. The metadata here serves as a fingerprint of the whole compilation.
[Sourcify](https://sourcify.dev/) makes use of this feature for “full/perfect verification”, as well as pinning the files publicly on IPFS to be accessed with the metadata hash.

# [Language Influences — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/language-influences.html) 
 _https://docs.soliditylang.org/tr/latest/language-influences.html_

[Solidity](https://docs.soliditylang.org/tr/latest/index.html)
Solidity is a [curly-bracket language](https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Curly-bracket_languages) that has been influenced and inspired by several well-known programming languages.
Solidity is most profoundly influenced by C++, but also borrowed concepts from languages like Python, JavaScript, and others.
The influence from C++ can be seen in the syntax for variable declarations, for loops, the concept of overloading functions, implicit and explicit type conversions and many other details.
In the early days of the language, Solidity used to be partly influenced by JavaScript. This was due to function-level scoping of variables and the use of the keyword `var`. The JavaScript influence was reduced starting from version 0.4.0. Now, the main remaining similarity to JavaScript is that functions are defined using the keyword `function`. Solidity also supports import syntax and semantics that are similar to those available in JavaScript. Besides those points, Solidity looks like most other curly-bracket languages and has no major JavaScript influence anymore.
Another influence to Solidity was Python. Solidity’s modifiers were added trying to model Python’s decorators with a much more restricted functionality. Furthermore, multiple inheritance, C3 linearization, and the `super` keyword are taken from Python as well as the general assignment and copy semantics of value and reference types.

# [Yul — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/yul.html) 
 _https://docs.soliditylang.org/en/v0.8.30/yul.html_

Yul (previously also called JULIA or IULIA) is an intermediate language that can be compiled to bytecode for different backends.
It can be used in stand-alone mode and for “inline assembly” inside Solidity. The compiler uses Yul as an intermediate language in the IR-based code generator (“new codegen” or “IR-based codegen”). Yul is a good target for high-level optimisation stages that can benefit all target platforms equally.
## Motivation and High-level Description[](#motivation-and-high-level-description "Link to this heading")
The design of Yul tries to achieve several goals:
1. Programs written in Yul should be readable, even if the code is generated by a compiler from Solidity or another high-level language.
 
2. Control flow should be easy to understand to help in manual inspection, formal verification and optimization.
 
3. The translation from Yul to bytecode should be as straightforward as possible.
 
4. Yul should be suitable for whole-program optimization.
 
In order to achieve the first and second goal, Yul provides high-level constructs like `for` loops, `if` and `switch` statements and function calls. These should be sufficient for adequately representing the control flow for assembly programs. Therefore, no explicit statements for `SWAP`, `DUP`, `JUMPDEST`, `JUMP` and `JUMPI` are provided, because the first two obfuscate the data flow and the last two obfuscate control flow. Furthermore, functional statements of the form `mul(add(x, y), 7)` are preferred over pure opcode statements like `7 y x add mul` because in the first form, it is much easier to see which operand is used for which opcode.
Even though it was designed for stack machines, Yul does not expose the complexity of the stack itself. The programmer or auditor should not have to worry about the stack.
The third goal is achieved by compiling the higher level constructs to bytecode in a very regular way. The only non-local operation performed by the assembler is name lookup of user-defined identifiers (functions, variables, …) and cleanup of local variables from the stack.
To avoid confusions between concepts like values and references, Yul is statically typed. At the same time, there is a default type (usually the integer word of the target machine) that can always be omitted to help readability.
To keep the language simple and flexible, Yul does not have any built-in operations, functions or types in its pure form. These are added together with their semantics when specifying a dialect of Yul, which allows specializing Yul to the requirements of different target platforms and feature sets.
Currently, there is only one specified dialect of Yul. This dialect uses the EVM opcodes as builtin functions (see below) and defines only the type `u256`, which is the native 256-bit type of the EVM. Because of that, we will not provide types in the examples below.
## Simple Example[](#simple-example "Link to this heading")
The following example program is written in the EVM dialect and computes exponentiation. It can be compiled using `solc --strict-assembly`. The builtin functions `mul` and `div` compute product and division, respectively.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ewogICAgZnVuY3Rpb24gcG93ZXIoYmFzZSwgZXhwb25lbnQpIC0+IHJlc3VsdAogICAgewogICAgICAgIHN3aXRjaCBleHBvbmVudAogICAgICAgIGNhc2UgMCB7IHJlc3VsdCA6PSAxIH0KICAgICAgICBjYXNlIDEgeyByZXN1bHQgOj0gYmFzZSB9CiAgICAgICAgZGVmYXVsdAogICAgICAgIHsKICAgICAgICAgICAgcmVzdWx0IDo9IHBvd2VyKG11bChiYXNlLCBiYXNlKSwgZGl2KGV4cG9uZW50LCAyKSkKICAgICAgICAgICAgc3dpdGNoIG1vZChleHBvbmVudCwgMikKICAgICAgICAgICAgICAgIGNhc2UgMSB7IHJlc3VsdCA6PSBtdWwoYmFzZSwgcmVzdWx0KSB9CiAgICAgICAgfQogICAgfQp9)
{
 function power(base, exponent) \-> result
 {
 switch exponent
 case 0 { result := 1 }
 case 1 { result := base }
 default
 {
 result := power(mul(base, base), div(exponent, 2))
 switch mod(exponent, 2)
 case 1 { result := mul(base, result) }
 }
 }
}
It is also possible to implement the same function using a for-loop instead of with recursion. Here, `lt(a, b)` computes whether `a` is less than `b`.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ewogICAgZnVuY3Rpb24gcG93ZXIoYmFzZSwgZXhwb25lbnQpIC0+IHJlc3VsdAogICAgewogICAgICAgIHJlc3VsdCA6PSAxCiAgICAgICAgZm9yIHsgbGV0IGkgOj0gMCB9IGx0KGksIGV4cG9uZW50KSB7IGkgOj0gYWRkKGksIDEpIH0KICAgICAgICB7CiAgICAgICAgICAgIHJlc3VsdCA6PSBtdWwocmVzdWx0LCBiYXNlKQogICAgICAgIH0KICAgIH0KfQ==)
{
 function power(base, exponent) \-> result
 {
 result := 1
 for { let i := 0 } lt(i, exponent) { i := add(i, 1) }
 {
 result := mul(result, base)
 }
 }
}
At the [end of the section](#erc20yul), a complete implementation of the ERC-20 standard can be found.
## Stand-Alone Usage[](#stand-alone-usage "Link to this heading")
You can use Yul in its stand-alone form in the EVM dialect using the Solidity compiler. This will use the [Yul object notation](#yul-object) so that it is possible to refer to code as data to deploy contracts. This Yul mode is available for the commandline compiler (use `--strict-assembly`) and for the [standard-json interface](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#compiler-api):
{
 "language": "Yul",
 "sources": { "input.yul": { "content": "{ sstore(0, 1) }" } },
 "settings": {
 "outputSelection": { "\*": { "\*": \["\*"\], "": \[ "\*" \] } },
 "optimizer": { "enabled": true, "details": { "yul": true } }
 }
}
Warning
Yul is in active development and bytecode generation is only fully implemented for the EVM dialect of Yul with EVM 1.0 as target.
## Informal Description of Yul[](#informal-description-of-yul "Link to this heading")
In the following, we will talk about each individual aspect of the Yul language. In examples, we will use the default EVM dialect.
### Syntax[](#syntax "Link to this heading")
Yul parses comments, literals and identifiers in the same way as Solidity, so you can e.g. use `//` and `/* */` to denote comments. There is one exception: Identifiers in Yul can contain dots: `.`.
Yul can specify “objects” that consist of code, data and sub-objects. Please see [Yul Objects](#yul-object) below for details on that. In this section, we are only concerned with the code part of such an object. This code part always consists of a curly-braces delimited block. Most tools support specifying just a code block where an object is expected.
Inside a code block, the following elements can be used (see the later sections for more details):
* literals, e.g. `0x123`, `42` or `"abc"` (strings up to 32 characters)
 
* calls to builtin functions, e.g. `add(1, mload(0))`
 
* variable declarations, e.g. `let x := 7`, `let x := add(y, 3)` or `let x` (initial value of 0 is assigned)
 
* identifiers (variables), e.g. `add(3, x)`
 
* assignments, e.g. `x := add(y, 3)`
 
* blocks where local variables are scoped inside, e.g. `{ let x := 3 { let y := add(x, 1) } }`
 
* if statements, e.g. `if lt(a, b) { sstore(0, 1) }`
 
* switch statements, e.g. `switch mload(0) case 0 { revert() } default { mstore(0, 1) }`
 
* for loops, e.g. `for { let i := 0} lt(i, 10) { i := add(i, 1) } { mstore(i, 7) }`
 
* function definitions, e.g. `function f(a, b) -> c { c := add(a, b) }`
 
Multiple syntactical elements can follow each other simply separated by whitespace, i.e. there is no terminating `;` or newline required.
### Literals[](#literals "Link to this heading")
As literals, you can use:
* Integer constants in decimal or hexadecimal notation.
 
* ASCII strings (e.g. `"abc"`), which may contain hex escapes `\xNN` and Unicode escapes `\uNNNN` where `N` are hexadecimal digits.
 
* Hex strings (e.g. `hex"616263"`).
 
In the EVM dialect of Yul, literals represent 256-bit words as follows:
* Decimal or hexadecimal constants must be less than `2**256`. They represent the 256-bit word with that value as an unsigned integer in big endian encoding.
 
* An ASCII string is first viewed as a byte sequence, by viewing a non-escape ASCII character as a single byte whose value is the ASCII code, an escape `\xNN` as single byte with that value, and an escape `\uNNNN` as the UTF-8 sequence of bytes for that code point. The byte sequence must not exceed 32 bytes. The byte sequence is padded with zeros on the right to reach 32 bytes in length; in other words, the string is stored left-aligned. The padded byte sequence represents a 256-bit word whose most significant 8 bits are the ones from the first byte, i.e. the bytes are interpreted in big endian form.
 
* A hex string is first viewed as a byte sequence, by viewing each pair of contiguous hex digits as a byte. The byte sequence must not exceed 32 bytes (i.e. 64 hex digits), and is treated as above.
 
When compiling for the EVM, this will be translated into an appropriate `PUSHi` instruction. In the following example, `3` and `2` are added resulting in 5 and then the bitwise `and` with the string “abc” is computed. The final value is assigned to a local variable called `x`.
The 32-byte limit above does not apply to string literals passed to builtin functions that require literal arguments (e.g. `setimmutable` or `loadimmutable`). Those strings never end up in the generated bytecode.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=bGV0IHggOj0gYW5kKCJhYmMiLCBhZGQoMywgMikp)
let x := and("abc", add(3, 2))
Unless it is the default type, the type of a literal has to be specified after a colon:
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=Ly8gVGhpcyB3aWxsIG5vdCBjb21waWxlICh1MzIgYW5kIHUyNTYgdHlwZSBub3QgaW1wbGVtZW50ZWQgeWV0KQpsZXQgeCA6PSBhbmQoImFiYyI6dTMyLCBhZGQoMzp1MjU2LCAyOnUyNTYpKQ==)
// This will not compile (u32 and u256 type not implemented yet)
let x := and("abc":u32, add(3:u256, 2:u256))
### Function Calls[](#function-calls "Link to this heading")
Both built-in and user-defined functions (see below) can be called in the same way as shown in the previous example. If the function returns a single value, it can be directly used inside an expression again. If it returns multiple values, they have to be assigned to local variables.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ZnVuY3Rpb24gZih4LCB5KSAtPiBhLCBiIHsgLyogLi4uICovIH0KbXN0b3JlKDB4ODAsIGFkZChtbG9hZCgweDgwKSwgMykpCi8vIEhlcmUsIHRoZSB1c2VyLWRlZmluZWQgZnVuY3Rpb24gYGZgIHJldHVybnMgdHdvIHZhbHVlcy4KbGV0IHgsIHkgOj0gZigxLCBtbG9hZCgwKSk=)
function f(x, y) \-> a, b { /\* ... \*/ }
mstore(0x80, add(mload(0x80), 3))
// Here, the user-defined function \`f\` returns two values.
let x, y := f(1, mload(0))
For built-in functions of the EVM, functional expressions can be directly translated to a stream of opcodes: You just read the expression from right to left to obtain the opcodes. In the case of the second line in the example, this is `PUSH1 3 PUSH1 0x80 MLOAD ADD PUSH1 0x80 MSTORE`.
For calls to user-defined functions, the arguments are also put on the stack from right to left and this is the order in which argument lists are evaluated. The return values, though, are expected on the stack from left to right, i.e. in this example, `y` is on top of the stack and `x` is below it.
### Variable Declarations[](#variable-declarations "Link to this heading")
You can use the `let` keyword to declare variables. A variable is only visible inside the `{...}`\-block it was defined in. When compiling to the EVM, a new stack slot is created that is reserved for the variable and automatically removed again when the end of the block is reached. You can provide an initial value for the variable. If you do not provide a value, the variable will be initialized to zero.
Since variables are stored on the stack, they do not directly influence memory or storage, but they can be used as pointers to memory or storage locations in the built-in functions `mstore`, `mload`, `sstore` and `sload`. Future dialects might introduce specific types for such pointers.
When a variable is referenced, its current value is copied. For the EVM, this translates to a `DUP` instruction.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ewogICAgbGV0IHplcm8gOj0gMAogICAgbGV0IHYgOj0gY2FsbGRhdGFsb2FkKHplcm8pCiAgICB7CiAgICAgICAgbGV0IHkgOj0gYWRkKHNsb2FkKHYpLCAxKQogICAgICAgIHYgOj0geQogICAgfSAvLyB5IGlzICJkZWFsbG9jYXRlZCIgaGVyZQogICAgc3N0b3JlKHYsIHplcm8pCn0gLy8gdiBhbmQgemVybyBhcmUgImRlYWxsb2NhdGVkIiBoZXJl)
{
 let zero := 0
 let v := calldataload(zero)
 {
 let y := add(sload(v), 1)
 v := y
 } // y is "deallocated" here
 sstore(v, zero)
} // v and zero are "deallocated" here
If the declared variable should have a type different from the default type, you denote that following a colon. You can also declare multiple variables in one statement when you assign from a function call that returns multiple values.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=Ly8gVGhpcyB3aWxsIG5vdCBjb21waWxlICh1MzIgYW5kIHUyNTYgdHlwZSBub3QgaW1wbGVtZW50ZWQgeWV0KQp7CiAgICBsZXQgemVybzp1MzIgOj0gMDp1MzIKICAgIGxldCB2OnUyNTYsIHQ6dTMyIDo9IGYoKQogICAgbGV0IHgsIHkgOj0gZygpCn0=)
// This will not compile (u32 and u256 type not implemented yet)
{
 let zero:u32 := 0:u32
 let v:u256, t:u32 := f()
 let x, y := g()
}
Depending on the optimiser settings, the compiler can free the stack slots already after the variable has been used for the last time, even though it is still in scope.
### Assignments[](#assignments "Link to this heading")
Variables can be assigned to after their definition using the `:=` operator. It is possible to assign multiple variables at the same time. For this, the number and types of the values have to match. If you want to assign the values returned from a function that has multiple return parameters, you have to provide multiple variables. The same variable may not occur multiple times on the left-hand side of an assignment, e.g. `x, x := f()` is invalid.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=bGV0IHYgOj0gMAovLyByZS1hc3NpZ24gdgp2IDo9IDIKbGV0IHQgOj0gYWRkKHYsIDIpCmZ1bmN0aW9uIGYoKSAtPiBhLCBiIHsgfQovLyBhc3NpZ24gbXVsdGlwbGUgdmFsdWVzCnYsIHQgOj0gZigp)
let v := 0
// re-assign v
v := 2
let t := add(v, 2)
function f() \-> a, b { }
// assign multiple values
v, t := f()
### If[](#if "Link to this heading")
The if statement can be used for conditionally executing code. No “else” block can be defined. Consider using “switch” instead (see below) if you need multiple alternatives.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=aWYgbHQoY2FsbGRhdGFzaXplKCksIDQpIHsgcmV2ZXJ0KDAsIDApIH0=)
if lt(calldatasize(), 4) { revert(0, 0) }
The curly braces for the body are required.
### Switch[](#switch "Link to this heading")
You can use a switch statement as an extended version of the if statement. It takes the value of an expression and compares it to several literal constants. The branch corresponding to the matching constant is taken. Contrary to other programming languages, for safety reasons, control flow does not continue from one case to the next. There can be a fallback or default case called `default` which is taken if none of the literal constants matches.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ewogICAgbGV0IHggOj0gMAogICAgc3dpdGNoIGNhbGxkYXRhbG9hZCg0KQogICAgY2FzZSAwIHsKICAgICAgICB4IDo9IGNhbGxkYXRhbG9hZCgweDI0KQogICAgfQogICAgZGVmYXVsdCB7CiAgICAgICAgeCA6PSBjYWxsZGF0YWxvYWQoMHg0NCkKICAgIH0KICAgIHNzdG9yZSgwLCBkaXYoeCwgMikpCn0=)
{
 let x := 0
 switch calldataload(4)
 case 0 {
 x := calldataload(0x24)
 }
 default {
 x := calldataload(0x44)
 }
 sstore(0, div(x, 2))
}
The list of cases is not enclosed by curly braces, but the body of a case does require them.
### Loops[](#loops "Link to this heading")
Yul supports for-loops which consist of a header containing an initializing part, a condition, a post-iteration part and a body. The condition has to be an expression, while the other three are blocks. If the initializing part declares any variables at the top level, the scope of these variables extends to all other parts of the loop.
The `break` and `continue` statements can be used in the body to exit the loop or skip to the post-part, respectively.
The following example computes the sum of an area in memory.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ewogICAgbGV0IHggOj0gMAogICAgZm9yIHsgbGV0IGkgOj0gMCB9IGx0KGksIDB4MTAwKSB7IGkgOj0gYWRkKGksIDB4MjApIH0gewogICAgICAgIHggOj0gYWRkKHgsIG1sb2FkKGkpKQogICAgfQp9)
{
 let x := 0
 for { let i := 0 } lt(i, 0x100) { i := add(i, 0x20) } {
 x := add(x, mload(i))
 }
}
For loops can also be used as a replacement for while loops: Simply leave the initialization and post-iteration parts empty.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ewogICAgbGV0IHggOj0gMAogICAgbGV0IGkgOj0gMAogICAgZm9yIHsgfSBsdChpLCAweDEwMCkgeyB9IHsgICAgIC8vIHdoaWxlKGkgPCAweDEwMCkKICAgICAgICB4IDo9IGFkZCh4LCBtbG9hZChpKSkKICAgICAgICBpIDo9IGFkZChpLCAweDIwKQogICAgfQp9)
{
 let x := 0
 let i := 0
 for { } lt(i, 0x100) { } { // while(i < 0x100)
 x := add(x, mload(i))
 i := add(i, 0x20)
 }
}
### Function Declarations[](#function-declarations "Link to this heading")
Yul allows the definition of functions. These should not be confused with functions in Solidity since they are never part of an external interface of a contract and are part of a namespace separate from the one for Solidity functions.
For the EVM, Yul functions take their arguments (and a return PC) from the stack and also put the results onto the stack. User-defined functions and built-in functions are called in exactly the same way.
Functions can be defined anywhere and are visible in the block they are declared in. Inside a function, you cannot access local variables defined outside of that function.
Functions declare parameters and return variables, similar to Solidity. To return a value, you assign it to the return variable(s).
If you call a function that returns multiple values, you have to assign them to multiple variables using `a, b := f(x)` or `let a, b := f(x)`.
The `leave` statement can be used to exit the current function. It works like the `return` statement in other languages just that it does not take a value to return, it just exits the functions and the function will return whatever values are currently assigned to the return variable(s).
Note that the EVM dialect has a built-in function called `return` that quits the full execution context (internal message call) and not just the current yul function.
The following example implements the power function by square-and-multiply.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ewogICAgZnVuY3Rpb24gcG93ZXIoYmFzZSwgZXhwb25lbnQpIC0+IHJlc3VsdCB7CiAgICAgICAgc3dpdGNoIGV4cG9uZW50CiAgICAgICAgY2FzZSAwIHsgcmVzdWx0IDo9IDEgfQogICAgICAgIGNhc2UgMSB7IHJlc3VsdCA6PSBiYXNlIH0KICAgICAgICBkZWZhdWx0IHsKICAgICAgICAgICAgcmVzdWx0IDo9IHBvd2VyKG11bChiYXNlLCBiYXNlKSwgZGl2KGV4cG9uZW50LCAyKSkKICAgICAgICAgICAgc3dpdGNoIG1vZChleHBvbmVudCwgMikKICAgICAgICAgICAgICAgIGNhc2UgMSB7IHJlc3VsdCA6PSBtdWwoYmFzZSwgcmVzdWx0KSB9CiAgICAgICAgfQogICAgfQp9)
{
 function power(base, exponent) \-> result {
 switch exponent
 case 0 { result := 1 }
 case 1 { result := base }
 default {
 result := power(mul(base, base), div(exponent, 2))
 switch mod(exponent, 2)
 case 1 { result := mul(base, result) }
 }
 }
}
## Specification of Yul[](#specification-of-yul "Link to this heading")
This chapter describes Yul code formally. Yul code is usually placed inside Yul objects, which are explained in their own chapter.
Block = '{' Statement\* '}'
Statement =
 Block |
 FunctionDefinition |
 VariableDeclaration |
 Assignment |
 If |
 Expression |
 Switch |
 ForLoop |
 BreakContinue |
 Leave
FunctionDefinition =
 'function' Identifier '(' TypedIdentifierList? ')'
 ( '->' TypedIdentifierList )? Block
VariableDeclaration =
 'let' TypedIdentifierList ( ':=' Expression )?
Assignment =
 IdentifierList ':=' Expression
Expression =
 FunctionCall | Identifier | Literal
If =
 'if' Expression Block
Switch =
 'switch' Expression ( Case+ Default? | Default )
Case =
 'case' Literal Block
Default =
 'default' Block
ForLoop =
 'for' Block Expression Block Block
BreakContinue =
 'break' | 'continue'
Leave = 'leave'
FunctionCall =
 Identifier '(' ( Expression ( ',' Expression )\* )? ')'
Identifier = \[a-zA-Z\_$\] \[a-zA-Z\_$0-9.\]\*
IdentifierList = Identifier ( ',' Identifier)\*
TypeName = Identifier
TypedIdentifierList = Identifier ( ':' TypeName )? ( ',' Identifier ( ':' TypeName )? )\*
Literal =
 (NumberLiteral | StringLiteral | TrueLiteral | FalseLiteral) ( ':' TypeName )?
NumberLiteral = HexNumber | DecimalNumber
StringLiteral = '"' (\[^"\\r\\n\\\\\] | '\\\\' .)\* '"'
TrueLiteral = 'true'
FalseLiteral = 'false'
HexNumber = '0x' \[0-9a-fA-F\]+
DecimalNumber = \[0-9\]+
### Restrictions on the Grammar[](#restrictions-on-the-grammar "Link to this heading")
Apart from those directly imposed by the grammar, the following restrictions apply:
Switches must have at least one case (including the default case). All case values need to have the same type and distinct values. If all possible values of the expression type are covered, a default case is not allowed (i.e. a switch with a `bool` expression that has both a true and a false case do not allow a default case).
Every expression evaluates to zero or more values. Identifiers and Literals evaluate to exactly one value and function calls evaluate to a number of values equal to the number of return variables of the function called.
In variable declarations and assignments, the right-hand-side expression (if present) has to evaluate to a number of values equal to the number of variables on the left-hand-side. This is the only situation where an expression evaluating to more than one value is allowed. The same variable name cannot occur more than once in the left-hand-side of an assignment or variable declaration.
Expressions that are also statements (i.e. at the block level) have to evaluate to zero values.
In all other situations, expressions have to evaluate to exactly one value.
A `continue` or `break` statement can only be used inside the body of a for-loop, as follows. Consider the innermost loop that contains the statement. The loop and the statement must be in the same function, or both must be at the top level. The statement must be in the loop’s body block; it cannot be in the loop’s initialization block or update block. It is worth emphasizing that this restriction applies just to the innermost loop that contains the `continue` or `break` statement: this innermost loop, and therefore the `continue` or `break` statement, may appear anywhere in an outer loop, possibly in an outer loop’s initialization block or update block. For example, the following is legal, because the `break` occurs in the body block of the inner loop, despite also occurring in the update block of the outer loop:
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=Zm9yIHt9IHRydWUgeyBmb3Ige30gdHJ1ZSB7fSB7IGJyZWFrIH0gfQp7Cn0=)
for {} true { for {} true {} { break } }
{
}
The condition part of the for-loop has to evaluate to exactly one value.
The `leave` statement can only be used inside a function.
Functions cannot be defined anywhere inside for loop init blocks.
Literals cannot be larger than their type. The largest type defined is 256-bit wide.
During assignments and function calls, the types of the respective values have to match. There is no implicit type conversion. Type conversion in general can only be achieved if the dialect provides an appropriate built-in function that takes a value of one type and returns a value of a different type.
### Scoping Rules[](#scoping-rules "Link to this heading")
Scopes in Yul are tied to Blocks (exceptions are functions and the for loop as explained below) and all declarations (`FunctionDefinition`, `VariableDeclaration`) introduce new identifiers into these scopes.
Identifiers are visible in the block they are defined in (including all sub-nodes and sub-blocks): Functions are visible in the whole block (even before their definitions) while variables are only visible starting from the statement after the `VariableDeclaration`.
In particular, variables cannot be referenced in the right hand side of their own variable declaration. Functions can be referenced already before their declaration (if they are visible).
As an exception to the general scoping rule, the scope of the “init” part of the for-loop (the first block) extends across all other parts of the for loop. This means that variables (and functions) declared in the init part (but not inside a block inside the init part) are visible in all other parts of the for-loop.
Identifiers declared in the other parts of the for loop respect the regular syntactical scoping rules.
This means a for-loop of the form `for { I... } C { P... } { B... }` is equivalent to `{ I... for {} C { P... } { B... } }`.
The parameters and return parameters of functions are visible in the function body and their names have to be distinct.
Inside functions, it is not possible to reference a variable that was declared outside of that function.
Shadowing is disallowed, i.e. you cannot declare an identifier at a point where another identifier with the same name is also visible, even if it is not possible to reference it because it was declared outside the current function.
### Formal Specification[](#formal-specification "Link to this heading")
We formally specify Yul by providing an evaluation function E overloaded on the various nodes of the AST. As builtin functions can have side effects, E takes two state objects and the AST node and returns two new state objects and a variable number of other values. The two state objects are the global state object (which in the context of the EVM is the memory, storage and state of the blockchain) and the local state object (the state of local variables, i.e. a segment of the stack in the EVM).
If the AST node is a statement, E returns the two state objects and a “mode”, which is used for the `break`, `continue` and `leave` statements. If the AST node is an expression, E returns the two state objects and as many values as the expression evaluates to.
The exact nature of the global state is unspecified for this high level description. The local state `L` is a mapping of identifiers `i` to values `v`, denoted as `L[i] = v`.
For an identifier `v`, let `$v` be the name of the identifier.
We will use a destructuring notation for the AST nodes.
E(G, L, <{St1, ..., Stn}>: Block) =
 let G1, L1, mode = E(G, L, St1, ..., Stn)
 let L2 be a restriction of L1 to the identifiers of L
 G1, L2, mode
E(G, L, St1, ..., Stn: Statement) =
 if n is zero:
 G, L, regular
 else:
 let G1, L1, mode = E(G, L, St1)
 if mode is regular then
 E(G1, L1, St2, ..., Stn)
 otherwise
 G1, L1, mode
E(G, L, FunctionDefinition) =
 G, L, regular
E(G, L, <let var\_1, ..., var\_n := rhs>: VariableDeclaration) =
 E(G, L, <var\_1, ..., var\_n := rhs>: Assignment)
E(G, L, <let var\_1, ..., var\_n>: VariableDeclaration) =
 let L1 be a copy of L where L1\[$var\_i\] = 0 for i = 1, ..., n
 G, L1, regular
E(G, L, <var\_1, ..., var\_n := rhs>: Assignment) =
 let G1, L1, v1, ..., vn = E(G, L, rhs)
 let L2 be a copy of L1 where L2\[$var\_i\] = vi for i = 1, ..., n
 G1, L2, regular
E(G, L, <for { i1, ..., in } condition post body>: ForLoop) =
 if n >= 1:
 let G1, L1, mode = E(G, L, i1, ..., in)
 // mode has to be regular or leave due to the syntactic restrictions
 if mode is leave then
 G1, L1 restricted to variables of L, leave
 otherwise
 let G2, L2, mode = E(G1, L1, for {} condition post body)
 G2, L2 restricted to variables of L, mode
 else:
 let G1, L1, v = E(G, L, condition)
 if v is false:
 G1, L1, regular
 else:
 let G2, L2, mode = E(G1, L, body)
 if mode is break:
 G2, L2, regular
 otherwise if mode is leave:
 G2, L2, leave
 else:
 G3, L3, mode = E(G2, L2, post)
 if mode is leave:
 G3, L3, leave
 otherwise
 E(G3, L3, for {} condition post body)
E(G, L, break: BreakContinue) =
 G, L, break
E(G, L, continue: BreakContinue) =
 G, L, continue
E(G, L, leave: Leave) =
 G, L, leave
E(G, L, <if condition body>: If) =
 let G0, L0, v = E(G, L, condition)
 if v is true:
 E(G0, L0, body)
 else:
 G0, L0, regular
E(G, L, <switch condition case l1:t1 st1 ... case ln:tn stn>: Switch) =
 E(G, L, switch condition case l1:t1 st1 ... case ln:tn stn default {})
E(G, L, <switch condition case l1:t1 st1 ... case ln:tn stn default st'>: Switch) =
 let G0, L0, v = E(G, L, condition)
 // i = 1 .. n
 // Evaluate literals, context doesn't matter
 let \_, \_, v1 = E(G0, L0, l1)
 ...
 let \_, \_, vn = E(G0, L0, ln)
 if there exists smallest i such that vi = v:
 E(G0, L0, sti)
 else:
 E(G0, L0, st')
E(G, L, <name>: Identifier) =
 G, L, L\[$name\]
E(G, L, <fname(arg1, ..., argn)>: FunctionCall) =
 G1, L1, vn = E(G, L, argn)
 ...
 G(n-1), L(n-1), v2 = E(G(n-2), L(n-2), arg2)
 Gn, Ln, v1 = E(G(n-1), L(n-1), arg1)
 Let <function fname (param1, ..., paramn) -> ret1, ..., retm block>
 be the function of name $fname visible at the point of the call.
 Let L' be a new local state such that
 L'\[$parami\] = vi and L'\[$reti\] = 0 for all i.
 Let G'', L'', mode = E(Gn, L', block)
 G'', Ln, L''\[$ret1\], ..., L''\[$retm\]
E(G, L, l: StringLiteral) = G, L, str(l),
 where str is the string evaluation function,
 which for the EVM dialect is defined in the section 'Literals' above
E(G, L, n: HexNumber) = G, L, hex(n)
 where hex is the hexadecimal evaluation function,
 which turns a sequence of hexadecimal digits into their big endian value
E(G, L, n: DecimalNumber) = G, L, dec(n),
 where dec is the decimal evaluation function,
 which turns a sequence of decimal digits into their big endian value
### EVM Dialect[](#evm-dialect "Link to this heading")
The default dialect of Yul currently is the EVM dialect for the currently selected version of the EVM. The only type available in this dialect is `u256`, the 256-bit native type of the Ethereum Virtual Machine. Since it is the default type of this dialect, it can be omitted.
The following table lists all builtin functions (depending on the EVM version) and provides a short description of the semantics of the function / opcode. This document does not want to be a full description of the Ethereum virtual machine. Please refer to a different document if you are interested in the precise semantics.
Opcodes marked with `-` do not return a result and all others return exactly one value. Opcodes marked with `F`, `H`, `B`, `C`, `I`, `L`, `P` and `N` are present since Frontier, Homestead, Byzantium, Constantinople, Istanbul, London, Paris or Cancun respectively.
In the following, `mem[a...b)` signifies the bytes of memory starting at position `a` up to but not including position `b`, `storage[p]` signifies the storage contents at slot `p`, and similarly, `transientStorage[p]` signifies the transient storage contents at slot `p`.
Since Yul manages local variables and control-flow, opcodes that interfere with these features are not available. This includes the `dup` and `swap` instructions as well as `jump` instructions, labels and the `push` instructions.
Instruction
Explanation
stop()
\-
F
stop execution, identical to return(0, 0)
add(x, y)
F
x + y
sub(x, y)
F
x - y
mul(x, y)
F
x \* y
div(x, y)
F
x / y or 0 if y == 0
sdiv(x, y)
F
x / y, for signed numbers in two’s complement, 0 if y == 0
mod(x, y)
F
x % y, 0 if y == 0
smod(x, y)
F
x % y, for signed numbers in two’s complement, 0 if y == 0
exp(x, y)
F
x to the power of y
not(x)
F
bitwise “not” of x (every bit of x is negated)
lt(x, y)
F
1 if x < y, 0 otherwise
gt(x, y)
F
1 if x > y, 0 otherwise
slt(x, y)
F
1 if x < y, 0 otherwise, for signed numbers in two’s complement
sgt(x, y)
F
1 if x > y, 0 otherwise, for signed numbers in two’s complement
eq(x, y)
F
1 if x == y, 0 otherwise
iszero(x)
F
1 if x == 0, 0 otherwise
and(x, y)
F
bitwise “and” of x and y
or(x, y)
F
bitwise “or” of x and y
xor(x, y)
F
bitwise “xor” of x and y
byte(n, x)
F
nth byte of x, where the most significant byte is the 0th byte
shl(x, y)
C
logical shift left y by x bits
shr(x, y)
C
logical shift right y by x bits
sar(x, y)
C
signed arithmetic shift right y by x bits
addmod(x, y, m)
F
(x + y) % m with arbitrary precision arithmetic, 0 if m == 0
mulmod(x, y, m)
F
(x \* y) % m with arbitrary precision arithmetic, 0 if m == 0
signextend(i, x)
F
sign extend from (i\*8+7)th bit counting from least significant
keccak256(p, n)
F
keccak(mem\[p…(p+n)))
pop(x)
\-
F
discard value x
mload(p)
F
mem\[p…(p+32))
mstore(p, v)
\-
F
mem\[p…(p+32)) := v
mstore8(p, v)
\-
F
mem\[p\] := v & 0xff (only modifies a single byte)
sload(p)
F
storage\[p\]
sstore(p, v)
\-
F
storage\[p\] := v
tload(p)
N
transientStorage\[p\]
tstore(p, v)
\-
N
transientStorage\[p\] := v
msize()
F
size of memory, i.e. largest accessed memory index
gas()
F
gas still available to execution
address()
F
address of the current contract / execution context
balance(a)
F
wei balance at address a
selfbalance()
I
equivalent to balance(address()), but cheaper
caller()
F
call sender (excluding `delegatecall`)
callvalue()
F
wei sent together with the current call
calldataload(p)
F
call data starting from position p (32 bytes)
calldatasize()
F
size of call data in bytes
calldatacopy(t, f, s)
\-
F
copy s bytes from calldata at position f to mem at position t
codesize()
F
size of the code of the current contract / execution context
codecopy(t, f, s)
\-
F
copy s bytes from code at position f to mem at position t
extcodesize(a)
F
size of the code at address a
extcodecopy(a, t, f, s)
\-
F
like codecopy(t, f, s) but take code at address a
returndatasize()
B
size of the last returndata
returndatacopy(t, f, s)
\-
B
copy s bytes from returndata at position f to mem at position t
mcopy(t, f, s)
\-
N
copy s bytes from mem at position f to mem at position t
extcodehash(a)
C
code hash of address a
create(v, p, n)
F
create new contract with code mem\[p…(p+n)) and send v wei and return the new address; returns 0 on error
create2(v, p, n, s)
C
create new contract with code mem\[p…(p+n)) at address keccak256(0xff . this . s . keccak256(mem\[p…(p+n))) and send v wei and return the new address, where `0xff` is a 1 byte value, `this` is the current contract’s address as a 20 byte value and `s` is a big-endian 256-bit value; returns 0 on error
call(g, a, v, in, insize, out, outsize)
F
call contract at address a with input mem\[in…(in+insize)) providing g gas and v wei and output area mem\[out…(out+outsize)) returning 0 on error (eg. out of gas) and 1 on success [See more](#yul-call-return-area)
callcode(g, a, v, in, insize, out, outsize)
F
identical to `call` but only use the code from a and stay in the context of the current contract otherwise [See more](#yul-call-return-area)
delegatecall(g, a, in, insize, out, outsize)
H
identical to `callcode` but also keep `caller` and `callvalue` [See more](#yul-call-return-area)
staticcall(g, a, in, insize, out, outsize)
B
identical to `call(g, a, 0, in, insize, out, outsize)` but do not allow state modifications [See more](#yul-call-return-area)
return(p, s)
\-
F
end execution, return data mem\[p…(p+s))
revert(p, s)
\-
B
end execution, revert state changes, return data mem\[p…(p+s))
selfdestruct(a)
\-
F
end execution, destroy current contract and send funds to a (deprecated)
invalid()
\-
F
end execution with invalid instruction
log0(p, s)
\-
F
log data mem\[p…(p+s))
log1(p, s, t1)
\-
F
log data mem\[p…(p+s)) with topic t1
log2(p, s, t1, t2)
\-
F
log data mem\[p…(p+s)) with topics t1, t2
log3(p, s, t1, t2, t3)
\-
F
log data mem\[p…(p+s)) with topics t1, t2, t3
log4(p, s, t1, t2, t3, t4)
\-
F
log data mem\[p…(p+s)) with topics t1, t2, t3, t4
chainid()
I
ID of the executing chain (EIP-1344)
basefee()
L
current block’s base fee (EIP-3198 and EIP-1559)
blobbasefee()
N
current block’s blob base fee (EIP-7516 and EIP-4844)
origin()
F
transaction sender
gasprice()
F
gas price of the transaction
blockhash(b)
F
hash of block nr b - only for last 256 blocks excluding current
blobhash(i)
N
versioned hash of transaction’s i-th blob, 0 if blob does not exist
coinbase()
F
current mining beneficiary
timestamp()
F
timestamp of the current block in seconds since the epoch
number()
F
current block number
difficulty()
F
difficulty of the current block (see note below)
prevrandao()
P
randomness provided by the beacon chain (see note below)
gaslimit()
F
block gas limit of the current block
Note
The `call*` instructions use the `out` and `outsize` parameters to define an area in memory where the return or failure data is placed. This area is written to depending on how many bytes the called contract returns. If it returns more data, only the first `outsize` bytes are written. You can access the rest of the data using the `returndatacopy` opcode. If it returns less data, then the remaining bytes are not touched at all. You need to use the `returndatasize` opcode to check which part of this memory area contains the return data. The remaining bytes will retain their values as of before the call.
Note
The `difficulty()` instruction is disallowed in EVM version >= Paris. With the Paris network upgrade the semantics of the instruction that was previously called `difficulty` have been changed and the instruction was renamed to `prevrandao`. It can now return arbitrary values in the full 256-bit range, whereas the highest recorded difficulty value within Ethash was ~54 bits. This change is described in [EIP-4399](https://eips.ethereum.org/EIPS/eip-4399). Please note that irrelevant to which EVM version is selected in the compiler, the semantics of instructions depend on the final chain of deployment.
Warning
From version 0.8.18 and up, the use of `selfdestruct` in both Solidity and Yul will trigger a deprecation warning, since the `SELFDESTRUCT` opcode will eventually undergo breaking changes in behavior as stated in [EIP-6049](https://eips.ethereum.org/EIPS/eip-6049).
In some internal dialects, there are additional functions:
#### datasize, dataoffset, datacopy[](#datasize-dataoffset-datacopy "Link to this heading")
The functions `datasize(x)`, `dataoffset(x)` and `datacopy(t, f, l)` are used to access other parts of a Yul object.
`datasize` and `dataoffset` can only take string literals (the names of other objects) as arguments and return the size and offset in the data area, respectively. For the EVM, the `datacopy` function is equivalent to `codecopy`.
#### setimmutable, loadimmutable[](#setimmutable-loadimmutable "Link to this heading")
The functions `setimmutable(offset, "name", value)` and `loadimmutable("name")` are used for the immutable mechanism in Solidity and do not nicely map to pure Yul. The call to `setimmutable(offset, "name", value)` assumes that the runtime code of the contract containing the given named immutable was copied to memory at offset `offset` and will write `value` to all positions in memory (relative to `offset`) that contain the placeholder that was generated for calls to `loadimmutable("name")` in the runtime code.
#### linkersymbol[](#linkersymbol "Link to this heading")
The function `linkersymbol("library_id")` is a placeholder for an address literal to be substituted by the linker. Its first and only argument must be a string literal and uniquely represents the address to be inserted. Identifiers can be arbitrary but when the compiler produces Yul code from Solidity sources, it uses a library name qualified with the name of the source unit that defines that library. To link the code with a particular library address, the same identifier must be provided to the `--libraries` option on the command-line.
For example this code
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=bGV0IGEgOj0gbGlua2Vyc3ltYm9sKCJmaWxlLnNvbDpNYXRoIik=)
let a := linkersymbol("file.sol:Math")
is equivalent to
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=bGV0IGEgOj0gMHgxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkw)
let a := 0x1234567890123456789012345678901234567890
when the linker is invoked with `--libraries "file.sol:Math=0x1234567890123456789012345678901234567890` option.
See [Using the Commandline Compiler](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#commandline-compiler) for details about the Solidity linker.
#### memoryguard[](#memoryguard "Link to this heading")
This function is available in the EVM dialect with objects. The caller of `let ptr := memoryguard(size)` (where `size` has to be a literal number) promises that they only use memory in either the range `[0, size)` or the unbounded range starting at `ptr`.
Since the presence of a `memoryguard` call indicates that all memory access adheres to this restriction, it allows the optimizer to perform additional optimization steps, for example the stack limit evader, which attempts to move stack variables that would otherwise be unreachable to memory.
The Yul optimizer promises to only use the memory range `[size, ptr)` for its purposes. If the optimizer does not need to reserve any memory, it holds that `ptr == size`.
`memoryguard` can be called multiple times, but needs to have the same literal as argument within one Yul subobject. If at least one `memoryguard` call is found in a subobject, the additional optimiser steps will be run on it.
#### verbatim[](#verbatim "Link to this heading")
The set of `verbatim...` builtin functions lets you create bytecode for opcodes that are not known to the Yul compiler. It also allows you to create bytecode sequences that will not be modified by the optimizer.
The functions are `verbatim_<n>i_<m>o("<data>", ...)`, where
* `n` is a decimal between 0 and 99 that specifies the number of input stack slots / variables
 
* `m` is a decimal between 0 and 99 that specifies the number of output stack slots / variables
 
* `data` is a string literal that contains the sequence of bytes
 
If you for example want to define a function that multiplies the input by two, without the optimizer touching the constant two, you can use
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=bGV0IHggOj0gY2FsbGRhdGFsb2FkKDApCmxldCBkb3VibGUgOj0gdmVyYmF0aW1fMWlfMW8oaGV4IjYwMDIwMiIsIHgp)
let x := calldataload(0)
let double := verbatim\_1i\_1o(hex"600202", x)
This code will result in a `dup1` opcode to retrieve `x` (the optimizer might directly reuse result of the `calldataload` opcode, though) directly followed by `600202`. The code is assumed to consume the copied value of `x` and produce the result on the top of the stack. The compiler then generates code to allocate a stack slot for `double` and store the result there.
As with all opcodes, the arguments are arranged on the stack with the leftmost argument on the top, while the return values are assumed to be laid out such that the rightmost variable is at the top of the stack.
Since `verbatim` can be used to generate arbitrary opcodes or even opcodes unknown to the Solidity compiler, care has to be taken when using `verbatim` together with the optimizer. Even when the optimizer is switched off, the code generator has to determine the stack layout, which means that e.g. using `verbatim` to modify the stack height can lead to undefined behavior.
The following is a non-exhaustive list of restrictions on verbatim bytecode that are not checked by the compiler. Violations of these restrictions can result in undefined behavior.
* Control-flow should not jump into or out of verbatim blocks, but it can jump within the same verbatim block. In particular, reverting or returning from the block is _not_ allowed.
 
* Stack contents apart from the input and output parameters should not be accessed.
 
* The stack height difference should be exactly `m - n` (output slots minus input slots).
 
* Verbatim bytecode cannot make any assumptions about the surrounding bytecode. All required parameters have to be passed in as stack variables.
 
The optimizer does not analyze verbatim bytecode and always assumes that it modifies all aspects of state and thus can only do very few optimizations across `verbatim` function calls.
The optimizer treats verbatim bytecode as an opaque block of code. It will not split it but might move, duplicate or combine it with identical verbatim bytecode blocks. If a verbatim bytecode block is unreachable by the control-flow, it can be removed.
Warning
During discussions about whether or not EVM improvements might break existing smart contracts, features inside `verbatim` cannot receive the same consideration as those used by the Solidity compiler itself.
Note
To avoid confusion, all identifiers starting with the string `verbatim` are reserved and cannot be used for user-defined identifiers.
## Specification of Yul Object[](#specification-of-yul-object "Link to this heading")
Yul objects are used to group named code and data sections. The functions `datasize`, `dataoffset` and `datacopy` can be used to access these sections from within code. Hex strings can be used to specify data in hex encoding, regular strings in native encoding. For code, `datacopy` will access its assembled binary representation.
Object = 'object' StringLiteral '{' Code ( Object | Data )\* '}'
Code = 'code' Block
Data = 'data' StringLiteral ( HexLiteral | StringLiteral )
HexLiteral = 'hex' ('"' (\[0-9a-fA-F\]{2})\* '"' | '\\'' (\[0-9a-fA-F\]{2})\* '\\'')
StringLiteral = '"' (\[^"\\r\\n\\\\\] | '\\\\' .)\* '"'
Above, `Block` refers to `Block` in the Yul code grammar explained in the previous chapter.
Note
An object with a name that ends in `_deployed` is treated as deployed code by the Yul optimizer. The only consequence of this is a different gas cost heuristic in the optimizer.
Note
Data objects or sub-objects whose names contain a `.` can be defined but it is not possible to access them through `datasize`, `dataoffset` or `datacopy` because `.` is used as a separator to access objects inside another object.
Note
The data object called `".metadata"` has a special meaning: It cannot be accessed from code and is always appended to the very end of the bytecode, regardless of its position in the object.
Other data objects with special significance might be added in the future, but their names will always start with a `.`.
An example Yul Object is shown below:
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=Ly8gQSBjb250cmFjdCBjb25zaXN0cyBvZiBhIHNpbmdsZSBvYmplY3Qgd2l0aCBzdWItb2JqZWN0cyByZXByZXNlbnRpbmcKLy8gdGhlIGNvZGUgdG8gYmUgZGVwbG95ZWQgb3Igb3RoZXIgY29udHJhY3RzIGl0IGNhbiBjcmVhdGUuCi8vIFRoZSBzaW5nbGUgImNvZGUiIG5vZGUgaXMgdGhlIGV4ZWN1dGFibGUgY29kZSBvZiB0aGUgb2JqZWN0LgovLyBFdmVyeSAob3RoZXIpIG5hbWVkIG9iamVjdCBvciBkYXRhIHNlY3Rpb24gaXMgc2VyaWFsaXplZCBhbmQKLy8gbWFkZSBhY2Nlc3NpYmxlIHRvIHRoZSBzcGVjaWFsIGJ1aWx0LWluIGZ1bmN0aW9ucyBkYXRhY29weSAvIGRhdGFvZmZzZXQgLyBkYXRhc2l6ZQovLyBUaGUgY3VycmVudCBvYmplY3QsIHN1Yi1vYmplY3RzIGFuZCBkYXRhIGl0ZW1zIGluc2lkZSB0aGUgY3VycmVudCBvYmplY3QKLy8gYXJlIGluIHNjb3BlLgpvYmplY3QgIkNvbnRyYWN0MSIgewogICAgLy8gVGhpcyBpcyB0aGUgY29uc3RydWN0b3IgY29kZSBvZiB0aGUgY29udHJhY3QuCiAgICBjb2RlIHsKICAgICAgICBmdW5jdGlvbiBhbGxvY2F0ZShzaXplKSAtPiBwdHIgewogICAgICAgICAgICBwdHIgOj0gbWxvYWQoMHg0MCkKICAgICAgICAgICAgLy8gTm90ZSB0aGF0IFNvbGlkaXR5IGdlbmVyYXRlZCBJUiBjb2RlIHJlc2VydmVzIG1lbW9yeSBvZmZzZXQgYGAweDYwYGAgYXMgd2VsbCwgYnV0IGEgcHVyZSBZdWwgb2JqZWN0IGlzIGZyZWUgdG8gdXNlIG1lbW9yeSBhcyBpdCBjaG9vc2VzLgogICAgICAgICAgICBpZiBpc3plcm8ocHRyKSB7IHB0ciA6PSAweDYwIH0KICAgICAgICAgICAgbXN0b3JlKDB4NDAsIGFkZChwdHIsIHNpemUpKQogICAgICAgIH0KCiAgICAgICAgLy8gZmlyc3QgY3JlYXRlICJDb250cmFjdDIiCiAgICAgICAgbGV0IHNpemUgOj0gZGF0YXNpemUoIkNvbnRyYWN0MiIpCiAgICAgICAgbGV0IG9mZnNldCA6PSBhbGxvY2F0ZShzaXplKQogICAgICAgIC8vIFRoaXMgd2lsbCB0dXJuIGludG8gY29kZWNvcHkgZm9yIEVWTQogICAgICAgIGRhdGFjb3B5KG9mZnNldCwgZGF0YW9mZnNldCgiQ29udHJhY3QyIiksIHNpemUpCiAgICAgICAgLy8gY29uc3RydWN0b3IgcGFyYW1ldGVyIGlzIGEgc2luZ2xlIG51bWJlciAweDEyMzQKICAgICAgICBtc3RvcmUoYWRkKG9mZnNldCwgc2l6ZSksIDB4MTIzNCkKICAgICAgICBwb3AoY3JlYXRlKDAsIG9mZnNldCwgYWRkKHNpemUsIDMyKSkpCgogICAgICAgIC8vIG5vdyByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0ICh0aGUgY3VycmVudGx5CiAgICAgICAgLy8gZXhlY3V0aW5nIGNvZGUgaXMgdGhlIGNvbnN0cnVjdG9yIGNvZGUpCiAgICAgICAgc2l6ZSA6PSBkYXRhc2l6ZSgiQ29udHJhY3QxX2RlcGxveWVkIikKICAgICAgICBvZmZzZXQgOj0gYWxsb2NhdGUoc2l6ZSkKICAgICAgICAvLyBUaGlzIHdpbGwgdHVybiBpbnRvIGEgY29kZWNvcHkgZm9yIEVWTQogICAgICAgIGRhdGFjb3B5KG9mZnNldCwgZGF0YW9mZnNldCgiQ29udHJhY3QxX2RlcGxveWVkIiksIHNpemUpCiAgICAgICAgcmV0dXJuKG9mZnNldCwgc2l6ZSkKICAgIH0KCiAgICBkYXRhICJUYWJsZTIiIGhleCI0MTIzIgoKICAgIG9iamVjdCAiQ29udHJhY3QxX2RlcGxveWVkIiB7CiAgICAgICAgY29kZSB7CiAgICAgICAgICAgIGZ1bmN0aW9uIGFsbG9jYXRlKHNpemUpIC0+IHB0ciB7CiAgICAgICAgICAgICAgICBwdHIgOj0gbWxvYWQoMHg0MCkKICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBTb2xpZGl0eSBnZW5lcmF0ZWQgSVIgY29kZSByZXNlcnZlcyBtZW1vcnkgb2Zmc2V0IGBgMHg2MGBgIGFzIHdlbGwsIGJ1dCBhIHB1cmUgWXVsIG9iamVjdCBpcyBmcmVlIHRvIHVzZSBtZW1vcnkgYXMgaXQgY2hvb3Nlcy4KICAgICAgICAgICAgICAgIGlmIGlzemVybyhwdHIpIHsgcHRyIDo9IDB4NjAgfQogICAgICAgICAgICAgICAgbXN0b3JlKDB4NDAsIGFkZChwdHIsIHNpemUpKQogICAgICAgICAgICB9CgogICAgICAgICAgICAvLyBydW50aW1lIGNvZGUKCiAgICAgICAgICAgIG1zdG9yZSgwLCAiSGVsbG8sIFdvcmxkISIpCiAgICAgICAgICAgIHJldHVybigwLCAweDIwKQogICAgICAgIH0KICAgIH0KCiAgICAvLyBFbWJlZGRlZCBvYmplY3QuIFVzZSBjYXNlIGlzIHRoYXQgdGhlIG91dHNpZGUgaXMgYSBmYWN0b3J5IGNvbnRyYWN0LAogICAgLy8gYW5kIENvbnRyYWN0MiBpcyB0aGUgY29kZSB0byBiZSBjcmVhdGVkIGJ5IHRoZSBmYWN0b3J5CiAgICBvYmplY3QgIkNvbnRyYWN0MiIgewogICAgICAgIGNvZGUgewogICAgICAgICAgICAvLyBjb2RlIGhlcmUgLi4uCiAgICAgICAgfQoKICAgICAgICBvYmplY3QgIkNvbnRyYWN0Ml9kZXBsb3llZCIgewogICAgICAgICAgICBjb2RlIHsKICAgICAgICAgICAgICAgIC8vIGNvZGUgaGVyZSAuLi4KICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgZGF0YSAiVGFibGUxIiBoZXgiNDEyMyIKICAgIH0KfQ==)
// A contract consists of a single object with sub-objects representing
// the code to be deployed or other contracts it can create.
// The single "code" node is the executable code of the object.
// Every (other) named object or data section is serialized and
// made accessible to the special built-in functions datacopy / dataoffset / datasize
// The current object, sub-objects and data items inside the current object
// are in scope.
object "Contract1" {
 // This is the constructor code of the contract.
 code {
 function allocate(size) \-> ptr {
 ptr := mload(0x40)
 // Note that Solidity generated IR code reserves memory offset \`\`0x60\`\` as well, but a pure Yul object is free to use memory as it chooses.
 if iszero(ptr) { ptr := 0x60 }
 mstore(0x40, add(ptr, size))
 }
 // first create "Contract2"
 let size := datasize("Contract2")
 let offset := allocate(size)
 // This will turn into codecopy for EVM
 datacopy(offset, dataoffset("Contract2"), size)
 // constructor parameter is a single number 0x1234
 mstore(add(offset, size), 0x1234)
 pop(create(0, offset, add(size, 32)))
 // now return the runtime object (the currently
 // executing code is the constructor code)
 size := datasize("Contract1\_deployed")
 offset := allocate(size)
 // This will turn into a codecopy for EVM
 datacopy(offset, dataoffset("Contract1\_deployed"), size)
 return(offset, size)
 }
 data "Table2" hex"4123"
 object "Contract1\_deployed" {
 code {
 function allocate(size) \-> ptr {
 ptr := mload(0x40)
 // Note that Solidity generated IR code reserves memory offset \`\`0x60\`\` as well, but a pure Yul object is free to use memory as it chooses.
 if iszero(ptr) { ptr := 0x60 }
 mstore(0x40, add(ptr, size))
 }
 // runtime code
 mstore(0, "Hello, World!")
 return(0, 0x20)
 }
 }
 // Embedded object. Use case is that the outside is a factory contract,
 // and Contract2 is the code to be created by the factory
 object "Contract2" {
 code {
 // code here ...
 }
 object "Contract2\_deployed" {
 code {
 // code here ...
 }
 }
 data "Table1" hex"4123"
 }
}
## Yul Optimizer[](#yul-optimizer "Link to this heading")
The Yul optimizer operates on Yul code and uses the same language for input, output and intermediate states. This allows for easy debugging and verification of the optimizer.
Please refer to the general [optimizer documentation](https://docs.soliditylang.org/en/v0.8.30/internals/optimizer.html#optimizer) for more details about the different optimization stages and how to use the optimizer.
If you want to use Solidity in stand-alone Yul mode, you activate the optimizer using `--optimize` and optionally specify the [expected number of contract executions](https://docs.soliditylang.org/en/v0.8.30/internals/optimizer.html#optimizer-parameter-runs) with `--optimize-runs`:
solc \--strict-assembly \--optimize \--optimize-runs 200
In Solidity mode, the Yul optimizer is activated together with the regular optimizer.
### Optimization Step Sequence[](#optimization-step-sequence "Link to this heading")
Detailed information regarding the optimization sequence as well as a list of abbreviations is available in the [optimizer docs](https://docs.soliditylang.org/en/v0.8.30/internals/optimizer.html#optimizer-steps).
## Complete ERC20 Example[](#complete-erc20-example "Link to this heading")
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=b2JqZWN0ICJUb2tlbiIgewogICAgY29kZSB7CiAgICAgICAgLy8gU3RvcmUgdGhlIGNyZWF0b3IgaW4gc2xvdCB6ZXJvLgogICAgICAgIHNzdG9yZSgwLCBjYWxsZXIoKSkKCiAgICAgICAgLy8gRGVwbG95IHRoZSBjb250cmFjdAogICAgICAgIGRhdGFjb3B5KDAsIGRhdGFvZmZzZXQoInJ1bnRpbWUiKSwgZGF0YXNpemUoInJ1bnRpbWUiKSkKICAgICAgICByZXR1cm4oMCwgZGF0YXNpemUoInJ1bnRpbWUiKSkKICAgIH0KICAgIG9iamVjdCAicnVudGltZSIgewogICAgICAgIGNvZGUgewogICAgICAgICAgICAvLyBQcm90ZWN0aW9uIGFnYWluc3Qgc2VuZGluZyBFdGhlcgogICAgICAgICAgICByZXF1aXJlKGlzemVybyhjYWxsdmFsdWUoKSkpCgogICAgICAgICAgICAvLyBEaXNwYXRjaGVyCiAgICAgICAgICAgIHN3aXRjaCBzZWxlY3RvcigpCiAgICAgICAgICAgIGNhc2UgMHg3MGEwODIzMSAvKiAiYmFsYW5jZU9mKGFkZHJlc3MpIiAqLyB7CiAgICAgICAgICAgICAgICByZXR1cm5VaW50KGJhbGFuY2VPZihkZWNvZGVBc0FkZHJlc3MoMCkpKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGNhc2UgMHgxODE2MGRkZCAvKiAidG90YWxTdXBwbHkoKSIgKi8gewogICAgICAgICAgICAgICAgcmV0dXJuVWludCh0b3RhbFN1cHBseSgpKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGNhc2UgMHhhOTA1OWNiYiAvKiAidHJhbnNmZXIoYWRkcmVzcyx1aW50MjU2KSIgKi8gewogICAgICAgICAgICAgICAgdHJhbnNmZXIoZGVjb2RlQXNBZGRyZXNzKDApLCBkZWNvZGVBc1VpbnQoMSkpCiAgICAgICAgICAgICAgICByZXR1cm5UcnVlKCkKICAgICAgICAgICAgfQogICAgICAgICAgICBjYXNlIDB4MjNiODcyZGQgLyogInRyYW5zZmVyRnJvbShhZGRyZXNzLGFkZHJlc3MsdWludDI1NikiICovIHsKICAgICAgICAgICAgICAgIHRyYW5zZmVyRnJvbShkZWNvZGVBc0FkZHJlc3MoMCksIGRlY29kZUFzQWRkcmVzcygxKSwgZGVjb2RlQXNVaW50KDIpKQogICAgICAgICAgICAgICAgcmV0dXJuVHJ1ZSgpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgY2FzZSAweDA5NWVhN2IzIC8qICJhcHByb3ZlKGFkZHJlc3MsdWludDI1NikiICovIHsKICAgICAgICAgICAgICAgIGFwcHJvdmUoZGVjb2RlQXNBZGRyZXNzKDApLCBkZWNvZGVBc1VpbnQoMSkpCiAgICAgICAgICAgICAgICByZXR1cm5UcnVlKCkKICAgICAgICAgICAgfQogICAgICAgICAgICBjYXNlIDB4ZGQ2MmVkM2UgLyogImFsbG93YW5jZShhZGRyZXNzLGFkZHJlc3MpIiAqLyB7CiAgICAgICAgICAgICAgICByZXR1cm5VaW50KGFsbG93YW5jZShkZWNvZGVBc0FkZHJlc3MoMCksIGRlY29kZUFzQWRkcmVzcygxKSkpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgY2FzZSAweDQwYzEwZjE5IC8qICJtaW50KGFkZHJlc3MsdWludDI1NikiICovIHsKICAgICAgICAgICAgICAgIG1pbnQoZGVjb2RlQXNBZGRyZXNzKDApLCBkZWNvZGVBc1VpbnQoMSkpCiAgICAgICAgICAgICAgICByZXR1cm5UcnVlKCkKICAgICAgICAgICAgfQogICAgICAgICAgICBkZWZhdWx0IHsKICAgICAgICAgICAgICAgIHJldmVydCgwLCAwKQogICAgICAgICAgICB9CgogICAgICAgICAgICBmdW5jdGlvbiBtaW50KGFjY291bnQsIGFtb3VudCkgewogICAgICAgICAgICAgICAgcmVxdWlyZShjYWxsZWRCeU93bmVyKCkpCgogICAgICAgICAgICAgICAgbWludFRva2VucyhhbW91bnQpCiAgICAgICAgICAgICAgICBhZGRUb0JhbGFuY2UoYWNjb3VudCwgYW1vdW50KQogICAgICAgICAgICAgICAgZW1pdFRyYW5zZmVyKDAsIGFjY291bnQsIGFtb3VudCkKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiB0cmFuc2Zlcih0bywgYW1vdW50KSB7CiAgICAgICAgICAgICAgICBleGVjdXRlVHJhbnNmZXIoY2FsbGVyKCksIHRvLCBhbW91bnQpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gYXBwcm92ZShzcGVuZGVyLCBhbW91bnQpIHsKICAgICAgICAgICAgICAgIHJldmVydElmWmVyb0FkZHJlc3Moc3BlbmRlcikKICAgICAgICAgICAgICAgIHNldEFsbG93YW5jZShjYWxsZXIoKSwgc3BlbmRlciwgYW1vdW50KQogICAgICAgICAgICAgICAgZW1pdEFwcHJvdmFsKGNhbGxlcigpLCBzcGVuZGVyLCBhbW91bnQpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gdHJhbnNmZXJGcm9tKGZyb20sIHRvLCBhbW91bnQpIHsKICAgICAgICAgICAgICAgIGRlY3JlYXNlQWxsb3dhbmNlQnkoZnJvbSwgY2FsbGVyKCksIGFtb3VudCkKICAgICAgICAgICAgICAgIGV4ZWN1dGVUcmFuc2Zlcihmcm9tLCB0bywgYW1vdW50KQogICAgICAgICAgICB9CgogICAgICAgICAgICBmdW5jdGlvbiBleGVjdXRlVHJhbnNmZXIoZnJvbSwgdG8sIGFtb3VudCkgewogICAgICAgICAgICAgICAgcmV2ZXJ0SWZaZXJvQWRkcmVzcyh0bykKICAgICAgICAgICAgICAgIGRlZHVjdEZyb21CYWxhbmNlKGZyb20sIGFtb3VudCkKICAgICAgICAgICAgICAgIGFkZFRvQmFsYW5jZSh0bywgYW1vdW50KQogICAgICAgICAgICAgICAgZW1pdFRyYW5zZmVyKGZyb20sIHRvLCBhbW91bnQpCiAgICAgICAgICAgIH0KCgogICAgICAgICAgICAvKiAtLS0tLS0tLS0tIGNhbGxkYXRhIGRlY29kaW5nIGZ1bmN0aW9ucyAtLS0tLS0tLS0tLSAqLwogICAgICAgICAgICBmdW5jdGlvbiBzZWxlY3RvcigpIC0+IHMgewogICAgICAgICAgICAgICAgcyA6PSBkaXYoY2FsbGRhdGFsb2FkKDApLCAweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCkKICAgICAgICAgICAgfQoKICAgICAgICAgICAgZnVuY3Rpb24gZGVjb2RlQXNBZGRyZXNzKG9mZnNldCkgLT4gdiB7CiAgICAgICAgICAgICAgICB2IDo9IGRlY29kZUFzVWludChvZmZzZXQpCiAgICAgICAgICAgICAgICBpZiBpc3plcm8oaXN6ZXJvKGFuZCh2LCBub3QoMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmKSkpKSB7CiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0KDAsIDApCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gZGVjb2RlQXNVaW50KG9mZnNldCkgLT4gdiB7CiAgICAgICAgICAgICAgICBsZXQgcG9zIDo9IGFkZCg0LCBtdWwob2Zmc2V0LCAweDIwKSkKICAgICAgICAgICAgICAgIGlmIGx0KGNhbGxkYXRhc2l6ZSgpLCBhZGQocG9zLCAweDIwKSkgewogICAgICAgICAgICAgICAgICAgIHJldmVydCgwLCAwKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdiA6PSBjYWxsZGF0YWxvYWQocG9zKQogICAgICAgICAgICB9CiAgICAgICAgICAgIC8qIC0tLS0tLS0tLS0gY2FsbGRhdGEgZW5jb2RpbmcgZnVuY3Rpb25zIC0tLS0tLS0tLS0gKi8KICAgICAgICAgICAgZnVuY3Rpb24gcmV0dXJuVWludCh2KSB7CiAgICAgICAgICAgICAgICBtc3RvcmUoMCwgdikKICAgICAgICAgICAgICAgIHJldHVybigwLCAweDIwKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIHJldHVyblRydWUoKSB7CiAgICAgICAgICAgICAgICByZXR1cm5VaW50KDEpCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8qIC0tLS0tLS0tIGV2ZW50cyAtLS0tLS0tLS0tICovCiAgICAgICAgICAgIGZ1bmN0aW9uIGVtaXRUcmFuc2Zlcihmcm9tLCB0bywgYW1vdW50KSB7CiAgICAgICAgICAgICAgICBsZXQgc2lnbmF0dXJlSGFzaCA6PSAweGRkZjI1MmFkMWJlMmM4OWI2OWMyYjA2OGZjMzc4ZGFhOTUyYmE3ZjE2M2M0YTExNjI4ZjU1YTRkZjUyM2IzZWYKICAgICAgICAgICAgICAgIGVtaXRFdmVudChzaWduYXR1cmVIYXNoLCBmcm9tLCB0bywgYW1vdW50KQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGVtaXRBcHByb3ZhbChmcm9tLCBzcGVuZGVyLCBhbW91bnQpIHsKICAgICAgICAgICAgICAgIGxldCBzaWduYXR1cmVIYXNoIDo9IDB4OGM1YmUxZTVlYmVjN2Q1YmQxNGY3MTQyN2QxZTg0ZjNkZDAzMTRjMGY3YjIyOTFlNWIyMDBhYzhjN2MzYjkyNQogICAgICAgICAgICAgICAgZW1pdEV2ZW50KHNpZ25hdHVyZUhhc2gsIGZyb20sIHNwZW5kZXIsIGFtb3VudCkKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBlbWl0RXZlbnQoc2lnbmF0dXJlSGFzaCwgaW5kZXhlZDEsIGluZGV4ZWQyLCBub25JbmRleGVkKSB7CiAgICAgICAgICAgICAgICBtc3RvcmUoMCwgbm9uSW5kZXhlZCkKICAgICAgICAgICAgICAgIGxvZzMoMCwgMHgyMCwgc2lnbmF0dXJlSGFzaCwgaW5kZXhlZDEsIGluZGV4ZWQyKQogICAgICAgICAgICB9CgogICAgICAgICAgICAvKiAtLS0tLS0tLSBzdG9yYWdlIGxheW91dCAtLS0tLS0tLS0tICovCiAgICAgICAgICAgIGZ1bmN0aW9uIG93bmVyUG9zKCkgLT4gcCB7IHAgOj0gMCB9CiAgICAgICAgICAgIGZ1bmN0aW9uIHRvdGFsU3VwcGx5UG9zKCkgLT4gcCB7IHAgOj0gMSB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGFjY291bnRUb1N0b3JhZ2VPZmZzZXQoYWNjb3VudCkgLT4gb2Zmc2V0IHsKICAgICAgICAgICAgICAgIG9mZnNldCA6PSBhZGQoMHgxMDAwLCBhY2NvdW50KQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGFsbG93YW5jZVN0b3JhZ2VPZmZzZXQoYWNjb3VudCwgc3BlbmRlcikgLT4gb2Zmc2V0IHsKICAgICAgICAgICAgICAgIG9mZnNldCA6PSBhY2NvdW50VG9TdG9yYWdlT2Zmc2V0KGFjY291bnQpCiAgICAgICAgICAgICAgICBtc3RvcmUoMCwgb2Zmc2V0KQogICAgICAgICAgICAgICAgbXN0b3JlKDB4MjAsIHNwZW5kZXIpCiAgICAgICAgICAgICAgICBvZmZzZXQgOj0ga2VjY2FrMjU2KDAsIDB4NDApCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8qIC0tLS0tLS0tIHN0b3JhZ2UgYWNjZXNzIC0tLS0tLS0tLS0gKi8KICAgICAgICAgICAgZnVuY3Rpb24gb3duZXIoKSAtPiBvIHsKICAgICAgICAgICAgICAgIG8gOj0gc2xvYWQob3duZXJQb3MoKSkKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiB0b3RhbFN1cHBseSgpIC0+IHN1cHBseSB7CiAgICAgICAgICAgICAgICBzdXBwbHkgOj0gc2xvYWQodG90YWxTdXBwbHlQb3MoKSkKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBtaW50VG9rZW5zKGFtb3VudCkgewogICAgICAgICAgICAgICAgc3N0b3JlKHRvdGFsU3VwcGx5UG9zKCksIHNhZmVBZGQodG90YWxTdXBwbHkoKSwgYW1vdW50KSkKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBiYWxhbmNlT2YoYWNjb3VudCkgLT4gYmFsIHsKICAgICAgICAgICAgICAgIGJhbCA6PSBzbG9hZChhY2NvdW50VG9TdG9yYWdlT2Zmc2V0KGFjY291bnQpKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFRvQmFsYW5jZShhY2NvdW50LCBhbW91bnQpIHsKICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgOj0gYWNjb3VudFRvU3RvcmFnZU9mZnNldChhY2NvdW50KQogICAgICAgICAgICAgICAgc3N0b3JlKG9mZnNldCwgc2FmZUFkZChzbG9hZChvZmZzZXQpLCBhbW91bnQpKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGRlZHVjdEZyb21CYWxhbmNlKGFjY291bnQsIGFtb3VudCkgewogICAgICAgICAgICAgICAgbGV0IG9mZnNldCA6PSBhY2NvdW50VG9TdG9yYWdlT2Zmc2V0KGFjY291bnQpCiAgICAgICAgICAgICAgICBsZXQgYmFsIDo9IHNsb2FkKG9mZnNldCkKICAgICAgICAgICAgICAgIHJlcXVpcmUobHRlKGFtb3VudCwgYmFsKSkKICAgICAgICAgICAgICAgIHNzdG9yZShvZmZzZXQsIHN1YihiYWwsIGFtb3VudCkpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gYWxsb3dhbmNlKGFjY291bnQsIHNwZW5kZXIpIC0+IGFtb3VudCB7CiAgICAgICAgICAgICAgICBhbW91bnQgOj0gc2xvYWQoYWxsb3dhbmNlU3RvcmFnZU9mZnNldChhY2NvdW50LCBzcGVuZGVyKSkKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBzZXRBbGxvd2FuY2UoYWNjb3VudCwgc3BlbmRlciwgYW1vdW50KSB7CiAgICAgICAgICAgICAgICBzc3RvcmUoYWxsb3dhbmNlU3RvcmFnZU9mZnNldChhY2NvdW50LCBzcGVuZGVyKSwgYW1vdW50KQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGRlY3JlYXNlQWxsb3dhbmNlQnkoYWNjb3VudCwgc3BlbmRlciwgYW1vdW50KSB7CiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0IDo9IGFsbG93YW5jZVN0b3JhZ2VPZmZzZXQoYWNjb3VudCwgc3BlbmRlcikKICAgICAgICAgICAgICAgIGxldCBjdXJyZW50QWxsb3dhbmNlIDo9IHNsb2FkKG9mZnNldCkKICAgICAgICAgICAgICAgIHJlcXVpcmUobHRlKGFtb3VudCwgY3VycmVudEFsbG93YW5jZSkpCiAgICAgICAgICAgICAgICBzc3RvcmUob2Zmc2V0LCBzdWIoY3VycmVudEFsbG93YW5jZSwgYW1vdW50KSkKICAgICAgICAgICAgfQoKICAgICAgICAgICAgLyogLS0tLS0tLS0tLSB1dGlsaXR5IGZ1bmN0aW9ucyAtLS0tLS0tLS0tICovCiAgICAgICAgICAgIGZ1bmN0aW9uIGx0ZShhLCBiKSAtPiByIHsKICAgICAgICAgICAgICAgIHIgOj0gaXN6ZXJvKGd0KGEsIGIpKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGd0ZShhLCBiKSAtPiByIHsKICAgICAgICAgICAgICAgIHIgOj0gaXN6ZXJvKGx0KGEsIGIpKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIHNhZmVBZGQoYSwgYikgLT4gciB7CiAgICAgICAgICAgICAgICByIDo9IGFkZChhLCBiKQogICAgICAgICAgICAgICAgaWYgb3IobHQociwgYSksIGx0KHIsIGIpKSB7IHJldmVydCgwLCAwKSB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gY2FsbGVkQnlPd25lcigpIC0+IGNibyB7CiAgICAgICAgICAgICAgICBjYm8gOj0gZXEob3duZXIoKSwgY2FsbGVyKCkpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gcmV2ZXJ0SWZaZXJvQWRkcmVzcyhhZGRyKSB7CiAgICAgICAgICAgICAgICByZXF1aXJlKGFkZHIpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gcmVxdWlyZShjb25kaXRpb24pIHsKICAgICAgICAgICAgICAgIGlmIGlzemVybyhjb25kaXRpb24pIHsgcmV2ZXJ0KDAsIDApIH0KICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH0KfQ==)
object "Token" {
 code {
 // Store the creator in slot zero.
 sstore(0, caller())
 // Deploy the contract
 datacopy(0, dataoffset("runtime"), datasize("runtime"))
 return(0, datasize("runtime"))
 }
 object "runtime" {
 code {
 // Protection against sending Ether
 require(iszero(callvalue()))
 // Dispatcher
 switch selector()
 case 0x70a08231 /\* "balanceOf(address)" \*/ {
 returnUint(balanceOf(decodeAsAddress(0)))
 }
 case 0x18160ddd /\* "totalSupply()" \*/ {
 returnUint(totalSupply())
 }
 case 0xa9059cbb /\* "transfer(address,uint256)" \*/ {
 transfer(decodeAsAddress(0), decodeAsUint(1))
 returnTrue()
 }
 case 0x23b872dd /\* "transferFrom(address,address,uint256)" \*/ {
 transferFrom(decodeAsAddress(0), decodeAsAddress(1), decodeAsUint(2))
 returnTrue()
 }
 case 0x095ea7b3 /\* "approve(address,uint256)" \*/ {
 approve(decodeAsAddress(0), decodeAsUint(1))
 returnTrue()
 }
 case 0xdd62ed3e /\* "allowance(address,address)" \*/ {
 returnUint(allowance(decodeAsAddress(0), decodeAsAddress(1)))
 }
 case 0x40c10f19 /\* "mint(address,uint256)" \*/ {
 mint(decodeAsAddress(0), decodeAsUint(1))
 returnTrue()
 }
 default {
 revert(0, 0)
 }
 function mint(account, amount) {
 require(calledByOwner())
 mintTokens(amount)
 addToBalance(account, amount)
 emitTransfer(0, account, amount)
 }
 function transfer(to, amount) {
 executeTransfer(caller(), to, amount)
 }
 function approve(spender, amount) {
 revertIfZeroAddress(spender)
 setAllowance(caller(), spender, amount)
 emitApproval(caller(), spender, amount)
 }
 function transferFrom(from, to, amount) {
 decreaseAllowanceBy(from, caller(), amount)
 executeTransfer(from, to, amount)
 }
 function executeTransfer(from, to, amount) {
 revertIfZeroAddress(to)
 deductFromBalance(from, amount)
 addToBalance(to, amount)
 emitTransfer(from, to, amount)
 }
 /\* ---------- calldata decoding functions ----------- \*/
 function selector() \-> s {
 s := div(calldataload(0), 0x100000000000000000000000000000000000000000000000000000000)
 }
 function decodeAsAddress(offset) \-> v {
 v := decodeAsUint(offset)
 if iszero(iszero(and(v, not(0xffffffffffffffffffffffffffffffffffffffff)))) {
 revert(0, 0)
 }
 }
 function decodeAsUint(offset) \-> v {
 let pos := add(4, mul(offset, 0x20))
 if lt(calldatasize(), add(pos, 0x20)) {
 revert(0, 0)
 }
 v := calldataload(pos)
 }
 /\* ---------- calldata encoding functions ---------- \*/
 function returnUint(v) {
 mstore(0, v)
 return(0, 0x20)
 }
 function returnTrue() {
 returnUint(1)
 }
 /\* -------- events ---------- \*/
 function emitTransfer(from, to, amount) {
 let signatureHash := 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
 emitEvent(signatureHash, from, to, amount)
 }
 function emitApproval(from, spender, amount) {
 let signatureHash := 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925
 emitEvent(signatureHash, from, spender, amount)
 }
 function emitEvent(signatureHash, indexed1, indexed2, nonIndexed) {
 mstore(0, nonIndexed)
 log3(0, 0x20, signatureHash, indexed1, indexed2)
 }
 /\* -------- storage layout ---------- \*/
 function ownerPos() \-> p { p := 0 }
 function totalSupplyPos() \-> p { p := 1 }
 function accountToStorageOffset(account) \-> offset {
 offset := add(0x1000, account)
 }
 function allowanceStorageOffset(account, spender) \-> offset {
 offset := accountToStorageOffset(account)
 mstore(0, offset)
 mstore(0x20, spender)
 offset := keccak256(0, 0x40)
 }
 /\* -------- storage access ---------- \*/
 function owner() \-> o {
 o := sload(ownerPos())
 }
 function totalSupply() \-> supply {
 supply := sload(totalSupplyPos())
 }
 function mintTokens(amount) {
 sstore(totalSupplyPos(), safeAdd(totalSupply(), amount))
 }
 function balanceOf(account) \-> bal {
 bal := sload(accountToStorageOffset(account))
 }
 function addToBalance(account, amount) {
 let offset := accountToStorageOffset(account)
 sstore(offset, safeAdd(sload(offset), amount))
 }
 function deductFromBalance(account, amount) {
 let offset := accountToStorageOffset(account)
 let bal := sload(offset)
 require(lte(amount, bal))
 sstore(offset, sub(bal, amount))
 }
 function allowance(account, spender) \-> amount {
 amount := sload(allowanceStorageOffset(account, spender))
 }
 function setAllowance(account, spender, amount) {
 sstore(allowanceStorageOffset(account, spender), amount)
 }
 function decreaseAllowanceBy(account, spender, amount) {
 let offset := allowanceStorageOffset(account, spender)
 let currentAllowance := sload(offset)
 require(lte(amount, currentAllowance))
 sstore(offset, sub(currentAllowance, amount))
 }
 /\* ---------- utility functions ---------- \*/
 function lte(a, b) \-> r {
 r := iszero(gt(a, b))
 }
 function gte(a, b) \-> r {
 r := iszero(lt(a, b))
 }
 function safeAdd(a, b) \-> r {
 r := add(a, b)
 if or(lt(r, a), lt(r, b)) { revert(0, 0) }
 }
 function calledByOwner() \-> cbo {
 cbo := eq(owner(), caller())
 }
 function revertIfZeroAddress(addr) {
 require(addr)
 }
 function require(condition) {
 if iszero(condition) { revert(0, 0) }
 }
 }
 }
}

# [安装 Solidity 编译器 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/installing-solidity.html) 
 _https://docs.soliditylang.org/zh-cn/latest/installing-solidity.html_

## 版本[](#id1 "此标题的永久链接")
Solidity 的版本遵循 [语义化版本原则](https://semver.org/)。此外， 主版本0（例如：0.x.y）的补丁级版本的发布不会包含重大更改。这意味着用 0.x.y 版本 编译的代码可望用 0.x.z 版本编译，其中 z > y。
除了发行版本外，我们还提供 **每日开发构建版本 （nightly development builds）** ， 目的是使开发人员能够轻松地试用即将推出的功能并提供早期反馈。然而，请注意， 虽然每日开发构建版本通常是很稳定的，但它们包含了来自开发分支的前沿代码， 并不保证总是有效的。尽管我们尽了最大努力， 它们仍可能含有未记录的和/或重大的修改，这些修改不会成为实际发布版本的一部分。 它们也不会用于生产。
当开发智能合约时，您应该使用最新版本的 Solidity。这是因为重大的改变， 以及新的特性和错误修复是定期引入的。 我们目前使用 0.x 版本号 [来表示这种快速的变化的](https://semver.org/#spec-item-4)。
## Remix[](#remix "此标题的永久链接")
_我们推荐使用 Remix 来开发简单合约和快速学习 Solidity。_
[Remix 可以在线使用](https://remix.ethereum.org/)，而无需安装任何东西。 如果您想离线使用，请访问 [https://github.com/ethereum/remix-live/tree/gh-pages#readme](https://github.com/ethereum/remix-live/tree/gh-pages#readme) 并按照页面上的说明操作。 Remix 也是一个方便的选择， 可以在不安装多个Solidity版本的情况下测试每日开发构建版本。
本页的进一步选项详细说明了在您的计算机上安装 Solidity 命令行编译器。 如果您刚好要处理大型合约，或者需要更多的编译选项， 那么您应该选择使用一个命令行编译器。
## npm / Node.js[](#npm-node-js "此标题的永久链接")
使用 `npm` 可以便捷地安装 `solcjs` ，它一个 Solidity 编译器。 但该 solcjs 程序的功能比本页下面描述的访问编译器的方法要少。 在 [使用命令行编译器](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#commandline-compiler) 一章中，我们假定您使用的是全功能的编译器: `solc`。 `solcjs` 的用法在它自己的 [代码仓库](https://github.com/ethereum/solc-js) 中记录。
注意: solc-js项目是通过使用Emscripten从C++版的 solc 衍生出来的， 这意味着两者使用相同的编译器源代码。 因此， solc-js 可以直接用于JavaScript项目（如 Remix）。 具体介绍请参考solc-js代码库。
备注
在命令行中，可执行文件被命名为 `solcjs`。
`solcjs` 的命令行选项与 `solc` 和一些工具（如 `geth`）是不兼容的， 因此不要期望 `solcjs` 能像 `solc` 一样工作。
## Docker[](#docker "此标题的永久链接")
可以使用来自 `ethereum` 组织的 `solc` 镜像来获取Solidity构建的Docker镜像。 使用 `stable` 标签获取最新发布的版本，使用 `nightly` 标签获取 `develop` 分支中潜在的不稳定变更的版本。
Docker镜像会运行编译器可执行文件，以便您可以将所有编译器参数传递给它。 例如，下面的命令提取了稳定版的 `solc` 镜像（如果您还没有）， 并在一个新的容器中运行它，同时传递 `--help` 参数。
docker run ethereum/solc:stable \--help
例如，您可以在0.5.4版本的标签中指定发布的构建版本。
docker run ethereum/solc:0.5.4 \--help
要使用 Docker 镜像来编译主机上的 Solidity 文件，请安装一个本地文件夹 用于输入和输出，并指定要编译的合约。例如：
docker run \-v /local/path:/sources ethereum/solc:stable \-o /sources/output \--abi \--bin /sources/Contract.sol
您也可以使用标准的JSON接口（当使用工具化的编译器时建议使用这种方式）。 当使用这个接口时，不需要装载任何目录，只要输入的JSON是自成一体的 （即它没有引用任何外部文件，而这些文件必须要被 [由导入回调](https://docs.soliditylang.org/zh-cn/latest/path-resolution.html#initial-vfs-content-standard-json-with-import-callback)）。
docker run ethereum/solc:stable \--standard-json < input.json \> output.json
## Linux 包[](#linux "此标题的永久链接")
Solidity 的二进制安装包可在 [solidity/releases](https://github.com/ethereum/solidity/releases) 找到。
对于 Ubuntu ，我们也提供 PPAs 。通过以下命令，可获取最新的稳定版本：
sudo add-apt-repository ppa:ethereum/ethereum
sudo apt-get update
sudo apt-get install solc
您也可以使用以下命令安装每日开发构建版本：
sudo add-apt-repository ppa:ethereum/ethereum
sudo add-apt-repository ppa:ethereum/ethereum-dev
sudo apt-get update
sudo apt-get install solc
此外，一些 Linux 发行版提供了他们自己的软件包。这些软件包不是由我们直接维护的， 但通常由各自的软件包维护者保持最新。
例如，Arch Linux 将最新开发版本的软件包作为AUR软件包： [solidity](https://aur.archlinux.org/packages/solidity) 和 [solidity-bin](https://aur.archlinux.org/packages/solidity-bin)。
备注
请注意， [AUR](https://wiki.archlinux.org/title/Arch_User_Repository) 包 是用户生成的内容且是非官方包。使用它们时请务必小心。
还有一个 [snap包](https://snapcraft.io/solc)，然而，它 **目前没有维护** 。 它可以安装在所有 [支持的Linux发行版](https://snapcraft.io/docs/core/install) 。通过以下命令， 安装最新的稳定版本的 solc：
如果您想测试 develop 分支下的最新变更，请使用以下方式：
sudo snap install solc \--edge
## macOS 软件包[](#macos "此标题的永久链接")
我们通过 Homebrew 作为从源头建立的版本, 发布 Solidity 编译器，目前不支持预构建。
brew update
brew upgrade
brew tap ethereum/ethereum
brew install solidity
要安装最新的 0.4.x/0.5.x 版本的 Solidity，您也可以分别使用 `brew install solidity@4` 和 `brew install solidity@5`。
如果您需要特定版本的 Solidity，您可以直接从 Github 上安装一个 Homebrew 列表。
参见 [solidity.rb 在 Github 上的提交情况](https://github.com/ethereum/homebrew-ethereum/commits/master/solidity.rb).
复制您想要的版本的提交哈希值，然后在您的机器上检出该分支。
git clone https://github.com/ethereum/homebrew-ethereum.git
cd homebrew-ethereum
git checkout <your-hash-goes-here>
使用 `brew` 安装:
brew unlink solidity
＃ 例如，安装 0.4.8
brew install solidity.rb
## 静态二进制文件[](#id8 "此标题的永久链接")
我们在 [solc-bin](https://github.com/ethereum/solc-bin/) 上维护了一个包含过去和现在编译器版本的静态构建的资源库，用于所有支持的平台。 您也可以找到每日开发构建版本。
该资源库不仅是一个快速且简单的方法，让终端用户获得可以开箱即用的二进制文件， 而且它对第三方工具也很友好：
* 这些内容被镜像到 [https://binaries.soliditylang.org](https://binaries.soliditylang.org/)，在那里可以很容易地通过HTTPS下载， 而没有任何认证、速率或需要使用git的限制。
 
* 提供的内容具有正确的 Content-Type 请求头和宽松的 CORS 配置， 因此它可以被运行在浏览器中的工具直接加载。
 
* 二进制文件不需要安装或解压（对于附带所需DLLs的旧版Windows构建除外）。
 
* 我们努力争取高水平的向后兼容性。文件一旦被添加，在没有提供旧位置的链接/重定向的情况下，不会被删除或移动。 它们也不会被修改，而且应始终与原始校验相匹配。唯一的例外是破损或无法使用的文件， 如果保持原样，有可能造成更大的伤害。
 
* 文件是通过 HTTP 和 HTTPS 提供的。只要您以安全的方式获得文件列表 （通过 git、HTTPS、IPFS 或者只是在本地的缓存），并在下载后验证二进制文件的哈希值， 您就不必通过HTTPS获得二进制文件。
 
在大多数情况下，同样的二进制文件可以在 [Github 上的 Solidity 发布页](https://github.com/ethereum/solidity/releases) 中找到。 不同的是，我们一般不更新Github已发布的旧版本。这意味着如果命名规则改变，我们不会重新命名， 也不会为发布时不支持的平台添加构建。这只发生在 `solc-bin` 资源库里。
`solc-bin` 资源库包含几个顶级目录，每个目录代表一个平台。 每个目录都包含一个 `list.json` 文件，列出可用的二进制文件。 例如，在 `emscripten-wasm32/list.json` 中您会发现以下关于 0.7.4 版本的信息：
{
 "path": "solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js",
 "version": "0.7.4",
 "build": "commit.3f05b770",
 "longVersion": "0.7.4+commit.3f05b770",
 "keccak256": "0x300330ecd127756b824aa13e843cb1f43c473cb22eaf3750d5fb9c99279af8c3",
 "sha256": "0x2b55ed5fec4d9625b6c7b3ab1abd2b7fb7dd2a9c68543bf0323db2c7e2d55af2",
 "urls": \[
 "bzzr://16c5f09109c793db99fe35f037c6092b061bd39260ee7a677c8a97f18c955ab1",
 "dweb:/ipfs/QmTLs5MuLEWXQkths41HiACoXDiH8zxyqBHGFDRSzVE5CS"
 \]
}
这意味着：
* 您可以在同一目录下找到二进制文件，名称为 [solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js](https://github.com/ethereum/solc-bin/blob/gh-pages/emscripten-wasm32/solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js). 注意，该文件可能是一个软链接，如果您没有使用 git 下载，或者您的文件系统不支持软链接，您需要自己解决。
 
* 该二进制文件也被镜像在 [https://binaries.soliditylang.org/emscripten-wasm32/solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js](https://binaries.soliditylang.org/emscripten-wasm32/solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js). 在这种情况下，不需要 git，软链接的解决方式是显而易见的，要么提供一个文件的副本，要么返回一个 HTTP 重定向。
 
* 该文件也可在 IPFS上 找到，地址是 [QmTLs5MuLEWXQkths41HiACoXDiH8zxyqBHGFDRSzVE5CS](https://gateway.ipfs.io/ipfs/QmTLs5MuLEWXQkths41HiACoXDiH8zxyqBHGFDRSzVE5CS).
 
* 该文件将来可能会存储在 Swarm 上， 地址是 [16c5f09109c793db99fe35f037c6092b061bd39260ee7a677c8a97f18c955ab1](https://swarm-gateways.net/bzz:/16c5f09109c793db99fe35f037c6092b061bd39260ee7a677c8a97f18c955ab1/).
 
* 您可以通过比较其keccak256哈希值来验证二进制文件的完整性 `0x300330ecd127756b824aa13e843cb1f43c473cb22eaf3750d5fb9c99279af8c3`。哈希值可以在命令行上 使用 [sha3sum](https://github.com/maandree/sha3sum) 提供的 `keccak256sum` 工具 或在 JavaScript 中使用 [ethereumjs-util 的 keccak256() 函数](https://github.com/ethereumjs/ethereumjs-util/blob/master/docs/modules/_hash_.md#const-keccak256)
 
* 您也可以通过比较二进制文件的sha256哈希值来验证它的完整性 `0x2b55ed5fec4d9625b6c7b3ab1abd2b7fb7dd2a9c68543bf0323db2c7e2d55af2`。
 
警告
由于高度的向后兼容性要求，版本库包含一些遗留元素，但您在编写新工具时应避免使用它们：
* 如果您想获得最佳的性能，请使用 `emscripten-wasm32/` （有回退功能的 `emscripten-asmjs/`）而不是 `bin/`。 在 0.6.1 版本之前，我们只提供 asm.js 二进制文件。从 0.6.2 开始，我们改用 [WebAssembly 构建](https://emscripten.org/docs/compiling/WebAssembly.html)，性能好得多。 我们已经为wasm重建了旧版本，但原来的asm.js文件仍然在 `bin/` 下。 新的文件必须放在一个单独的目录中，以避免名称冲突。
 
* 如果您想确定下载的是 wasm 还是 asm.js 二进制文件，请使用 `emscripten-asmjs/` 和 `emscripten-wasm32/` 而不是 `bin/` 和 `wasm/` 目录。
 
* 使用 `list.json` 代替 `list.js` 和 `list.txt`。JSON列表格式包含了旧列表的所有信息。
 
* 使用 [https://binaries.soliditylang.org](https://binaries.soliditylang.org/)，而不是 [https://solc-bin.ethereum.org](https://solc-bin.ethereum.org/)。 为了使事情简单化，我们把几乎所有与编译器有关的东西都移到了新的域名 `soliditylang.org` 下， 这也适用于 `solc-bin`。虽然推荐使用新的域名，但旧的域名仍然被完全支持，并保证指向同一位置。
 
## 从源代码编译[](#building-from-source "此标题的永久链接")
### 先决条件 - 所有操作系统[](#id10 "此标题的永久链接")
以下是 Solidity 构建的所有依赖性：
软件
备注
[CMake](https://cmake.org/download/) （在Windows上为3.21.3以上版本， 其他为3.13以上版）
跨平台构建文件生成器。
[Boost](https://www.boost.org/) （Windows系统为1.77以上版本， 其他系统1.65以上版）
C++ 库。
[Git](https://git-scm.com/download)
用于获取源代码的命令行工具。
[z3](https://github.com/Z3Prover/z3) （4.8.16以上版本, 可选）
与SMT检查器一起使用。
[cvc4](https://cvc4.cs.stanford.edu/web/) （可选）
与SMT检查器一起使用。
备注
0.5.10 之前的 Solidity 版本可能无法与 Boost 1.70 以上版本正确链接。 一个可能的解决方法是，在运行 cmake 命令配置 Solidity 之前，暂时重命名 `<Boost install path>/lib/cmake/Boost-1.70.0`。
从 0.5.10 开始，针对 Boost 1.70 以上版本的链接应该无需人工干预。
备注
默认的构建配置需要一个特定的 Z3 版本（在代码最后更新时的最新版本）。 Z3 版本之间的变化常常导致返回的结果略有不同（但仍然有效）。 我们的SMT测试没有考虑到这些差异，很可能会在不同的版本中失败，而不是为其编写的版本。 这并不意味着使用不同版本的构建是有问题的。如果将 `-DSTRICT_Z3_VERSION=OFF` 选项传递给CMake， 您可以使用任何满足上表要求的版本进行构建。 然而，如果您这样做，请记得在 `scripts/tests.sh` 中传递 `--no-smt` 选项以跳过SMT测试。
备注
默认情况下，编译是以 _语义模式_ 进行的，这将启用额外的警告，并告诉编译器将所有警告视为错误。 这迫使开发人员在警告出现时进行修复，因此它们不会累积到“以后再修复”。 如果您只对创建发布版本感兴趣，不打算修改源代码来处理这些警告， 您可以向CMake传递 `-DPEDANTIC=OFF` 选项来禁用这种模式。 一般情况下不建议这样做，但在使用我们没有测试过的工具链或试图用较新的工具构建旧版本时， 可能需要这样做。 如果您遇到这种警告，请考虑 [报告它们](https://github.com/ethereum/solidity/issues/new)。
#### 最小编译器版本[](#id12 "此标题的永久链接")
以下C++编译器及其最小版本可构建 Solidity 代码库：
* [GCC](https://gcc.gnu.org/), 8以上版本
 
* [Clang](https://clang.llvm.org/), 7以上版本
 
* [MSVC](https://visualstudio.microsoft.com/vs/), 2019以上版本
 
### 先决条件 - macOS[](#id13 "此标题的永久链接")
对于 macOS 的构建，确保最新版本的 [Xcode 已安装](https://developer.apple.com/xcode/resources/)。 这包含了 [Clang C++ 编译器](https://en.wikipedia.org/wiki/Clang)， [Xcode IDE](https://en.wikipedia.org/wiki/Xcode) 和其他苹果公司的开发工具， 这些工具是在 OS X 上构建 C++ 应用程序所必须的。 如果您是第一次安装 Xcode，或者刚刚安装了一个新的版本， 那么您在使用命令行构建前，需同意使用协议：
sudo xcodebuild \-license accept
我们的 OS X 构建脚本使用 [the Homebrew](https://brew.sh/) 软件包管理器来安装外部依赖。 如果您想从头开始的话，以下是如何 [卸载Homebrew](https://docs.brew.sh/FAQ#how-do-i-uninstall-homebrew)。
### 先决条件 - Windows[](#windows "此标题的永久链接")
您需要为 Solidity 的 Windows 版本安装以下依赖软件包:
如果您已经有一个 IDE 并且只需要编译器和库文件。您可以安装 Visual Studio 2019 构建工具。
Visual Studio 2019 同时提供IDE和必要的编译器和库。 所以，如果您没有一个 IDE，并且想要开发 Solidity， 那么 Visual Studio 2019 将是一个可以使您轻松获得一切设置的选择。
以下是应在 Visual Studio 2019 构建工具或 Visual Studio 2019 中安装的组件列表：
* Visual Studio C++ core features
 
* VC++ 2019 v141 toolset (x86,x64)
 
* Windows Universal CRT SDK
 
* Windows 8.1 SDK
 
* C++/CLI support
 
我们有一个辅助脚本，您可以用它来安装所有需要的外部依赖：
这将安装 `boost` 和 `cmake` 到 `deps` 子目录。
### 克隆代码库[](#id14 "此标题的永久链接")
执行以下命令，克隆源代码：
git clone \--recursive https://github.com/ethereum/solidity.git
cd solidity
如果您想帮助开发 Solidity， 您可以分叉（fork） Solidity，然后将您个人的分叉库作为第二远程源添加。
git remote add personal git@github.com:\[username\]/solidity.git
### 命令行构建[](#id15 "此标题的永久链接")
**请确保在构建前安装外部依赖项（见上文）。**
Solidity 项目使用 CMake 来配置构建。 您可能想安装 [ccache](https://ccache.dev/) 以加快重复构建的速度。CMake 会自动使用它。 在 Linux、macOS 和其他 Unix 系统上构建 Solidity 方式都差不多：
mkdir build
cd build
cmake .. && make
或者在 Linux 和 macOS 上有更简单的方式，您可以运行：
＃注意：这将在 usr/local/bin 安装 solc 和 soltest 的二进制文件。
./scripts/build.sh
警告
BSD 构建应该也可以工作，但是 Solidity 团队没有测试过。
对于 Windows 执行：
mkdir build
cd build
cmake \-G "Visual Studio 16 2019" ..
如果您想使用由 `scripts\install_deps.ps1` 安装的 boost 版本， 您需要额外传递 `-DBoost_DIR="deps\boost\lib\cmake\Boost-*"` 和 `-DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreaded` 作为参数给 `cmake` 调用。
这将会导致在构建目录中创建 **solidity.sln** 文件。 双击该文件，Visual Studio 就会启动。 我们建议创建 **Release** 配置，但其他的配置也可以。
或者，您可以在命令行上为 Windows 构建，像这样：
cmake \--build . \--config Release
## CMake 选项[](#id16 "此标题的永久链接")
如果您对CMake的可选项感兴趣，可以运行 `cmake ... -LH`。
### SMT 解算器[](#smt "此标题的永久链接")
Solidity 可以针对 SMT 解算器进行构建，如果它们在系统中被发现， 将默认为是这样做的。每个解算器都可以通过 `cmake` 选项禁用。
_注意：在某些情况下，这也可以是构建失败后，可能的变通方法。_
在构建文件夹内，您可以禁用它们，因为它们是默认启用的:
＃ 只禁用Z3 SMT解算器。
cmake .. -DUSE_Z3=OFF
# 只禁用CVC4 SMT解算器。
cmake .. -DUSE_CVC4=OFF
# 同时禁用Z3和CVC4
cmake .. -DUSE_CVC4=OFF -DUSE_Z3=OFF
## 版本号字符串详解[](#id17 "此标题的永久链接")
Solidity 版本名包含四部分：
* 版本号
 
* 预发布版本标签，通常为 `develop.YYYY.MM.DD` 或者 `nightly.YYYY.MM.DD`
 
* 以 `commit.GITHASH` 格式展示的提交号
 
* 由若干条平台、编译器详细信息构成的平台标识
 
如果有本地修改，提交将会有后缀 `.mod`。
这些部分按照 Semver 的要求来组合， 其中 Solidity 预发布版标签等价于 Semver 预发布版标签， 而 Solidity 提交号和平台标识则组成Semver的构建元数据。
发布版样例: `0.4.8+commit.60cc1668.Emscripten.clang`。
预发布版样例: `0.4.9-nightly.2017.1.17+commit.6ecb4aa3.Emscripten.clang`。
## 关于版本管理的重要信息[](#id18 "此标题的永久链接")
在版本发布之后，补丁版本号会增加，因为我们假定接下来只有补丁级别的变更。 当变更被合并后，版本应该根据 Semver 和变更的重要程度来提升。 最后，发行版本总是与当前每日开发构建版本本的版本号一致，但没有 `prerelease` 指示符。
示例:
1. 0.4.0 版本发布。
 
2. 从现在开始，每晚构建一个 0.4.1 版本。
 
3. 引入非重大变更 —— 不改变版本号。
 
4. 引入重大变更 —— 版本号提升到 0.5.0。
 
5. 0.5.0 版本发布。
 
该方式与 [版本编译指示](https://docs.soliditylang.org/zh-cn/latest/layout-of-source-files.html#version-pragma) 配合得很好。

# [Solidity by Example — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/solidity-by-example.html) 
 _https://docs.soliditylang.org/en/latest/solidity-by-example.html_

## Voting[](#voting "Link to this heading")
The following contract is quite complex, but showcases a lot of Solidity’s features. It implements a voting contract. Of course, the main problems of electronic voting is how to assign voting rights to the correct persons and how to prevent manipulation. We will not solve all problems here, but at least we will show how delegated voting can be done so that vote counting is **automatic and completely transparent** at the same time.
The idea is to create one contract per ballot, providing a short name for each option. Then the creator of the contract who serves as chairperson will give the right to vote to each address individually.
The persons behind the addresses can then choose to either vote themselves or to delegate their vote to a person they trust.
At the end of the voting time, `winningProposal()` will return the proposal with the largest number of votes.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwovLy8gQHRpdGxlIFZvdGluZyB3aXRoIGRlbGVnYXRpb24uCmNvbnRyYWN0IEJhbGxvdCB7CiAgICAvLyBUaGlzIGRlY2xhcmVzIGEgbmV3IGNvbXBsZXggdHlwZSB3aGljaCB3aWxsCiAgICAvLyBiZSB1c2VkIGZvciB2YXJpYWJsZXMgbGF0ZXIuCiAgICAvLyBJdCB3aWxsIHJlcHJlc2VudCBhIHNpbmdsZSB2b3Rlci4KICAgIHN0cnVjdCBWb3RlciB7CiAgICAgICAgdWludCB3ZWlnaHQ7IC8vIHdlaWdodCBpcyBhY2N1bXVsYXRlZCBieSBkZWxlZ2F0aW9uCiAgICAgICAgYm9vbCB2b3RlZDsgIC8vIGlmIHRydWUsIHRoYXQgcGVyc29uIGFscmVhZHkgdm90ZWQKICAgICAgICBhZGRyZXNzIGRlbGVnYXRlOyAvLyBwZXJzb24gZGVsZWdhdGVkIHRvCiAgICAgICAgdWludCB2b3RlOyAgIC8vIGluZGV4IG9mIHRoZSB2b3RlZCBwcm9wb3NhbAogICAgfQoKICAgIC8vIFRoaXMgaXMgYSB0eXBlIGZvciBhIHNpbmdsZSBwcm9wb3NhbC4KICAgIHN0cnVjdCBQcm9wb3NhbCB7CiAgICAgICAgYnl0ZXMzMiBuYW1lOyAgIC8vIHNob3J0IG5hbWUgKHVwIHRvIDMyIGJ5dGVzKQogICAgICAgIHVpbnQgdm90ZUNvdW50OyAvLyBudW1iZXIgb2YgYWNjdW11bGF0ZWQgdm90ZXMKICAgIH0KCiAgICBhZGRyZXNzIHB1YmxpYyBjaGFpcnBlcnNvbjsKCiAgICAvLyBUaGlzIGRlY2xhcmVzIGEgc3RhdGUgdmFyaWFibGUgdGhhdAogICAgLy8gc3RvcmVzIGEgYFZvdGVyYCBzdHJ1Y3QgZm9yIGVhY2ggcG9zc2libGUgYWRkcmVzcy4KICAgIG1hcHBpbmcoYWRkcmVzcyA9PiBWb3RlcikgcHVibGljIHZvdGVyczsKCiAgICAvLyBBIGR5bmFtaWNhbGx5LXNpemVkIGFycmF5IG9mIGBQcm9wb3NhbGAgc3RydWN0cy4KICAgIFByb3Bvc2FsW10gcHVibGljIHByb3Bvc2FsczsKCiAgICAvLy8gQ3JlYXRlIGEgbmV3IGJhbGxvdCB0byBjaG9vc2Ugb25lIG9mIGBwcm9wb3NhbE5hbWVzYC4KICAgIGNvbnN0cnVjdG9yKGJ5dGVzMzJbXSBtZW1vcnkgcHJvcG9zYWxOYW1lcykgewogICAgICAgIGNoYWlycGVyc29uID0gbXNnLnNlbmRlcjsKICAgICAgICB2b3RlcnNbY2hhaXJwZXJzb25dLndlaWdodCA9IDE7CgogICAgICAgIC8vIEZvciBlYWNoIG9mIHRoZSBwcm92aWRlZCBwcm9wb3NhbCBuYW1lcywKICAgICAgICAvLyBjcmVhdGUgYSBuZXcgcHJvcG9zYWwgb2JqZWN0IGFuZCBhZGQgaXQKICAgICAgICAvLyB0byB0aGUgZW5kIG9mIHRoZSBhcnJheS4KICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCBwcm9wb3NhbE5hbWVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIC8vIGBQcm9wb3NhbCh7Li4ufSlgIGNyZWF0ZXMgYSB0ZW1wb3JhcnkKICAgICAgICAgICAgLy8gUHJvcG9zYWwgb2JqZWN0IGFuZCBgcHJvcG9zYWxzLnB1c2goLi4uKWAKICAgICAgICAgICAgLy8gYXBwZW5kcyBpdCB0byB0aGUgZW5kIG9mIGBwcm9wb3NhbHNgLgogICAgICAgICAgICBwcm9wb3NhbHMucHVzaChQcm9wb3NhbCh7CiAgICAgICAgICAgICAgICBuYW1lOiBwcm9wb3NhbE5hbWVzW2ldLAogICAgICAgICAgICAgICAgdm90ZUNvdW50OiAwCiAgICAgICAgICAgIH0pKTsKICAgICAgICB9CiAgICB9CgogICAgLy8gR2l2ZSBgdm90ZXJgIHRoZSByaWdodCB0byB2b3RlIG9uIHRoaXMgYmFsbG90LgogICAgLy8gTWF5IG9ubHkgYmUgY2FsbGVkIGJ5IGBjaGFpcnBlcnNvbmAuCiAgICBmdW5jdGlvbiBnaXZlUmlnaHRUb1ZvdGUoYWRkcmVzcyB2b3RlcikgZXh0ZXJuYWwgewogICAgICAgIC8vIElmIHRoZSBmaXJzdCBhcmd1bWVudCBvZiBgcmVxdWlyZWAgZXZhbHVhdGVzCiAgICAgICAgLy8gdG8gYGZhbHNlYCwgZXhlY3V0aW9uIHRlcm1pbmF0ZXMgYW5kIGFsbAogICAgICAgIC8vIGNoYW5nZXMgdG8gdGhlIHN0YXRlIGFuZCB0byBFdGhlciBiYWxhbmNlcwogICAgICAgIC8vIGFyZSByZXZlcnRlZC4KICAgICAgICAvLyBUaGlzIHVzZWQgdG8gY29uc3VtZSBhbGwgZ2FzIGluIG9sZCBFVk0gdmVyc2lvbnMsIGJ1dAogICAgICAgIC8vIG5vdCBhbnltb3JlLgogICAgICAgIC8vIEl0IGlzIG9mdGVuIGEgZ29vZCBpZGVhIHRvIHVzZSBgcmVxdWlyZWAgdG8gY2hlY2sgaWYKICAgICAgICAvLyBmdW5jdGlvbnMgYXJlIGNhbGxlZCBjb3JyZWN0bHkuCiAgICAgICAgLy8gQXMgYSBzZWNvbmQgYXJndW1lbnQsIHlvdSBjYW4gYWxzbyBwcm92aWRlIGFuCiAgICAgICAgLy8gZXhwbGFuYXRpb24gYWJvdXQgd2hhdCB3ZW50IHdyb25nLgogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgIG1zZy5zZW5kZXIgPT0gY2hhaXJwZXJzb24sCiAgICAgICAgICAgICJPbmx5IGNoYWlycGVyc29uIGNhbiBnaXZlIHJpZ2h0IHRvIHZvdGUuIgogICAgICAgICk7CiAgICAgICAgcmVxdWlyZSgKICAgICAgICAgICAgIXZvdGVyc1t2b3Rlcl0udm90ZWQsCiAgICAgICAgICAgICJUaGUgdm90ZXIgYWxyZWFkeSB2b3RlZC4iCiAgICAgICAgKTsKICAgICAgICByZXF1aXJlKHZvdGVyc1t2b3Rlcl0ud2VpZ2h0ID09IDApOwogICAgICAgIHZvdGVyc1t2b3Rlcl0ud2VpZ2h0ID0gMTsKICAgIH0KCiAgICAvLy8gRGVsZWdhdGUgeW91ciB2b3RlIHRvIHRoZSB2b3RlciBgdG9gLgogICAgZnVuY3Rpb24gZGVsZWdhdGUoYWRkcmVzcyB0bykgZXh0ZXJuYWwgewogICAgICAgIC8vIGFzc2lnbnMgcmVmZXJlbmNlCiAgICAgICAgVm90ZXIgc3RvcmFnZSBzZW5kZXIgPSB2b3RlcnNbbXNnLnNlbmRlcl07CiAgICAgICAgcmVxdWlyZShzZW5kZXIud2VpZ2h0ICE9IDAsICJZb3UgaGF2ZSBubyByaWdodCB0byB2b3RlIik7CiAgICAgICAgcmVxdWlyZSghc2VuZGVyLnZvdGVkLCAiWW91IGFscmVhZHkgdm90ZWQuIik7CgogICAgICAgIHJlcXVpcmUodG8gIT0gbXNnLnNlbmRlciwgIlNlbGYtZGVsZWdhdGlvbiBpcyBkaXNhbGxvd2VkLiIpOwoKICAgICAgICAvLyBGb3J3YXJkIHRoZSBkZWxlZ2F0aW9uIGFzIGxvbmcgYXMKICAgICAgICAvLyBgdG9gIGFsc28gZGVsZWdhdGVkLgogICAgICAgIC8vIEluIGdlbmVyYWwsIHN1Y2ggbG9vcHMgYXJlIHZlcnkgZGFuZ2Vyb3VzLAogICAgICAgIC8vIGJlY2F1c2UgaWYgdGhleSBydW4gdG9vIGxvbmcsIHRoZXkgbWlnaHQKICAgICAgICAvLyBuZWVkIG1vcmUgZ2FzIHRoYW4gaXMgYXZhaWxhYmxlIGluIGEgYmxvY2suCiAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCB0aGUgZGVsZWdhdGlvbiB3aWxsIG5vdCBiZSBleGVjdXRlZCwKICAgICAgICAvLyBidXQgaW4gb3RoZXIgc2l0dWF0aW9ucywgc3VjaCBsb29wcyBtaWdodAogICAgICAgIC8vIGNhdXNlIGEgY29udHJhY3QgdG8gZ2V0ICJzdHVjayIgY29tcGxldGVseS4KICAgICAgICB3aGlsZSAodm90ZXJzW3RvXS5kZWxlZ2F0ZSAhPSBhZGRyZXNzKDApKSB7CiAgICAgICAgICAgIHRvID0gdm90ZXJzW3RvXS5kZWxlZ2F0ZTsKCiAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgbG9vcCBpbiB0aGUgZGVsZWdhdGlvbiwgbm90IGFsbG93ZWQuCiAgICAgICAgICAgIHJlcXVpcmUodG8gIT0gbXNnLnNlbmRlciwgIkZvdW5kIGxvb3AgaW4gZGVsZWdhdGlvbi4iKTsKICAgICAgICB9CgogICAgICAgIFZvdGVyIHN0b3JhZ2UgZGVsZWdhdGVfID0gdm90ZXJzW3RvXTsKCiAgICAgICAgLy8gVm90ZXJzIGNhbm5vdCBkZWxlZ2F0ZSB0byBhY2NvdW50cyB0aGF0IGNhbm5vdCB2b3RlLgogICAgICAgIHJlcXVpcmUoZGVsZWdhdGVfLndlaWdodCA+PSAxKTsKCiAgICAgICAgLy8gU2luY2UgYHNlbmRlcmAgaXMgYSByZWZlcmVuY2UsIHRoaXMKICAgICAgICAvLyBtb2RpZmllcyBgdm90ZXJzW21zZy5zZW5kZXJdYC4KICAgICAgICBzZW5kZXIudm90ZWQgPSB0cnVlOwogICAgICAgIHNlbmRlci5kZWxlZ2F0ZSA9IHRvOwoKICAgICAgICBpZiAoZGVsZWdhdGVfLnZvdGVkKSB7CiAgICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBhbHJlYWR5IHZvdGVkLAogICAgICAgICAgICAvLyBkaXJlY3RseSBhZGQgdG8gdGhlIG51bWJlciBvZiB2b3RlcwogICAgICAgICAgICBwcm9wb3NhbHNbZGVsZWdhdGVfLnZvdGVdLnZvdGVDb3VudCArPSBzZW5kZXIud2VpZ2h0OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBkaWQgbm90IHZvdGUgeWV0LAogICAgICAgICAgICAvLyBhZGQgdG8gaGVyIHdlaWdodC4KICAgICAgICAgICAgZGVsZWdhdGVfLndlaWdodCArPSBzZW5kZXIud2VpZ2h0OwogICAgICAgIH0KICAgIH0KCiAgICAvLy8gR2l2ZSB5b3VyIHZvdGUgKGluY2x1ZGluZyB2b3RlcyBkZWxlZ2F0ZWQgdG8geW91KQogICAgLy8vIHRvIHByb3Bvc2FsIGBwcm9wb3NhbHNbcHJvcG9zYWxdLm5hbWVgLgogICAgZnVuY3Rpb24gdm90ZSh1aW50IHByb3Bvc2FsKSBleHRlcm5hbCB7CiAgICAgICAgVm90ZXIgc3RvcmFnZSBzZW5kZXIgPSB2b3RlcnNbbXNnLnNlbmRlcl07CiAgICAgICAgcmVxdWlyZShzZW5kZXIud2VpZ2h0ICE9IDAsICJIYXMgbm8gcmlnaHQgdG8gdm90ZSIpOwogICAgICAgIHJlcXVpcmUoIXNlbmRlci52b3RlZCwgIkFscmVhZHkgdm90ZWQuIik7CiAgICAgICAgc2VuZGVyLnZvdGVkID0gdHJ1ZTsKICAgICAgICBzZW5kZXIudm90ZSA9IHByb3Bvc2FsOwoKICAgICAgICAvLyBJZiBgcHJvcG9zYWxgIGlzIG91dCBvZiB0aGUgcmFuZ2Ugb2YgdGhlIGFycmF5LAogICAgICAgIC8vIHRoaXMgd2lsbCB0aHJvdyBhdXRvbWF0aWNhbGx5IGFuZCByZXZlcnQgYWxsCiAgICAgICAgLy8gY2hhbmdlcy4KICAgICAgICBwcm9wb3NhbHNbcHJvcG9zYWxdLnZvdGVDb3VudCArPSBzZW5kZXIud2VpZ2h0OwogICAgfQoKICAgIC8vLyBAZGV2IENvbXB1dGVzIHRoZSB3aW5uaW5nIHByb3Bvc2FsIHRha2luZyBhbGwKICAgIC8vLyBwcmV2aW91cyB2b3RlcyBpbnRvIGFjY291bnQuCiAgICBmdW5jdGlvbiB3aW5uaW5nUHJvcG9zYWwoKSBwdWJsaWMgdmlldwogICAgICAgICAgICByZXR1cm5zICh1aW50IHdpbm5pbmdQcm9wb3NhbF8pCiAgICB7CiAgICAgICAgdWludCB3aW5uaW5nVm90ZUNvdW50ID0gMDsKICAgICAgICBmb3IgKHVpbnQgcCA9IDA7IHAgPCBwcm9wb3NhbHMubGVuZ3RoOyBwKyspIHsKICAgICAgICAgICAgaWYgKHByb3Bvc2Fsc1twXS52b3RlQ291bnQgPiB3aW5uaW5nVm90ZUNvdW50KSB7CiAgICAgICAgICAgICAgICB3aW5uaW5nVm90ZUNvdW50ID0gcHJvcG9zYWxzW3BdLnZvdGVDb3VudDsKICAgICAgICAgICAgICAgIHdpbm5pbmdQcm9wb3NhbF8gPSBwOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQoKICAgIC8vIENhbGxzIHdpbm5pbmdQcm9wb3NhbCgpIGZ1bmN0aW9uIHRvIGdldCB0aGUgaW5kZXgKICAgIC8vIG9mIHRoZSB3aW5uZXIgY29udGFpbmVkIGluIHRoZSBwcm9wb3NhbHMgYXJyYXkgYW5kIHRoZW4KICAgIC8vIHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHdpbm5lcgogICAgZnVuY3Rpb24gd2lubmVyTmFtZSgpIGV4dGVybmFsIHZpZXcKICAgICAgICAgICAgcmV0dXJucyAoYnl0ZXMzMiB3aW5uZXJOYW1lXykKICAgIHsKICAgICAgICB3aW5uZXJOYW1lXyA9IHByb3Bvc2Fsc1t3aW5uaW5nUHJvcG9zYWwoKV0ubmFtZTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
/// @title Voting with delegation.
contract Ballot {
 // This declares a new complex type which will
 // be used for variables later.
 // It will represent a single voter.
 struct Voter {
 uint weight; // weight is accumulated by delegation
 bool voted; // if true, that person already voted
 address delegate; // person delegated to
 uint vote; // index of the voted proposal
 }
 // This is a type for a single proposal.
 struct Proposal {
 bytes32 name; // short name (up to 32 bytes)
 uint voteCount; // number of accumulated votes
 }
 address public chairperson;
 // This declares a state variable that
 // stores a \`Voter\` struct for each possible address.
 mapping(address \=> Voter) public voters;
 // A dynamically-sized array of \`Proposal\` structs.
 Proposal\[\] public proposals;
 /// Create a new ballot to choose one of \`proposalNames\`.
 constructor(bytes32\[\] memory proposalNames) {
 chairperson \= msg.sender;
 voters\[chairperson\].weight \= 1;
 // For each of the provided proposal names,
 // create a new proposal object and add it
 // to the end of the array.
 for (uint i \= 0; i < proposalNames.length; i++) {
 // \`Proposal({...})\` creates a temporary
 // Proposal object and \`proposals.push(...)\`
 // appends it to the end of \`proposals\`.
 proposals.push(Proposal({
 name: proposalNames\[i\],
 voteCount: 0
 }));
 }
 }
 // Give \`voter\` the right to vote on this ballot.
 // May only be called by \`chairperson\`.
 function giveRightToVote(address voter) external {
 // If the first argument of \`require\` evaluates
 // to \`false\`, execution terminates and all
 // changes to the state and to Ether balances
 // are reverted.
 // This used to consume all gas in old EVM versions, but
 // not anymore.
 // It is often a good idea to use \`require\` to check if
 // functions are called correctly.
 // As a second argument, you can also provide an
 // explanation about what went wrong.
 require(
 msg.sender \== chairperson,
 "Only chairperson can give right to vote."
 );
 require(
 !voters\[voter\].voted,
 "The voter already voted."
 );
 require(voters\[voter\].weight \== 0);
 voters\[voter\].weight \= 1;
 }
 /// Delegate your vote to the voter \`to\`.
 function delegate(address to) external {
 // assigns reference
 Voter storage sender \= voters\[msg.sender\];
 require(sender.weight != 0, "You have no right to vote");
 require(!sender.voted, "You already voted.");
 require(to != msg.sender, "Self-delegation is disallowed.");
 // Forward the delegation as long as
 // \`to\` also delegated.
 // In general, such loops are very dangerous,
 // because if they run too long, they might
 // need more gas than is available in a block.
 // In this case, the delegation will not be executed,
 // but in other situations, such loops might
 // cause a contract to get "stuck" completely.
 while (voters\[to\].delegate != address(0)) {
 to \= voters\[to\].delegate;
 // We found a loop in the delegation, not allowed.
 require(to != msg.sender, "Found loop in delegation.");
 }
 Voter storage delegate\_ \= voters\[to\];
 // Voters cannot delegate to accounts that cannot vote.
 require(delegate\_.weight \>= 1);
 // Since \`sender\` is a reference, this
 // modifies \`voters\[msg.sender\]\`.
 sender.voted \= true;
 sender.delegate \= to;
 if (delegate\_.voted) {
 // If the delegate already voted,
 // directly add to the number of votes
 proposals\[delegate\_.vote\].voteCount += sender.weight;
 } else {
 // If the delegate did not vote yet,
 // add to her weight.
 delegate\_.weight += sender.weight;
 }
 }
 /// Give your vote (including votes delegated to you)
 /// to proposal \`proposals\[proposal\].name\`.
 function vote(uint proposal) external {
 Voter storage sender \= voters\[msg.sender\];
 require(sender.weight != 0, "Has no right to vote");
 require(!sender.voted, "Already voted.");
 sender.voted \= true;
 sender.vote \= proposal;
 // If \`proposal\` is out of the range of the array,
 // this will throw automatically and revert all
 // changes.
 proposals\[proposal\].voteCount += sender.weight;
 }
 /// @dev Computes the winning proposal taking all
 /// previous votes into account.
 function winningProposal() public view
 returns (uint winningProposal\_)
 {
 uint winningVoteCount \= 0;
 for (uint p \= 0; p < proposals.length; p++) {
 if (proposals\[p\].voteCount \> winningVoteCount) {
 winningVoteCount \= proposals\[p\].voteCount;
 winningProposal\_ \= p;
 }
 }
 }
 // Calls winningProposal() function to get the index
 // of the winner contained in the proposals array and then
 // returns the name of the winner
 function winnerName() external view
 returns (bytes32 winnerName\_)
 {
 winnerName\_ \= proposals\[winningProposal()\].name;
 }
}
### Possible Improvements[](#possible-improvements "Link to this heading")
Currently, many transactions are needed to assign the rights to vote to all participants. Moreover, if two or more proposals have the same number of votes, `winningProposal()` is not able to register a tie. Can you think of a way to fix these issues?
## Blind Auction[](#blind-auction "Link to this heading")
In this section, we will show how easy it is to create a completely blind auction contract on Ethereum. We will start with an open auction where everyone can see the bids that are made and then extend this contract into a blind auction where it is not possible to see the actual bid until the bidding period ends.
### Simple Open Auction[](#simple-open-auction "Link to this heading")
The general idea of the following simple auction contract is that everyone can send their bids during a bidding period. The bids already include sending some compensation, e.g. Ether, in order to bind the bidders to their bid. If the highest bid is raised, the previous highest bidder gets their Ether back. After the end of the bidding period, the contract has to be called manually for the beneficiary to receive their Ether - contracts cannot activate themselves.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKY29udHJhY3QgU2ltcGxlQXVjdGlvbiB7CiAgICAvLyBQYXJhbWV0ZXJzIG9mIHRoZSBhdWN0aW9uLiBUaW1lcyBhcmUgZWl0aGVyCiAgICAvLyBhYnNvbHV0ZSB1bml4IHRpbWVzdGFtcHMgKHNlY29uZHMgc2luY2UgMTk3MC0wMS0wMSkKICAgIC8vIG9yIHRpbWUgcGVyaW9kcyBpbiBzZWNvbmRzLgogICAgYWRkcmVzcyBwYXlhYmxlIHB1YmxpYyBiZW5lZmljaWFyeTsKICAgIHVpbnQgcHVibGljIGF1Y3Rpb25FbmRUaW1lOwoKICAgIC8vIEN1cnJlbnQgc3RhdGUgb2YgdGhlIGF1Y3Rpb24uCiAgICBhZGRyZXNzIHB1YmxpYyBoaWdoZXN0QmlkZGVyOwogICAgdWludCBwdWJsaWMgaGlnaGVzdEJpZDsKCiAgICAvLyBBbGxvd2VkIHdpdGhkcmF3YWxzIG9mIHByZXZpb3VzIGJpZHMKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50KSBwZW5kaW5nUmV0dXJuczsKCiAgICAvLyBTZXQgdG8gdHJ1ZSBhdCB0aGUgZW5kLCBkaXNhbGxvd3MgYW55IGNoYW5nZS4KICAgIC8vIEJ5IGRlZmF1bHQgaW5pdGlhbGl6ZWQgdG8gYGZhbHNlYC4KICAgIGJvb2wgZW5kZWQ7CgogICAgLy8gRXZlbnRzIHRoYXQgd2lsbCBiZSBlbWl0dGVkIG9uIGNoYW5nZXMuCiAgICBldmVudCBIaWdoZXN0QmlkSW5jcmVhc2VkKGFkZHJlc3MgYmlkZGVyLCB1aW50IGFtb3VudCk7CiAgICBldmVudCBBdWN0aW9uRW5kZWQoYWRkcmVzcyB3aW5uZXIsIHVpbnQgYW1vdW50KTsKCiAgICAvLyBFcnJvcnMgdGhhdCBkZXNjcmliZSBmYWlsdXJlcy4KCiAgICAvLyBUaGUgdHJpcGxlLXNsYXNoIGNvbW1lbnRzIGFyZSBzby1jYWxsZWQgbmF0c3BlYwogICAgLy8gY29tbWVudHMuIFRoZXkgd2lsbCBiZSBzaG93biB3aGVuIHRoZSB1c2VyCiAgICAvLyBpcyBhc2tlZCB0byBjb25maXJtIGEgdHJhbnNhY3Rpb24gb3IKICAgIC8vIHdoZW4gYW4gZXJyb3IgaXMgZGlzcGxheWVkLgoKICAgIC8vLyBUaGUgYXVjdGlvbiBoYXMgYWxyZWFkeSBlbmRlZC4KICAgIGVycm9yIEF1Y3Rpb25BbHJlYWR5RW5kZWQoKTsKICAgIC8vLyBUaGVyZSBpcyBhbHJlYWR5IGEgaGlnaGVyIG9yIGVxdWFsIGJpZC4KICAgIGVycm9yIEJpZE5vdEhpZ2hFbm91Z2godWludCBoaWdoZXN0QmlkKTsKICAgIC8vLyBUaGUgYXVjdGlvbiBoYXMgbm90IGVuZGVkIHlldC4KICAgIGVycm9yIEF1Y3Rpb25Ob3RZZXRFbmRlZCgpOwogICAgLy8vIFRoZSBmdW5jdGlvbiBhdWN0aW9uRW5kIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkLgogICAgZXJyb3IgQXVjdGlvbkVuZEFscmVhZHlDYWxsZWQoKTsKCiAgICAvLy8gQ3JlYXRlIGEgc2ltcGxlIGF1Y3Rpb24gd2l0aCBgYmlkZGluZ1RpbWVgCiAgICAvLy8gc2Vjb25kcyBiaWRkaW5nIHRpbWUgb24gYmVoYWxmIG9mIHRoZQogICAgLy8vIGJlbmVmaWNpYXJ5IGFkZHJlc3MgYGJlbmVmaWNpYXJ5QWRkcmVzc2AuCiAgICBjb25zdHJ1Y3RvcigKICAgICAgICB1aW50IGJpZGRpbmdUaW1lLAogICAgICAgIGFkZHJlc3MgcGF5YWJsZSBiZW5lZmljaWFyeUFkZHJlc3MKICAgICkgewogICAgICAgIGJlbmVmaWNpYXJ5ID0gYmVuZWZpY2lhcnlBZGRyZXNzOwogICAgICAgIGF1Y3Rpb25FbmRUaW1lID0gYmxvY2sudGltZXN0YW1wICsgYmlkZGluZ1RpbWU7CiAgICB9CgogICAgLy8vIEJpZCBvbiB0aGUgYXVjdGlvbiB3aXRoIHRoZSB2YWx1ZSBzZW50CiAgICAvLy8gdG9nZXRoZXIgd2l0aCB0aGlzIHRyYW5zYWN0aW9uLgogICAgLy8vIFRoZSB2YWx1ZSB3aWxsIG9ubHkgYmUgcmVmdW5kZWQgaWYgdGhlCiAgICAvLy8gYXVjdGlvbiBpcyBub3Qgd29uLgogICAgZnVuY3Rpb24gYmlkKCkgZXh0ZXJuYWwgcGF5YWJsZSB7CiAgICAgICAgLy8gTm8gYXJndW1lbnRzIGFyZSBuZWNlc3NhcnksIGFsbAogICAgICAgIC8vIGluZm9ybWF0aW9uIGlzIGFscmVhZHkgcGFydCBvZgogICAgICAgIC8vIHRoZSB0cmFuc2FjdGlvbi4gVGhlIGtleXdvcmQgcGF5YWJsZQogICAgICAgIC8vIGlzIHJlcXVpcmVkIGZvciB0aGUgZnVuY3Rpb24gdG8KICAgICAgICAvLyBiZSBhYmxlIHRvIHJlY2VpdmUgRXRoZXIuCgogICAgICAgIC8vIFJldmVydCB0aGUgY2FsbCBpZiB0aGUgYmlkZGluZwogICAgICAgIC8vIHBlcmlvZCBpcyBvdmVyLgogICAgICAgIGlmIChibG9jay50aW1lc3RhbXAgPiBhdWN0aW9uRW5kVGltZSkKICAgICAgICAgICAgcmV2ZXJ0IEF1Y3Rpb25BbHJlYWR5RW5kZWQoKTsKCiAgICAgICAgLy8gSWYgdGhlIGJpZCBpcyBub3QgaGlnaGVyLCBzZW5kIHRoZQogICAgICAgIC8vIEV0aGVyIGJhY2sgKHRoZSByZXZlcnQgc3RhdGVtZW50CiAgICAgICAgLy8gd2lsbCByZXZlcnQgYWxsIGNoYW5nZXMgaW4gdGhpcwogICAgICAgIC8vIGZ1bmN0aW9uIGV4ZWN1dGlvbiBpbmNsdWRpbmcKICAgICAgICAvLyBpdCBoYXZpbmcgcmVjZWl2ZWQgdGhlIEV0aGVyKS4KICAgICAgICBpZiAobXNnLnZhbHVlIDw9IGhpZ2hlc3RCaWQpCiAgICAgICAgICAgIHJldmVydCBCaWROb3RIaWdoRW5vdWdoKGhpZ2hlc3RCaWQpOwoKICAgICAgICBpZiAoaGlnaGVzdEJpZCAhPSAwKSB7CiAgICAgICAgICAgIC8vIFNlbmRpbmcgYmFjayB0aGUgRXRoZXIgYnkgc2ltcGx5IHVzaW5nCiAgICAgICAgICAgIC8vIGhpZ2hlc3RCaWRkZXIuc2VuZChoaWdoZXN0QmlkKSBpcyBhIHNlY3VyaXR5IHJpc2sKICAgICAgICAgICAgLy8gYmVjYXVzZSBpdCBjb3VsZCBleGVjdXRlIGFuIHVudHJ1c3RlZCBjb250cmFjdC4KICAgICAgICAgICAgLy8gSXQgaXMgYWx3YXlzIHNhZmVyIHRvIGxldCB0aGUgcmVjaXBpZW50cwogICAgICAgICAgICAvLyB3aXRoZHJhdyB0aGVpciBFdGhlciB0aGVtc2VsdmVzLgogICAgICAgICAgICBwZW5kaW5nUmV0dXJuc1toaWdoZXN0QmlkZGVyXSArPSBoaWdoZXN0QmlkOwogICAgICAgIH0KICAgICAgICBoaWdoZXN0QmlkZGVyID0gbXNnLnNlbmRlcjsKICAgICAgICBoaWdoZXN0QmlkID0gbXNnLnZhbHVlOwogICAgICAgIGVtaXQgSGlnaGVzdEJpZEluY3JlYXNlZChtc2cuc2VuZGVyLCBtc2cudmFsdWUpOwogICAgfQoKICAgIC8vLyBXaXRoZHJhdyBhIGJpZCB0aGF0IHdhcyBvdmVyYmlkLgogICAgZnVuY3Rpb24gd2l0aGRyYXcoKSBleHRlcm5hbCByZXR1cm5zIChib29sKSB7CiAgICAgICAgdWludCBhbW91bnQgPSBwZW5kaW5nUmV0dXJuc1ttc2cuc2VuZGVyXTsKICAgICAgICBpZiAoYW1vdW50ID4gMCkgewogICAgICAgICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gc2V0IHRoaXMgdG8gemVybyBiZWNhdXNlIHRoZSByZWNpcGllbnQKICAgICAgICAgICAgLy8gY2FuIGNhbGwgdGhpcyBmdW5jdGlvbiBhZ2FpbiBhcyBwYXJ0IG9mIHRoZSByZWNlaXZpbmcgY2FsbAogICAgICAgICAgICAvLyBiZWZvcmUgYHNlbmRgIHJldHVybnMuCiAgICAgICAgICAgIHBlbmRpbmdSZXR1cm5zW21zZy5zZW5kZXJdID0gMDsKCiAgICAgICAgICAgIC8vIG1zZy5zZW5kZXIgaXMgbm90IG9mIHR5cGUgYGFkZHJlc3MgcGF5YWJsZWAgYW5kIG11c3QgYmUKICAgICAgICAgICAgLy8gZXhwbGljaXRseSBjb252ZXJ0ZWQgdXNpbmcgYHBheWFibGUobXNnLnNlbmRlcilgIGluIG9yZGVyCiAgICAgICAgICAgIC8vIHVzZSB0aGUgbWVtYmVyIGZ1bmN0aW9uIGBzZW5kKClgLgogICAgICAgICAgICBpZiAoIXBheWFibGUobXNnLnNlbmRlcikuc2VuZChhbW91bnQpKSB7CiAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGNhbGwgdGhyb3cgaGVyZSwganVzdCByZXNldCB0aGUgYW1vdW50IG93aW5nCiAgICAgICAgICAgICAgICBwZW5kaW5nUmV0dXJuc1ttc2cuc2VuZGVyXSA9IGFtb3VudDsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICAvLy8gRW5kIHRoZSBhdWN0aW9uIGFuZCBzZW5kIHRoZSBoaWdoZXN0IGJpZAogICAgLy8vIHRvIHRoZSBiZW5lZmljaWFyeS4KICAgIGZ1bmN0aW9uIGF1Y3Rpb25FbmQoKSBleHRlcm5hbCB7CiAgICAgICAgLy8gSXQgaXMgYSBnb29kIGd1aWRlbGluZSB0byBzdHJ1Y3R1cmUgZnVuY3Rpb25zIHRoYXQgaW50ZXJhY3QKICAgICAgICAvLyB3aXRoIG90aGVyIGNvbnRyYWN0cyAoaS5lLiB0aGV5IGNhbGwgZnVuY3Rpb25zIG9yIHNlbmQgRXRoZXIpCiAgICAgICAgLy8gaW50byB0aHJlZSBwaGFzZXM6CiAgICAgICAgLy8gMS4gY2hlY2tpbmcgY29uZGl0aW9ucwogICAgICAgIC8vIDIuIHBlcmZvcm1pbmcgYWN0aW9ucyAocG90ZW50aWFsbHkgY2hhbmdpbmcgY29uZGl0aW9ucykKICAgICAgICAvLyAzLiBpbnRlcmFjdGluZyB3aXRoIG90aGVyIGNvbnRyYWN0cwogICAgICAgIC8vIElmIHRoZXNlIHBoYXNlcyBhcmUgbWl4ZWQgdXAsIHRoZSBvdGhlciBjb250cmFjdCBjb3VsZCBjYWxsCiAgICAgICAgLy8gYmFjayBpbnRvIHRoZSBjdXJyZW50IGNvbnRyYWN0IGFuZCBtb2RpZnkgdGhlIHN0YXRlIG9yIGNhdXNlCiAgICAgICAgLy8gZWZmZWN0cyAoZXRoZXIgcGF5b3V0KSB0byBiZSBwZXJmb3JtZWQgbXVsdGlwbGUgdGltZXMuCiAgICAgICAgLy8gSWYgZnVuY3Rpb25zIGNhbGxlZCBpbnRlcm5hbGx5IGluY2x1ZGUgaW50ZXJhY3Rpb24gd2l0aCBleHRlcm5hbAogICAgICAgIC8vIGNvbnRyYWN0cywgdGhleSBhbHNvIGhhdmUgdG8gYmUgY29uc2lkZXJlZCBpbnRlcmFjdGlvbiB3aXRoCiAgICAgICAgLy8gZXh0ZXJuYWwgY29udHJhY3RzLgoKICAgICAgICAvLyAxLiBDb25kaXRpb25zCiAgICAgICAgaWYgKGJsb2NrLnRpbWVzdGFtcCA8IGF1Y3Rpb25FbmRUaW1lKQogICAgICAgICAgICByZXZlcnQgQXVjdGlvbk5vdFlldEVuZGVkKCk7CiAgICAgICAgaWYgKGVuZGVkKQogICAgICAgICAgICByZXZlcnQgQXVjdGlvbkVuZEFscmVhZHlDYWxsZWQoKTsKCiAgICAgICAgLy8gMi4gRWZmZWN0cwogICAgICAgIGVuZGVkID0gdHJ1ZTsKICAgICAgICBlbWl0IEF1Y3Rpb25FbmRlZChoaWdoZXN0QmlkZGVyLCBoaWdoZXN0QmlkKTsKCiAgICAgICAgLy8gMy4gSW50ZXJhY3Rpb24KICAgICAgICBiZW5lZmljaWFyeS50cmFuc2ZlcihoaWdoZXN0QmlkKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract SimpleAuction {
 // Parameters of the auction. Times are either
 // absolute unix timestamps (seconds since 1970-01-01)
 // or time periods in seconds.
 address payable public beneficiary;
 uint public auctionEndTime;
 // Current state of the auction.
 address public highestBidder;
 uint public highestBid;
 // Allowed withdrawals of previous bids
 mapping(address \=> uint) pendingReturns;
 // Set to true at the end, disallows any change.
 // By default initialized to \`false\`.
 bool ended;
 // Events that will be emitted on changes.
 event HighestBidIncreased(address bidder, uint amount);
 event AuctionEnded(address winner, uint amount);
 // Errors that describe failures.
 // The triple-slash comments are so-called natspec
 // comments. They will be shown when the user
 // is asked to confirm a transaction or
 // when an error is displayed.
 /// The auction has already ended.
 error AuctionAlreadyEnded();
 /// There is already a higher or equal bid.
 error BidNotHighEnough(uint highestBid);
 /// The auction has not ended yet.
 error AuctionNotYetEnded();
 /// The function auctionEnd has already been called.
 error AuctionEndAlreadyCalled();
 /// Create a simple auction with \`biddingTime\`
 /// seconds bidding time on behalf of the
 /// beneficiary address \`beneficiaryAddress\`.
 constructor(
 uint biddingTime,
 address payable beneficiaryAddress
 ) {
 beneficiary \= beneficiaryAddress;
 auctionEndTime \= block.timestamp + biddingTime;
 }
 /// Bid on the auction with the value sent
 /// together with this transaction.
 /// The value will only be refunded if the
 /// auction is not won.
 function bid() external payable {
 // No arguments are necessary, all
 // information is already part of
 // the transaction. The keyword payable
 // is required for the function to
 // be able to receive Ether.
 // Revert the call if the bidding
 // period is over.
 if (block.timestamp \> auctionEndTime)
 revert AuctionAlreadyEnded();
 // If the bid is not higher, send the
 // Ether back (the revert statement
 // will revert all changes in this
 // function execution including
 // it having received the Ether).
 if (msg.value <= highestBid)
 revert BidNotHighEnough(highestBid);
 if (highestBid != 0) {
 // Sending back the Ether by simply using
 // highestBidder.send(highestBid) is a security risk
 // because it could execute an untrusted contract.
 // It is always safer to let the recipients
 // withdraw their Ether themselves.
 pendingReturns\[highestBidder\] += highestBid;
 }
 highestBidder \= msg.sender;
 highestBid \= msg.value;
 emit HighestBidIncreased(msg.sender, msg.value);
 }
 /// Withdraw a bid that was overbid.
 function withdraw() external returns (bool) {
 uint amount \= pendingReturns\[msg.sender\];
 if (amount \> 0) {
 // It is important to set this to zero because the recipient
 // can call this function again as part of the receiving call
 // before \`send\` returns.
 pendingReturns\[msg.sender\] \= 0;
 // msg.sender is not of type \`address payable\` and must be
 // explicitly converted using \`payable(msg.sender)\` in order
 // use the member function \`send()\`.
 if (!payable(msg.sender).send(amount)) {
 // No need to call throw here, just reset the amount owing
 pendingReturns\[msg.sender\] \= amount;
 return false;
 }
 }
 return true;
 }
 /// End the auction and send the highest bid
 /// to the beneficiary.
 function auctionEnd() external {
 // It is a good guideline to structure functions that interact
 // with other contracts (i.e. they call functions or send Ether)
 // into three phases:
 // 1. checking conditions
 // 2. performing actions (potentially changing conditions)
 // 3. interacting with other contracts
 // If these phases are mixed up, the other contract could call
 // back into the current contract and modify the state or cause
 // effects (ether payout) to be performed multiple times.
 // If functions called internally include interaction with external
 // contracts, they also have to be considered interaction with
 // external contracts.
 // 1. Conditions
 if (block.timestamp < auctionEndTime)
 revert AuctionNotYetEnded();
 if (ended)
 revert AuctionEndAlreadyCalled();
 // 2. Effects
 ended \= true;
 emit AuctionEnded(highestBidder, highestBid);
 // 3. Interaction
 beneficiary.transfer(highestBid);
 }
}
### Blind Auction[](#id2 "Link to this heading")
The previous open auction is extended to a blind auction in the following. The advantage of a blind auction is that there is no time pressure towards the end of the bidding period. Creating a blind auction on a transparent computing platform might sound like a contradiction, but cryptography comes to the rescue.
During the **bidding period**, a bidder does not actually send their bid, but only a hashed version of it. Since it is currently considered practically impossible to find two (sufficiently long) values whose hash values are equal, the bidder commits to the bid by that. After the end of the bidding period, the bidders have to reveal their bids: They send their values unencrypted, and the contract checks that the hash value is the same as the one provided during the bidding period.
Another challenge is how to make the auction **binding and blind** at the same time: The only way to prevent the bidder from just not sending the Ether after they won the auction is to make them send it together with the bid. Since value transfers cannot be blinded in Ethereum, anyone can see the value.
The following contract solves this problem by accepting any value that is larger than the highest bid. Since this can of course only be checked during the reveal phase, some bids might be **invalid**, and this is on purpose (it even provides an explicit flag to place invalid bids with high-value transfers): Bidders can confuse competition by placing several high or low invalid bids.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKY29udHJhY3QgQmxpbmRBdWN0aW9uIHsKICAgIHN0cnVjdCBCaWQgewogICAgICAgIGJ5dGVzMzIgYmxpbmRlZEJpZDsKICAgICAgICB1aW50IGRlcG9zaXQ7CiAgICB9CgogICAgYWRkcmVzcyBwYXlhYmxlIHB1YmxpYyBiZW5lZmljaWFyeTsKICAgIHVpbnQgcHVibGljIGJpZGRpbmdFbmQ7CiAgICB1aW50IHB1YmxpYyByZXZlYWxFbmQ7CiAgICBib29sIHB1YmxpYyBlbmRlZDsKCiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gQmlkW10pIHB1YmxpYyBiaWRzOwoKICAgIGFkZHJlc3MgcHVibGljIGhpZ2hlc3RCaWRkZXI7CiAgICB1aW50IHB1YmxpYyBoaWdoZXN0QmlkOwoKICAgIC8vIEFsbG93ZWQgd2l0aGRyYXdhbHMgb2YgcHJldmlvdXMgYmlkcwogICAgbWFwcGluZyhhZGRyZXNzID0+IHVpbnQpIHBlbmRpbmdSZXR1cm5zOwoKICAgIGV2ZW50IEF1Y3Rpb25FbmRlZChhZGRyZXNzIHdpbm5lciwgdWludCBoaWdoZXN0QmlkKTsKCiAgICAvLyBFcnJvcnMgdGhhdCBkZXNjcmliZSBmYWlsdXJlcy4KCiAgICAvLy8gVGhlIGZ1bmN0aW9uIGhhcyBiZWVuIGNhbGxlZCB0b28gZWFybHkuCiAgICAvLy8gVHJ5IGFnYWluIGF0IGB0aW1lYC4KICAgIGVycm9yIFRvb0Vhcmx5KHVpbnQgdGltZSk7CiAgICAvLy8gVGhlIGZ1bmN0aW9uIGhhcyBiZWVuIGNhbGxlZCB0b28gbGF0ZS4KICAgIC8vLyBJdCBjYW5ub3QgYmUgY2FsbGVkIGFmdGVyIGB0aW1lYC4KICAgIGVycm9yIFRvb0xhdGUodWludCB0aW1lKTsKICAgIC8vLyBUaGUgZnVuY3Rpb24gYXVjdGlvbkVuZCBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZC4KICAgIGVycm9yIEF1Y3Rpb25FbmRBbHJlYWR5Q2FsbGVkKCk7CgogICAgLy8gTW9kaWZpZXJzIGFyZSBhIGNvbnZlbmllbnQgd2F5IHRvIHZhbGlkYXRlIGlucHV0cyB0bwogICAgLy8gZnVuY3Rpb25zLiBgb25seUJlZm9yZWAgaXMgYXBwbGllZCB0byBgYmlkYCBiZWxvdzoKICAgIC8vIFRoZSBuZXcgZnVuY3Rpb24gYm9keSBpcyB0aGUgbW9kaWZpZXIncyBib2R5IHdoZXJlCiAgICAvLyBgX2AgaXMgcmVwbGFjZWQgYnkgdGhlIG9sZCBmdW5jdGlvbiBib2R5LgogICAgbW9kaWZpZXIgb25seUJlZm9yZSh1aW50IHRpbWUpIHsKICAgICAgICBpZiAoYmxvY2sudGltZXN0YW1wID49IHRpbWUpIHJldmVydCBUb29MYXRlKHRpbWUpOwogICAgICAgIF87CiAgICB9CiAgICBtb2RpZmllciBvbmx5QWZ0ZXIodWludCB0aW1lKSB7CiAgICAgICAgaWYgKGJsb2NrLnRpbWVzdGFtcCA8PSB0aW1lKSByZXZlcnQgVG9vRWFybHkodGltZSk7CiAgICAgICAgXzsKICAgIH0KCiAgICBjb25zdHJ1Y3RvcigKICAgICAgICB1aW50IGJpZGRpbmdUaW1lLAogICAgICAgIHVpbnQgcmV2ZWFsVGltZSwKICAgICAgICBhZGRyZXNzIHBheWFibGUgYmVuZWZpY2lhcnlBZGRyZXNzCiAgICApIHsKICAgICAgICBiZW5lZmljaWFyeSA9IGJlbmVmaWNpYXJ5QWRkcmVzczsKICAgICAgICBiaWRkaW5nRW5kID0gYmxvY2sudGltZXN0YW1wICsgYmlkZGluZ1RpbWU7CiAgICAgICAgcmV2ZWFsRW5kID0gYmlkZGluZ0VuZCArIHJldmVhbFRpbWU7CiAgICB9CgogICAgLy8vIFBsYWNlIGEgYmxpbmRlZCBiaWQgd2l0aCBgYmxpbmRlZEJpZGAgPQogICAgLy8vIGtlY2NhazI1NihhYmkuZW5jb2RlUGFja2VkKHZhbHVlLCBmYWtlLCBzZWNyZXQpKS4KICAgIC8vLyBUaGUgc2VudCBldGhlciBpcyBvbmx5IHJlZnVuZGVkIGlmIHRoZSBiaWQgaXMgY29ycmVjdGx5CiAgICAvLy8gcmV2ZWFsZWQgaW4gdGhlIHJldmVhbGluZyBwaGFzZS4gVGhlIGJpZCBpcyB2YWxpZCBpZiB0aGUKICAgIC8vLyBldGhlciBzZW50IHRvZ2V0aGVyIHdpdGggdGhlIGJpZCBpcyBhdCBsZWFzdCAidmFsdWUiIGFuZAogICAgLy8vICJmYWtlIiBpcyBub3QgdHJ1ZS4gU2V0dGluZyAiZmFrZSIgdG8gdHJ1ZSBhbmQgc2VuZGluZwogICAgLy8vIG5vdCB0aGUgZXhhY3QgYW1vdW50IGFyZSB3YXlzIHRvIGhpZGUgdGhlIHJlYWwgYmlkIGJ1dAogICAgLy8vIHN0aWxsIG1ha2UgdGhlIHJlcXVpcmVkIGRlcG9zaXQuIFRoZSBzYW1lIGFkZHJlc3MgY2FuCiAgICAvLy8gcGxhY2UgbXVsdGlwbGUgYmlkcy4KICAgIGZ1bmN0aW9uIGJpZChieXRlczMyIGJsaW5kZWRCaWQpCiAgICAgICAgZXh0ZXJuYWwKICAgICAgICBwYXlhYmxlCiAgICAgICAgb25seUJlZm9yZShiaWRkaW5nRW5kKQogICAgewogICAgICAgIGJpZHNbbXNnLnNlbmRlcl0ucHVzaChCaWQoewogICAgICAgICAgICBibGluZGVkQmlkOiBibGluZGVkQmlkLAogICAgICAgICAgICBkZXBvc2l0OiBtc2cudmFsdWUKICAgICAgICB9KSk7CiAgICB9CgogICAgLy8vIFJldmVhbCB5b3VyIGJsaW5kZWQgYmlkcy4gWW91IHdpbGwgZ2V0IGEgcmVmdW5kIGZvciBhbGwKICAgIC8vLyBjb3JyZWN0bHkgYmxpbmRlZCBpbnZhbGlkIGJpZHMgYW5kIGZvciBhbGwgYmlkcyBleGNlcHQgZm9yCiAgICAvLy8gdGhlIHRvdGFsbHkgaGlnaGVzdC4KICAgIGZ1bmN0aW9uIHJldmVhbCgKICAgICAgICB1aW50W10gY2FsbGRhdGEgdmFsdWVzLAogICAgICAgIGJvb2xbXSBjYWxsZGF0YSBmYWtlcywKICAgICAgICBieXRlczMyW10gY2FsbGRhdGEgc2VjcmV0cwogICAgKQogICAgICAgIGV4dGVybmFsCiAgICAgICAgb25seUFmdGVyKGJpZGRpbmdFbmQpCiAgICAgICAgb25seUJlZm9yZShyZXZlYWxFbmQpCiAgICB7CiAgICAgICAgdWludCBsZW5ndGggPSBiaWRzW21zZy5zZW5kZXJdLmxlbmd0aDsKICAgICAgICByZXF1aXJlKHZhbHVlcy5sZW5ndGggPT0gbGVuZ3RoKTsKICAgICAgICByZXF1aXJlKGZha2VzLmxlbmd0aCA9PSBsZW5ndGgpOwogICAgICAgIHJlcXVpcmUoc2VjcmV0cy5sZW5ndGggPT0gbGVuZ3RoKTsKCiAgICAgICAgdWludCByZWZ1bmQ7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgQmlkIHN0b3JhZ2UgYmlkVG9DaGVjayA9IGJpZHNbbXNnLnNlbmRlcl1baV07CiAgICAgICAgICAgICh1aW50IHZhbHVlLCBib29sIGZha2UsIGJ5dGVzMzIgc2VjcmV0KSA9CiAgICAgICAgICAgICAgICAgICAgKHZhbHVlc1tpXSwgZmFrZXNbaV0sIHNlY3JldHNbaV0pOwogICAgICAgICAgICBpZiAoYmlkVG9DaGVjay5ibGluZGVkQmlkICE9IGtlY2NhazI1NihhYmkuZW5jb2RlUGFja2VkKHZhbHVlLCBmYWtlLCBzZWNyZXQpKSkgewogICAgICAgICAgICAgICAgLy8gQmlkIHdhcyBub3QgYWN0dWFsbHkgcmV2ZWFsZWQuCiAgICAgICAgICAgICAgICAvLyBEbyBub3QgcmVmdW5kIGRlcG9zaXQuCiAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZWZ1bmQgKz0gYmlkVG9DaGVjay5kZXBvc2l0OwogICAgICAgICAgICBpZiAoIWZha2UgJiYgYmlkVG9DaGVjay5kZXBvc2l0ID49IHZhbHVlKSB7CiAgICAgICAgICAgICAgICBpZiAocGxhY2VCaWQobXNnLnNlbmRlciwgdmFsdWUpKQogICAgICAgICAgICAgICAgICAgIHJlZnVuZCAtPSB2YWx1ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICAvLyBNYWtlIGl0IGltcG9zc2libGUgZm9yIHRoZSBzZW5kZXIgdG8gcmUtY2xhaW0KICAgICAgICAgICAgLy8gdGhlIHNhbWUgZGVwb3NpdC4KICAgICAgICAgICAgYmlkVG9DaGVjay5ibGluZGVkQmlkID0gYnl0ZXMzMigwKTsKICAgICAgICB9CiAgICAgICAgcGF5YWJsZShtc2cuc2VuZGVyKS50cmFuc2ZlcihyZWZ1bmQpOwogICAgfQoKICAgIC8vLyBXaXRoZHJhdyBhIGJpZCB0aGF0IHdhcyBvdmVyYmlkLgogICAgZnVuY3Rpb24gd2l0aGRyYXcoKSBleHRlcm5hbCB7CiAgICAgICAgdWludCBhbW91bnQgPSBwZW5kaW5nUmV0dXJuc1ttc2cuc2VuZGVyXTsKICAgICAgICBpZiAoYW1vdW50ID4gMCkgewogICAgICAgICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gc2V0IHRoaXMgdG8gemVybyBiZWNhdXNlIHRoZSByZWNpcGllbnQKICAgICAgICAgICAgLy8gY2FuIGNhbGwgdGhpcyBmdW5jdGlvbiBhZ2FpbiBhcyBwYXJ0IG9mIHRoZSByZWNlaXZpbmcgY2FsbAogICAgICAgICAgICAvLyBiZWZvcmUgYHRyYW5zZmVyYCByZXR1cm5zIChzZWUgdGhlIHJlbWFyayBhYm92ZSBhYm91dAogICAgICAgICAgICAvLyBjb25kaXRpb25zIC0+IGVmZmVjdHMgLT4gaW50ZXJhY3Rpb24pLgogICAgICAgICAgICBwZW5kaW5nUmV0dXJuc1ttc2cuc2VuZGVyXSA9IDA7CgogICAgICAgICAgICBwYXlhYmxlKG1zZy5zZW5kZXIpLnRyYW5zZmVyKGFtb3VudCk7CiAgICAgICAgfQogICAgfQoKICAgIC8vLyBFbmQgdGhlIGF1Y3Rpb24gYW5kIHNlbmQgdGhlIGhpZ2hlc3QgYmlkCiAgICAvLy8gdG8gdGhlIGJlbmVmaWNpYXJ5LgogICAgZnVuY3Rpb24gYXVjdGlvbkVuZCgpCiAgICAgICAgZXh0ZXJuYWwKICAgICAgICBvbmx5QWZ0ZXIocmV2ZWFsRW5kKQogICAgewogICAgICAgIGlmIChlbmRlZCkgcmV2ZXJ0IEF1Y3Rpb25FbmRBbHJlYWR5Q2FsbGVkKCk7CiAgICAgICAgZW1pdCBBdWN0aW9uRW5kZWQoaGlnaGVzdEJpZGRlciwgaGlnaGVzdEJpZCk7CiAgICAgICAgZW5kZWQgPSB0cnVlOwogICAgICAgIGJlbmVmaWNpYXJ5LnRyYW5zZmVyKGhpZ2hlc3RCaWQpOwogICAgfQoKICAgIC8vIFRoaXMgaXMgYW4gImludGVybmFsIiBmdW5jdGlvbiB3aGljaCBtZWFucyB0aGF0IGl0CiAgICAvLyBjYW4gb25seSBiZSBjYWxsZWQgZnJvbSB0aGUgY29udHJhY3QgaXRzZWxmIChvciBmcm9tCiAgICAvLyBkZXJpdmVkIGNvbnRyYWN0cykuCiAgICBmdW5jdGlvbiBwbGFjZUJpZChhZGRyZXNzIGJpZGRlciwgdWludCB2YWx1ZSkgaW50ZXJuYWwKICAgICAgICAgICAgcmV0dXJucyAoYm9vbCBzdWNjZXNzKQogICAgewogICAgICAgIGlmICh2YWx1ZSA8PSBoaWdoZXN0QmlkKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgICAgaWYgKGhpZ2hlc3RCaWRkZXIgIT0gYWRkcmVzcygwKSkgewogICAgICAgICAgICAvLyBSZWZ1bmQgdGhlIHByZXZpb3VzbHkgaGlnaGVzdCBiaWRkZXIuCiAgICAgICAgICAgIHBlbmRpbmdSZXR1cm5zW2hpZ2hlc3RCaWRkZXJdICs9IGhpZ2hlc3RCaWQ7CiAgICAgICAgfQogICAgICAgIGhpZ2hlc3RCaWQgPSB2YWx1ZTsKICAgICAgICBoaWdoZXN0QmlkZGVyID0gYmlkZGVyOwogICAgICAgIHJldHVybiB0cnVlOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract BlindAuction {
 struct Bid {
 bytes32 blindedBid;
 uint deposit;
 }
 address payable public beneficiary;
 uint public biddingEnd;
 uint public revealEnd;
 bool public ended;
 mapping(address \=> Bid\[\]) public bids;
 address public highestBidder;
 uint public highestBid;
 // Allowed withdrawals of previous bids
 mapping(address \=> uint) pendingReturns;
 event AuctionEnded(address winner, uint highestBid);
 // Errors that describe failures.
 /// The function has been called too early.
 /// Try again at \`time\`.
 error TooEarly(uint time);
 /// The function has been called too late.
 /// It cannot be called after \`time\`.
 error TooLate(uint time);
 /// The function auctionEnd has already been called.
 error AuctionEndAlreadyCalled();
 // Modifiers are a convenient way to validate inputs to
 // functions. \`onlyBefore\` is applied to \`bid\` below:
 // The new function body is the modifier's body where
 // \`\_\` is replaced by the old function body.
 modifier onlyBefore(uint time) {
 if (block.timestamp \>= time) revert TooLate(time);
 \_;
 }
 modifier onlyAfter(uint time) {
 if (block.timestamp <= time) revert TooEarly(time);
 \_;
 }
 constructor(
 uint biddingTime,
 uint revealTime,
 address payable beneficiaryAddress
 ) {
 beneficiary \= beneficiaryAddress;
 biddingEnd \= block.timestamp + biddingTime;
 revealEnd \= biddingEnd + revealTime;
 }
 /// Place a blinded bid with \`blindedBid\` =
 /// keccak256(abi.encodePacked(value, fake, secret)).
 /// The sent ether is only refunded if the bid is correctly
 /// revealed in the revealing phase. The bid is valid if the
 /// ether sent together with the bid is at least "value" and
 /// "fake" is not true. Setting "fake" to true and sending
 /// not the exact amount are ways to hide the real bid but
 /// still make the required deposit. The same address can
 /// place multiple bids.
 function bid(bytes32 blindedBid)
 external
 payable
 onlyBefore(biddingEnd)
 {
 bids\[msg.sender\].push(Bid({
 blindedBid: blindedBid,
 deposit: msg.value
 }));
 }
 /// Reveal your blinded bids. You will get a refund for all
 /// correctly blinded invalid bids and for all bids except for
 /// the totally highest.
 function reveal(
 uint\[\] calldata values,
 bool\[\] calldata fakes,
 bytes32\[\] calldata secrets
 )
 external
 onlyAfter(biddingEnd)
 onlyBefore(revealEnd)
 {
 uint length \= bids\[msg.sender\].length;
 require(values.length \== length);
 require(fakes.length \== length);
 require(secrets.length \== length);
 uint refund;
 for (uint i \= 0; i < length; i++) {
 Bid storage bidToCheck \= bids\[msg.sender\]\[i\];
 (uint value, bool fake, bytes32 secret) \=
 (values\[i\], fakes\[i\], secrets\[i\]);
 if (bidToCheck.blindedBid != keccak256(abi.encodePacked(value, fake, secret))) {
 // Bid was not actually revealed.
 // Do not refund deposit.
 continue;
 }
 refund += bidToCheck.deposit;
 if (!fake && bidToCheck.deposit \>= value) {
 if (placeBid(msg.sender, value))
 refund \-= value;
 }
 // Make it impossible for the sender to re-claim
 // the same deposit.
 bidToCheck.blindedBid \= bytes32(0);
 }
 payable(msg.sender).transfer(refund);
 }
 /// Withdraw a bid that was overbid.
 function withdraw() external {
 uint amount \= pendingReturns\[msg.sender\];
 if (amount \> 0) {
 // It is important to set this to zero because the recipient
 // can call this function again as part of the receiving call
 // before \`transfer\` returns (see the remark above about
 // conditions -> effects -> interaction).
 pendingReturns\[msg.sender\] \= 0;
 payable(msg.sender).transfer(amount);
 }
 }
 /// End the auction and send the highest bid
 /// to the beneficiary.
 function auctionEnd()
 external
 onlyAfter(revealEnd)
 {
 if (ended) revert AuctionEndAlreadyCalled();
 emit AuctionEnded(highestBidder, highestBid);
 ended \= true;
 beneficiary.transfer(highestBid);
 }
 // This is an "internal" function which means that it
 // can only be called from the contract itself (or from
 // derived contracts).
 function placeBid(address bidder, uint value) internal
 returns (bool success)
 {
 if (value <= highestBid) {
 return false;
 }
 if (highestBidder != address(0)) {
 // Refund the previously highest bidder.
 pendingReturns\[highestBidder\] += highestBid;
 }
 highestBid \= value;
 highestBidder \= bidder;
 return true;
 }
}
## Safe Remote Purchase[](#safe-remote-purchase "Link to this heading")
Purchasing goods remotely currently requires multiple parties that need to trust each other. The simplest configuration involves a seller and a buyer. The buyer would like to receive an item from the seller and the seller would like to get some compensation, e.g. Ether, in return. The problematic part is the shipment here: There is no way to determine for sure that the item arrived at the buyer.
There are multiple ways to solve this problem, but all fall short in one or the other way. In the following example, both parties have to put twice the value of the item into the contract as escrow. As soon as this happened, the Ether will stay locked inside the contract until the buyer confirms that they received the item. After that, the buyer is returned the value (half of their deposit) and the seller gets three times the value (their deposit plus the value). The idea behind this is that both parties have an incentive to resolve the situation or otherwise their Ether is locked forever.
This contract of course does not solve the problem, but gives an overview of how you can use state machine-like constructs inside a contract.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKY29udHJhY3QgUHVyY2hhc2UgewogICAgdWludCBwdWJsaWMgdmFsdWU7CiAgICBhZGRyZXNzIHBheWFibGUgcHVibGljIHNlbGxlcjsKICAgIGFkZHJlc3MgcGF5YWJsZSBwdWJsaWMgYnV5ZXI7CgogICAgZW51bSBTdGF0ZSB7IENyZWF0ZWQsIExvY2tlZCwgUmVsZWFzZSwgSW5hY3RpdmUgfQogICAgLy8gVGhlIHN0YXRlIHZhcmlhYmxlIGhhcyBhIGRlZmF1bHQgdmFsdWUgb2YgdGhlIGZpcnN0IG1lbWJlciwgYFN0YXRlLmNyZWF0ZWRgCiAgICBTdGF0ZSBwdWJsaWMgc3RhdGU7CgogICAgbW9kaWZpZXIgY29uZGl0aW9uKGJvb2wgY29uZGl0aW9uXykgewogICAgICAgIHJlcXVpcmUoY29uZGl0aW9uXyk7CiAgICAgICAgXzsKICAgIH0KCiAgICAvLy8gT25seSB0aGUgYnV5ZXIgY2FuIGNhbGwgdGhpcyBmdW5jdGlvbi4KICAgIGVycm9yIE9ubHlCdXllcigpOwogICAgLy8vIE9ubHkgdGhlIHNlbGxlciBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uLgogICAgZXJyb3IgT25seVNlbGxlcigpOwogICAgLy8vIFRoZSBmdW5jdGlvbiBjYW5ub3QgYmUgY2FsbGVkIGF0IHRoZSBjdXJyZW50IHN0YXRlLgogICAgZXJyb3IgSW52YWxpZFN0YXRlKCk7CiAgICAvLy8gVGhlIHByb3ZpZGVkIHZhbHVlIGhhcyB0byBiZSBldmVuLgogICAgZXJyb3IgVmFsdWVOb3RFdmVuKCk7CgogICAgbW9kaWZpZXIgb25seUJ1eWVyKCkgewogICAgICAgIGlmIChtc2cuc2VuZGVyICE9IGJ1eWVyKQogICAgICAgICAgICByZXZlcnQgT25seUJ1eWVyKCk7CiAgICAgICAgXzsKICAgIH0KCiAgICBtb2RpZmllciBvbmx5U2VsbGVyKCkgewogICAgICAgIGlmIChtc2cuc2VuZGVyICE9IHNlbGxlcikKICAgICAgICAgICAgcmV2ZXJ0IE9ubHlTZWxsZXIoKTsKICAgICAgICBfOwogICAgfQoKICAgIG1vZGlmaWVyIGluU3RhdGUoU3RhdGUgc3RhdGVfKSB7CiAgICAgICAgaWYgKHN0YXRlICE9IHN0YXRlXykKICAgICAgICAgICAgcmV2ZXJ0IEludmFsaWRTdGF0ZSgpOwogICAgICAgIF87CiAgICB9CgogICAgZXZlbnQgQWJvcnRlZCgpOwogICAgZXZlbnQgUHVyY2hhc2VDb25maXJtZWQoKTsKICAgIGV2ZW50IEl0ZW1SZWNlaXZlZCgpOwogICAgZXZlbnQgU2VsbGVyUmVmdW5kZWQoKTsKCiAgICAvLyBFbnN1cmUgdGhhdCBgbXNnLnZhbHVlYCBpcyBhbiBldmVuIG51bWJlci4KICAgIC8vIERpdmlzaW9uIHdpbGwgdHJ1bmNhdGUgaWYgaXQgaXMgYW4gb2RkIG51bWJlci4KICAgIC8vIENoZWNrIHZpYSBtdWx0aXBsaWNhdGlvbiB0aGF0IGl0IHdhc24ndCBhbiBvZGQgbnVtYmVyLgogICAgY29uc3RydWN0b3IoKSBwYXlhYmxlIHsKICAgICAgICBzZWxsZXIgPSBwYXlhYmxlKG1zZy5zZW5kZXIpOwogICAgICAgIHZhbHVlID0gbXNnLnZhbHVlIC8gMjsKICAgICAgICBpZiAoKDIgKiB2YWx1ZSkgIT0gbXNnLnZhbHVlKQogICAgICAgICAgICByZXZlcnQgVmFsdWVOb3RFdmVuKCk7CiAgICB9CgogICAgLy8vIEFib3J0IHRoZSBwdXJjaGFzZSBhbmQgcmVjbGFpbSB0aGUgZXRoZXIuCiAgICAvLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHRoZSBzZWxsZXIgYmVmb3JlCiAgICAvLy8gdGhlIGNvbnRyYWN0IGlzIGxvY2tlZC4KICAgIGZ1bmN0aW9uIGFib3J0KCkKICAgICAgICBleHRlcm5hbAogICAgICAgIG9ubHlTZWxsZXIKICAgICAgICBpblN0YXRlKFN0YXRlLkNyZWF0ZWQpCiAgICB7CiAgICAgICAgZW1pdCBBYm9ydGVkKCk7CiAgICAgICAgc3RhdGUgPSBTdGF0ZS5JbmFjdGl2ZTsKICAgICAgICAvLyBXZSB1c2UgdHJhbnNmZXIgaGVyZSBkaXJlY3RseS4gSXQgaXMKICAgICAgICAvLyByZWVudHJhbmN5LXNhZmUsIGJlY2F1c2UgaXQgaXMgdGhlCiAgICAgICAgLy8gbGFzdCBjYWxsIGluIHRoaXMgZnVuY3Rpb24gYW5kIHdlCiAgICAgICAgLy8gYWxyZWFkeSBjaGFuZ2VkIHRoZSBzdGF0ZS4KICAgICAgICBzZWxsZXIudHJhbnNmZXIoYWRkcmVzcyh0aGlzKS5iYWxhbmNlKTsKICAgIH0KCiAgICAvLy8gQ29uZmlybSB0aGUgcHVyY2hhc2UgYXMgYnV5ZXIuCiAgICAvLy8gVHJhbnNhY3Rpb24gaGFzIHRvIGluY2x1ZGUgYDIgKiB2YWx1ZWAgZXRoZXIuCiAgICAvLy8gVGhlIGV0aGVyIHdpbGwgYmUgbG9ja2VkIHVudGlsIGNvbmZpcm1SZWNlaXZlZAogICAgLy8vIGlzIGNhbGxlZC4KICAgIGZ1bmN0aW9uIGNvbmZpcm1QdXJjaGFzZSgpCiAgICAgICAgZXh0ZXJuYWwKICAgICAgICBpblN0YXRlKFN0YXRlLkNyZWF0ZWQpCiAgICAgICAgY29uZGl0aW9uKG1zZy52YWx1ZSA9PSAoMiAqIHZhbHVlKSkKICAgICAgICBwYXlhYmxlCiAgICB7CiAgICAgICAgZW1pdCBQdXJjaGFzZUNvbmZpcm1lZCgpOwogICAgICAgIGJ1eWVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsKICAgICAgICBzdGF0ZSA9IFN0YXRlLkxvY2tlZDsKICAgIH0KCiAgICAvLy8gQ29uZmlybSB0aGF0IHlvdSAodGhlIGJ1eWVyKSByZWNlaXZlZCB0aGUgaXRlbS4KICAgIC8vLyBUaGlzIHdpbGwgcmVsZWFzZSB0aGUgbG9ja2VkIGV0aGVyLgogICAgZnVuY3Rpb24gY29uZmlybVJlY2VpdmVkKCkKICAgICAgICBleHRlcm5hbAogICAgICAgIG9ubHlCdXllcgogICAgICAgIGluU3RhdGUoU3RhdGUuTG9ja2VkKQogICAgewogICAgICAgIGVtaXQgSXRlbVJlY2VpdmVkKCk7CiAgICAgICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIGNoYW5nZSB0aGUgc3RhdGUgZmlyc3QgYmVjYXVzZQogICAgICAgIC8vIG90aGVyd2lzZSwgdGhlIGNvbnRyYWN0cyBjYWxsZWQgdXNpbmcgYHNlbmRgIGJlbG93CiAgICAgICAgLy8gY2FuIGNhbGwgaW4gYWdhaW4gaGVyZS4KICAgICAgICBzdGF0ZSA9IFN0YXRlLlJlbGVhc2U7CgogICAgICAgIGJ1eWVyLnRyYW5zZmVyKHZhbHVlKTsKICAgIH0KCiAgICAvLy8gVGhpcyBmdW5jdGlvbiByZWZ1bmRzIHRoZSBzZWxsZXIsIGkuZS4KICAgIC8vLyBwYXlzIGJhY2sgdGhlIGxvY2tlZCBmdW5kcyBvZiB0aGUgc2VsbGVyLgogICAgZnVuY3Rpb24gcmVmdW5kU2VsbGVyKCkKICAgICAgICBleHRlcm5hbAogICAgICAgIG9ubHlTZWxsZXIKICAgICAgICBpblN0YXRlKFN0YXRlLlJlbGVhc2UpCiAgICB7CiAgICAgICAgZW1pdCBTZWxsZXJSZWZ1bmRlZCgpOwogICAgICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byBjaGFuZ2UgdGhlIHN0YXRlIGZpcnN0IGJlY2F1c2UKICAgICAgICAvLyBvdGhlcndpc2UsIHRoZSBjb250cmFjdHMgY2FsbGVkIHVzaW5nIGBzZW5kYCBiZWxvdwogICAgICAgIC8vIGNhbiBjYWxsIGluIGFnYWluIGhlcmUuCiAgICAgICAgc3RhdGUgPSBTdGF0ZS5JbmFjdGl2ZTsKCiAgICAgICAgc2VsbGVyLnRyYW5zZmVyKDMgKiB2YWx1ZSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
contract Purchase {
 uint public value;
 address payable public seller;
 address payable public buyer;
 enum State { Created, Locked, Release, Inactive }
 // The state variable has a default value of the first member, \`State.created\`
 State public state;
 modifier condition(bool condition\_) {
 require(condition\_);
 \_;
 }
 /// Only the buyer can call this function.
 error OnlyBuyer();
 /// Only the seller can call this function.
 error OnlySeller();
 /// The function cannot be called at the current state.
 error InvalidState();
 /// The provided value has to be even.
 error ValueNotEven();
 modifier onlyBuyer() {
 if (msg.sender != buyer)
 revert OnlyBuyer();
 \_;
 }
 modifier onlySeller() {
 if (msg.sender != seller)
 revert OnlySeller();
 \_;
 }
 modifier inState(State state\_) {
 if (state != state\_)
 revert InvalidState();
 \_;
 }
 event Aborted();
 event PurchaseConfirmed();
 event ItemReceived();
 event SellerRefunded();
 // Ensure that \`msg.value\` is an even number.
 // Division will truncate if it is an odd number.
 // Check via multiplication that it wasn't an odd number.
 constructor() payable {
 seller \= payable(msg.sender);
 value \= msg.value / 2;
 if ((2 \* value) != msg.value)
 revert ValueNotEven();
 }
 /// Abort the purchase and reclaim the ether.
 /// Can only be called by the seller before
 /// the contract is locked.
 function abort()
 external
 onlySeller
 inState(State.Created)
 {
 emit Aborted();
 state \= State.Inactive;
 // We use transfer here directly. It is
 // reentrancy-safe, because it is the
 // last call in this function and we
 // already changed the state.
 seller.transfer(address(this).balance);
 }
 /// Confirm the purchase as buyer.
 /// Transaction has to include \`2 \* value\` ether.
 /// The ether will be locked until confirmReceived
 /// is called.
 function confirmPurchase()
 external
 inState(State.Created)
 condition(msg.value \== (2 \* value))
 payable
 {
 emit PurchaseConfirmed();
 buyer \= payable(msg.sender);
 state \= State.Locked;
 }
 /// Confirm that you (the buyer) received the item.
 /// This will release the locked ether.
 function confirmReceived()
 external
 onlyBuyer
 inState(State.Locked)
 {
 emit ItemReceived();
 // It is important to change the state first because
 // otherwise, the contracts called using \`send\` below
 // can call in again here.
 state \= State.Release;
 buyer.transfer(value);
 }
 /// This function refunds the seller, i.e.
 /// pays back the locked funds of the seller.
 function refundSeller()
 external
 onlySeller
 inState(State.Release)
 {
 emit SellerRefunded();
 // It is important to change the state first because
 // otherwise, the contracts called using \`send\` below
 // can call in again here.
 state \= State.Inactive;
 seller.transfer(3 \* value);
 }
}
## Micropayment Channel[](#micropayment-channel "Link to this heading")
In this section, we will learn how to build an example implementation of a payment channel. It uses cryptographic signatures to make repeated transfers of Ether between the same parties secure, instantaneous, and without transaction fees. For the example, we need to understand how to sign and verify signatures, and setup the payment channel.
### Creating and verifying signatures[](#creating-and-verifying-signatures "Link to this heading")
Imagine Alice wants to send some Ether to Bob, i.e. Alice is the sender and Bob is the recipient.
Alice only needs to send cryptographically signed messages off-chain (e.g. via email) to Bob and it is similar to writing checks.
Alice and Bob use signatures to authorize transactions, which is possible with smart contracts on Ethereum. Alice will build a simple smart contract that lets her transmit Ether, but instead of calling a function herself to initiate a payment, she will let Bob do that, and therefore pay the transaction fee.
The contract will work as follows:
> 1. Alice deploys the `ReceiverPays` contract, attaching enough Ether to cover the payments that will be made.
> 
> 2. Alice authorizes a payment by signing a message with her private key.
> 
> 3. Alice sends the cryptographically signed message to Bob. The message does not need to be kept secret (explained later), and the mechanism for sending it does not matter.
> 
> 4. Bob claims his payment by presenting the signed message to the smart contract, it verifies the authenticity of the message and then releases the funds.
> 
#### Creating the signature[](#creating-the-signature "Link to this heading")
Alice does not need to interact with the Ethereum network to sign the transaction, the process is completely offline. In this tutorial, we will sign messages in the browser using [web3.js](https://github.com/web3/web3.js) and [MetaMask](https://metamask.io/), using the method described in [EIP-712](https://github.com/ethereum/EIPs/pull/712), as it provides a number of other security benefits.
/// Hashing first makes things easier
var hash \= web3.utils.sha3("message to sign");
web3.eth.personal.sign(hash, web3.eth.defaultAccount, function () { console.log("Signed"); });
Note
The `web3.eth.personal.sign` prepends the length of the message to the signed data. Since we hash first, the message will always be exactly 32 bytes long, and thus this length prefix is always the same.
#### What to Sign[](#what-to-sign "Link to this heading")
For a contract that fulfills payments, the signed message must include:
> 1. The recipient’s address.
> 
> 2. The amount to be transferred.
> 
> 3. Protection against replay attacks.
> 
A replay attack is when a signed message is reused to claim authorization for a second action. To avoid replay attacks we use the same technique as in Ethereum transactions themselves, a so-called nonce, which is the number of transactions sent by an account. The smart contract checks if a nonce is used multiple times.
Another type of replay attack can occur when the owner deploys a `ReceiverPays` smart contract, makes some payments, and then destroys the contract. Later, they decide to deploy the `RecipientPays` smart contract again, but the new contract does not know the nonces used in the previous deployment, so the attacker can use the old messages again.
Alice can protect against this attack by including the contract’s address in the message, and only messages containing the contract’s address itself will be accepted. You can find an example of this in the first two lines of the `claimPayment()` function of the full contract at the end of this section.
Furthermore, instead of destroying the contract by calling `selfdestruct`, which is currently deprecated, we will disable the contract’s functionalities by freezing it, resulting in the reversion of any call after it being frozen.
#### Packing arguments[](#packing-arguments "Link to this heading")
Now that we have identified what information to include in the signed message, we are ready to put the message together, hash it, and sign it. For simplicity, we concatenate the data. The [ethereumjs-abi](https://github.com/ethereumjs/ethereumjs-abi) library provides a function called `soliditySHA3` that mimics the behavior of Solidity’s `keccak256` function applied to arguments encoded using `abi.encodePacked`. Here is a JavaScript function that creates the proper signature for the `ReceiverPays` example:
// recipient is the address that should be paid.
// amount, in wei, specifies how much ether should be sent.
// nonce can be any unique number to prevent replay attacks
// contractAddress is used to prevent cross-contract replay attacks
function signPayment(recipient, amount, nonce, contractAddress, callback) {
 var hash \= "0x" + abi.soliditySHA3(
 \["address", "uint256", "uint256", "address"\],
 \[recipient, amount, nonce, contractAddress\]
 ).toString("hex");
 web3.eth.personal.sign(hash, web3.eth.defaultAccount, callback);
}
#### Recovering the Message Signer in Solidity[](#recovering-the-message-signer-in-solidity "Link to this heading")
In general, ECDSA signatures consist of two parameters, `r` and `s`. Signatures in Ethereum include a third parameter called `v`, that you can use to verify which account’s private key was used to sign the message, and the transaction’s sender. Solidity provides a built-in function [ecrecover](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#mathematical-and-cryptographic-functions) that accepts a message along with the `r`, `s` and `v` parameters and returns the address that was used to sign the message.
#### Computing the Message Hash[](#computing-the-message-hash "Link to this heading")
The smart contract needs to know exactly what parameters were signed, and so it must recreate the message from the parameters and use that for signature verification. The functions `prefixed` and `recoverSigner` do this in the `claimPayment` function.
#### The full contract[](#the-full-contract "Link to this heading")
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgT3duZWQgewogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwogICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgb3duZXIgPSBwYXlhYmxlKG1zZy5zZW5kZXIpOwogICAgfQp9Cgpjb250cmFjdCBGcmVlemFibGUgaXMgT3duZWQgewogICAgYm9vbCBwcml2YXRlIF9mcm96ZW4gPSBmYWxzZTsKCiAgICBtb2RpZmllciBub3RGcm96ZW4oKSB7CiAgICAgICAgcmVxdWlyZSghX2Zyb3plbiwgIkluYWN0aXZlIENvbnRyYWN0LiIpOwogICAgICAgIF87CiAgICB9CgogICAgZnVuY3Rpb24gZnJlZXplKCkgaW50ZXJuYWwgewogICAgICAgIGlmIChtc2cuc2VuZGVyID09IG93bmVyKQogICAgICAgICAgICBfZnJvemVuID0gdHJ1ZTsKICAgIH0KfQoKY29udHJhY3QgUmVjZWl2ZXJQYXlzIGlzIEZyZWV6YWJsZSB7CiAgICBtYXBwaW5nKHVpbnQyNTYgPT4gYm9vbCkgdXNlZE5vbmNlczsKCiAgICBjb25zdHJ1Y3RvcigpIHBheWFibGUge30KCiAgICBmdW5jdGlvbiBjbGFpbVBheW1lbnQodWludDI1NiBhbW91bnQsIHVpbnQyNTYgbm9uY2UsIGJ5dGVzIG1lbW9yeSBzaWduYXR1cmUpCiAgICAgICAgZXh0ZXJuYWwKICAgICAgICBub3RGcm96ZW4KICAgIHsKICAgICAgICByZXF1aXJlKCF1c2VkTm9uY2VzW25vbmNlXSk7CiAgICAgICAgdXNlZE5vbmNlc1tub25jZV0gPSB0cnVlOwoKICAgICAgICAvLyB0aGlzIHJlY3JlYXRlcyB0aGUgbWVzc2FnZSB0aGF0IHdhcyBzaWduZWQgb24gdGhlIGNsaWVudAogICAgICAgIGJ5dGVzMzIgbWVzc2FnZSA9IHByZWZpeGVkKGtlY2NhazI1NihhYmkuZW5jb2RlUGFja2VkKG1zZy5zZW5kZXIsIGFtb3VudCwgbm9uY2UsIHRoaXMpKSk7CiAgICAgICAgcmVxdWlyZShyZWNvdmVyU2lnbmVyKG1lc3NhZ2UsIHNpZ25hdHVyZSkgPT0gb3duZXIpOwogICAgICAgIHBheWFibGUobXNnLnNlbmRlcikudHJhbnNmZXIoYW1vdW50KTsKICAgIH0KCiAgICAvLy8gZnJlZXplIHRoZSBjb250cmFjdCBhbmQgcmVjbGFpbSB0aGUgbGVmdG92ZXIgZnVuZHMuCiAgICBmdW5jdGlvbiBzaHV0ZG93bigpCiAgICAgICAgZXh0ZXJuYWwKICAgICAgICBub3RGcm96ZW4KICAgIHsKICAgICAgICByZXF1aXJlKG1zZy5zZW5kZXIgPT0gb3duZXIpOwogICAgICAgIGZyZWV6ZSgpOwogICAgICAgIHBheWFibGUobXNnLnNlbmRlcikudHJhbnNmZXIoYWRkcmVzcyh0aGlzKS5iYWxhbmNlKTsKICAgIH0KCiAgICAvLy8gc2lnbmF0dXJlIG1ldGhvZHMuCiAgICBmdW5jdGlvbiBzcGxpdFNpZ25hdHVyZShieXRlcyBtZW1vcnkgc2lnKQogICAgICAgIGludGVybmFsCiAgICAgICAgcHVyZQogICAgICAgIHJldHVybnMgKHVpbnQ4IHYsIGJ5dGVzMzIgciwgYnl0ZXMzMiBzKQogICAgewogICAgICAgIHJlcXVpcmUoc2lnLmxlbmd0aCA9PSA2NSk7CgogICAgICAgIGFzc2VtYmx5IHsKICAgICAgICAgICAgLy8gZmlyc3QgMzIgYnl0ZXMsIGFmdGVyIHRoZSBsZW5ndGggcHJlZml4LgogICAgICAgICAgICByIDo9IG1sb2FkKGFkZChzaWcsIDMyKSkKICAgICAgICAgICAgLy8gc2Vjb25kIDMyIGJ5dGVzLgogICAgICAgICAgICBzIDo9IG1sb2FkKGFkZChzaWcsIDY0KSkKICAgICAgICAgICAgLy8gZmluYWwgYnl0ZSAoZmlyc3QgYnl0ZSBvZiB0aGUgbmV4dCAzMiBieXRlcykuCiAgICAgICAgICAgIHYgOj0gYnl0ZSgwLCBtbG9hZChhZGQoc2lnLCA5NikpKQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuICh2LCByLCBzKTsKICAgIH0KCiAgICBmdW5jdGlvbiByZWNvdmVyU2lnbmVyKGJ5dGVzMzIgbWVzc2FnZSwgYnl0ZXMgbWVtb3J5IHNpZykKICAgICAgICBpbnRlcm5hbAogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zIChhZGRyZXNzKQogICAgewogICAgICAgICh1aW50OCB2LCBieXRlczMyIHIsIGJ5dGVzMzIgcykgPSBzcGxpdFNpZ25hdHVyZShzaWcpOwogICAgICAgIHJldHVybiBlY3JlY292ZXIobWVzc2FnZSwgdiwgciwgcyk7CiAgICB9CgogICAgLy8vIGJ1aWxkcyBhIHByZWZpeGVkIGhhc2ggdG8gbWltaWMgdGhlIGJlaGF2aW9yIG9mIGV0aF9zaWduLgogICAgZnVuY3Rpb24gcHJlZml4ZWQoYnl0ZXMzMiBoYXNoKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKGJ5dGVzMzIpIHsKICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQoIlx4MTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcbjMyIiwgaGFzaCkpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Owned {
 address payable owner;
 constructor() {
 owner \= payable(msg.sender);
 }
}
contract Freezable is Owned {
 bool private \_frozen \= false;
 modifier notFrozen() {
 require(!\_frozen, "Inactive Contract.");
 \_;
 }
 function freeze() internal {
 if (msg.sender \== owner)
 \_frozen \= true;
 }
}
contract ReceiverPays is Freezable {
 mapping(uint256 \=> bool) usedNonces;
 constructor() payable {}
 function claimPayment(uint256 amount, uint256 nonce, bytes memory signature)
 external
 notFrozen
 {
 require(!usedNonces\[nonce\]);
 usedNonces\[nonce\] \= true;
 // this recreates the message that was signed on the client
 bytes32 message \= prefixed(keccak256(abi.encodePacked(msg.sender, amount, nonce, this)));
 require(recoverSigner(message, signature) \== owner);
 payable(msg.sender).transfer(amount);
 }
 /// freeze the contract and reclaim the leftover funds.
 function shutdown()
 external
 notFrozen
 {
 require(msg.sender \== owner);
 freeze();
 payable(msg.sender).transfer(address(this).balance);
 }
 /// signature methods.
 function splitSignature(bytes memory sig)
 internal
 pure
 returns (uint8 v, bytes32 r, bytes32 s)
 {
 require(sig.length \== 65);
 assembly {
 // first 32 bytes, after the length prefix.
 r := mload(add(sig, 32))
 // second 32 bytes.
 s := mload(add(sig, 64))
 // final byte (first byte of the next 32 bytes).
 v := byte(0, mload(add(sig, 96)))
 }
 return (v, r, s);
 }
 function recoverSigner(bytes32 message, bytes memory sig)
 internal
 pure
 returns (address)
 {
 (uint8 v, bytes32 r, bytes32 s) \= splitSignature(sig);
 return ecrecover(message, v, r, s);
 }
 /// builds a prefixed hash to mimic the behavior of eth\_sign.
 function prefixed(bytes32 hash) internal pure returns (bytes32) {
 return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));
 }
}
### Writing a Simple Payment Channel[](#writing-a-simple-payment-channel "Link to this heading")
Alice now builds a simple but complete implementation of a payment channel. Payment channels use cryptographic signatures to make repeated transfers of Ether securely, instantaneously, and without transaction fees.
#### What is a Payment Channel?[](#what-is-a-payment-channel "Link to this heading")
Payment channels allow participants to make repeated transfers of Ether without using transactions. This means that you can avoid the delays and fees associated with transactions. We are going to explore a simple unidirectional payment channel between two parties (Alice and Bob). It involves three steps:
> 1. Alice funds a smart contract with Ether. This “opens” the payment channel.
> 
> 2. Alice signs messages that specify how much of that Ether is owed to the recipient. This step is repeated for each payment.
> 
> 3. Bob “closes” the payment channel, withdrawing his portion of the Ether and sending the remainder back to the sender.
> 
Note
Only steps 1 and 3 require Ethereum transactions, step 2 means that the sender transmits a cryptographically signed message to the recipient via off chain methods (e.g. email). This means only two transactions are required to support any number of transfers.
Bob is guaranteed to receive his funds because the smart contract escrows the Ether and honours a valid signed message. The smart contract also enforces a timeout, so Alice is guaranteed to eventually recover her funds even if the recipient refuses to close the channel. It is up to the participants in a payment channel to decide how long to keep it open. For a short-lived transaction, such as paying an internet café for each minute of network access, the payment channel may be kept open for a limited duration. On the other hand, for a recurring payment, such as paying an employee an hourly wage, the payment channel may be kept open for several months or years.
#### Opening the Payment Channel[](#opening-the-payment-channel "Link to this heading")
To open the payment channel, Alice deploys the smart contract, attaching the Ether to be escrowed and specifying the intended recipient and a maximum duration for the channel to exist. This is the `constructor` in the `SimplePaymentChannel` contract, at the end of this section.
#### Making Payments[](#making-payments "Link to this heading")
Alice makes payments by sending signed messages to Bob. This step is performed entirely outside of the Ethereum network. Messages are cryptographically signed by the sender and then transmitted directly to the recipient.
Each message includes the following information:
> * The smart contract’s address, used to prevent cross-contract replay attacks.
> 
> * The total amount of Ether that is owed to the recipient so far.
> 
A payment channel is closed just once, at the end of a series of transfers. Because of this, only one of the messages sent is redeemed. This is why each message specifies a cumulative total amount of Ether owed, rather than the amount of the individual micropayment. The recipient will naturally choose to redeem the most recent message because that is the one with the highest total. The nonce per-message is not needed anymore, because the smart contract only honours a single message. The address of the smart contract is still used to prevent a message intended for one payment channel from being used for a different channel.
Here is the modified JavaScript code to cryptographically sign a message from the previous section:
function constructPaymentMessage(contractAddress, amount) {
 return abi.soliditySHA3(
 \["address", "uint256"\],
 \[contractAddress, amount\]
 );
}
function signMessage(message, callback) {
 web3.eth.personal.sign(
 "0x" + message.toString("hex"),
 web3.eth.defaultAccount,
 callback
 );
}
// contractAddress is used to prevent cross-contract replay attacks.
// amount, in wei, specifies how much Ether should be sent.
function signPayment(contractAddress, amount, callback) {
 var message \= constructPaymentMessage(contractAddress, amount);
 signMessage(message, callback);
}
#### Closing the Payment Channel[](#closing-the-payment-channel "Link to this heading")
When Bob is ready to receive his funds, it is time to close the payment channel by calling a `close` function on the smart contract. Closing the channel pays the recipient the Ether they are owed and deactivates the contract by freezing it, sending any remaining Ether back to Alice. To close the channel, Bob needs to provide a message signed by Alice.
The smart contract must verify that the message contains a valid signature from the sender. The process for doing this verification is the same as the process the recipient uses. The Solidity functions `isValidSignature` and `recoverSigner` work just like their JavaScript counterparts in the previous section, with the latter function borrowed from the `ReceiverPays` contract.
Only the payment channel recipient can call the `close` function, who naturally passes the most recent payment message because that message carries the highest total owed. If the sender were allowed to call this function, they could provide a message with a lower amount and cheat the recipient out of what they are owed.
The function verifies the signed message matches the given parameters. If everything checks out, the recipient is sent their portion of the Ether, and the sender is sent the remaining funds via a `transfer`. You can see the `close` function in the full contract.
#### Channel Expiration[](#channel-expiration "Link to this heading")
Bob can close the payment channel at any time, but if they fail to do so, Alice needs a way to recover her escrowed funds. An _expiration_ time was set at the time of contract deployment. Once that time is reached, Alice can call `claimTimeout` to recover her funds. You can see the `claimTimeout` function in the full contract.
After this function is called, Bob can no longer receive any Ether, so it is important that Bob closes the channel before the expiration is reached.
#### The full contract[](#id3 "Link to this heading")
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgRnJvemVhYmxlIHsKICAgIGJvb2wgcHJpdmF0ZSBfZnJvemVuID0gZmFsc2U7CgogICAgbW9kaWZpZXIgbm90RnJvemVuKCkgewogICAgICAgIHJlcXVpcmUoIV9mcm96ZW4sICJJbmFjdGl2ZSBDb250cmFjdC4iKTsKICAgICAgICBfOwogICAgfQoKICAgIGZ1bmN0aW9uIGZyZWV6ZSgpIGludGVybmFsIHsKICAgICAgICBfZnJvemVuID0gdHJ1ZTsKICAgIH0KfQoKY29udHJhY3QgU2ltcGxlUGF5bWVudENoYW5uZWwgaXMgRnJvemVhYmxlIHsKICAgIGFkZHJlc3MgcGF5YWJsZSBwdWJsaWMgc2VuZGVyOyAgICAvLyBUaGUgYWNjb3VudCBzZW5kaW5nIHBheW1lbnRzLgogICAgYWRkcmVzcyBwYXlhYmxlIHB1YmxpYyByZWNpcGllbnQ7IC8vIFRoZSBhY2NvdW50IHJlY2VpdmluZyB0aGUgcGF5bWVudHMuCiAgICB1aW50MjU2IHB1YmxpYyBleHBpcmF0aW9uOyAgICAgICAgLy8gVGltZW91dCBpbiBjYXNlIHRoZSByZWNpcGllbnQgbmV2ZXIgY2xvc2VzLgoKICAgIGNvbnN0cnVjdG9yIChhZGRyZXNzIHBheWFibGUgcmVjaXBpZW50QWRkcmVzcywgdWludDI1NiBkdXJhdGlvbikKICAgICAgICBwYXlhYmxlCiAgICB7CiAgICAgICAgc2VuZGVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsKICAgICAgICByZWNpcGllbnQgPSByZWNpcGllbnRBZGRyZXNzOwogICAgICAgIGV4cGlyYXRpb24gPSBibG9jay50aW1lc3RhbXAgKyBkdXJhdGlvbjsKICAgIH0KCiAgICAvLy8gdGhlIHJlY2lwaWVudCBjYW4gY2xvc2UgdGhlIGNoYW5uZWwgYXQgYW55IHRpbWUgYnkgcHJlc2VudGluZyBhCiAgICAvLy8gc2lnbmVkIGFtb3VudCBmcm9tIHRoZSBzZW5kZXIuIHRoZSByZWNpcGllbnQgd2lsbCBiZSBzZW50IHRoYXQgYW1vdW50LAogICAgLy8vIGFuZCB0aGUgcmVtYWluZGVyIHdpbGwgZ28gYmFjayB0byB0aGUgc2VuZGVyCiAgICBmdW5jdGlvbiBjbG9zZSh1aW50MjU2IGFtb3VudCwgYnl0ZXMgbWVtb3J5IHNpZ25hdHVyZSkKICAgICAgICBleHRlcm5hbAogICAgICAgIG5vdEZyb3plbgogICAgewogICAgICAgIHJlcXVpcmUobXNnLnNlbmRlciA9PSByZWNpcGllbnQpOwogICAgICAgIHJlcXVpcmUoaXNWYWxpZFNpZ25hdHVyZShhbW91bnQsIHNpZ25hdHVyZSkpOwoKICAgICAgICByZWNpcGllbnQudHJhbnNmZXIoYW1vdW50KTsKICAgICAgICBmcmVlemUoKTsKICAgICAgICBzZW5kZXIudHJhbnNmZXIoYWRkcmVzcyh0aGlzKS5iYWxhbmNlKTsKICAgIH0KCiAgICAvLy8gdGhlIHNlbmRlciBjYW4gZXh0ZW5kIHRoZSBleHBpcmF0aW9uIGF0IGFueSB0aW1lCiAgICBmdW5jdGlvbiBleHRlbmQodWludDI1NiBuZXdFeHBpcmF0aW9uKQogICAgICAgIGV4dGVybmFsCiAgICAgICAgbm90RnJvemVuCiAgICB7CiAgICAgICAgcmVxdWlyZShtc2cuc2VuZGVyID09IHNlbmRlcik7CiAgICAgICAgcmVxdWlyZShuZXdFeHBpcmF0aW9uID4gZXhwaXJhdGlvbik7CgogICAgICAgIGV4cGlyYXRpb24gPSBuZXdFeHBpcmF0aW9uOwogICAgfQoKICAgIC8vLyBpZiB0aGUgdGltZW91dCBpcyByZWFjaGVkIHdpdGhvdXQgdGhlIHJlY2lwaWVudCBjbG9zaW5nIHRoZSBjaGFubmVsLAogICAgLy8vIHRoZW4gdGhlIEV0aGVyIGlzIHJlbGVhc2VkIGJhY2sgdG8gdGhlIHNlbmRlci4KICAgIGZ1bmN0aW9uIGNsYWltVGltZW91dCgpCiAgICAgICAgZXh0ZXJuYWwKICAgICAgICBub3RGcm96ZW4KICAgIHsKICAgICAgICByZXF1aXJlKGJsb2NrLnRpbWVzdGFtcCA+PSBleHBpcmF0aW9uKTsKICAgICAgICBmcmVlemUoKTsKICAgICAgICBzZW5kZXIudHJhbnNmZXIoYWRkcmVzcyh0aGlzKS5iYWxhbmNlKTsKICAgIH0KCiAgICBmdW5jdGlvbiBpc1ZhbGlkU2lnbmF0dXJlKHVpbnQyNTYgYW1vdW50LCBieXRlcyBtZW1vcnkgc2lnbmF0dXJlKQogICAgICAgIGludGVybmFsCiAgICAgICAgdmlldwogICAgICAgIHJldHVybnMgKGJvb2wpCiAgICB7CiAgICAgICAgYnl0ZXMzMiBtZXNzYWdlID0gcHJlZml4ZWQoa2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQodGhpcywgYW1vdW50KSkpOwogICAgICAgIC8vIGNoZWNrIHRoYXQgdGhlIHNpZ25hdHVyZSBpcyBmcm9tIHRoZSBwYXltZW50IHNlbmRlcgogICAgICAgIHJldHVybiByZWNvdmVyU2lnbmVyKG1lc3NhZ2UsIHNpZ25hdHVyZSkgPT0gc2VuZGVyOwogICAgfQoKICAgIC8vLyBBbGwgZnVuY3Rpb25zIGJlbG93IHRoaXMgYXJlIGp1c3QgdGFrZW4gZnJvbSB0aGUgY2hhcHRlcgogICAgLy8vICdjcmVhdGluZyBhbmQgdmVyaWZ5aW5nIHNpZ25hdHVyZXMnIGNoYXB0ZXIuCiAgICBmdW5jdGlvbiBzcGxpdFNpZ25hdHVyZShieXRlcyBtZW1vcnkgc2lnKQogICAgICAgIGludGVybmFsCiAgICAgICAgcHVyZQogICAgICAgIHJldHVybnMgKHVpbnQ4IHYsIGJ5dGVzMzIgciwgYnl0ZXMzMiBzKQogICAgewogICAgICAgIHJlcXVpcmUoc2lnLmxlbmd0aCA9PSA2NSk7CgogICAgICAgIGFzc2VtYmx5IHsKICAgICAgICAgICAgLy8gZmlyc3QgMzIgYnl0ZXMsIGFmdGVyIHRoZSBsZW5ndGggcHJlZml4CiAgICAgICAgICAgIHIgOj0gbWxvYWQoYWRkKHNpZywgMzIpKQogICAgICAgICAgICAvLyBzZWNvbmQgMzIgYnl0ZXMKICAgICAgICAgICAgcyA6PSBtbG9hZChhZGQoc2lnLCA2NCkpCiAgICAgICAgICAgIC8vIGZpbmFsIGJ5dGUgKGZpcnN0IGJ5dGUgb2YgdGhlIG5leHQgMzIgYnl0ZXMpCiAgICAgICAgICAgIHYgOj0gYnl0ZSgwLCBtbG9hZChhZGQoc2lnLCA5NikpKQogICAgICAgIH0KICAgICAgICByZXR1cm4gKHYsIHIsIHMpOwogICAgfQoKICAgIGZ1bmN0aW9uIHJlY292ZXJTaWduZXIoYnl0ZXMzMiBtZXNzYWdlLCBieXRlcyBtZW1vcnkgc2lnKQogICAgICAgIGludGVybmFsCiAgICAgICAgcHVyZQogICAgICAgIHJldHVybnMgKGFkZHJlc3MpCiAgICB7CiAgICAgICAgKHVpbnQ4IHYsIGJ5dGVzMzIgciwgYnl0ZXMzMiBzKSA9IHNwbGl0U2lnbmF0dXJlKHNpZyk7CiAgICAgICAgcmV0dXJuIGVjcmVjb3ZlcihtZXNzYWdlLCB2LCByLCBzKTsKICAgIH0KCiAgICAvLy8gYnVpbGRzIGEgcHJlZml4ZWQgaGFzaCB0byBtaW1pYyB0aGUgYmVoYXZpb3Igb2YgZXRoX3NpZ24uCiAgICBmdW5jdGlvbiBwcmVmaXhlZChieXRlczMyIGhhc2gpIGludGVybmFsIHB1cmUgcmV0dXJucyAoYnl0ZXMzMikgewogICAgICAgIHJldHVybiBrZWNjYWsyNTYoYWJpLmVuY29kZVBhY2tlZCgiXHgxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxuMzIiLCBoYXNoKSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Frozeable {
 bool private \_frozen \= false;
 modifier notFrozen() {
 require(!\_frozen, "Inactive Contract.");
 \_;
 }
 function freeze() internal {
 \_frozen \= true;
 }
}
contract SimplePaymentChannel is Frozeable {
 address payable public sender; // The account sending payments.
 address payable public recipient; // The account receiving the payments.
 uint256 public expiration; // Timeout in case the recipient never closes.
 constructor (address payable recipientAddress, uint256 duration)
 payable
 {
 sender \= payable(msg.sender);
 recipient \= recipientAddress;
 expiration \= block.timestamp + duration;
 }
 /// the recipient can close the channel at any time by presenting a
 /// signed amount from the sender. the recipient will be sent that amount,
 /// and the remainder will go back to the sender
 function close(uint256 amount, bytes memory signature)
 external
 notFrozen
 {
 require(msg.sender \== recipient);
 require(isValidSignature(amount, signature));
 recipient.transfer(amount);
 freeze();
 sender.transfer(address(this).balance);
 }
 /// the sender can extend the expiration at any time
 function extend(uint256 newExpiration)
 external
 notFrozen
 {
 require(msg.sender \== sender);
 require(newExpiration \> expiration);
 expiration \= newExpiration;
 }
 /// if the timeout is reached without the recipient closing the channel,
 /// then the Ether is released back to the sender.
 function claimTimeout()
 external
 notFrozen
 {
 require(block.timestamp \>= expiration);
 freeze();
 sender.transfer(address(this).balance);
 }
 function isValidSignature(uint256 amount, bytes memory signature)
 internal
 view
 returns (bool)
 {
 bytes32 message \= prefixed(keccak256(abi.encodePacked(this, amount)));
 // check that the signature is from the payment sender
 return recoverSigner(message, signature) \== sender;
 }
 /// All functions below this are just taken from the chapter
 /// 'creating and verifying signatures' chapter.
 function splitSignature(bytes memory sig)
 internal
 pure
 returns (uint8 v, bytes32 r, bytes32 s)
 {
 require(sig.length \== 65);
 assembly {
 // first 32 bytes, after the length prefix
 r := mload(add(sig, 32))
 // second 32 bytes
 s := mload(add(sig, 64))
 // final byte (first byte of the next 32 bytes)
 v := byte(0, mload(add(sig, 96)))
 }
 return (v, r, s);
 }
 function recoverSigner(bytes32 message, bytes memory sig)
 internal
 pure
 returns (address)
 {
 (uint8 v, bytes32 r, bytes32 s) \= splitSignature(sig);
 return ecrecover(message, v, r, s);
 }
 /// builds a prefixed hash to mimic the behavior of eth\_sign.
 function prefixed(bytes32 hash) internal pure returns (bytes32) {
 return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));
 }
}
Note
The function `splitSignature` does not use all security checks. A real implementation should use a more rigorously tested library, such as openzeppelin’s [version](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol) of this code.
#### Verifying Payments[](#verifying-payments "Link to this heading")
Unlike in the previous section, messages in a payment channel aren’t redeemed right away. The recipient keeps track of the latest message and redeems it when it’s time to close the payment channel. This means it’s critical that the recipient perform their own verification of each message. Otherwise there is no guarantee that the recipient will be able to get paid in the end.
The recipient should verify each message using the following process:
> 1. Verify that the contract address in the message matches the payment channel.
> 
> 2. Verify that the new total is the expected amount.
> 
> 3. Verify that the new total does not exceed the amount of Ether escrowed.
> 
> 4. Verify that the signature is valid and comes from the payment channel sender.
> 
We’ll use the [ethereumjs-util](https://github.com/ethereumjs/ethereumjs-util) library to write this verification. The final step can be done a number of ways, and we use JavaScript. The following code borrows the `constructPaymentMessage` function from the signing **JavaScript code** above:
// this mimics the prefixing behavior of the eth\_sign JSON-RPC method.
function prefixed(hash) {
 return ethereumjs.ABI.soliditySHA3(
 \["string", "bytes32"\],
 \["\\x19Ethereum Signed Message:\\n32", hash\]
 );
}
function recoverSigner(message, signature) {
 var split \= ethereumjs.Util.fromRpcSig(signature);
 var publicKey \= ethereumjs.Util.ecrecover(message, split.v, split.r, split.s);
 var signer \= ethereumjs.Util.pubToAddress(publicKey).toString("hex");
 return signer;
}
function isValidSignature(contractAddress, amount, signature, expectedSigner) {
 var message \= prefixed(constructPaymentMessage(contractAddress, amount));
 var signer \= recoverSigner(message, signature);
 return signer.toLowerCase() \==
 ethereumjs.Util.stripHexPrefix(expectedSigner).toLowerCase();
}
## Modular Contracts[](#modular-contracts "Link to this heading")
A modular approach to building your contracts helps you reduce the complexity and improve the readability which will help to identify bugs and vulnerabilities during development and code review. If you specify and control the behavior of each module in isolation, the interactions you have to consider are only those between the module specifications and not every other moving part of the contract. In the example below, the contract uses the `move` method of the `Balances` [library](https://docs.soliditylang.org/en/latest/contracts.html#libraries) to check that balances sent between addresses match what you expect. In this way, the `Balances` library provides an isolated component that properly tracks balances of accounts. It is easy to verify that the `Balances` library never produces negative balances or overflows and the sum of all balances is an invariant across the lifetime of the contract.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKbGlicmFyeSBCYWxhbmNlcyB7CiAgICBmdW5jdGlvbiBtb3ZlKG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50MjU2KSBzdG9yYWdlIGJhbGFuY2VzLCBhZGRyZXNzIGZyb20sIGFkZHJlc3MgdG8sIHVpbnQgYW1vdW50KSBpbnRlcm5hbCB7CiAgICAgICAgcmVxdWlyZShiYWxhbmNlc1tmcm9tXSA+PSBhbW91bnQpOwogICAgICAgIHJlcXVpcmUoYmFsYW5jZXNbdG9dICsgYW1vdW50ID49IGJhbGFuY2VzW3RvXSk7CiAgICAgICAgYmFsYW5jZXNbZnJvbV0gLT0gYW1vdW50OwogICAgICAgIGJhbGFuY2VzW3RvXSArPSBhbW91bnQ7CiAgICB9Cn0KCmNvbnRyYWN0IFRva2VuIHsKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50MjU2KSBiYWxhbmNlczsKICAgIHVzaW5nIEJhbGFuY2VzIGZvciAqOwogICAgbWFwcGluZyhhZGRyZXNzID0+IG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50MjU2KSkgYWxsb3dlZDsKCiAgICBldmVudCBUcmFuc2ZlcihhZGRyZXNzIGZyb20sIGFkZHJlc3MgdG8sIHVpbnQgYW1vdW50KTsKICAgIGV2ZW50IEFwcHJvdmFsKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3Mgc3BlbmRlciwgdWludCBhbW91bnQpOwoKICAgIGZ1bmN0aW9uIHRyYW5zZmVyKGFkZHJlc3MgdG8sIHVpbnQgYW1vdW50KSBleHRlcm5hbCByZXR1cm5zIChib29sIHN1Y2Nlc3MpIHsKICAgICAgICBiYWxhbmNlcy5tb3ZlKG1zZy5zZW5kZXIsIHRvLCBhbW91bnQpOwogICAgICAgIGVtaXQgVHJhbnNmZXIobXNnLnNlbmRlciwgdG8sIGFtb3VudCk7CiAgICAgICAgcmV0dXJuIHRydWU7CgogICAgfQoKICAgIGZ1bmN0aW9uIHRyYW5zZmVyRnJvbShhZGRyZXNzIGZyb20sIGFkZHJlc3MgdG8sIHVpbnQgYW1vdW50KSBleHRlcm5hbCByZXR1cm5zIChib29sIHN1Y2Nlc3MpIHsKICAgICAgICByZXF1aXJlKGFsbG93ZWRbZnJvbV1bbXNnLnNlbmRlcl0gPj0gYW1vdW50KTsKICAgICAgICBhbGxvd2VkW2Zyb21dW21zZy5zZW5kZXJdIC09IGFtb3VudDsKICAgICAgICBiYWxhbmNlcy5tb3ZlKGZyb20sIHRvLCBhbW91bnQpOwogICAgICAgIGVtaXQgVHJhbnNmZXIoZnJvbSwgdG8sIGFtb3VudCk7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICB9CgogICAgZnVuY3Rpb24gYXBwcm92ZShhZGRyZXNzIHNwZW5kZXIsIHVpbnQgdG9rZW5zKSBleHRlcm5hbCByZXR1cm5zIChib29sIHN1Y2Nlc3MpIHsKICAgICAgICByZXF1aXJlKGFsbG93ZWRbbXNnLnNlbmRlcl1bc3BlbmRlcl0gPT0gMCwgIiIpOwogICAgICAgIGFsbG93ZWRbbXNnLnNlbmRlcl1bc3BlbmRlcl0gPSB0b2tlbnM7CiAgICAgICAgZW1pdCBBcHByb3ZhbChtc2cuc2VuZGVyLCBzcGVuZGVyLCB0b2tlbnMpOwogICAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICAgIGZ1bmN0aW9uIGJhbGFuY2VPZihhZGRyZXNzIHRva2VuT3duZXIpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAodWludCBiYWxhbmNlKSB7CiAgICAgICAgcmV0dXJuIGJhbGFuY2VzW3Rva2VuT3duZXJdOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
library Balances {
 function move(mapping(address \=> uint256) storage balances, address from, address to, uint amount) internal {
 require(balances\[from\] \>= amount);
 require(balances\[to\] + amount \>= balances\[to\]);
 balances\[from\] \-= amount;
 balances\[to\] += amount;
 }
}
contract Token {
 mapping(address \=> uint256) balances;
 using Balances for \*;
 mapping(address \=> mapping(address \=> uint256)) allowed;
 event Transfer(address from, address to, uint amount);
 event Approval(address owner, address spender, uint amount);
 function transfer(address to, uint amount) external returns (bool success) {
 balances.move(msg.sender, to, amount);
 emit Transfer(msg.sender, to, amount);
 return true;
 }
 function transferFrom(address from, address to, uint amount) external returns (bool success) {
 require(allowed\[from\]\[msg.sender\] \>= amount);
 allowed\[from\]\[msg.sender\] \-= amount;
 balances.move(from, to, amount);
 emit Transfer(from, to, amount);
 return true;
 }
 function approve(address spender, uint tokens) external returns (bool success) {
 require(allowed\[msg.sender\]\[spender\] \== 0, "");
 allowed\[msg.sender\]\[spender\] \= tokens;
 emit Approval(msg.sender, spender, tokens);
 return true;
 }
 function balanceOf(address tokenOwner) external view returns (uint balance) {
 return balances\[tokenOwner\];
 }
}

# [Index — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/genindex.html) 
 _https://docs.soliditylang.org/en/v0.8.30/genindex.html_

[**Symbols**](#Symbols) | [**A**](#A) | [**B**](#B) | [**C**](#C) | [**D**](#D) | [**E**](#E) | [**F**](#F) | [**G**](#G) | [**H**](#H) | [**I**](#I) | [**J**](#J) | [**K**](#K) | [**L**](#L) | [**M**](#M) | [**N**](#N) | [**O**](#O) | [**P**](#P) | [**R**](#R) | [**S**](#S) | [**T**](#T) | [**U**](#U) | [**V**](#V) | [**W**](#W) | [**Y**](#Y)
## Symbols
* [**\--allow-paths**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-8), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#index-1)
* [**\--base-path**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-7), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#index-1), [\[2\]](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#index-3)
* [**\--include-path**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-7), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#index-1)
* [**\--libraries**](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#index-2)
* [**\--link**](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#index-2)
* [**\--no-import-callback**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-1)
* [**\--standard-json**](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#index-5), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#index-3)
* [<stdin>](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-3)
## A
* [abi](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#index-0), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-3), [\[2\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-4)
 * [decode](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-1)
 * [encode](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-1)
 * [encodeCall](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-1)
 * [encodePacked](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-1)
 * [encodeWithSelector](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-1)
 * [encodeWithSignature](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-1)
* [**ABI coder**](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-3)
* [**abstract contract**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-25), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-23)
* access
 * [restricting](https://docs.soliditylang.org/en/v0.8.30/common-patterns.html#index-1)
* [**account**](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-7)
* [addmod](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-8)
* [address](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-7), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/types.html#index-5), [\[2\]](https://docs.soliditylang.org/en/v0.8.30/types.html#index-8)
 * [balance](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-3)
 * [code](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-3)
 * [codehash](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-3)
 * [send](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-3)
 * [transfer](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-3)
* [**allowed paths**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-8), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#index-1)
* [analyse](https://docs.soliditylang.org/en/v0.8.30/analysing-compilation-output.html#index-0)
* [anonymous](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-11)
* [application binary interface](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#index-0)
* [**array**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-17), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-10), [\[2\]](https://docs.soliditylang.org/en/v0.8.30/types.html#index-16)
 * [**allocating**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-20)
 * [**dangling storage references**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-23)
 * [**length**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-22)
 * [**pop**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-22)
 * [**push**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-22)
 * [**slice**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-24)
* [array of strings](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-10)
* [**asm**](https://docs.soliditylang.org/en/v0.8.30/assembly.html#index-0), [**\[1\]**](https://docs.soliditylang.org/en/v0.8.30/yul.html#index-0), [\[2\]](https://docs.soliditylang.org/en/v0.8.30/analysing-compilation-output.html#index-0)
* [**assembly**](https://docs.soliditylang.org/en/v0.8.30/assembly.html#index-0), [**\[1\]**](https://docs.soliditylang.org/en/v0.8.30/yul.html#index-0)
* [assembly-flags (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.assemblyFlags)
* [assembly-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.assemblyStatement)
* [**assert**](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-8), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-6), [\[2\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-7)
* [**assignment**](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-4), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/types.html#index-29)
 * [**destructuring**](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-5)
* auction
 * [blind](https://docs.soliditylang.org/en/v0.8.30/solidity-by-example.html#index-1)
 * [open](https://docs.soliditylang.org/en/v0.8.30/solidity-by-example.html#index-1)
## B
* [balance](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-7), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/types.html#index-5), [\[2\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-9)
* [ballot](https://docs.soliditylang.org/en/v0.8.30/solidity-by-example.html#index-0)
* base
 * [**constructor**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-23)
* [**base class**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-19)
* [**base path**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-7), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#index-1)
* [**base slot**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-8)
* [blind auction](https://docs.soliditylang.org/en/v0.8.30/solidity-by-example.html#index-1)
* [blobhash](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-4)
* [**block**](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-5), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-4), [\[2\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-3)
 * [basefee](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-4), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-3)
 * [blobbasefee](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-4), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-3)
 * [chainid](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-4)
 * [coinbase](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-4)
 * [difficulty](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-4)
 * [gaslimit](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-4)
 * [number](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-4), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-3)
 * [prevrandao](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-4)
 * [timestamp](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-4), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-3)
* [block (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.block)
* [blockhash](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-4)
* [**bool**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-2)
* [boolean-literal (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.booleanLiteral)
* [break](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-1)
* [break-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.breakStatement)
* [Bugs](https://docs.soliditylang.org/en/v0.8.30/bugs.html#index-0)
* [byte array](https://docs.soliditylang.org/en/v0.8.30/types.html#index-7)
* [**bytes**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-18), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/types.html#index-12)
 * [concat](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-2)
* [bytes members](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-5)
* [**bytes-concat**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-19)
* [bytes32](https://docs.soliditylang.org/en/v0.8.30/types.html#index-7)
## C
* [**C3 linearization**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-24)
* [call](https://docs.soliditylang.org/en/v0.8.30/types.html#index-5), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-9)
* [call-argument-list (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.callArgumentList)
* [callcode](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-27), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-9)
* [**cast**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-32)
* [catch-clause (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.catchClause)
* [checked](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-7)
* [cleanup](https://docs.soliditylang.org/en/v0.8.30/ir-breaking-changes.html#index-3)
* [codehash](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-9)
* [coding style](https://docs.soliditylang.org/en/v0.8.30/style-guide.html#index-0)
* [coin](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-3)
* [coinbase](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-3)
* [**commandline compiler**](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#index-0)
* [**comment**](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-9)
* [common subexpression elimination](https://docs.soliditylang.org/en/v0.8.30/internals/optimizer.html#index-0)
* [compile target](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#index-4)
* compiler
 * [commandline](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#index-0)
* [**compound operators**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-29)
* [**constant**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-7), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-11)
* [constant propagation](https://docs.soliditylang.org/en/v0.8.30/internals/optimizer.html#index-0)
* [constant-variable-declaration (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.constantVariableDeclaration)
* [**constructor**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-22), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-1)
 * [arguments](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-2)
* [constructor-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.constructorDefinition)
* [continue](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-1)
* [continue-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.continueStatement)
* [**contract**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-0), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/structure-of-a-contract.html#index-0)
 * [**abstract**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-25), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-23)
 * [**base**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-19)
 * [**creation**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-1)
 * [**interface**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-26)
 * [modular](https://docs.soliditylang.org/en/v0.8.30/solidity-by-example.html#index-3)
 * [**precompiled**](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-17)
* [contract creation](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-15)
* [**contract type**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-6)
* [contract verification](https://docs.soliditylang.org/en/v0.8.30/metadata.html#index-0)
* [contract-body-element (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.contractBodyElement)
* [contract-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.contractDefinition)
* contracts
 * [creating](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-3)
* [creationCode](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-11)
* [cryptography](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-8)
* [**custom storage layout**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-8)
* [custom type](https://docs.soliditylang.org/en/v0.8.30/types.html#index-14)
## D
* [data](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-3)
* [data-location (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.dataLocation)
* [**days**](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-2)
* [deactivate](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-16)
* [decimal-number (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer.DecimalNumber)
* [declarations](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-6)
* [default value](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-6)
* [delegatecall](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-27), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-13), [\[2\]](https://docs.soliditylang.org/en/v0.8.30/types.html#index-5), [\[3\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-9)
* [**delete**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-30)
* [**denomination**](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-0)
 * [**ether**](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-1)
 * [**time**](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-2)
* [**deriving**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-19)
* [difficulty](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-3)
* [**direct import**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-5)
* [dirty bits](https://docs.soliditylang.org/en/v0.8.30/ir-breaking-changes.html#index-3)
* [do-while-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.doWhileStatement)
* [do/while](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-1)
* [double-quoted-printable (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer.DoubleQuotedPrintable)
* [dynamic array](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-10)
## E
* [ecrecover](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-8)
* [elementary-type-name (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.elementaryTypeName)
* [else](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-1)
* [emit-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.emitStatement)
* [empty-string-literal (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer.EmptyStringLiteral)
* [encode](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-3)
* [encoding](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-4)
* [enum](https://docs.soliditylang.org/en/v0.8.30/structure-of-a-contract.html#index-0), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/types.html#index-13)
* [enum-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.enumDefinition)
* [**error**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-18), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#index-2)
* [error-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.errorDefinition)
* [error-parameter (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.errorParameter)
* [**errors**](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-8)
* [escape-sequence (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer.EscapeSequence)
* [escrow](https://docs.soliditylang.org/en/v0.8.30/solidity-by-example.html#index-2)
* [**ether**](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-1)
* [**ethereum virtual machine**](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-6)
* evaluation order
 * [**expression**](https://docs.soliditylang.org/en/v0.8.30/ir-breaking-changes.html#index-0)
 * [**function arguments**](https://docs.soliditylang.org/en/v0.8.30/ir-breaking-changes.html#index-1)
* [**event**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-16), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-2), [\[2\]](https://docs.soliditylang.org/en/v0.8.30/structure-of-a-contract.html#index-0)
 * [**anonymous**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-16)
 * [**indexed**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-16)
 * [**topic**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-16)
* [event-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.eventDefinition)
* [event-parameter (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.eventParameter)
* [**evm**](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-6)
* [**EVM version**](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#index-4)
* [**evmasm**](https://docs.soliditylang.org/en/v0.8.30/assembly.html#index-0), [**\[1\]**](https://docs.soliditylang.org/en/v0.8.30/yul.html#index-0)
* [**exception**](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-8)
* [expression (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.expression)
* [expression-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.expressionStatement)
* [external](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-10), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-3)
## F
* [**fallback function**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-14)
* [fallback-function-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.fallbackFunctionDefinition)
* [**false**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-2)
* [file://](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-10)
* [filesystem path](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-8)
* [**finney**](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-1)
* [**fixed**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-4)
* [**fixed point number**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-4)
* [fixed-bytes (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer.FixedBytes)
* [for](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-1)
* [for-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.forStatement)
* [function](https://docs.soliditylang.org/en/v0.8.30/structure-of-a-contract.html#index-0)
 * [**call**](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-2), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-12)
 * [external](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-2)
 * [fallback](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-14)
 * [**free**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-9), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-30)
 * [**getter**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-4)
 * [internal](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-2)
 * [**modifier**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-5), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/common-patterns.html#index-2), [\[2\]](https://docs.soliditylang.org/en/v0.8.30/common-patterns.html#index-4), [\[3\]](https://docs.soliditylang.org/en/v0.8.30/structure-of-a-contract.html#index-0)
 * [pure](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-12)
 * [receive](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-13)
 * [view](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-11)
* [function parameter](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-0)
* [function pointers](https://docs.soliditylang.org/en/v0.8.30/ir-breaking-changes.html#index-2)
* [**function type**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-15)
* [function-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.functionDefinition)
* [function-type-name (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.functionTypeName)
* [**functions**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-9)
## G
* [**gas**](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-9), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-3)
* [**gas price**](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-9), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-3)
* [gasleft](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-5)
* getter
 * [**function**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-4)
* [goto](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-1)
* [**gwei**](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-1)
## H
* [hex-number (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer.HexNumber)
* [hex-string (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer.HexString)
* [hex-string-literal (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.hexStringLiteral)
* [**Host Filesystem Loader**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-1)
* [**hours**](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-2)
## I
* [identifier (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer.Identifier), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.identifier)
* [identifier-path (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.identifierPath)
* [if](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-1)
* [if-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.ifStatement)
* [**import**](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-7)
 * [direct](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-5)
 * [**path**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-4), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-8)
 * [**relative**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-6)
 * [**remapping**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-9)
* [**import callback**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-1), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-8)
* [import-directive (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.importDirective)
* [**include paths**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-7), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#index-1)
* [indexed](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-11)
* [**inheritance**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-19)
 * [**multiple**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-24)
* [inheritance list](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-23)
* [inheritance-specifier (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.inheritanceSpecifier)
* inline
 * [**arrays**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-21)
* [inline-array-expression (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.inlineArrayExpression)
* [**installing**](https://docs.soliditylang.org/en/v0.8.30/installing-solidity.html#index-0)
* [**instruction**](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-11)
* [**int**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-3)
* [**integer**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-3), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/types.html#index-9)
* [**interface contract**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-26)
* [interface-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.interfaceDefinition)
* [internal](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-10), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-3)
* [**iterable mappings**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-27)
* [iulia](https://docs.soliditylang.org/en/v0.8.30/yul.html#index-0)
## J
* [julia](https://docs.soliditylang.org/en/v0.8.30/yul.html#index-0)
## K
* [keccak256](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-8)
## L
* [**layout at**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-8)
* [length](https://docs.soliditylang.org/en/v0.8.30/types.html#index-22)
* [**library**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-27), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-30), [\[2\]](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-13)
* [library-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.libraryDefinition)
* [**license**](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-0)
* [**linearization**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-24)
* [**linker**](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#index-2)
* literal
 * [**address**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-8), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/types.html#index-35)
 * [**array**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-21)
 * [**conversion**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-33)
 * [**hexadecimal**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-12), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/types.html#index-34)
 * [hexadecimal number](https://docs.soliditylang.org/en/v0.8.30/types.html#index-33)
 * [**in Yul**](https://docs.soliditylang.org/en/v0.8.30/yul.html#index-1)
 * [**rational**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-9), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/types.html#index-33)
 * [**string**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-10), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/types.html#index-34)
 * [**unicode**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-11)
* [literal (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.literal)
* [literal-with-sub-denomination (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.literalWithSubDenomination)
* [location](https://docs.soliditylang.org/en/v0.8.30/types.html#index-16)
* [log](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-14)
* [lvalue](https://docs.soliditylang.org/en/v0.8.30/types.html#index-29)
## M
* [**mapping**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-26), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/internals/layout_in_storage.html#index-0), [\[2\]](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-1)
* [mapping-key-type (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.mappingKeyType)
* [mapping-type (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.mappingType)
* [**memory**](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-10), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/types.html#index-16)
* [**message call**](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-12)
* [metadata](https://docs.soliditylang.org/en/v0.8.30/metadata.html#index-0)
* [**minutes**](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-2)
* [modifier-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.modifierDefinition)
* [modifier-invocation (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.modifierInvocation)
* [modifiers](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-11)
* [modular contract](https://docs.soliditylang.org/en/v0.8.30/solidity-by-example.html#index-3)
* [module](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-7)
* [msg](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-3)
 * [data](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-5)
 * [sender](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-5)
 * [sig](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-5)
 * [value](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-5)
* [mulmod](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-8)
## N
* [natspec](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-9)
* [**new**](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-3), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/types.html#index-20)
* [non-empty-string-literal (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer.NonEmptyStringLiteral)
* [number](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-3)
* [number-literal (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.numberLiteral)
## O
* [open auction](https://docs.soliditylang.org/en/v0.8.30/solidity-by-example.html#index-1)
* [**operator**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-28)
 * [**precedence**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-31), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-0)
 * [**user-defined**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-30)
* [optimiser](https://docs.soliditylang.org/en/v0.8.30/internals/optimizer.html#index-0)
* [optimizer](https://docs.soliditylang.org/en/v0.8.30/internals/optimizer.html#index-0)
* [origin](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-3)
* [**overload**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-15)
* [override-specifier (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.overrideSpecifier)
* overriding
 * [**function**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-20)
 * [**modifier**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-21)
## P
* [packed](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-4)
* [**parameter**](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-0)
 * [function](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-0)
 * [input](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-0)
 * [output](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-0)
* [parameter-list (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.parameterList)
* [path (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.path)
* [payable](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-11)
* [pop](https://docs.soliditylang.org/en/v0.8.30/types.html#index-22)
* [**pragma**](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-1)
 * [**abicoder**](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-3)
 * [**ABIEncoderV2**](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-5), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-3)
 * [**experimental**](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-4)
 * [**SMTChecker**](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-6)
 * [**version**](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-2)
* [pragma-token (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer.PragmaToken)
* [**precompiled contracts**](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-17)
* [**precompiles**](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-17)
* [prevrandao](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-3)
* [private](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-10), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-3)
* [public](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-10), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-3)
* [purchase](https://docs.soliditylang.org/en/v0.8.30/solidity-by-example.html#index-2)
* [pure](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-11)
* [**pure function**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-12)
* [push](https://docs.soliditylang.org/en/v0.8.30/types.html#index-22)
## R
* [rational number](https://docs.soliditylang.org/en/v0.8.30/types.html#index-9)
* [**receive**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-13)
* [**receive ether function**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-13)
* [receive-function-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.receiveFunctionDefinition)
* [**reference type**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-16)
* [**relative import**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-6)
* remapping
 * [**context**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-9)
 * [**import**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-9)
 * [**prefix**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-9)
 * [**target**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-9), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-8)
* [Remix IDE](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-8), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-10)
* [remote purchase](https://docs.soliditylang.org/en/v0.8.30/solidity-by-example.html#index-2)
* [**require**](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-8), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-6), [\[2\]](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-18), [\[3\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-7)
* [return](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-0), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-1)
* [return array](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-10)
* [return string](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-10)
* [return struct](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-10)
* [return variable](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-0)
* [return-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.returnStatement)
* [**revert**](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-8), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-6), [\[2\]](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-18), [\[3\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-7)
* [revert-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.revertStatement)
* [ripemd160](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-8)
* [runtimeCode](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-11)
## S
* [**safe math**](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-7)
* [safemath](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-7)
* [**scoping**](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-6)
* [**seconds**](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-2)
* selector
 * [**of a function**](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#index-1), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/assembly.html#index-1)
 * [**of a library function**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-29)
 * [**of an error**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-18), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#index-2)
 * [**of an event**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-17)
* [**selfdestruct**](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-16), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-8), [\[2\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-10)
* [send](https://docs.soliditylang.org/en/v0.8.30/types.html#index-5), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-9)
* [sender](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-3)
* [set](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-28)
* [sha256](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-7), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-8)
* [signed-integer-type (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer.SignedIntegerType)
* [single-quoted-printable (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer.SingleQuotedPrintable)
* [**solc**](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#index-0)
* [SolidityLexer (Antlr4 lexer grammar)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer)
* [SolidityParser (Antlr4 parser grammar)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser)
* [source file](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-7)
* [source mappings](https://docs.soliditylang.org/en/v0.8.30/internals/source_mappings.html#index-0)
* [source unit](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-7)
* [**source unit name**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-0), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-8)
* [source-unit (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.sourceUnit)
* [spdx](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-0)
* [**stack**](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-10)
* [standard input](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-3)
* [**standard JSON**](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#index-5), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-2)
* [state machine](https://docs.soliditylang.org/en/v0.8.30/common-patterns.html#index-3)
* [state variable](https://docs.soliditylang.org/en/v0.8.30/internals/layout_in_storage.html#index-0), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/structure-of-a-contract.html#index-0)
* [state-mutability (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.stateMutability)
* [state-variable-declaration (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.stateVariableDeclaration)
* [statement (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.statement)
* [staticcall](https://docs.soliditylang.org/en/v0.8.30/types.html#index-5), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-9)
* [stdin](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-3)
* [**storage**](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-10), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/internals/layout_in_storage.html#index-0), [\[2\]](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-7), [\[3\]](https://docs.soliditylang.org/en/v0.8.30/types.html#index-16)
* [**storage layout specifier**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-8)
* [**string**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-18), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-10), [\[2\]](https://docs.soliditylang.org/en/v0.8.30/types.html#index-10)
 * [concat](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-2)
* [string members](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-6)
* [**string-concat**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-19)
* [string-literal (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.stringLiteral)
* [**struct**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-25), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-10), [\[2\]](https://docs.soliditylang.org/en/v0.8.30/structure-of-a-contract.html#index-0), [\[3\]](https://docs.soliditylang.org/en/v0.8.30/types.html#index-16)
* [struct-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.structDefinition)
* [struct-member (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.structMember)
* [style](https://docs.soliditylang.org/en/v0.8.30/style-guide.html#index-0)
* [sub-denomination (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer.SubDenomination)
* [**subcurrency**](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-0)
* [super](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-8), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-10)
* [switch](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-1)
* [symbol-aliases (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.symbolAliases)
* [**szabo**](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-1)
## T
* [this](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-8), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-10)
* [**throw**](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-8)
* [timestamp](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-3)
* [tload](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-6)
* [**transaction**](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-8), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-4)
* [transfer](https://docs.soliditylang.org/en/v0.8.30/types.html#index-5), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-9)
* [**transient**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-6)
* [**transient storage**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-6), [**\[1\]**](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#index-10), [\[2\]](https://docs.soliditylang.org/en/v0.8.30/internals/layout_in_storage.html#index-0)
* [**true**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-2)
* [try-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.tryStatement)
* [tstore](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-6)
* [tuple-expression (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.tupleExpression)
* tx
 * [gasprice](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-5)
 * [origin](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-5)
* [type](https://docs.soliditylang.org/en/v0.8.30/types.html#index-0), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-11)
 * [**contract**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-6)
 * [**conversion**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-32)
 * [creationCode](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-9)
 * [**function**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-15)
 * [interfaceId](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-9)
 * [max](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-9)
 * [min](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-9)
 * [name](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-9)
 * [**reference**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-16)
 * [runtimeCode](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-9)
 * [**struct**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-25)
 * [**value**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-1)
* [type-name (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.typeName)
## U
* [**ufixed**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-4)
* [**uint**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-3)
* [unchecked](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-7)
* [unchecked-block (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.uncheckedBlock)
* [unicode-string-literal (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer.UnicodeStringLiteral), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.unicodeStringLiteral)
* [unsigned-integer-type (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer.UnsignedIntegerType)
* [**UnusedStoreEliminator**](https://docs.soliditylang.org/en/v0.8.30/internals/optimizer.html#index-1)
* [**user defined value type**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-14)
* [user-definable-operator (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.userDefinableOperator)
* [user-defined-value-type-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.userDefinedValueTypeDefinition)
* [**using for**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-30), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-28)
* [using-aliases (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.usingAliases)
* [using-directive (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.usingDirective)
## V
* [value](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-3)
* [**value type**](https://docs.soliditylang.org/en/v0.8.30/types.html#index-1)
* variable
 * [return](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-0)
* [variable-declaration (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.variableDeclaration)
* [variable-declaration-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.variableDeclarationStatement)
* [variable-declaration-tuple (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.variableDeclarationTuple)
* [variably sized array](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-10)
* [**VFS**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-0)
* [view](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-11)
* [**view function**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-11)
* [**virtual filesystem**](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#index-0), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#index-8)
* [**visibility**](https://docs.soliditylang.org/en/v0.8.30/contracts.html#index-3), [\[1\]](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#index-10)
 * [(Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.visibility)
* [voting](https://docs.soliditylang.org/en/v0.8.30/solidity-by-example.html#index-0)
## W
* [**weeks**](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-2)
* [**wei**](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-1)
* [while](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#index-1)
* [while-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.whileStatement)
* [withdrawal](https://docs.soliditylang.org/en/v0.8.30/common-patterns.html#index-0)
## Y
* [**years**](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#index-2)
* [**yul**](https://docs.soliditylang.org/en/v0.8.30/yul.html#index-0)
* [yul-assignment (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.yulAssignment)
* [yul-block (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.yulBlock)
* [yul-boolean (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.yulBoolean)
* [yul-decimal-number (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer.YulDecimalNumber)
* [yul-evm-builtin (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer.YulEVMBuiltin)
* [yul-expression (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.yulExpression)
* [yul-for-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.yulForStatement)
* [yul-function-call (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.yulFunctionCall)
* [yul-function-definition (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.yulFunctionDefinition)
* [yul-hex-number (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer.YulHexNumber)
* [yul-identifier (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer.YulIdentifier)
* [yul-if-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.yulIfStatement)
* [yul-literal (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.yulLiteral)
* [yul-path (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.yulPath)
* [yul-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.yulStatement)
* [yul-string-literal (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityLexer.YulStringLiteral)
* [yul-switch-statement (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.yulSwitchStatement)
* [yul-variable-declaration (Antlr4 production rule)](https://docs.soliditylang.org/en/v0.8.30/grammar.html#a4.SolidityParser.yulVariableDeclaration)

# [Using the Compiler — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/using-the-compiler.html) 
 _https://docs.soliditylang.org/en/latest/using-the-compiler.html_

## Using the Commandline Compiler[](#using-the-commandline-compiler "Link to this heading")
Note
This section does not apply to [solcjs](https://docs.soliditylang.org/en/latest/installing-solidity.html#solcjs), not even if it is used in commandline mode.
### Basic Usage[](#basic-usage "Link to this heading")
One of the build targets of the Solidity repository is `solc`, the Solidity commandline compiler. Using `solc --help` provides you with an explanation of all options. The compiler can produce various outputs, ranging from simple binaries and assembly over an abstract syntax tree (parse tree) to estimations of gas usage. If you only want to compile a single file, you run it as `solc --bin sourceFile.sol` and it will print the binary. If you want to get some of the more advanced output variants of `solc`, it is probably better to tell it to output everything to separate files using `solc -o outputDirectory --bin --ast-compact-json --asm sourceFile.sol`.
### Optimizer Options[](#optimizer-options "Link to this heading")
Before you deploy your contract, activate the optimizer when compiling using `solc --optimize --bin sourceFile.sol`. By default, the optimizer will optimize the contract assuming it is called 200 times across its lifetime (more specifically, it assumes each opcode is executed around 200 times). If you want the initial contract deployment to be cheaper and the later function executions to be more expensive, set it to `--optimize-runs=1`. If you expect many transactions and do not care for higher deployment cost and output size, set `--optimize-runs` to a high number. This parameter has effects on the following (this might change in the future):
* the size of the binary search in the function dispatch routine
 
* the way constants like large numbers or strings are stored
 
### Base Path and Import Remapping[](#base-path-and-import-remapping "Link to this heading")
The commandline compiler will automatically read imported files from the filesystem, but it is also possible to provide [path redirects](https://docs.soliditylang.org/en/latest/path-resolution.html#import-remapping) using `prefix=path` in the following way:
solc github.com/ethereum/dapp-bin/\=/usr/local/lib/dapp-bin/ file.sol
This essentially instructs the compiler to search for anything starting with `github.com/ethereum/dapp-bin/` under `/usr/local/lib/dapp-bin`.
When accessing the filesystem to search for imports, [paths that do not start with ./ or ../](https://docs.soliditylang.org/en/latest/path-resolution.html#direct-imports) are treated as relative to the directories specified using `--base-path` and `--include-path` options (or the current working directory if base path is not specified). Furthermore, the part of the path added via these options will not appear in the contract metadata.
For security reasons the compiler has [restrictions on what directories it can access](https://docs.soliditylang.org/en/latest/path-resolution.html#allowed-paths). Directories of source files specified on the command-line and target paths of remappings are automatically allowed to be accessed by the file reader, but everything else is rejected by default. Additional paths (and their subdirectories) can be allowed via the `--allow-paths /sample/path,/another/sample/path` switch. Everything inside the path specified via `--base-path` is always allowed.
The above is only a simplification of how the compiler handles import paths. For a detailed explanation with examples and discussion of corner cases please refer to the section on [path resolution](https://docs.soliditylang.org/en/latest/path-resolution.html#path-resolution).
### Library Linking[](#library-linking "Link to this heading")
If your contracts use [libraries](https://docs.soliditylang.org/en/latest/contracts.html#libraries), you will notice that the bytecode contains substrings of the form `__$53aea86b7d70b31448b230b20ae141a537$__` [(format was different <v0.5.0)](https://docs.soliditylang.org/en/v0.4.26/contracts.html#libraries). These are placeholders for the actual library addresses. The placeholder is a 34 character prefix of the hex encoding of the keccak256 hash of the fully qualified library name. The bytecode file will also contain lines of the form `// <placeholder> -> <fq library name>` at the end to help identify which libraries the placeholders represent. Note that the fully qualified library name is the path of its source file and the library name separated by `:`. You can use `solc` as a linker meaning that it will insert the library addresses for you at those points:
Either add `--libraries "file.sol:Math=0x1234567890123456789012345678901234567890 file.sol:Heap=0xabCD567890123456789012345678901234567890"` to your command to provide an address for each library (use commas or spaces as separators) or store the string in a file (one library per line) and run `solc` using `--libraries fileName`.
Note
Starting Solidity 0.8.1 accepts `=` as separator between library and address, and `:` as a separator is deprecated. It will be removed in the future. Currently `--libraries "file.sol:Math:0x1234567890123456789012345678901234567890 file.sol:Heap:0xabCD567890123456789012345678901234567890"` will work too.
If `solc` is called with the option `--standard-json`, it will expect a JSON input (as explained below) on the standard input, and return a JSON output on the standard output. This is the recommended interface for more complex and especially automated uses. The process will always terminate in a “success” state and report any errors via the JSON output. The option `--base-path` is also processed in standard-json mode.
If `solc` is called with the option `--link`, all input files are interpreted to be unlinked binaries (hex-encoded) in the `__$53aea86b7d70b31448b230b20ae141a537$__`\-format given above and are linked in-place (if the input is read from stdin, it is written to stdout). All options except `--libraries` are ignored (including `-o`) in this case.
Warning
Manually linking libraries on the generated bytecode is discouraged because it does not update contract metadata. Since metadata contains a list of libraries specified at the time of compilation and bytecode contains a metadata hash, you will get different binaries, depending on when linking is performed.
You should ask the compiler to link the libraries at the time a contract is compiled by either using the `--libraries` option of `solc` or the `libraries` key if you use the standard-JSON interface to the compiler.
Note
The library placeholder used to be the fully qualified name of the library itself instead of the hash of it. This format is still supported by `solc --link` but the compiler will no longer output it. This change was made to reduce the likelihood of a collision between libraries, since only the first 36 characters of the fully qualified library name could be used.
## Setting the EVM Version to Target[](#setting-the-evm-version-to-target "Link to this heading")
When you compile your contract code you can specify the Ethereum virtual machine version to compile for to avoid particular features or behaviors.
Warning
Compiling for the wrong EVM version can result in wrong, strange and failing behavior. Please ensure, especially if running a private chain, that you use matching EVM versions.
On the command-line, you can select the EVM version as follows:
solc \--evm-version <VERSION> contract.sol
In the [standard JSON interface](#compiler-api), use the `"evmVersion"` key in the `"settings"` field:
{
 "sources": {/\* ... \*/},
 "settings": {
 "optimizer": {/\* ... \*/},
 "evmVersion": "<VERSION>"
 }
}
### Target Options[](#target-options "Link to this heading")
Below is a list of target EVM versions and the compiler-relevant changes introduced at each version. Backward compatibility is not guaranteed between each version.
* `homestead` (_support deprecated_)
 
 * (oldest version)
 
 
* `tangerineWhistle` (_support deprecated_)
 
 * Gas cost for access to other accounts increased, relevant for gas estimation and the optimizer.
 
 * All gas sent by default for external calls, previously a certain amount had to be retained.
 
 
* `spuriousDragon` (_support deprecated_)
 
 * Gas cost for the `exp` opcode increased, relevant for gas estimation and the optimizer.
 
 
* `byzantium` (_support deprecated_)
 
 * Opcodes `returndatacopy`, `returndatasize` and `staticcall` are available in assembly.
 
 * The `staticcall` opcode is used when calling non-library view or pure functions, which prevents the functions from modifying state at the EVM level, i.e., even applies when you use invalid type conversions.
 
 * It is possible to access dynamic data returned from function calls.
 
 * `revert` opcode introduced, which means that `revert()` will not waste gas.
 
 
* `constantinople`
 
 * Opcodes `create2`, `extcodehash`, `shl`, `shr` and `sar` are available in assembly.
 
 * Shifting operators use shifting opcodes and thus need less gas.
 
 
* `petersburg`
 
 * The compiler behaves the same way as with constantinople.
 
 
* `istanbul`
 
 * Opcodes `chainid` and `selfbalance` are available in assembly.
 
 
* `berlin`
 
 * Gas costs for `SLOAD`, `*CALL`, `BALANCE`, `EXT*` and `SELFDESTRUCT` increased. The compiler assumes cold gas costs for such operations. This is relevant for gas estimation and the optimizer.
 
 
* `london`
 
 * The block’s base fee ([EIP-3198](https://eips.ethereum.org/EIPS/eip-3198) and [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559)) can be accessed via the global `block.basefee` or `basefee()` in inline assembly.
 
 
* `paris`
 
 * Introduces `prevrandao()` and `block.prevrandao`, and changes the semantics of the now deprecated `block.difficulty`, disallowing `difficulty()` in inline assembly (see [EIP-4399](https://eips.ethereum.org/EIPS/eip-4399)).
 
 
* `shanghai`
 
 * Smaller code size and gas savings due to the introduction of `push0` (see [EIP-3855](https://eips.ethereum.org/EIPS/eip-3855)).
 
 
* `cancun`
 
 * The block’s blob base fee ([EIP-7516](https://eips.ethereum.org/EIPS/eip-7516) and [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844)) can be accessed via the global `block.blobbasefee` or `blobbasefee()` in inline assembly.
 
 * Introduces `blobhash()` in inline assembly and a corresponding global function to retrieve versioned hashes of blobs associated with the transaction (see [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844)).
 
 * Opcode `mcopy` is available in assembly (see [EIP-5656](https://eips.ethereum.org/EIPS/eip-5656)).
 
 * Opcodes `tstore` and `tload` are available in assembly (see [EIP-1153](https://eips.ethereum.org/EIPS/eip-1153)).
 
 
* `prague` (**default**)
 
* `osaka` (**experimental**)
 
 * Experimental compilation to EOF is available starting from this version. ([EIP-7692](https://eips.ethereum.org/EIPS/eip-7692))
 
 
## Compiler Input and Output JSON Description[](#compiler-input-and-output-json-description "Link to this heading")
The recommended way to interface with the Solidity compiler especially for more complex and automated setups is the so-called JSON-input-output interface. The same interface is provided by all distributions of the compiler.
The fields are generally subject to change, some are optional (as noted), but we try to only make backwards compatible changes.
The compiler API expects a JSON formatted input and outputs the compilation result in a JSON formatted output. The standard error output is not used and the process will always terminate in a “success” state, even if there were errors. Errors are always reported as part of the JSON output.
The following subsections describe the format through an example. Comments are of course not permitted and used here only for explanatory purposes.
### Input Description[](#input-description "Link to this heading")
{
 // Required: Source code language. Currently supported are "Solidity", "Yul", "SolidityAST" (experimental), "EVMAssembly" (experimental).
 "language": "Solidity",
 // Required
 "sources":
 {
 // The keys here are the "global" names of the source files,
 // imports can use other files via remappings (see below).
 "myFile.sol":
 {
 // Optional: keccak256 hash of the source file
 // It is used to verify the retrieved content if imported via URLs.
 "keccak256": "0x123...",
 // Required (unless "content" is used, see below): URL(s) to the source file.
 // URL(s) should be imported in this order and the result checked against the
 // keccak256 hash (if available). If the hash doesn't match or none of the
 // URL(s) result in success, an error should be raised.
 // Using the commandline interface only filesystem paths are supported.
 // With the JavaScript interface the URL will be passed to the user-supplied
 // read callback, so any URL supported by the callback can be used.
 "urls":
 \[
 "bzzr://56ab...",
 "ipfs://Qma...",
 "/tmp/path/to/file.sol"
 // If files are used, their directories should be added to the command-line via
 // \`--allow-paths <path>\`.
 \]
 },
 "settable":
 {
 // Optional: keccak256 hash of the source file
 "keccak256": "0x234...",
 // Required (unless "urls" is used): literal contents of the source file
 "content": "contract settable is owned { uint256 private x = 0; function set(uint256 \_x) public { if (msg.sender == owner) x = \_x; } }"
 },
 "myFile.sol\_json.ast":
 {
 // If language is set to "SolidityAST", an AST needs to be supplied under the "ast" key
 // and there can be only one source file present.
 // The format is the same as used by the \`ast\` output.
 // Note that importing ASTs is experimental and in particular that:
 // - importing invalid ASTs can produce undefined results and
 // - no proper error reporting is available on invalid ASTs.
 // Furthermore, note that the AST import only consumes the fields of the AST as
 // produced by the compiler in "stopAfter": "parsing" mode and then re-performs
 // analysis, so any analysis-based annotations of the AST are ignored upon import.
 "ast": { ... }
 },
 "myFile\_evm.json":
 {
 // If language is set to "EVMAssembly", an EVM Assembly JSON object needs to be supplied
 // under the "assemblyJson" key and there can be only one source file present.
 // The format is the same as used by the \`evm.legacyAssembly\` output or \`--asm-json\`
 // output on the command line.
 // Note that importing EVM assembly is experimental.
 "assemblyJson":
 {
 ".code": \[ ... \],
 ".data": { ... }, // optional
 "sourceList": \[ ... \] // optional (if no \`source\` node was defined in any \`.code\` object)
 }
 }
 },
 // Optional
 "settings":
 {
 // Optional: Stop compilation after the given stage. Currently only "parsing" is valid here
 "stopAfter": "parsing",
 // Optional: List of remappings
 "remappings": \[ ":g=/dir" \],
 // Optional: Optimizer settings
 "optimizer": {
 // Turn on the optimizer. Optional. Default: false.
 // NOTE: The state of the optimizer is fully determined by the 'details' dict and this setting
 // only affects its defaults - when enabled, all components default to being enabled.
 // The opposite is not true - there are several components that always default to being
 // enabled an can only be explicitly disabled via 'details'.
 // WARNING: Before version 0.8.6 omitting this setting was not equivalent to setting
 // it to false and would result in all components being disabled instead.
 // WARNING: Enabling optimizations for EVMAssembly input is allowed but not necessary under normal
 // circumstances. It forces the opcode-based optimizer to run again and can produce bytecode that
 // is not reproducible from metadata.
 "enabled": true,
 // Optimize for how many times you intend to run the code. Optional. Default: 200.
 // Lower values will optimize more for initial deployment cost, higher
 // values will optimize more for high-frequency usage.
 "runs": 200,
 // State of all optimizer components. Optional.
 // Default values are determined by whether the optimizer is enabled or not.
 // Note that the 'enabled' setting only affects the defaults here and has no effect when
 // all values are provided explicitly.
 "details": {
 // Peephole optimizer (opcode-based). Optional. Default: true.
 // Default for EVMAssembly input: false when optimization is not enabled.
 // NOTE: Always runs (even with optimization disabled) except for EVMAssembly input or when explicitly turned off here.
 "peephole": true,
 // Inliner (opcode-based). Optional. Default: true when optimization is enabled.
 "inliner": false,
 // Unused JUMPDEST remover (opcode-based). Optional. Default: true.
 // Default for EVMAssembly input: false when optimization is not enabled.
 // NOTE: Always runs (even with optimization disabled) except for EVMAssembly input or when explicitly turned off here.
 "jumpdestRemover": true,
 // Literal reordering (codegen-based). Optional. Default: true when optimization is enabled.
 // Moves literals to the right of commutative binary operators during code generation, helping exploit associativity.
 "orderLiterals": false,
 // Block deduplicator (opcode-based). Optional. Default: true when optimization is enabled.
 // Unifies assembly code blocks that share content.
 "deduplicate": false,
 // Common subexpression elimination (opcode-based). Optional. Default: true when optimization is enabled.
 // This is the most complicated step but can also provide the largest gain.
 "cse": false,
 // Constant optimizer (opcode-based). Optional. Default: true when optimization is enabled.
 // Tries to find better representations of literal numbers and strings, that satisfy the
 // size/cost trade-off determined by the 'runs' setting.
 "constantOptimizer": false,
 // Unchecked loop increment (codegen-based). Optional. Default: true.
 // Use unchecked arithmetic when incrementing the counter of 'for' loops under certain circumstances.
 // NOTE: Always runs (even with optimization disabled) unless explicitly turned off here.
 "simpleCounterForLoopUncheckedIncrement": true,
 // Yul optimizer. Optional. Default: true when optimization is enabled.
 // Used to optimize the IR produced by the Yul IR-based pipeline as well as inline assembly
 // and utility Yul code generated by the compiler.
 // NOTE: Before Solidity 0.6.0 the default was false.
 "yul": false,
 // Tuning options for the Yul optimizer. Optional.
 "yulDetails": {
 // Improve allocation of stack slots for variables, can free up stack slots early.
 // Optional. Default: true if Yul optimizer is enabled.
 "stackAllocation": true,
 // Optimization step sequence.
 // The general form of the value is "<main sequence>:<cleanup sequence>".
 // The setting is optional and when omitted, default values are used for both sequences.
 // If the value does not contain the ':' delimiter, it is interpreted as the main
 // sequence and the default is used for the cleanup sequence.
 // To make one of the sequences empty, the delimiter must be present at the first or last position.
 // In particular if the whole value consists only of the delimiter, both sequences are empty.
 // Note that there are several hard-coded steps that always run, even when both sequences are empty.
 // For more information see "The Optimizer > Selecting Optimizations".
 "optimizerSteps": "dhfoDgvulfnTUtnIf..."
 }
 }
 },
 // Version of the EVM to compile for (optional).
 // Affects type checking and code generation. Can be homestead,
 // tangerineWhistle, spuriousDragon, byzantium, constantinople,
 // petersburg, istanbul, berlin, london, paris, shanghai, cancun, prague (default) or osaka (experimental).
 "evmVersion": "prague",
 // EVM Object Format version to compile for (optional, experimental).
 // Currently the only valid value is 1. If not specified, legacy non-EOF bytecode will be generated.
 "eofVersion": null,
 // Optional: Change compilation pipeline to go through the Yul intermediate representation.
 // This is false by default.
 "viaIR": true,
 // Optional: Debugging settings
 "debug": {
 // How to treat revert (and require) reason strings. Settings are
 // "default", "strip", "debug" and "verboseDebug".
 // "default" does not inject compiler-generated revert strings and keeps user-supplied ones.
 // "strip" removes all revert strings (if possible, i.e. if literals are used) keeping side-effects
 // "debug" injects strings for compiler-generated internal reverts, implemented for ABI encoders V1 and V2 for now.
 // "verboseDebug" even appends further information to user-supplied revert strings (not yet implemented)
 "revertStrings": "default",
 // Optional: How much extra debug information to include in comments in the produced EVM
 // assembly and Yul code. Available components are:
 // - \`location\`: Annotations of the form \`@src <index>:<start>:<end>\` indicating the
 // location of the corresponding element in the original Solidity file, where:
 // - \`<index>\` is the file index matching the \`@use-src\` annotation,
 // - \`<start>\` is the index of the first byte at that location,
 // - \`<end>\` is the index of the first byte after that location.
 // - \`snippet\`: A single-line code snippet from the location indicated by \`@src\`.
 // The snippet is quoted and follows the corresponding \`@src\` annotation.
 // - \`\*\`: Wildcard value that can be used to request everything.
 "debugInfo": \["location", "snippet"\]
 },
 // Metadata settings (optional)
 "metadata": {
 // The CBOR metadata is appended at the end of the bytecode by default.
 // Setting this to false omits the metadata from the runtime and deploy time code.
 "appendCBOR": true,
 // Use only literal content and not URLs (false by default)
 "useLiteralContent": true,
 // Use the given hash method for the metadata hash that is appended to the bytecode.
 // The metadata hash can be removed from the bytecode via option "none".
 // The other options are "ipfs" and "bzzr1".
 // If the option is omitted, "ipfs" is used by default.
 "bytecodeHash": "ipfs"
 },
 // Addresses of the libraries. If not all libraries are given here,
 // it can result in unlinked objects whose output data is different.
 "libraries": {
 // The top level key is the name of the source file where the library is used.
 // If remappings are used, this source file should match the global path
 // after remappings were applied.
 // If this key is an empty string, that refers to a global level.
 "myFile.sol": {
 "MyLib": "0x123123..."
 }
 },
 // The following can be used to select desired outputs based
 // on file and contract names.
 // If this field is omitted, then the compiler loads and does type checking,
 // but will not generate any outputs apart from errors.
 // The first level key is the file name and the second level key is the contract name.
 // An empty contract name is used for outputs that are not tied to a contract
 // but to the whole source file like the AST.
 // A star as contract name refers to all contracts in the file.
 // Similarly, a star as a file name matches all files.
 // To select all outputs the compiler can possibly generate, with the exclusion of
 // Yul intermediate representation outputs, use
 // "outputSelection: { "\*": { "\*": \[ "\*" \], "": \[ "\*" \] } }"
 // but note that this might slow down the compilation process needlessly.
 //
 // The available output types are as follows:
 //
 // File level (needs empty string as contract name):
 // ast - AST of all source files
 //
 // Contract level (needs the contract name or "\*"):
 // abi - ABI
 // devdoc - Developer documentation (natspec)
 // userdoc - User documentation (natspec)
 // metadata - Metadata
 // ir - Yul intermediate representation of the code before optimization
 // irAst - AST of Yul intermediate representation of the code before optimization
 // irOptimized - Intermediate representation after optimization
 // irOptimizedAst - AST of intermediate representation after optimization
 // storageLayout - Slots, offsets and types of the contract's state variables in storage.
 // transientStorageLayout - Slots, offsets and types of the contract's state variables in transient storage.
 // evm.assembly - New assembly format
 // evm.legacyAssembly - Old-style assembly format in JSON
 // evm.bytecode.functionDebugData - Debugging information at function level
 // evm.bytecode.object - Bytecode object
 // evm.bytecode.opcodes - Opcodes list
 // evm.bytecode.sourceMap - Source mapping (useful for debugging)
 // evm.bytecode.linkReferences - Link references (if unlinked object)
 // evm.bytecode.generatedSources - Sources generated by the compiler
 // evm.deployedBytecode\* - Deployed bytecode (has all the options that evm.bytecode has)
 // evm.deployedBytecode.immutableReferences - Map from AST ids to bytecode ranges that reference immutables
 // evm.methodIdentifiers - The list of function hashes
 // evm.gasEstimates - Function gas estimates
 //
 // Note that using \`evm\`, \`evm.bytecode\`, etc. will select every
 // target part of that output. Additionally, \`\*\` can be used as a wildcard to request everything.
 //
 "outputSelection": {
 "\*": {
 "\*": \[
 "metadata", "evm.bytecode" // Enable the metadata and bytecode outputs of every single contract.
 , "evm.bytecode.sourceMap" // Enable the source map output of every single contract.
 \],
 "": \[
 "ast" // Enable the AST output of every single file.
 \]
 },
 // Enable the abi and opcodes output of MyContract defined in file def.
 "def": {
 "MyContract": \[ "abi", "evm.bytecode.opcodes" \]
 }
 },
 // The modelChecker object is experimental and subject to changes.
 "modelChecker":
 {
 // Chose which contracts should be analyzed as the deployed one.
 "contracts":
 {
 "source1.sol": \["contract1"\],
 "source2.sol": \["contract2", "contract3"\]
 },
 // Choose how division and modulo operations should be encoded.
 // When using \`false\` they are replaced by multiplication with slack
 // variables. This is the default.
 // Using \`true\` here is recommended if you are using the CHC engine
 // and not using Spacer as the Horn solver (using Eldarica, for example).
 // See the Formal Verification section for a more detailed explanation of this option.
 "divModNoSlacks": false,
 // Choose which model checker engine to use: all (default), bmc, chc, none.
 "engine": "chc",
 // Choose whether external calls should be considered trusted in case the
 // code of the called function is available at compile-time.
 // For details see the SMTChecker section.
 "extCalls": "trusted",
 // Choose which types of invariants should be reported to the user: contract, reentrancy.
 "invariants": \["contract", "reentrancy"\],
 // Choose whether to output all proved targets. The default is \`false\`.
 "showProvedSafe": true,
 // Choose whether to output all unproved targets. The default is \`false\`.
 "showUnproved": true,
 // Choose whether to output all unsupported language features. The default is \`false\`.
 "showUnsupported": true,
 // Choose which solvers should be used, if available.
 // See the Formal Verification section for the solvers description.
 "solvers": \["cvc5", "smtlib2", "z3"\],
 // Choose which targets should be checked: constantCondition,
 // underflow, overflow, divByZero, balance, assert, popEmptyArray, outOfBounds.
 // If the option is not given all targets are checked by default,
 // except underflow/overflow for Solidity >=0.8.7.
 // See the Formal Verification section for the targets description.
 "targets": \["underflow", "overflow", "assert"\],
 // Timeout for each SMT query in milliseconds.
 // If this option is not given, the SMTChecker will use a deterministic
 // resource limit by default.
 // A given timeout of 0 means no resource/time restrictions for any query.
 "timeout": 20000
 }
 }
}
### Output Description[](#output-description "Link to this heading")
{
 // Optional: not present if no errors/warnings/infos were encountered
 "errors": \[
 {
 // Optional: Location within the source file.
 "sourceLocation": {
 "file": "sourceFile.sol",
 "start": 0,
 "end": 100
 },
 // Optional: Further locations (e.g. places of conflicting declarations)
 "secondarySourceLocations": \[
 {
 "file": "sourceFile.sol",
 "start": 64,
 "end": 92,
 "message": "Other declaration is here:"
 }
 \],
 // Mandatory: Error type, such as "TypeError", "InternalCompilerError", "Exception", etc.
 // See below for complete list of types.
 "type": "TypeError",
 // Mandatory: Component where the error originated, such as "general" etc.
 "component": "general",
 // Mandatory ("error", "warning" or "info", but please note that this may be extended in the future)
 "severity": "error",
 // Optional: unique code for the cause of the error
 "errorCode": "3141",
 // Mandatory
 "message": "Invalid keyword",
 // Optional: the message formatted with source location
 "formattedMessage": "sourceFile.sol:100: Invalid keyword"
 }
 \],
 // This contains the file-level outputs.
 // It can be limited/filtered by the outputSelection settings.
 "sources": {
 "sourceFile.sol": {
 // Identifier of the source (used in source maps)
 "id": 1,
 // The AST object
 "ast": {}
 }
 },
 // This contains the contract-level outputs.
 // It can be limited/filtered by the outputSelection settings.
 "contracts": {
 "sourceFile.sol": {
 // If the language used has no contract names, this field should equal to an empty string.
 "ContractName": {
 // The Ethereum Contract ABI. If empty, it is represented as an empty array.
 // See https://docs.soliditylang.org/en/develop/abi-spec.html
 "abi": \[\],
 // See the Metadata Output documentation (serialised JSON string)
 "metadata": "{/\* ... \*/}",
 // User documentation (natspec)
 "userdoc": {},
 // Developer documentation (natspec)
 "devdoc": {},
 // Intermediate representation before optimization (string)
 "ir": "",
 // AST of intermediate representation before optimization
 "irAst": {/\* ... \*/},
 // Intermediate representation after optimization (string)
 "irOptimized": "",
 // AST of intermediate representation after optimization
 "irOptimizedAst": {/\* ... \*/},
 // See the Storage Layout documentation.
 "storageLayout": {"storage": \[/\* ... \*/\], "types": {/\* ... \*/} },
 // See the Storage Layout documentation.
 "transientStorageLayout": {"storage": \[/\* ... \*/\], "types": {/\* ... \*/} },
 // EVM-related outputs
 "evm": {
 // Assembly (string)
 "assembly": "",
 // Old-style assembly (object)
 "legacyAssembly": {},
 // Bytecode and related details.
 "bytecode": {
 // Debugging data at the level of functions.
 "functionDebugData": {
 // Now follows a set of functions including compiler-internal and
 // user-defined function. The set does not have to be complete.
 "@mint\_13": { // Internal name of the function
 "entryPoint": 128, // Byte offset into the bytecode where the function starts (optional)
 "id": 13, // AST ID of the function definition or null for compiler-internal functions (optional)
 "parameterSlots": 2, // Number of EVM stack slots for the function parameters (optional)
 "returnSlots": 1 // Number of EVM stack slots for the return values (optional)
 }
 },
 // The bytecode as a hex string.
 "object": "00fe",
 // Opcodes list (string)
 "opcodes": "",
 // The source mapping as a string. See the source mapping definition.
 "sourceMap": "",
 // Array of sources generated by the compiler. Currently only
 // contains a single Yul file.
 "generatedSources": \[{
 // Yul AST
 "ast": {/\* ... \*/},
 // Source file in its text form (may contain comments)
 "contents":"{ function abi\_decode(start, end) -> data { data := calldataload(start) } }",
 // Source file ID, used for source references, same "namespace" as the Solidity source files
 "id": 2,
 "language": "Yul",
 "name": "#utility.yul"
 }\],
 // If given, this is an unlinked object.
 "linkReferences": {
 "libraryFile.sol": {
 // Byte offsets into the bytecode.
 // Linking replaces the 20 bytes located there.
 "Library1": \[
 { "start": 0, "length": 20 },
 { "start": 200, "length": 20 }
 \]
 }
 }
 },
 "deployedBytecode": {
 /\* ..., \*/ // The same layout as above.
 "immutableReferences": {
 // There are two references to the immutable with AST ID 3, both 32 bytes long. One is
 // at bytecode offset 42, the other at bytecode offset 80.
 "3": \[{ "start": 42, "length": 32 }, { "start": 80, "length": 32 }\]
 }
 },
 // The list of function hashes
 "methodIdentifiers": {
 "delegate(address)": "5c19a95c"
 },
 // Function gas estimates
 "gasEstimates": {
 "creation": {
 "codeDepositCost": "420000",
 "executionCost": "infinite",
 "totalCost": "infinite"
 },
 "external": {
 "delegate(address)": "25000"
 },
 "internal": {
 "heavyLifting()": "infinite"
 }
 }
 }
 }
 }
 }
}
#### Error Types[](#error-types "Link to this heading")
1. `JSONError`: JSON input doesn’t conform to the required format, e.g. input is not a JSON object, the language is not supported, etc.
 
2. `IOError`: IO and import processing errors, such as unresolvable URL or hash mismatch in supplied sources.
 
3. `ParserError`: Source code doesn’t conform to the language rules.
 
4. `DocstringParsingError`: The NatSpec tags in the comment block cannot be parsed.
 
5. `SyntaxError`: Syntactical error, such as `continue` is used outside of a `for` loop.
 
6. `DeclarationError`: Invalid, unresolvable or clashing identifier names. e.g. `Identifier not found`
 
7. `TypeError`: Error within the type system, such as invalid type conversions, invalid assignments, etc.
 
8. `UnimplementedFeatureError`: Feature is not supported by the compiler, but is expected to be supported in future versions.
 
9. `InternalCompilerError`: Internal bug triggered in the compiler - this should be reported as an issue.
 
10. `Exception`: Unknown failure during compilation - this should be reported as an issue.
 
11. `CompilerError`: Invalid use of the compiler stack - this should be reported as an issue.
 
12. `FatalError`: Fatal error not processed correctly - this should be reported as an issue.
 
13. `YulException`: Error during Yul code generation - this should be reported as an issue.
 
14. `Warning`: A warning, which didn’t stop the compilation, but should be addressed if possible.
 
15. `Info`: Information that the compiler thinks the user might find useful, but is not dangerous and does not necessarily need to be addressed.

# [Cleaning Up Variables — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/internals/variable_cleanup.html) 
 _https://docs.soliditylang.org/en/v0.8.30/internals/variable_cleanup.html_

Ultimately, all values in the EVM are stored in 256 bit words. Thus, in some cases, when the type of a value has less than 256 bits, it is necessary to clean the remaining bits. The Solidity compiler is designed to do such cleaning before any operations that might be adversely affected by the potential garbage in the remaining bits. For example, before writing a value to memory, the remaining bits need to be cleared because the memory contents can be used for computing hashes or sent as the data of a message call. Similarly, before storing a value in the storage, the remaining bits need to be cleaned because otherwise the garbled value can be observed.
Note that access via inline assembly is not considered such an operation: If you use inline assembly to access Solidity variables shorter than 256 bits, the compiler does not guarantee that the value is properly cleaned up.
Moreover, we do not clean the bits if the immediately following operation is not affected. For instance, since any non-zero value is considered `true` by `JUMPI` instruction, we do not clean the boolean values before they are used as the condition for `JUMPI`.
In addition to the design principle above, the Solidity compiler cleans input data when it is loaded onto the stack.
The following table describes the cleaning rules applied to different types, where `higher bits` refers to the remaining bits in case the type has less than 256 bits.
Type
Valid Values
Cleanup of Invalid Values
enum of n members
0 until n - 1
throws exception
bool
0 or 1
results in 1
signed integers
higher bits set to the sign bit
currently silently signextends to a valid value, i.e. all higher bits are set to the sign bit; may throw an exception in the future
unsigned integers
higher bits zeroed
currently silently masks to a valid value, i.e. all higher bits are set to zero; may throw an exception in the future
Note that valid and invalid values are dependent on their type size. Consider `uint8`, the unsigned 8-bit type, which has the following valid values:
0000...0000 0000 0000
0000...0000 0000 0001
0000...0000 0000 0010
....
0000...0000 1111 1111
Any invalid value will have the higher bits set to zero:
0101...1101 0010 1010 invalid value
0000...0000 0010 1010 cleaned value
For `int8`, the signed 8-bit type, the valid values are:
Negative
1111...1111 1111 1111
1111...1111 1111 1110
....
1111...1111 1000 0000
Positive
0000...0000 0000 0000
0000...0000 0000 0001
0000...0000 0000 0010
....
0000...0000 1111 1111
The compiler will `signextend` the sign bit, which is 1 for negative and 0 for positive values, overwriting the higher bits:
Negative
0010...1010 1111 1111 invalid value
1111...1111 1111 1111 cleaned value
Positive
1101...0101 0000 0100 invalid value
0000...0000 0000 0100 cleaned value

# [Import Path Resolution — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html) 
 _https://docs.soliditylang.org/en/v0.8.30/path-resolution.html_

In order to be able to support reproducible builds on all platforms, the Solidity compiler has to abstract away the details of the filesystem where source files are stored. Paths used in imports must work the same way everywhere while the command-line interface must be able to work with platform-specific paths to provide good user experience. This section aims to explain in detail how Solidity reconciles these requirements.
## Virtual Filesystem[](#virtual-filesystem "Link to this heading")
The compiler maintains an internal database (_virtual filesystem_ or _VFS_ for short) where each source unit is assigned a unique _source unit name_ which is an opaque and unstructured identifier. When you use the [import statement](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#import), you specify an _import path_ that references a source unit name.
### Import Callback[](#import-callback "Link to this heading")
The VFS is initially populated only with files the compiler has received as input. Additional files can be loaded during compilation using an _import callback_, which is different depending on the type of compiler you use (see below). If the compiler does not find any source unit name matching the import path in the VFS, it invokes the callback, which is responsible for obtaining the source code to be placed under that name. An import callback is free to interpret source unit names in an arbitrary way, not just as paths. If there is no callback available when one is needed or if it fails to locate the source code, compilation fails.
By default, the command-line compiler provides the _Host Filesystem Loader_ - a rudimentary callback that interprets a source unit name as a path in the local filesystem. This callback can be disabled using the `--no-import-callback` command-line option. The [JavaScript interface](https://github.com/ethereum/solc-js) does not provide any by default, but one can be provided by the user. This mechanism can be used to obtain source code from locations other than the local filesystem (which may not even be accessible, e.g. when the compiler is running in a browser). For example the [Remix IDE](https://remix.ethereum.org/) provides a versatile callback that lets you [import files from HTTP, IPFS and Swarm URLs or refer directly to packages in NPM registry](https://remix-ide.readthedocs.io/en/latest/import.html).
Note
Host Filesystem Loader’s file lookup is platform-dependent. For example backslashes in a source unit name can be interpreted as directory separators or not and the lookup can be case-sensitive or not, depending on the underlying platform.
For portability it is recommended to avoid using import paths that will work correctly only with a specific import callback or only on one platform. For example you should always use forward slashes since they work as path separators also on platforms that support backslashes.
### Initial Content of the Virtual Filesystem[](#initial-content-of-the-virtual-filesystem "Link to this heading")
The initial content of the VFS depends on how you invoke the compiler:
1. **solc / command-line interface**
 
 When you compile a file using the command-line interface of the compiler, you provide one or more paths to files containing Solidity code:
 
 solc contract.sol /usr/local/dapp-bin/token.sol
 
 The source unit name of a file loaded this way is constructed by converting its path to a canonical form and, if possible, making it relative to either the base path or one of the include paths. See [CLI Path Normalization and Stripping](#cli-path-normalization-and-stripping) for a detailed description of this process.
 
2. **Standard JSON**
 
 When using the [Standard JSON](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#compiler-api) API (via either the [JavaScript interface](https://github.com/ethereum/solc-js) or the `--standard-json` command-line option) you provide input in JSON format, containing, among other things, the content of all your source files:
 
 {
 "language": "Solidity",
 "sources": {
 "contract.sol": {
 "content": "import \\"./util.sol\\";\\ncontract C {}"
 },
 "util.sol": {
 "content": "library Util {}"
 },
 "/usr/local/dapp-bin/token.sol": {
 "content": "contract Token {}"
 }
 },
 "settings": {"outputSelection": {"\*": { "\*": \["metadata", "evm.bytecode"\]}}}
 }
 
 The `sources` dictionary becomes the initial content of the virtual filesystem and its keys are used as source unit names.
 
3. **Standard JSON (via import callback)**
 
 With Standard JSON it is also possible to tell the compiler to use the import callback to obtain the source code:
 
 {
 "language": "Solidity",
 "sources": {
 "/usr/local/dapp-bin/token.sol": {
 "urls": \[
 "/projects/mytoken.sol",
 "https://example.com/projects/mytoken.sol"
 \]
 }
 },
 "settings": {"outputSelection": {"\*": { "\*": \["metadata", "evm.bytecode"\]}}}
 }
 
 If an import callback is available, the compiler will give it the strings specified in `urls` one by one, until one is loaded successfully or the end of the list is reached.
 
 The source unit names are determined the same way as when using `content` - they are keys of the `sources` dictionary and the content of `urls` does not affect them in any way.
 
4. **Standard input**
 
 On the command-line it is also possible to provide the source by sending it to compiler’s standard input:
 
 echo 'import "./util.sol"; contract C {}' | solc \-
 
 `-` used as one of the arguments instructs the compiler to place the content of the standard input in the virtual filesystem under a special source unit name: `<stdin>`.
 
Once the VFS is initialized, additional files can still be added to it only through the import callback.
## Imports[](#imports "Link to this heading")
The import statement specifies an _import path_. Based on how the import path is specified, we can divide imports into two categories:
* [Direct imports](#direct-imports), where you specify the full source unit name directly.
 
* [Relative imports](#relative-imports), where you specify a path starting with `./` or `../` to be combined with the source unit name of the importing file.
 
contracts/contract.sol[](#id9 "Link to this code")
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=aW1wb3J0ICIuL21hdGgvbWF0aC5zb2wiOwppbXBvcnQgImNvbnRyYWN0cy90b2tlbnMvdG9rZW4uc29sIjs=)
import "./math/math.sol";
import "contracts/tokens/token.sol";
In the above `./math/math.sol` and `contracts/tokens/token.sol` are import paths while the source unit names they translate to are `contracts/math/math.sol` and `contracts/tokens/token.sol` respectively.
### Direct Imports[](#direct-imports "Link to this heading")
An import that does not start with `./` or `../` is a _direct import_.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=aW1wb3J0ICIvcHJvamVjdC9saWIvdXRpbC5zb2wiOyAgICAgICAgIC8vIHNvdXJjZSB1bml0IG5hbWU6IC9wcm9qZWN0L2xpYi91dGlsLnNvbAppbXBvcnQgImxpYi91dGlsLnNvbCI7ICAgICAgICAgICAgICAgICAgLy8gc291cmNlIHVuaXQgbmFtZTogbGliL3V0aWwuc29sCmltcG9ydCAiQG9wZW56ZXBwZWxpbi9hZGRyZXNzLnNvbCI7ICAgICAvLyBzb3VyY2UgdW5pdCBuYW1lOiBAb3BlbnplcHBlbGluL2FkZHJlc3Muc29sCmltcG9ydCAiaHR0cHM6Ly9leGFtcGxlLmNvbS90b2tlbi5zb2wiOyAvLyBzb3VyY2UgdW5pdCBuYW1lOiBodHRwczovL2V4YW1wbGUuY29tL3Rva2VuLnNvbA==)
import "/project/lib/util.sol"; // source unit name: /project/lib/util.sol
import "lib/util.sol"; // source unit name: lib/util.sol
import "@openzeppelin/address.sol"; // source unit name: @openzeppelin/address.sol
import "https://example.com/token.sol"; // source unit name: https://example.com/token.sol
After applying any [import remappings](#import-remapping) the import path simply becomes the source unit name.
Note
A source unit name is just an identifier and even if its value happens to look like a path, it is not subject to the normalization rules you would typically expect in a shell. Any `/./` or `/../` segments or sequences of multiple slashes remain a part of it. When the source is provided via Standard JSON interface it is entirely possible to associate different content with source unit names that would refer to the same file on disk.
When the source is not available in the virtual filesystem, the compiler passes the source unit name to the import callback. The Host Filesystem Loader will attempt to use it as a path and look up the file on disk. At this point the platform-specific normalization rules kick in and names that were considered different in the VFS may actually result in the same file being loaded. For example `/project/lib/math.sol` and `/project/lib/../lib///math.sol` are considered completely different in the VFS even though they refer to the same file on disk.
Note
Even if an import callback ends up loading source code for two different source unit names from the same file on disk, the compiler will still see them as separate source units. It is the source unit name that matters, not the physical location of the code.
### Relative Imports[](#relative-imports "Link to this heading")
An import starting with `./` or `../` is a _relative import_. Such imports specify a path relative to the source unit name of the importing source unit:
/project/lib/math.sol[](#id10 "Link to this code")
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=aW1wb3J0ICIuL3V0aWwuc29sIiBhcyB1dGlsOyAgICAvLyBzb3VyY2UgdW5pdCBuYW1lOiAvcHJvamVjdC9saWIvdXRpbC5zb2wKaW1wb3J0ICIuLi90b2tlbi5zb2wiIGFzIHRva2VuOyAvLyBzb3VyY2UgdW5pdCBuYW1lOiAvcHJvamVjdC90b2tlbi5zb2w=)
import "./util.sol" as util; // source unit name: /project/lib/util.sol
import "../token.sol" as token; // source unit name: /project/token.sol
lib/math.sol[](#id11 "Link to this code")
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=aW1wb3J0ICIuL3V0aWwuc29sIiBhcyB1dGlsOyAgICAvLyBzb3VyY2UgdW5pdCBuYW1lOiBsaWIvdXRpbC5zb2wKaW1wb3J0ICIuLi90b2tlbi5zb2wiIGFzIHRva2VuOyAvLyBzb3VyY2UgdW5pdCBuYW1lOiB0b2tlbi5zb2w=)
import "./util.sol" as util; // source unit name: lib/util.sol
import "../token.sol" as token; // source unit name: token.sol
Note
Relative imports **always** start with `./` or `../` so `import "util.sol"`, unlike `import "./util.sol"`, is a direct import. While both paths would be considered relative in the host filesystem, `util.sol` is actually absolute in the VFS.
Let us define a _path segment_ as any non-empty part of the path that does not contain a separator and is bounded by two path separators. A separator is a forward slash or the beginning/end of the string. For example in `./abc/..//` there are three path segments: `.`, `abc` and `..`.
The compiler resolves the import into a source unit name based on the import path, in the following way:
1. We start with the source unit name of the importing source unit.
 
2. The last path segment with preceding slashes is removed from the resolved name.
 
3. Then, for every segment in the import path, starting from the leftmost one:
 
 > * If the segment is `.`, it is skipped.
 > 
 > * If the segment is `..`, the last path segment with preceding slashes is removed from the resolved name.
 > 
 > * Otherwise, the segment (preceded by a single slash if the resolved name is not empty), is appended to the resolved name.
 > 
 
The removal of the last path segment with preceding slashes is understood to work as follows:
1. Everything past the last slash is removed (i.e. `a/b//c.sol` becomes `a/b//`).
 
2. All trailing slashes are removed (i.e. `a/b//` becomes `a/b`).
 
Note that the process normalizes the part of the resolved source unit name that comes from the import path according to the usual rules for UNIX paths, i.e. all `.` and `..` are removed and multiple slashes are squashed into a single one. On the other hand, the part that comes from the source unit name of the importing module remains unnormalized. This ensures that the `protocol://` part does not turn into `protocol:/` if the importing file is identified with a URL.
If your import paths are already normalized, you can expect the above algorithm to produce very intuitive results. Here are some examples of what you can expect if they are not:
lib/src/../contract.sol[](#id12 "Link to this code")
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=aW1wb3J0ICIuL3V0aWwvLi91dGlsLnNvbCI7ICAgICAgICAgLy8gc291cmNlIHVuaXQgbmFtZTogbGliL3NyYy8uLi91dGlsL3V0aWwuc29sCmltcG9ydCAiLi91dGlsLy91dGlsLnNvbCI7ICAgICAgICAgIC8vIHNvdXJjZSB1bml0IG5hbWU6IGxpYi9zcmMvLi4vdXRpbC91dGlsLnNvbAppbXBvcnQgIi4uL3V0aWwvLi4vYXJyYXkvdXRpbC5zb2wiOyAvLyBzb3VyY2UgdW5pdCBuYW1lOiBsaWIvc3JjL2FycmF5L3V0aWwuc29sCmltcG9ydCAiLi4vLi4vLi8uLi91dGlsLnNvbCI7ICAgICAgIC8vIHNvdXJjZSB1bml0IG5hbWU6IHV0aWwuc29sCmltcG9ydCAiLi4vLi4vLi4vLi8uLi91dGlsLnNvbCI7ICAgIC8vIHNvdXJjZSB1bml0IG5hbWU6IHV0aWwuc29s)
import "./util/./util.sol"; // source unit name: lib/src/../util/util.sol
import "./util//util.sol"; // source unit name: lib/src/../util/util.sol
import "../util/../array/util.sol"; // source unit name: lib/src/array/util.sol
import "../.././../util.sol"; // source unit name: util.sol
import "../../.././../util.sol"; // source unit name: util.sol
Note
The use of relative imports containing leading `..` segments is not recommended. The same effect can be achieved in a more reliable way by using direct imports with [base path and include paths](#base-and-include-paths).
## Base Path and Include Paths[](#base-path-and-include-paths "Link to this heading")
The base path and include paths represent directories that the Host Filesystem Loader will load files from. When a source unit name is passed to the loader, it prepends the base path to it and performs a filesystem lookup. If the lookup does not succeed, the same is done with all directories on the include path list.
It is recommended to set the base path to the root directory of your project and use include paths to specify additional locations that may contain libraries your project depends on. This lets you import from these libraries in a uniform way, no matter where they are located in the filesystem relative to your project. For example, if you use npm to install packages and your contract imports `@openzeppelin/contracts/utils/Strings.sol`, you can use these options to tell the compiler that the library can be found in one of the npm package directories:
solc contract.sol \\
 \--base-path . \\
 \--include-path node\_modules/ \\
 \--include-path /usr/local/lib/node\_modules/
Your contract will compile (with the same exact metadata) no matter whether you install the library in the local or global package directory or even directly under your project root.
By default the base path is empty, which leaves the source unit name unchanged. When the source unit name is a relative path, this results in the file being looked up in the directory the compiler has been invoked from. It is also the only value that results in absolute paths in source unit names being actually interpreted as absolute paths on disk. If the base path itself is relative, it is interpreted as relative to the current working directory of the compiler.
Note
Include paths cannot have empty values and must be used together with a non-empty base path.
Note
Include paths and base path can overlap as long as it does not make import resolution ambiguous. For example, you can specify a directory inside base path as an include directory or have an include directory that is a subdirectory of another include directory. The compiler will only issue an error if the source unit name passed to the Host Filesystem Loader represents an existing path when combined with multiple include paths or an include path and base path.
### CLI Path Normalization and Stripping[](#cli-path-normalization-and-stripping "Link to this heading")
On the command-line the compiler behaves just as you would expect from any other program: it accepts paths in a format native to the platform and relative paths are relative to the current working directory. The source unit names assigned to files whose paths are specified on the command-line, however, should not change just because the project is being compiled on a different platform or because the compiler happens to have been invoked from a different directory. To achieve this, paths to source files coming from the command-line must be converted to a canonical form, and, if possible, made relative to the base path or one of the include paths.
The normalization rules are as follows:
* If a path is relative, it is made absolute by prepending the current working directory to it.
 
* Internal `.` and `..` segments are collapsed.
 
* Platform-specific path separators are replaced with forward slashes.
 
* Sequences of multiple consecutive path separators are squashed into a single separator (unless they are the leading slashes of an [UNC path](https://en.wikipedia.org/wiki/Path_\(computing\)#UNC)).
 
* If the path includes a root name (e.g. a drive letter on Windows) and the root is the same as the root of the current working directory, the root is replaced with `/`.
 
* Symbolic links in the path are **not** resolved.
 
 * The only exception is the path to the current working directory prepended to relative paths in the process of making them absolute. On some platforms the working directory is reported always with symbolic links resolved so for consistency the compiler resolves them everywhere.
 
* The original case of the path is preserved even if the filesystem is case-insensitive but [case-preserving](https://en.wikipedia.org/wiki/Case_preservation) and the actual case on disk is different.
 
Note
There are situations where paths cannot be made platform-independent. For example on Windows the compiler can avoid using drive letters by referring to the root directory of the current drive as `/` but drive letters are still necessary for paths leading to other drives. You can avoid such situations by ensuring that all the files are available within a single directory tree on the same drive.
After normalization the compiler attempts to make the source file path relative. It tries the base path first and then the include paths in the order they were given. If the base path is empty or not specified, it is treated as if it was equal to the path to the current working directory (with all symbolic links resolved). The result is accepted only if the normalized directory path is the exact prefix of the normalized file path. Otherwise the file path remains absolute. This makes the conversion unambiguous and ensures that the relative path does not start with `../`. The resulting file path becomes the source unit name.
Note
The relative path produced by stripping must remain unique within the base path and include paths. For example the compiler will issue an error for the following command if both `/project/contract.sol` and `/lib/contract.sol` exist:
solc /project/contract.sol \--base-path /project \--include-path /lib
Note
Prior to version 0.8.8, CLI path stripping was not performed and the only normalization applied was the conversion of path separators. When working with older versions of the compiler it is recommended to invoke the compiler from the base path and to only use relative paths on the command-line.
## Allowed Paths[](#allowed-paths "Link to this heading")
As a security measure, the Host Filesystem Loader will refuse to load files from outside of a few locations that are considered safe by default:
* Outside of Standard JSON mode:
 
 * The directories containing input files listed on the command-line.
 
 * The directories used as [remapping](#import-remapping) targets. If the target is not a directory (i.e does not end with `/`, `/.` or `/..`) the directory containing the target is used instead.
 
 * Base path and include paths.
 
* In Standard JSON mode:
 
 * Base path and include paths.
 
Additional directories can be whitelisted using the `--allow-paths` option. The option accepts a comma-separated list of paths:
cd /home/user/project/
solc token/contract.sol \\
 lib/util.sol\=libs/util.sol \\
 \--base-path\=token/ \\
 \--include-path\=/lib/ \\
 \--allow-paths\=../utils/,/tmp/libraries
When the compiler is invoked with the command shown above, the Host Filesystem Loader will allow importing files from the following directories:
* `/home/user/project/token/` (because `token/` contains the input file and also because it is the base path),
 
* `/lib/` (because `/lib/` is one of the include paths),
 
* `/home/user/project/libs/` (because `libs/` is a directory containing a remapping target),
 
* `/home/user/utils/` (because of `../utils/` passed to `--allow-paths`),
 
* `/tmp/libraries/` (because of `/tmp/libraries` passed to `--allow-paths`),
 
Note
The working directory of the compiler is one of the paths allowed by default only if it happens to be the base path (or the base path is not specified or has an empty value).
Note
The compiler does not check if allowed paths actually exist and whether they are directories. Non-existent or empty paths are simply ignored. If an allowed path matches a file rather than a directory, the file is considered whitelisted, too.
Note
Allowed paths are case-sensitive even if the filesystem is not. The case must exactly match the one used in your imports. For example `--allow-paths tokens` will not match `import "Tokens/IERC20.sol"`.
Warning
Files and directories only reachable through symbolic links from allowed directories are not automatically whitelisted. For example if `token/contract.sol` in the example above was actually a symlink pointing at `/etc/passwd` the compiler would refuse to load it unless `/etc/` was one of the allowed paths too.
## Import Remapping[](#import-remapping "Link to this heading")
Import remapping allows you to redirect imports to a different location in the virtual filesystem. The mechanism works by changing the translation between import paths and source unit names. For example you can set up a remapping so that any import from the virtual directory `github.com/ethereum/dapp-bin/library/` would be seen as an import from `dapp-bin/library/` instead.
You can limit the scope of a remapping by specifying a _context_. This allows creating remappings that apply only to imports located in a specific library or a specific file. Without a context a remapping is applied to every matching import in all the files in the virtual filesystem.
Import remappings have the form of `context:prefix=target`:
* `context` must match the beginning of the source unit name of the file containing the import.
 
* `prefix` must match the beginning of the source unit name resulting from the import.
 
* `target` is the value the prefix is replaced with.
 
For example, if you clone [https://github.com/ethereum/dapp-bin/](https://github.com/ethereum/dapp-bin/) locally to `/project/dapp-bin` and run the compiler with:
solc github.com/ethereum/dapp-bin/\=dapp-bin/ \--base-path /project source.sol
you can use the following in your source file:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=aW1wb3J0ICJnaXRodWIuY29tL2V0aGVyZXVtL2RhcHAtYmluL2xpYnJhcnkvbWF0aC5zb2wiOyAvLyBzb3VyY2UgdW5pdCBuYW1lOiBkYXBwLWJpbi9saWJyYXJ5L21hdGguc29s)
import "github.com/ethereum/dapp-bin/library/math.sol"; // source unit name: dapp-bin/library/math.sol
The compiler will look for the file in the VFS under `dapp-bin/library/math.sol`. If the file is not available there, the source unit name will be passed to the Host Filesystem Loader, which will then look in `/project/dapp-bin/library/math.sol`.
Warning
Information about remappings is stored in contract metadata. Since the binary produced by the compiler has a hash of the metadata embedded in it, any modification to the remappings will result in different bytecode.
For this reason you should be careful not to include any local information in remapping targets. For example if your library is located in `/home/user/packages/mymath/math.sol`, a remapping like `@math/=/home/user/packages/mymath/` would result in your home directory being included in the metadata. To be able to reproduce the same bytecode with such a remapping on a different machine, you would need to recreate parts of your local directory structure in the VFS and (if you rely on Host Filesystem Loader) also in the host filesystem.
To avoid having your local directory structure embedded in the metadata, it is recommended to designate the directories containing libraries as _include paths_ instead. For example, in the example above `--include-path /home/user/packages/` would let you use imports starting with `mymath/`. Unlike remapping, the option on its own will not make `mymath` appear as `@math` but this can be achieved by creating a symbolic link or renaming the package subdirectory.
As a more complex example, suppose you rely on a module that uses an old version of dapp-bin that you checked out to `/project/dapp-bin_old`, then you can run:
solc module1:github.com/ethereum/dapp-bin/\=dapp-bin/ \\
 module2:github.com/ethereum/dapp-bin/\=dapp-bin\_old/ \\
 \--base-path /project \\
 source.sol
This means that all imports in `module2` point to the old version but imports in `module1` point to the new version.
Here are the detailed rules governing the behavior of remappings:
1. **Remappings only affect the translation between import paths and source unit names.**
 
 Source unit names added to the VFS in any other way cannot be remapped. For example the paths you specify on the command-line and the ones in `sources.urls` in Standard JSON are not affected.
 
 solc /project/\=/contracts/ /project/contract.sol ＃ source unit name: /project/contract.sol
 
 In the example above the compiler will load the source code from `/project/contract.sol` and place it under that exact source unit name in the VFS, not under `/contract/contract.sol`.
 
2. **Context and prefix must match source unit names, not import paths.**
 
 * This means that you cannot remap `./` or `../` directly since they are replaced during the translation to source unit name but you can remap the part of the name they are replaced with:
 
 solc ./\=a/ /project/\=b/ /project/contract.sol ＃ source unit name: /project/contract.sol
 
 /project/contract.sol[](#id13 "Link to this code")
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=aW1wb3J0ICIuL3V0aWwuc29sIiBhcyB1dGlsOyAvLyBzb3VyY2UgdW5pdCBuYW1lOiBiL3V0aWwuc29s)
 
 import "./util.sol" as util; // source unit name: b/util.sol
 
 * You cannot remap base path or any other part of the path that is only added internally by an import callback:
 
 solc /project/\=/contracts/ /project/contract.sol \--base-path /project ＃ source unit name: contract.sol
 
 /project/contract.sol[](#id14 "Link to this code")
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=aW1wb3J0ICJ1dGlsLnNvbCIgYXMgdXRpbDsgLy8gc291cmNlIHVuaXQgbmFtZTogdXRpbC5zb2w=)
 
 import "util.sol" as util; // source unit name: util.sol
 
3. **Target is inserted directly into the source unit name and does not necessarily have to be a valid path.**
 
 * It can be anything as long as the import callback can handle it. In case of the Host Filesystem Loader this includes also relative paths. When using the JavaScript interface you can even use URLs and abstract identifiers if your callback can handle them.
 
 * Remapping happens after relative imports have already been resolved into source unit names. This means that targets starting with `./` and `../` have no special meaning and are relative to the base path rather than to the location of the source file.
 
 * Remapping targets are not normalized so `@root/=./a/b//` will remap `@root/contract.sol` to `./a/b//contract.sol` and not `a/b/contract.sol`.
 
 * If the target does not end with a slash, the compiler will not add one automatically:
 
 solc /project/\=/contracts /project/contract.sol ＃ source unit name: /project/contract.sol
 
 /project/contract.sol[](#id15 "Link to this code")
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=aW1wb3J0ICIvcHJvamVjdC91dGlsLnNvbCIgYXMgdXRpbDsgLy8gc291cmNlIHVuaXQgbmFtZTogL2NvbnRyYWN0c3V0aWwuc29s)
 
 import "/project/util.sol" as util; // source unit name: /contractsutil.sol
 
4. **Context and prefix are patterns and matches must be exact.**
 
 * `a//b=c` will not match `a/b`.
 
 * source unit names are not normalized so `a/b=c` will not match `a//b` either.
 
 * Parts of file and directory names can match as well. `/newProject/con:/new=old` will match `/newProject/contract.sol` and remap it to `oldProject/contract.sol`.
 
5. **At most one remapping is applied to a single import.**
 
 * If multiple remappings match the same source unit name, the one with the longest matching prefix is chosen.
 
 * If prefixes are identical, the one specified last wins.
 
 * Remappings do not work on other remappings. For example `a=b b=c c=d` will not result in `a` being remapped to `d`.
 
6. **Prefix cannot be empty but context and target are optional.**
 
 * If `target` is the empty string, `prefix` is simply removed from import paths.
 
 * Empty `context` means that the remapping applies to all imports in all source units.
 
## Using URLs in imports[](#using-urls-in-imports "Link to this heading")
Most URL prefixes such as `https://` or `data://` have no special meaning in import paths. The only exception is `file://` which is stripped from source unit names by the Host Filesystem Loader.
When compiling locally you can use import remapping to replace the protocol and domain part with a local path:
solc :https://github.com/ethereum/dapp-bin\=/usr/local/dapp-bin contract.sol
Note the leading `:`, which is necessary when the remapping context is empty. Otherwise the `https:` part would be interpreted by the compiler as the context.

# [Contracts — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/contracts.html) 
 _https://docs.soliditylang.org/en/v0.8.30/contracts.html_

Contracts in Solidity are similar to classes in object-oriented languages. They contain persistent data in state variables, and functions that can modify these variables. Calling a function on a different contract (instance) will perform an EVM function call and thus switch the context such that state variables in the calling contract are inaccessible. A contract and its functions need to be called for anything to happen. There is no “cron” concept in Ethereum to call a function at a particular event automatically.
## Creating Contracts[](#creating-contracts "Link to this heading")
Contracts can be created “from outside” via Ethereum transactions or from within Solidity contracts.
IDEs, such as [Remix](https://remix.ethereum.org/), make the creation process seamless using UI elements.
One way to create contracts programmatically on Ethereum is via the JavaScript API [web3.js](https://github.com/web3/web3.js). It has a function called [web3.eth.Contract](https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract) to facilitate contract creation.
When a contract is created, its [constructor](#constructor) (a function declared with the `constructor` keyword) is executed once.
A constructor is optional. Only one constructor is allowed, which means overloading is not supported.
After the constructor has executed, the final code of the contract is stored on the blockchain. This code includes all public and external functions and all functions that are reachable from there through function calls. The deployed code does not include the constructor code or internal functions only called from the constructor.
Internally, constructor arguments are passed [ABI encoded](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#abi) after the code of the contract itself, but you do not have to care about this if you use `web3.js`.
If a contract wants to create another contract, the source code (and the binary) of the created contract has to be known to the creator. This means that cyclic creation dependencies are impossible.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCgpjb250cmFjdCBPd25lZFRva2VuIHsKICAgIC8vIGBUb2tlbkNyZWF0b3JgIGlzIGEgY29udHJhY3QgdHlwZSB0aGF0IGlzIGRlZmluZWQgYmVsb3cuCiAgICAvLyBJdCBpcyBmaW5lIHRvIHJlZmVyZW5jZSBpdCBhcyBsb25nIGFzIGl0IGlzIG5vdCB1c2VkCiAgICAvLyB0byBjcmVhdGUgYSBuZXcgY29udHJhY3QuCiAgICBUb2tlbkNyZWF0b3IgY3JlYXRvcjsKICAgIGFkZHJlc3Mgb3duZXI7CiAgICBieXRlczMyIG5hbWU7CgogICAgLy8gVGhpcyBpcyB0aGUgY29uc3RydWN0b3Igd2hpY2ggcmVnaXN0ZXJzIHRoZQogICAgLy8gY3JlYXRvciBhbmQgdGhlIGFzc2lnbmVkIG5hbWUuCiAgICBjb25zdHJ1Y3RvcihieXRlczMyIG5hbWVfKSB7CiAgICAgICAgLy8gU3RhdGUgdmFyaWFibGVzIGFyZSBhY2Nlc3NlZCB2aWEgdGhlaXIgbmFtZQogICAgICAgIC8vIGFuZCBub3QgdmlhIGUuZy4gYHRoaXMub3duZXJgLiBGdW5jdGlvbnMgY2FuCiAgICAgICAgLy8gYmUgYWNjZXNzZWQgZGlyZWN0bHkgb3IgdGhyb3VnaCBgdGhpcy5mYCwKICAgICAgICAvLyBidXQgdGhlIGxhdHRlciBwcm92aWRlcyBhbiBleHRlcm5hbCB2aWV3CiAgICAgICAgLy8gdG8gdGhlIGZ1bmN0aW9uLiBFc3BlY2lhbGx5IGluIHRoZSBjb25zdHJ1Y3RvciwKICAgICAgICAvLyB5b3Ugc2hvdWxkIG5vdCBhY2Nlc3MgZnVuY3Rpb25zIGV4dGVybmFsbHksCiAgICAgICAgLy8gYmVjYXVzZSB0aGUgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QgeWV0LgogICAgICAgIC8vIFNlZSB0aGUgbmV4dCBzZWN0aW9uIGZvciBkZXRhaWxzLgogICAgICAgIG93bmVyID0gbXNnLnNlbmRlcjsKCiAgICAgICAgLy8gV2UgcGVyZm9ybSBhbiBleHBsaWNpdCB0eXBlIGNvbnZlcnNpb24gZnJvbSBgYWRkcmVzc2AKICAgICAgICAvLyB0byBgVG9rZW5DcmVhdG9yYCBhbmQgYXNzdW1lIHRoYXQgdGhlIHR5cGUgb2YKICAgICAgICAvLyB0aGUgY2FsbGluZyBjb250cmFjdCBpcyBgVG9rZW5DcmVhdG9yYCwgdGhlcmUgaXMKICAgICAgICAvLyBubyByZWFsIHdheSB0byB2ZXJpZnkgdGhhdC4KICAgICAgICAvLyBUaGlzIGRvZXMgbm90IGNyZWF0ZSBhIG5ldyBjb250cmFjdC4KICAgICAgICBjcmVhdG9yID0gVG9rZW5DcmVhdG9yKG1zZy5zZW5kZXIpOwogICAgICAgIG5hbWUgPSBuYW1lXzsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGFuZ2VOYW1lKGJ5dGVzMzIgbmV3TmFtZSkgcHVibGljIHsKICAgICAgICAvLyBPbmx5IHRoZSBjcmVhdG9yIGNhbiBhbHRlciB0aGUgbmFtZS4KICAgICAgICAvLyBXZSBjb21wYXJlIHRoZSBjb250cmFjdCBiYXNlZCBvbiBpdHMKICAgICAgICAvLyBhZGRyZXNzIHdoaWNoIGNhbiBiZSByZXRyaWV2ZWQgYnkKICAgICAgICAvLyBleHBsaWNpdCBjb252ZXJzaW9uIHRvIGFkZHJlc3MuCiAgICAgICAgaWYgKG1zZy5zZW5kZXIgPT0gYWRkcmVzcyhjcmVhdG9yKSkKICAgICAgICAgICAgbmFtZSA9IG5ld05hbWU7CiAgICB9CgogICAgZnVuY3Rpb24gdHJhbnNmZXIoYWRkcmVzcyBuZXdPd25lcikgcHVibGljIHsKICAgICAgICAvLyBPbmx5IHRoZSBjdXJyZW50IG93bmVyIGNhbiB0cmFuc2ZlciB0aGUgdG9rZW4uCiAgICAgICAgaWYgKG1zZy5zZW5kZXIgIT0gb3duZXIpIHJldHVybjsKCiAgICAgICAgLy8gV2UgYXNrIHRoZSBjcmVhdG9yIGNvbnRyYWN0IGlmIHRoZSB0cmFuc2ZlcgogICAgICAgIC8vIHNob3VsZCBwcm9jZWVkIGJ5IHVzaW5nIGEgZnVuY3Rpb24gb2YgdGhlCiAgICAgICAgLy8gYFRva2VuQ3JlYXRvcmAgY29udHJhY3QgZGVmaW5lZCBiZWxvdy4gSWYKICAgICAgICAvLyB0aGUgY2FsbCBmYWlscyAoZS5nLiBkdWUgdG8gb3V0LW9mLWdhcyksCiAgICAgICAgLy8gdGhlIGV4ZWN1dGlvbiBhbHNvIGZhaWxzIGhlcmUuCiAgICAgICAgaWYgKGNyZWF0b3IuaXNUb2tlblRyYW5zZmVyT0sob3duZXIsIG5ld093bmVyKSkKICAgICAgICAgICAgb3duZXIgPSBuZXdPd25lcjsKICAgIH0KfQoKCmNvbnRyYWN0IFRva2VuQ3JlYXRvciB7CiAgICBmdW5jdGlvbiBjcmVhdGVUb2tlbihieXRlczMyIG5hbWUpCiAgICAgICAgcHVibGljCiAgICAgICAgcmV0dXJucyAoT3duZWRUb2tlbiB0b2tlbkFkZHJlc3MpCiAgICB7CiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGBUb2tlbmAgY29udHJhY3QgYW5kIHJldHVybiBpdHMgYWRkcmVzcy4KICAgICAgICAvLyBGcm9tIHRoZSBKYXZhU2NyaXB0IHNpZGUsIHRoZSByZXR1cm4gdHlwZQogICAgICAgIC8vIG9mIHRoaXMgZnVuY3Rpb24gaXMgYGFkZHJlc3NgLCBhcyB0aGlzIGlzCiAgICAgICAgLy8gdGhlIGNsb3Nlc3QgdHlwZSBhdmFpbGFibGUgaW4gdGhlIEFCSS4KICAgICAgICByZXR1cm4gbmV3IE93bmVkVG9rZW4obmFtZSk7CiAgICB9CgogICAgZnVuY3Rpb24gY2hhbmdlTmFtZShPd25lZFRva2VuIHRva2VuQWRkcmVzcywgYnl0ZXMzMiBuYW1lKSBwdWJsaWMgewogICAgICAgIC8vIEFnYWluLCB0aGUgZXh0ZXJuYWwgdHlwZSBvZiBgdG9rZW5BZGRyZXNzYCBpcwogICAgICAgIC8vIHNpbXBseSBgYWRkcmVzc2AuCiAgICAgICAgdG9rZW5BZGRyZXNzLmNoYW5nZU5hbWUobmFtZSk7CiAgICB9CgogICAgLy8gUGVyZm9ybSBjaGVja3MgdG8gZGV0ZXJtaW5lIGlmIHRyYW5zZmVycmluZyBhIHRva2VuIHRvIHRoZQogICAgLy8gYE93bmVkVG9rZW5gIGNvbnRyYWN0IHNob3VsZCBwcm9jZWVkCiAgICBmdW5jdGlvbiBpc1Rva2VuVHJhbnNmZXJPSyhhZGRyZXNzIGN1cnJlbnRPd25lciwgYWRkcmVzcyBuZXdPd25lcikKICAgICAgICBwdWJsaWMKICAgICAgICBwdXJlCiAgICAgICAgcmV0dXJucyAoYm9vbCBvaykKICAgIHsKICAgICAgICAvLyBDaGVjayBhbiBhcmJpdHJhcnkgY29uZGl0aW9uIHRvIHNlZSBpZiB0cmFuc2ZlciBzaG91bGQgcHJvY2VlZAogICAgICAgIHJldHVybiBrZWNjYWsyNTYoYWJpLmVuY29kZVBhY2tlZChjdXJyZW50T3duZXIsIG5ld093bmVyKSlbMF0gPT0gMHg3ZjsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.22 <0.9.0;
contract OwnedToken {
 // \`TokenCreator\` is a contract type that is defined below.
 // It is fine to reference it as long as it is not used
 // to create a new contract.
 TokenCreator creator;
 address owner;
 bytes32 name;
 // This is the constructor which registers the
 // creator and the assigned name.
 constructor(bytes32 name\_) {
 // State variables are accessed via their name
 // and not via e.g. \`this.owner\`. Functions can
 // be accessed directly or through \`this.f\`,
 // but the latter provides an external view
 // to the function. Especially in the constructor,
 // you should not access functions externally,
 // because the function does not exist yet.
 // See the next section for details.
 owner \= msg.sender;
 // We perform an explicit type conversion from \`address\`
 // to \`TokenCreator\` and assume that the type of
 // the calling contract is \`TokenCreator\`, there is
 // no real way to verify that.
 // This does not create a new contract.
 creator \= TokenCreator(msg.sender);
 name \= name\_;
 }
 function changeName(bytes32 newName) public {
 // Only the creator can alter the name.
 // We compare the contract based on its
 // address which can be retrieved by
 // explicit conversion to address.
 if (msg.sender \== address(creator))
 name \= newName;
 }
 function transfer(address newOwner) public {
 // Only the current owner can transfer the token.
 if (msg.sender != owner) return;
 // We ask the creator contract if the transfer
 // should proceed by using a function of the
 // \`TokenCreator\` contract defined below. If
 // the call fails (e.g. due to out-of-gas),
 // the execution also fails here.
 if (creator.isTokenTransferOK(owner, newOwner))
 owner \= newOwner;
 }
}
contract TokenCreator {
 function createToken(bytes32 name)
 public
 returns (OwnedToken tokenAddress)
 {
 // Create a new \`Token\` contract and return its address.
 // From the JavaScript side, the return type
 // of this function is \`address\`, as this is
 // the closest type available in the ABI.
 return new OwnedToken(name);
 }
 function changeName(OwnedToken tokenAddress, bytes32 name) public {
 // Again, the external type of \`tokenAddress\` is
 // simply \`address\`.
 tokenAddress.changeName(name);
 }
 // Perform checks to determine if transferring a token to the
 // \`OwnedToken\` contract should proceed
 function isTokenTransferOK(address currentOwner, address newOwner)
 public
 pure
 returns (bool ok)
 {
 // Check an arbitrary condition to see if transfer should proceed
 return keccak256(abi.encodePacked(currentOwner, newOwner))\[0\] \== 0x7f;
 }
}
## Visibility and Getters[](#visibility-and-getters "Link to this heading")
### State Variable Visibility[](#state-variable-visibility "Link to this heading")
`public`
Public state variables differ from internal ones only in that the compiler automatically generates [getter functions](#getter-functions) for them, which allows other contracts to read their values. When used within the same contract, the external access (e.g. `this.x`) invokes the getter while internal access (e.g. `x`) gets the variable value directly from storage. Setter functions are not generated so other contracts cannot directly modify their values.
`internal`
Internal state variables can only be accessed from within the contract they are defined in and in derived contracts. They cannot be accessed externally. This is the default visibility level for state variables.
`private`
Private state variables are like internal ones but they are not visible in derived contracts.
Warning
Making something `private` or `internal` only prevents other contracts from reading or modifying the information, but it will still be visible to the whole world outside of the blockchain.
### Function Visibility[](#function-visibility "Link to this heading")
Solidity knows two kinds of function calls: external ones that do create an actual EVM message call and internal ones that do not. Furthermore, internal functions can be made inaccessible to derived contracts. This gives rise to four types of visibility for functions.
`external`
External functions are part of the contract interface, which means they can be called from other contracts and via transactions. An external function `f` cannot be called internally (i.e. `f()` does not work, but `this.f()` works).
`public`
Public functions are part of the contract interface and can be either called internally or via message calls.
`internal`
Internal functions can only be accessed from within the current contract or contracts deriving from it. They cannot be accessed externally. Since they are not exposed to the outside through the contract’s ABI, they can take parameters of internal types like mappings or storage references.
`private`
Private functions are like internal ones but they are not visible in derived contracts.
Warning
Making something `private` or `internal` only prevents other contracts from reading or modifying the information, but it will still be visible to the whole world outside of the blockchain.
The visibility specifier is given after the type for state variables and between parameter list and return parameter list for functions.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50IGEpIHByaXZhdGUgcHVyZSByZXR1cm5zICh1aW50IGIpIHsgcmV0dXJuIGEgKyAxOyB9CiAgICBmdW5jdGlvbiBzZXREYXRhKHVpbnQgYSkgaW50ZXJuYWwgeyBkYXRhID0gYTsgfQogICAgdWludCBwdWJsaWMgZGF0YTsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 function f(uint a) private pure returns (uint b) { return a + 1; }
 function setData(uint a) internal { data \= a; }
 uint public data;
}
In the following example, `D`, can call `c.getData()` to retrieve the value of `data` in state storage, but is not able to call `f`. Contract `E` is derived from `C` and, thus, can call `compute`.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludCBwcml2YXRlIGRhdGE7CgogICAgZnVuY3Rpb24gZih1aW50IGEpIHByaXZhdGUgcHVyZSByZXR1cm5zKHVpbnQgYikgeyByZXR1cm4gYSArIDE7IH0KICAgIGZ1bmN0aW9uIHNldERhdGEodWludCBhKSBwdWJsaWMgeyBkYXRhID0gYTsgfQogICAgZnVuY3Rpb24gZ2V0RGF0YSgpIHB1YmxpYyB2aWV3IHJldHVybnModWludCkgeyByZXR1cm4gZGF0YTsgfQogICAgZnVuY3Rpb24gY29tcHV0ZSh1aW50IGEsIHVpbnQgYikgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7IHJldHVybiBhICsgYjsgfQp9CgovLyBUaGlzIHdpbGwgbm90IGNvbXBpbGUKY29udHJhY3QgRCB7CiAgICBmdW5jdGlvbiByZWFkRGF0YSgpIHB1YmxpYyB7CiAgICAgICAgQyBjID0gbmV3IEMoKTsKICAgICAgICB1aW50IGxvY2FsID0gYy5mKDcpOyAvLyBlcnJvcjogbWVtYmVyIGBmYCBpcyBub3QgdmlzaWJsZQogICAgICAgIGMuc2V0RGF0YSgzKTsKICAgICAgICBsb2NhbCA9IGMuZ2V0RGF0YSgpOwogICAgICAgIGxvY2FsID0gYy5jb21wdXRlKDMsIDUpOyAvLyBlcnJvcjogbWVtYmVyIGBjb21wdXRlYCBpcyBub3QgdmlzaWJsZQogICAgfQp9Cgpjb250cmFjdCBFIGlzIEMgewogICAgZnVuY3Rpb24gZygpIHB1YmxpYyB7CiAgICAgICAgQyBjID0gbmV3IEMoKTsKICAgICAgICB1aW50IHZhbCA9IGNvbXB1dGUoMywgNSk7IC8vIGFjY2VzcyB0byBpbnRlcm5hbCBtZW1iZXIgKGZyb20gZGVyaXZlZCB0byBwYXJlbnQgY29udHJhY3QpCiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 uint private data;
 function f(uint a) private pure returns(uint b) { return a + 1; }
 function setData(uint a) public { data \= a; }
 function getData() public view returns(uint) { return data; }
 function compute(uint a, uint b) internal pure returns (uint) { return a + b; }
}
// This will not compile
contract D {
 function readData() public {
 C c \= new C();
 uint local \= c.f(7); // error: member \`f\` is not visible
 c.setData(3);
 local \= c.getData();
 local \= c.compute(3, 5); // error: member \`compute\` is not visible
 }
}
contract E is C {
 function g() public {
 C c \= new C();
 uint val \= compute(3, 5); // access to internal member (from derived to parent contract)
 }
}
### Getter Functions[](#getter-functions "Link to this heading")
The compiler automatically creates getter functions for all **public** state variables. For the contract given below, the compiler will generate a function called `data` that does not take any arguments and returns a `uint`, the value of the state variable `data`. State variables can be initialized when they are declared.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludCBwdWJsaWMgZGF0YSA9IDQyOwp9Cgpjb250cmFjdCBDYWxsZXIgewogICAgQyBjID0gbmV3IEMoKTsKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGMuZGF0YSgpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract C {
 uint public data \= 42;
}
contract Caller {
 C c \= new C();
 function f() public view returns (uint) {
 return c.data();
 }
}
The getter functions have external visibility. If the symbol is accessed internally (i.e. without `this.`), it evaluates to a state variable. If it is accessed externally (i.e. with `this.`), it evaluates to a function.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50IHB1YmxpYyBkYXRhOwogICAgZnVuY3Rpb24geCgpIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgZGF0YSA9IDM7IC8vIGludGVybmFsIGFjY2VzcwogICAgICAgIHJldHVybiB0aGlzLmRhdGEoKTsgLy8gZXh0ZXJuYWwgYWNjZXNzCiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract C {
 uint public data;
 function x() public returns (uint) {
 data \= 3; // internal access
 return this.data(); // external access
 }
}
If you have a `public` state variable of array type, then you can only retrieve single elements of the array via the generated getter function. This mechanism exists to avoid high gas costs when returning an entire array. You can use arguments to specify which individual element to return, for example `myArray(0)`. If you want to return an entire array in one call, then you need to write a function, for example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IGFycmF5RXhhbXBsZSB7CiAgICAvLyBwdWJsaWMgc3RhdGUgdmFyaWFibGUKICAgIHVpbnRbXSBwdWJsaWMgbXlBcnJheTsKCiAgICAvLyBHZXR0ZXIgZnVuY3Rpb24gZ2VuZXJhdGVkIGJ5IHRoZSBjb21waWxlcgogICAgLyoKICAgIGZ1bmN0aW9uIG15QXJyYXkodWludCBpKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIG15QXJyYXlbaV07CiAgICB9CiAgICAqLwoKICAgIC8vIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBlbnRpcmUgYXJyYXkKICAgIGZ1bmN0aW9uIGdldEFycmF5KCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludFtdIG1lbW9yeSkgewogICAgICAgIHJldHVybiBteUFycmF5OwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract arrayExample {
 // public state variable
 uint\[\] public myArray;
 // Getter function generated by the compiler
 /\*
 function myArray(uint i) public view returns (uint) {
 return myArray\[i\];
 }
 \*/
 // function that returns entire array
 function getArray() public view returns (uint\[\] memory) {
 return myArray;
 }
}
Now you can use `getArray()` to retrieve the entire array, instead of `myArray(i)`, which returns a single element per call.
The next example is more complex:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQ29tcGxleCB7CiAgICBzdHJ1Y3QgRGF0YSB7CiAgICAgICAgdWludCBhOwogICAgICAgIGJ5dGVzMyBiOwogICAgICAgIG1hcHBpbmcodWludCA9PiB1aW50KSBtYXA7CiAgICAgICAgdWludFszXSBjOwogICAgICAgIHVpbnRbXSBkOwogICAgICAgIGJ5dGVzIGU7CiAgICB9CiAgICBtYXBwaW5nKHVpbnQgPT4gbWFwcGluZyhib29sID0+IERhdGFbXSkpIHB1YmxpYyBkYXRhOwp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract Complex {
 struct Data {
 uint a;
 bytes3 b;
 mapping(uint \=> uint) map;
 uint\[3\] c;
 uint\[\] d;
 bytes e;
 }
 mapping(uint \=> mapping(bool \=> Data\[\])) public data;
}
It generates a function of the following form. The mapping and arrays (with the exception of byte arrays) in the struct are omitted because there is no good way to select individual struct members or provide a key for the mapping:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=ZnVuY3Rpb24gZGF0YSh1aW50IGFyZzEsIGJvb2wgYXJnMiwgdWludCBhcmczKQogICAgcHVibGljCiAgICByZXR1cm5zICh1aW50IGEsIGJ5dGVzMyBiLCBieXRlcyBtZW1vcnkgZSkKewogICAgYSA9IGRhdGFbYXJnMV1bYXJnMl1bYXJnM10uYTsKICAgIGIgPSBkYXRhW2FyZzFdW2FyZzJdW2FyZzNdLmI7CiAgICBlID0gZGF0YVthcmcxXVthcmcyXVthcmczXS5lOwp9)
function data(uint arg1, bool arg2, uint arg3)
 public
 returns (uint a, bytes3 b, bytes memory e)
{
 a \= data\[arg1\]\[arg2\]\[arg3\].a;
 b \= data\[arg1\]\[arg2\]\[arg3\].b;
 e \= data\[arg1\]\[arg2\]\[arg3\].e;
}
## Function Modifiers[](#function-modifiers "Link to this heading")
Modifiers can be used to change the behavior of functions in a declarative way. For example, you can use a modifier to automatically check a condition prior to executing the function.
Modifiers are inheritable properties of contracts and may be overridden by derived contracts, but only if they are marked `virtual`. For details, please see [Modifier Overriding](#modifier-overriding).
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwoKICAgIC8vIFRoaXMgY29udHJhY3Qgb25seSBkZWZpbmVzIGEgbW9kaWZpZXIgYnV0IGRvZXMgbm90IHVzZQogICAgLy8gaXQ6IGl0IHdpbGwgYmUgdXNlZCBpbiBkZXJpdmVkIGNvbnRyYWN0cy4KICAgIC8vIFRoZSBmdW5jdGlvbiBib2R5IGlzIGluc2VydGVkIHdoZXJlIHRoZSBzcGVjaWFsIHN5bWJvbAogICAgLy8gYF87YCBpbiB0aGUgZGVmaW5pdGlvbiBvZiBhIG1vZGlmaWVyIGFwcGVhcnMuCiAgICAvLyBUaGlzIG1lYW5zIHRoYXQgaWYgdGhlIG93bmVyIGNhbGxzIHRoaXMgZnVuY3Rpb24sIHRoZQogICAgLy8gZnVuY3Rpb24gaXMgZXhlY3V0ZWQgYW5kIG90aGVyd2lzZSwgYW4gZXhjZXB0aW9uIGlzCiAgICAvLyB0aHJvd24uCiAgICBtb2RpZmllciBvbmx5T3duZXIgewogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgIG1zZy5zZW5kZXIgPT0gb3duZXIsCiAgICAgICAgICAgICJPbmx5IG93bmVyIGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24uIgogICAgICAgICk7CiAgICAgICAgXzsKICAgIH0KfQoKY29udHJhY3QgcHJpY2VkIHsKICAgIC8vIE1vZGlmaWVycyBjYW4gcmVjZWl2ZSBhcmd1bWVudHM6CiAgICBtb2RpZmllciBjb3N0cyh1aW50IHByaWNlKSB7CiAgICAgICAgaWYgKG1zZy52YWx1ZSA+PSBwcmljZSkgewogICAgICAgICAgICBfOwogICAgICAgIH0KICAgIH0KfQoKY29udHJhY3QgUmVnaXN0ZXIgaXMgcHJpY2VkLCBvd25lZCB7CiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gYm9vbCkgcmVnaXN0ZXJlZEFkZHJlc3NlczsKICAgIHVpbnQgcHJpY2U7CgogICAgY29uc3RydWN0b3IodWludCBpbml0aWFsUHJpY2UpIHsgcHJpY2UgPSBpbml0aWFsUHJpY2U7IH0KCiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gYWxzbyBwcm92aWRlIHRoZQogICAgLy8gYHBheWFibGVgIGtleXdvcmQgaGVyZSwgb3RoZXJ3aXNlIHRoZSBmdW5jdGlvbiB3aWxsCiAgICAvLyBhdXRvbWF0aWNhbGx5IHJlamVjdCBhbGwgRXRoZXIgc2VudCB0byBpdC4KICAgIGZ1bmN0aW9uIHJlZ2lzdGVyKCkgcHVibGljIHBheWFibGUgY29zdHMocHJpY2UpIHsKICAgICAgICByZWdpc3RlcmVkQWRkcmVzc2VzW21zZy5zZW5kZXJdID0gdHJ1ZTsKICAgIH0KCiAgICAvLyBUaGlzIGNvbnRyYWN0IGluaGVyaXRzIHRoZSBgb25seU93bmVyYCBtb2RpZmllciBmcm9tCiAgICAvLyB0aGUgYG93bmVkYCBjb250cmFjdC4gQXMgYSByZXN1bHQsIGNhbGxzIHRvIGBjaGFuZ2VQcmljZWAgd2lsbAogICAgLy8gb25seSB0YWtlIGVmZmVjdCBpZiB0aGV5IGFyZSBtYWRlIGJ5IHRoZSBzdG9yZWQgb3duZXIuCiAgICBmdW5jdGlvbiBjaGFuZ2VQcmljZSh1aW50IHByaWNlXykgcHVibGljIG9ubHlPd25lciB7CiAgICAgICAgcHJpY2UgPSBwcmljZV87CiAgICB9Cn0KCmNvbnRyYWN0IE11dGV4IHsKICAgIGJvb2wgbG9ja2VkOwogICAgbW9kaWZpZXIgbm9SZWVudHJhbmN5KCkgewogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgICFsb2NrZWQsCiAgICAgICAgICAgICJSZWVudHJhbnQgY2FsbC4iCiAgICAgICAgKTsKICAgICAgICBsb2NrZWQgPSB0cnVlOwogICAgICAgIF87CiAgICAgICAgbG9ja2VkID0gZmFsc2U7CiAgICB9CgogICAgLy8vIFRoaXMgZnVuY3Rpb24gaXMgcHJvdGVjdGVkIGJ5IGEgbXV0ZXgsIHdoaWNoIG1lYW5zIHRoYXQKICAgIC8vLyByZWVudHJhbnQgY2FsbHMgZnJvbSB3aXRoaW4gYG1zZy5zZW5kZXIuY2FsbGAgY2Fubm90IGNhbGwgYGZgIGFnYWluLgogICAgLy8vIFRoZSBgcmV0dXJuIDdgIHN0YXRlbWVudCBhc3NpZ25zIDcgdG8gdGhlIHJldHVybiB2YWx1ZSBidXQgc3RpbGwKICAgIC8vLyBleGVjdXRlcyB0aGUgc3RhdGVtZW50IGBsb2NrZWQgPSBmYWxzZWAgaW4gdGhlIG1vZGlmaWVyLgogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBub1JlZW50cmFuY3kgcmV0dXJucyAodWludCkgewogICAgICAgIChib29sIHN1Y2Nlc3MsKSA9IG1zZy5zZW5kZXIuY2FsbCgiIik7CiAgICAgICAgcmVxdWlyZShzdWNjZXNzKTsKICAgICAgICByZXR1cm4gNzsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.1 <0.9.0;
contract owned {
 constructor() { owner \= payable(msg.sender); }
 address payable owner;
 // This contract only defines a modifier but does not use
 // it: it will be used in derived contracts.
 // The function body is inserted where the special symbol
 // \`\_;\` in the definition of a modifier appears.
 // This means that if the owner calls this function, the
 // function is executed and otherwise, an exception is
 // thrown.
 modifier onlyOwner {
 require(
 msg.sender \== owner,
 "Only owner can call this function."
 );
 \_;
 }
}
contract priced {
 // Modifiers can receive arguments:
 modifier costs(uint price) {
 if (msg.value \>= price) {
 \_;
 }
 }
}
contract Register is priced, owned {
 mapping(address \=> bool) registeredAddresses;
 uint price;
 constructor(uint initialPrice) { price \= initialPrice; }
 // It is important to also provide the
 // \`payable\` keyword here, otherwise the function will
 // automatically reject all Ether sent to it.
 function register() public payable costs(price) {
 registeredAddresses\[msg.sender\] \= true;
 }
 // This contract inherits the \`onlyOwner\` modifier from
 // the \`owned\` contract. As a result, calls to \`changePrice\` will
 // only take effect if they are made by the stored owner.
 function changePrice(uint price\_) public onlyOwner {
 price \= price\_;
 }
}
contract Mutex {
 bool locked;
 modifier noReentrancy() {
 require(
 !locked,
 "Reentrant call."
 );
 locked \= true;
 \_;
 locked \= false;
 }
 /// This function is protected by a mutex, which means that
 /// reentrant calls from within \`msg.sender.call\` cannot call \`f\` again.
 /// The \`return 7\` statement assigns 7 to the return value but still
 /// executes the statement \`locked = false\` in the modifier.
 function f() public noReentrancy returns (uint) {
 (bool success,) \= msg.sender.call("");
 require(success);
 return 7;
 }
}
If you want to access a modifier `m` defined in a contract `C`, you can use `C.m` to reference it without virtual lookup. It is only possible to use modifiers defined in the current contract or its base contracts. Modifiers can also be defined in libraries but their use is limited to functions of the same library.
Multiple modifiers are applied to a function by specifying them in a whitespace-separated list and are evaluated in the order presented.
Modifiers cannot implicitly access or change the arguments and return values of functions they modify. Their values can only be passed to them explicitly at the point of invocation.
In function modifiers, it is necessary to specify when you want the function to which the modifier is applied to be run. The placeholder statement (denoted by a single underscore character `_`) is used to denote where the body of the function being modified should be inserted. Note that the placeholder operator is different from using underscores as leading or trailing characters in variable names, which is a stylistic choice.
Explicit returns from a modifier or function body only leave the current modifier or function body. Return variables are assigned and control flow continues after the `_` in the preceding modifier.
Warning
In an earlier version of Solidity, `return` statements in functions having modifiers behaved differently.
An explicit return from a modifier with `return;` does not affect the values returned by the function. The modifier can, however, choose not to execute the function body at all and in that case the return variables are set to their [default values](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#default-value) just as if the function had an empty body.
The `_` symbol can appear in the modifier multiple times. Each occurrence is replaced with the function body, and the function returns the return value of the final occurrence.
Arbitrary expressions are allowed for modifier arguments and in this context, all symbols visible from the function are visible in the modifier. Symbols introduced in the modifier are not visible in the function (as they might change by overriding).
## Transient Storage[](#transient-storage "Link to this heading")
Transient storage is another data location besides memory, storage, calldata (and return-data and code) which was introduced alongside its respective opcodes `TSTORE` and `TLOAD` by [EIP-1153](https://eips.ethereum.org/EIPS/eip-1153). This new data location behaves as a key-value store similar to storage with the main difference being that data in transient storage is not permanent, but is scoped to the current transaction only, after which it will be reset to zero. Since the content of transient storage has very limited lifetime and size, it does not need to be stored permanently as a part of state and the associated gas costs are much lower than in case of storage. EVM version `cancun` or newer is required for transient storage to be available.
Transient storage variables cannot be initialized in place, i.e., they cannot be assigned to upon declaration, since the value would be cleared at the end of the creation transaction, rendering the initialization ineffective. Transient variables will be [default value](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#default-value) initialized depending on their underlying type. `constant` and `immutable` variables conflict with transient storage, since their values are either inlined or directly stored in code.
Transient storage variables have completely independent address space from storage, so that the order of transient state variables does not affect the layout of storage state variables and vice-versa. They do need distinct names though because all state variables share the same namespace. It is also important to note that the values in transient storage are packed in the same fashion as those in persistent storage. See [Storage Layout](https://docs.soliditylang.org/en/v0.8.30/internals/layout_in_storage.html#storage-inplace-encoding) for more information.
Besides that, transient variables can have visibility as well and `public` ones will have a getter function generated automatically as usual.
Note that, currently, such use of `transient` as a data location is only allowed for [value type](https://docs.soliditylang.org/en/v0.8.30/types.html#value-types) state variable declarations. Reference types, such as arrays, mappings and structs, as well as local or parameter variables are not yet supported.
An expected canonical use case for transient storage is cheaper reentrancy locks, which can be readily implemented with the opcodes as showcased next.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjg7Cgpjb250cmFjdCBHZW5lcm9zaXR5IHsKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiBib29sKSBzZW50R2lmdHM7CiAgICBib29sIHRyYW5zaWVudCBsb2NrZWQ7CgogICAgbW9kaWZpZXIgbm9uUmVlbnRyYW50IHsKICAgICAgICByZXF1aXJlKCFsb2NrZWQsICJSZWVudHJhbmN5IGF0dGVtcHQiKTsKICAgICAgICBsb2NrZWQgPSB0cnVlOwogICAgICAgIF87CiAgICAgICAgLy8gVW5sb2NrcyB0aGUgZ3VhcmQsIG1ha2luZyB0aGUgcGF0dGVybiBjb21wb3NhYmxlLgogICAgICAgIC8vIEFmdGVyIHRoZSBmdW5jdGlvbiBleGl0cywgaXQgY2FuIGJlIGNhbGxlZCBhZ2FpbiwgZXZlbiBpbiB0aGUgc2FtZSB0cmFuc2FjdGlvbi4KICAgICAgICBsb2NrZWQgPSBmYWxzZTsKICAgIH0KCiAgICBmdW5jdGlvbiBjbGFpbUdpZnQoKSBub25SZWVudHJhbnQgcHVibGljIHsKICAgICAgICByZXF1aXJlKGFkZHJlc3ModGhpcykuYmFsYW5jZSA+PSAxIGV0aGVyKTsKICAgICAgICByZXF1aXJlKCFzZW50R2lmdHNbbXNnLnNlbmRlcl0pOwogICAgICAgIChib29sIHN1Y2Nlc3MsICkgPSBtc2cuc2VuZGVyLmNhbGx7dmFsdWU6IDEgZXRoZXJ9KCIiKTsKICAgICAgICByZXF1aXJlKHN1Y2Nlc3MpOwoKICAgICAgICAvLyBJbiBhIHJlZW50cmFudCBmdW5jdGlvbiwgZG9pbmcgdGhpcyBsYXN0IHdvdWxkIG9wZW4gdXAgdGhlIHZ1bG5lcmFiaWxpdHkKICAgICAgICBzZW50R2lmdHNbbXNnLnNlbmRlcl0gPSB0cnVlOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.28;
contract Generosity {
 mapping(address \=> bool) sentGifts;
 bool transient locked;
 modifier nonReentrant {
 require(!locked, "Reentrancy attempt");
 locked \= true;
 \_;
 // Unlocks the guard, making the pattern composable.
 // After the function exits, it can be called again, even in the same transaction.
 locked \= false;
 }
 function claimGift() nonReentrant public {
 require(address(this).balance \>= 1 ether);
 require(!sentGifts\[msg.sender\]);
 (bool success, ) \= msg.sender.call{value: 1 ether}("");
 require(success);
 // In a reentrant function, doing this last would open up the vulnerability
 sentGifts\[msg.sender\] \= true;
 }
}
Transient storage is private to the contract that owns it, in the same way as persistent storage. Only owning contract frames may access their transient storage, and when they do, all the frames access the same transient store.
Transient storage is part of the EVM state and is subject to the same mutability enforcements as persistent storage. As such, any read access to it is not `pure` and writing access is not `view`.
If the `TSTORE` opcode is called within the context of a `STATICCALL`, it will result in an exception instead of performing the modification. `TLOAD` is allowed within the context of a `STATICCALL`.
When transient storage is used in the context of `DELEGATECALL` or `CALLCODE`, then the owning contract of the transient storage is the contract that issued `DELEGATECALL` or `CALLCODE` instruction (the caller) as with persistent storage. When transient storage is used in the context of `CALL` or `STATICCALL`, then the owning contract of the transient storage is the contract that is the target of the `CALL` or `STATICCALL` instruction (the callee).
Note
In the case of `DELEGATECALL`, since references to transient storage variables are currently not supported, it is not possible to pass those into library calls. In libraries, access to transient storage is only possible using inline assembly.
If a frame reverts, all writes to transient storage that took place between entry to the frame and the return are reverted, including those that took place in inner calls. The caller of an external call may employ a `try ... catch` block to prevent reverts bubbling up from the inner calls.
## Composability of Smart Contracts and the Caveats of Transient Storage[](#composability-of-smart-contracts-and-the-caveats-of-transient-storage "Link to this heading")
Given the caveats mentioned in the specification of EIP-1153, in order to preserve the composability of your smart contract, utmost care is recommended for more advanced use cases of transient storage.
For smart contracts, composability is a very important design principle to achieve self-contained behaviour, such that multiple calls into individual smart contracts can be composed to more complex applications. So far the EVM largely guaranteed composable behaviour, since multiple calls into a smart contract within a complex transaction are virtually indistinguishable from multiple calls to the contract stretched over several transactions. However, transient storage allows a violation of this principle, and incorrect use may lead to complex bugs that only surface when used across several calls.
Let’s illustrate the problem with a simple example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjg7Cgpjb250cmFjdCBNdWxTZXJ2aWNlIHsKICAgIHVpbnQgdHJhbnNpZW50IG11bHRpcGxpZXI7CiAgICBmdW5jdGlvbiBzZXRNdWx0aXBsaWVyKHVpbnQgbXVsKSBleHRlcm5hbCB7CiAgICAgICAgbXVsdGlwbGllciA9IG11bDsKICAgIH0KCiAgICBmdW5jdGlvbiBtdWx0aXBseSh1aW50IHZhbHVlKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXR1cm4gdmFsdWUgKiBtdWx0aXBsaWVyOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.28;
contract MulService {
 uint transient multiplier;
 function setMultiplier(uint mul) external {
 multiplier \= mul;
 }
 function multiply(uint value) external view returns (uint) {
 return value \* multiplier;
 }
}
and a sequence of external calls:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=c2V0TXVsdGlwbGllcig0Mik7Cm11bHRpcGx5KDEpOwptdWx0aXBseSgyKTs=)
setMultiplier(42);
multiply(1);
multiply(2);
If the example used memory or storage to store the multiplier, it would be fully composable. It would not matter whether you split the sequence into separate transactions or grouped them in some way. You would always get the same result: after `multiplier` is set to `42`, the subsequent calls would return `42` and `84` respectively. This enables use cases such as batching calls from multiple transactions together to reduce gas costs. Transient storage potentially breaks such use cases since composability can no longer be taken for granted. In the example, if the calls are not executed in the same transaction, then `multiplier` is reset and the next calls to function `multiply` would always return `0`.
As another example, since transient storage is constructed as a relatively cheap key-value store, a smart contract author may be tempted to use transient storage as a replacement for in-memory mappings without keeping track of the modified keys in the mapping and thereby without clearing the mapping at the end of the call. This, however, can easily lead to unexpected behaviour in complex transactions, in which values set by a previous call into the contract within the same transaction remain.
The use of transient storage for reentrancy locks that are cleared at the end of the call frame into the contract, is safe. However, be sure to resist the temptation to save the 100 gas used for resetting the reentrancy lock, since failing to do so, will restrict your contract to only one call within a transaction, preventing its use in complex composed transactions, which have been a cornerstone for complex applications on chain.
It is recommend to generally always clear transient storage completely at the end of a call into your smart contract to avoid these kinds of issues and to simplify the analysis of the behaviour of your contract within complex transactions. Check the [Security Considerations section of EIP-1153](https://eips.ethereum.org/EIPS/eip-1153#security-considerations) for further details.
## Constant and Immutable State Variables[](#constant-and-immutable-state-variables "Link to this heading")
State variables can be declared as `constant` or `immutable`. In both cases, the variables cannot be modified after the contract has been constructed. For `constant` variables, the value has to be fixed at compile-time, while for `immutable`, it can still be assigned at construction time.
It is also possible to define `constant` variables at the file level.
Every occurrence of such a variable in the source is replaced by its underlying value and the compiler does not reserve a storage slot for it. It cannot be assigned a slot in transient storage using the `transient` keyword either.
Compared to regular state variables, the gas costs of constant and immutable variables are much lower. For a constant variable, the expression assigned to it is copied to all the places where it is accessed and also re-evaluated each time. This allows for local optimizations. Immutable variables are evaluated once at construction time and their value is copied to all the places in the code where they are accessed. For these values, 32 bytes are reserved, even if they would fit in fewer bytes. Due to this, constant values can sometimes be cheaper than immutable values.
Not all types for constants and immutables are implemented at this time. The only supported types are [strings](https://docs.soliditylang.org/en/v0.8.30/types.html#strings) (only for constants) and [value types](https://docs.soliditylang.org/en/v0.8.30/types.html#value-types).
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjE7Cgp1aW50IGNvbnN0YW50IFggPSAzMioqMjIgKyA4OwoKY29udHJhY3QgQyB7CiAgICBzdHJpbmcgY29uc3RhbnQgVEVYVCA9ICJhYmMiOwogICAgYnl0ZXMzMiBjb25zdGFudCBNWV9IQVNIID0ga2VjY2FrMjU2KCJhYmMiKTsKICAgIHVpbnQgaW1tdXRhYmxlIGRlY2ltYWxzID0gMTg7CiAgICB1aW50IGltbXV0YWJsZSBtYXhCYWxhbmNlOwogICAgYWRkcmVzcyBpbW11dGFibGUgb3duZXIgPSBtc2cuc2VuZGVyOwoKICAgIGNvbnN0cnVjdG9yKHVpbnQgZGVjaW1hbHNfLCBhZGRyZXNzIHJlZikgewogICAgICAgIGlmIChkZWNpbWFsc18gIT0gMCkKICAgICAgICAgICAgLy8gSW1tdXRhYmxlcyBhcmUgb25seSBpbW11dGFibGUgd2hlbiBkZXBsb3llZC4KICAgICAgICAgICAgLy8gQXQgY29uc3RydWN0aW9uIHRpbWUgdGhleSBjYW4gYmUgYXNzaWduZWQgdG8gYW55IG51bWJlciBvZiB0aW1lcy4KICAgICAgICAgICAgZGVjaW1hbHMgPSBkZWNpbWFsc187CgogICAgICAgIC8vIEFzc2lnbm1lbnRzIHRvIGltbXV0YWJsZXMgY2FuIGV2ZW4gYWNjZXNzIHRoZSBlbnZpcm9ubWVudC4KICAgICAgICBtYXhCYWxhbmNlID0gcmVmLmJhbGFuY2U7CiAgICB9CgogICAgZnVuY3Rpb24gaXNCYWxhbmNlVG9vSGlnaChhZGRyZXNzIG90aGVyKSBwdWJsaWMgdmlldyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmV0dXJuIG90aGVyLmJhbGFuY2UgPiBtYXhCYWxhbmNlOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.21;
uint constant X \= 32\*\*22 + 8;
contract C {
 string constant TEXT \= "abc";
 bytes32 constant MY\_HASH \= keccak256("abc");
 uint immutable decimals \= 18;
 uint immutable maxBalance;
 address immutable owner \= msg.sender;
 constructor(uint decimals\_, address ref) {
 if (decimals\_ != 0)
 // Immutables are only immutable when deployed.
 // At construction time they can be assigned to any number of times.
 decimals \= decimals\_;
 // Assignments to immutables can even access the environment.
 maxBalance \= ref.balance;
 }
 function isBalanceTooHigh(address other) public view returns (bool) {
 return other.balance \> maxBalance;
 }
}
### Constant[](#constant "Link to this heading")
For `constant` variables, the value has to be a constant at compile time and it has to be assigned where the variable is declared. Any expression that accesses storage, blockchain data (e.g. `block.timestamp`, `address(this).balance` or `block.number`) or execution data (`msg.value` or `gasleft()`) or makes calls to external contracts is disallowed. Expressions that might have a side-effect on memory allocation are allowed, but those that might have a side-effect on other memory objects are not. The built-in functions `keccak256`, `sha256`, `ripemd160`, `ecrecover`, `addmod` and `mulmod` are allowed (even though, with the exception of `keccak256`, they do call external contracts).
The reason behind allowing side-effects on the memory allocator is that it should be possible to construct complex objects like e.g. lookup-tables. This feature is not yet fully usable.
### Immutable[](#immutable "Link to this heading")
Variables declared as `immutable` are a bit less restricted than those declared as `constant`: Immutable variables can be assigned a value at construction time. The value can be changed at any time before deployment and then it becomes permanent.
One additional restriction is that immutables can only be assigned to inside expressions for which there is no possibility of being executed after creation. This excludes all modifier definitions and functions other than constructors.
There are no restrictions on reading immutable variables. The read is even allowed to happen before the variable is written to for the first time because variables in Solidity always have a well-defined initial value. For this reason it is also allowed to never explicitly assign a value to an immutable.
Warning
When accessing immutables at construction time, please keep the [initialization order](https://docs.soliditylang.org/en/v0.8.30/ir-breaking-changes.html#state-variable-initialization-order) in mind. Even if you provide an explicit initializer, some expressions may end up being evaluated before that initializer, especially when they are at a different level in inheritance hierarchy.
Note
Before Solidity 0.8.21 initialization of immutable variables was more restrictive. Such variables had to be initialized exactly once at construction time and could not be read before then.
The contract creation code generated by the compiler will modify the contract’s runtime code before it is returned by replacing all references to immutables with the values assigned to them. This is important if you are comparing the runtime code generated by the compiler with the one actually stored in the blockchain. The compiler outputs where these immutables are located in the deployed bytecode in the `immutableReferences` field of the [compiler JSON standard output](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#compiler-api).
## Custom Storage Layout[](#custom-storage-layout "Link to this heading")
A contract can define an arbitrary location for its storage using the `layout` specifier. The contract’s state variables, including those inherited from base contracts, start from the specified base slot instead of the default slot zero.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjk7Cgpjb250cmFjdCBDIGxheW91dCBhdCAweEFBQUEgKyAweDExIHsKICAgIHVpbnRbM10geDsgLy8gT2NjdXBpZXMgc2xvdHMgMHhBQUJCLi4weEFBQkQKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.29;
contract C layout at 0xAAAA + 0x11 {
 uint\[3\] x; // Occupies slots 0xAABB..0xAABD
}
As the above example shows, the specifier uses the `layout at <base-slot-expression>` syntax and is located in the header of a contract definition.
The layout specifier can be placed either before or after the inheritance specifier, and can appear at most once. The `base-slot-expression` must be an [integer literal](https://docs.soliditylang.org/en/v0.8.30/types.html#rational-literals) expression that can be evaluated at compilation time and yields a value in the range of `uint256`.
A custom layout cannot make contract’s storage “wrap around”. If the selected base slot would push the static variables past the end of storage, the compiler will issue an error. Note that the data areas of dynamic arrays and mappings are not affected by this check because their layout is not linear. Regardless of the base slot used, their locations are calculated in a way that always puts them within the range of `uint256` and their sizes are not known at compilation time.
While there are no other limits placed on the base slot, it is recommended to avoid locations that are too close to the end of the address space. Leaving too little space may complicate contract upgrades or cause problems for contracts that store additional values past their allocated space using inline assembly.
The storage layout can only be specified for the topmost contract of an inheritance tree, and affects locations of all the storage variables in all the contracts in that tree. Variables are laid out according to the order of their definitions and the positions of their contracts in the [linearized inheritance hierarchy](#multi-inheritance) and a custom base slot preserves their relative positions, shifting them all by the same amount.
The storage layout cannot be specified for abstract contracts, interfaces and libraries. Also, it is important to note that it does _not_ affect transient state variables.
For details about storage layout and the effect of the layout specifier on it see [layout of storage variables](https://docs.soliditylang.org/en/v0.8.30/internals/layout_in_storage.html#storage-inplace-encoding).
Warning
The identifiers `layout` and `at` are not yet reserved as keywords in the language. It is strongly recommended to avoid using them since they will become reserved in a future breaking release.
## Functions[](#functions "Link to this heading")
Functions can be defined inside and outside of contracts.
Functions outside of a contract, also called “free functions”, always have implicit `internal` [visibility](#visibility-and-getters). Their code is included in all contracts that call them, similar to internal library functions.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKZnVuY3Rpb24gc3VtKHVpbnRbXSBtZW1vcnkgYXJyKSBwdXJlIHJldHVybnMgKHVpbnQgcykgewogICAgZm9yICh1aW50IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKQogICAgICAgIHMgKz0gYXJyW2ldOwp9Cgpjb250cmFjdCBBcnJheUV4YW1wbGUgewogICAgYm9vbCBmb3VuZDsKICAgIGZ1bmN0aW9uIGYodWludFtdIG1lbW9yeSBhcnIpIHB1YmxpYyB7CiAgICAgICAgLy8gVGhpcyBjYWxscyB0aGUgZnJlZSBmdW5jdGlvbiBpbnRlcm5hbGx5LgogICAgICAgIC8vIFRoZSBjb21waWxlciB3aWxsIGFkZCBpdHMgY29kZSB0byB0aGUgY29udHJhY3QuCiAgICAgICAgdWludCBzID0gc3VtKGFycik7CiAgICAgICAgcmVxdWlyZShzID49IDEwKTsKICAgICAgICBmb3VuZCA9IHRydWU7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.1 <0.9.0;
function sum(uint\[\] memory arr) pure returns (uint s) {
 for (uint i \= 0; i < arr.length; i++)
 s += arr\[i\];
}
contract ArrayExample {
 bool found;
 function f(uint\[\] memory arr) public {
 // This calls the free function internally.
 // The compiler will add its code to the contract.
 uint s \= sum(arr);
 require(s \>= 10);
 found \= true;
 }
}
Note
Functions defined outside a contract are still always executed in the context of a contract. They still can call other contracts, send them Ether and destroy the contract that called them, among other things. The main difference to functions defined inside a contract is that free functions do not have direct access to the variable `this`, storage variables and functions not in their scope.
### Function Parameters and Return Variables[](#function-parameters-and-return-variables "Link to this heading")
Functions take typed parameters as input and may, unlike in many other languages, also return an arbitrary number of values as output.
#### Function Parameters[](#function-parameters "Link to this heading")
Function parameters are declared the same way as variables, and the name of unused parameters can be omitted.
For example, if you want your contract to accept one kind of external call with two integers, you would use something like the following:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICB1aW50IHN1bTsKICAgIGZ1bmN0aW9uIHRha2VyKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgewogICAgICAgIHN1bSA9IGEgKyBiOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract Simple {
 uint sum;
 function taker(uint a, uint b) public {
 sum \= a + b;
 }
}
Function parameters can be used as any other local variable and they can also be assigned to.
#### Return Variables[](#return-variables "Link to this heading")
Function return variables are declared with the same syntax after the `returns` keyword.
For example, suppose you want to return two results: the sum and the product of two integers passed as function parameters, then you use something like:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICBmdW5jdGlvbiBhcml0aG1ldGljKHVpbnQgYSwgdWludCBiKQogICAgICAgIHB1YmxpYwogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50IHN1bSwgdWludCBwcm9kdWN0KQogICAgewogICAgICAgIHN1bSA9IGEgKyBiOwogICAgICAgIHByb2R1Y3QgPSBhICogYjsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract Simple {
 function arithmetic(uint a, uint b)
 public
 pure
 returns (uint sum, uint product)
 {
 sum \= a + b;
 product \= a \* b;
 }
}
The names of return variables can be omitted. Return variables can be used as any other local variable and they are initialized with their [default value](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#default-value) and have that value until they are (re-)assigned.
You can either explicitly assign to return variables and then leave the function as above, or you can provide return values (either a single or [multiple ones](#multi-return)) directly with the `return` statement:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICBmdW5jdGlvbiBhcml0aG1ldGljKHVpbnQgYSwgdWludCBiKQogICAgICAgIHB1YmxpYwogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50IHN1bSwgdWludCBwcm9kdWN0KQogICAgewogICAgICAgIHJldHVybiAoYSArIGIsIGEgKiBiKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract Simple {
 function arithmetic(uint a, uint b)
 public
 pure
 returns (uint sum, uint product)
 {
 return (a + b, a \* b);
 }
}
If you use an early `return` to leave a function that has return variables, you must provide return values together with the return statement.
Note
You cannot return some types from non-internal functions. This includes the types listed below and any composite types that recursively contain them:
* mappings,
 
* internal function types,
 
* reference types with location set to `storage`,
 
* multi-dimensional arrays (applies only to [ABI coder v1](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#abi-coder)),
 
* structs (applies only to [ABI coder v1](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#abi-coder)).
 
This restriction does not apply to library functions because of their different [internal ABI](#library-selectors).
#### Returning Multiple Values[](#returning-multiple-values "Link to this heading")
When a function has multiple return types, the statement `return (v0, v1, ..., vn)` can be used to return multiple values. The number of components must be the same as the number of return variables and their types have to match, potentially after an [implicit conversion](https://docs.soliditylang.org/en/v0.8.30/types.html#types-conversion-elementary-types).
### State Mutability[](#state-mutability "Link to this heading")
#### View Functions[](#view-functions "Link to this heading")
Functions can be declared `view` in which case they promise not to modify the state.
Note
If the compiler’s EVM target is Byzantium or newer (default) the opcode `STATICCALL` is used when `view` functions are called, which enforces the state to stay unmodified as part of the EVM execution. For library `view` functions `DELEGATECALL` is used, because there is no combined `DELEGATECALL` and `STATICCALL`. This means library `view` functions do not have run-time checks that prevent state modifications. This should not impact security negatively because library code is usually known at compile-time and the static checker performs compile-time checks.
The following statements are considered modifying the state:
1. Writing to state variables (storage and transient storage).
 
2. [Emitting events](#events).
 
3. [Creating other contracts](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#creating-contracts).
 
4. Using `selfdestruct`.
 
5. Sending Ether via calls.
 
6. Calling any function not marked `view` or `pure`.
 
7. Using low-level calls.
 
8. Using inline assembly that contains certain opcodes.
 
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgKiAoYiArIDQyKSArIGJsb2NrLnRpbWVzdGFtcDsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
contract C {
 function f(uint a, uint b) public view returns (uint) {
 return a \* (b + 42) + block.timestamp;
 }
}
Note
`constant` on functions used to be an alias to `view`, but this was dropped in version 0.5.0.
Note
Getter methods are automatically marked `view`.
Note
Prior to version 0.5.0, the compiler did not use the `STATICCALL` opcode for `view` functions. This enabled state modifications in `view` functions through the use of invalid explicit type conversions. By using `STATICCALL` for `view` functions, modifications to the state are prevented on the level of the EVM.
#### Pure Functions[](#pure-functions "Link to this heading")
Functions can be declared `pure` in which case they promise not to read from or modify the state. In particular, it should be possible to evaluate a `pure` function at compile-time given only its inputs and `msg.data`, but without any knowledge of the current blockchain state. This means that reading from `immutable` variables can be a non-pure operation.
Note
If the compiler’s EVM target is Byzantium or newer (default) the opcode `STATICCALL` is used, which does not guarantee that the state is not read, but at least that it is not modified.
In addition to the list of state modifying statements explained above, the following are considered reading from the state:
1. Reading from state variables (storage and transient storage).
 
2. Accessing `address(this).balance` or `<address>.balance`.
 
3. Accessing any of the members of `block`, `tx`, `msg` (with the exception of `msg.sig` and `msg.data`).
 
4. Calling any function not marked `pure`.
 
5. Using inline assembly that contains certain opcodes.
 
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgKiAoYiArIDQyKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
contract C {
 function f(uint a, uint b) public pure returns (uint) {
 return a \* (b + 42);
 }
}
Pure functions are able to use the `revert()` and `require()` functions to revert potential state changes when an [error occurs](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#assert-and-require).
Reverting a state change is not considered a “state modification”, as only changes to the state made previously in code that did not have the `view` or `pure` restriction are reverted and that code has the option to catch the `revert` and not pass it on.
This behavior is also in line with the `STATICCALL` opcode.
Warning
It is not possible to prevent functions from reading the state at the level of the EVM, it is only possible to prevent them from writing to the state (i.e. only `view` can be enforced at the EVM level, `pure` can not).
Note
Prior to version 0.5.0, the compiler did not use the `STATICCALL` opcode for `pure` functions. This enabled state modifications in `pure` functions through the use of invalid explicit type conversions. By using `STATICCALL` for `pure` functions, modifications to the state are prevented on the level of the EVM.
Note
Prior to version 0.4.17 the compiler did not enforce that `pure` is not reading the state. It is a compile-time type check, which can be circumvented by doing invalid explicit conversions between contract types, because the compiler can verify that the type of the contract does not do state-changing operations, but it cannot check that the contract that will be called at runtime is actually of that type.
### Special Functions[](#special-functions "Link to this heading")
#### Receive Ether Function[](#receive-ether-function "Link to this heading")
A contract can have at most one `receive` function, declared using `receive() external payable { ... }` (without the `function` keyword). This function cannot have arguments, cannot return anything and must have `external` visibility and `payable` state mutability. It can be virtual, can override and can have modifiers.
The receive function is executed on a call to the contract with empty calldata. This is the function that is executed on plain Ether transfers (e.g. via `.send()` or `.transfer()`). If no such function exists, but a payable [fallback function](#fallback-function) exists, the fallback function will be called on a plain Ether transfer. If neither a receive Ether nor a payable fallback function is present, the contract cannot receive Ether through a transaction that does not represent a payable function call and throws an exception.
In the worst case, the `receive` function can only rely on 2300 gas being available (for example when `send` or `transfer` is used), leaving little room to perform other operations except basic logging. The following operations will consume more gas than the 2300 gas stipend:
* Writing to storage
 
* Creating a contract
 
* Calling an external function which consumes a large amount of gas
 
* Sending Ether
 
Warning
When Ether is sent directly to a contract (without a function call, i.e. sender uses `send` or `transfer`) but the receiving contract does not define a receive Ether function or a payable fallback function, an exception will be thrown, sending back the Ether (this was different before Solidity v0.4.0). If you want your contract to receive Ether, you have to implement a receive Ether function (using payable fallback functions for receiving Ether is not recommended, since the fallback is invoked and would not fail for interface confusions on the part of the sender).
Warning
A contract without a receive Ether function can receive Ether as a recipient of a _coinbase transaction_ (aka _miner block reward_) or as a destination of a `selfdestruct`.
A contract cannot react to such Ether transfers and thus also cannot reject them. This is a design choice of the EVM and Solidity cannot work around it.
It also means that `address(this).balance` can be higher than the sum of some manual accounting implemented in a contract (i.e. having a counter updated in the receive Ether function).
Below you can see an example of a Sink contract that uses function `receive`.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKLy8gVGhpcyBjb250cmFjdCBrZWVwcyBhbGwgRXRoZXIgc2VudCB0byBpdCB3aXRoIG5vIHdheQovLyB0byBnZXQgaXQgYmFjay4KY29udHJhY3QgU2luayB7CiAgICBldmVudCBSZWNlaXZlZChhZGRyZXNzLCB1aW50KTsKICAgIHJlY2VpdmUoKSBleHRlcm5hbCBwYXlhYmxlIHsKICAgICAgICBlbWl0IFJlY2VpdmVkKG1zZy5zZW5kZXIsIG1zZy52YWx1ZSk7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
// This contract keeps all Ether sent to it with no way
// to get it back.
contract Sink {
 event Received(address, uint);
 receive() external payable {
 emit Received(msg.sender, msg.value);
 }
}
#### Fallback Function[](#fallback-function "Link to this heading")
A contract can have at most one `fallback` function, declared using either `fallback () external [payable]` or `fallback (bytes calldata input) external [payable] returns (bytes memory output)` (both without the `function` keyword). This function must have `external` visibility. A fallback function can be virtual, can override and can have modifiers.
The fallback function is executed on a call to the contract if none of the other functions match the given function signature, or if no data was supplied at all and there is no [receive Ether function](#receive-ether-function). The fallback function always receives data, but in order to also receive Ether it must be marked `payable`.
If the version with parameters is used, `input` will contain the full data sent to the contract (equal to `msg.data`) and can return data in `output`. The returned data will not be ABI-encoded. Instead it will be returned without modifications (not even padding).
In the worst case, if a payable fallback function is also used in place of a receive function, it can only rely on 2300 gas being available (see [receive Ether function](#receive-ether-function) for a brief description of the implications of this).
Like any function, the fallback function can execute complex operations as long as there is enough gas passed on to it.
Warning
A `payable` fallback function is also executed for plain Ether transfers, if no [receive Ether function](#receive-ether-function) is present. It is recommended to always define a receive Ether function as well, if you define a payable fallback function to distinguish Ether transfers from interface confusions.
Note
If you want to decode the input data, you can check the first four bytes for the function selector and then you can use `abi.decode` together with the array slice syntax to decode ABI-encoded data: `(c, d) = abi.decode(input[4:], (uint256, uint256));` Note that this should only be used as a last resort and proper functions should be used instead.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKY29udHJhY3QgVGVzdCB7CiAgICB1aW50IHg7CiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgYWxsIG1lc3NhZ2VzIHNlbnQgdG8KICAgIC8vIHRoaXMgY29udHJhY3QgKHRoZXJlIGlzIG5vIG90aGVyIGZ1bmN0aW9uKS4KICAgIC8vIFNlbmRpbmcgRXRoZXIgdG8gdGhpcyBjb250cmFjdCB3aWxsIGNhdXNlIGFuIGV4Y2VwdGlvbiwKICAgIC8vIGJlY2F1c2UgdGhlIGZhbGxiYWNrIGZ1bmN0aW9uIGRvZXMgbm90IGhhdmUgdGhlIGBwYXlhYmxlYAogICAgLy8gbW9kaWZpZXIuCiAgICBmYWxsYmFjaygpIGV4dGVybmFsIHsgeCA9IDE7IH0KfQoKY29udHJhY3QgVGVzdFBheWFibGUgewogICAgdWludCB4OwogICAgdWludCB5OwogICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGFsbCBtZXNzYWdlcyBzZW50IHRvCiAgICAvLyB0aGlzIGNvbnRyYWN0LCBleGNlcHQgcGxhaW4gRXRoZXIgdHJhbnNmZXJzCiAgICAvLyAodGhlcmUgaXMgbm8gb3RoZXIgZnVuY3Rpb24gZXhjZXB0IHRoZSByZWNlaXZlIGZ1bmN0aW9uKS4KICAgIC8vIEFueSBjYWxsIHdpdGggbm9uLWVtcHR5IGNhbGxkYXRhIHRvIHRoaXMgY29udHJhY3Qgd2lsbCBleGVjdXRlCiAgICAvLyB0aGUgZmFsbGJhY2sgZnVuY3Rpb24gKGV2ZW4gaWYgRXRoZXIgaXMgc2VudCBhbG9uZyB3aXRoIHRoZSBjYWxsKS4KICAgIGZhbGxiYWNrKCkgZXh0ZXJuYWwgcGF5YWJsZSB7IHggPSAxOyB5ID0gbXNnLnZhbHVlOyB9CgogICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIHBsYWluIEV0aGVyIHRyYW5zZmVycywgaS5lLgogICAgLy8gZm9yIGV2ZXJ5IGNhbGwgd2l0aCBlbXB0eSBjYWxsZGF0YS4KICAgIHJlY2VpdmUoKSBleHRlcm5hbCBwYXlhYmxlIHsgeCA9IDI7IHkgPSBtc2cudmFsdWU7IH0KfQoKY29udHJhY3QgQ2FsbGVyIHsKICAgIGZ1bmN0aW9uIGNhbGxUZXN0KFRlc3QgdGVzdCkgcHVibGljIHJldHVybnMgKGJvb2wpIHsKICAgICAgICAoYm9vbCBzdWNjZXNzLCkgPSBhZGRyZXNzKHRlc3QpLmNhbGwoYWJpLmVuY29kZVdpdGhTaWduYXR1cmUoIm5vbkV4aXN0aW5nRnVuY3Rpb24oKSIpKTsKICAgICAgICByZXF1aXJlKHN1Y2Nlc3MpOwogICAgICAgIC8vIHJlc3VsdHMgaW4gdGVzdC54IGJlY29taW5nID09IDEuCgogICAgICAgIC8vIGFkZHJlc3ModGVzdCkgd2lsbCBub3QgYWxsb3cgdG8gY2FsbCBgYHNlbmRgYCBkaXJlY3RseSwgc2luY2UgYGB0ZXN0YGAgaGFzIG5vIHBheWFibGUKICAgICAgICAvLyBmYWxsYmFjayBmdW5jdGlvbi4KICAgICAgICAvLyBJdCBoYXMgdG8gYmUgY29udmVydGVkIHRvIHRoZSBgYGFkZHJlc3MgcGF5YWJsZWBgIHR5cGUgdG8gZXZlbiBhbGxvdyBjYWxsaW5nIGBgc2VuZGBgIG9uIGl0LgogICAgICAgIGFkZHJlc3MgcGF5YWJsZSB0ZXN0UGF5YWJsZSA9IHBheWFibGUoYWRkcmVzcyh0ZXN0KSk7CgogICAgICAgIC8vIElmIHNvbWVvbmUgc2VuZHMgRXRoZXIgdG8gdGhhdCBjb250cmFjdCwKICAgICAgICAvLyB0aGUgdHJhbnNmZXIgd2lsbCBmYWlsLCBpLmUuIHRoaXMgcmV0dXJucyBmYWxzZSBoZXJlLgogICAgICAgIHJldHVybiB0ZXN0UGF5YWJsZS5zZW5kKDIgZXRoZXIpOwogICAgfQoKICAgIGZ1bmN0aW9uIGNhbGxUZXN0UGF5YWJsZShUZXN0UGF5YWJsZSB0ZXN0KSBwdWJsaWMgcmV0dXJucyAoYm9vbCkgewogICAgICAgIChib29sIHN1Y2Nlc3MsKSA9IGFkZHJlc3ModGVzdCkuY2FsbChhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgibm9uRXhpc3RpbmdGdW5jdGlvbigpIikpOwogICAgICAgIHJlcXVpcmUoc3VjY2Vzcyk7CiAgICAgICAgLy8gcmVzdWx0cyBpbiB0ZXN0LnggYmVjb21pbmcgPT0gMSBhbmQgdGVzdC55IGJlY29taW5nIDAuCiAgICAgICAgKHN1Y2Nlc3MsKSA9IGFkZHJlc3ModGVzdCkuY2FsbHt2YWx1ZTogMX0oYWJpLmVuY29kZVdpdGhTaWduYXR1cmUoIm5vbkV4aXN0aW5nRnVuY3Rpb24oKSIpKTsKICAgICAgICByZXF1aXJlKHN1Y2Nlc3MpOwogICAgICAgIC8vIHJlc3VsdHMgaW4gdGVzdC54IGJlY29taW5nID09IDEgYW5kIHRlc3QueSBiZWNvbWluZyAxLgoKICAgICAgICAvLyBJZiBzb21lb25lIHNlbmRzIEV0aGVyIHRvIHRoYXQgY29udHJhY3QsIHRoZSByZWNlaXZlIGZ1bmN0aW9uIGluIFRlc3RQYXlhYmxlIHdpbGwgYmUgY2FsbGVkLgogICAgICAgIC8vIFNpbmNlIHRoYXQgZnVuY3Rpb24gd3JpdGVzIHRvIHN0b3JhZ2UsIGl0IHRha2VzIG1vcmUgZ2FzIHRoYW4gaXMgYXZhaWxhYmxlIHdpdGggYQogICAgICAgIC8vIHNpbXBsZSBgYHNlbmRgYCBvciBgYHRyYW5zZmVyYGAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgaGF2ZSB0byB1c2UgYSBsb3ctbGV2ZWwgY2FsbC4KICAgICAgICAoc3VjY2VzcywpID0gYWRkcmVzcyh0ZXN0KS5jYWxse3ZhbHVlOiAyIGV0aGVyfSgiIik7CiAgICAgICAgcmVxdWlyZShzdWNjZXNzKTsKICAgICAgICAvLyByZXN1bHRzIGluIHRlc3QueCBiZWNvbWluZyA9PSAyIGFuZCB0ZXN0LnkgYmVjb21pbmcgMiBldGhlci4KCiAgICAgICAgcmV0dXJuIHRydWU7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.2 <0.9.0;
contract Test {
 uint x;
 // This function is called for all messages sent to
 // this contract (there is no other function).
 // Sending Ether to this contract will cause an exception,
 // because the fallback function does not have the \`payable\`
 // modifier.
 fallback() external { x \= 1; }
}
contract TestPayable {
 uint x;
 uint y;
 // This function is called for all messages sent to
 // this contract, except plain Ether transfers
 // (there is no other function except the receive function).
 // Any call with non-empty calldata to this contract will execute
 // the fallback function (even if Ether is sent along with the call).
 fallback() external payable { x \= 1; y \= msg.value; }
 // This function is called for plain Ether transfers, i.e.
 // for every call with empty calldata.
 receive() external payable { x \= 2; y \= msg.value; }
}
contract Caller {
 function callTest(Test test) public returns (bool) {
 (bool success,) \= address(test).call(abi.encodeWithSignature("nonExistingFunction()"));
 require(success);
 // results in test.x becoming == 1.
 // address(test) will not allow to call \`\`send\`\` directly, since \`\`test\`\` has no payable
 // fallback function.
 // It has to be converted to the \`\`address payable\`\` type to even allow calling \`\`send\`\` on it.
 address payable testPayable \= payable(address(test));
 // If someone sends Ether to that contract,
 // the transfer will fail, i.e. this returns false here.
 return testPayable.send(2 ether);
 }
 function callTestPayable(TestPayable test) public returns (bool) {
 (bool success,) \= address(test).call(abi.encodeWithSignature("nonExistingFunction()"));
 require(success);
 // results in test.x becoming == 1 and test.y becoming 0.
 (success,) \= address(test).call{value: 1}(abi.encodeWithSignature("nonExistingFunction()"));
 require(success);
 // results in test.x becoming == 1 and test.y becoming 1.
 // If someone sends Ether to that contract, the receive function in TestPayable will be called.
 // Since that function writes to storage, it takes more gas than is available with a
 // simple \`\`send\`\` or \`\`transfer\`\`. Because of that, we have to use a low-level call.
 (success,) \= address(test).call{value: 2 ether}("");
 require(success);
 // results in test.x becoming == 2 and test.y becoming 2 ether.
 return true;
 }
}
### Function Overloading[](#function-overloading "Link to this heading")
A contract can have multiple functions of the same name but with different parameter types. This process is called “overloading” and also applies to inherited functions. The following example shows overloading of the function `f` in the scope of contract `A`.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEEgewogICAgZnVuY3Rpb24gZih1aW50IHZhbHVlKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IG91dCkgewogICAgICAgIG91dCA9IHZhbHVlOwogICAgfQoKICAgIGZ1bmN0aW9uIGYodWludCB2YWx1ZSwgYm9vbCByZWFsbHkpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQgb3V0KSB7CiAgICAgICAgaWYgKHJlYWxseSkKICAgICAgICAgICAgb3V0ID0gdmFsdWU7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract A {
 function f(uint value) public pure returns (uint out) {
 out \= value;
 }
 function f(uint value, bool really) public pure returns (uint out) {
 if (really)
 out \= value;
 }
}
Overloaded functions are also present in the external interface. It is an error if two externally visible functions differ by their Solidity types but not by their external types.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCi8vIFRoaXMgd2lsbCBub3QgY29tcGlsZQpjb250cmFjdCBBIHsKICAgIGZ1bmN0aW9uIGYoQiB2YWx1ZSkgcHVibGljIHB1cmUgcmV0dXJucyAoQiBvdXQpIHsKICAgICAgICBvdXQgPSB2YWx1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBmKGFkZHJlc3MgdmFsdWUpIHB1YmxpYyBwdXJlIHJldHVybnMgKGFkZHJlc3Mgb3V0KSB7CiAgICAgICAgb3V0ID0gdmFsdWU7CiAgICB9Cn0KCmNvbnRyYWN0IEIgewp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
// This will not compile
contract A {
 function f(B value) public pure returns (B out) {
 out \= value;
 }
 function f(address value) public pure returns (address out) {
 out \= value;
 }
}
contract B {
}
Both `f` function overloads above end up accepting the address type for the ABI although they are considered different inside Solidity.
#### Overload resolution and Argument matching[](#overload-resolution-and-argument-matching "Link to this heading")
Overloaded functions are selected by matching the function declarations in the current scope to the arguments supplied in the function call. Functions are selected as overload candidates if all arguments can be implicitly converted to the expected types. If there is not exactly one candidate, resolution fails.
Note
Return parameters are not taken into account for overload resolution.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEEgewogICAgZnVuY3Rpb24gZih1aW50OCB2YWwpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQ4IG91dCkgewogICAgICAgIG91dCA9IHZhbDsKICAgIH0KCiAgICBmdW5jdGlvbiBmKHVpbnQyNTYgdmFsKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50MjU2IG91dCkgewogICAgICAgIG91dCA9IHZhbDsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
contract A {
 function f(uint8 val) public pure returns (uint8 out) {
 out \= val;
 }
 function f(uint256 val) public pure returns (uint256 out) {
 out \= val;
 }
}
Calling `f(50)` would create a type error since `50` can be implicitly converted both to `uint8` and `uint256` types. On another hand `f(256)` would resolve to `f(uint256)` overload as `256` cannot be implicitly converted to `uint8`.
## Events[](#events "Link to this heading")
Solidity events give an abstraction on top of the EVM’s logging functionality. Applications can subscribe and listen to these events through the RPC interface of an Ethereum client.
Events can be defined at file level or as inheritable members of contracts (including interfaces and libraries). When you call them, they cause the arguments to be stored in the transaction’s log - a special data structure in the blockchain. These logs are associated with the address of the contract that emitted them, are incorporated into the blockchain, and stay there as long as a block is accessible (forever as of now, but this might change in the future). The Log and its event data are not accessible from within contracts (not even from the contract that created them).
It is possible to request a Merkle proof for logs, so if an external entity supplies a contract with such a proof, it can check that the log actually exists inside the blockchain. You have to supply block headers because the contract can only see the last 256 block hashes.
You can add the attribute `indexed` to up to three parameters which adds them to a special data structure known as [“topics”](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#abi-events) instead of the data part of the log. A topic can only hold a single word (32 bytes) so if you use a [reference type](https://docs.soliditylang.org/en/v0.8.30/types.html#reference-types) for an indexed argument, the Keccak-256 hash of the value is stored as a topic instead.
All parameters without the `indexed` attribute are [ABI-encoded](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#abi) into the data part of the log.
Topics allow you to search for events, for example when filtering a sequence of blocks for certain events. You can also filter events by the address of the contract that emitted the event.
For example, the code below uses the web3.js `subscribe("logs")` [method](https://web3js.readthedocs.io/en/1.0/web3-eth-subscribe.html#subscribe-logs) to filter logs that match a topic with a certain address value:
var options \= {
 fromBlock: 0,
 address: web3.eth.defaultAccount,
 topics: \["0x0000000000000000000000000000000000000000000000000000000000000000", null, null\]
};
web3.eth.subscribe('logs', options, function (error, result) {
 if (!error)
 console.log(result);
})
 .on("data", function (log) {
 console.log(log);
 })
 .on("changed", function (log) {
});
The hash of the signature of the event is one of the topics, except if you declared the event with the `anonymous` specifier. This means that it is not possible to filter for specific anonymous events by name, you can only filter by the contract address. The advantage of anonymous events is that they are cheaper to deploy and call. It also allows you to declare four indexed arguments rather than three.
Note
Since the transaction log only stores the event data and not the type, you have to know the type of the event, including which parameter is indexed and if the event is anonymous in order to correctly interpret the data. In particular, it is possible to “fake” the signature of another event using an anonymous event.
### Members of Events[](#members-of-events "Link to this heading")
* `event.selector`: For non-anonymous events, this is a `bytes32` value containing the `keccak256` hash of the event signature, as used in the default topic.
 
### Example[](#example "Link to this heading")
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIxIDwwLjkuMDsKCmNvbnRyYWN0IENsaWVudFJlY2VpcHQgewogICAgZXZlbnQgRGVwb3NpdCgKICAgICAgICBhZGRyZXNzIGluZGV4ZWQgZnJvbSwKICAgICAgICBieXRlczMyIGluZGV4ZWQgaWQsCiAgICAgICAgdWludCB2YWx1ZQogICAgKTsKCiAgICBmdW5jdGlvbiBkZXBvc2l0KGJ5dGVzMzIgaWQpIHB1YmxpYyBwYXlhYmxlIHsKICAgICAgICAvLyBFdmVudHMgYXJlIGVtaXR0ZWQgdXNpbmcgYGVtaXRgLCBmb2xsb3dlZCBieQogICAgICAgIC8vIHRoZSBuYW1lIG9mIHRoZSBldmVudCBhbmQgdGhlIGFyZ3VtZW50cwogICAgICAgIC8vIChpZiBhbnkpIGluIHBhcmVudGhlc2VzLiBBbnkgc3VjaCBpbnZvY2F0aW9uCiAgICAgICAgLy8gKGV2ZW4gZGVlcGx5IG5lc3RlZCkgY2FuIGJlIGRldGVjdGVkIGZyb20KICAgICAgICAvLyB0aGUgSmF2YVNjcmlwdCBBUEkgYnkgZmlsdGVyaW5nIGZvciBgRGVwb3NpdGAuCiAgICAgICAgZW1pdCBEZXBvc2l0KG1zZy5zZW5kZXIsIGlkLCBtc2cudmFsdWUpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.21 <0.9.0;
contract ClientReceipt {
 event Deposit(
 address indexed from,
 bytes32 indexed id,
 uint value
 );
 function deposit(bytes32 id) public payable {
 // Events are emitted using \`emit\`, followed by
 // the name of the event and the arguments
 // (if any) in parentheses. Any such invocation
 // (even deeply nested) can be detected from
 // the JavaScript API by filtering for \`Deposit\`.
 emit Deposit(msg.sender, id, msg.value);
 }
}
The use in the JavaScript API is as follows:
var abi \= /\* abi as generated by the compiler \*/;
var ClientReceipt \= web3.eth.contract(abi);
var clientReceipt \= ClientReceipt.at("0x1234...ab67" /\* address \*/);
var depositEvent \= clientReceipt.Deposit();
// watch for changes
depositEvent.watch(function(error, result){
 // result contains non-indexed arguments and topics
 // given to the \`Deposit\` call.
 if (!error)
 console.log(result);
});
// Or pass a callback to start watching immediately
var depositEvent \= clientReceipt.Deposit(function(error, result) {
 if (!error)
 console.log(result);
});
The output of the above looks like the following (trimmed):
{
 "returnValues": {
 "from": "0x1111…FFFFCCCC",
 "id": "0x50…sd5adb20",
 "value": "0x420042"
 },
 "raw": {
 "data": "0x7f…91385",
 "topics": \["0xfd4…b4ead7", "0x7f…1a91385"\]
 }
}
### Additional Resources for Understanding Events[](#additional-resources-for-understanding-events "Link to this heading")
* [JavaScript documentation](https://github.com/web3/web3.js/blob/1.x/docs/web3-eth-contract.rst#events)
 
* [Example usage of events](https://github.com/ethchange/smart-exchange/blob/master/lib/contracts/SmartExchange.sol)
 
* [How to access them in js](https://github.com/ethchange/smart-exchange/blob/master/lib/exchange_transactions.js)
 
## Custom Errors[](#custom-errors "Link to this heading")
Errors in Solidity provide a convenient and gas-efficient way to explain to the user why an operation failed. They can be defined inside and outside of contracts (including interfaces and libraries).
They have to be used together with the [revert statement](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#revert-statement) or the [require function](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#assert-and-require-statements). In the case of `revert` statements, or `require` calls where the condition is evaluated to be false, all changes in the current call are reverted, and the error data passed back to the caller.
The example below shows custom error usage with the `revert` statement in function `transferWithRevertError`, as well as the newer approach with `require` in function `transferWithRequireError`.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjc7CgovLy8gSW5zdWZmaWNpZW50IGJhbGFuY2UgZm9yIHRyYW5zZmVyLiBOZWVkZWQgYHJlcXVpcmVkYCBidXQgb25seQovLy8gYGF2YWlsYWJsZWAgYXZhaWxhYmxlLgovLy8gQHBhcmFtIGF2YWlsYWJsZSBiYWxhbmNlIGF2YWlsYWJsZS4KLy8vIEBwYXJhbSByZXF1aXJlZCByZXF1ZXN0ZWQgYW1vdW50IHRvIHRyYW5zZmVyLgplcnJvciBJbnN1ZmZpY2llbnRCYWxhbmNlKHVpbnQyNTYgYXZhaWxhYmxlLCB1aW50MjU2IHJlcXVpcmVkKTsKCmNvbnRyYWN0IFRlc3RUb2tlbiB7CiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gdWludCkgYmFsYW5jZTsKICAgIGZ1bmN0aW9uIHRyYW5zZmVyV2l0aFJldmVydEVycm9yKGFkZHJlc3MgdG8sIHVpbnQyNTYgYW1vdW50KSBwdWJsaWMgewogICAgICAgIGlmIChhbW91bnQgPiBiYWxhbmNlW21zZy5zZW5kZXJdKQogICAgICAgICAgICByZXZlcnQgSW5zdWZmaWNpZW50QmFsYW5jZSh7CiAgICAgICAgICAgICAgICBhdmFpbGFibGU6IGJhbGFuY2VbbXNnLnNlbmRlcl0sCiAgICAgICAgICAgICAgICByZXF1aXJlZDogYW1vdW50CiAgICAgICAgICAgIH0pOwogICAgICAgIGJhbGFuY2VbbXNnLnNlbmRlcl0gLT0gYW1vdW50OwogICAgICAgIGJhbGFuY2VbdG9dICs9IGFtb3VudDsKICAgIH0KICAgIGZ1bmN0aW9uIHRyYW5zZmVyV2l0aFJlcXVpcmVFcnJvcihhZGRyZXNzIHRvLCB1aW50MjU2IGFtb3VudCkgcHVibGljIHsKICAgICAgICByZXF1aXJlKGFtb3VudCA8PSBiYWxhbmNlW21zZy5zZW5kZXJdLCBJbnN1ZmZpY2llbnRCYWxhbmNlKGJhbGFuY2VbbXNnLnNlbmRlcl0sIGFtb3VudCkpOwogICAgICAgIGJhbGFuY2VbbXNnLnNlbmRlcl0gLT0gYW1vdW50OwogICAgICAgIGJhbGFuY2VbdG9dICs9IGFtb3VudDsKICAgIH0KICAgIC8vIC4uLgp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.27;
/// Insufficient balance for transfer. Needed \`required\` but only
/// \`available\` available.
/// @param available balance available.
/// @param required requested amount to transfer.
error InsufficientBalance(uint256 available, uint256 required);
contract TestToken {
 mapping(address \=> uint) balance;
 function transferWithRevertError(address to, uint256 amount) public {
 if (amount \> balance\[msg.sender\])
 revert InsufficientBalance({
 available: balance\[msg.sender\],
 required: amount
 });
 balance\[msg.sender\] \-= amount;
 balance\[to\] += amount;
 }
 function transferWithRequireError(address to, uint256 amount) public {
 require(amount <= balance\[msg.sender\], InsufficientBalance(balance\[msg.sender\], amount));
 balance\[msg.sender\] \-= amount;
 balance\[to\] += amount;
 }
 // ...
}
Another important detail to mention when it comes to using `require` with custom errors, is that memory allocation for the error-based revert reason will only happen in the reverting case, which, along with optimization of constants and string literals makes this about as gas-efficient as the `if (!condition) revert CustomError(args)` pattern.
Errors cannot be overloaded or overridden but are inherited. The same error can be defined in multiple places as long as the scopes are distinct. Instances of errors can only be created using `revert` statements, or as the second argument to `require` functions.
The error creates data that is then passed to the caller with the revert operation to either return to the off-chain component or catch it in a [try/catch statement](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#try-catch). Note that an error can only be caught when coming from an external call, reverts happening in internal calls or inside the same function cannot be caught.
If you do not provide any parameters, the error only needs four bytes of data and you can use [NatSpec](https://docs.soliditylang.org/en/v0.8.30/natspec-format.html#natspec) as above to further explain the reasons behind the error, which is not stored on chain. This makes this a very cheap and convenient error-reporting feature at the same time.
More specifically, an error instance is ABI-encoded in the same way as a function call to a function of the same name and types would be and then used as the return data in the `revert` opcode. This means that the data consists of a 4-byte selector followed by [ABI-encoded](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#abi) data. The selector consists of the first four bytes of the keccak256-hash of the signature of the error type.
Note
It is possible for a contract to revert with different errors of the same name or even with errors defined in different places that are indistinguishable by the caller. For the outside, i.e. the ABI, only the name of the error is relevant, not the contract or file where it is defined.
The statement `require(condition, "description");` would be equivalent to `if (!condition) revert Error("description")` if you could define `error Error(string)`. Note, however, that `Error` is a built-in type and cannot be defined in user-supplied code.
Similarly, a failing `assert` or similar conditions will revert with an error of the built-in type `Panic(uint256)`.
Note
Error data should only be used to give an indication of failure, but not as a means for control-flow. The reason is that the revert data of inner calls is propagated back through the chain of external calls by default. This means that an inner call can “forge” revert data that looks like it could have come from the contract that called it.
### Members of Errors[](#members-of-errors "Link to this heading")
* `error.selector`: A `bytes4` value containing the error selector.
 
## Inheritance[](#inheritance "Link to this heading")
Solidity supports multiple inheritance including polymorphism.
Polymorphism means that a function call (internal and external) always executes the function of the same name (and parameter types) in the most derived contract in the inheritance hierarchy. This has to be explicitly enabled on each function in the hierarchy using the `virtual` and `override` keywords. See [Function Overriding](#function-overriding) for more details.
It is possible to call functions further up in the inheritance hierarchy internally by explicitly specifying the contract using `ContractName.functionName()` or using `super.functionName()` if you want to call the function one level higher up in the flattened inheritance hierarchy (see below).
When a contract inherits from other contracts, only a single contract is created on the blockchain, and the code from all the base contracts is compiled into the created contract. This means that all internal calls to functions of base contracts also just use internal function calls (`super.f(..)` will use JUMP and not a message call).
State variable shadowing is considered as an error. A derived contract can only declare a state variable `x`, if there is no visible state variable with the same name in any of its bases.
The general inheritance system is very similar to [Python’s](https://docs.python.org/3/tutorial/classes.html#inheritance), especially concerning multiple inheritance, but there are also some [differences](#multi-inheritance).
Details are given in the following example.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgT3duZWQgewogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQp9CgovLyBVc2UgYGlzYCB0byBkZXJpdmUgZnJvbSBhbm90aGVyIGNvbnRyYWN0LiBEZXJpdmVkCi8vIGNvbnRyYWN0cyBjYW4gYWNjZXNzIGFsbCBub24tcHJpdmF0ZSBtZW1iZXJzIGluY2x1ZGluZwovLyBpbnRlcm5hbCBmdW5jdGlvbnMgYW5kIHN0YXRlIHZhcmlhYmxlcy4gVGhlc2UgY2Fubm90IGJlCi8vIGFjY2Vzc2VkIGV4dGVybmFsbHkgdmlhIGB0aGlzYCwgdGhvdWdoLgpjb250cmFjdCBFbWl0dGFibGUgaXMgT3duZWQgewogICAgZXZlbnQgRW1pdHRlZCgpOwoKICAgIC8vIFRoZSBrZXl3b3JkIGB2aXJ0dWFsYCBtZWFucyB0aGF0IHRoZSBmdW5jdGlvbiBjYW4gY2hhbmdlCiAgICAvLyBpdHMgYmVoYXZpb3IgaW4gZGVyaXZlZCBjbGFzc2VzICgib3ZlcnJpZGluZyIpLgogICAgZnVuY3Rpb24gZW1pdEV2ZW50KCkgdmlydHVhbCBwdWJsaWMgewogICAgICAgIGlmIChtc2cuc2VuZGVyID09IG93bmVyKQogICAgICAgICAgICBlbWl0IEVtaXR0ZWQoKTsKICAgIH0KfQoKLy8gVGhlc2UgYWJzdHJhY3QgY29udHJhY3RzIGFyZSBvbmx5IHByb3ZpZGVkIHRvIG1ha2UgdGhlCi8vIGludGVyZmFjZSBrbm93biB0byB0aGUgY29tcGlsZXIuIE5vdGUgdGhlIGZ1bmN0aW9uCi8vIHdpdGhvdXQgYm9keS4gSWYgYSBjb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgYWxsCi8vIGZ1bmN0aW9ucyBpdCBjYW4gb25seSBiZSB1c2VkIGFzIGFuIGludGVyZmFjZS4KYWJzdHJhY3QgY29udHJhY3QgQ29uZmlnIHsKICAgIGZ1bmN0aW9uIGxvb2t1cCh1aW50IGlkKSBwdWJsaWMgdmlydHVhbCByZXR1cm5zIChhZGRyZXNzIGFkcik7Cn0KCmFic3RyYWN0IGNvbnRyYWN0IE5hbWVSZWcgewogICAgZnVuY3Rpb24gcmVnaXN0ZXIoYnl0ZXMzMiBuYW1lKSBwdWJsaWMgdmlydHVhbDsKICAgIGZ1bmN0aW9uIHVucmVnaXN0ZXIoKSBwdWJsaWMgdmlydHVhbDsKfQoKLy8gTXVsdGlwbGUgaW5oZXJpdGFuY2UgaXMgcG9zc2libGUuIE5vdGUgdGhhdCBgT3duZWRgIGlzCi8vIGFsc28gYSBiYXNlIGNsYXNzIG9mIGBFbWl0dGFibGVgLCB5ZXQgdGhlcmUgaXMgb25seSBhIHNpbmdsZQovLyBpbnN0YW5jZSBvZiBgT3duZWRgIChhcyBmb3IgdmlydHVhbCBpbmhlcml0YW5jZSBpbiBDKyspLgpjb250cmFjdCBOYW1lZCBpcyBPd25lZCwgRW1pdHRhYmxlIHsKICAgIGNvbnN0cnVjdG9yKGJ5dGVzMzIgbmFtZSkgewogICAgICAgIENvbmZpZyBjb25maWcgPSBDb25maWcoMHhENWY5RDhEOTQ4ODZFNzBiMDZFNDc0YzNmQjE0RmQ0M0UyZjIzOTcwKTsKICAgICAgICBOYW1lUmVnKGNvbmZpZy5sb29rdXAoMSkpLnJlZ2lzdGVyKG5hbWUpOwogICAgfQoKICAgIC8vIEZ1bmN0aW9ucyBjYW4gYmUgb3ZlcnJpZGRlbiBieSBhbm90aGVyIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgbmFtZSBhbmQKICAgIC8vIHRoZSBzYW1lIG51bWJlci90eXBlcyBvZiBpbnB1dHMuIElmIHRoZSBvdmVycmlkaW5nIGZ1bmN0aW9uIGhhcyBkaWZmZXJlbnQKICAgIC8vIHR5cGVzIG9mIG91dHB1dCBwYXJhbWV0ZXJzLCB0aGF0IGNhdXNlcyBhbiBlcnJvci4KICAgIC8vIEJvdGggbG9jYWwgYW5kIG1lc3NhZ2UtYmFzZWQgZnVuY3Rpb24gY2FsbHMgdGFrZSB0aGVzZSBvdmVycmlkZXMKICAgIC8vIGludG8gYWNjb3VudC4KICAgIC8vIElmIHlvdSB3YW50IHRoZSBmdW5jdGlvbiB0byBvdmVycmlkZSwgeW91IG5lZWQgdG8gdXNlIHRoZQogICAgLy8gYG92ZXJyaWRlYCBrZXl3b3JkLiBZb3UgbmVlZCB0byBzcGVjaWZ5IHRoZSBgdmlydHVhbGAga2V5d29yZCBhZ2FpbgogICAgLy8gaWYgeW91IHdhbnQgdGhpcyBmdW5jdGlvbiB0byBiZSBvdmVycmlkZGVuIGFnYWluLgogICAgZnVuY3Rpb24gZW1pdEV2ZW50KCkgcHVibGljIHZpcnR1YWwgb3ZlcnJpZGUgewogICAgICAgIGlmIChtc2cuc2VuZGVyID09IG93bmVyKSB7CiAgICAgICAgICAgIENvbmZpZyBjb25maWcgPSBDb25maWcoMHhENWY5RDhEOTQ4ODZFNzBiMDZFNDc0YzNmQjE0RmQ0M0UyZjIzOTcwKTsKICAgICAgICAgICAgTmFtZVJlZyhjb25maWcubG9va3VwKDEpKS51bnJlZ2lzdGVyKCk7CiAgICAgICAgICAgIC8vIEl0IGlzIHN0aWxsIHBvc3NpYmxlIHRvIGNhbGwgYSBzcGVjaWZpYwogICAgICAgICAgICAvLyBvdmVycmlkZGVuIGZ1bmN0aW9uLgogICAgICAgICAgICBFbWl0dGFibGUuZW1pdEV2ZW50KCk7CiAgICAgICAgfQogICAgfQp9CgoKLy8gSWYgYSBjb25zdHJ1Y3RvciB0YWtlcyBhbiBhcmd1bWVudCwgaXQgbmVlZHMgdG8gYmUKLy8gcHJvdmlkZWQgaW4gdGhlIGhlYWRlciBvciBtb2RpZmllci1pbnZvY2F0aW9uLXN0eWxlIGF0Ci8vIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZGVyaXZlZCBjb250cmFjdCAoc2VlIGJlbG93KS4KY29udHJhY3QgUHJpY2VGZWVkIGlzIE93bmVkLCBFbWl0dGFibGUsIE5hbWVkKCJHb2xkRmVlZCIpIHsKICAgIHVpbnQgaW5mbzsKCiAgICBmdW5jdGlvbiB1cGRhdGVJbmZvKHVpbnQgbmV3SW5mbykgcHVibGljIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgaW5mbyA9IG5ld0luZm87CiAgICB9CgogICAgLy8gSGVyZSwgd2Ugb25seSBzcGVjaWZ5IGBvdmVycmlkZWAgYW5kIG5vdCBgdmlydHVhbGAuCiAgICAvLyBUaGlzIG1lYW5zIHRoYXQgY29udHJhY3RzIGRlcml2aW5nIGZyb20gYFByaWNlRmVlZGAKICAgIC8vIGNhbm5vdCBjaGFuZ2UgdGhlIGJlaGF2aW9yIG9mIGBlbWl0RXZlbnRgIGFueW1vcmUuCiAgICBmdW5jdGlvbiBlbWl0RXZlbnQoKSBwdWJsaWMgb3ZlcnJpZGUoRW1pdHRhYmxlLCBOYW1lZCkgeyBOYW1lZC5lbWl0RXZlbnQoKTsgfQogICAgZnVuY3Rpb24gZ2V0KCkgcHVibGljIHZpZXcgcmV0dXJucyh1aW50IHIpIHsgcmV0dXJuIGluZm87IH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Owned {
 address payable owner;
 constructor() { owner \= payable(msg.sender); }
}
// Use \`is\` to derive from another contract. Derived
// contracts can access all non-private members including
// internal functions and state variables. These cannot be
// accessed externally via \`this\`, though.
contract Emittable is Owned {
 event Emitted();
 // The keyword \`virtual\` means that the function can change
 // its behavior in derived classes ("overriding").
 function emitEvent() virtual public {
 if (msg.sender \== owner)
 emit Emitted();
 }
}
// These abstract contracts are only provided to make the
// interface known to the compiler. Note the function
// without body. If a contract does not implement all
// functions it can only be used as an interface.
abstract contract Config {
 function lookup(uint id) public virtual returns (address adr);
}
abstract contract NameReg {
 function register(bytes32 name) public virtual;
 function unregister() public virtual;
}
// Multiple inheritance is possible. Note that \`Owned\` is
// also a base class of \`Emittable\`, yet there is only a single
// instance of \`Owned\` (as for virtual inheritance in C++).
contract Named is Owned, Emittable {
 constructor(bytes32 name) {
 Config config \= Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
 NameReg(config.lookup(1)).register(name);
 }
 // Functions can be overridden by another function with the same name and
 // the same number/types of inputs. If the overriding function has different
 // types of output parameters, that causes an error.
 // Both local and message-based function calls take these overrides
 // into account.
 // If you want the function to override, you need to use the
 // \`override\` keyword. You need to specify the \`virtual\` keyword again
 // if you want this function to be overridden again.
 function emitEvent() public virtual override {
 if (msg.sender \== owner) {
 Config config \= Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
 NameReg(config.lookup(1)).unregister();
 // It is still possible to call a specific
 // overridden function.
 Emittable.emitEvent();
 }
 }
}
// If a constructor takes an argument, it needs to be
// provided in the header or modifier-invocation-style at
// the constructor of the derived contract (see below).
contract PriceFeed is Owned, Emittable, Named("GoldFeed") {
 uint info;
 function updateInfo(uint newInfo) public {
 if (msg.sender \== owner) info \= newInfo;
 }
 // Here, we only specify \`override\` and not \`virtual\`.
 // This means that contracts deriving from \`PriceFeed\`
 // cannot change the behavior of \`emitEvent\` anymore.
 function emitEvent() public override(Emittable, Named) { Named.emitEvent(); }
 function get() public view returns(uint r) { return info; }
}
Note that above, we call `Emittable.emitEvent()` to “forward” the emit event request. The way this is done is problematic, as seen in the following example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgT3duZWQgewogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQp9Cgpjb250cmFjdCBFbWl0dGFibGUgaXMgT3duZWQgewogICAgZXZlbnQgRW1pdHRlZCgpOwoKICAgIGZ1bmN0aW9uIGVtaXRFdmVudCgpIHZpcnR1YWwgcHVibGljIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgewogICAgICAgICAgICBlbWl0IEVtaXR0ZWQoKTsKICAgICAgICB9CiAgICB9Cn0KCmNvbnRyYWN0IEJhc2UxIGlzIEVtaXR0YWJsZSB7CiAgICBldmVudCBCYXNlMUVtaXR0ZWQoKTsKICAgIGZ1bmN0aW9uIGVtaXRFdmVudCgpIHB1YmxpYyB2aXJ0dWFsIG92ZXJyaWRlIHsKICAgICAgICAvKiBIZXJlLCB3ZSBlbWl0IGFuIGV2ZW50IHRvIHNpbXVsYXRlIHNvbWUgQmFzZTEgbG9naWMgKi8KICAgICAgICBlbWl0IEJhc2UxRW1pdHRlZCgpOwogICAgICAgIEVtaXR0YWJsZS5lbWl0RXZlbnQoKTsKICAgIH0KfQoKY29udHJhY3QgQmFzZTIgaXMgRW1pdHRhYmxlIHsKICAgIGV2ZW50IEJhc2UyRW1pdHRlZCgpOwogICAgZnVuY3Rpb24gZW1pdEV2ZW50KCkgcHVibGljIHZpcnR1YWwgb3ZlcnJpZGUgewogICAgICAgIC8qIEhlcmUsIHdlIGVtaXQgYW4gZXZlbnQgdG8gc2ltdWxhdGUgc29tZSBCYXNlMiBsb2dpYyAqLwogICAgICAgIGVtaXQgQmFzZTJFbWl0dGVkKCk7CiAgICAgICAgRW1pdHRhYmxlLmVtaXRFdmVudCgpOwogICAgfQp9Cgpjb250cmFjdCBGaW5hbCBpcyBCYXNlMSwgQmFzZTIgewogICAgZXZlbnQgRmluYWxFbWl0dGVkKCk7CiAgICBmdW5jdGlvbiBlbWl0RXZlbnQoKSBwdWJsaWMgb3ZlcnJpZGUoQmFzZTEsIEJhc2UyKSB7CiAgICAgICAgLyogSGVyZSwgd2UgZW1pdCBhbiBldmVudCB0byBzaW11bGF0ZSBzb21lIEZpbmFsIGxvZ2ljICovCiAgICAgICAgZW1pdCBGaW5hbEVtaXR0ZWQoKTsKICAgICAgICBCYXNlMi5lbWl0RXZlbnQoKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Owned {
 address payable owner;
 constructor() { owner \= payable(msg.sender); }
}
contract Emittable is Owned {
 event Emitted();
 function emitEvent() virtual public {
 if (msg.sender \== owner) {
 emit Emitted();
 }
 }
}
contract Base1 is Emittable {
 event Base1Emitted();
 function emitEvent() public virtual override {
 /\* Here, we emit an event to simulate some Base1 logic \*/
 emit Base1Emitted();
 Emittable.emitEvent();
 }
}
contract Base2 is Emittable {
 event Base2Emitted();
 function emitEvent() public virtual override {
 /\* Here, we emit an event to simulate some Base2 logic \*/
 emit Base2Emitted();
 Emittable.emitEvent();
 }
}
contract Final is Base1, Base2 {
 event FinalEmitted();
 function emitEvent() public override(Base1, Base2) {
 /\* Here, we emit an event to simulate some Final logic \*/
 emit FinalEmitted();
 Base2.emitEvent();
 }
}
A call to `Final.emitEvent()` will call `Base2.emitEvent` because we specify it explicitly in the final override, but this function will bypass `Base1.emitEvent`, resulting in the following sequence of events: `FinalEmitted -> Base2Emitted -> Emitted`, instead of the expected sequence: `FinalEmitted -> Base2Emitted -> Base1Emitted -> Emitted`. The way around this is to use `super`:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgT3duZWQgewogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQp9Cgpjb250cmFjdCBFbWl0dGFibGUgaXMgT3duZWQgewogICAgZXZlbnQgRW1pdHRlZCgpOwoKICAgIGZ1bmN0aW9uIGVtaXRFdmVudCgpIHZpcnR1YWwgcHVibGljIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgewogICAgICAgICAgICBlbWl0IEVtaXR0ZWQoKTsKICAgICAgICB9CiAgICB9Cn0KCmNvbnRyYWN0IEJhc2UxIGlzIEVtaXR0YWJsZSB7CiAgICBldmVudCBCYXNlMUVtaXR0ZWQoKTsKICAgIGZ1bmN0aW9uIGVtaXRFdmVudCgpIHB1YmxpYyB2aXJ0dWFsIG92ZXJyaWRlIHsKICAgICAgICAvKiBIZXJlLCB3ZSBlbWl0IGFuIGV2ZW50IHRvIHNpbXVsYXRlIHNvbWUgQmFzZTEgbG9naWMgKi8KICAgICAgICBlbWl0IEJhc2UxRW1pdHRlZCgpOwogICAgICAgIHN1cGVyLmVtaXRFdmVudCgpOwogICAgfQp9CgoKY29udHJhY3QgQmFzZTIgaXMgRW1pdHRhYmxlIHsKICAgIGV2ZW50IEJhc2UyRW1pdHRlZCgpOwogICAgZnVuY3Rpb24gZW1pdEV2ZW50KCkgcHVibGljIHZpcnR1YWwgb3ZlcnJpZGUgewogICAgICAgIC8qIEhlcmUsIHdlIGVtaXQgYW4gZXZlbnQgdG8gc2ltdWxhdGUgc29tZSBCYXNlMiBsb2dpYyAqLwogICAgICAgIGVtaXQgQmFzZTJFbWl0dGVkKCk7CiAgICAgICAgc3VwZXIuZW1pdEV2ZW50KCk7CiAgICB9Cn0KCmNvbnRyYWN0IEZpbmFsIGlzIEJhc2UxLCBCYXNlMiB7CiAgICBldmVudCBGaW5hbEVtaXR0ZWQoKTsKICAgIGZ1bmN0aW9uIGVtaXRFdmVudCgpIHB1YmxpYyBvdmVycmlkZShCYXNlMSwgQmFzZTIpIHsKICAgICAgICAvKiBIZXJlLCB3ZSBlbWl0IGFuIGV2ZW50IHRvIHNpbXVsYXRlIHNvbWUgRmluYWwgbG9naWMgKi8KICAgICAgICBlbWl0IEZpbmFsRW1pdHRlZCgpOwogICAgICAgIHN1cGVyLmVtaXRFdmVudCgpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Owned {
 address payable owner;
 constructor() { owner \= payable(msg.sender); }
}
contract Emittable is Owned {
 event Emitted();
 function emitEvent() virtual public {
 if (msg.sender \== owner) {
 emit Emitted();
 }
 }
}
contract Base1 is Emittable {
 event Base1Emitted();
 function emitEvent() public virtual override {
 /\* Here, we emit an event to simulate some Base1 logic \*/
 emit Base1Emitted();
 super.emitEvent();
 }
}
contract Base2 is Emittable {
 event Base2Emitted();
 function emitEvent() public virtual override {
 /\* Here, we emit an event to simulate some Base2 logic \*/
 emit Base2Emitted();
 super.emitEvent();
 }
}
contract Final is Base1, Base2 {
 event FinalEmitted();
 function emitEvent() public override(Base1, Base2) {
 /\* Here, we emit an event to simulate some Final logic \*/
 emit FinalEmitted();
 super.emitEvent();
 }
}
If `Final` calls a function of `super`, it does not simply call this function on one of its base contracts. Rather, it calls this function on the next base contract in the final inheritance graph, so it will call `Base1.emitEvent()` (note that the final inheritance sequence is – starting with the most derived contract: Final, Base2, Base1, Emittable, Owned). The actual function that is called when using super is not known in the context of the class where it is used, although its type is known. This is similar for ordinary virtual method lookup.
### Function Overriding[](#function-overriding "Link to this heading")
Base functions can be overridden by inheriting contracts to change their behavior if they are marked as `virtual`. The overriding function must then use the `override` keyword in the function header. The overriding function may only change the visibility of the overridden function from `external` to `public`. The mutability may be changed to a more strict one following the order: `nonpayable` can be overridden by `view` and `pure`. `view` can be overridden by `pure`. `payable` is an exception and cannot be changed to any other mutability.
The following example demonstrates changing mutability and visibility:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZQp7CiAgICBmdW5jdGlvbiBmb28oKSB2aXJ0dWFsIGV4dGVybmFsIHZpZXcge30KfQoKY29udHJhY3QgTWlkZGxlIGlzIEJhc2Uge30KCmNvbnRyYWN0IEluaGVyaXRlZCBpcyBNaWRkbGUKewogICAgZnVuY3Rpb24gZm9vKCkgb3ZlcnJpZGUgcHVibGljIHB1cmUge30KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Base
{
 function foo() virtual external view {}
}
contract Middle is Base {}
contract Inherited is Middle
{
 function foo() override public pure {}
}
For multiple inheritance, the most derived base contracts that define the same function must be specified explicitly after the `override` keyword. In other words, you have to specify all base contracts that define the same function and have not yet been overridden by another base contract (on some path through the inheritance graph). Additionally, if a contract inherits the same function from multiple (unrelated) bases, it has to explicitly override it:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEKewogICAgZnVuY3Rpb24gZm9vKCkgdmlydHVhbCBwdWJsaWMge30KfQoKY29udHJhY3QgQmFzZTIKewogICAgZnVuY3Rpb24gZm9vKCkgdmlydHVhbCBwdWJsaWMge30KfQoKY29udHJhY3QgSW5oZXJpdGVkIGlzIEJhc2UxLCBCYXNlMgp7CiAgICAvLyBEZXJpdmVzIGZyb20gbXVsdGlwbGUgYmFzZXMgZGVmaW5pbmcgZm9vKCksIHNvIHdlIG11c3QgZXhwbGljaXRseQogICAgLy8gb3ZlcnJpZGUgaXQKICAgIGZ1bmN0aW9uIGZvbygpIHB1YmxpYyBvdmVycmlkZShCYXNlMSwgQmFzZTIpIHt9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract Base1
{
 function foo() virtual public {}
}
contract Base2
{
 function foo() virtual public {}
}
contract Inherited is Base1, Base2
{
 // Derives from multiple bases defining foo(), so we must explicitly
 // override it
 function foo() public override(Base1, Base2) {}
}
An explicit override specifier is not required if the function is defined in a common base contract or if there is a unique function in a common base contract that already overrides all other functions.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQSB7IGZ1bmN0aW9uIGYoKSBwdWJsaWMgcHVyZXt9IH0KY29udHJhY3QgQiBpcyBBIHt9CmNvbnRyYWN0IEMgaXMgQSB7fQovLyBObyBleHBsaWNpdCBvdmVycmlkZSByZXF1aXJlZApjb250cmFjdCBEIGlzIEIsIEMge30=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract A { function f() public pure{} }
contract B is A {}
contract C is A {}
// No explicit override required
contract D is B, C {}
More formally, it is not required to override a function (directly or indirectly) inherited from multiple bases if there is a base contract that is part of all override paths for the signature, and (1) that base implements the function and no paths from the current contract to the base mentions a function with that signature or (2) that base does not implement the function and there is at most one mention of the function in all paths from the current contract to that base.
In this sense, an override path for a signature is a path through the inheritance graph that starts at the contract under consideration and ends at a contract mentioning a function with that signature that does not override.
If you do not mark a function that overrides as `virtual`, derived contracts can no longer change the behavior of that function.
Note
Functions with the `private` visibility cannot be `virtual`.
Note
Functions without implementation have to be marked `virtual` outside of interfaces. In interfaces, all functions are automatically considered `virtual`.
Note
Starting from Solidity 0.8.8, the `override` keyword is not required when overriding an interface function, except for the case where the function is defined in multiple bases.
Public state variables can override external functions if the parameter and return types of the function matches the getter function of the variable:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQQp7CiAgICBmdW5jdGlvbiBmKCkgZXh0ZXJuYWwgdmlldyB2aXJ0dWFsIHJldHVybnModWludCkgeyByZXR1cm4gNTsgfQp9Cgpjb250cmFjdCBCIGlzIEEKewogICAgdWludCBwdWJsaWMgb3ZlcnJpZGUgZjsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract A
{
 function f() external view virtual returns(uint) { return 5; }
}
contract B is A
{
 uint public override f;
}
Note
While public state variables can override external functions, they themselves cannot be overridden.
### Modifier Overriding[](#modifier-overriding "Link to this heading")
Function modifiers can override each other. This works in the same way as [function overriding](#function-overriding) (except that there is no overloading for modifiers). The `virtual` keyword must be used on the overridden modifier and the `override` keyword must be used in the overriding modifier:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZQp7CiAgICBtb2RpZmllciBmb28oKSB2aXJ0dWFsIHtfO30KfQoKY29udHJhY3QgSW5oZXJpdGVkIGlzIEJhc2UKewogICAgbW9kaWZpZXIgZm9vKCkgb3ZlcnJpZGUge187fQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract Base
{
 modifier foo() virtual {\_;}
}
contract Inherited is Base
{
 modifier foo() override {\_;}
}
In case of multiple inheritance, all direct base contracts must be specified explicitly:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEKewogICAgbW9kaWZpZXIgZm9vKCkgdmlydHVhbCB7Xzt9Cn0KCmNvbnRyYWN0IEJhc2UyCnsKICAgIG1vZGlmaWVyIGZvbygpIHZpcnR1YWwge187fQp9Cgpjb250cmFjdCBJbmhlcml0ZWQgaXMgQmFzZTEsIEJhc2UyCnsKICAgIG1vZGlmaWVyIGZvbygpIG92ZXJyaWRlKEJhc2UxLCBCYXNlMikge187fQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
contract Base1
{
 modifier foo() virtual {\_;}
}
contract Base2
{
 modifier foo() virtual {\_;}
}
contract Inherited is Base1, Base2
{
 modifier foo() override(Base1, Base2) {\_;}
}
### Constructors[](#constructors "Link to this heading")
A constructor is an optional function declared with the `constructor` keyword which is executed upon contract creation, and where you can run contract initialization code.
Before the constructor code is executed, state variables are initialised to their specified value if you initialise them inline, or their [default value](https://docs.soliditylang.org/en/v0.8.30/control-structures.html#default-value) if you do not.
After the constructor has run, the final code of the contract is deployed to the blockchain. The deployment of the code costs additional gas linear to the length of the code. This code includes all functions that are part of the public interface and all functions that are reachable from there through function calls. It does not include the constructor code or internal functions that are only called from the constructor.
If there is no constructor, the contract will assume the default constructor, which is equivalent to `constructor() {}`. For example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgQSB7CiAgICB1aW50IHB1YmxpYyBhOwoKICAgIGNvbnN0cnVjdG9yKHVpbnQgYV8pIHsKICAgICAgICBhID0gYV87CiAgICB9Cn0KCmNvbnRyYWN0IEIgaXMgQSgxKSB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
abstract contract A {
 uint public a;
 constructor(uint a\_) {
 a \= a\_;
 }
}
contract B is A(1) {
 constructor() {}
}
You can use internal parameters in a constructor (for example storage pointers). In this case, the contract has to be marked [abstract](#abstract-contract), because these parameters cannot be assigned valid values from outside but only through the constructors of derived contracts.
Warning
Prior to version 0.4.22, constructors were defined as functions with the same name as the contract. This syntax was deprecated and is not allowed anymore in version 0.5.0.
Warning
Prior to version 0.7.0, you had to specify the visibility of constructors as either `internal` or `public`.
### Arguments for Base Constructors[](#arguments-for-base-constructors "Link to this heading")
The constructors of all the base contracts will be called following the linearization rules explained below. If the base constructors have arguments, derived contracts need to specify all of them. This can be done in two ways:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZSB7CiAgICB1aW50IHg7CiAgICBjb25zdHJ1Y3Rvcih1aW50IHhfKSB7IHggPSB4XzsgfQp9CgovLyBFaXRoZXIgZGlyZWN0bHkgc3BlY2lmeSBpbiB0aGUgaW5oZXJpdGFuY2UgbGlzdC4uLgpjb250cmFjdCBEZXJpdmVkMSBpcyBCYXNlKDcpIHsKICAgIGNvbnN0cnVjdG9yKCkge30KfQoKLy8gb3IgdGhyb3VnaCBhICJtb2RpZmllciIgb2YgdGhlIGRlcml2ZWQgY29uc3RydWN0b3IuLi4KY29udHJhY3QgRGVyaXZlZDIgaXMgQmFzZSB7CiAgICBjb25zdHJ1Y3Rvcih1aW50IHkpIEJhc2UoeSAqIHkpIHt9Cn0KCi8vIG9yIGRlY2xhcmUgYWJzdHJhY3QuLi4KYWJzdHJhY3QgY29udHJhY3QgRGVyaXZlZDMgaXMgQmFzZSB7Cn0KCi8vIGFuZCBoYXZlIHRoZSBuZXh0IGNvbmNyZXRlIGRlcml2ZWQgY29udHJhY3QgaW5pdGlhbGl6ZSBpdC4KY29udHJhY3QgRGVyaXZlZEZyb21EZXJpdmVkIGlzIERlcml2ZWQzIHsKICAgIGNvbnN0cnVjdG9yKCkgQmFzZSgxMCArIDEwKSB7fQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Base {
 uint x;
 constructor(uint x\_) { x \= x\_; }
}
// Either directly specify in the inheritance list...
contract Derived1 is Base(7) {
 constructor() {}
}
// or through a "modifier" of the derived constructor...
contract Derived2 is Base {
 constructor(uint y) Base(y \* y) {}
}
// or declare abstract...
abstract contract Derived3 is Base {
}
// and have the next concrete derived contract initialize it.
contract DerivedFromDerived is Derived3 {
 constructor() Base(10 + 10) {}
}
One way is directly in the inheritance list (`is Base(7)`). The other is in the way a modifier is invoked as part of the derived constructor (`Base(y * y)`). The first way to do it is more convenient if the constructor argument is a constant and defines the behavior of the contract or describes it. The second way has to be used if the constructor arguments of the base depend on those of the derived contract. Arguments have to be given either in the inheritance list or in modifier-style in the derived constructor. Specifying arguments in both places is an error.
If a derived contract does not specify the arguments to all of its base contracts’ constructors, it must be declared abstract. In that case, when another contract derives from it, that other contract’s inheritance list or constructor must provide the necessary parameters for all base classes that haven’t had their parameters specified (otherwise, that other contract must be declared abstract as well). For example, in the above code snippet, see `Derived3` and `DerivedFromDerived`.
### Multiple Inheritance and Linearization[](#multiple-inheritance-and-linearization "Link to this heading")
Languages that allow multiple inheritance have to deal with several problems. One is the [Diamond Problem](https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem). Solidity is similar to Python in that it uses C3 Linearization to force a specific order in the directed acyclic graph (DAG) of base classes. This results in the desirable property of monotonicity but disallows some inheritance graphs. Especially, the order in which the base classes are given in the `is` directive is important: You have to list the direct base contracts in the order from “most base-like” to “most derived”. Note that this order is the reverse of the one used in Python.
Another simplifying way to explain this is that when a function is called that is defined multiple times in different contracts, the given bases are searched from right to left (left to right in Python) in a depth-first manner, stopping at the first match. If a base contract has already been searched, it is skipped.
In the following code, Solidity will give the error “Linearization of inheritance graph impossible”.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgWCB7fQpjb250cmFjdCBBIGlzIFgge30KLy8gVGhpcyB3aWxsIG5vdCBjb21waWxlCmNvbnRyYWN0IEMgaXMgQSwgWCB7fQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract X {}
contract A is X {}
// This will not compile
contract C is A, X {}
The reason for this is that `C` requests `X` to override `A` (by specifying `A, X` in this order), but `A` itself requests to override `X`, which is a contradiction that cannot be resolved.
Due to the fact that you have to explicitly override a function that is inherited from multiple bases without a unique override, C3 linearization is not too important in practice.
One area where inheritance linearization is especially important and perhaps not as clear is when there are multiple constructors in the inheritance hierarchy. The constructors will always be executed in the linearized order, regardless of the order in which their arguments are provided in the inheriting contract’s constructor. For example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEgewogICAgY29uc3RydWN0b3IoKSB7fQp9Cgpjb250cmFjdCBCYXNlMiB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0KCi8vIENvbnN0cnVjdG9ycyBhcmUgZXhlY3V0ZWQgaW4gdGhlIGZvbGxvd2luZyBvcmRlcjoKLy8gIDEgLSBCYXNlMQovLyAgMiAtIEJhc2UyCi8vICAzIC0gRGVyaXZlZDEKY29udHJhY3QgRGVyaXZlZDEgaXMgQmFzZTEsIEJhc2UyIHsKICAgIGNvbnN0cnVjdG9yKCkgQmFzZTEoKSBCYXNlMigpIHt9Cn0KCi8vIENvbnN0cnVjdG9ycyBhcmUgZXhlY3V0ZWQgaW4gdGhlIGZvbGxvd2luZyBvcmRlcjoKLy8gIDEgLSBCYXNlMgovLyAgMiAtIEJhc2UxCi8vICAzIC0gRGVyaXZlZDIKY29udHJhY3QgRGVyaXZlZDIgaXMgQmFzZTIsIEJhc2UxIHsKICAgIGNvbnN0cnVjdG9yKCkgQmFzZTIoKSBCYXNlMSgpIHt9Cn0KCi8vIENvbnN0cnVjdG9ycyBhcmUgc3RpbGwgZXhlY3V0ZWQgaW4gdGhlIGZvbGxvd2luZyBvcmRlcjoKLy8gIDEgLSBCYXNlMgovLyAgMiAtIEJhc2UxCi8vICAzIC0gRGVyaXZlZDMKY29udHJhY3QgRGVyaXZlZDMgaXMgQmFzZTIsIEJhc2UxIHsKICAgIGNvbnN0cnVjdG9yKCkgQmFzZTEoKSBCYXNlMigpIHt9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.7.0 <0.9.0;
contract Base1 {
 constructor() {}
}
contract Base2 {
 constructor() {}
}
// Constructors are executed in the following order:
// 1 - Base1
// 2 - Base2
// 3 - Derived1
contract Derived1 is Base1, Base2 {
 constructor() Base1() Base2() {}
}
// Constructors are executed in the following order:
// 1 - Base2
// 2 - Base1
// 3 - Derived2
contract Derived2 is Base2, Base1 {
 constructor() Base2() Base1() {}
}
// Constructors are still executed in the following order:
// 1 - Base2
// 2 - Base1
// 3 - Derived3
contract Derived3 is Base2, Base1 {
 constructor() Base1() Base2() {}
}
### Inheriting Different Kinds of Members of the Same Name[](#inheriting-different-kinds-of-members-of-the-same-name "Link to this heading")
The only situations where, due to inheritance, a contract may contain multiple definitions sharing the same name are:
* Overloading of functions.
 
* Overriding of virtual functions.
 
* Overriding of external virtual functions by state variable getters.
 
* Overriding of virtual modifiers.
 
* Overloading of events.
 
## Abstract Contracts[](#abstract-contracts "Link to this heading")
Contracts must be marked as abstract when at least one of their functions is not implemented or when they do not provide arguments for all of their base contract constructors. Even if this is not the case, a contract may still be marked abstract, such as when you do not intend for the contract to be created directly. Abstract contracts are similar to [Interfaces](#interfaces) but an interface is more limited in what it can declare.
An abstract contract is declared using the `abstract` keyword as shown in the following example. Note that this contract needs to be defined as abstract, because the function `utterance()` is declared, but no implementation was provided (no implementation body `{ }` was given).
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgRmVsaW5lIHsKICAgIGZ1bmN0aW9uIHV0dGVyYW5jZSgpIHB1YmxpYyB2aXJ0dWFsIHJldHVybnMgKGJ5dGVzMzIpOwp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
abstract contract Feline {
 function utterance() public virtual returns (bytes32);
}
Such abstract contracts can not be instantiated directly. This is also true, if an abstract contract itself does implement all defined functions. The usage of an abstract contract as a base class is shown in the following example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgRmVsaW5lIHsKICAgIGZ1bmN0aW9uIHV0dGVyYW5jZSgpIHB1YmxpYyBwdXJlIHZpcnR1YWwgcmV0dXJucyAoYnl0ZXMzMik7Cn0KCmNvbnRyYWN0IENhdCBpcyBGZWxpbmUgewogICAgZnVuY3Rpb24gdXR0ZXJhbmNlKCkgcHVibGljIHB1cmUgb3ZlcnJpZGUgcmV0dXJucyAoYnl0ZXMzMikgeyByZXR1cm4gIm1pYW93IjsgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
abstract contract Feline {
 function utterance() public pure virtual returns (bytes32);
}
contract Cat is Feline {
 function utterance() public pure override returns (bytes32) { return "miaow"; }
}
If a contract inherits from an abstract contract and does not implement all non-implemented functions by overriding, it needs to be marked as abstract as well.
Note that a function without implementation is different from a [Function Type](https://docs.soliditylang.org/en/v0.8.30/types.html#function-types) even though their syntax looks very similar.
Example of function without implementation (a function declaration):
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=ZnVuY3Rpb24gZm9vKGFkZHJlc3MpIGV4dGVybmFsIHJldHVybnMgKGFkZHJlc3MpOw==)
function foo(address) external returns (address);
Example of a declaration of a variable whose type is a function type:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=ZnVuY3Rpb24oYWRkcmVzcykgZXh0ZXJuYWwgcmV0dXJucyAoYWRkcmVzcykgZm9vOw==)
function(address) external returns (address) foo;
Abstract contracts decouple the definition of a contract from its implementation providing better extensibility and self-documentation and facilitating patterns like the [Template method](https://en.wikipedia.org/wiki/Template_method_pattern) and removing code duplication. Abstract contracts are useful in the same way that defining methods in an interface is useful. It is a way for the designer of the abstract contract to say “any child of mine must implement this method”.
Note
Abstract contracts cannot override an implemented virtual function with an unimplemented one.
## Interfaces[](#interfaces "Link to this heading")
Interfaces are similar to abstract contracts, but they cannot have any functions implemented. There are further restrictions:
* They cannot inherit from other contracts, but they can inherit from other interfaces.
 
* All declared functions must be external in the interface, even if they are public in the contract.
 
* They cannot declare a constructor.
 
* They cannot declare state variables.
 
* They cannot declare modifiers.
 
Some of these restrictions might be lifted in the future.
Interfaces are basically limited to what the Contract ABI can represent, and the conversion between the ABI and an interface should be possible without any information loss.
Interfaces are denoted by their own keyword:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKaW50ZXJmYWNlIFRva2VuIHsKICAgIGVudW0gVG9rZW5UeXBlIHsgRnVuZ2libGUsIE5vbkZ1bmdpYmxlIH0KICAgIHN0cnVjdCBDb2luIHsgc3RyaW5nIG9idmVyc2U7IHN0cmluZyByZXZlcnNlOyB9CiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIHJlY2lwaWVudCwgdWludCBhbW91bnQpIGV4dGVybmFsOwp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.2 <0.9.0;
interface Token {
 enum TokenType { Fungible, NonFungible }
 struct Coin { string obverse; string reverse; }
 function transfer(address recipient, uint amount) external;
}
Contracts can inherit interfaces as they would inherit other contracts.
All functions declared in interfaces are implicitly `virtual` and any functions that override them do not need the `override` keyword. This does not automatically mean that an overriding function can be overridden again - this is only possible if the overriding function is marked `virtual`.
Interfaces can inherit from other interfaces. This has the same rules as normal inheritance.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKaW50ZXJmYWNlIFBhcmVudEEgewogICAgZnVuY3Rpb24gdGVzdCgpIGV4dGVybmFsIHJldHVybnMgKHVpbnQyNTYpOwp9CgppbnRlcmZhY2UgUGFyZW50QiB7CiAgICBmdW5jdGlvbiB0ZXN0KCkgZXh0ZXJuYWwgcmV0dXJucyAodWludDI1Nik7Cn0KCmludGVyZmFjZSBTdWJJbnRlcmZhY2UgaXMgUGFyZW50QSwgUGFyZW50QiB7CiAgICAvLyBNdXN0IHJlZGVmaW5lIHRlc3QgaW4gb3JkZXIgdG8gYXNzZXJ0IHRoYXQgdGhlIHBhcmVudAogICAgLy8gbWVhbmluZ3MgYXJlIGNvbXBhdGlibGUuCiAgICBmdW5jdGlvbiB0ZXN0KCkgZXh0ZXJuYWwgb3ZlcnJpZGUoUGFyZW50QSwgUGFyZW50QikgcmV0dXJucyAodWludDI1Nik7Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.2 <0.9.0;
interface ParentA {
 function test() external returns (uint256);
}
interface ParentB {
 function test() external returns (uint256);
}
interface SubInterface is ParentA, ParentB {
 // Must redefine test in order to assert that the parent
 // meanings are compatible.
 function test() external override(ParentA, ParentB) returns (uint256);
}
Types defined inside interfaces and other contract-like structures can be accessed from other contracts: `Token.TokenType` or `Token.Coin`.
Warning
Interfaces have supported `enum` types since [Solidity version 0.5.0](https://docs.soliditylang.org/en/v0.8.30/050-breaking-changes.html), make sure the pragma version specifies this version as a minimum.
## Libraries[](#libraries "Link to this heading")
Libraries are similar to contracts, but their purpose is that they are deployed only once at a specific address and their code is reused using the `DELEGATECALL` (`CALLCODE` until Homestead) feature of the EVM. This means that if library functions are called, their code is executed in the context of the calling contract, i.e. `this` points to the calling contract, and especially the storage from the calling contract can be accessed. As a library is an isolated piece of source code, it can only access state variables of the calling contract if they are explicitly supplied (it would have no way to name them, otherwise). Library functions can only be called directly (i.e. without the use of `DELEGATECALL`) if they do not modify the state (i.e. if they are `view` or `pure` functions), because libraries are assumed to be stateless. In particular, it is not possible to destroy a library.
Note
Until version 0.4.20, it was possible to destroy libraries by circumventing Solidity’s type system. Starting from that version, libraries contain a [mechanism](#call-protection) that disallows state-modifying functions to be called directly (i.e. without `DELEGATECALL`).
Libraries can be seen as implicit base contracts of the contracts that use them. They will not be explicitly visible in the inheritance hierarchy, but calls to library functions look just like calls to functions of explicit base contracts (using qualified access like `L.f()`). Of course, calls to internal functions use the internal calling convention, which means that all internal types can be passed and types [stored in memory](https://docs.soliditylang.org/en/v0.8.30/types.html#data-location) will be passed by reference and not copied. To realize this in the EVM, the code of internal library functions that are called from a contract and all functions called from therein will at compile time be included in the calling contract, and a regular `JUMP` call will be used instead of a `DELEGATECALL`.
Note
The inheritance analogy breaks down when it comes to public functions. Calling a public library function with `L.f()` results in an external call (`DELEGATECALL` to be precise). In contrast, `A.f()` is an internal call when `A` is a base contract of the current contract.
The following example illustrates how to use libraries (but using a manual method, be sure to check out [using for](#using-for) for a more advanced example to implement a set).
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKCi8vIFdlIGRlZmluZSBhIG5ldyBzdHJ1Y3QgZGF0YXR5cGUgdGhhdCB3aWxsIGJlIHVzZWQgdG8KLy8gaG9sZCBpdHMgZGF0YSBpbiB0aGUgY2FsbGluZyBjb250cmFjdC4Kc3RydWN0IERhdGEgewogICAgbWFwcGluZyh1aW50ID0+IGJvb2wpIGZsYWdzOwp9CgpsaWJyYXJ5IFNldCB7CiAgICAvLyBOb3RlIHRoYXQgdGhlIGZpcnN0IHBhcmFtZXRlciBpcyBvZiB0eXBlICJzdG9yYWdlCiAgICAvLyByZWZlcmVuY2UiIGFuZCB0aHVzIG9ubHkgaXRzIHN0b3JhZ2UgYWRkcmVzcyBhbmQgbm90CiAgICAvLyBpdHMgY29udGVudHMgaXMgcGFzc2VkIGFzIHBhcnQgb2YgdGhlIGNhbGwuICBUaGlzIGlzIGEKICAgIC8vIHNwZWNpYWwgZmVhdHVyZSBvZiBsaWJyYXJ5IGZ1bmN0aW9ucy4gIEl0IGlzIGlkaW9tYXRpYwogICAgLy8gdG8gY2FsbCB0aGUgZmlyc3QgcGFyYW1ldGVyIGBzZWxmYCwgaWYgdGhlIGZ1bmN0aW9uIGNhbgogICAgLy8gYmUgc2VlbiBhcyBhIG1ldGhvZCBvZiB0aGF0IG9iamVjdC4KICAgIGZ1bmN0aW9uIGluc2VydChEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgICAgICBwdWJsaWMKICAgICAgICByZXR1cm5zIChib29sKQogICAgewogICAgICAgIGlmIChzZWxmLmZsYWdzW3ZhbHVlXSkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBhbHJlYWR5IHRoZXJlCiAgICAgICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSB0cnVlOwogICAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICAgIGZ1bmN0aW9uIHJlbW92ZShEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgICAgICBwdWJsaWMKICAgICAgICByZXR1cm5zIChib29sKQogICAgewogICAgICAgIGlmICghc2VsZi5mbGFnc1t2YWx1ZV0pCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gbm90IHRoZXJlCiAgICAgICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSBmYWxzZTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBjb250YWlucyhEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgICAgICBwdWJsaWMKICAgICAgICB2aWV3CiAgICAgICAgcmV0dXJucyAoYm9vbCkKICAgIHsKICAgICAgICByZXR1cm4gc2VsZi5mbGFnc1t2YWx1ZV07CiAgICB9Cn0KCgpjb250cmFjdCBDIHsKICAgIERhdGEga25vd25WYWx1ZXM7CgogICAgZnVuY3Rpb24gcmVnaXN0ZXIodWludCB2YWx1ZSkgcHVibGljIHsKICAgICAgICAvLyBUaGUgbGlicmFyeSBmdW5jdGlvbnMgY2FuIGJlIGNhbGxlZCB3aXRob3V0IGEKICAgICAgICAvLyBzcGVjaWZpYyBpbnN0YW5jZSBvZiB0aGUgbGlicmFyeSwgc2luY2UgdGhlCiAgICAgICAgLy8gImluc3RhbmNlIiB3aWxsIGJlIHRoZSBjdXJyZW50IGNvbnRyYWN0LgogICAgICAgIHJlcXVpcmUoU2V0Lmluc2VydChrbm93blZhbHVlcywgdmFsdWUpKTsKICAgIH0KICAgIC8vIEluIHRoaXMgY29udHJhY3QsIHdlIGNhbiBhbHNvIGRpcmVjdGx5IGFjY2VzcyBrbm93blZhbHVlcy5mbGFncywgaWYgd2Ugd2FudC4KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.6.0 <0.9.0;
// We define a new struct datatype that will be used to
// hold its data in the calling contract.
struct Data {
 mapping(uint \=> bool) flags;
}
library Set {
 // Note that the first parameter is of type "storage
 // reference" and thus only its storage address and not
 // its contents is passed as part of the call. This is a
 // special feature of library functions. It is idiomatic
 // to call the first parameter \`self\`, if the function can
 // be seen as a method of that object.
 function insert(Data storage self, uint value)
 public
 returns (bool)
 {
 if (self.flags\[value\])
 return false; // already there
 self.flags\[value\] \= true;
 return true;
 }
 function remove(Data storage self, uint value)
 public
 returns (bool)
 {
 if (!self.flags\[value\])
 return false; // not there
 self.flags\[value\] \= false;
 return true;
 }
 function contains(Data storage self, uint value)
 public
 view
 returns (bool)
 {
 return self.flags\[value\];
 }
}
contract C {
 Data knownValues;
 function register(uint value) public {
 // The library functions can be called without a
 // specific instance of the library, since the
 // "instance" will be the current contract.
 require(Set.insert(knownValues, value));
 }
 // In this contract, we can also directly access knownValues.flags, if we want.
}
Of course, you do not have to follow this way to use libraries: they can also be used without defining struct data types. Functions also work without any storage reference parameters, and they can have multiple storage reference parameters and in any position.
The calls to `Set.contains`, `Set.insert` and `Set.remove` are all compiled as calls (`DELEGATECALL`) to an external contract/library. If you use libraries, be aware that an actual external function call is performed. `msg.sender`, `msg.value` and `this` will retain their values in this call, though (prior to Homestead, because of the use of `CALLCODE`, `msg.sender` and `msg.value` changed, though).
The following example shows how to use [types stored in memory](https://docs.soliditylang.org/en/v0.8.30/types.html#data-location) and internal functions in libraries in order to implement custom types without the overhead of external function calls:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMDsKCnN0cnVjdCBiaWdpbnQgewogICAgdWludFtdIGxpbWJzOwp9CgpsaWJyYXJ5IEJpZ0ludCB7CiAgICBmdW5jdGlvbiBmcm9tVWludCh1aW50IHgpIGludGVybmFsIHB1cmUgcmV0dXJucyAoYmlnaW50IG1lbW9yeSByKSB7CiAgICAgICAgci5saW1icyA9IG5ldyB1aW50W10oMSk7CiAgICAgICAgci5saW1ic1swXSA9IHg7CiAgICB9CgogICAgZnVuY3Rpb24gYWRkKGJpZ2ludCBtZW1vcnkgYSwgYmlnaW50IG1lbW9yeSBiKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKGJpZ2ludCBtZW1vcnkgcikgewogICAgICAgIHIubGltYnMgPSBuZXcgdWludFtdKG1heChhLmxpbWJzLmxlbmd0aCwgYi5saW1icy5sZW5ndGgpKTsKICAgICAgICB1aW50IGNhcnJ5ID0gMDsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCByLmxpbWJzLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICAgIHVpbnQgbGltYkEgPSBsaW1iKGEsIGkpOwogICAgICAgICAgICB1aW50IGxpbWJCID0gbGltYihiLCBpKTsKICAgICAgICAgICAgdW5jaGVja2VkIHsKICAgICAgICAgICAgICAgIHIubGltYnNbaV0gPSBsaW1iQSArIGxpbWJCICsgY2Fycnk7CgogICAgICAgICAgICAgICAgaWYgKGxpbWJBICsgbGltYkIgPCBsaW1iQSB8fCAobGltYkEgKyBsaW1iQiA9PSB0eXBlKHVpbnQpLm1heCAmJiBjYXJyeSA+IDApKQogICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gMTsKICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICBjYXJyeSA9IDA7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKGNhcnJ5ID4gMCkgewogICAgICAgICAgICAvLyB0b28gYmFkLCB3ZSBoYXZlIHRvIGFkZCBhIGxpbWIKICAgICAgICAgICAgdWludFtdIG1lbW9yeSBuZXdMaW1icyA9IG5ldyB1aW50W10oci5saW1icy5sZW5ndGggKyAxKTsKICAgICAgICAgICAgdWludCBpOwogICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgci5saW1icy5sZW5ndGg7ICsraSkKICAgICAgICAgICAgICAgIG5ld0xpbWJzW2ldID0gci5saW1ic1tpXTsKICAgICAgICAgICAgbmV3TGltYnNbaV0gPSBjYXJyeTsKICAgICAgICAgICAgci5saW1icyA9IG5ld0xpbWJzOwogICAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiBsaW1iKGJpZ2ludCBtZW1vcnkgYSwgdWludCBpbmRleCkgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGluZGV4IDwgYS5saW1icy5sZW5ndGggPyBhLmxpbWJzW2luZGV4XSA6IDA7CiAgICB9CgogICAgZnVuY3Rpb24gbWF4KHVpbnQgYSwgdWludCBiKSBwcml2YXRlIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBhID4gYiA/IGEgOiBiOwogICAgfQp9Cgpjb250cmFjdCBDIHsKICAgIHVzaW5nIEJpZ0ludCBmb3IgYmlnaW50OwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgcHVyZSB7CiAgICAgICAgYmlnaW50IG1lbW9yeSB4ID0gQmlnSW50LmZyb21VaW50KDcpOwogICAgICAgIGJpZ2ludCBtZW1vcnkgeSA9IEJpZ0ludC5mcm9tVWludCh0eXBlKHVpbnQpLm1heCk7CiAgICAgICAgYmlnaW50IG1lbW9yeSB6ID0geC5hZGQoeSk7CiAgICAgICAgYXNzZXJ0KHoubGltYigxKSA+IDApOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;
struct bigint {
 uint\[\] limbs;
}
library BigInt {
 function fromUint(uint x) internal pure returns (bigint memory r) {
 r.limbs \= new uint\[\](1);
 r.limbs\[0\] \= x;
 }
 function add(bigint memory a, bigint memory b) internal pure returns (bigint memory r) {
 r.limbs \= new uint\[\](max(a.limbs.length, b.limbs.length));
 uint carry \= 0;
 for (uint i \= 0; i < r.limbs.length; ++i) {
 uint limbA \= limb(a, i);
 uint limbB \= limb(b, i);
 unchecked {
 r.limbs\[i\] \= limbA + limbB + carry;
 if (limbA + limbB < limbA || (limbA + limbB \== type(uint).max && carry \> 0))
 carry \= 1;
 else
 carry \= 0;
 }
 }
 if (carry \> 0) {
 // too bad, we have to add a limb
 uint\[\] memory newLimbs \= new uint\[\](r.limbs.length + 1);
 uint i;
 for (i \= 0; i < r.limbs.length; ++i)
 newLimbs\[i\] \= r.limbs\[i\];
 newLimbs\[i\] \= carry;
 r.limbs \= newLimbs;
 }
 }
 function limb(bigint memory a, uint index) internal pure returns (uint) {
 return index < a.limbs.length ? a.limbs\[index\] : 0;
 }
 function max(uint a, uint b) private pure returns (uint) {
 return a \> b ? a : b;
 }
}
contract C {
 using BigInt for bigint;
 function f() public pure {
 bigint memory x \= BigInt.fromUint(7);
 bigint memory y \= BigInt.fromUint(type(uint).max);
 bigint memory z \= x.add(y);
 assert(z.limb(1) \> 0);
 }
}
It is possible to obtain the address of a library by converting the library type to the `address` type, i.e. using `address(LibraryName)`.
As the compiler does not know the address where the library will be deployed, the compiled hex code will contain placeholders of the form `__$30bbc0abd4d6364515865950d3e0d10953$__` [(format was different <v0.5.0)](https://docs.soliditylang.org/en/v0.4.26/contracts.html#libraries). The placeholder is a 34 character prefix of the hex encoding of the keccak256 hash of the fully qualified library name, which would be for example `libraries/bigint.sol:BigInt` if the library was stored in a file called `bigint.sol` in a `libraries/` directory. Such bytecode is incomplete and should not be deployed. Placeholders need to be replaced with actual addresses. You can do that by either passing them to the compiler when the library is being compiled or by using the linker to update an already compiled binary. See [Library Linking](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#library-linking) for information on how to use the commandline compiler for linking.
In comparison to contracts, libraries are restricted in the following ways:
* they cannot have state variables
 
* they cannot inherit nor be inherited
 
* they cannot receive Ether
 
* they cannot be destroyed
 
(These might be lifted at a later point.)
### Function Signatures and Selectors in Libraries[](#function-signatures-and-selectors-in-libraries "Link to this heading")
While external calls to public or external library functions are possible, the calling convention for such calls is considered to be internal to Solidity and not the same as specified for the regular [contract ABI](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#abi). External library functions support more argument types than external contract functions, for example recursive structs and storage pointers. For that reason, the function signatures used to compute the 4-byte selector are computed following an internal naming schema and arguments of types not supported in the contract ABI use an internal encoding.
The following identifiers are used for the types in the signatures:
* Value types, non-storage `string` and non-storage `bytes` use the same identifiers as in the contract ABI.
 
* Non-storage array types follow the same convention as in the contract ABI, i.e. `<type>[]` for dynamic arrays and `<type>[M]` for fixed-size arrays of `M` elements.
 
* Non-storage structs are referred to by their fully qualified name, i.e. `C.S` for `contract C { struct S { ... } }`.
 
* Storage pointer mappings use `mapping(<keyType> => <valueType>) storage` where `<keyType>` and `<valueType>` are the identifiers for the key and value types of the mapping, respectively.
 
* Other storage pointer types use the type identifier of their corresponding non-storage type, but append a single space followed by `storage` to it.
 
The argument encoding is the same as for the regular contract ABI, except for storage pointers, which are encoded as a `uint256` value referring to the storage slot to which they point.
Similarly to the contract ABI, the selector consists of the first four bytes of the Keccak256-hash of the signature. Its value can be obtained from Solidity using the `.selector` member as follows:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjE0IDwwLjkuMDsKCmxpYnJhcnkgTCB7CiAgICBmdW5jdGlvbiBmKHVpbnQyNTYpIGV4dGVybmFsIHt9Cn0KCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZygpIHB1YmxpYyBwdXJlIHJldHVybnMgKGJ5dGVzNCkgewogICAgICAgIHJldHVybiBMLmYuc2VsZWN0b3I7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.14 <0.9.0;
library L {
 function f(uint256) external {}
}
contract C {
 function g() public pure returns (bytes4) {
 return L.f.selector;
 }
}
### Call Protection For Libraries[](#call-protection-for-libraries "Link to this heading")
As mentioned in the introduction, if a library’s code is executed using a `CALL` instead of a `DELEGATECALL` or `CALLCODE`, it will revert unless a `view` or `pure` function is called.
The EVM does not provide a direct way for a contract to detect whether it was called using `CALL` or not, but a contract can use the `ADDRESS` opcode to find out “where” it is currently running. The generated code compares this address to the address used at construction time to determine the mode of calling.
More specifically, the runtime code of a library always starts with a push instruction, which is a zero of 20 bytes at compilation time. When the deploy code runs, this constant is replaced in memory by the current address and this modified code is stored in the contract. At runtime, this causes the deploy time address to be the first constant to be pushed onto the stack and the dispatcher code compares the current address against this constant for any non-view and non-pure function.
This means that the actual code stored on chain for a library is different from the code reported by the compiler as `deployedBytecode`.
## Using For[](#using-for "Link to this heading")
The directive `using A for B` can be used to attach functions (`A`) as operators to user-defined value types or as member functions to any type (`B`). The member functions receive the object they are called on as their first parameter (like the `self` variable in Python). The operator functions receive operands as parameters.
It is valid either at file level or inside a contract, at contract level.
The first part, `A`, can be one of:
* A list of functions, optionally with an operator name assigned (e.g. `using {f, g as +, h, L.t} for uint`). If no operator is specified, the function can be either a library function or a free function and is attached to the type as a member function. Otherwise it must be a free function and it becomes the definition of that operator on the type.
 
* The name of a library (e.g. `using L for uint`) - all non-private functions of the library are attached to the type as member functions
 
At file level, the second part, `B`, has to be an explicit type (without data location specifier). Inside contracts, you can also use `*` in place of the type (e.g. `using L for *;`), which has the effect that all functions of the library `L` are attached to _all_ types.
If you specify a library, _all_ non-private functions in the library get attached, even those where the type of the first parameter does not match the type of the object. The type is checked at the point the function is called and function overload resolution is performed.
If you use a list of functions (e.g. `using {f, g, h, L.t} for uint`), then the type (`uint`) has to be implicitly convertible to the first parameter of each of these functions. This check is performed even if none of these functions are called. Note that private library functions can only be specified when `using for` is inside a library.
If you define an operator (e.g. `using {f as +} for T`), then the type (`T`) must be a [user-defined value type](https://docs.soliditylang.org/en/v0.8.30/types.html#user-defined-value-types) and the definition must be a `pure` function. Operator definitions must be global. The following operators can be defined this way:
Category
Operator
Possible signatures
Bitwise
`&`
`function (T, T) pure returns (T)`
`|`
`function (T, T) pure returns (T)`
`^`
`function (T, T) pure returns (T)`
`~`
`function (T) pure returns (T)`
Arithmetic
`+`
`function (T, T) pure returns (T)`
`-`
`function (T, T) pure returns (T)`
`function (T) pure returns (T)`
`*`
`function (T, T) pure returns (T)`
`/`
`function (T, T) pure returns (T)`
`%`
`function (T, T) pure returns (T)`
Comparison
`==`
`function (T, T) pure returns (bool)`
`!=`
`function (T, T) pure returns (bool)`
`<`
`function (T, T) pure returns (bool)`
`<=`
`function (T, T) pure returns (bool)`
`>`
`function (T, T) pure returns (bool)`
`>=`
`function (T, T) pure returns (bool)`
Note that unary and binary `-` need separate definitions. The compiler will choose the right definition based on how the operator is invoked.
The `using A for B;` directive is active only within the current scope (either the contract or the current module/source unit), including within all of its functions, and has no effect outside of the contract or module in which it is used.
When the directive is used at file level and applied to a user-defined type which was defined at file level in the same file, the word `global` can be added at the end. This will have the effect that the functions and operators are attached to the type everywhere the type is available (including other files), not only in the scope of the using statement.
Let us rewrite the set example from the [Libraries](#libraries) section in this way, using file-level functions instead of library functions.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTM7CgpzdHJ1Y3QgRGF0YSB7IG1hcHBpbmcodWludCA9PiBib29sKSBmbGFnczsgfQovLyBOb3cgd2UgYXR0YWNoIGZ1bmN0aW9ucyB0byB0aGUgdHlwZS4KLy8gVGhlIGF0dGFjaGVkIGZ1bmN0aW9ucyBjYW4gYmUgdXNlZCB0aHJvdWdob3V0IHRoZSByZXN0IG9mIHRoZSBtb2R1bGUuCi8vIElmIHlvdSBpbXBvcnQgdGhlIG1vZHVsZSwgeW91IGhhdmUgdG8KLy8gcmVwZWF0IHRoZSB1c2luZyBkaXJlY3RpdmUgdGhlcmUsIGZvciBleGFtcGxlIGFzCi8vICAgaW1wb3J0ICJmbGFncy5zb2wiIGFzIEZsYWdzOwovLyAgIHVzaW5nIHtGbGFncy5pbnNlcnQsIEZsYWdzLnJlbW92ZSwgRmxhZ3MuY29udGFpbnN9Ci8vICAgICBmb3IgRmxhZ3MuRGF0YTsKdXNpbmcge2luc2VydCwgcmVtb3ZlLCBjb250YWluc30gZm9yIERhdGE7CgpmdW5jdGlvbiBpbnNlcnQoRGF0YSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICByZXR1cm5zIChib29sKQp7CiAgICBpZiAoc2VsZi5mbGFnc1t2YWx1ZV0pCiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBhbHJlYWR5IHRoZXJlCiAgICBzZWxmLmZsYWdzW3ZhbHVlXSA9IHRydWU7CiAgICByZXR1cm4gdHJ1ZTsKfQoKZnVuY3Rpb24gcmVtb3ZlKERhdGEgc3RvcmFnZSBzZWxmLCB1aW50IHZhbHVlKQogICAgcmV0dXJucyAoYm9vbCkKewogICAgaWYgKCFzZWxmLmZsYWdzW3ZhbHVlXSkKICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG5vdCB0aGVyZQogICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSBmYWxzZTsKICAgIHJldHVybiB0cnVlOwp9CgpmdW5jdGlvbiBjb250YWlucyhEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgIHZpZXcKICAgIHJldHVybnMgKGJvb2wpCnsKICAgIHJldHVybiBzZWxmLmZsYWdzW3ZhbHVlXTsKfQoKCmNvbnRyYWN0IEMgewogICAgRGF0YSBrbm93blZhbHVlczsKCiAgICBmdW5jdGlvbiByZWdpc3Rlcih1aW50IHZhbHVlKSBwdWJsaWMgewogICAgICAgIC8vIEhlcmUsIGFsbCB2YXJpYWJsZXMgb2YgdHlwZSBEYXRhIGhhdmUKICAgICAgICAvLyBjb3JyZXNwb25kaW5nIG1lbWJlciBmdW5jdGlvbnMuCiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBmdW5jdGlvbiBjYWxsIGlzIGlkZW50aWNhbCB0bwogICAgICAgIC8vIGBTZXQuaW5zZXJ0KGtub3duVmFsdWVzLCB2YWx1ZSlgCiAgICAgICAgcmVxdWlyZShrbm93blZhbHVlcy5pbnNlcnQodmFsdWUpKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.13;
struct Data { mapping(uint \=> bool) flags; }
// Now we attach functions to the type.
// The attached functions can be used throughout the rest of the module.
// If you import the module, you have to
// repeat the using directive there, for example as
// import "flags.sol" as Flags;
// using {Flags.insert, Flags.remove, Flags.contains}
// for Flags.Data;
using {insert, remove, contains} for Data;
function insert(Data storage self, uint value)
 returns (bool)
{
 if (self.flags\[value\])
 return false; // already there
 self.flags\[value\] \= true;
 return true;
}
function remove(Data storage self, uint value)
 returns (bool)
{
 if (!self.flags\[value\])
 return false; // not there
 self.flags\[value\] \= false;
 return true;
}
function contains(Data storage self, uint value)
 view
 returns (bool)
{
 return self.flags\[value\];
}
contract C {
 Data knownValues;
 function register(uint value) public {
 // Here, all variables of type Data have
 // corresponding member functions.
 // The following function call is identical to
 // \`Set.insert(knownValues, value)\`
 require(knownValues.insert(value));
 }
}
It is also possible to extend built-in types in that way. In this example, we will use a library.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTM7CgpsaWJyYXJ5IFNlYXJjaCB7CiAgICBmdW5jdGlvbiBpbmRleE9mKHVpbnRbXSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICAgICAgcHVibGljCiAgICAgICAgdmlldwogICAgICAgIHJldHVybnMgKHVpbnQpCiAgICB7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykKICAgICAgICAgICAgaWYgKHNlbGZbaV0gPT0gdmFsdWUpIHJldHVybiBpOwogICAgICAgIHJldHVybiB0eXBlKHVpbnQpLm1heDsKICAgIH0KfQp1c2luZyBTZWFyY2ggZm9yIHVpbnRbXTsKCmNvbnRyYWN0IEMgewogICAgdWludFtdIGRhdGE7CgogICAgZnVuY3Rpb24gYXBwZW5kKHVpbnQgdmFsdWUpIHB1YmxpYyB7CiAgICAgICAgZGF0YS5wdXNoKHZhbHVlKTsKICAgIH0KCiAgICBmdW5jdGlvbiByZXBsYWNlKHVpbnQgZnJvbSwgdWludCB0bykgcHVibGljIHsKICAgICAgICAvLyBUaGlzIHBlcmZvcm1zIHRoZSBsaWJyYXJ5IGZ1bmN0aW9uIGNhbGwKICAgICAgICB1aW50IGluZGV4ID0gZGF0YS5pbmRleE9mKGZyb20pOwogICAgICAgIGlmIChpbmRleCA9PSB0eXBlKHVpbnQpLm1heCkKICAgICAgICAgICAgZGF0YS5wdXNoKHRvKTsKICAgICAgICBlbHNlCiAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gdG87CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.13;
library Search {
 function indexOf(uint\[\] storage self, uint value)
 public
 view
 returns (uint)
 {
 for (uint i \= 0; i < self.length; i++)
 if (self\[i\] \== value) return i;
 return type(uint).max;
 }
}
using Search for uint\[\];
contract C {
 uint\[\] data;
 function append(uint value) public {
 data.push(value);
 }
 function replace(uint from, uint to) public {
 // This performs the library function call
 uint index \= data.indexOf(from);
 if (index \== type(uint).max)
 data.push(to);
 else
 data\[index\] \= to;
 }
}
Note that all external library calls are actual EVM function calls. This means that if you pass memory or value types, a copy will be performed, even in case of the `self` variable. The only situation where no copy will be performed is when storage reference variables are used or when internal library functions are called.
Another example shows how to define a custom operator for a user-defined type:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTk7Cgp0eXBlIFVGaXhlZDE2eDIgaXMgdWludDE2OwoKdXNpbmcgewogICAgYWRkIGFzICssCiAgICBkaXYgYXMgLwp9IGZvciBVRml4ZWQxNngyIGdsb2JhbDsKCnVpbnQzMiBjb25zdGFudCBTQ0FMRSA9IDEwMDsKCmZ1bmN0aW9uIGFkZChVRml4ZWQxNngyIGEsIFVGaXhlZDE2eDIgYikgcHVyZSByZXR1cm5zIChVRml4ZWQxNngyKSB7CiAgICByZXR1cm4gVUZpeGVkMTZ4Mi53cmFwKFVGaXhlZDE2eDIudW53cmFwKGEpICsgVUZpeGVkMTZ4Mi51bndyYXAoYikpOwp9CgpmdW5jdGlvbiBkaXYoVUZpeGVkMTZ4MiBhLCBVRml4ZWQxNngyIGIpIHB1cmUgcmV0dXJucyAoVUZpeGVkMTZ4MikgewogICAgdWludDMyIGEzMiA9IFVGaXhlZDE2eDIudW53cmFwKGEpOwogICAgdWludDMyIGIzMiA9IFVGaXhlZDE2eDIudW53cmFwKGIpOwogICAgdWludDMyIHJlc3VsdDMyID0gYTMyICogU0NBTEUgLyBiMzI7CiAgICByZXF1aXJlKHJlc3VsdDMyIDw9IHR5cGUodWludDE2KS5tYXgsICJEaXZpZGUgb3ZlcmZsb3ciKTsKICAgIHJldHVybiBVRml4ZWQxNngyLndyYXAodWludDE2KGEzMiAqIFNDQUxFIC8gYjMyKSk7Cn0KCmNvbnRyYWN0IE1hdGggewogICAgZnVuY3Rpb24gYXZnKFVGaXhlZDE2eDIgYSwgVUZpeGVkMTZ4MiBiKSBwdWJsaWMgcHVyZSByZXR1cm5zIChVRml4ZWQxNngyKSB7CiAgICAgICAgcmV0dXJuIChhICsgYikgLyBVRml4ZWQxNngyLndyYXAoMjAwKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.19;
type UFixed16x2 is uint16;
using {
 add as +,
 div as /
} for UFixed16x2 global;
uint32 constant SCALE \= 100;
function add(UFixed16x2 a, UFixed16x2 b) pure returns (UFixed16x2) {
 return UFixed16x2.wrap(UFixed16x2.unwrap(a) + UFixed16x2.unwrap(b));
}
function div(UFixed16x2 a, UFixed16x2 b) pure returns (UFixed16x2) {
 uint32 a32 \= UFixed16x2.unwrap(a);
 uint32 b32 \= UFixed16x2.unwrap(b);
 uint32 result32 \= a32 \* SCALE / b32;
 require(result32 <= type(uint16).max, "Divide overflow");
 return UFixed16x2.wrap(uint16(a32 \* SCALE / b32));
}
contract Math {
 function avg(UFixed16x2 a, UFixed16x2 b) public pure returns (UFixed16x2) {
 return (a + b) / UFixed16x2.wrap(200);
 }
}

# [Installing the Solidity Compiler — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/installing-solidity.html) 
 _https://docs.soliditylang.org/en/v0.8.30/installing-solidity.html_

## Versioning[](#versioning "Link to this heading")
Solidity versions follow [Semantic Versioning](https://semver.org/). In addition, patch-level releases with major release 0 (i.e. 0.x.y) will not contain breaking changes. That means code that compiles with version 0.x.y can be expected to compile with 0.x.z where z > y.
In addition to releases, we provide **nightly development builds** to make it easy for developers to try out upcoming features and provide early feedback. Note, however, that while the nightly builds are usually very stable, they contain bleeding-edge code from the development branch and are not guaranteed to be always working. Despite our best efforts, they might contain undocumented and/or broken changes that will not become a part of an actual release. They are not meant for production use.
When deploying contracts, you should use the latest released version of Solidity. This is because breaking changes, as well as new features and bug fixes are introduced regularly. We currently use a 0.x version number [to indicate this fast pace of change](https://semver.org/#spec-item-4).
## Remix[](#remix "Link to this heading")
_We recommend Remix for small contracts and for quickly learning Solidity._
[Access Remix online](https://remix.ethereum.org/), you do not need to install anything. If you want to use it without connection to the Internet, go to [https://github.com/ethereum/remix-live/tree/gh-pages#readme](https://github.com/ethereum/remix-live/tree/gh-pages#readme) and follow the instructions on that page. Remix is also a convenient option for testing nightly builds without installing multiple Solidity versions.
Further options on this page detail installing command-line Solidity compiler software on your computer. Choose a command-line compiler if you are working on a larger contract or if you require more compilation options.
## npm / Node.js[](#npm-node-js "Link to this heading")
Use `npm` for a convenient and portable way to install `solcjs`, a Solidity compiler. The `solcjs` program has fewer features than the ways to access the compiler described further down this page. The [Using the Commandline Compiler](https://docs.soliditylang.org/en/v0.8.30/using-the-compiler.html#commandline-compiler) documentation assumes you are using the full-featured compiler, `solc`. The usage of `solcjs` is documented inside its own [repository](https://github.com/ethereum/solc-js).
Note: The solc-js project is derived from the C++ `solc` by using Emscripten, which means that both use the same compiler source code. `solc-js` can be used in JavaScript projects directly (such as Remix). Please refer to the solc-js repository for instructions.
npm install \--global solc
Note
The command-line executable is named `solcjs`.
The command-line options of `solcjs` are not compatible with `solc` and tools (such as `geth`) expecting the behavior of `solc` will not work with `solcjs`.
## Docker[](#docker "Link to this heading")
Docker images of Solidity builds are available using the `solc` image from the `ethereum` organization. Use the `stable` tag for the latest released version, and `nightly` for potentially unstable changes in the `develop` branch.
The Docker image runs the compiler executable so that you can pass all compiler arguments to it. For example, the command below pulls the stable version of the `solc` image (if you do not have it already), and runs it in a new container, passing the `--help` argument.
docker run ethereum/solc:stable \--help
Note
Specific compiler versions are supported as the Docker image tag such as `ethereum/solc:0.8.23`. We will be passing the `stable` tag here instead of specific version tag to ensure that users get the latest version by default and avoid the issue of an out-of-date version.
To use the Docker image to compile Solidity files on the host machine, mount a local folder for input and output, and specify the contract to compile. For example:
docker run \\
 \--volume "/tmp/some/local/path/:/sources/" \\
 ethereum/solc:stable \\
 /sources/Contract.sol \\
 \--abi \\
 \--bin \\
 \--output-dir /sources/output/
You can also use the standard JSON interface (which is recommended when using the compiler with tooling). When using this interface, it is not necessary to mount any directories as long as the JSON input is self-contained (i.e. it does not refer to any external files that would have to be [loaded by the import callback](https://docs.soliditylang.org/en/v0.8.30/path-resolution.html#initial-vfs-content-standard-json-with-import-callback)).
docker run ethereum/solc:stable \--standard-json < input.json \> output.json
## Linux Packages[](#linux-packages "Link to this heading")
Binary packages of Solidity are available at [solidity/releases](https://github.com/ethereum/solidity/releases).
We also have PPAs for Ubuntu, you can get the latest stable version using the following commands:
sudo add-apt-repository ppa:ethereum/ethereum
sudo apt-get update
sudo apt-get install solc
The nightly version can be installed using these commands:
sudo add-apt-repository ppa:ethereum/ethereum
sudo add-apt-repository ppa:ethereum/ethereum-dev
sudo apt-get update
sudo apt-get install solc
Furthermore, some Linux distributions provide their own packages. These packages are not directly maintained by us but usually kept up-to-date by the respective package maintainers.
For example, Arch Linux has packages for the latest development version as AUR packages: [solidity](https://aur.archlinux.org/packages/solidity) and [solidity-bin](https://aur.archlinux.org/packages/solidity-bin).
Note
Please be aware that [AUR](https://wiki.archlinux.org/title/Arch_User_Repository) packages are user-produced content and unofficial packages. Exercise caution when using them.
There is also a [snap package](https://snapcraft.io/solc), however, it is **currently unmaintained**. It is installable in all the [supported Linux distros](https://snapcraft.io/docs/core/install). To install the latest stable version of solc:
If you want to help testing the latest development version of Solidity with the most recent changes, please use the following:
sudo snap install solc \--edge
Note
The `solc` snap uses strict confinement. This is the most secure mode for snap packages but it comes with limitations, like accessing only the files in your `/home` and `/media` directories. For more information, go to [Demystifying Snap Confinement](https://snapcraft.io/blog/demystifying-snap-confinement).
## macOS Packages[](#macos-packages "Link to this heading")
We distribute the Solidity compiler through Homebrew as a build-from-source version. Pre-built bottles are currently not supported.
brew update
brew upgrade
brew tap ethereum/ethereum
brew install solidity
To install the most recent 0.4.x / 0.5.x version of Solidity you can also use `brew install solidity@4` and `brew install solidity@5`, respectively.
If you need a specific version of Solidity you can install a Homebrew formula directly from Github.
View [solidity.rb commits on GitHub](https://github.com/ethereum/homebrew-ethereum/commits/master/solidity.rb).
Copy the commit hash of the version you want and check it out on your machine.
git clone https://github.com/ethereum/homebrew-ethereum.git
cd homebrew-ethereum
git checkout <your-hash-goes-here>
Install it using `brew`:
brew unlink solidity
＃ eg. Install 0.4.8
brew install solidity.rb
## Static Binaries[](#static-binaries "Link to this heading")
We maintain a repository containing static builds of past and current compiler versions for all supported platforms at [solc-bin](https://github.com/ethereum/solc-bin/). This is also the location where you can find the nightly builds.
The repository is not only a quick and easy way for end users to get binaries ready to be used out-of-the-box but it is also meant to be friendly to third-party tools:
* The content is mirrored to [https://binaries.soliditylang.org](https://binaries.soliditylang.org/) where it can be easily downloaded over HTTPS without any authentication, rate limiting or the need to use git.
 
* Content is served with correct `Content-Type` headers and lenient CORS configuration so that it can be directly loaded by tools running in the browser.
 
* Binaries do not require installation or unpacking (exception for older Windows builds bundled with necessary DLLs).
 
* We strive for a high level of backward-compatibility. Files, once added, are not removed or moved without providing a symlink/redirect at the old location. They are also never modified in place and should always match the original checksum. The only exception would be broken or unusable files with the potential to cause more harm than good if left as is.
 
* Files are served over both HTTP and HTTPS. As long as you obtain the file list in a secure way (via git, HTTPS, IPFS or just have it cached locally) and verify hashes of the binaries after downloading them, you do not have to use HTTPS for the binaries themselves.
 
The same binaries are in most cases available on the [Solidity release page on GitHub](https://github.com/ethereum/solidity/releases). The difference is that we do not generally update old releases on the GitHub release page. This means that we do not rename them if the naming convention changes and we do not add builds for platforms that were not supported at the time of release. This only happens in `solc-bin`.
The `solc-bin` repository contains several top-level directories, each representing a single platform. Each one includes a `list.json` file listing the available binaries. For example in `emscripten-wasm32/list.json` you will find the following information about version 0.7.4:
{
 "path": "solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js",
 "version": "0.7.4",
 "build": "commit.3f05b770",
 "longVersion": "0.7.4+commit.3f05b770",
 "keccak256": "0x300330ecd127756b824aa13e843cb1f43c473cb22eaf3750d5fb9c99279af8c3",
 "sha256": "0x2b55ed5fec4d9625b6c7b3ab1abd2b7fb7dd2a9c68543bf0323db2c7e2d55af2",
 "urls": \[
 "dweb:/ipfs/QmTLs5MuLEWXQkths41HiACoXDiH8zxyqBHGFDRSzVE5CS"
 \]
}
This means that:
* You can find the binary in the same directory under the name [solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js](https://github.com/ethereum/solc-bin/blob/gh-pages/emscripten-wasm32/solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js). Note that the file might be a symlink, and you will need to resolve it yourself if you are not using git to download it or your file system does not support symlinks.
 
* The binary is also mirrored at [https://binaries.soliditylang.org/emscripten-wasm32/solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js](https://binaries.soliditylang.org/emscripten-wasm32/solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js). In this case git is not necessary and symlinks are resolved transparently, either by serving a copy of the file or returning a HTTP redirect.
 
* The file is also available on IPFS at [QmTLs5MuLEWXQkths41HiACoXDiH8zxyqBHGFDRSzVE5CS](https://gateway.ipfs.io/ipfs/QmTLs5MuLEWXQkths41HiACoXDiH8zxyqBHGFDRSzVE5CS). Please, be aware that the order of items in the `urls` array is not predetermined or guaranteed and users should not rely on it.
 
* You can verify the integrity of the binary by comparing its keccak256 hash to `0x300330ecd127756b824aa13e843cb1f43c473cb22eaf3750d5fb9c99279af8c3`. The hash can be computed on the command-line using `keccak256sum` utility provided by [sha3sum](https://github.com/maandree/sha3sum) or [keccak256() function from ethereumjs-util](https://github.com/ethereumjs/ethereumjs-util/blob/master/docs/modules/_hash_.md#const-keccak256) in JavaScript.
 
* You can also verify the integrity of the binary by comparing its sha256 hash to `0x2b55ed5fec4d9625b6c7b3ab1abd2b7fb7dd2a9c68543bf0323db2c7e2d55af2`.
 
Warning
Due to the strong backwards compatibility requirement the repository contains some legacy elements but you should avoid using them when writing new tools:
* Use `emscripten-wasm32/` (with a fallback to `emscripten-asmjs/`) instead of `bin/` if you want the best performance. Until version 0.6.1 we only provided asm.js binaries. Starting with 0.6.2 we switched to [WebAssembly builds](https://emscripten.org/docs/compiling/WebAssembly.html) with much better performance. We have rebuilt the older versions for wasm but the original asm.js files remain in `bin/`. The new ones had to be placed in a separate directory to avoid name clashes.
 
* Use `emscripten-asmjs/` and `emscripten-wasm32/` instead of `bin/` and `wasm/` directories if you want to be sure whether you are downloading a wasm or an asm.js binary.
 
* Use `list.json` instead of `list.js` and `list.txt`. The JSON list format contains all the information from the old ones and more.
 
* Use [https://binaries.soliditylang.org](https://binaries.soliditylang.org/) instead of [https://solc-bin.ethereum.org](https://solc-bin.ethereum.org/). To keep things simple we moved almost everything related to the compiler under the new `soliditylang.org` domain and this applies to `solc-bin` too. While the new domain is recommended, the old one is still fully supported and guaranteed to point at the same location.
 
Warning
The binaries are also available at [https://ethereum.github.io/solc-bin/](https://ethereum.github.io/solc-bin/) but this page stopped being updated just after the release of version 0.7.2, will not receive any new releases or nightly builds for any platform and does not serve the new directory structure, including non-emscripten builds.
If you are using it, please switch to [https://binaries.soliditylang.org](https://binaries.soliditylang.org/), which is a drop-in replacement. This allows us to make changes to the underlying hosting in a transparent way and minimize disruption. Unlike the `ethereum.github.io` domain, which we do not have any control over, `binaries.soliditylang.org` is guaranteed to work and maintain the same URL structure in the long-term.
## Building from Source[](#building-from-source "Link to this heading")
### Prerequisites - All Operating Systems[](#prerequisites-all-operating-systems "Link to this heading")
The following are dependencies for all builds of Solidity:
Software
Notes
[CMake](https://cmake.org/download/) (version 3.21.3+ on Windows, 3.13+ otherwise)
Cross-platform build file generator.
[Boost](https://www.boost.org/) (version 1.77+ on Windows, 1.67+ otherwise)
C++ libraries.
[Git](https://git-scm.com/download)
Command-line tool for retrieving source code.
[z3](https://github.com/Z3Prover/z3) (version 4.8.16+, Optional)
For use with SMT checker.
Note
Solidity versions prior to 0.5.10 can fail to correctly link against Boost versions 1.70+. A possible workaround is to temporarily rename `<Boost install path>/lib/cmake/Boost-1.70.0` prior to running the cmake command to configure Solidity.
Starting from 0.5.10 linking against Boost 1.70+ should work without manual intervention.
Note
The default build configuration requires a specific Z3 version (the latest one at the time the code was last updated). Changes introduced between Z3 releases often result in slightly different (but still valid) results being returned. Our SMT tests do not account for these differences and will likely fail with a different version than the one they were written for. This does not mean that a build using a different version is faulty. If you pass `-DSTRICT_Z3_VERSION=OFF` option to CMake, you can build with any version that satisfies the requirement given in the table above. If you do this, however, please remember to pass the `--no-smt` option to `scripts/tests.sh` to skip the SMT tests.
Note
By default the build is performed in _pedantic mode_, which enables extra warnings and tells the compiler to treat all warnings as errors. This forces developers to fix warnings as they arise, so they do not accumulate “to be fixed later”. If you are only interested in creating a release build and do not intend to modify the source code to deal with such warnings, you can pass `-DPEDANTIC=OFF` option to CMake to disable this mode. Doing this is not recommended for general use but may be necessary when using a toolchain we are not testing with or trying to build an older version with newer tools. If you encounter such warnings, please consider [reporting them](https://github.com/ethereum/solidity/issues/new).
#### Minimum Compiler Versions[](#minimum-compiler-versions "Link to this heading")
The following C++ compilers and their minimum versions can build the Solidity codebase:
* [GCC](https://gcc.gnu.org/), version 11+
 
* [Clang](https://clang.llvm.org/), version 14+
 
* [MSVC](https://visualstudio.microsoft.com/vs/), version 2019+
 
### Prerequisites - macOS[](#prerequisites-macos "Link to this heading")
For macOS builds, ensure that you have the latest version of [Xcode installed](https://developer.apple.com/xcode/resources/). This contains the [Clang C++ compiler](https://en.wikipedia.org/wiki/Clang), the [Xcode IDE](https://en.wikipedia.org/wiki/Xcode) and other Apple development tools that are required for building C++ applications on OS X. If you are installing Xcode for the first time, or have just installed a new version then you will need to agree to the license before you can do command-line builds:
sudo xcodebuild \-license accept
Our OS X build script uses [the Homebrew](https://brew.sh/) package manager for installing external dependencies. Here’s how to [uninstall Homebrew](https://docs.brew.sh/FAQ#how-do-i-uninstall-homebrew), if you ever want to start again from scratch.
### Prerequisites - Windows[](#prerequisites-windows "Link to this heading")
You need to install the following dependencies for Windows builds of Solidity:
If you already have one IDE and only need the compiler and libraries, you could install Visual Studio 2019 Build Tools.
Visual Studio 2019 provides both IDE and necessary compiler and libraries. So if you have not got an IDE and prefer to develop Solidity, Visual Studio 2019 may be a choice for you to get everything setup easily.
Here is the list of components that should be installed in Visual Studio 2019 Build Tools or Visual Studio 2019:
* Visual Studio C++ core features
 
* VC++ 2019 v141 toolset (x86,x64)
 
* Windows Universal CRT SDK
 
* Windows 8.1 SDK
 
* C++/CLI support
 
We have a helper script which you can use to install all required external dependencies:
This will install `boost` and `cmake` to the `deps` subdirectory.
### Clone the Repository[](#clone-the-repository "Link to this heading")
To clone the source code, execute the following command:
git clone \--recursive https://github.com/ethereum/solidity.git
cd solidity
If you want to help develop Solidity, you should fork Solidity and add your personal fork as a second remote:
git remote add personal git@github.com:\[username\]/solidity.git
### Command-Line Build[](#command-line-build "Link to this heading")
**Be sure to install External Dependencies (see above) before build.**
Solidity project uses CMake to configure the build. You might want to install [ccache](https://ccache.dev/) to speed up repeated builds. CMake will pick it up automatically. Building Solidity is quite similar on Linux, macOS and other Unices:
mkdir build
cd build
cmake .. && make
or even easier on Linux and macOS, you can run:
＃note: this will install binaries solc and soltest at usr/local/bin
./scripts/build.sh
Warning
BSD builds should work, but are untested by the Solidity team.
And for Windows:
mkdir build
cd build
cmake \-G "Visual Studio 16 2019" ..
In case you want to use the version of boost installed by `scripts\install_deps.ps1`, you will additionally need to pass `-DBoost_ROOT="deps/boost" -DBoost_INCLUDE_DIR="deps/boost/include"` and `-DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreaded` as arguments to the call to `cmake`.
This should result in the creation of **solidity.sln** in that build directory. Double-clicking on that file should result in Visual Studio firing up. We suggest building **Release** configuration, but all others work.
Alternatively, you can build for Windows on the command-line, like so:
cmake \--build . \--config Release
## CMake Options[](#cmake-options "Link to this heading")
If you are interested what CMake options are available run `cmake .. -LH`.
### SMT Solvers[](#smt-solvers "Link to this heading")
Solidity can optionally use SMT solvers, namely `z3`, `cvc5` and `Eldarica`, but their presence is checked only at runtime, they are not needed for the build to succeed.
Note
The emscripten builds require Z3 and will statically link against it instead.
## The Version String in Detail[](#the-version-string-in-detail "Link to this heading")
The Solidity version string contains four parts:
* the version number
 
* pre-release tag, usually set to `develop.YYYY.MM.DD` or `nightly.YYYY.MM.DD`
 
* commit in the format of `commit.GITHASH`
 
* platform, which has an arbitrary number of items, containing details about the platform and compiler
 
If there are local modifications, the commit will be postfixed with `.mod`.
These parts are combined as required by SemVer, where the Solidity pre-release tag equals to the SemVer pre-release and the Solidity commit and platform combined make up the SemVer build metadata.
A release example: `0.4.8+commit.60cc1668.Emscripten.clang`.
A pre-release example: `0.4.9-nightly.2017.1.17+commit.6ecb4aa3.Emscripten.clang`
## Important Information About Versioning[](#important-information-about-versioning "Link to this heading")
After a release is made, the patch version level is bumped, because we assume that only patch level changes follow. When changes are merged, the version should be bumped according to SemVer and the severity of the change. Finally, a release is always made with the version of the current nightly build, but without the `prerelease` specifier.
Example:
1. The 0.4.0 release is made.
 
2. The nightly build has a version of 0.4.1 from now on.
 
3. Non-breaking changes are introduced –> no change in version.
 
4. A breaking change is introduced –> version is bumped to 0.5.0.
 
5. The 0.5.0 release is made.
 
This behavior works well with the [version pragma](https://docs.soliditylang.org/en/v0.8.30/layout-of-source-files.html#version-pragma).

# [Solidity v0.5.0 重大变化 — Solidity 0.8.24 文档](https://docs.soliditylang.org/zh-cn/latest/050-breaking-changes.html) 
 _https://docs.soliditylang.org/zh-cn/latest/050-breaking-changes.html_

本节强调了 Solidity 0.5.0 版本中引入的主要重大变化， 以及这些变化背后的原因和如何更新受影响的代码。 对于完整的列表，请查看 [版本更新日志](https://github.com/ethereum/solidity/releases/tag/v0.5.0)。
备注
用 Solidity v0.5.0 编译的合约仍然可以与合约甚至用旧版本编译的库对接， 而无需重新编译或重新部署。 将接口更改为包含数据位置，可见性和可变性说明符就足够了。 参见下面的 [与旧合约的互操作性](#interoperability) 部分。
## 仅有语义上的变化[](#id2 "此标题的永久链接")
本节仅列出了语义的变化，因此有可能在现有代码中隐藏新的且不同的行为。
* 有符号的右移现在使用正确的算术移位，即向负无穷大取整，而不是向零取整。 有符号和无符号移位在 君士坦丁堡（Constantinople）版本将有专门的操作码， 目前由Solidity模拟。
 
* 在 `do...while` 循环中的 `continue` 语句现在跳转到条件，这是在这种情况下的常见行为。 以前是跳到循环主体。因此，如果条件是假的，循环就终止了。
 
* 函数 `.call()`， `.delegatecall()` 和 `.staticcall()` 在给定一个 `bytes` 参数时， 不再进行填充。
 
* 如果EVM的版本是 拜占庭（Byzantium） 或更高版本， 现在调用 pure 和 view 函数时使用操作码 `STATICCALL` 而不是 `CALL`。 这不允许在EVM层面上改变状态。
 
* 当在外部函数调用和 `abi.encode` 中使用时， ABI编码器现在可以正确地对来自 calldata（ `msg.data` 和外部函数参数）的字节数组和字符串进行填充。 对于未填充的编码，请使用 `abi.encodePacked`。
 
* 如果传入的 calldata 太短或指向界外，ABI解码器会在函数的开头和 `abi.decode()` 中回退。 注意，脏的高阶位仍然会被忽略。
 
* 从蜜桔前哨（Tangerine Whistle）开始，用外部功能调用转发所有可用燃料。
 
## 语义和语法的变化[](#id3 "此标题的永久链接")
本节重点介绍影响语法和语义的变化。
* 函数 `.call()`， `.delegatecall()`， `staticcall()`， `keccak256()`， `sha256()` 和 `ripemd160()` 现在只接受一个 `bytes` 参数。此外，该参数没有被填充。 这样做是为了使参数的连接方式更加明确和清晰。 将每个 `.call()` (和家族)改为 `.call("")`， 将每个 `.call(signature, a,b, c)` 改为 `.call(abi.encodeWithSignature(signature, a, b, c))` （最后一项只对值类型有效）。 将每个 `keccak256(a, b, c)` 改为 `keccak256(abi.encodePacked(a, b, c))`。 尽管这不是一个重大的改变，建议开发者将 `x.call(bytes4(keccak256("f(uint256)")), a, b)` 改为 `x.call(abi.encodeWithSignature("f(uint256)", a, b))`。
 
* 函数 `.call()`， `.delegatecall()` 和 `.staticcall()` 现在返回 `(bool, bytes memory)` 以提供对返回数据的访问。 将 `bool success = otherContract.call("f")` 改为 `(bool success, bytes memory data) = otherContract.call("f")`。
 
* Solidity 现在为函数局部变量实现了C99风格的范围规则， 也就是说，变量只能在它们被声明后使用，并且只能在相同或嵌套的范围内使用。 在 `for` 循环的初始化块中声明的变量在循环内部的任何一点都是有效的。
 
## 明确性要求[](#id4 "此标题的永久链接")
本节列出了现在的代码需要更加明确的变化。 对于大多数的主题，编译器会提供建议。
* 明确的函数可见性现在是强制性的。 在每个函数和构造函数中添加 `public`， 在每个未指定可见性的回退或接口函数中添加 `external`。
 
* 所有结构，数组或映射类型的变量的明确数据位置现在是强制性的。 这也适用于函数参数和返回变量。 例如，将 `uint[] x = z` 改为 `uint[] storage x = z`， 将 `function f(uint[] [] x)` 改为 `function f(uint[] [] memory x)`， 其中 `memory` 是数据位置，可以相应地替换为 `storage` 或 `calldata`。 注意， `external` 函数要求参数的数据位置为 `calldata`。
 
* 合约类型不再包括 `address` 成员，以便分离命名空间。 因此，现在有必要在使用 `address` 成员之前，明确地将合约类型的值转换为地址。 例如：如果 `c` 是一个合约，把 `c.transfer(...)` 改为 `address(c).transfer(...)`， 把 `c.balance` 改为 `address(c).balance`。
 
* 现在不允许在不相关的合约类型之间进行显式的转换。您只能从一个合约类型转换到它的一个基础或祖先类型。 如果您确定一个合约与您想转换的合约类型是兼容的，尽管它没有继承它， 您可以通过先转换为 `address` 来解决这个问题。 例如：如果 `A` 和 `B` 是合约类型， `B` 不继承 `A`，而 `b` 是 `B` 类型的合约， 您仍然可以用 `A(address(b))` 将 `b` 转换成 `A` 类型。 请注意，您仍然需要注意匹配的payable修饰的回退函数，如下文所述。
 
* `address` 类型被分成 `address` 和 `address payable`， 其中只有 `address payable` 提供 `transfer` 功能。 一个 `address payable` 可以直接转换为 `address`， 但不允许以其他方式转换。将 `address` 转换为 `address payable` 是可以通过 `uint160` 转换的。 如果 `c` 是一个合约， 只有当 `c` 有一个 payable 修饰的回退函数时， `address(c)` 的结果是 `address payable`。 如果您使用 [取回模式](https://docs.soliditylang.org/zh-cn/latest/common-patterns.html#withdrawal-pattern)，您很可能不必改变您的代码， 因为 `transfer` 只用于 `msg.sender` 而不是存储地址， 而且 `msg.sender` 是一个 `address payable` 类型。
 
* 现在不允许不同位数的 `bytesX` 和 `uintY` 之间的转换了， 因为 `bytesX` 会在右侧填充， `uintY` 会在左侧填充，这可能导致意外的转换结果。 现在在转换前必须在类型内调整位数。 例如， 您想要将 `bytes4` （4字节）转换为 `uint64` （8字节）， 首先将 `bytes4` 变量转换为 `bytes8`，然后再转换为 `uint64`。 当通过 `uint32` 转换时，您会得到相反的填充结果。 在v0.5.0之前，任何 `bytesX` 和 `uintY` 之间的转换都要通过 `uint8X`。 例如， `uint8(bytes3(0x291807))` 将被转换为 `uint8(uint24(bytes3(0x291807)))` （结果是 `0x07`）。
 
* 在非payable函数中使用 `msg.value` （或通过修改器引入）是不允许的，因为这是一个安全特性。 将该函数变成 `payable`，或为程序逻辑创建一个新的内部函数，使用 `msg.value`。
 
* 为了清晰起见，如果使用标准输入作为源，命令行界面现在要求使用 `-`。
 
## 废弃的元素[](#id5 "此标题的永久链接")
这一节列出了废弃以前的功能或语法的变化。 请注意，其中许多变化已经在实验模式 `v0.5.0` 中启用。
### 命令行和JSON接口[](#json "此标题的永久链接")
* 命令行选项 `--formal` （用于生成Why3输出以进一步形式化验证）已被废弃，现在已被删除。 一个新的形式化验证模块，SMTChecker，可以通过 `pragma experimental SMTChecker;` 启用。
 
* 由于中间语言 `Julia` 更名为 `Yul`，命令行选项 `--julia` 被更名为 `--yul`。
 
* 删除了 `--clone-bin` 和 `--combined-json clone-bin` 命令行选项。
 
* 不允许使用空前缀的重映射。
 
* JSON AST字段 `constant` 和 `payable` 被删除。 这些信息现在出现在 `stateMutability` 字段中。
 
* `FunctionDefinition` 节点的JSON AST字段 `isConstructor` 被一个名为 `kind` 的字段取代， 该字段的值可以是 `"constructor"`， `"fallback"` 或 `"function"`。
 
* 在非链接的二进制十六进制文件中，库地址占位符现在是完全等同的库名的keccak256哈希值的前36个十六进制字符， 用 `$...$` 包围。以前，只使用完全等同的库名。这减少了碰撞的机会，特别是在使用长路径的时候。 二进制文件现在也包含一个从这些占位符到完全等同名称的映射列表。
 
### 构造函数[](#id6 "此标题的永久链接")
* 现在必须使用 `constructor` 关键字来定义构造函数。
 
* 现在不允许在没有括号的情况下调用基本构造函数。
 
* 现在不允许在同一继承层次中多次指定基本构造函数参数。
 
* 现在不允许调用有参数但参数个数错误的构造函数。 如果您只是想指定一个继承关系而不是给参数，完全不要提供括号。
 
### 函数[](#id7 "此标题的永久链接")
* 函数 `callcode` 现在被禁止使用（改用 `delegatecall`）。 但仍然可以通过内联汇编使用它。
 
* 现在不允许使用 `suicide` （改用 `selfdestruct`）。
 
* 现在不允许使用 `sha3` （改用 `keccak256`）。
 
* 现在不允许使用 `throw` （改用 `revert`， `require` 和 `assert`）。
 
### 转换[](#id8 "此标题的永久链接")
* 现在不允许从数字到 `bytesXX` 类型的显性和隐性转换。
 
* 现在不允许从十六进制字数到不同大小的 `bytesXX` 类型的显性和隐性转换。
 
### 字面常量和后缀[](#id9 "此标题的永久链接")
* 由于闰年的复杂性和混乱性，现在不允许使用单位名称 `years`。
 
* 现在不允许出现后面没有数字的尾部圆点。
 
* 现在不允许将十六进制数字与单位值相结合（例如： `0x1e wei`）。
 
* 十六进制数字的前缀 `0X` 是不允许的，只能是 `0x`。
 
### 变量[](#id10 "此标题的永久链接")
* 为了清晰起见，现在不允许声明空结构。
 
* 现在不允许使用 `var` 关键字，以利于明确性。
 
* 现在不允许在具有不同组件数量的元组之间进行分配。
 
* 不允许使用不属于编译时常量的常量值。
 
* 现在不允许出现数值不匹配的多变量声明。
 
* 现在不允许出现未初始化的存储变量。
 
* 现在不允许使用空元组。
 
* 检测变量和结构中的循环依赖关系，在递归中被限制为256个。
 
* 现在不允许长度为零的固定长度数组。
 
### 语法[](#id11 "此标题的永久链接")
* 现在不允许使用 `constant` 作为函数状态的可变性修饰符。
 
* 布尔表达式不能使用算术运算。
 
* 现在不允许使用单数的 `+` 操作符。
 
* 如果没有事先转换为明确的类型，字面量不能再使用 `abi.encodePacked`。
 
* 现在不允许有一个或多个返回值的函数的空返回语句。
 
* 现在完全不允许使用 “松散汇编” 语法，也就是说， 不能再使用跳转标签，跳转和非功能指令。使用新的 `while`， `switch` 和 `if` 结构代替。
 
* 没有实现的函数不能再使用修改器。
 
* 现在不允许具有命名返回值的函数类型。
 
* 现在不允许在不是程序块的 if/while/for 语句体中进行单语句变量声明。
 
* 新的关键字： `calldata` 和 `constructor`。
 
* 新的保留关键字： `alias`， `apply`， `auto`， `copyof`， `define`， `immutable`， `implements`， `macro`， `mutable`， `override`， `partial`， `promise`， `reference`， `sealed`， `sizeof`， `supports`， `typedef` 和 `unchecked`。
 
## 与旧合约的互操作性[](#interoperability "此标题的永久链接")
通过为它们定义接口，仍然可以与为0.5.0之前的Solidity版本编写的合于对接（或者反过来）。 考虑到您已经部署了以下0.5.0之前的合约：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjQuMjU7Ci8vIOWcqDAuNC4yNeeJiOacrOeahOe8luivkeWZqOS5i+WJje+8jOi/meWwhuaKpeWRiuS4gOS4quitpuWRigovLyDov5nlnKgwLjUuMOS5i+WQjuWwhuaXoOazlee8luivkeOAggpjb250cmFjdCBPbGRDb250cmFjdCB7CiAgICBmdW5jdGlvbiBzb21lT2xkRnVuY3Rpb24odWludDggYSkgewogICAgICAgIC8vLi4uCiAgICB9CiAgICBmdW5jdGlvbiBhbm90aGVyT2xkRnVuY3Rpb24oKSBjb25zdGFudCByZXR1cm5zIChib29sKSB7CiAgICAgICAgLy8uLi4KICAgIH0KICAgIC8vIC4uLgp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.4.25;
// 在0.4.25版本的编译器之前，这将报告一个警告
// 这在0.5.0之后将无法编译。
contract OldContract {
 function someOldFunction(uint8 a) {
 //...
 }
 function anotherOldFunction() constant returns (bool) {
 //...
 }
 // ...
}
这将不再在Solidity 0.5.0版本中进行编译。然而，您可以为它定义一个兼容的接口：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwppbnRlcmZhY2UgT2xkQ29udHJhY3QgewogICAgZnVuY3Rpb24gc29tZU9sZEZ1bmN0aW9uKHVpbnQ4IGEpIGV4dGVybmFsOwogICAgZnVuY3Rpb24gYW5vdGhlck9sZEZ1bmN0aW9uKCkgZXh0ZXJuYWwgcmV0dXJucyAoYm9vbCk7Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
interface OldContract {
 function someOldFunction(uint8 a) external;
 function anotherOldFunction() external returns (bool);
}
请注意，我们没有声明 `anotherOldFunction` 是 `view`，尽管它在原始合约中被声明为 `constant`。 这是由于从Solidity 0.5.0版本开始，`staticcall` 被用来调用 `view` 函数。 在 0.5.0 版本之前， `constant` 关键字没有被强制执行， 所以用 `staticcall` 调用一个被声明为 `constant` 的函数仍然可能被还原， 因为 `constant` 函数仍然可能试图修改存储。因此，当为旧合约定义接口时， 您应该只使用 `view` 来代替 `constant`，以防您绝对确定该函数能与 `staticcall` 一起工作。
有了上面定义的接口，您现在可以很容易地使用已经部署的 0.5.0 之前的合约：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKaW50ZXJmYWNlIE9sZENvbnRyYWN0IHsKICAgIGZ1bmN0aW9uIHNvbWVPbGRGdW5jdGlvbih1aW50OCBhKSBleHRlcm5hbDsKICAgIGZ1bmN0aW9uIGFub3RoZXJPbGRGdW5jdGlvbigpIGV4dGVybmFsIHJldHVybnMgKGJvb2wpOwp9Cgpjb250cmFjdCBOZXdDb250cmFjdCB7CiAgICBmdW5jdGlvbiBkb1NvbWV0aGluZyhPbGRDb250cmFjdCBhKSBwdWJsaWMgcmV0dXJucyAoYm9vbCkgewogICAgICAgIGEuc29tZU9sZEZ1bmN0aW9uKDB4NDIpOwogICAgICAgIHJldHVybiBhLmFub3RoZXJPbGRGdW5jdGlvbigpOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.5.0 <0.9.0;
interface OldContract {
 function someOldFunction(uint8 a) external;
 function anotherOldFunction() external returns (bool);
}
contract NewContract {
 function doSomething(OldContract a) public returns (bool) {
 a.someOldFunction(0x42);
 return a.anotherOldFunction();
 }
}
同样，0.5.0以前的库可以通过定义库的功能而不需要实现， 并在连接时提供0.5.0以前的库的地址来使用 （关于如何使用命令行编译器进行连接，请参见 [使用命令行编译器](https://docs.soliditylang.org/zh-cn/latest/using-the-compiler.html#commandline-compiler)）。
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8g6L+Z5ZyoMC42LjDniYjmnKzkuYvlkI7lsIbml6Dms5XnvJbor5HjgIIKLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjUuMDsKCmxpYnJhcnkgT2xkTGlicmFyeSB7CiAgICBmdW5jdGlvbiBzb21lRnVuY3Rpb24odWludDggYSkgcHVibGljIHJldHVybnMoYm9vbCk7Cn0KCmNvbnRyYWN0IE5ld0NvbnRyYWN0IHsKICAgIGZ1bmN0aW9uIGYodWludDggYSkgcHVibGljIHJldHVybnMgKGJvb2wpIHsKICAgICAgICByZXR1cm4gT2xkTGlicmFyeS5zb21lRnVuY3Rpb24oYSk7CiAgICB9Cn0=)
// 这在0.6.0版本之后将无法编译。
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.5.0;
library OldLibrary {
 function someFunction(uint8 a) public returns(bool);
}
contract NewContract {
 function f(uint8 a) public returns (bool) {
 return OldLibrary.someFunction(a);
 }
}
## 示例[](#id13 "此标题的永久链接")
下面的例子显示了Solidity 0.5.0 版本的合约及其更新版本，其中包括本节中列出的一些变化。
Old version:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjQuMjU7Ci8vIOi/meWcqDAuNS4w54mI5pys5LmL5ZCO5bCG5peg5rOV57yW6K+R44CCCgpjb250cmFjdCBPdGhlckNvbnRyYWN0IHsKICAgIHVpbnQgeDsKICAgIGZ1bmN0aW9uIGYodWludCB5KSBleHRlcm5hbCB7CiAgICAgICAgeCA9IHk7CiAgICB9CiAgICBmdW5jdGlvbigpIHBheWFibGUgZXh0ZXJuYWwge30KfQoKY29udHJhY3QgT2xkIHsKICAgIE90aGVyQ29udHJhY3Qgb3RoZXI7CiAgICB1aW50IG15TnVtYmVyOwoKICAgIC8vIOayoeacieaPkOS+m+WHveaVsOeahOWPr+WPmOaAp++8jOS4jeaYr+mUmeivr+OAggogICAgZnVuY3Rpb24gc29tZUludGVnZXIoKSBpbnRlcm5hbCByZXR1cm5zICh1aW50KSB7IHJldHVybiAyOyB9CgogICAgLy8g5rKh5pyJ5o+Q5L6b5Ye95pWw55qE5Y+v6KeB5oCn77yM5LiN5piv6ZSZ6K+v44CCCiAgICAvLyDmsqHmnInmj5Dkvpvlh73mlbDnmoTlj6/lj5jmgKfvvIzkuI3mmK/plJnor6/jgIIKICAgIGZ1bmN0aW9uIGYodWludCB4KSByZXR1cm5zIChieXRlcykgewogICAgICAgIC8vIOWcqOi/meS4queJiOacrOS4re+8jHZhcuaYr+WPr+S7peS9v+eUqOeahOOAggogICAgICAgIHZhciB6ID0gc29tZUludGVnZXIoKTsKICAgICAgICB4ICs9IHo7CiAgICAgICAgLy8g5Zyo6L+Z5Liq54mI5pys5Lit77yMdGhyb3fmmK/lj6/ku6Xkvb/nlKjnmoTjgIIKICAgICAgICBpZiAoeCA+IDEwMCkKICAgICAgICAgICAgdGhyb3c7CiAgICAgICAgYnl0ZXMgbWVtb3J5IGIgPSBuZXcgYnl0ZXMoeCk7CiAgICAgICAgeSA9IC0zID4+IDE7CiAgICAgICAgLy8geSA9PSAtMe+8iOmUme+8jOW6lOivpeaYry0y77yJ44CCCiAgICAgICAgZG8gewogICAgICAgICAgICB4ICs9IDE7CiAgICAgICAgICAgIGlmICh4ID4gMTApIGNvbnRpbnVlOwogICAgICAgICAgICAvLyAnQ29udGludWUnIOS8muWvvOiHtOaXoOmZkOW+queOr+OAggogICAgICAgIH0gd2hpbGUgKHggPCAxMSk7CiAgICAgICAgLy8g6LCD55So5Y+q6L+U5Zue5LiA5Liq5biD5bCU5YC844CCCiAgICAgICAgYm9vbCBzdWNjZXNzID0gYWRkcmVzcyhvdGhlcikuY2FsbCgiZiIpOwogICAgICAgIGlmICghc3VjY2VzcykKICAgICAgICAgICAgcmV2ZXJ0KCk7CiAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIC8vIOWxgOmDqOWPmOmHj+WPr+S7peWcqOWFtuS9v+eUqOWQjuWjsOaYjuOAggogICAgICAgICAgICBpbnQgeTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGI7CiAgICB9CgogICAgLy/kuI3pnIDopoHkuLonYXJyJ+iuvue9ruaYjuehrueahOaVsOaNruS9jee9rgogICAgZnVuY3Rpb24gZyh1aW50W10gYXJyLCBieXRlczggeCwgT3RoZXJDb250cmFjdCBvdGhlckNvbnRyYWN0KSBwdWJsaWMgewogICAgICAgIG90aGVyQ29udHJhY3QudHJhbnNmZXIoMSBldGhlcik7CgogICAgICAgIC8vIOeUseS6jnVpbnQzMu+8iDTkuKrlrZfoioLvvInlsI/kuo5ieXRlOO+8iDjkuKrlrZfoioLvvInvvIwKICAgICAgICAvLyB455qE5YmNNOS4quWtl+iKguWwhuiiq+S4ouWkseOAggogICAgICAgIC8vIOi/meWPr+iDveS8muWvvOiHtOaEj+aDs+S4jeWIsOeahOihjOS4uu+8jOWboOS4umJ5dGVzWOaYr+WQkeWPs+Whq+WFheeahOOAggogICAgICAgIHVpbnQzMiB5ID0gdWludDMyKHgpOwogICAgICAgIG15TnVtYmVyICs9IHkgKyBtc2cudmFsdWU7CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.4.25;
// 这在0.5.0版本之后将无法编译。
contract OtherContract {
 uint x;
 function f(uint y) external {
 x \= y;
 }
 function() payable external {}
}
contract Old {
 OtherContract other;
 uint myNumber;
 // 没有提供函数的可变性，不是错误。
 function someInteger() internal returns (uint) { return 2; }
 // 没有提供函数的可见性，不是错误。
 // 没有提供函数的可变性，不是错误。
 function f(uint x) returns (bytes) {
 // 在这个版本中，var是可以使用的。
 var z \= someInteger();
 x += z;
 // 在这个版本中，throw是可以使用的。
 if (x \> 100)
 throw;
 bytes memory b \= new bytes(x);
 y \= \-3 \>> 1;
 // y == -1（错，应该是-2）。
 do {
 x += 1;
 if (x \> 10) continue;
 // 'Continue' 会导致无限循环。
 } while (x < 11);
 // 调用只返回一个布尔值。
 bool success \= address(other).call("f");
 if (!success)
 revert();
 else {
 // 局部变量可以在其使用后声明。
 int y;
 }
 return b;
 }
 //不需要为'arr'设置明确的数据位置
 function g(uint\[\] arr, bytes8 x, OtherContract otherContract) public {
 otherContract.transfer(1 ether);
 // 由于uint32（4个字节）小于byte8（8个字节），
 // x的前4个字节将被丢失。
 // 这可能会导致意想不到的行为，因为bytesX是向右填充的。
 uint32 y \= uint32(x);
 myNumber += y + msg.value;
 }
}
新版本：
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.24&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjUuMDsKLy8g6L+Z5ZyoMC42LjDniYjmnKzkuYvlkI7lsIbml6Dms5XnvJbor5HjgIIKCmNvbnRyYWN0IE90aGVyQ29udHJhY3QgewogICAgdWludCB4OwogICAgZnVuY3Rpb24gZih1aW50IHkpIGV4dGVybmFsIHsKICAgICAgICB4ID0geTsKICAgIH0KICAgIGZ1bmN0aW9uKCkgcGF5YWJsZSBleHRlcm5hbCB7fQp9Cgpjb250cmFjdCBOZXcgewogICAgT3RoZXJDb250cmFjdCBvdGhlcjsKICAgIHVpbnQgbXlOdW1iZXI7CgogICAgLy8g5b+F6aG75oyH5a6a5Ye95pWw55qE5Y+v5Y+Y5oCn44CCCiAgICBmdW5jdGlvbiBzb21lSW50ZWdlcigpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludCkgeyByZXR1cm4gMjsgfQoKICAgIC8vIOW/hemhu+aMh+WumuWHveaVsOeahOWPr+ingeaAp+OAggogICAgLy8g5b+F6aG75oyH5a6a5Ye95pWw55qE5Y+v5Y+Y5oCn44CCCiAgICBmdW5jdGlvbiBmKHVpbnQgeCkgcHVibGljIHJldHVybnMgKGJ5dGVzIG1lbW9yeSkgewogICAgICAgIC8vIOeOsOWcqOW/hemhu+aYjuehruWcsOe7meWHuuexu+Wei+OAggogICAgICAgIHVpbnQgeiA9IHNvbWVJbnRlZ2VyKCk7CiAgICAgICAgeCArPSB6OwogICAgICAgIC8vIOeOsOWcqOS4jeWFgeiuuOS9v+eUqHRocm9344CCCiAgICAgICAgcmVxdWlyZSh4IDw9IDEwMCk7CiAgICAgICAgaW50IHkgPSAtMyA+PiAxOwogICAgICAgIHJlcXVpcmUoeSA9PSAtMik7CiAgICAgICAgZG8gewogICAgICAgICAgICB4ICs9IDE7CiAgICAgICAgICAgIGlmICh4ID4gMTApIGNvbnRpbnVlOwogICAgICAgICAgICAvLyAnQ29udGludWUn6Lez6L2s5Yiw5LiL6Z2i55qE5p2h5Lu244CCCiAgICAgICAgfSB3aGlsZSAoeCA8IDExKTsKCiAgICAgICAgLy8gY2FsbOi/lOWbnuWAvOS4uihib29sLCBieXRlcykuCiAgICAgICAgLy8g5b+F6aG75oyH5a6a5pWw5o2u5L2N572u44CCCiAgICAgICAgKGJvb2wgc3VjY2VzcywgYnl0ZXMgbWVtb3J5IGRhdGEpID0gYWRkcmVzcyhvdGhlcikuY2FsbCgiZiIpOwogICAgICAgIGlmICghc3VjY2VzcykKICAgICAgICAgICAgcmV2ZXJ0KCk7CiAgICAgICAgcmV0dXJuIGRhdGE7CiAgICB9CgogICAgdXNpbmcgQWRkcmVzc01ha2VQYXlhYmxlIGZvciBhZGRyZXNzOwogICAgLy8g5b+F6aG75oyH5a6aJ2FycifnmoTmlbDmja7kvY3nva4KICAgIGZ1bmN0aW9uIGcodWludFtdIG1lbW9yeSAvKiBhcnIgKi8sIGJ5dGVzOCB4LCBPdGhlckNvbnRyYWN0IG90aGVyQ29udHJhY3QsIGFkZHJlc3MgdW5rbm93bkNvbnRyYWN0KSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgLy8g5rKh5pyJ5o+Q5L6bJ290aGVyQ29udHJhY3QudHJhbnNmZXIn44CCCiAgICAgICAgLy8g55Sx5LqOJ090aGVyQ29udHJhY3Qn55qE5Luj56CB5piv5bey55+l55qE77yM5bm25LiU5YW35pyJ5Zue6YCA5Yqf6IO977yMCiAgICAgICAgLy8gYWRkcmVzcyhvdGhlckNvbnRyYWN0KeWFt+aciSdhZGRyZXNzIHBheWFibGUn57G75Z6L44CCCiAgICAgICAgYWRkcmVzcyhvdGhlckNvbnRyYWN0KS50cmFuc2ZlcigxIGV0aGVyKTsKCiAgICAgICAgLy8g5rKh5pyJ5o+Q5L6bJ3Vua25vd25Db250cmFjdC50cmFuc2ZlcifjgIIKICAgICAgICAvLyDmsqHmnInmj5DkvpsnYWRkcmVzcyh1bmtub3duQ29udHJhY3QpLnRyYW5zZmVyJwogICAgICAgIC8vIOWboOS4uidhZGRyZXNzKHVua25vd25Db250cmFjdCkn5LiN5pivJ2FkZHJlc3MgcGF5YWJsZSfnsbvlnovjgIIKICAgICAgICAvLyDlpoLmnpzor6Xlh73mlbDpnIDopoHkuIDkuKrmgqjmg7Plj5HpgIHotYTph5HnmoQnYWRkcmVzcyfnsbvlnovvvIwKICAgICAgICAvLyDmgqjlj6/ku6XpgJrov4cndWludDE2MCflsIblhbbovazmjaLkuLonYWRkcmVzcyBwYXlhYmxlJ+exu+Wei+OAggogICAgICAgIC8vIOazqOaEj++8muS4jeW7uuiurui/meagt+WBmu+8jOW6lOWwveWPr+iDveS9v+eUqOaYjuehrueahCdhZGRyZXNzIHBheWFibGUn57G75Z6L44CCCiAgICAgICAgLy8g5Li65LqG5o+Q6auY5piO56Gu5oCn77yM5oiR5Lus5bu66K6u5L2/55So5LiA5Liq5bqT5ZCI57qm5p2l6L+b6KGM6L2s5o2i77yI5bey5Zyo6L+Z5Liq56S65L6L5ZCI57qm55qE5ZCO6Z2i5o+Q5L6b77yJ44CCCiAgICAgICAgYWRkcmVzcyBwYXlhYmxlIGFkZHIgPSB1bmtub3duQ29udHJhY3QubWFrZVBheWFibGUoKTsKICAgICAgICByZXF1aXJlKGFkZHIuc2VuZCgxIGV0aGVyKSk7CgogICAgICAgIC8vIOeUseS6jnVpbnQzMu+8iDTlrZfoioLvvInlsI/kuo5ieXRlczjvvIg45a2X6IqC77yJ77yMCiAgICAgICAgLy8g5omA5Lul5LiN5YWB6K646L+b6KGM6L2s5o2i44CCCiAgICAgICAgLy8g5oiR5Lus6ZyA6KaB5YWI6L2s5o2i5Yiw5LiA5Liq6YCa55So55qE5aSn5bCP77yaCiAgICAgICAgYnl0ZXM0IHg0ID0gYnl0ZXM0KHgpOyAvLyBQYWRkaW5nIGhhcHBlbnMgb24gdGhlIHJpZ2h0CiAgICAgICAgdWludDMyIHkgPSB1aW50MzIoeDQpOyAvLyBDb252ZXJzaW9uIGlzIGNvbnNpc3RlbnQKICAgICAgICAvLyAnbXNnLnZhbHVlJ+S4jeiDveeUqOWcqCfpnZ5wYXlhYmxlJ+exu+Wei+eahOWHveaVsOS4reOAggogICAgICAgIC8vIOaIkeS7rOmcgOimgeaKiuWHveaVsOWPmOaIkHBheWFibGXnsbvlnosKICAgICAgICBteU51bWJlciArPSB5ICsgbXNnLnZhbHVlOwogICAgfQp9CgovLyDmiJHku6zlj6/ku6XlrprkuYnkuIDkuKrlupPvvIzlsIYgYGBhZGRyZXNzYGAg57G75Z6L5piO56Gu6L2s5o2i5Li6IGBgYWRkcmVzcyBwYXlhYmxlYGAg57G75Z6L77yM5L2c5Li65LiA56eN5Y+Y6YCa5pa55rOV44CCCmxpYnJhcnkgQWRkcmVzc01ha2VQYXlhYmxlIHsKICAgIGZ1bmN0aW9uIG1ha2VQYXlhYmxlKGFkZHJlc3MgeCkgaW50ZXJuYWwgcHVyZSByZXR1cm5zIChhZGRyZXNzIHBheWFibGUpIHsKICAgICAgICByZXR1cm4gYWRkcmVzcyh1aW50MTYwKHgpKTsKICAgIH0KfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.5.0;
// 这在0.6.0版本之后将无法编译。
contract OtherContract {
 uint x;
 function f(uint y) external {
 x \= y;
 }
 function() payable external {}
}
contract New {
 OtherContract other;
 uint myNumber;
 // 必须指定函数的可变性。
 function someInteger() internal pure returns (uint) { return 2; }
 // 必须指定函数的可见性。
 // 必须指定函数的可变性。
 function f(uint x) public returns (bytes memory) {
 // 现在必须明确地给出类型。
 uint z \= someInteger();
 x += z;
 // 现在不允许使用throw。
 require(x <= 100);
 int y \= \-3 \>> 1;
 require(y \== \-2);
 do {
 x += 1;
 if (x \> 10) continue;
 // 'Continue'跳转到下面的条件。
 } while (x < 11);
 // call返回值为(bool, bytes).
 // 必须指定数据位置。
 (bool success, bytes memory data) \= address(other).call("f");
 if (!success)
 revert();
 return data;
 }
 using AddressMakePayable for address;
 // 必须指定'arr'的数据位置
 function g(uint\[\] memory /\* arr \*/, bytes8 x, OtherContract otherContract, address unknownContract) public payable {
 // 没有提供'otherContract.transfer'。
 // 由于'OtherContract'的代码是已知的，并且具有回退功能，
 // address(otherContract)具有'address payable'类型。
 address(otherContract).transfer(1 ether);
 // 没有提供'unknownContract.transfer'。
 // 没有提供'address(unknownContract).transfer'
 // 因为'address(unknownContract)'不是'address payable'类型。
 // 如果该函数需要一个您想发送资金的'address'类型，
 // 您可以通过'uint160'将其转换为'address payable'类型。
 // 注意：不建议这样做，应尽可能使用明确的'address payable'类型。
 // 为了提高明确性，我们建议使用一个库合约来进行转换（已在这个示例合约的后面提供）。
 address payable addr \= unknownContract.makePayable();
 require(addr.send(1 ether));
 // 由于uint32（4字节）小于bytes8（8字节），
 // 所以不允许进行转换。
 // 我们需要先转换到一个通用的大小：
 bytes4 x4 \= bytes4(x); // Padding happens on the right
 uint32 y \= uint32(x4); // Conversion is consistent
 // 'msg.value'不能用在'非payable'类型的函数中。
 // 我们需要把函数变成payable类型
 myNumber += y + msg.value;
 }
}
// 我们可以定义一个库，将 \`\`address\`\` 类型明确转换为 \`\`address payable\`\` 类型，作为一种变通方法。
library AddressMakePayable {
 function makePayable(address x) internal pure returns (address payable) {
 return address(uint160(x));
 }
}

# [Inline Assembly — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/assembly.html) 
 _https://docs.soliditylang.org/en/latest/assembly.html_

You can interleave Solidity statements with inline assembly in a language close to the one of the Ethereum Virtual Machine. This gives you more fine-grained control, which is especially useful when you are enhancing the language by writing libraries or optimizing gas usage.
The language used for inline assembly in Solidity is called [Yul](https://docs.soliditylang.org/en/latest/yul.html#yul) and it is documented in its own section. This section will only cover how the inline assembly code can interface with the surrounding Solidity code.
Warning
Inline assembly is a way to access the Ethereum Virtual Machine at a low level. This bypasses several important safety features and checks of Solidity. You should only use it for tasks that need it, and only if you are confident with using it.
An inline assembly block is marked by `assembly { ... }`, where the code inside the curly braces is code in the [Yul](https://docs.soliditylang.org/en/latest/yul.html#yul) language.
The inline assembly code can access local Solidity variables as explained below.
Different inline assembly blocks share no namespace, i.e. it is not possible to call a Yul function or access a Yul variable defined in a different inline assembly block.
## Example[](#example "Link to this heading")
The following example provides library code to access the code of another contract and load it into a `bytes` variable. This is possible with “plain Solidity” too, by using `<address>.code`. But the point here is that reusable assembly libraries can enhance the Solidity language without a compiler change.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmxpYnJhcnkgR2V0Q29kZSB7CiAgICBmdW5jdGlvbiBhdChhZGRyZXNzIGFkZHIpIHB1YmxpYyB2aWV3IHJldHVybnMgKGJ5dGVzIG1lbW9yeSBjb2RlKSB7CiAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICAvLyByZXRyaWV2ZSB0aGUgc2l6ZSBvZiB0aGUgY29kZSwgdGhpcyBuZWVkcyBhc3NlbWJseQogICAgICAgICAgICBsZXQgc2l6ZSA6PSBleHRjb2Rlc2l6ZShhZGRyKQogICAgICAgICAgICAvLyBhbGxvY2F0ZSBvdXRwdXQgYnl0ZSBhcnJheSAtIHRoaXMgY291bGQgYWxzbyBiZSBkb25lIHdpdGhvdXQgYXNzZW1ibHkKICAgICAgICAgICAgLy8gYnkgdXNpbmcgY29kZSA9IG5ldyBieXRlcyhzaXplKQogICAgICAgICAgICBjb2RlIDo9IG1sb2FkKDB4NDApCiAgICAgICAgICAgIC8vIG5ldyAibWVtb3J5IGVuZCIgaW5jbHVkaW5nIHBhZGRpbmcKICAgICAgICAgICAgbXN0b3JlKDB4NDAsIGFkZChjb2RlLCBhbmQoYWRkKGFkZChzaXplLCAweDIwKSwgMHgxZiksIG5vdCgweDFmKSkpKQogICAgICAgICAgICAvLyBzdG9yZSBsZW5ndGggaW4gbWVtb3J5CiAgICAgICAgICAgIG1zdG9yZShjb2RlLCBzaXplKQogICAgICAgICAgICAvLyBhY3R1YWxseSByZXRyaWV2ZSB0aGUgY29kZSwgdGhpcyBuZWVkcyBhc3NlbWJseQogICAgICAgICAgICBleHRjb2RlY29weShhZGRyLCBhZGQoY29kZSwgMHgyMCksIDAsIHNpemUpCiAgICAgICAgfQogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
library GetCode {
 function at(address addr) public view returns (bytes memory code) {
 assembly {
 // retrieve the size of the code, this needs assembly
 let size := extcodesize(addr)
 // allocate output byte array - this could also be done without assembly
 // by using code = new bytes(size)
 code := mload(0x40)
 // new "memory end" including padding
 mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f))))
 // store length in memory
 mstore(code, size)
 // actually retrieve the code, this needs assembly
 extcodecopy(addr, add(code, 0x20), 0, size)
 }
 }
}
Inline assembly is also beneficial in cases where the optimizer fails to produce efficient code, for example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCgpsaWJyYXJ5IFZlY3RvclN1bSB7CiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGxlc3MgZWZmaWNpZW50IGJlY2F1c2UgdGhlIG9wdGltaXplciBjdXJyZW50bHkgZmFpbHMgdG8KICAgIC8vIHJlbW92ZSB0aGUgYm91bmRzIGNoZWNrcyBpbiBhcnJheSBhY2Nlc3MuCiAgICBmdW5jdGlvbiBzdW1Tb2xpZGl0eSh1aW50W10gbWVtb3J5IGRhdGEpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQgc3VtKSB7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkKICAgICAgICAgICAgc3VtICs9IGRhdGFbaV07CiAgICB9CgogICAgLy8gV2Uga25vdyB0aGF0IHdlIG9ubHkgYWNjZXNzIHRoZSBhcnJheSBpbiBib3VuZHMsIHNvIHdlIGNhbiBhdm9pZCB0aGUgY2hlY2suCiAgICAvLyAweDIwIG5lZWRzIHRvIGJlIGFkZGVkIHRvIGFuIGFycmF5IGJlY2F1c2UgdGhlIGZpcnN0IHNsb3QgY29udGFpbnMgdGhlCiAgICAvLyBhcnJheSBsZW5ndGguCiAgICBmdW5jdGlvbiBzdW1Bc20odWludFtdIG1lbW9yeSBkYXRhKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IHN1bSkgewogICAgICAgIGZvciAodWludCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHsKICAgICAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICAgICAgc3VtIDo9IGFkZChzdW0sIG1sb2FkKGFkZChhZGQoZGF0YSwgMHgyMCksIG11bChpLCAweDIwKSkpKQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQoKICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2NvbXBsaXNoIHRoZSBlbnRpcmUgY29kZSB3aXRoaW4gaW5saW5lIGFzc2VtYmx5LgogICAgZnVuY3Rpb24gc3VtUHVyZUFzbSh1aW50W10gbWVtb3J5IGRhdGEpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQgc3VtKSB7CiAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICAvLyBMb2FkIHRoZSBsZW5ndGggKGZpcnN0IDMyIGJ5dGVzKQogICAgICAgICAgICBsZXQgbGVuIDo9IG1sb2FkKGRhdGEpCgogICAgICAgICAgICAvLyBTa2lwIG92ZXIgdGhlIGxlbmd0aCBmaWVsZC4KICAgICAgICAgICAgLy8KICAgICAgICAgICAgLy8gS2VlcCB0ZW1wb3JhcnkgdmFyaWFibGUgc28gaXQgY2FuIGJlIGluY3JlbWVudGVkIGluIHBsYWNlLgogICAgICAgICAgICAvLwogICAgICAgICAgICAvLyBOT1RFOiBpbmNyZW1lbnRpbmcgZGF0YSB3b3VsZCByZXN1bHQgaW4gYW4gdW51c2FibGUKICAgICAgICAgICAgLy8gICAgICAgZGF0YSB2YXJpYWJsZSBhZnRlciB0aGlzIGFzc2VtYmx5IGJsb2NrCiAgICAgICAgICAgIGxldCBkYXRhRWxlbWVudExvY2F0aW9uIDo9IGFkZChkYXRhLCAweDIwKQoKICAgICAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCB0aGUgYm91bmQgaXMgbm90IG1ldC4KICAgICAgICAgICAgZm9yCiAgICAgICAgICAgICAgICB7IGxldCBlbmQgOj0gYWRkKGRhdGFFbGVtZW50TG9jYXRpb24sIG11bChsZW4sIDB4MjApKSB9CiAgICAgICAgICAgICAgICBsdChkYXRhRWxlbWVudExvY2F0aW9uLCBlbmQpCiAgICAgICAgICAgICAgICB7IGRhdGFFbGVtZW50TG9jYXRpb24gOj0gYWRkKGRhdGFFbGVtZW50TG9jYXRpb24sIDB4MjApIH0KICAgICAgICAgICAgewogICAgICAgICAgICAgICAgc3VtIDo9IGFkZChzdW0sIG1sb2FkKGRhdGFFbGVtZW50TG9jYXRpb24pKQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.16 <0.9.0;
library VectorSum {
 // This function is less efficient because the optimizer currently fails to
 // remove the bounds checks in array access.
 function sumSolidity(uint\[\] memory data) public pure returns (uint sum) {
 for (uint i \= 0; i < data.length; ++i)
 sum += data\[i\];
 }
 // We know that we only access the array in bounds, so we can avoid the check.
 // 0x20 needs to be added to an array because the first slot contains the
 // array length.
 function sumAsm(uint\[\] memory data) public pure returns (uint sum) {
 for (uint i \= 0; i < data.length; ++i) {
 assembly {
 sum := add(sum, mload(add(add(data, 0x20), mul(i, 0x20))))
 }
 }
 }
 // Same as above, but accomplish the entire code within inline assembly.
 function sumPureAsm(uint\[\] memory data) public pure returns (uint sum) {
 assembly {
 // Load the length (first 32 bytes)
 let len := mload(data)
 // Skip over the length field.
 //
 // Keep temporary variable so it can be incremented in place.
 //
 // NOTE: incrementing data would result in an unusable
 // data variable after this assembly block
 let dataElementLocation := add(data, 0x20)
 // Iterate until the bound is not met.
 for
 { let end := add(dataElementLocation, mul(len, 0x20)) }
 lt(dataElementLocation, end)
 { dataElementLocation := add(dataElementLocation, 0x20) }
 {
 sum := add(sum, mload(dataElementLocation))
 }
 }
 }
}
## Access to External Variables, Functions and Libraries[](#access-to-external-variables-functions-and-libraries "Link to this heading")
You can access Solidity variables and other identifiers by using their name.
Local variables of value type are directly usable in inline assembly. They can both be read and assigned to.
Local variables that refer to memory evaluate to the address of the variable in memory, not the value itself. Such variables can also be assigned to, but note that an assignment will only change the pointer and not the data and that it is your responsibility to respect Solidity’s memory management. See [Conventions in Solidity](#conventions-in-solidity).
Similarly, local variables that refer to statically-sized calldata arrays or calldata structs evaluate to the address of the variable in calldata, not the value itself. The variable can also be assigned a new offset, but note that no validation is performed to ensure that the variable will not point beyond `calldatasize()`.
For external function pointers the address and the function selector can be accessed using `x.address` and `x.selector`. The selector consists of four right-aligned bytes. Both values can be assigned to. For example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjEwIDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgLy8gQXNzaWducyBhIG5ldyBzZWxlY3RvciBhbmQgYWRkcmVzcyB0byB0aGUgcmV0dXJuIHZhcmlhYmxlIEBmdW4KICAgIGZ1bmN0aW9uIGNvbWJpbmVUb0Z1bmN0aW9uUG9pbnRlcihhZGRyZXNzIG5ld0FkZHJlc3MsIHVpbnQgbmV3U2VsZWN0b3IpIHB1YmxpYyBwdXJlIHJldHVybnMgKGZ1bmN0aW9uKCkgZXh0ZXJuYWwgZnVuKSB7CiAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICBmdW4uc2VsZWN0b3IgOj0gbmV3U2VsZWN0b3IKICAgICAgICAgICAgZnVuLmFkZHJlc3MgIDo9IG5ld0FkZHJlc3MKICAgICAgICB9CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.10 <0.9.0;
contract C {
 // Assigns a new selector and address to the return variable @fun
 function combineToFunctionPointer(address newAddress, uint newSelector) public pure returns (function() external fun) {
 assembly {
 fun.selector := newSelector
 fun.address := newAddress
 }
 }
}
For dynamic calldata arrays, you can access their calldata offset (in bytes) and length (number of elements) using `x.offset` and `x.length`. Both expressions can also be assigned to, but as for the static case, no validation will be performed to ensure that the resulting data area is within the bounds of `calldatasize()`.
For local storage variables or state variables (including transient storage) a single Yul identifier is not sufficient, since they do not necessarily occupy a single full storage slot. Therefore, their “address” is composed of a slot and a byte-offset inside that slot. To retrieve the slot pointed to by the variable `x`, you use `x.slot`, and to retrieve the byte-offset you use `x.offset`. Using `x` itself will result in an error.
You can also assign to the `.slot` part of a local storage variable pointer. For these (structs, arrays or mappings), the `.offset` part is always zero. It is not possible to assign to the `.slot` or `.offset` part of a state variable, though.
Local Solidity variables are available for assignments, for example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjI4IDwwLjkuMDsKCi8vIFRoaXMgd2lsbCByZXBvcnQgYSB3YXJuaW5nCmNvbnRyYWN0IEMgewogICAgYm9vbCB0cmFuc2llbnQgYTsKICAgIHVpbnQgYjsKICAgIGZ1bmN0aW9uIGYodWludCB4KSBwdWJsaWMgcmV0dXJucyAodWludCByKSB7CiAgICAgICAgYXNzZW1ibHkgewogICAgICAgICAgICAvLyBXZSBpZ25vcmUgdGhlIHN0b3JhZ2Ugc2xvdCBvZmZzZXQsIHdlIGtub3cgaXQgaXMgemVybwogICAgICAgICAgICAvLyBpbiB0aGlzIHNwZWNpYWwgY2FzZS4KICAgICAgICAgICAgciA6PSBtdWwoeCwgc2xvYWQoYi5zbG90KSkKICAgICAgICAgICAgdHN0b3JlKGEuc2xvdCwgdHJ1ZSkKICAgICAgICB9CiAgICB9Cn0=)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.28 <0.9.0;
// This will report a warning
contract C {
 bool transient a;
 uint b;
 function f(uint x) public returns (uint r) {
 assembly {
 // We ignore the storage slot offset, we know it is zero
 // in this special case.
 r := mul(x, sload(b.slot))
 tstore(a.slot, true)
 }
 }
}
Warning
If you access variables of a type that spans less than 256 bits (for example `uint64`, `address`, or `bytes16`), you cannot make any assumptions about bits not part of the encoding of the type. Especially, do not assume them to be zero. To be safe, always clear the data properly before you use it in a context where this is important: `uint32 x = f(); assembly { x := and(x, 0xffffffff) /* now use x */ }` To clean signed types, you can use the `signextend` opcode: `assembly { signextend(<num_bytes_of_x_minus_one>, x) }`
Since Solidity 0.6.0, the name of an inline assembly variable may not shadow any declaration visible in the scope of the inline assembly block (including variable, contract and function declarations).
Since Solidity 0.7.0, variables and functions declared inside the inline assembly block may not contain `.`, but using `.` is valid to access Solidity variables from outside the inline assembly block. However, it is still valid to use dots if you use Solidity in Yul-only mode.
## Things to Avoid[](#things-to-avoid "Link to this heading")
Inline assembly might have a quite high-level look, but it actually is extremely low-level. Function calls, loops, ifs and switches are converted by simple rewriting rules and after that, the only thing the assembler does for you is re-arranging functional-style opcodes, counting stack height for variable access and removing stack slots for assembly-local variables when the end of their block is reached.
## Conventions in Solidity[](#conventions-in-solidity "Link to this heading")
### Values of Typed Variables[](#values-of-typed-variables "Link to this heading")
In contrast to EVM assembly, Solidity has types which are narrower than 256 bits, e.g. `uint24`. For efficiency, most arithmetic operations ignore the fact that types can be shorter than 256 bits, and the higher-order bits are cleaned when necessary, i.e., shortly before they are written to memory or before comparisons are performed. This means that if you access such a variable from within inline assembly, you might have to manually clean the higher-order bits first.
### Memory Management[](#memory-management "Link to this heading")
Solidity manages memory in the following way. There is a “free memory pointer” at position `0x40` in memory. If you want to allocate memory, use the memory starting from where this pointer points at and update it. There is no guarantee that the memory has not been used before and thus you cannot assume that its contents are zero bytes. There is no built-in mechanism to release or free allocated memory. Solidity does not guarantee and does not require that the values in memory are placed at positions aligned to a multiple of any value. Here is an assembly snippet you can use for allocating memory that follows the process outlined above:
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.31&code=ZnVuY3Rpb24gYWxsb2NhdGUobGVuZ3RoKSAtPiBwb3MgewogIHBvcyA6PSBtbG9hZCgweDQwKQogIG1zdG9yZSgweDQwLCBhZGQocG9zLCBsZW5ndGgpKQp9)
function allocate(length) \-> pos {
 pos := mload(0x40)
 mstore(0x40, add(pos, length))
}
The first 64 bytes of memory can be used as “scratch space” for short-term allocation. The 32 bytes after the free memory pointer (i.e., starting at `0x60`) are meant to be zero permanently and is used as the initial value for empty dynamic memory arrays. This means that the allocatable memory starts at `0x80`, which is the initial value of the free memory pointer.
Elements in memory arrays in Solidity always occupy multiples of 32 bytes (this is even true for `bytes1[]`, but not for `bytes` and `string`). Multi-dimensional memory arrays are pointers to memory arrays. The length of a dynamic array is stored at the first slot of the array and followed by the array elements.
Warning
Statically-sized memory arrays do not have a length field, but it might be added later to allow better convertibility between statically and dynamically-sized arrays; so, do not rely on this.
### Memory Safety[](#memory-safety "Link to this heading")
Without the use of inline assembly, the compiler can rely on memory to remain in a well-defined state at all times. This is especially relevant for [the new code generation pipeline via Yul IR](https://docs.soliditylang.org/en/latest/ir-breaking-changes.html#ir-breaking-changes): this code generation path can move local variables from stack to memory to avoid stack-too-deep errors and perform additional memory optimizations, if it can rely on certain assumptions about memory use.
While we recommend to always respect Solidity’s memory model, inline assembly allows you to use memory in an incompatible way. Therefore, moving stack variables to memory and additional memory optimizations are, by default, globally disabled in the presence of any inline assembly block that contains a memory operation or assigns to Solidity variables in memory.
However, you can specifically annotate an assembly block to indicate that it in fact respects Solidity’s memory model as follows:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=YXNzZW1ibHkgKCJtZW1vcnktc2FmZSIpIHsKICAgIC4uLgp9)
assembly ("memory-safe") {
 ...
}
In particular, a memory-safe assembly block may only access the following memory ranges:
* Memory allocated by yourself using a mechanism like the `allocate` function described above.
 
* Memory allocated by Solidity, e.g. memory within the bounds of a memory array you reference.
 
* The scratch space between memory offset 0 and 64 mentioned above.
 
* Temporary memory that is located _after_ the value of the free memory pointer at the beginning of the assembly block, i.e. memory that is “allocated” at the free memory pointer without updating the free memory pointer.
 
Furthermore, if the assembly block assigns to Solidity variables in memory, you need to assure that accesses to the Solidity variables only access these memory ranges.
Since this is mainly about the optimizer, these restrictions still need to be followed, even if the assembly block reverts or terminates. As an example, the following assembly snippet is not memory safe, because the value of `returndatasize()` may exceed the 64 byte scratch space:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=YXNzZW1ibHkgewogIHJldHVybmRhdGFjb3B5KDAsIDAsIHJldHVybmRhdGFzaXplKCkpCiAgcmV2ZXJ0KDAsIHJldHVybmRhdGFzaXplKCkpCn0=)
assembly {
 returndatacopy(0, 0, returndatasize())
 revert(0, returndatasize())
}
On the other hand, the following code _is_ memory safe, because memory beyond the location pointed to by the free memory pointer can safely be used as temporary scratch space:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=YXNzZW1ibHkgKCJtZW1vcnktc2FmZSIpIHsKICBsZXQgcCA6PSBtbG9hZCgweDQwKQogIHJldHVybmRhdGFjb3B5KHAsIDAsIHJldHVybmRhdGFzaXplKCkpCiAgcmV2ZXJ0KHAsIHJldHVybmRhdGFzaXplKCkpCn0=)
assembly ("memory-safe") {
 let p := mload(0x40)
 returndatacopy(p, 0, returndatasize())
 revert(p, returndatasize())
}
Note that you do not need to update the free memory pointer if there is no following allocation, but you can only use memory starting from the current offset given by the free memory pointer.
If the memory operations use a length of zero, it is also fine to just use any offset (not only if it falls into the scratch space):
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=YXNzZW1ibHkgKCJtZW1vcnktc2FmZSIpIHsKICByZXZlcnQoMCwgMCkKfQ==)
assembly ("memory-safe") {
 revert(0, 0)
}
Note that not only memory operations in inline assembly itself can be memory-unsafe, but also assignments to Solidity variables of reference type in memory. For example the following is not memory-safe:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ynl0ZXMgbWVtb3J5IHg7CmFzc2VtYmx5IHsKICB4IDo9IDB4NDAKfQp4WzB4MjBdID0gMHg0Mjs=)
bytes memory x;
assembly {
 x := 0x40
}
x\[0x20\] \= 0x42;
Inline assembly that neither involves any operations that access memory nor assigns to any Solidity variables in memory is automatically considered memory-safe and does not need to be annotated.
Warning
It is your responsibility to make sure that the assembly actually satisfies the memory model. If you annotate an assembly block as memory-safe, but violate one of the memory assumptions, this **will** lead to incorrect and undefined behavior that cannot easily be discovered by testing.
In case you are developing a library that is meant to be compatible across multiple versions of Solidity, you can use a special comment to annotate an assembly block as memory-safe:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8vIEBzb2xpZGl0eSBtZW1vcnktc2FmZS1hc3NlbWJseQphc3NlbWJseSB7CiAgICAuLi4KfQ==)
/// @solidity memory-safe-assembly
assembly {
 ...
}
Note that we will disallow the annotation via comment in a future breaking release; so, if you are not concerned with backward-compatibility with older compiler versions, prefer using the dialect string.
## Advanced Safe Use of Memory[](#advanced-safe-use-of-memory "Link to this heading")
Beyond the strict definition of memory-safety given above, there are cases in which you may want to use more than 64 bytes of scratch space starting at memory offset `0`. If you are careful, it can be admissible to use memory up to (and not including) offset `0x80` and still safely declare the assembly block as `memory-safe`. This is admissible under either of the following conditions:
* By the end of the assembly block, the free memory pointer at offset `0x40` is restored to a sane value (i.e. it is either restored to its original value or an increment of it due to a manual memory allocation), and the memory word at offset `0x60` is restored to a value of zero.
 
* The assembly block terminates, i.e. execution can never return to high-level Solidity code. This is the case, for example, if your assembly block unconditionally ends in calling the `revert` opcode.
 
Furthermore, you need to be aware that the default-value of dynamic arrays in Solidity point to memory offset `0x60`, so for the duration of temporarily changing the value at memory offset `0x60`, you can no longer rely on getting accurate length values when reading dynamic arrays, until you restore the zero value at `0x60`. To be more precise, we only guarantee safety when overwriting the zero pointer, if the remainder of the assembly snippet does not interact with the memory of high-level Solidity objects (including by reading from offsets previously stored in variables).

# [Solidity — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/index.html) 
 _https://docs.soliditylang.org/en/v0.8.30/index.html_

Solidity is an object-oriented, high-level language for implementing smart contracts. Smart contracts are programs that govern the behavior of accounts within the Ethereum state.
Solidity is a [curly-bracket language](https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Curly_bracket_languages) designed to target the Ethereum Virtual Machine (EVM). It is influenced by C++, Python, and JavaScript. You can find more details about which languages Solidity has been inspired by in the [language influences](https://docs.soliditylang.org/en/v0.8.30/language-influences.html) section.
Solidity is statically typed, supports inheritance, libraries, and complex user-defined types, among other features.
With Solidity, you can create contracts for uses such as voting, crowdfunding, blind auctions, and multi-signature wallets.
When deploying contracts, you should use the latest released version of Solidity. Apart from exceptional cases, only the latest version receives [security fixes](https://github.com/ethereum/solidity/security/policy#supported-versions). Furthermore, breaking changes, as well as new features, are introduced regularly. We currently use a 0.y.z version number [to indicate this fast pace of change](https://semver.org/#spec-item-4).
Warning
Solidity recently released the 0.8.x version that introduced a lot of breaking changes. Make sure you read [the full list](https://docs.soliditylang.org/en/v0.8.30/080-breaking-changes.html).
Ideas for improving Solidity or this documentation are always welcome, read our [contributors guide](https://docs.soliditylang.org/en/v0.8.30/contributing.html) for more details.
Hint
You can download this documentation as PDF, HTML or Epub by clicking on the versions flyout menu in the bottom-right corner and selecting the preferred download format.
## Getting Started[](#getting-started "Link to this heading")
**1\. Understand the Smart Contract Basics**
If you are new to the concept of smart contracts, we recommend you to get started by digging into the “Introduction to Smart Contracts” section, which covers the following:
* [A simple example smart contract](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#simple-smart-contract) written in Solidity.
 
* [Blockchain Basics](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#blockchain-basics).
 
* [The Ethereum Virtual Machine](https://docs.soliditylang.org/en/v0.8.30/introduction-to-smart-contracts.html#the-ethereum-virtual-machine).
 
**2\. Get to Know Solidity**
Once you are accustomed to the basics, we recommend you read the [“Solidity by Example”](https://docs.soliditylang.org/en/v0.8.30/solidity-by-example.html) and “Language Description” sections to understand the core concepts of the language.
**3\. Install the Solidity Compiler**
There are various ways to install the Solidity compiler, simply choose your preferred option and follow the steps outlined on the [installation page](https://docs.soliditylang.org/en/v0.8.30/installing-solidity.html#installing-solidity).
Hint
You can try out code examples directly in your browser with the [Remix IDE](https://remix.ethereum.org/). Remix is a web browser-based IDE that allows you to write, deploy and administer Solidity smart contracts, without the need to install Solidity locally.
Warning
As humans write software, it can have bugs. Therefore, you should follow established software development best practices when writing your smart contracts. This includes code review, testing, audits, and correctness proofs. Smart contract users are sometimes more confident with code than their authors, and blockchains and smart contracts have their own unique issues to watch out for, so before working on production code, make sure you read the [Security Considerations](https://docs.soliditylang.org/en/v0.8.30/security-considerations.html#security-considerations) section.
**4\. Learn More**
If you want to learn more about building decentralized applications on Ethereum, the [Ethereum Developer Resources](https://ethereum.org/en/developers/) can help you with further general documentation around Ethereum, and a wide selection of tutorials, tools, and development frameworks.
If you have any questions, you can try searching for answers or asking on the [Ethereum StackExchange](https://ethereum.stackexchange.com/), or our [Gitter channel](https://gitter.im/ethereum/solidity).
## Translations[](#translations "Link to this heading")
Community contributors help translate this documentation into several languages. Note that they have varying degrees of completeness and up-to-dateness. The English version stands as a reference.
You can switch between languages by clicking on the flyout menu in the bottom-left corner and selecting the preferred language.
* [Chinese](https://docs.soliditylang.org/zh-cn/latest/)
 
* [French](https://docs.soliditylang.org/fr/latest/)
 
* [Indonesian](https://github.com/solidity-docs/id-indonesian)
 
* [Japanese](https://github.com/solidity-docs/ja-japanese)
 
* [Korean](https://github.com/solidity-docs/ko-korean)
 
* [Persian](https://github.com/solidity-docs/fa-persian)
 
* [Russian](https://github.com/solidity-docs/ru-russian)
 
* [Spanish](https://github.com/solidity-docs/es-spanish)
 
* [Turkish](https://docs.soliditylang.org/tr/latest/)
 
Note
We set up a GitHub organization and translation workflow to help streamline the community efforts. Please refer to the translation guide in the [solidity-docs org](https://github.com/solidity-docs) for information on how to start a new language or contribute to the community translations.

# [Layout of a Solidity Source File — Solidity 0.4.26 documentation](https://docs.soliditylang.org/en/v0.4.26/layout-of-source-files.html) 
 _https://docs.soliditylang.org/en/v0.4.26/layout-of-source-files.html_

### Syntax and Semantics[¶](#syntax-and-semantics "Permalink to this headline")
Solidity supports import statements that are very similar to those available in JavaScript (from ES6 on), although Solidity does not know the concept of a “default export”.
At a global level, you can use import statements of the following form:
This statement imports all global symbols from “filename” (and symbols imported there) into the current global scope (different than in ES6 but backwards-compatible for Solidity).
import \* as symbolName from "filename";
…creates a new global symbol `symbolName` whose members are all the global symbols from `"filename"`.
import {symbol1 as alias, symbol2} from "filename";
…creates new global symbols `alias` and `symbol2` which reference `symbol1` and `symbol2` from `"filename"`, respectively.
Another syntax is not part of ES6, but probably convenient:
import "filename" as symbolName;
which is equivalent to `import * as symbolName from "filename";`.
### Paths[¶](#paths "Permalink to this headline")
In the above, `filename` is always treated as a path with `/` as directory separator, `.` as the current and `..` as the parent directory. When `.` or `..` is followed by a character except `/`, it is not considered as the current or the parent directory. All path names are treated as absolute paths unless they start with the current `.` or the parent directory `..`.
To import a file `x` from the same directory as the current file, use `import "./x" as x;`. If you use `import "x" as x;` instead, a different file could be referenced (in a global “include directory”).
It depends on the compiler (see below) how to actually resolve the paths. In general, the directory hierarchy does not need to strictly map onto your local filesystem, it can also map to resources discovered via e.g. ipfs, http or git.
### Use in Actual Compilers[¶](#use-in-actual-compilers "Permalink to this headline")
When the compiler is invoked, it is not only possible to specify how to discover the first element of a path, but it is possible to specify path prefix remappings so that e.g. `github.com/ethereum/dapp-bin/library` is remapped to `/usr/local/dapp-bin/library` and the compiler will read the files from there. If multiple remappings can be applied, the one with the longest key is tried first. This allows for a “fallback-remapping” with e.g. `""` maps to `"/usr/local/include/solidity"`. Furthermore, these remappings can depend on the context, which allows you to configure packages to import e.g. different versions of a library of the same name.
**solc**:
For solc (the commandline compiler), these remappings are provided as `context:prefix=target` arguments, where both the `context:` and the `=target` parts are optional (where target defaults to prefix in that case). All remapping values that are regular files are compiled (including their dependencies). This mechanism is completely backwards-compatible (as long as no filename contains = or :) and thus not a breaking change. All imports in files in or below the directory `context` that import a file that starts with `prefix` are redirected by replacing `prefix` by `target`.
So as an example, if you clone `github.com/ethereum/dapp-bin/` locally to `/usr/local/dapp-bin`, you can use the following in your source file:
import "github.com/ethereum/dapp-bin/library/iterable\_mapping.sol" as it\_mapping;
and then run the compiler as
solc github.com/ethereum/dapp-bin/\=/usr/local/dapp-bin/ source.sol
As a more complex example, suppose you rely on some module that uses a very old version of dapp-bin. That old version of dapp-bin is checked out at `/usr/local/dapp-bin_old`, then you can use
solc module1:github.com/ethereum/dapp-bin/\=/usr/local/dapp-bin/ \\
 module2:github.com/ethereum/dapp-bin/\=/usr/local/dapp-bin\_old/ \\
 source.sol
so that all imports in `module2` point to the old version but imports in `module1` get the new version.
Note that solc only allows you to include files from certain directories: They have to be in the directory (or subdirectory) of one of the explicitly specified source files or in the directory (or subdirectory) of a remapping target. If you want to allow direct absolute includes, just add the remapping `=/`.
If there are multiple remappings that lead to a valid file, the remapping with the longest common prefix is chosen.
**Remix**:
[Remix](https://remix.ethereum.org/) provides an automatic remapping for github and will also automatically retrieve the file over the network: You can import the iterable mapping by e.g. `import "github.com/ethereum/dapp-bin/library/iterable_mapping.sol" as it_mapping;`.
Other source code providers may be added in the future.

# [Layout of State Variables in Storage and Transient Storage — Solidity 0.8.31 documentation](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html) 
 _https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html_

Note
The rules described in this section apply for both storage and transient storage data locations. The layouts are completely independent and don’t interfere with each other’s variable locations. Thus storage and transient storage state variables can be safely interleaved without any side effects. Only value types are supported for transient storage.
State variables of contracts are stored in storage in a compact way such that multiple values sometimes use the same storage slot. Except for dynamically-sized arrays and mappings (see below), data is stored contiguously item after item starting with the first state variable, which is stored in slot `0`. For each variable, a size in bytes is determined according to its type. Multiple, contiguous items that need less than 32 bytes are packed into a single storage slot if possible, according to the following rules:
* The first item in a storage slot is stored lower-order aligned.
 
* Value types use only as many bytes as are necessary to store them.
 
* If a value type does not fit the remaining part of a storage slot, it is stored in the next storage slot.
 
* Structs and array data always start a new slot and their items are packed tightly according to these rules.
 
* Items following struct or array data always start a new storage slot.
 
For contracts that use inheritance, the ordering of state variables is determined by the C3-linearized order of contracts starting with the most base-ward contract. If allowed by the above rules, state variables from different contracts do share the same storage slot.
The elements of structs and arrays are stored after each other, just as if they were given as individual values.
If a contract specifies a [custom storage layout](https://docs.soliditylang.org/en/latest/contracts.html#custom-storage-layout), the slots assigned to static storage variables are shifted according the value defined as the layout base. Locations of dynamic arrays and mappings are also indirectly affected by this due to shifting of the static slots they are based on. The custom layout is specified in the most derived contract and, following the order explained above, starting from the most base-ward contract’s variables, all storage slots are adjusted.
In the following example, contract `C` inherits from contracts `A` and `B` and also specifies a custom storage base slot. The result is that all storage variable slots of the inheritance tree are adjusted according to the value specified by `C`.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjk7CgpzdHJ1Y3QgUyB7CiAgICBpbnQzMiB4OwogICAgYm9vbCB5Owp9Cgpjb250cmFjdCBBIHsKICAgIHVpbnQgYTsKICAgIHVpbnQxMjggdHJhbnNpZW50IGI7CiAgICB1aW50IGNvbnN0YW50IGMgPSAxMDsKICAgIHVpbnQgaW1tdXRhYmxlIGQgPSAxMjsKfQoKY29udHJhY3QgQiB7CiAgICB1aW50OFtdIGU7CiAgICBtYXBwaW5nKHVpbnQgPT4gUykgZjsKICAgIHVpbnQxNiBnOwogICAgdWludDE2IGg7CiAgICBieXRlczE2IHRyYW5zaWVudCBpOwogICAgUyBzOwogICAgaW50OCBrOwp9Cgpjb250cmFjdCBDIGlzIEEsIEIgbGF5b3V0IGF0IDQyIHsKICAgIGJ5dGVzMjEgbDsKICAgIHVpbnQ4WzEwXSBtOwogICAgYnl0ZXM1WzhdIG47CiAgICBieXRlczUgbzsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.29;
struct S {
 int32 x;
 bool y;
}
contract A {
 uint a;
 uint128 transient b;
 uint constant c \= 10;
 uint immutable d \= 12;
}
contract B {
 uint8\[\] e;
 mapping(uint \=> S) f;
 uint16 g;
 uint16 h;
 bytes16 transient i;
 S s;
 int8 k;
}
contract C is A, B layout at 42 {
 bytes21 l;
 uint8\[10\] m;
 bytes5\[8\] n;
 bytes5 o;
}
In the example, the storage layout starts with the inherited state variable `a` stored directly inside the base slot (slot `42`). Transient, constant and immutable variables are stored in separate locations, and thus, `b`, `i`, `c` and `d` have no effect on the storage layout. Then we get to the dynamic array `e` and mapping `f`. They both reserve a whole slot whose address will be used to [calculate](#storage-hashed-encoding) the location where their data is actually stored. The slot cannot be shared with any other variable, because the resulting addresses must be unique. The next two variables, `g` and `h`, need 2 bytes each and can be packed together into slot `45`, at offsets `0` and `2` respectively. Since `s` is a struct, its two members are packed contiguously, each taking up 5 bytes. Even though they both would still fit in slot `45`, structs and arrays always start a new slot. Therefore, `s` is placed in slot `46` and the next variable, `k`, in slot `47`. Base contracts, on the other hand, can share slots with derived ones, so `l` does not require an new one. Then variable `m`, which is an array of 10 items, gets into slot `48` and takes up 10 bytes. `n` is an array as well, but due to the size of its items, cannot fill its first slot perfectly and spills over to the next one. Finally, variable `o` ends up in slot `51`, even though it is of the same type as items of `n`. As explained before, variables after structs and arrays always start a new slot.
Putting it all together, the storage and transient storage layouts of contract `C` can be illustrated as follows:
* Storage:
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=NDIgW2FhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhXQo0MyBbZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVdCjQ0IFtmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZl0KNDUgWyAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaGdnXQo0NiBbICAgICAgICAgICAgICAgICAgICAgICAgICAgeXh4eHhdCjQ3IFsgICAgICAgICAgbGxsbGxsbGxsbGxsbGxsbGxsbGxsa10KNDggWyAgICAgICAgICAgICAgICAgICAgICBtbW1tbW1tbW1tXQo0OSBbICBubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5dCjUwIFsgICAgICAgICAgICAgICAgICAgICAgbm5ubm5ubm5ubl0KNTEgWyAgICAgICAgICAgICAgICAgICAgICAgICAgIG9vb29vXQ==)
 
 42 \[aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\]
 43 \[eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\]
 44 \[ffffffffffffffffffffffffffffffff\]
 45 \[ hhgg\]
 46 \[ yxxxx\]
 47 \[ lllllllllllllllllllllk\]
 48 \[ mmmmmmmmmm\]
 49 \[ nnnnnnnnnnnnnnnnnnnnnnnnnnnnnn\]
 50 \[ nnnnnnnnnn\]
 51 \[ ooooo\]
 
* Transient storage:
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=MDAgW2lpaWlpaWlpaWlpaWlpaWliYmJiYmJiYmJiYmJiYmJiXQ==)
 
 00 \[iiiiiiiiiiiiiiiibbbbbbbbbbbbbbbb\]
 
Note that the storage specifier affects `A` and `B` only as a part of `C`’s inheritance hierarchy. When deployed independently, their storage starts at `0`:
* Storage layout of `A`:
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=MDAgW2FhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhXQ==)
 
 00 \[aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\]
 
* Storage layout of `B`:
 
 [open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=MDAgW2VlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlXQowMSBbZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZdCjAyIFsgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGhnZ10KMDMgWyAgICAgICAgICAgICAgICAgICAgICAgICAgIHl4eHh4XQowNCBbICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtd)
 
 00 \[eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\]
 01 \[ffffffffffffffffffffffffffffffff\]
 02 \[ hhgg\]
 03 \[ yxxxx\]
 04 \[ k\]
 
Warning
When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.
It might be beneficial to use reduced-size types if you are dealing with storage values because the compiler will pack multiple elements into one storage slot, and thus, combine multiple reads or writes into a single operation. If you are not reading or writing all the values in a slot at the same time, this can have the opposite effect, though: When one value is written to a multi-value storage slot, the storage slot has to be read first and then combined with the new value such that other data in the same slot is not destroyed.
When dealing with function arguments or memory values, there is no inherent benefit because the compiler does not pack these values.
Finally, in order to allow the EVM to optimize for this, ensure that you try to order your storage variables and `struct` members such that they can be packed tightly. For example, declaring your storage variables in the order of `uint128, uint128, uint256` instead of `uint128, uint256, uint128`, as the former will only take up two slots of storage whereas the latter will take up three.
Note
The layout of state variables in storage is considered to be part of the external interface of Solidity due to the fact that storage pointers can be passed to libraries. This means that any change to the rules outlined in this section is considered a breaking change of the language and due to its critical nature should be considered very carefully before being executed. In the event of such a breaking change, we would want to release a compatibility mode in which the compiler would generate bytecode supporting the old layout.
## Mappings and Dynamic Arrays[](#mappings-and-dynamic-arrays "Link to this heading")
Due to their unpredictable size, mappings and dynamically-sized array types cannot be stored “in between” the state variables preceding and following them. Instead, they are considered to occupy only 32 bytes with regards to the [rules above](#storage-inplace-encoding) and the elements they contain are stored starting at a different storage slot that is computed using a Keccak-256 hash.
Assume the storage location of the mapping or array ends up being a slot `p` after applying [the storage layout rules](#storage-inplace-encoding). For dynamic arrays, this slot stores the number of elements in the array (byte arrays and strings are an exception, see [below](#bytes-and-string)). For mappings, the slot stays empty, but it is still needed to ensure that even if there are two mappings next to each other, their content ends up at different storage locations.
Array data is located starting at `keccak256(p)` and it is laid out in the same way as statically-sized array data would: One element after the other, potentially sharing storage slots if the elements are not longer than 16 bytes. Dynamic arrays of dynamic arrays apply this rule recursively. The location of element `x[i][j]`, where the type of `x` is `uint24[][]`, is computed as follows (again, assuming `x` itself is stored at slot `p`): The slot is `keccak256(keccak256(p) + i) + floor(j / floor(256 / 24))` and the element can be obtained from the slot data `v` using `(v >> ((j % floor(256 / 24)) * 24)) & type(uint24).max`.
The value corresponding to a mapping key `k` is located at `keccak256(h(k) . p)` where `.` is concatenation and `h` is a function that is applied to the key depending on its type:
* for value types, `h` pads the value to 32 bytes in the same way as when storing the value in memory.
 
* for strings and byte arrays, `h(k)` is just the unpadded data.
 
If the mapping value is a non-value type, the computed slot marks the start of the data. If the value is of struct type, for example, you have to add an offset corresponding to the struct member to reach the member.
As an example, consider the following contract:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKCmNvbnRyYWN0IEMgewogICAgc3RydWN0IFMgeyB1aW50MTYgYTsgdWludDE2IGI7IHVpbnQyNTYgYzsgfQogICAgdWludCB4OwogICAgbWFwcGluZyh1aW50ID0+IG1hcHBpbmcodWludCA9PiBTKSkgZGF0YTsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.4.0 <0.9.0;
contract C {
 struct S { uint16 a; uint16 b; uint256 c; }
 uint x;
 mapping(uint \=> mapping(uint \=> S)) data;
}
Let us compute the storage location of `data[4][9].c`. The position of the mapping itself is `1` (the variable `x` with 32 bytes precedes it). This means `data[4]` is stored at `keccak256(uint256(4) . uint256(1))`. The type of `data[4]` is again a mapping and the data for `data[4][9]` starts at slot `keccak256(uint256(9) . keccak256(uint256(4) . uint256(1)))`. The slot offset of the member `c` inside the struct `S` is `1` because `a` and `b` are packed in a single slot. This means the slot for `data[4][9].c` is `keccak256(uint256(9) . keccak256(uint256(4) . uint256(1))) + 1`. The type of the value is `uint256`, so it uses a single slot.
### `bytes` and `string`[](#bytes-and-string "Link to this heading")
`bytes` and `string` are encoded identically. In general, the encoding is similar to `bytes1[]`, in the sense that there is a slot for the array itself and a data area that is computed using a `keccak256` hash of that slot’s position. However, for short values (shorter than 32 bytes) the array elements are stored together with the length in the same slot.
In particular: if the data is at most `31` bytes long, the elements are stored in the higher-order bytes (left aligned) and the lowest-order byte stores the value `length * 2`. For byte arrays that store data which is `32` or more bytes long, the main slot `p` stores `length * 2 + 1` and the data is stored as usual in `keccak256(p)`. This means that you can distinguish a short array from a long array by checking if the lowest bit is set: short (not set) and long (set).
Note
Handling invalidly encoded slots is currently not supported but may be added in the future. If you are compiling via IR, reading an invalidly encoded slot results in a `Panic(0x22)` error.
## JSON Output[](#json-output "Link to this heading")
The storage (or transient storage) layout of a contract can be requested via the [standard JSON interface](https://docs.soliditylang.org/en/latest/using-the-compiler.html#compiler-api). The output is a JSON object containing two keys, `storage` and `types`. The `storage` object is an array where each element has the following form:
{
 "astId": 2,
 "contract": "fileA:A",
 "label": "x",
 "offset": 0,
 "slot": "0",
 "type": "t\_uint256"
}
The example above is the storage layout of `contract A { uint x; }` from source unit `fileA` and
* `astId` is the id of the AST node of the state variable’s declaration
 
* `contract` is the name of the contract including its path as prefix
 
* `label` is the name of the state variable
 
* `offset` is the offset in bytes within the storage slot according to the encoding
 
* `slot` is the storage slot where the state variable resides or starts. This number may be very large and therefore its JSON value is represented as a string.
 
* `type` is an identifier used as key to the variable’s type information (described in the following)
 
The given `type`, in this case `t_uint256` represents an element in `types`, which has the form:
{
 "encoding": "inplace",
 "label": "uint256",
 "numberOfBytes": "32",
}
where
* `encoding` how the data is encoded in storage, where the possible values are:
 
 * `inplace`: data is laid out contiguously in storage (see [above](#storage-inplace-encoding)).
 
 * `mapping`: Keccak-256 hash-based method (see [above](#storage-hashed-encoding)).
 
 * `dynamic_array`: Keccak-256 hash-based method (see [above](#storage-hashed-encoding)).
 
 * `bytes`: single slot or Keccak-256 hash-based depending on the data size (see [above](#bytes-and-string)).
 
* `label` is the canonical type name.
 
* `numberOfBytes` is the number of used bytes (as a decimal string). Note that if `numberOfBytes > 32` this means that more than one slot is used.
 
Some types have extra information besides the four above. Mappings contain its `key` and `value` types (again referencing an entry in this mapping of types), arrays have its `base` type, and structs list their `members` in the same format as the top-level `storage` (see [above](#storage-layout-top-level)).
Note
The JSON output format of a contract’s storage layout is still considered experimental and is subject to change in non-breaking releases of Solidity.
The following example shows a contract and both its storage and transient storage layout, containing value and reference types, types that are encoded packed, and nested types.
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.31&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMjg7CmNvbnRyYWN0IEEgewogICAgc3RydWN0IFMgewogICAgICAgIHVpbnQxMjggYTsKICAgICAgICB1aW50MTI4IGI7CiAgICAgICAgdWludFsyXSBzdGF0aWNBcnJheTsKICAgICAgICB1aW50W10gZHluQXJyYXk7CiAgICB9CgogICAgdWludCB4OwogICAgdWludCB0cmFuc2llbnQgeTsKICAgIHVpbnQgdzsKICAgIHVpbnQgdHJhbnNpZW50IHo7CgogICAgUyBzOwogICAgYWRkcmVzcyBhZGRyOwogICAgYWRkcmVzcyB0cmFuc2llbnQgdGFkZHI7CiAgICBtYXBwaW5nKHVpbnQgPT4gbWFwcGluZyhhZGRyZXNzID0+IGJvb2wpKSBtYXA7CiAgICB1aW50W10gYXJyYXk7CiAgICBzdHJpbmcgczE7CiAgICBieXRlcyBiMTsKfQ==)
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.28;
contract A {
 struct S {
 uint128 a;
 uint128 b;
 uint\[2\] staticArray;
 uint\[\] dynArray;
 }
 uint x;
 uint transient y;
 uint w;
 uint transient z;
 S s;
 address addr;
 address transient taddr;
 mapping(uint \=> mapping(address \=> bool)) map;
 uint\[\] array;
 string s1;
 bytes b1;
}
### Storage Layout[](#storage-layout "Link to this heading")
{
 "storage": \[
 {
 "astId": 15,
 "contract": "fileA:A",
 "label": "x",
 "offset": 0,
 "slot": "0",
 "type": "t\_uint256"
 },
 {
 "astId": 19,
 "contract": "fileA:A",
 "label": "w",
 "offset": 0,
 "slot": "1",
 "type": "t\_uint256"
 },
 {
 "astId": 24,
 "contract": "fileA:A",
 "label": "s",
 "offset": 0,
 "slot": "2",
 "type": "t\_struct(S)13\_storage"
 },
 {
 "astId": 26,
 "contract": "fileA:A",
 "label": "addr",
 "offset": 0,
 "slot": "6",
 "type": "t\_address"
 },
 {
 "astId": 34,
 "contract": "fileA:A",
 "label": "map",
 "offset": 0,
 "slot": "7",
 "type": "t\_mapping(t\_uint256,t\_mapping(t\_address,t\_bool))"
 },
 {
 "astId": 37,
 "contract": "fileA:A",
 "label": "array",
 "offset": 0,
 "slot": "8",
 "type": "t\_array(t\_uint256)dyn\_storage"
 },
 {
 "astId": 39,
 "contract": "fileA:A",
 "label": "s1",
 "offset": 0,
 "slot": "9",
 "type": "t\_string\_storage"
 },
 {
 "astId": 41,
 "contract": "fileA:A",
 "label": "b1",
 "offset": 0,
 "slot": "10",
 "type": "t\_bytes\_storage"
 }
 \],
 "types": {
 "t\_address": {
 "encoding": "inplace",
 "label": "address",
 "numberOfBytes": "20"
 },
 "t\_array(t\_uint256)2\_storage": {
 "base": "t\_uint256",
 "encoding": "inplace",
 "label": "uint256\[2\]",
 "numberOfBytes": "64"
 },
 "t\_array(t\_uint256)dyn\_storage": {
 "base": "t\_uint256",
 "encoding": "dynamic\_array",
 "label": "uint256\[\]",
 "numberOfBytes": "32"
 },
 "t\_bool": {
 "encoding": "inplace",
 "label": "bool",
 "numberOfBytes": "1"
 },
 "t\_bytes\_storage": {
 "encoding": "bytes",
 "label": "bytes",
 "numberOfBytes": "32"
 },
 "t\_mapping(t\_address,t\_bool)": {
 "encoding": "mapping",
 "key": "t\_address",
 "label": "mapping(address => bool)",
 "numberOfBytes": "32",
 "value": "t\_bool"
 },
 "t\_mapping(t\_uint256,t\_mapping(t\_address,t\_bool))": {
 "encoding": "mapping",
 "key": "t\_uint256",
 "label": "mapping(uint256 => mapping(address => bool))",
 "numberOfBytes": "32",
 "value": "t\_mapping(t\_address,t\_bool)"
 },
 "t\_string\_storage": {
 "encoding": "bytes",
 "label": "string",
 "numberOfBytes": "32"
 },
 "t\_struct(S)13\_storage": {
 "encoding": "inplace",
 "label": "struct A.S",
 "members": \[
 {
 "astId": 3,
 "contract": "fileA:A",
 "label": "a",
 "offset": 0,
 "slot": "0",
 "type": "t\_uint128"
 },
 {
 "astId": 5,
 "contract": "fileA:A",
 "label": "b",
 "offset": 16,
 "slot": "0",
 "type": "t\_uint128"
 },
 {
 "astId": 9,
 "contract": "fileA:A",
 "label": "staticArray",
 "offset": 0,
 "slot": "1",
 "type": "t\_array(t\_uint256)2\_storage"
 },
 {
 "astId": 12,
 "contract": "fileA:A",
 "label": "dynArray",
 "offset": 0,
 "slot": "3",
 "type": "t\_array(t\_uint256)dyn\_storage"
 }
 \],
 "numberOfBytes": "128"
 },
 "t\_uint128": {
 "encoding": "inplace",
 "label": "uint128",
 "numberOfBytes": "16"
 },
 "t\_uint256": {
 "encoding": "inplace",
 "label": "uint256",
 "numberOfBytes": "32"
 }
 }
}
### Transient Storage Layout[](#transient-storage-layout "Link to this heading")
{
 "storage": \[
 {
 "astId": 17,
 "contract": "fileA:A",
 "label": "y",
 "offset": 0,
 "slot": "0",
 "type": "t\_uint256"
 },
 {
 "astId": 21,
 "contract": "fileA:A",
 "label": "z",
 "offset": 0,
 "slot": "1",
 "type": "t\_uint256"
 },
 {
 "astId": 28,
 "contract": "fileA:A",
 "label": "taddr",
 "offset": 0,
 "slot": "2",
 "type": "t\_address"
 }
 \],
 "types": {
 "t\_address": {
 "encoding": "inplace",
 "label": "address",
 "numberOfBytes": "20"
 },
 "t\_uint256": {
 "encoding": "inplace",
 "label": "uint256",
 "numberOfBytes": "32"
 }
 }
}

# [The Optimizer — Solidity 0.8.30 documentation](https://docs.soliditylang.org/en/v0.8.30/internals/optimizer.html) 
 _https://docs.soliditylang.org/en/v0.8.30/internals/optimizer.html_

The Solidity compiler involves optimizations at three different levels (in order of execution):
* Optimizations during code generation based on a direct analysis of Solidity code.
 
* Optimizing transformations on the Yul IR code.
 
* Optimizations at the opcode level.
 
The opcode-based optimizer applies a set of [simplification rules](https://github.com/ethereum/solidity/blob/develop/libevmasm/RuleList.h) to opcodes. It also combines equal code sets and removes unused code.
The Yul-based optimizer is much more powerful, because it can work across function calls. For example, arbitrary jumps are not possible in Yul, so it is possible to compute the side-effects of each function. Consider two function calls, where the first does not modify storage and the second does modify storage. If their arguments and return values do not depend on each other, we can reorder the function calls. Similarly, if a function is side-effect free and its result is multiplied by zero, you can remove the function call completely.
The codegen-based optimizer affects the initial low-level code produced from the Solidity input. In the legacy pipeline, the bytecode is generated immediately and most of the optimizations of this kind are implicit and not configurable, the only exception being an optimization which changes the order of literals in binary operations. The IR-based pipeline takes a different approach and produces Yul IR closely matching the structure of the Solidity code, with nearly all optimizations deferred to the Yul optimizer module. In that case codegen-level optimization is done only in very limited cases which are difficult to handle in Yul IR, but are straightforward with the high-level information from analysis phase at hand. An example of such an optimization is the bypass of checked arithmetic when incrementing the counter in certain idiomatic `for` loops.
Currently, the parameter `--optimize` activates the opcode-based optimizer for the generated bytecode and the Yul optimizer for the Yul code generated internally, for example for ABI coder v2. One can use `solc --ir-optimized --optimize` to produce an optimized Yul IR for a Solidity source. Similarly, one can use `solc --strict-assembly --optimize` for a stand-alone Yul mode.
Note
An empty optimizer sequence, i.e `:`, is accepted even without `--optimize` in order to fully disable the user-supplied portion of the Yul [optimizer sequence](#selecting-optimizations), as by default, even when the optimizer is not turned on, the [unused pruner](#unused-pruner) step will be run.
You can find more details on both optimizer modules and their optimization steps below.
## Benefits of Optimizing Solidity Code[](#benefits-of-optimizing-solidity-code "Link to this heading")
Overall, the optimizer tries to simplify complicated expressions, which reduces both code size and execution cost, i.e., it can reduce gas needed for contract deployment as well as for external calls made to the contract. It also specializes or inlines functions. Especially function inlining is an operation that can cause much bigger code, but it is often done because it results in opportunities for more simplifications.
## Differences between Optimized and Non-Optimized Code[](#differences-between-optimized-and-non-optimized-code "Link to this heading")
Generally, the most visible difference is that constant expressions are evaluated at compile time. When it comes to the ASM output, one can also notice a reduction of equivalent or duplicate code blocks (compare the output of the flags `--asm` and `--asm --optimize`). However, when it comes to the Yul/intermediate-representation, there can be significant differences, for example, functions may be inlined, combined, or rewritten to eliminate redundancies, etc. (compare the output between the flags `--ir` and `--optimize --ir-optimized`).
## Optimizer Parameter Runs[](#optimizer-parameter-runs "Link to this heading")
The number of runs (`--optimize-runs`) specifies roughly how often each opcode of the deployed code will be executed across the life-time of the contract. This means it is a trade-off parameter between code size (deploy cost) and code execution cost (cost after deployment). A “runs” parameter of “1” will produce short but expensive code. In contrast, a larger “runs” parameter will produce longer but more gas efficient code. The maximum value of the parameter is `2**32-1`.
Note
A common misconception is that this parameter specifies the number of iterations of the optimizer. This is not true: The optimizer will always run as many times as it can still improve the code.
## Opcode-Based Optimizer Module[](#opcode-based-optimizer-module "Link to this heading")
The opcode-based optimizer module operates on assembly code. It splits the sequence of instructions into basic blocks at `JUMPs` and `JUMPDESTs`. Inside these blocks, the optimizer analyzes the instructions and records every modification to the stack, memory, or storage as an expression which consists of an instruction and a list of arguments which are pointers to other expressions.
Additionally, the opcode-based optimizer uses a component called “CommonSubexpressionEliminator” that, amongst other tasks, finds expressions that are always equal (on every input) and combines them into an expression class. It first tries to find each new expression in a list of already known expressions. If no such matches are found, it simplifies the expression according to rules like `constant + constant = sum_of_constants` or `X * 1 = X`. Since this is a recursive process, we can also apply the latter rule if the second factor is a more complex expression which we know always evaluates to one.
Certain optimizer steps symbolically track the storage and memory locations. For example, this information is used to compute Keccak-256 hashes that can be evaluated during compile time. Consider the sequence:
PUSH 32
PUSH 0
CALLDATALOAD
PUSH 100
DUP2
MSTORE
KECCAK256
or the equivalent Yul
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=bGV0IHggOj0gY2FsbGRhdGFsb2FkKDApCm1zdG9yZSh4LCAxMDApCmxldCB2YWx1ZSA6PSBrZWNjYWsyNTYoeCwgMzIp)
let x := calldataload(0)
mstore(x, 100)
let value := keccak256(x, 32)
In this case, the optimizer tracks the value at a memory location `calldataload(0)` and then realizes that the Keccak-256 hash can be evaluated at compile time. This only works if there is no other instruction that modifies memory between the `mstore` and `keccak256`. So if there is an instruction that writes to memory (or storage), then we need to erase the knowledge of the current memory (or storage). There is, however, an exception to this erasing, when we can easily see that the instruction doesn’t write to a certain location.
For example,
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=bGV0IHggOj0gY2FsbGRhdGFsb2FkKDApCm1zdG9yZSh4LCAxMDApCi8vIEN1cnJlbnQga25vd2xlZGdlIG1lbW9yeSBsb2NhdGlvbiB4IC0+IDEwMApsZXQgeSA6PSBhZGQoeCwgMzIpCi8vIERvZXMgbm90IGNsZWFyIHRoZSBrbm93bGVkZ2UgdGhhdCB4IC0+IDEwMCwgc2luY2UgeSBkb2VzIG5vdCB3cml0ZSB0byBbeCwgeCArIDMyKQptc3RvcmUoeSwgMjAwKQovLyBUaGlzIEtlY2Nhay0yNTYgY2FuIG5vdyBiZSBldmFsdWF0ZWQKbGV0IHZhbHVlIDo9IGtlY2NhazI1Nih4LCAzMik=)
let x := calldataload(0)
mstore(x, 100)
// Current knowledge memory location x -> 100
let y := add(x, 32)
// Does not clear the knowledge that x -> 100, since y does not write to \[x, x + 32)
mstore(y, 200)
// This Keccak-256 can now be evaluated
let value := keccak256(x, 32)
Therefore, modifications to storage and memory locations, of say location `l`, must erase knowledge about storage or memory locations which may be equal to `l`. More specifically, for storage, the optimizer has to erase all knowledge of symbolic locations, that may be equal to `l` and for memory, the optimizer has to erase all knowledge of symbolic locations that may not be at least 32 bytes away. If `m` denotes an arbitrary location, then this decision on erasure is done by computing the value `sub(l, m)`. For storage, if this value evaluates to a literal that is non-zero, then the knowledge about `m` will be kept. For memory, if the value evaluates to a literal that is between `32` and `2**256 - 32`, then the knowledge about `m` will be kept. In all other cases, the knowledge about `m` will be erased.
After this process, we know which expressions have to be on the stack at the end, and have a list of modifications to memory and storage. This information is stored together with the basic blocks and is used to link them. Furthermore, knowledge about the stack, storage and memory configuration is forwarded to the next block(s).
If we know the targets of all `JUMP` and `JUMPI` instructions, we can build a complete control flow graph of the program. If there is only one target we do not know (this can happen as in principle, jump targets can be computed from inputs), we have to erase all knowledge about the input state of a block as it can be the target of the unknown `JUMP`. If the opcode-based optimizer module finds a `JUMPI` whose condition evaluates to a constant, it transforms it to an unconditional jump.
As the last step, the code in each block is re-generated. The optimizer creates a dependency graph from the expressions on the stack at the end of the block, and it drops every operation that is not part of this graph. It generates code that applies the modifications to memory and storage in the order they were made in the original code (dropping modifications which were found not to be needed). Finally, it generates all values that are required to be on the stack in the correct place.
These steps are applied to each basic block and the newly generated code is used as replacement if it is smaller. If a basic block is split at a `JUMPI` and during the analysis, the condition evaluates to a constant, the `JUMPI` is replaced based on the value of the constant. Thus code like
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=dWludCB4ID0gNzsKZGF0YVs3XSA9IDk7CmlmIChkYXRhW3hdICE9IHggKyAyKSAvLyB0aGlzIGNvbmRpdGlvbiBpcyBuZXZlciB0cnVlCiAgcmV0dXJuIDI7CmVsc2UKICByZXR1cm4gMTs=)
uint x \= 7;
data\[7\] \= 9;
if (data\[x\] != x + 2) // this condition is never true
 return 2;
else
 return 1;
simplifies to this:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=ZGF0YVs3XSA9IDk7CnJldHVybiAxOw==)
### Simple Inlining[](#simple-inlining "Link to this heading")
Since Solidity version 0.8.2, there is another optimizer step that replaces certain jumps to blocks containing “simple” instructions ending with a “jump” by a copy of these instructions. This corresponds to inlining of simple, small Solidity or Yul functions. In particular, the sequence `PUSHTAG(tag) JUMP` may be replaced, whenever the `JUMP` is marked as jump “into” a function and behind `tag` there is a basic block (as described above for the “CommonSubexpressionEliminator”) that ends in another `JUMP` which is marked as a jump “out of” a function.
In particular, consider the following prototypical example of assembly generated for a call to an internal Solidity function:
 tag\_return
 tag\_f
 jump // in
tag\_return:
 ...opcodes after call to f...
tag\_f:
 ...body of function f...
 jump // out
As long as the body of the function is a continuous basic block, the “Inliner” can replace `tag_f jump` by the block at `tag_f` resulting in:
 tag\_return
 ...body of function f...
 jump
tag\_return:
 ...opcodes after call to f...
tag\_f:
 ...body of function f...
 jump // out
Now ideally, the other optimizer steps described above will result in the return tag push being moved towards the remaining jump resulting in:
 ...body of function f...
 tag\_return
 jump
tag\_return:
 ...opcodes after call to f...
tag\_f:
 ...body of function f...
 jump // out
In this situation the “PeepholeOptimizer” will remove the return jump. Ideally, all of this can be done for all references to `tag_f` leaving it unused, s.t. it can be removed, yielding:
...body of function f...
...opcodes after call to f...
So the call to function `f` is inlined and the original definition of `f` can be removed.
Inlining like this is attempted, whenever a heuristics suggests that inlining is cheaper over the lifetime of a contract than not inlining. This heuristics depends on the size of the function body, the number of other references to its tag (approximating the number of calls to the function) and the expected number of executions of the contract (the global optimizer parameter “runs”).
## Yul-Based Optimizer Module[](#yul-based-optimizer-module "Link to this heading")
The Yul-based optimizer consists of several stages and components that all transform the AST in a semantically equivalent way. The goal is to end up either with code that is shorter or at least only marginally longer but will allow further optimization steps.
Warning
Since the optimizer is under heavy development, the information here might be outdated. If you rely on a certain functionality, please reach out to the team directly.
The optimizer currently follows a purely greedy strategy and does not do any backtracking.
All components of the Yul-based optimizer module are explained below. The following transformation steps are the main components:
* SSATransform
 
* CommonSubexpressionEliminator
 
* ExpressionSimplifier
 
* UnusedAssignEliminator
 
* FullInliner
 
### Optimizer Steps[](#optimizer-steps "Link to this heading")
This is a list of all steps the Yul-based optimizer sorted alphabetically. You can find more information on the individual steps and their sequence below.
Some steps depend on properties ensured by `BlockFlattener`, `FunctionGrouper`, `ForLoopInitRewriter`. For this reason the Yul optimizer always applies them before applying any steps supplied by the user.
### Selecting Optimizations[](#selecting-optimizations "Link to this heading")
By default the optimizer applies its predefined sequence of optimization steps to the generated assembly. You can override this sequence and supply your own using the `--yul-optimizations` option:
solc \--optimize \--ir-optimized \--yul-optimizations 'dhfoD\[xarrscLMcCTU\]uljmul:fDnTOcmu'
The order of steps is significant and affects the quality of the output. Moreover, applying a step may uncover new optimization opportunities for others that were already applied, so repeating steps is often beneficial.
The sequence inside `[...]` will be applied multiple times in a loop until the Yul code remains unchanged or until the maximum number of rounds (currently 12) has been reached. Brackets (`[]`) may be used multiple times in a sequence, but can not be nested.
An important thing to note, is that there are some hardcoded steps that are always run before and after the user-supplied sequence, or the default sequence if one was not supplied by the user.
The cleanup sequence delimiter `:` is optional, and is used to supply a custom cleanup sequence in order to replace the default one. If omitted, the optimizer will simply apply the default cleanup sequence. In addition, the delimiter may be placed at the beginning of the user-supplied sequence, which will result in the optimization sequence being empty, whereas conversely, if placed at the end of the sequence, will be treated as an empty cleanup sequence.
### Preprocessing[](#preprocessing "Link to this heading")
The preprocessing components perform transformations to get the program into a certain normal form that is easier to work with. This normal form is kept during the rest of the optimization process.
#### Disambiguator[](#disambiguator "Link to this heading")
The disambiguator takes an AST and returns a fresh copy where all identifiers have unique names in the input AST. This is a prerequisite for all other optimizer stages. One of the benefits is that identifier lookup does not need to take scopes into account which simplifies the analysis needed for other steps.
All subsequent stages have the property that all names stay unique. This means if a new identifier needs to be introduced, a new unique name is generated.
#### FunctionHoister[](#functionhoister "Link to this heading")
The function hoister moves all function definitions to the end of the topmost block. This is a semantically equivalent transformation as long as it is performed after the disambiguation stage. The reason is that moving a definition to a higher-level block cannot decrease its visibility and it is impossible to reference variables defined in a different function.
The benefit of this stage is that function definitions can be looked up more easily and functions can be optimized in isolation without having to traverse the AST completely.
#### FunctionGrouper[](#functiongrouper "Link to this heading")
The function grouper has to be applied after the Disambiguator and the FunctionHoister. Its effect is that all topmost elements that are not function definitions are moved into a single block which is the first statement of the root block.
After this step, a program has the following normal form:
Where `I` is a (potentially empty) block that does not contain any function definitions (not even recursively) and `F` is a list of function definitions such that no function contains a function definition.
The benefit of this stage is that we always know where the list of functions begins.
#### ForLoopConditionIntoBody[](#forloopconditionintobody "Link to this heading")
This transformation moves the loop-iteration condition of a `for` loop into loop body. We need this transformation because [ExpressionSplitter](#expression-splitter) will not apply to iteration condition expressions (the `C` in the following example).
for { Init... } C { Post... } {
 Body...
}
is transformed to
for { Init... } 1 { Post... } {
 if iszero(C) { break }
 Body...
}
This transformation can also be useful when paired with LoopInvariantCodeMotion, since invariants in the loop-invariant conditions can then be taken outside the loop.
#### ForLoopInitRewriter[](#forloopinitrewriter "Link to this heading")
This transformation moves the initialization part of a `for` loop to before the loop:
for { Init... } C { Post... } {
 Body...
}
is transformed to
Init...
for {} C { Post... } {
 Body...
}
This eases the rest of the optimization process because we can ignore the complicated scoping rules of the `for` loop initialization block.
#### VarDeclInitializer[](#vardeclinitializer "Link to this heading")
This step rewrites variable declarations so that all of them are initialized. Declarations like `let x, y` are split into multiple declaration statements.
Only supports initializing with the zero literal for now.
### Pseudo-SSA Transformation[](#pseudo-ssa-transformation "Link to this heading")
The purpose of this components is to get the program into a longer form, so that other components can more easily work with it. The final representation will be similar to a static-single-assignment (SSA) form, with the difference that it does not make use of explicit “phi” functions which combines the values from different branches of control flow because such a feature does not exist in the Yul language. Instead, when control flow merges, if a variable is re-assigned in one of the branches, a new SSA variable is declared to hold its current value, so that the following expressions still only need to reference SSA variables.
An example transformation is the following:
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ewogICAgbGV0IGEgOj0gY2FsbGRhdGFsb2FkKDApCiAgICBsZXQgYiA6PSBjYWxsZGF0YWxvYWQoMHgyMCkKICAgIGlmIGd0KGEsIDApIHsKICAgICAgICBiIDo9IG11bChiLCAweDIwKQogICAgfQogICAgYSA6PSBhZGQoYSwgMSkKICAgIHNzdG9yZShhLCBhZGQoYiwgMHgyMCkpCn0=)
{
 let a := calldataload(0)
 let b := calldataload(0x20)
 if gt(a, 0) {
 b := mul(b, 0x20)
 }
 a := add(a, 1)
 sstore(a, add(b, 0x20))
}
When all the following transformation steps are applied, the program will look as follows:
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ewogICAgbGV0IF8xIDo9IDAKICAgIGxldCBhXzkgOj0gY2FsbGRhdGFsb2FkKF8xKQogICAgbGV0IGEgOj0gYV85CiAgICBsZXQgXzIgOj0gMHgyMAogICAgbGV0IGJfMTAgOj0gY2FsbGRhdGFsb2FkKF8yKQogICAgbGV0IGIgOj0gYl8xMAogICAgbGV0IF8zIDo9IDAKICAgIGxldCBfNCA6PSBndChhXzksIF8zKQogICAgaWYgXzQKICAgIHsKICAgICAgICBsZXQgXzUgOj0gMHgyMAogICAgICAgIGxldCBiXzExIDo9IG11bChiXzEwLCBfNSkKICAgICAgICBiIDo9IGJfMTEKICAgIH0KICAgIGxldCBiXzEyIDo9IGIKICAgIGxldCBfNiA6PSAxCiAgICBsZXQgYV8xMyA6PSBhZGQoYV85LCBfNikKICAgIGxldCBfNyA6PSAweDIwCiAgICBsZXQgXzggOj0gYWRkKGJfMTIsIF83KQogICAgc3N0b3JlKGFfMTMsIF84KQp9)
{
 let \_1 := 0
 let a\_9 := calldataload(\_1)
 let a := a\_9
 let \_2 := 0x20
 let b\_10 := calldataload(\_2)
 let b := b\_10
 let \_3 := 0
 let \_4 := gt(a\_9, \_3)
 if \_4
 {
 let \_5 := 0x20
 let b\_11 := mul(b\_10, \_5)
 b := b\_11
 }
 let b\_12 := b
 let \_6 := 1
 let a\_13 := add(a\_9, \_6)
 let \_7 := 0x20
 let \_8 := add(b\_12, \_7)
 sstore(a\_13, \_8)
}
Note that the only variable that is re-assigned in this snippet is `b`. This re-assignment cannot be avoided because `b` has different values depending on the control flow. All other variables never change their value once they are defined. The advantage of this property is that variables can be freely moved around and references to them can be exchanged by their initial value (and vice-versa), as long as these values are still valid in the new context.
Of course, the code here is far from being optimized. To the contrary, it is much longer. The hope is that this code will be easier to work with and furthermore, there are optimizer steps that undo these changes and make the code more compact again at the end.
#### ExpressionSplitter[](#expressionsplitter "Link to this heading")
The expression splitter turns expressions like `add(mload(0x123), mul(mload(0x456), 0x20))` into a sequence of declarations of unique variables that are assigned sub-expressions of that expression so that each function call has only variables as arguments.
The above would be transformed into
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ewogICAgbGV0IF8xIDo9IDB4MjAKICAgIGxldCBfMiA6PSAweDQ1NgogICAgbGV0IF8zIDo9IG1sb2FkKF8yKQogICAgbGV0IF80IDo9IG11bChfMywgXzEpCiAgICBsZXQgXzUgOj0gMHgxMjMKICAgIGxldCBfNiA6PSBtbG9hZChfNSkKICAgIGxldCB6IDo9IGFkZChfNiwgXzQpCn0=)
{
 let \_1 := 0x20
 let \_2 := 0x456
 let \_3 := mload(\_2)
 let \_4 := mul(\_3, \_1)
 let \_5 := 0x123
 let \_6 := mload(\_5)
 let z := add(\_6, \_4)
}
Note that this transformation does not change the order of opcodes or function calls.
It is not applied to loop iteration-condition, because the loop control flow does not allow this “outlining” of the inner expressions in all cases. We can sidestep this limitation by applying [ForLoopConditionIntoBody](#for-loop-condition-into-body) to move the iteration condition into loop body.
The final program should be in an _expression-split form_, where (with the exception of loop conditions) function calls cannot appear nested inside expressions and all function call arguments have to be variables.
The benefits of this form are that it is much easier to re-order the sequence of opcodes and it is also easier to perform function call inlining. Furthermore, it is simpler to replace individual parts of expressions or re-organize the “expression tree”. The drawback is that such code is much harder to read for humans.
#### SSATransform[](#ssatransform "Link to this heading")
This stage tries to replace repeated assignments to existing variables by declarations of new variables as much as possible. The reassignments are still there, but all references to the reassigned variables are replaced by the newly declared variables.
Example:
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ewogICAgbGV0IGEgOj0gMQogICAgbXN0b3JlKGEsIDIpCiAgICBhIDo9IDMKfQ==)
{
 let a := 1
 mstore(a, 2)
 a := 3
}
is transformed to
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ewogICAgbGV0IGFfMSA6PSAxCiAgICBsZXQgYSA6PSBhXzEKICAgIG1zdG9yZShhXzEsIDIpCiAgICBsZXQgYV8zIDo9IDMKICAgIGEgOj0gYV8zCn0=)
{
 let a\_1 := 1
 let a := a\_1
 mstore(a\_1, 2)
 let a\_3 := 3
 a := a\_3
}
Exact semantics:
For any variable `a` that is assigned to somewhere in the code (variables that are declared with value and never re-assigned are not modified) perform the following transforms:
* replace `let a := v` by `let a_i := v   let a := a_i`
 
* replace `a := v` by `let a_i := v   a := a_i` where `i` is a number such that `a_i` is yet unused.
 
Furthermore, always record the current value of `i` used for `a` and replace each reference to `a` by `a_i`. The current value mapping is cleared for a variable `a` at the end of each block in which it was assigned to and at the end of the `for` loop init block if it is assigned inside the `for` loop body or post block. If a variable’s value is cleared according to the rule above and the variable is declared outside the block, a new SSA variable will be created at the location where control flow joins, this includes the beginning of loop post/body block and the location right after `if`/`switch`/`for`/block statement.
After this stage, the UnusedAssignEliminator is recommended to remove the unnecessary intermediate assignments.
This stage provides best results if the ExpressionSplitter and the CommonSubexpressionEliminator are run right before it, because then it does not generate excessive amounts of variables. On the other hand, the CommonSubexpressionEliminator could be more efficient if run after the SSA transform.
#### UnusedAssignEliminator[](#unusedassigneliminator "Link to this heading")
The SSA transform always generates an assignment of the form `a := a_i`, even though these might be unnecessary in many cases, like the following example:
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ewogICAgbGV0IGEgOj0gMQogICAgYSA6PSBtbG9hZChhKQogICAgYSA6PSBzbG9hZChhKQogICAgc3N0b3JlKGEsIDEpCn0=)
{
 let a := 1
 a := mload(a)
 a := sload(a)
 sstore(a, 1)
}
The SSA transform converts this snippet to the following:
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ewogICAgbGV0IGFfMSA6PSAxCiAgICBsZXQgYSA6PSBhXzEKICAgIGxldCBhXzIgOj0gbWxvYWQoYV8xKQogICAgYSA6PSBhXzIKICAgIGxldCBhXzMgOj0gc2xvYWQoYV8yKQogICAgYSA6PSBhXzMKICAgIHNzdG9yZShhXzMsIDEpCn0=)
{
 let a\_1 := 1
 let a := a\_1
 let a\_2 := mload(a\_1)
 a := a\_2
 let a\_3 := sload(a\_2)
 a := a\_3
 sstore(a\_3, 1)
}
The UnusedAssignEliminator removes all the three assignments to `a`, because the value of `a` is not used and thus turn this snippet into strict SSA form:
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ewogICAgbGV0IGFfMSA6PSAxCiAgICBsZXQgYV8yIDo9IG1sb2FkKGFfMSkKICAgIGxldCBhXzMgOj0gc2xvYWQoYV8yKQogICAgc3N0b3JlKGFfMywgMSkKfQ==)
{
 let a\_1 := 1
 let a\_2 := mload(a\_1)
 let a\_3 := sload(a\_2)
 sstore(a\_3, 1)
}
Of course the intricate parts of determining whether an assignment is unused or not are connected to joining control flow.
The component works as follows in detail:
The AST is traversed twice: in an information gathering step and in the actual removal step. During information gathering, we maintain a mapping from assignment statements to the three states “unused”, “undecided” and “used” which signifies whether the assigned value will be used later by a reference to the variable.
When an assignment is visited, it is added to the mapping in the “undecided” state (see remark about `for` loops below) and every other assignment to the same variable that is still in the “undecided” state is changed to “unused”. When a variable is referenced, the state of any assignment to that variable still in the “undecided” state is changed to “used”.
At points where control flow splits, a copy of the mapping is handed over to each branch. At points where control flow joins, the two mappings coming from the two branches are combined in the following way: Statements that are only in one mapping or have the same state are used unchanged. Conflicting values are resolved in the following way:
* “unused”, “undecided” -> “undecided”
 
* “unused”, “used” -> “used”
 
* “undecided”, “used” -> “used”
 
For `for` loops, the condition, body and post-part are visited twice, taking the joining control-flow at the condition into account. In other words, we create three control flow paths: Zero runs of the loop, one run and two runs and then combine them at the end.
Simulating a third run or even more is unnecessary, which can be seen as follows:
A state of an assignment at the beginning of the iteration will deterministically result in a state of that assignment at the end of the iteration. Let this state mapping function be called `f`. The combination of the three different states `unused`, `undecided` and `used` as explained above is the `max` operation where `unused = 0`, `undecided = 1` and `used = 2`.
The proper way would be to compute
max(s, f(s), f(f(s)), f(f(f(s))), ...)
as state after the loop. Since `f` just has a range of three different values, iterating it has to reach a cycle after at most three iterations, and thus `f(f(f(s)))` has to equal one of `s`, `f(s)`, or `f(f(s))` and thus
max(s, f(s), f(f(s))) = max(s, f(s), f(f(s)), f(f(f(s))), ...)
In summary, running the loop at most twice is enough because there are only three different states.
For `switch` statements that have a default case, there is no control-flow part that skips the `switch`.
When a variable goes out of scope, all statements still in the “undecided” state are changed to “unused”, unless the variable is the return parameter of a function - there, the state changes to “used”.
In the second traversal, all assignments that are in the “unused” state are removed.
This step is usually run right after the SSA transform to complete the generation of the pseudo-SSA.
### Tools[](#tools "Link to this heading")
#### Movability[](#movability "Link to this heading")
Movability is a property of an expression. It roughly means that the expression is side-effect free and its evaluation only depends on the values of variables and the call-constant state of the environment. Most expressions are movable. The following parts make an expression non-movable:
* function calls (might be relaxed in the future if all statements in the function are movable)
 
* opcodes that (can) have side-effects (like `call` or `selfdestruct`)
 
* opcodes that read or write memory, storage or external state information
 
* opcodes that depend on the current PC, memory size or returndata size
 
#### DataflowAnalyzer[](#dataflowanalyzer "Link to this heading")
The DataflowAnalyzer is not an optimizer step itself but is used as a tool by other components. While traversing the AST, it tracks the current value of each variable, as long as that value is a movable expression. It records the variables that are part of the expression that is currently assigned to each other variable. Upon each assignment to a variable `a`, the current stored value of `a` is updated and all stored values of all variables `b` are cleared whenever `a` is part of the currently stored expression for `b`.
At control-flow joins, knowledge about variables is cleared if they have or would be assigned in any of the control-flow paths. For instance, upon entering a `for` loop, all variables are cleared that will be assigned during the body or the post block.
### Expression-Scale Simplifications[](#expression-scale-simplifications "Link to this heading")
These simplification passes change expressions and replace them by equivalent and hopefully simpler expressions.
#### CommonSubexpressionEliminator[](#commonsubexpressioneliminator "Link to this heading")
This step uses the DataflowAnalyzer and replaces subexpressions that syntactically match the current value of a variable by a reference to that variable. This is an equivalence transform because such subexpressions have to be movable.
All subexpressions that are identifiers themselves are replaced by their current value if the value is an identifier.
The combination of the two rules above allow to compute a local value numbering, which means that if two variables have the same value, one of them will always be unused. The UnusedPruner or the UnusedAssignEliminator will then be able to fully eliminate such variables.
This step is especially efficient if the ExpressionSplitter is run before. If the code is in pseudo-SSA form, the values of variables are available for a longer time and thus we have a higher chance of expressions to be replaceable.
The ExpressionSimplifier will be able to perform better replacements if the CommonSubexpressionEliminator was run right before it.
#### ExpressionSimplifier[](#expressionsimplifier "Link to this heading")
The ExpressionSimplifier uses the DataflowAnalyzer and makes use of a list of equivalence transforms on expressions like `X + 0 -> X` to simplify the code.
It tries to match patterns like `X + 0` on each subexpression. During the matching procedure, it resolves variables to their currently assigned expressions to be able to match more deeply nested patterns even when the code is in pseudo-SSA form.
Some of the patterns like `X - X -> 0` can only be applied as long as the expression `X` is movable, because otherwise it would remove its potential side-effects. Since variable references are always movable, even if their current value might not be, the ExpressionSimplifier is again more powerful in split or pseudo-SSA form.
#### LiteralRematerialiser[](#literalrematerialiser "Link to this heading")
To be documented.
#### LoadResolver[](#loadresolver "Link to this heading")
Optimisation stage that replaces expressions of type `sload(x)` and `mload(x)` by the value currently stored in storage resp. memory, if known.
Works best if the code is in SSA form.
Prerequisites: Disambiguator, ForLoopInitRewriter.
### Statement-Scale Simplifications[](#statement-scale-simplifications "Link to this heading")
#### CircularReferencesPruner[](#circularreferencespruner "Link to this heading")
This stage removes functions that call each other but are neither externally referenced nor referenced from the outermost context.
#### ConditionalSimplifier[](#conditionalsimplifier "Link to this heading")
The ConditionalSimplifier inserts assignments to condition variables if the value can be determined from the control-flow.
Destroys SSA form.
Currently, this tool is very limited, mostly because we do not yet have support for boolean types. Since conditions only check for expressions being nonzero, we cannot assign a specific value.
Current features:
* `switch` cases: insert `<condition> := <caseLabel>`
 
* after `if` statement with terminating control-flow, insert `<condition> := 0`
 
Future features:
* allow replacements by `1`
 
* take termination of user-defined functions into account
 
Works best with SSA form and if dead code removal has run before.
Prerequisite: Disambiguator.
#### ConditionalUnsimplifier[](#conditionalunsimplifier "Link to this heading")
Reverse of ConditionalSimplifier.
#### ControlFlowSimplifier[](#controlflowsimplifier "Link to this heading")
Simplifies several control-flow structures:
* replace `if` with empty body with `pop(condition)`
 
* remove empty default `switch` case
 
* remove empty `switch` case if no default case exists
 
* replace `switch` with no cases with `pop(expression)`
 
* turn `switch` with single case into `if`
 
* replace `switch` with only default case with `pop(expression)` and body
 
* replace `switch` with const expr with matching case body
 
* replace `for` with terminating control flow and without other `break`/`continue` by `if`
 
* remove `leave` at the end of a function.
 
None of these operations depend on the data flow. The StructuralSimplifier performs similar tasks that do depend on data flow.
The ControlFlowSimplifier does record the presence or absence of `break` and `continue` statements during its traversal.
Prerequisite: Disambiguator, FunctionHoister, ForLoopInitRewriter.
Important: Introduces EVM opcodes and thus can only be used on EVM code for now.
#### DeadCodeEliminator[](#deadcodeeliminator "Link to this heading")
This optimization stage removes unreachable code.
Unreachable code is any code within a block which is preceded by a `leave`, `return`, `invalid`, `break`, `continue`, `selfdestruct`, `revert` or by a call to a user-defined function that recurses infinitely.
Function definitions are retained as they might be called by earlier code and thus are considered reachable.
Because variables declared in a `for` loop’s init block have their scope extended to the loop body, we require ForLoopInitRewriter to run before this step.
Prerequisites: ForLoopInitRewriter, FunctionHoister, FunctionGrouper.
#### EqualStoreEliminator[](#equalstoreeliminator "Link to this heading")
This steps removes `mstore(k, v)` and `sstore(k, v)` calls if there was a previous call to `mstore(k, v)` / `sstore(k, v)`, no other store in between and the values of `k` and `v` did not change.
This simple step is effective if run after the SSATransform and the CommonSubexpressionEliminator, because SSA will make sure that the variables will not change and the CommonSubexpressionEliminator reuses exactly the same variable if the value is known to be the same.
Prerequisites: Disambiguator, ForLoopInitRewriter.
#### UnusedPruner[](#unusedpruner "Link to this heading")
This step removes the definitions of all functions that are never referenced.
It also removes declarations of variables that are never referenced. If a declaration assigns a value that is not movable, the expression is retained, but its value is discarded.
All movable expression statements (expressions that are not assigned) are removed.
#### StructuralSimplifier[](#structuralsimplifier "Link to this heading")
This is a general step that performs various kinds of simplifications on a structural level:
* replace `if` statement with empty body by `pop(condition)`
 
* replace `if` statement with true condition by its body
 
* remove `if` statement with false condition
 
* turn `switch` with single case into `if`
 
* replace `switch` with only default case by `pop(expression)` and body
 
* replace `switch` with literal expression by matching case body
 
* replace `for` loop with false condition by its initialization part
 
This component uses the DataflowAnalyzer.
#### BlockFlattener[](#blockflattener "Link to this heading")
This stage eliminates nested blocks by inserting the statements in the inner block at the appropriate place in the outer block. It depends on the FunctionGrouper and does not flatten the outermost block to keep the form produced by the FunctionGrouper.
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ewogICAgewogICAgICAgIGxldCB4IDo9IDIKICAgICAgICB7CiAgICAgICAgICAgIGxldCB5IDo9IDMKICAgICAgICAgICAgbXN0b3JlKHgsIHkpCiAgICAgICAgfQogICAgfQp9)
{
 {
 let x := 2
 {
 let y := 3
 mstore(x, y)
 }
 }
}
is transformed to
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ewogICAgewogICAgICAgIGxldCB4IDo9IDIKICAgICAgICBsZXQgeSA6PSAzCiAgICAgICAgbXN0b3JlKHgsIHkpCiAgICB9Cn0=)
{
 {
 let x := 2
 let y := 3
 mstore(x, y)
 }
}
As long as the code is disambiguated, this does not cause a problem because the scopes of variables can only grow.
#### LoopInvariantCodeMotion[](#loopinvariantcodemotion "Link to this heading")
This optimization moves movable SSA variable declarations outside the loop.
Only statements at the top level in a loop’s body or post block are considered, i.e variable declarations inside conditional branches will not be moved out of the loop.
ExpressionSplitter and SSATransform should be run upfront to obtain better results.
Prerequisites: Disambiguator, ForLoopInitRewriter, FunctionHoister.
### Function-Level Optimizations[](#function-level-optimizations "Link to this heading")
#### FunctionSpecializer[](#functionspecializer "Link to this heading")
This step specializes the function with its literal arguments.
If a function, say, `function f(a, b) { sstore (a, b) }`, is called with literal arguments, for example, `f(x, 5)`, where `x` is an identifier, it could be specialized by creating a new function `f_1` that takes only one argument, i.e.,
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ZnVuY3Rpb24gZl8xKGFfMSkgewogICAgbGV0IGJfMSA6PSA1CiAgICBzc3RvcmUoYV8xLCBiXzEpCn0=)
function f\_1(a\_1) {
 let b\_1 := 5
 sstore(a\_1, b\_1)
}
Other optimization steps will be able to make more simplifications to the function. The optimization step is mainly useful for functions that would not be inlined.
Prerequisites: Disambiguator, FunctionHoister.
LiteralRematerialiser is recommended as a prerequisite, even though it’s not required for correctness.
#### UnusedFunctionParameterPruner[](#unusedfunctionparameterpruner "Link to this heading")
This step removes unused parameters in a function.
If a parameter is unused, like `c` and `y` in, `function f(a,b,c) -> x, y { x := div(a,b) }`, we remove the parameter and create a new “linking” function as follows:
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ZnVuY3Rpb24gZihhLGIpIC0+IHggeyB4IDo9IGRpdihhLGIpIH0KZnVuY3Rpb24gZjIoYSxiLGMpIC0+IHgsIHkgeyB4IDo9IGYoYSxiKSB9)
function f(a,b) \-> x { x := div(a,b) }
function f2(a,b,c) \-> x, y { x := f(a,b) }
and replace all references to `f` by `f2`. The inliner should be run afterwards to make sure that all references to `f2` are replaced by `f`.
Prerequisites: Disambiguator, FunctionHoister, LiteralRematerialiser.
The step LiteralRematerialiser is not required for correctness. It helps deal with cases such as: `function f(x) -> y { revert(y, y} }` where the literal `y` will be replaced by its value `0`, allowing us to rewrite the function.
#### UnusedStoreEliminator[](#unusedstoreeliminator "Link to this heading")
Optimizer component that removes redundant `sstore` and memory store statements. In case of an `sstore`, if all outgoing code paths revert (due to an explicit `revert()`, `invalid()`, or infinite recursion) or lead to another `sstore` for which the optimizer can tell that it will overwrite the first store, the statement will be removed. However, if there is a read operation between the initial `sstore` and the revert, or the overwriting `sstore`, the statement will not be removed. Such read operations include: external calls, user-defined functions with any storage access, and `sload` of a slot that cannot be proven to differ from the slot written by the initial `sstore`.
For example, the following code
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ewogICAgbGV0IGMgOj0gY2FsbGRhdGFsb2FkKDApCiAgICBzc3RvcmUoYywgMSkKICAgIGlmIGMgewogICAgICAgIHNzdG9yZShjLCAyKQogICAgfQogICAgc3N0b3JlKGMsIDMpCn0=)
{
 let c := calldataload(0)
 sstore(c, 1)
 if c {
 sstore(c, 2)
 }
 sstore(c, 3)
}
will be transformed into the code below after the UnusedStoreEliminator step is run
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=ewogICAgbGV0IGMgOj0gY2FsbGRhdGFsb2FkKDApCiAgICBpZiBjIHsgfQogICAgc3N0b3JlKGMsIDMpCn0=)
{
 let c := calldataload(0)
 if c { }
 sstore(c, 3)
}
For memory store operations, things are generally simpler, at least in the outermost Yul block as all such statements will be removed if they are never read from in any code path. At function analysis level, however, the approach is similar to `sstore`, as we do not know whether the memory location will be read once we leave the function’s scope, so the statement will be removed only if all code paths lead to a memory overwrite.
Best run in SSA form.
Prerequisites: Disambiguator, ForLoopInitRewriter.
#### EquivalentFunctionCombiner[](#equivalentfunctioncombiner "Link to this heading")
If two functions are syntactically equivalent, while allowing variable renaming but not any re-ordering, then any reference to one of the functions is replaced by the other.
The actual removal of the function is performed by the UnusedPruner.
### Function Inlining[](#function-inlining "Link to this heading")
#### ExpressionInliner[](#expressioninliner "Link to this heading")
This component of the optimizer performs restricted function inlining by inlining functions that can be inlined inside functional expressions, i.e. functions that:
* return a single value.
 
* have a body like `r := <functional expression>`.
 
* neither reference themselves nor `r` in the right hand side.
 
Furthermore, for all parameters, all of the following need to be true:
* The argument is movable.
 
* The parameter is either referenced less than twice in the function body, or the argument is rather cheap (“cost” of at most 1, like a constant up to `0xff`).
 
Example: The function to be inlined has the form of `function f(...) -> r { r := E }` where `E` is an expression that does not reference `r` and all arguments in the function call are movable expressions.
The result of this inlining is always a single expression.
This component can only be used on sources with unique names.
#### FullInliner[](#fullinliner "Link to this heading")
The FullInliner replaces certain calls of certain functions by the function’s body. This is not very helpful in most cases, because it just increases the code size but does not have a benefit. Furthermore, code is usually very expensive and we would often rather have shorter code than more efficient code. In some cases, though, inlining a function can have positive effects on subsequent optimizer steps. This is the case if one of the function arguments is a constant, for example.
During inlining, a heuristic is used to tell if the function call should be inlined or not. The current heuristic does not inline into “large” functions unless the called function is tiny. Functions that are only used once are inlined, as well as medium-sized functions, while function calls with constant arguments allow slightly larger functions.
In the future, we may include a backtracking component that, instead of inlining a function right away, only specializes it, which means that a copy of the function is generated where a certain parameter is always replaced by a constant. After that, we can run the optimizer on this specialized function. If it results in heavy gains, the specialized function is kept, otherwise the original function is used instead.
FunctionHoister and ExpressionSplitter are recommended as prerequisites since they make the step more efficient, but are not required for correctness. In particular, function calls with other function calls as arguments are not inlined, but running ExpressionSplitter beforehand ensures that there are no such calls in the input.
### Cleanup[](#cleanup "Link to this heading")
The cleanup is performed at the end of the optimizer run. It tries to combine split expressions into deeply nested ones again and also improves the “compilability” for stack machines by eliminating variables as much as possible.
#### ExpressionJoiner[](#expressionjoiner "Link to this heading")
This is the opposite operation of the ExpressionSplitter. It turns a sequence of variable declarations that have exactly one reference into a complex expression. This stage fully preserves the order of function calls and opcode executions. It does not make use of any information concerning the commutativity of the opcodes; if moving the value of a variable to its place of use would change the order of any function call or opcode execution, the transformation is not performed.
Note that the component will not move the assigned value of a variable assignment or a variable that is referenced more than once.
The snippet `let x := add(0, 2) let y := mul(x, mload(2))` is not transformed, because it would cause the order of the call to the opcodes `add` and `mload` to be swapped - even though this would not make a difference because `add` is movable.
When reordering opcodes like that, variable references and literals are ignored. Because of that, the snippet `let x := add(0, 2) let y := mul(x, 3)` is transformed to `let y := mul(add(0, 2), 3)`, even though the `add` opcode would be executed after the evaluation of the literal `3`.
#### SSAReverser[](#ssareverser "Link to this heading")
This is a tiny step that helps in reversing the effects of the SSATransform if it is combined with the CommonSubexpressionEliminator and the UnusedPruner.
The SSA form we generate is detrimental to code generation because it produces many local variables. It would be better to just reuse existing variables with assignments instead of fresh variable declarations.
The SSATransform rewrites
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=bGV0IGEgOj0gY2FsbGRhdGFsb2FkKDApCm1zdG9yZShhLCAxKQ==)
let a := calldataload(0)
mstore(a, 1)
to
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=bGV0IGFfMSA6PSBjYWxsZGF0YWxvYWQoMCkKbGV0IGEgOj0gYV8xCm1zdG9yZShhXzEsIDEpCmxldCBhXzIgOj0gY2FsbGRhdGFsb2FkKDB4MjApCmEgOj0gYV8y)
let a\_1 := calldataload(0)
let a := a\_1
mstore(a\_1, 1)
let a\_2 := calldataload(0x20)
a := a\_2
The problem is that instead of `a`, the variable `a_1` is used whenever `a` was referenced. The SSATransform changes statements of this form by just swapping out the declaration and the assignment. The above snippet is turned into
[open in Remix](https://remix.ethereum.org/?#language=yul&version=0.8.30&code=bGV0IGEgOj0gY2FsbGRhdGFsb2FkKDApCmxldCBhXzEgOj0gYQptc3RvcmUoYV8xLCAxKQphIDo9IGNhbGxkYXRhbG9hZCgweDIwKQpsZXQgYV8yIDo9IGE=)
let a := calldataload(0)
let a\_1 := a
mstore(a\_1, 1)
a := calldataload(0x20)
let a\_2 := a
This is a very simple equivalence transform, but when we now run the CommonSubexpressionEliminator, it will replace all occurrences of `a_1` by `a` (until `a` is re-assigned). The UnusedPruner will then eliminate the variable `a_1` altogether and thus fully reverse the SSATransform.
#### StackCompressor[](#stackcompressor "Link to this heading")
One problem that makes code generation for the Ethereum Virtual Machine hard is the fact that there is a hard limit of 16 slots for reaching down the expression stack. This more or less translates to a limit of 16 local variables. The stack compressor takes Yul code and compiles it to EVM bytecode. Whenever the stack difference is too large, it records the function this happened in.
For each function that caused such a problem, the Rematerialiser is called with a special request to aggressively eliminate specific variables sorted by the cost of their values.
On failure, this procedure is repeated multiple times.
#### Rematerialiser[](#rematerialiser "Link to this heading")
The rematerialisation stage tries to replace variable references by the expression that was last assigned to the variable. This is of course only beneficial if this expression is comparatively cheap to evaluate. Furthermore, it is only semantically equivalent if the value of the expression did not change between the point of assignment and the point of use. The main benefit of this stage is that it can save stack slots if it leads to a variable being eliminated completely (see below), but it can also save a `DUP` opcode on the EVM if the expression is very cheap.
The Rematerialiser uses the DataflowAnalyzer to track the current values of variables, which are always movable. If the value is very cheap or the variable was explicitly requested to be eliminated, the variable reference is replaced by its current value.
#### ForLoopConditionOutOfBody[](#forloopconditionoutofbody "Link to this heading")
Reverses the transformation of ForLoopConditionIntoBody.
For any movable `c`, it turns
for { ... } 1 { ... } {
if iszero(c) { break }
...
}
into
for { ... } c { ... } {
...
}
and it turns
for { ... } 1 { ... } {
if c { break }
...
}
into
for { ... } iszero(c) { ... } {
...
}
The LiteralRematerialiser should be run before this step.
## Codegen-Based Optimizer Module[](#codegen-based-optimizer-module "Link to this heading")
Currently, the codegen-based optimizer module provides two optimizations.
The first one, available in the legacy code generator, moves literals to the right side of commutative binary operators, which helps exploit their associativity.
The other one, available in the IR-based code generator, enables the use of unchecked arithmetic when generating code for incrementing the counter variable of certain idiomatic `for` loops. This avoids wasting gas by identifying some conditions that guarantee that the counter variable cannot overflow. This eliminates the need to use a verbose unchecked arithmetic block inside the loop body to increment the counter variable.
### Unchecked Loop Increment[](#unchecked-loop-increment "Link to this heading")
Introduced in Solidity `0.8.22`, the overflow check optimization step is concerned with identifying the conditions under which the `for` loop counter can be safely incremented without overflow checks.
This optimization is **only** applied to `for` loops of the general form:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Zm9yICh1aW50IGkgPSBYOyBpIDwgWTsgKytpKSB7CiAgICAvLyB2YXJpYWJsZSBpIGlzIG5vdCBtb2RpZmllZCBpbiB0aGUgbG9vcCBib2R5Cn0=)
for (uint i \= X; i < Y; ++i) {
 // variable i is not modified in the loop body
}
The condition and the fact that the counter variable is only ever incremented guarantee that it never overflows. The precise requirements for the loop to be eligible for the optimization are as follows:
* The loop condition is a comparison of the form `i < Y`, for a local counter variable `i` (called the “loop counter” hereon) and an expression `Y`.
 
* The built-in operator `<` is necessarily used in the loop condition and is the only operator that triggers the optimization. `<=` and the like are intentionally excluded. Additionally, user-defined operators are **not** eligible.
 
* The loop expression is a prefix or postfix increment of the counter variable, i.e, `i++` or `++i`.
 
* The loop counter is a local variable of a built-in integer type.
 
* The loop counter is **not** modified by the loop body or by the expression used as the loop condition.
 
* The comparison is performed on the same type as the loop counter, meaning that the type of the right-hand-side expression is implicitly convertible to the type of the counter, such that the latter is not implicitly widened before the comparison.
 
To clarify the last condition, consider the following example:
[open in Remix](https://remix.ethereum.org/?#language=solidity&version=0.8.30&code=Zm9yICh1aW50OCBpID0gMDsgaSA8IHVpbnQxNigxMDAwKTsgaSsrKSB7CiAgICAvLyAuLi4KfQ==)
for (uint8 i \= 0; i < uint16(1000); i++) {
 // ...
}
In this case, the counter `i` has its type implicitly converted from `uint8` to `uint16` before the comparison and the condition is in fact never false, so the overflow check for the increment cannot be removed.

# [Solidity — Solidity 0.8.15 belgelendirmesi](https://docs.soliditylang.org/tr/latest/index.html) 
 _https://docs.soliditylang.org/tr/latest/index.html_

Uyarı
You are reading a community translation of the Solidity documentation. The Solidity team can give no guarantees on the quality and accuracy of the translations provided. The English reference version is and will remain the only officially supported version by the Solidity team and will always be the most accurate and most up-to-date one. When in doubt, please always refer to the [English (original) documentation](https://docs.soliditylang.org/en/latest/).
Solidity akıllı sözleşmelerin (smart contracts) uygulanması için geliştirilen nesne yönelimli, üst düzey bir programlama dilidir. Akıllı sözleşmeler Ethereum ağı içindeki hesapların hareketlerini ve davranışlarını yöneten programlardır.
Solidity Ethereum Sanal Makinası (ESM) (Ethereum Virtual Machine) hedeflenerek dizayn edilmiş bir [curly-bracket dilidir](https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Curly-bracket_languages). C++, Python ve JavaScript gibi dillerden ilham alınarak oluşturulmuştur. Solidity’nin başka hangi dillerden ilham aldığı hakkındaki detaylı bilgiyi [ilham alınan diller](https://docs.soliditylang.org/tr/latest/language-influences.html) bölümünde bulabilirsiniz.
Solidity statik olarak yazılmış olmasının yanı sıra, kütüphaneleri, kullanıcı tanımlı karmaşık türleri ve kalıtımsallığı destekler.
Solidity’le kullanıcılar için oylama, crowdfunding, blind auctions ve çoklu-imza cüzdanları gibi kullanımlara yönelik akıllı sözleşmeler oluşturabilirsiniz.
Sözleşmelerin gönderimini yaparken, en son yayınlanan Solidity sürümünü kullanmalısınız. İstisnai durumlar dışında, yalnızca son sürüm [güvenlik düzeltmeleri](https://github.com/ethereum/solidity/security/policy#supported-versions) güncellemelerini alır. Ayrıca, önemli değişikliklerinin yanı sıra yeni özellikler düzenli olarak tanıtılmaktadır. Bu hızlı [değişimleri belirtmek için](https://semver.org/#spec-item-4) bir 0.y.z sürüm numarası kullanıyoruz.
İpucu
Solidity kısa bir süre önce birçok yenilik ve önemli değişiklikler getiren 0.8.x sürümünü yayınladı. Değişiklikleri mutlaka okuyun [tam liste](https://docs.soliditylang.org/tr/latest/080-breaking-changes.html).
Solidity’yi veya bu dokümantasyonu geliştirmek için fikirlere her zaman açığız, Daha fazla ayrıntı için [katkıda bulunanlar rehberi](https://docs.soliditylang.org/tr/latest/contributing.html) sayfamızı okuyun.
Uyarı
Bu belgeyi, sol alt köşedeki sürümler menüsüne tıklayarak ve tercih edilen indirme biçimini seçerek PDF, HTML veya Epub olarak indirebilirsiniz.
## Hadi Başlayalım[](#hadi-baslayalim "Permalink to this heading")
**1\. Akıllı Sözleşmelerin Temellerini Anlama**
Eğer akıllı sözleşmeler kavramında yeniyseniz “Akıllı Sözleşmelere Giriş” bölümünü araştırarak başlamanızı öneririz. Bu bölüm aşağıdakileri kapsar:
* Solidity ile yazılmış [Basit bir akıllı sözleşme örneği](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#simple-smart-contract).
 
* [Blockchain Temelleri](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#blockchain-basics).
 
* [Ethereum Sanal Makinası (Ethereum Virtual Machine)](https://docs.soliditylang.org/tr/latest/introduction-to-smart-contracts.html#the-ethereum-virtual-machine).
 
**2\. Solidity ile Tanışın**
Temel bilgilere alıştıktan sonra, [“Örneklerle Solidity”](https://docs.soliditylang.org/tr/latest/solidity-by-example.html) bölümünü okumanızı öneririz. Ve ayrıca “Dil Tanımları” bölümünü inceleyerek dilin temel kavramlarını anlayabilirsiniz..
**3\. Solidity Derleyicisini İndirme**
Solidity derleyicisini indirmenin birçok yolu vardır, tercih edeceğiniz yola göre [indirme sayfası](https://docs.soliditylang.org/tr/latest/installing-solidity.html#installing-solidity) ‘da bulunan adımları izleyin.
İpucu
[Remix IDE](https://remix.ethereum.org/) ile birlikte kod örneklerini doğrudan tarayıcınızda deneyebilirsiniz. Remix, Solidity’yi yerel olarak yüklemenize gerek kalmadan Solidity akıllı sözleşmelerini yazmanıza, dağıtmanıza ve yönetmenize olanak tanıyan web tarayıcısı tabanlı bir IDE’dir.
Uyarı
İnsanlar kodlama yaparken, hataları olabilir. Akıllı sözleşmelerinizi yazarken belirlenmiş en iyi yazılım geliştirme uygulamalarını izlemelisiniz. Buna kod incelemesi, kodunuzu test etme, denetimler ve correctness proofs dahildir. Akıllı sözleşme kullanıcıları bazen kod konusunda yazarlarından daha emin olabilirler, blockchain ve akıllı sözleşmelerin dikkat edilmesi gereken kendine özgü sorunları vardır, bu nedenle üretim kodu(production code) üzerinde çalışmadan önce [Güvenlikle İlgili Değerlendirmeler](https://docs.soliditylang.org/tr/latest/security-considerations.html#security-considerations) bölümünü okuduğunuzdan emin olun.
**4\. Daha Fazla Bilgi Edinin**
Ethereum ağı üzerinde merkeziyetsiz uygulamalar oluşturma hakkında daha fazla bilgi edinmek istiyorsanız, [Ethereum Geliştirici Kaynakları](https://ethereum.org/en/developers/) size Ethereum ile ilgili daha fazla genel dokümantasyon, çok çeşitli öğreticiler, araçlar ve framework’ler(Yazılım iskeleti) konusunda yardımcı olabilir.
Eğer herhangi bir sorunuz varsa, [Ethereum StackExchange](https://ethereum.stackexchange.com/), veya [Gitter kanalımıza](https://gitter.im/ethereum/solidity/) sorabilirsiniz.
## Çeviriler[](#ceviriler "Permalink to this heading")
Topluluk’tan bazı gönüllüler bu belgeyi farklı dillere çevirmemize yardımcı oluyor. Bu sebeple çevirilerin farklı derecelerde bütünlük ve güncelliğe sahip olduğunu unutmayın. İngilizce versiyonunu referans olarak alın.
Sol alt köşedeki açılır menüye tıklayarak ve tercih ettiğiniz dili seçerek diller arasında geçiş yapabilirsiniz.
* [Fransızce](https://docs.soliditylang.org/fr/latest/)
 
* [Endonezya Dili](https://github.com/solidity-docs/id-indonesian)
 
* [Farsça](https://github.com/solidity-docs/fa-persian)
 
* [Japonca](https://github.com/solidity-docs/ja-japanese)
 
* [Korece](https://github.com/solidity-docs/ko-korean)
 
* [Çince](https://github.com/solidity-docs/zh-cn-chinese/)
 
Not
Kısa süre önce topluluk çalışmalarını kolaylaştırmak ve düzene koymak için yeni bir GitHub organizasyonu ve çeviri için bir iş akışı(workflow) kurduk. Yeni bir dile nasıl başlayacağınız veya var olan çevirilere nasıl katkıda bulunacağınız hakkında bilgi için lütfen [çeviri kılavuzuna](https://github.com/solidity-docs/translation-guide) bakın.

# [Format NatSpec — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/natspec-format.html) 
 _https://docs.soliditylang.org/fr/latest/natspec-format.html_

Les contrats Solidity peuvent utiliser une forme spéciale de commentaires pour fournir une documentation riche pour les fonctions, les variables de retour et autres. Cette forme spéciale est nommé Ethereum Natural Language Specification Format (NatSpec).
Note
NatSpec a été inspiré par [Doxygen](https://en.wikipedia.org/wiki/Doxygen). Bien qu’il utilise des commentaires et des balises de style Doxygen, il n’y a aucune intention de garder une compatibilité stricte avec Doxygen. Veuillez examiner attentivement les balises supportées listées ci-dessous.
Cette documentation est segmentée en messages destinés aux développeurs et en messages destinés aux l’utilisateur finaux. Ces messages peuvent être présentés à l’utilisateur final (l’humain) au moment où il interagit avec le contrat (c’est-à-dire lorsqu’il signe une transaction).
Il est recommandé que les contrats Solidity soient entièrement annotés à l’aide de NatSpec pour toutes les interfaces publiques (tout ce qui se trouve dans l’ABI).
NatSpec inclut le formatage des commentaires que l’auteur du contrat intelligent utilisera et qui sont compris par le compilateur Solidity. Ils sont également détaillés ci-dessous sortie du compilateur Solidity, qui extrait ces commentaires dans un format lisible par la machine.
NatSpec peut également inclure des annotations utilisées par des outils tiers. Celles-ci sont très probablement via la balise `@custom:<name>`, et un bon cas d’utilisation est celui des outils d’analyse et de vérification.
## Exemple de documentation[](#exemple-de-documentation "Lien permanent vers cette rubrique")
La documentation est insérée au-dessus de chaque `contrat`, `interface`, `fonction`, et `event` en utilisant le format de notation Doxygen. Une variable d’état `public` est équivalente à une `function` pour les besoins de NatSpec.
* Pour Solidity, vous pouvez choisir `///` pour les commentaires d’une ou plusieurs lignes
 
 commentaires, ou `/**` et se terminant par `*/`.
 
* Pour Vyper, utilisez `"""` indenté jusqu’au contenu intérieur avec des
 
 commentaires. Voir la documentation de [Vyper](https://vyper.readthedocs.io/en/latest/natspec.html).
 
L’exemple suivant montre un contrat et une fonction utilisant toutes les balises disponibles.
Note
Le compilateur Solidity n’interprète les balises que si elles sont externes ou publiques. Vous pouvez utiliser des commentaires similaires pour vos fonctions internes et privées, mais elles ne seront pas interprétées.
Ceci pourrait changer à l’avenir.
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjIgPCAwLjkuMDsKCi8vLyBAdGl0bGUgVW4gc2ltdWxhdGV1ciBwb3VyIGxlcyBhcmJyZXMKLy8vIEBhdXRob3IgTGFycnkgQS4gR2FyZG5lcgovLy8gQG5vdGljZSBWb3VzIG5lIHBvdXZleiB1dGlsaXNlciBjZSBjb250cmF0IHF1ZSBwb3VyIGxhIHNpbXVsYXRpb24gbGEgcGx1cyDDqWzDqW1lbnRhaXJlLgovLy8gVG91cyBsZXMgYXBwZWxzIGRlIGZvbmN0aW9ucyBzb250IGFjdHVlbGxlbWVudCBpbXBsw6ltZW50w6lzIHNhbnMgZWZmZXRzIHNlY29uZGFpcmVzLgovLy8gQGN1c3RvbTpleHBlcmltZW50YWwgSWwgcydhZ2l0IGQndW4gY29udHJhdCBleHDDqXJpbWVudGFsLgpjb250cmFjdCBUcmVlIHsKICAgIC8vLyBAbm90aWNlIENhbGN1bGVyIGwnw6JnZSBkZSBsJ2FyYnJlIGVuIGFubsOpZXMsIGFycm9uZGkgw6AgbCd1bml0w6kgc3Vww6lyaWV1cmUsIHBvdXIgbGVzIGFyYnJlcyB2aXZhbnRzLgogICAgLy8vIEBkZXYgTCdhbGdvcml0aG1lIGQnQWxleGFuZHIgTi4gVGV0ZWFyaW5nIHBvdXJyYWl0IGFtw6lsaW9yZXIgbGEgcHLDqWNpc2lvbi4KICAgIC8vLyBAcGFyYW0gcmluZ3MgTGUgbm9tYnJlIGRlIGNlcm5lcyBkZSBsJ8OpY2hhbnRpbGxvbiBkZW5kcm9jaHJvbm9sb2dpcXVlLgogICAgLy8vIEByZXR1cm4gw4JnZSBlbiBhbm7DqWVzLCBhcnJvbmRpIGF1IGNoaWZmcmUgc3Vww6lyaWV1ciBwb3VyIGxlcyBhbm7DqWVzIHBhcnRpZWxsZXMKICAgIGZ1bmN0aW9uIGFnZSh1aW50MjU2IHJpbmdzKSBleHRlcm5hbCB2aXJ0dWFsIHB1cmUgcmV0dXJucyAodWludDI1NikgewogICAgICAgIHJldHVybiByaW5ncyArIDE7CiAgICB9CgogICAgLy8vIEBub3RpY2UgUmVudm9pZSBsZSBub21icmUgZGUgZmV1aWxsZXMgZGUgbCdhcmJyZS4KICAgIC8vLyBAZGV2IFJlbnZvaWUgdW5pcXVlbWVudCB1biBub21icmUgZml4ZS4KICAgIGZ1bmN0aW9uIGxlYXZlcygpIGV4dGVybmFsIHZpcnR1YWwgcHVyZSByZXR1cm5zKHVpbnQyNTYpIHsKICAgICAgICByZXR1cm4gMjsKICAgIH0KfQoKY29udHJhY3QgUGxhbnQgewogICAgZnVuY3Rpb24gbGVhdmVzKCkgZXh0ZXJuYWwgdmlydHVhbCBwdXJlIHJldHVybnModWludDI1NikgewogICAgICAgIHJldHVybiAzOwogICAgfQp9Cgpjb250cmFjdCBLdW1xdWF0VHJlZSBpcyBUcmVlLCBQbGFudCB7CiAgICBmdW5jdGlvbiBhZ2UodWludDI1NiByaW5ncykgZXh0ZXJuYWwgb3ZlcnJpZGUgcHVyZSByZXR1cm5zICh1aW50MjU2KSB7CiAgICAgICAgcmV0dXJuIHJpbmdzICsgMjsKICAgIH0KCiAgICAvLy8gUmV0b3VybmUgbGUgbm9tYnJlIGRlIGZldWlsbGVzIHF1ZSBwb3Nzw6hkZSBjZSB0eXBlIGQnYXJicmUgc3DDqWNpZmlxdWUuCiAgICAvLy8gQGluaGVyaXRkb2MgQXJicmUKICAgIGZ1bmN0aW9uIGxlYXZlcygpIGV4dGVybmFsIG92ZXJyaWRlKFRyZWUsIFBsYW50KSBwdXJlIHJldHVybnModWludDI1NikgewogICAgICAgIHJldHVybiAzOwogICAgfQp9)
// SPDX-License-Identifier: GPL-3.0
pragma solidity \>=0.8.2 < 0.9.0;
/// @title Un simulateur pour les arbres
/// @author Larry A. Gardner
/// @notice Vous ne pouvez utiliser ce contrat que pour la simulation la plus élémentaire.
/// Tous les appels de fonctions sont actuellement implémentés sans effets secondaires.
/// @custom:experimental Il s'agit d'un contrat expérimental.
contract Tree {
 /// @notice Calculer l'âge de l'arbre en années, arrondi à l'unité supérieure, pour les arbres vivants.
 /// @dev L'algorithme d'Alexandr N. Tetearing pourrait améliorer la précision.
 /// @param rings Le nombre de cernes de l'échantillon dendrochronologique.
 /// @return Âge en années, arrondi au chiffre supérieur pour les années partielles
 function age(uint256 rings) external virtual pure returns (uint256) {
 return rings + 1;
 }
 /// @notice Renvoie le nombre de feuilles de l'arbre.
 /// @dev Renvoie uniquement un nombre fixe.
 function leaves() external virtual pure returns(uint256) {
 return 2;
 }
}
contract Plant {
 function leaves() external virtual pure returns(uint256) {
 return 3;
 }
}
contract KumquatTree is Tree, Plant {
 function age(uint256 rings) external override pure returns (uint256) {
 return rings + 2;
 }
 /// Retourne le nombre de feuilles que possède ce type d'arbre spécifique.
 /// @inheritdoc Arbre
 function leaves() external override(Tree, Plant) pure returns(uint256) {
 return 3;
 }
}
## Tags[](#tags "Lien permanent vers cette rubrique")
Toutes les balises sont facultatives. Le tableau suivant explique le but de chaque balise NatSpec et où elle peut être utilisée. Dans un cas particulier, si aucune balise n’est utilisée, le compilateur Solidity interprétera un commentaire `///` ou `/**` de la même manière que s’il était balisé avec @notice\`.
 
Tag
Contexte
`@title`
Un titre qui doit décrire le contrat/interface
contract, library, interface
`@author`
Le nom de l’auteur
contract, library, interface
`@notice`
Expliquer à un utilisateur final ce que cela fait
contract, library, interface, function, public state variable, event
`@dev`
Expliquez à un développeur tout détail supplémentaire
contract, library, interface, function, state variable, event
`@param`
Documente un paramètre comme dans Doxygen (doit être suivi du nom du paramètre)
function, event
`@return`
Documente les variables de retour de la fonction d’un contrat
function, public state variable
`@inheritdoc`
Copie toutes les étiquettes manquantes de la fonction de base (doit être suivi du nom du contrat).
function, public state variable
`@custom:...`
Balise personnalisée, la sémantique est définie par l’application.
everywhere
Si votre fonction renvoie plusieurs valeurs, comme `(int quotient, int remainder)`, alors utilisez plusieurs instructions `return` dans le même format que les instructions `@param`.
Les balises personnalisées commencent par `@custom:` et doivent être suivies d’une ou plusieurs lettres minuscules ou d’un trait d’union. Elles ne peuvent cependant pas commencer par un trait d’union. Elles peuvent être utilisées partout et font partie de la documentation du développeur.
### Expressions dynamiques[](#expressions-dynamiques "Lien permanent vers cette rubrique")
Le compilateur Solidity fera passer la documentation NatSpec de votre code source Solidity jusqu’à la sortie JSON, comme décrit dans ce guide. Le consommateur de ce JSON, par exemple le logiciel client de l’utilisateur final, peut le présenter directement à l’utilisateur final ou appliquer un prétraitement.
Par exemple, certains logiciels clients effectueront un rendu :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=Ly8vIEBub3RpY2UgQ2V0dGUgZm9uY3Rpb24gdmEgbXVsdGlwbGllciBgYWAgcGFyIDc=)
/// @notice Cette fonction va multiplier \`a\` par 7
to the end-user as:
Cette fonction va multiplier 10 par 7
Si une fonction est appelée et que la valeur 10 est attribuée à l’entrée `a`.
La spécification de ces expressions dynamiques n’entre pas dans le cadre de la documentation de Solidity. et vous pouvez en savoir plus à l’adresse suivante [le projet radspec](https://github.com/aragon/radspec).
### Notes sur l’héritage[](#notes-sur-l-heritage "Lien permanent vers cette rubrique")
Les fonctions sans NatSpec hériteront automatiquement de la documentation de leur fonction de base. Les exceptions à cette règle sont :
* Lorsque les noms des paramètres sont différents.
 
* Quand il y a plus d’une fonction de base.
 
* Quand il y a une balise explicite `@inheritdoc` qui spécifie quel contrat doit être utilisé pour hériter.
 
## Sortie de documentation[](#sortie-de-documentation "Lien permanent vers cette rubrique")
Lorsqu’elle est analysée par le compilateur, une documentation telle que celle de l’exemple ci-dessus produira deux fichiers JSON différents. L’un est destiné à être consommé par l’utilisateur final comme un avis lorsqu’une fonction est exécutée et l’autre à être utilisé par le développeur.
Si le contrat ci-dessus est enregistré sous le nom de `ex1.sol`, alors vous pouvez générer la documentation en utilisant :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=c29sYyAtLXVzZXJkb2MgLS1kZXZkb2MgZXgxLnNvbA==)
solc \--userdoc \--devdoc ex1.sol
Et la sortie est ci-dessous.
Note
À partir de la version 0.6.11 de Solidity, la sortie NatSpec contient également un champ `version` et un champ `kind`. Actuellement, la `version` est fixée à `1` et le `kind` doit être l’un de `user` ou `dev`. Dans le futur, il est possible que de nouvelles versions soient introduites et que les anciennes soient supprimées.
### Documentation pour les utilisateurs[](#documentation-pour-les-utilisateurs "Lien permanent vers cette rubrique")
La documentation ci-dessus produira la documentation utilisateur suivante Fichier JSON en sortie :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ewogICJ2ZXJzaW9uIiA6IDEsCiAgImtpbmQiIDogInVzZXIiLAogICJtZXRob2RzIiA6CiAgewogICAgImFnZSh1aW50MjU2KSIgOgogICAgewogICAgICAibm90aWNlIiA6ICJDYWxjdWxleiBsJ8OiZ2UgZGUgbCdhcmJyZSBlbiBhbm7DqWVzLCBhcnJvbmRpIGF1IGNoaWZmcmUgc3Vww6lyaWV1ciwgcG91ciBsZXMgYXJicmVzIHZpdmFudHMuIgogICAgfQogIH0sCiAgIm5vdGljZSIgOiAiVm91cyBwb3V2ZXogdXRpbGlzZXIgY2UgY29udHJhdCB1bmlxdWVtZW50IHBvdXIgbGEgc2ltdWxhdGlvbiBsYSBwbHVzIGJhc2lxdWUiCn0=)
{
 "version" : 1,
 "kind" : "user",
 "methods" :
 {
 "age(uint256)" :
 {
 "notice" : "Calculez l'âge de l'arbre en années, arrondi au chiffre supérieur, pour les arbres vivants."
 }
 },
 "notice" : "Vous pouvez utiliser ce contrat uniquement pour la simulation la plus basique"
}
Notez que la clé permettant de trouver les méthodes est la signature canonique de la fonction telle que définie dans le [Contrat ABI](https://docs.soliditylang.org/fr/latest/abi-spec.html#abi-function-selector) et non le simple nom de la fonction.
### Documentation pour les développeurs[](#documentation-pour-les-developpeurs "Lien permanent vers cette rubrique")
Outre le fichier de documentation utilisateur, un fichier JSON de documentation pour les développeurs doit également être produit et doit ressembler à ceci :
[open in Remix](https://remix.ethereum.org/?language=solidity&version=0.8.12&code=ewogICJ2ZXJzaW9uIiA6IDEsCiAgImtpbmQiIDogImRldiIsCiAgImF1dGhvciIgOiAiTGFycnkgQS4gR2FyZG5lciIsCiAgImRldGFpbHMiIDogIlRvdXMgbGVzIGFwcGVscyBkZSBmb25jdGlvbiBzb250IGFjdHVlbGxlbWVudCBtaXMgZW4gxZN1dnJlIHNhbnMgZWZmZXRzIHNlY29uZGFpcmVzIiwKICAiY3VzdG9tOmV4cGVyaW1lbnRhbCIgOiAiSWwgcydhZ2l0IGQndW4gY29udHJhdCBleHDDqXJpbWVudGFsLiIsCiAgIm1ldGhvZHMiIDoKICB7CiAgICAiYWdlKHVpbnQyNTYpIiA6CiAgICB7CiAgICAgICJkZXRhaWxzIiA6ICJMJ2FsZ29yaXRobWUgZCdBbGV4YW5kciBOLiBUZXRlYXJpbmcgcG91cnJhaXQgYXVnbWVudGVyIGxhIHByw6ljaXNpb24iLAogICAgICAicGFyYW1zIiA6CiAgICAgIHsKICAgICAgICAicmluZ3MiIDogIkxlIG5vbWJyZSBkZSBjZXJuZXMgZGUgbCfDqWNoYW50aWxsb24gZGVuZHJvY2hyb25vbG9naXF1ZSIKICAgICAgfSwKICAgICAgInJldHVybiIgOiAiw6JnZSBlbiBhbm7DqWVzLCBhcnJvbmRpIGF1IGNoaWZmcmUgc3Vww6lyaWV1ciBwb3VyIGxlcyBhbm7DqWVzIGluY29tcGzDqHRlcyIKICAgIH0KICB9LAogICJ0aXRsZSIgOiAiVW4gc2ltdWxhdGV1ciBwb3VyIGxlcyBhcmJyZXMiCn0=)
{
 "version" : 1,
 "kind" : "dev",
 "author" : "Larry A. Gardner",
 "details" : "Tous les appels de fonction sont actuellement mis en œuvre sans effets secondaires",
 "custom:experimental" : "Il s'agit d'un contrat expérimental.",
 "methods" :
 {
 "age(uint256)" :
 {
 "details" : "L'algorithme d'Alexandr N. Tetearing pourrait augmenter la précision",
 "params" :
 {
 "rings" : "Le nombre de cernes de l'échantillon dendrochronologique"
 },
 "return" : "âge en années, arrondi au chiffre supérieur pour les années incomplètes"
 }
 },
 "title" : "Un simulateur pour les arbres"
}

# [Installation du compilateur Solidity — Documentation Solidity 0.8.12](https://docs.soliditylang.org/fr/latest/installing-solidity.html) 
 _https://docs.soliditylang.org/fr/latest/installing-solidity.html_

## Versionnage[](#versionnage "Lien permanent vers cette rubrique")
Les versions de Solidity suivent le [versionnement sémantique](https://semver.org/) et en plus des versions, **des builds de développement nocturnes** sont également mis à disposition. Les nightly builds ne sont pas garanties et, malgré tous les efforts, elles peuvent contenir et/ou des changements non documentés. Nous recommandons d’utiliser la dernière version. Les installateurs de paquets ci-dessous utiliseront la dernière version.
## Remix[](#remix "Lien permanent vers cette rubrique")
_Nous recommandons Remix pour les petits contrats et pour apprendre rapidement Solidity._
[Access Remix en ligne](https://remix.ethereum.org/), vous n’avez pas besoin d’installer quoi que ce soit. Si vous voulez l’utiliser sans connexion à l’Internet, allez sur [https://github.com/ethereum/remix-live/tree/gh-pages](https://github.com/ethereum/remix-live/tree/gh-pages) et téléchargez le fichier `.zip` comme comme expliqué sur cette page. Remix est également une option pratique pour tester les constructions nocturnes sans installer plusieurs versions de Solidity.
D’autres options sur cette page détaillent l’installation du compilateur Solidity en ligne de commande sur votre ordinateur. Choisissez un compilateur en ligne de commande si vous travaillez sur un contrat plus important ou si vous avez besoin de plus d’options de compilation.
## npm / Node.js[](#npm-node-js "Lien permanent vers cette rubrique")
Utilisez `npm` pour une manière pratique et portable d’installer `solcjs`, un compilateur Solidity. Le programme solcjs a moins de fonctionnalités que les façons d’accéder au compilateur décrites plus bas dans cette page. La documentation [Utilisation du compilateur en ligne de commande](https://docs.soliditylang.org/fr/latest/using-the-compiler.html#commandline-compiler) suppose que vous utilisez le compilateur complet, `solc`. L’utilisation de `solcjs` est documentée à l’intérieur de son propre [repository](https://github.com/ethereum/solc-js).
Note : Le projet solc-js est dérivé du projet C++ solc. solc en utilisant Emscripten ce qui signifie que les deux utilisent le même code source du compilateur. solc-js peut être utilisé directement dans des projets JavaScript (comme Remix). Veuillez vous référer au dépôt solc-js pour les instructions.
Note
L’exécutable en ligne de commande est nommé `solcjs`.
Les options en ligne de commande de `solcjs` ne sont pas compatibles avec `solc` et les outils (tels que `geth`) qui attendent le comportement de `solc` ne fonctionneront pas avec `solcjs`.
## Docker[](#docker "Lien permanent vers cette rubrique")
Les images Docker des constructions Solidity sont disponibles en utilisant l’image `solc` de l’organisation `ethereum`. Utilisez la balise `stable` pour la dernière version publiée, et `nightly` pour les changements potentiellement instables dans la branche de développement.
L’image Docker exécute l’exécutable du compilateur, vous pouvez donc lui passer tous les arguments du compilateur. Par exemple, la commande ci-dessous récupère la version stable de l’image `solc` (si vous ne l’avez pas déjà), et l’exécute dans un nouveau conteneur, en passant l’argument `--help`.
docker run ethereum/solc:stable --help
Vous pouvez également spécifier les versions de build de la version dans la balise, par exemple, pour la version 0.5.4.
docker run ethereum/solc:0.5.4 --help
Pour utiliser l’image Docker afin de compiler les fichiers Solidity sur la machine hôte, montez un dossier local pour l’entrée et la sortie, et spécifier le contrat à compiler. Par exemple.
docker run -v /local/path:/sources ethereum/solc:stable -o /sources/output --abi --bin /sources/Contract.sol
Vous pouvez également utiliser l’interface JSON standard (ce qui est recommandé lorsque vous utilisez le compilateur avec des outils). Lors de l’utilisation de cette interface, il n’est pas nécessaire de monter des répertoires tant que l’entrée JSON est autonome (c’est-à-dire qu’il ne fait pas référence à des fichiers externes qui devraient être [chargés par la callback d’importation](https://docs.soliditylang.org/fr/latest/path-resolution.html#initial-vfs-content-standard-json-with-import-callback)).
docker run ethereum/solc:stable --standard-json < input.json > output.json
## Paquets Linux[](#paquets-linux "Lien permanent vers cette rubrique")
Les paquets binaires de Solidity sont disponibles à l’adresse [solidity/releases](https://github.com/ethereum/solidity/releases).
Nous avons également des PPA pour Ubuntu, vous pouvez obtenir la dernière version stable en utilisant les commandes suivantes :
sudo add-apt-repository ppa:ethereum/ethereum
sudo apt-get update
sudo apt-get install solc
La version nocturne peut être installée en utilisant ces commandes :
sudo add-apt-repository ppa:ethereum/ethereum
sudo add-apt-repository ppa:ethereum/ethereum-dev
sudo apt-get update
sudo apt-get install solc
Nous publions également un paquet [snap](https://snapcraft.io/), qui est installable dans toutes les [distros Linux supportées](https://snapcraft.io/docs/core/install). Pour installer la dernière version stable de solc :
Si vous voulez aider à tester la dernière version de développement de Solidity avec les changements les plus récents, veuillez utiliser ce qui suit :
sudo snap install solc --edge
Note
Le snap `solc` utilise un confinement strict. Il s’agit du mode le plus sûr pour les paquets snap mais il comporte des limitations, comme l’accès aux seuls fichiers de vos répertoires `/home` et `/media`. Pour plus d’informations, consultez la page [Démystifier le confinement de Snap](https://snapcraft.io/blog/demystifying-snap-confinement).
Arch Linux dispose également de paquets, bien que limités à la dernière version de développement :
Gentoo Linux possède un [Ethereum overlay](https://overlays.gentoo.org/#ethereum) qui contient un paquet Solidity. Après la configuration de l’overlay, `solc` peut être installé dans les architectures x86\_64 par :
## Paquets macOS[](#paquets-macos "Lien permanent vers cette rubrique")
Nous distribuons le compilateur Solidity via Homebrew comme une version construite à partir des sources. Les bouteilles préconstruites ne sont actuellement pas supportées.
brew update
brew upgrade
brew tap ethereum/ethereum
brew install solidity
Pour installer la plus récente version 0.4.x / 0.5.x de Solidity, vous pouvez également utiliser `brew install solidity@4` et `brew install solidity@5`, respectivement.
Si vous avez besoin d’une version spécifique de Solidity, vous pouvez installer une formule Homebrew directement depuis Github.
Voir [solidity.rb commits sur Github](https://github.com/ethereum/homebrew-ethereum/commits/master/solidity.rb).
Copiez le hash de commit de la version que vous voulez et vérifiez-la sur votre machine.
git clone https://github.com/ethereum/homebrew-ethereum.git
cd homebrew-ethereum
git checkout <your-hash-goes-here>
Installez-le en utilisant `brew` :
brew unlink solidity
＃ eg. Install 0.4.8
brew install solidity.rb
## Binaires statiques[](#binaires-statiques "Lien permanent vers cette rubrique")
Nous maintenons un dépôt contenant des constructions statiques des versions passées et actuelles du compilateur pour toutes les plateformes supportées. plates-formes supportées à [solc-bin](https://github.com/ethereum/solc-bin/). C’est aussi l’endroit où vous pouvez trouver les nightly builds.
Le dépôt n’est pas seulement un moyen rapide et facile pour les utilisateurs finaux d’obtenir des binaires prêts à l’emploi, mais il est également conçu pour être convivial pour les outils tiers :
* Le contenu est mis en miroir sur [https://binaries.soliditylang.org](https://binaries.soliditylang.org/), où il peut être facilement téléchargé via HTTPS sans authentification, ni contrôle. HTTPS sans authentification, limitation de débit ou nécessité d’utiliser git.
 
* Le contenu est servi avec des en-têtes Content-Type corrects et une configuration CORS indulgente afin qu’il puisse être directement chargé par des outils s’exécutant dans le navigateur.
 
* Les binaires ne nécessitent pas d’installation ou de déballage (à l’exception des anciennes versions de Windows fournies avec les DLL nécessaires).
 
* Nous nous efforçons d’assurer un haut niveau de compatibilité ascendante. Les fichiers, une fois ajoutés, ne sont pas supprimés ou déplacés sans fournir un lien symbolique/une redirection à l’ancien emplacement. Ils ne sont jamais modifiés non plus en place et doivent toujours correspondre à la somme de contrôle d’origine. La seule exception serait les fichiers cassés ou inutilisables, susceptibles de causer plus de tort que de bien s’ils sont laissés en l’état.
 
* Les fichiers sont servis à la fois par HTTP et HTTPS. Tant que vous obtenez la liste des fichiers d’une manière sécurisée (via git, HTTPS, IPFS ou simplement en la mettant en cache localement) et que vous vérifiez les hachages des binaires après les avoir téléchargés, vous n’avez pas besoin d’utiliser HTTPS pour les binaires eux-mêmes.
 
Les mêmes binaires sont dans la plupart des cas disponibles sur la page [\`Solidity release page on Github\`\_](#id5). La différence est que nous ne mettons généralement pas à jour les anciennes versions sur la page Github. Cela signifie que que nous ne les renommons pas si la convention de nommage change et que nous n’ajoutons pas de builds pour les plates-formes qui n’étaient pas supportées au moment de la publication. Ceci n’arrive que dans `solc-bin`.
Le dépôt `solc-bin` contient plusieurs répertoires de haut niveau, chacun représentant une seule plate-forme. Chacun contient un fichier `list.json` listant les binaires disponibles. Par exemple dans `emscripten-wasm32/list.json`, vous trouverez les informations suivantes sur la version 0.7.4 :
{
 "path": "solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js",
 "version": "0.7.4",
 "build": "commit.3f05b770",
 "longVersion": "0.7.4+commit.3f05b770",
 "keccak256": "0x300330ecd127756b824aa13e843cb1f43c473cb22eaf3750d5fb9c99279af8c3",
 "sha256": "0x2b55ed5fec4d9625b6c7b3ab1abd2b7fb7dd2a9c68543bf0323db2c7e2d55af2",
 "urls": \[
 "bzzr://16c5f09109c793db99fe35f037c6092b061bd39260ee7a677c8a97f18c955ab1",
 "dweb:/ipfs/QmTLs5MuLEWXQkths41HiACoXDiH8zxyqBHGFDRSzVE5CS"
 \]
}
Cela signifie que :
* Vous pouvez trouver le binaire dans le même répertoire sous le nom de [solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js](https://github.com/ethereum/solc-bin/blob/gh-pages/emscripten-wasm32/solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js). Notez que le fichier pourrait être un lien symbolique, et vous devrez le résoudre vous-même si vous n’utilisez pas git pour le télécharger ou si votre système de fichiers ne supporte pas les liens symboliques.
 
* Le binaire est également mis en miroir à [https://binaries.soliditylang.org/emscripten-wasm32/solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js](https://binaries.soliditylang.org/emscripten-wasm32/solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js). Dans ce cas, git n’est pas nécessaire et les liens symboliques sont résolus de manière transparente, soit en fournissant une copie du fichier ou en renvoyant une redirection HTTP.
 
* Le fichier est également disponible sur IPFS à l’adresse [QmTLs5MuLEWXQkths41HiACoXDiH8zxyqBHGFDRSzVE5CS](https://gateway.ipfs.io/ipfs/QmTLs5MuLEWXQkths41HiACoXDiH8zxyqBHGFDRSzVE5CS).
 
* Le fichier pourrait à l’avenir être disponible sur Swarm à l’adresse [16c5f09109c793db99fe35f037c6092b061bd39260ee7a677c8a97f18c955ab1](https://swarm-gateways.net/bzz:/16c5f09109c793db99fe35f037c6092b061bd39260ee7a677c8a97f18c955ab1/).
 
* Vous pouvez vérifier l’intégrité du binaire en comparant son hachage keccak256 à `0x300330ecd127756b824aa13e843cb1f43c473cb22eaf3750d5fb9c99279af8c3`. Le hachage peut être calculé en ligne de commande à l’aide de l’utilitaire `keccak256sum` fourni par [sha3sum](https://github.com/maandree/sha3sum) ou de la fonction keccak256() de ethereumjs-util\`\_ en JavaScript.
 
* Vous pouvez également vérifier l’intégrité du binaire en comparant son hachage sha256 à `0x2b55ed5fec4d9625b6c7b3ab1abd2b7fb7dd2a9c68543bf0323db2c7e2d55af2`.
 
Avertissement
En raison de la forte exigence de compatibilité ascendante, le référentiel contient quelques éléments anciens mais vous devriez éviter de les utiliser lorsque vous écrivez de nouveaux outils :
* Utilisez `emscripten-wasm32/` (avec une solution de repli sur `emscripten-asmjs/`) au lieu de `bin/` si vous voulez les meilleures performances. Jusqu’à la version 0.6.1, nous ne fournissions que les binaires asm.js. À partir de la version 0.6.2, nous sommes passés à des constructions [\`WebAssembly\`\_](#id7) avec de bien meilleures performances. Nous avons reconstruit les anciennes versions pour wasm mais les fichiers asm.js originaux restent dans `bin/`. Les nouveaux fichiers ont dû être placés dans un répertoire séparé pour éviter les conflits de noms.
 
* Utilisez `emscripten-asmjs/` et `emscripten-wasm32/` au lieu des répertoires `bin/` et `wasm/` si vous voulez être sûr que vous téléchargez un binaire wasm ou asm.js.
 
* Utilisez `list.json` au lieu de `list.js` et `list.txt`. Le format de liste JSON contient toutes les informations des anciens formats et plus encore.
 
* Utilisez [https://binaries.soliditylang.org](https://binaries.soliditylang.org/) au lieu de [https://solc-bin.ethereum.org](https://solc-bin.ethereum.org/). Pour garder les choses simples, nous avons déplacé presque tout ce qui concerne le compilateur sous le nouveau domaine `soliditylang.org`, et cela s’applique aussi à `solc-bin`. Bien que le nouveau domaine soit recommandé, l’ancien domaine est toujours entièrement supporté et garanti pour pointer au même endroit.
 
Avertissement
Les binaires sont également disponibles à [https://ethereum.github.io/solc-bin/](https://ethereum.github.io/solc-bin/) mais cette page a cessé d’être mise à jour juste après la sortie de la version 0.7.2, ne recevra pas de nouvelles versions ou nightly builds pour n’importe quelle plateforme et ne sert pas la nouvelle structure de répertoire, y compris les les constructions non-emscriptées.
Si vous l’utilisez, veuillez basculer vers [https://binaries.soliditylang.org](https://binaries.soliditylang.org/), qui est une solution de remplacement. Ceci nous permet d’apporter des changements à l’hébergement sous-jacent de manière transparente et de minimiser les perturbations. Contrairement au domaine `ethereum.github.io`, sur lequel nous n’avons aucun contrôle, [\`\`](#id1)binaries.github.io\`”” est un domaine sur lequel nous n’avons aucun contrôle, « binaries.soliditylang.org  » est garanti de fonctionner et de maintenir la même structure d’URL à long terme.
## Construire à partir de la source[](#construire-a-partir-de-la-source "Lien permanent vers cette rubrique")
### Conditions préalables - Tous les systèmes d’exploitation[](#conditions-prealables-tous-les-systemes-d-exploitation "Lien permanent vers cette rubrique")
Les éléments suivants sont des dépendances pour toutes les versions de Solidity :
 
Logiciel
Notes
[CMake](https://cmake.org/download/) (version 3.13+)
Générateur de fichiers de construction multiplateforme.
[Boost](https://www.boost.org/) (version 1.77+ sur Windows, 1.65+ sinon)
Librairies C++.
[Git](https://git-scm.com/download)
Outil en ligne de commande pour la récupération du code source.
[z3](https://github.com/Z3Prover/z3) (version 4.8+, Optionnel)
À utiliser avec le vérificateur SMT.
[cvc4](https://cvc4.cs.stanford.edu/web/) (Optionnel)
À utiliser avec le vérificateur SMT.
Note
Les versions de Solidity antérieures à 0.5.10 ne parviennent pas à se lier correctement avec les versions Boost 1.70+. Une solution possible est de renommer temporairement le répertoire `<Chemin d'installation de Boost>/lib/cmake/Boost-1.70.0` avant d’exécuter la commande cmake pour configurer solidity.
A partir de la 0.5.10, la liaison avec Boost 1.70+ devrait fonctionner sans intervention manuelle.
Note
La configuration de construction par défaut requiert une version spécifique de Z3 (la plus récente au moment de la dernière mise à jour du code). Les changements introduits entre les versions de Z3 entraînent souvent des résultats résultats légèrement différents (mais toujours valides). Nos tests SMT ne tiennent pas compte de ces différences et échoueront probablement avec une version différente de celle pour laquelle ils ont été écrits. Cela ne veut pas dire qu’une compilation utilisant une version différente est défectueuse. Si vous passez l’option `-DSTRICT_Z3_VERSION=OFF` à CMake, vous pouvez construire avec n’importe quelle version qui satisfait aux exigences données dans la table ci-dessus. Si vous faites cela, cependant, n’oubliez pas de passer l’option `--no-smt` à `scripts/tests.sh` pour sauter les tests SMT.
#### Versions minimales du compilateur[](#versions-minimales-du-compilateur "Lien permanent vers cette rubrique")
Les compilateurs C++ suivants et leurs versions minimales peuvent construire la base de code Solidity :
* [GCC](https://gcc.gnu.org/), version 8+
 
* [Clang](https://clang.llvm.org/), version 7+
 
* [MSVC](https://visualstudio.microsoft.com/vs/), version 2019+
 
### Conditions préalables - macOS[](#conditions-prealables-macos "Lien permanent vers cette rubrique")
Pour les builds macOS, assurez-vous que vous avez la dernière version de [Xcode installée](https://developer.apple.com/xcode/download/). Cela contient le compilateur [Clang C++](https://en.wikipedia.org/wiki/Clang), l” [Xcode IDE](https://en.wikipedia.org/wiki/Xcode) et d’autres outils qui sont nécessaires à la création d’applications C++ sous OS X. Si vous installez Xcode pour la première fois, ou si vous venez d’installer une nouvelle nouvelle version, vous devrez accepter la licence avant de pouvoir effectuer des des constructions en ligne de commande :
sudo xcodebuild -license accept
Notre script de construction OS X utilise le gestionnaire de paquets Homebrew <[https://brew.sh](https://brew.sh/)\>\`\_ pour installer les dépendances externes. Voici comment [désinstaller Homebrew](https://docs.brew.sh/FAQ#how-do-i-uninstall-homebrew), si vous voulez un jour repartir de zéro.
### Conditions préalables - Windows[](#conditions-prealables-windows "Lien permanent vers cette rubrique")
Vous devez installer les dépendances suivantes pour les versions Windows de Solidity :
Si vous avez déjà un IDE et que vous avez seulement besoin du compilateur et des bibliothèques, vous pouvez installer Visual Studio 2019 Build Tools.
Visual Studio 2019 fournit à la fois l’IDE et le compilateur et les bibliothèques nécessaires. Donc, si vous n’avez pas d’IDE et que vous préférez développer Solidity, Visual Studio 2019 peut être un choix pour vous afin de tout configurer facilement.
Voici la liste des composants qui doivent être installés dans Visual Studio 2019 Build Tools ou Visual Studio 2019 :
* Fonctions de base de Visual Studio C++
 
* VC++ 2019 v141 toolset (x86,x64)
 
* SDK CRT universel Windows
 
* SDK Windows 8.1
 
* Support C++/CLI
 
Nous avons un script d’aide que vous pouvez utiliser pour installer toutes les dépendances externes requises :
Ceci installera `boost` et `cmake` dans le sous-répertoire `deps`.
### Clonez le référentiel[](#clonez-le-referentiel "Lien permanent vers cette rubrique")
Pour cloner le code source, exécutez la commande suivante :
git clone --recursive https://github.com/ethereum/solidity.git
cd solidity
Si vous voulez aider à développer Solidity, vous devez forker Solidity et ajouter votre fork personnel en tant que second remote :
git remote add personal git@github.com:\[username\]/solidity.git
Note
Cette méthode aboutira à une construction preerelease conduisant par exemple à ce qu’un drapeau dans chaque bytecode produit par un tel compilateur. Si vous souhaitez recompiler un compilateur Solidity déjà publié, alors veuillez utiliser le tarball source sur la page de publication github :
[https://github.com/ethereum/solidity/releases/download/v0.X.Y/solidity\_0.X.Y.tar.gz](https://github.com/ethereum/solidity/releases/download/v0.X.Y/solidity_0.X.Y.tar.gz)
(et non le « code source » fourni par github).
### Construction en ligne de commande[](#construction-en-ligne-de-commande "Lien permanent vers cette rubrique")
**Assurez-vous d’installer les dépendances externes (voir ci-dessus) avant la construction.**
Le projet Solidity utilise CMake pour configurer la construction. Vous pourriez vouloir installer [ccache](https://ccache.dev/) pour accélérer les constructions répétées, CMake le récupérera automatiquement. La construction de Solidity est assez similaire sur Linux, macOS et autres Unices :
mkdir build
cd build
cmake .. && make
ou encore plus facilement sur Linux et macOS, vous pouvez exécuter :
＃note: this will install binaries solc and soltest at usr/local/bin
./scripts/build.sh
Avertissement
Les versions BSD devraient fonctionner, mais ne sont pas testées par l’équipe Solidity.
Et pour Windows :
mkdir build
cd build
cmake -G "Visual Studio 16 2019" ..
Si vous voulez utiliser la version de boost installée par `scripts\install_deps.ps1`, vous aurez vous devrez en plus passer `-DBoost_DIR="deps\boost\lib\cmake\Boost-*"` et `-DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreaded` comme arguments à l’appel à `cmake`.
Cela devrait entraîner la création de **solidity.sln** dans ce répertoire de construction. En double-cliquant sur ce fichier, Visual Studio devrait se lancer. Nous suggérons de construire **Release**, mais toutes les autres configurations fonctionnent.
Alternativement, vous pouvez construire pour Windows sur la ligne de commande, comme ceci :
cmake --build . --config Release
## Options CMake[](#options-cmake "Lien permanent vers cette rubrique")
Si vous êtes intéressé par les options CMake disponibles, lancez `cmake .. -LH`.
### Solveurs SMT[](#solveurs-smt "Lien permanent vers cette rubrique")
Solidity peut être construit avec des solveurs SMT et le fera par défaut s’ils sont trouvés dans le système. Chaque solveur peut être désactivé par une option cmake.
_Note : Dans certains cas, cela peut également être une solution de contournement potentielle pour les échecs de construction._
Dans le dossier de construction, vous pouvez les désactiver, puisqu’ils sont activés par défaut :
＃ disables only Z3 SMT Solver.
cmake .. -DUSE_Z3=OFF
# disables only CVC4 SMT Solver.
cmake .. -DUSE_CVC4=OFF
# disables both Z3 and CVC4
cmake .. -DUSE_CVC4=OFF -DUSE_Z3=OFF
## La chaîne de version en détail[](#la-chaine-de-version-en-detail "Lien permanent vers cette rubrique")
La chaîne de la version de Solidity contient quatre parties :
* le numéro de version
 
* l’étiquette de préversion, généralement définie par `development.YYYY.MM.DD` ou `nightly.YYYY.MM.DD`.
 
* le commit au format `commit.GITHASH`.
 
* platform, qui comporte un nombre arbitraire d’éléments, contenant des détails sur la plate-forme et le compilateur.
 
S’il y a des modifications locales, le commit sera postfixé avec `.mod`.
Ces parties sont combinées comme requis par SemVer, où la balise pre-release Solidity est égale à la pre-release SemVer et le commit Solidity et la plateforme combinés constituent les métadonnées de construction SemVer.
Exemple de version :  » 0.4.8+commit.60cc1668.Emscripten.clang « .
Exemple de préversion :  » 0.4.9-nightly.2017.1.17+commit.6ecb4aa3.Emscripten.clang « .
## Informations importantes sur les versions[](#informations-importantes-sur-les-versions "Lien permanent vers cette rubrique")
Après la sortie d’une version, le niveau de version du patch est augmenté, car nous supposons que seuls les changements de niveau patch suivent. Lorsque les changements sont fusionnés, la version doit être augmentée en fonction de SemVer et de la gravité de la modification. Enfin, une version est toujours faite avec la version du nightly build actuel, mais sans le spécificateur [\`\`](#id3)prerelease\`”.
Exemple :
0. La version 0.4.0 est faite.
 
1. Le nightly build a une version 0.4.1 à partir de maintenant.
 
2. Des changements non cassants sont introduits –> pas de changement de version.
 
3. Un changement de rupture est introduit –> la version passe à 0.5.0.
 
4. La version 0.5.0 est publiée.
 
Ce comportement fonctionne bien avec la version [pragma](https://docs.soliditylang.org/fr/latest/layout-of-source-files.html#version-pragma).

