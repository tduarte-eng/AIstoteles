---
title: Private networks
sidebar_position: 1
sidebar_label: Introduction
id: index
description: Private networks overview
tags:
  - private networks
---

# Besu for private (permissioned) networks

You can use Besu to develop enterprise applications requiring secure, high-performance transaction processing in a private network.

A private (also known as permissioned) network is a network not connected to Ethereum Mainnet or an Ethereum testnet. Private networks typically use a different [chain ID](../public-networks/concepts/network-and-chain-id.md) and proof of authority (PoA) consensus ([QBFT](how-to/configure/consensus/qbft.md), [IBFT 2.0](how-to/configure/consensus/ibft.md), or [Clique](how-to/configure/consensus/clique.md)).

You can also [create a local development network using proof of work (PoW) (Deprecated)](tutorials/ethash.md).

Besu supports enterprise features including [privacy (Deprecated)](concepts/privacy/index.md) and [permissioning](concepts/permissioning/index.md).

Get started with the [Developer Quickstart](tutorials/quickstart.md) to rapidly generate local blockchain networks.

If you have any questions about Besu for private (permissioned) networks, ask on the **besu-enterprise** channel on
[Discord](https://discord.com/channels/905194001349627914/1172617318845657199).

## Architecture

The following diagram outlines the high-level architecture of Besu for private networks.

![Private architecture](../assets/images/private-architecture.jpeg)

---
sidebar_label: Node synchronization
sidebar_position: 4
description: Learn about node synchronization for private networks.
tags:
  - private networks
---

# Node synchronization for private networks

For private, permissioned blockchain networks, Besu uses the same [synchronization 
modes as public networks](../../public-networks/concepts/node-sync.md), but with specific configurations
for private network needs.

To sync Besu on a private network:

- Ensure all nodes use compatible sync modes and configurations.
- Configure the network with a custom genesis file.
- Set the network ID and bootnodes specific to your private network.
- Implement permissioning features to control network access.

The following is an overview of the private network sync modes.
Select the sync mode based on your network's requirements and node purposes.

| Sync mode                                                                            | Description                                                                                                                                                                         | Requirements                 | Limitations                                                                     |
|--------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------|---------------------------------------------------------------------------------|
| [Snap](../../public-networks/concepts/node-sync.md#snap-synchronization)             | Recommended for fastest sync and lowest storage requirements on Mainnet. Downloads as many leaves of the trie as possible and reconstructs the trie locally. Faster than fast sync. | Besu version 24.3.0 or later | Cannot switch from fast sync to snap sync mid-process.                          |
| [Checkpoint](../../public-networks/concepts/node-sync.md#checkpoint-synchronization) | Syncs from a specific checkpoint block configured in the genesis file. Fastest sync mode with lowest storage requirements.                                                          | Besu version 22.4.3 or later | Not supported for QBFT or IBFT 2.0 networks without a checkpoint configuration. |
| [Fast](../../public-networks/concepts/node-sync.md#fast-synchronization-deprecated)  | Downloads block headers and transaction receipts, verifies chain from genesis block.                                                                                                | None                         | Deprecated. Not supported with private transactions.                            |
| [Full](../../public-networks/concepts/node-sync.md#full-synchronization)             | Default for all private networks. Downloads and verifies the entire blockchain and state from genesis block, building an archive node with full state history.                      | None                         | Slowest sync mode, requires the most disk space.                                |


---
title: Proof of authority consensus
sidebar_position: 1
description: Besu proof of authority consensus protocols comparison
tags:
  - private networks
---

# Proof of authority consensus

Besu implements the QBFT, IBFT 2.0, and Clique proof of authority (PoA) [consensus protocols](../how-to/configure/consensus/index.md). PoA consensus protocols work when participants know each other and there is a level of trust between them. For example, in a permissioned consortium network.

PoA consensus protocols have faster block times and a much greater transaction throughput than the Ethash proof of work consensus protocol used on the Ethereum Mainnet.

In QBFT, IBFT 2.0, or Clique, a group of nodes in the network act as validators (QBFT and IBFT 2.0) or signers (Clique). The existing nodes in the signer/validator pool vote to add nodes to or remove nodes from the pool.

:::note

For the rest of this page, the term validator is used to refer to signers and validators.

:::

## Properties

Properties to consider when comparing QBFT, IBFT 2.0, and Clique are:

- Immediate finality.
- Minimum number of validators.
- Liveness.
- Speed.

### Immediate finality

QBFT and IBFT 2.0 have immediate finality; there are no forks and all valid blocks get included in the main chain.

Clique does not have immediate finality. Implementations using Clique must be aware of forks and chain reorganizations occurring.

### Minimum number of validators

To be Byzantine fault tolerant, QBFT and IBFT 2.0 require a minimum of four validators.

Clique can operate with a single validator but operating with a single validator offers no redundancy if the validator fails.

:::tip

Byzantine fault tolerant is the ability to function correctly and reach consensus despite nodes failing or propagating incorrect information to peers.

:::

### Liveness

Clique is more fault tolerant than QBFT and IBFT 2.0. Clique tolerates up to half of the validators failing. QBFT and IBFT 2.0 networks require greater than or equal to two-thirds of validators to be operating to create blocks. For example, an QBFT and IBFT 2.0 network of:

- Four to five validators tolerates one unresponsive validator.
- Six to eight validators tolerates two unresponsive validators.

Networks with three or less validators can produce blocks but do not guarantee finality when operating in adversarial environments.

:::caution

We recommend using QBFT or IBFT 2.0 networks with at least four nodes in production environments.

:::

### Speed

Reaching consensus and adding blocks is faster in Clique networks. For Clique, the probability of a fork increases as the number of validators increases.

For QBFT and IBFT 2.0, the time to add new blocks increases as the number of validators increases.

---
title: Permissioning
sidebar_position: 1
description: Besu permissioning feature
tags:
  - private networks
---

# Permissioning

A permissioned network enables node permissioning and account permissioning, allowing only specified nodes and accounts to access the network.

:::caution Permissioning is not privacy

In peer-to-peer networks, node permissioning enforces rules on nodes you control.

Permissioning requires a distributed network of trust across the network where participants agree to follow the rules. One bad actor can decide not to follow the rules. Nodes can take action to prevent the bad actor from adding to the chain but they cannot prevent the bad actor from allowing access to the chain.

Besu also implements [privacy](../privacy/index.md).

:::

## Node permissioning

Use node permissioning to restrict access to known participants only.

![Node Permissioning](../../../assets/images/node-permissioning-bad-actor.png)

## Account permissioning

Use account permissioning to:

- Enforce onboarding or identity requirements.
- Suspend accounts.
- Restrict the actions an account can perform.

![Account Permissioning](../../../assets/images/enterprise-ethereum-account-permissioning.png)

## Specify permissioning

You can specify permissioning [locally](#local) or [onchain](#onchain-deprecated).

### Local

[Local permissioning](../../how-to/use-permissioning/local.md) works at the node level. Each node in the network has a [permissions configuration file].

Local permissioning affects your node but not the rest of the network. Use local permissioning to restrict use of your node (that is, the resources under your control). For example, customers are able to access your node.

Local permissioning does not require coordination with the rest of the network and you can act immediately to protect your node. Your rules are not enforced in blocks produced by other nodes.

### Onchain (Deprecated)

:::caution

Onchain permissioning is deprecated in Besu version 24.12.0 and later. Please read this [blog post](https://www.lfdecentralizedtrust.org/blog/sunsetting-tessera-and-simplifying-hyperledger-besu) for more context on the rationale behind this decision as well as alternative options.

:::

[Onchain permissioning](onchain.md) works through a smart contract on the network. Specifying permissioning onchain enables all nodes to read and update permissioning configuration from one location.

Onchain permissioning requires coordination to update the rules. The network might not be able to act immediately (for example, the smart contract might enforce a minimum number of votes before changing permissioning rules).

When you update onchain permissioning, the update applies across the network and new blocks abide by the updated rules. For example, blocked accounts can no longer add transactions to the chain.

The following diagram illustrates applying local and onchain permissioning rules.

![Permissioning Flow](../../../assets/images/PermissioningFlow.png)

<!-- Links -->

[permissions configuration file]: ../../how-to/use-permissioning/local.md#permissions-configuration-file

---
title: Onchain permissioning
description: Onchain permissioning
sidebar_position: 1
tags:
  - private networks
---

# Onchain permissioning (Deprecated)

:::caution

Onchain permissioning is deprecated in Besu version 24.12.0 and later. Please read this [blog post](https://www.lfdecentralizedtrust.org/blog/sunsetting-tessera-and-simplifying-hyperledger-besu) for more context on the rationale behind this decision as well as alternative options.

:::

Onchain [permissioning](index.md) uses smart contracts to store and administer the node, account, and admin allowlists. Using onchain permissioning enables all nodes to read the allowlists from a single source, the blockchain.

:::danger

When using onchain account permissioning, a node checks permissions when importing blocks. Meaning, a node only imports blocks in which all transactions are from authorized senders. If you disable onchain account permissioning and your node accepts blocks without enforcing this rule, your node cannot re-synchronize with other nodes that enforce onchain account permissioning rules (your node goes into forked state).

:::

:::note

Custom smart contracts and dapps can be implemented to work with onchain permissioning.

:::

## Permissioning contracts

:::caution

The permissioning contract has multiple interfaces, and each interface maps to a specific version of the [Enterprise Ethereum Alliance Client Specification](https://entethalliance.org/technical-specifications/). Ensure that you [specify the permissioning contract interface] being used when starting Besu.

:::

### Allowlists

Permissioning implements three allowlists:

- Accounts, which can submit transactions to the network.
- Nodes, which can join the network.
- Admins, which are accounts able to update the accounts and nodes allowlists.

:::caution Using account permissioning and privacy

Account permissioning is incompatible with [random key signing](../../how-to/use-privacy/sign-pmts.md) for [privacy marker transactions](../privacy/private-transactions/processing.md).

If using account permissioning and privacy, a signing key must be specified using the [`--privacy-marker-transaction-signing-key-file`](../../reference/cli/options.md#privacy-marker-transaction-signing-key-file-deprecated) command line option and the corresponding public key included in the accounts allowlist.

:::

:::tip

If nodes are not connecting as expected, set the [log level to `TRACE`](../../../public-networks/reference/cli/options.md#logging) and search for messages containing `Node permissioning` to identify the issue.

Ensure the [`--p2p-host`](../../../public-networks/reference/cli/options.md#p2p-host) command line option has been correctly configured for all nodes with the externally accessible address.

If you change your network configuration, you may need to update the node allowlist.

:::

## Bootnodes

When a node joins the network, the node connects to the [bootnodes](../../how-to/configure/bootnodes.md) until it synchronizes to the chain head, regardless of node permissions. After synchronization, the Account Rules and Node Rules smart contracts apply the permissioning rules.

If a synchronized node loses all peer connections (that is, it has zero peers), it reconnects to the bootnodes to rediscover peers.

:::info

All bootnodes must be on the nodes allowlist.

:::

<!-- Links -->

[specify the permissioning contract interface]: ../../how-to/use-permissioning/onchain.md#specify-the-permissioning-contract-interface-version

---
title: Permissioning plugin
description: Plugin based permissioning
sidebar_position: 2
tags:
  - private networks
---

# Permissioning plugin

You can define complex [permissioning](index.md) solutions by building a plugin that extends Besu functionality.

The plugin API provides a `PermissioningService` interface that currently supports connection (node) permissioning, transaction permissioning and message permissioning.

## Connection (node) permissioning

Use connection permissioning when deciding whether to restrict node access to known participants only.

## Transaction permissioning

Use transaction permissioning when deciding whether to restrict transaction processing based on transaction properties.

## Message permissioning

Use message permissioning to propagate different types of devP2P messages to particular nodes. For example, this can be used to prevent pending transactions from being forwarded to other nodes.

## Register your plugin

To enable permissioning in your plugin, implement the `PermissioningService` interface and register your providers.

```java
@AutoService(BesuPlugin.class)
public class TestPermissioningPlugin implements BesuPlugin {
  PermissioningService service;
  @Override
  public void register(final BesuContext context) {
    service = context.getService(PermissioningService.class).get();
  }
  @Override
  public void start() {
    service.registerNodePermissioningProvider((sourceEnode, destinationEnode) -> {
      // perform logic for node permissioning
      return true;
    });
    service.registerNodeMessagePermissioningProvider((destinationEnode, code) -> {
      // perform logic for message permissioning
      return true;
    });
  }
  @Override
  public void stop() {}
}
```
---
title: Privacy
sidebar_position: 1
description: Privacy
---

# Privacy (Deprecated)

:::caution

Tessera-based privacy is deprecated in Besu version 24.12.0 and later. Please read this [blog post](https://www.lfdecentralizedtrust.org/blog/sunsetting-tessera-and-simplifying-hyperledger-besu) for more context on the rationale behind this decision as well as alternative options.

:::

In Besu, privacy refers to the ability to keep transactions private between the involved participants. Other participants cannot access the transaction content or list of participants.

:::danger

For production environments requiring private transactions:

- We recommend using a network with a consensus mechanism supporting transaction finality. For example, [IBFT 2.0](../../how-to/configure/consensus/ibft.md).
- Tessera must be [highly available and run in a separate instance to Besu].

Using private transactions with [fast sync](../../../public-networks/reference/cli/options.md#sync-mode) isn't supported.

:::

## Private transaction manager

Besu uses a private transaction manager, [Tessera](https://docs.tessera.consensys.net/), to implement privacy. Each Besu node that sends or receives [private transactions](private-transactions/index.md) requires an associated Tessera node.

<p align="center">

![Tessera Nodes](../../../assets/images/TesseraNodes.png)

</p>

Private transactions pass from the Besu node to the associated Tessera node. The Tessera node encrypts and directly distributes (that is, point-to-point) the private transaction to the Tessera nodes participating in the transaction.

By default, each participant in a privacy-enabled network uses its own Besu and Tessera node. [Multi-tenancy](multi-tenancy.md) allows more than one participant to use the same Besu and Tessera node.

:::tip

Private Transaction Managers are also known as Enclaves.

:::

## Privacy-enabled networks

When enabling privacy in a [private network](../../get-started/system-requirements.md), there's an assumed level of trust among the node operators, since all are members of the private network.

:::caution

Inefficient contracts deployed accidentally or deliberately can cause performance issues in privacy-enabled networks because gas isn't required in private transactions.

:::

In contrast, gas is required in Ethereum Mainnet and public testnets because they are trustless environments.

Privacy-enabled networks should have a mechanism to establish trust offchain. Node operators should be informed on:

- Guidelines for use, responsibilities, and good behavior.
- Smart contract security, so contracts deployed on the network use resources efficiently.
- Consequences for malicious activity.

Privacy-enabled networks should run development and test environments that closely resemble production, so contracts can be tested, and potential issues can be found before they're deployed in production.

## Reorg-compatible privacy

In v1.4, using private transactions in a network using a consensus mechanism where forks occur (that is, PoW algorithms or Clique) is an early access feature.

Do not use private transactions in production environments using consensus mechanisms where forks occur.

<!-- Links -->

[highly available and run in a separate instance to Besu]: ../../how-to/use-privacy/tessera.md

---
title: Flexible privacy groups
sidebar_position: 3
description: Flexible privacy groups
---

# Flexible privacy groups (Deprecated)

:::caution

Tessera-based privacy is deprecated in Besu version 24.12.0 and later. Please read this [blog post](https://www.lfdecentralizedtrust.org/blog/sunsetting-tessera-and-simplifying-hyperledger-besu) for more context on the rationale behind this decision as well as alternative options.

:::

Flexible [privacy groups](privacy-groups.md) use smart contracts to store and maintain the group membership. You can [add and remove members to and from flexible privacy groups](../../how-to/use-privacy/flexible.md).

:::tip

Because group membership for flexible privacy groups is stored in a smart contract, flexible privacy groups are also known as onchain privacy groups.

:::

:::danger

Flexible privacy groups are an early access feature. Don't use in production networks.

The flexible privacy group interfaces might change between releases. There might not be an upgrade path from flexible privacy groups created using v1.5 or earlier to enable use of flexible privacy group functionality in future versions.

We don't recommend creating flexible privacy groups in a chain with existing [offchain privacy groups](privacy-groups.md).

:::

## Group management contracts

The privacy group management contract bytecode is hard-coded into Besu and when you create a privacy group, the contract bytecode is part of the genesis state of the privacy group.

:::caution

All members of a flexible privacy group must be using the same version of Besu. If using different versions, the private state within the privacy group may become inconsistent.

:::

In the default implementation of the group management contract, the signer of the private transaction that creates the privacy group is also the owner of the group. Only the owner can add and remove participants, and upgrade the management contract.

The owner is identified by the signing key. Transactions to add and remove participants, or upgrade the management contract, must be signed by the same key that signed the group creation transaction.

## Flexible privacy group IDs

When creating a flexible privacy group, generate the privacy group ID for the group outside of Besu and pass the ID as a parameter.

The [web3js-quorum library](../../how-to/use-privacy/flexible.md) generates a unique privacy group ID and passes the ID to Besu when creating a privacy group.

:::caution

When generating a privacy group ID, you must ensure the ID is unique across all network participants. If you create a privacy group with an existing privacy group ID, the existing privacy group is overwritten.

To ensure unique privacy group IDs, we recommend using 256-bit SecureRandom.

:::

## Multi-tenancy

When using [multi-tenancy](multi-tenancy.md) with flexible privacy groups, each user provides a JSON Web Token (JWT) which allows Besu to check that the user has access to functionality and data associated with a privacy group.

Using multi-tenancy with flexible privacy groups is more complex than with [offchain privacy groups](privacy-groups.md) because users may be added and removed from flexible privacy groups. When a user is added to a privacy group, they get access to all existing data in the privacy group. After being removed from a privacy group, a user retains access to already existing data in the privacy group, up to the block containing the [privacy marker transaction (PMT)](private-transactions/processing.md) that removed them (the removal block). A removed user doesn't have access to data in the privacy group that happens after they were removed.

In particular, when multi-tenancy is enabled and a user requests access to a privacy group they were once a member of but later removed from, Besu allows the user access to the following functionality and data associated with the privacy group:

- Private transactions using `priv_getTransaction` and private transaction receipts using [`priv_getTransactionReceipt`](../../reference/api/index.md#priv_gettransactionreceipt) from blocks up to (and including) the removal block.

  :::note

  A removed group member may have access to some private transactions after the removal PMT in the same block.

  :::

- Using [`priv_call`](../../reference/api/index.md#priv_call) on blocks up to (and including) the removal block.

- Private logs using [`priv_getLogs`](../../reference/api/index.md#priv_getlogs) for blocks up to (and including) the removal block. When the `toBlock` is greater than the removal block, `priv_getLogs` still returns logs up to the removal block.

  :::note

  When a user is removed from a privacy group, any log filters they've created are also removed and can't be accessed. A user can only create and access filters for a privacy group they are currently a member of.

  :::

All other [`PRIV` API methods](../../reference/api/index.md#priv-methods) fail for the removed group member.

---
title: Multi-tenancy
sidebar_position: 4
description: Multi-tenancy
---

# Multi-tenancy (Deprecated)

:::caution

Tessera-based privacy is deprecated in Besu version 24.12.0 and later. Please read this [blog post](https://www.lfdecentralizedtrust.org/blog/sunsetting-tessera-and-simplifying-hyperledger-besu) for more context on the rationale behind this decision as well as alternative options.

:::

By default, each participant in a privacy network uses its own Besu and Tessera node.

Multi-tenancy allows multiple participants to use the same Besu and Tessera node. Each participant is a _tenant_, and the operator is the _owner_ of the Besu and Tessera node.

:::info

The operator is responsible for [configuring multi-tenancy](../../tutorials/privacy/multi-tenancy.md), and has access to all tenant data.

:::

![Multi-tenancy](../../../assets/images/Multi-tenancy.png)

:::tip

Ensure the multi-tenant Tessera node client API is configured to allow access only by the multi-tenant Besu node. Access to your data is secured through Besu using multi-tenancy mode.

If not configured to allow access only by the multi-tenant Besu node, other Tessera clients, including other Besu nodes, might be able to access tenant data.

To secure access, you can [configure TLS between Besu and Tessera](../../how-to/configure/tls.md) with the [`WHITELIST`](https://docs.tessera.consensys.net/en/stable/HowTo/Configure/TLS/#whitelist) trust mode.

:::

Multi-tenancy validates that tenants have permission to use the specified HTTP or WebSocket JSON-RPC requests, and the tenant has access to the requested privacy data. Private data is isolated and each tenant uses a JSON Web Token (JWT) for authentication.

You can [create the JWT either externally or internally](../../../public-networks/how-to/use-besu-api/authenticate.md).

---
title: Privacy plugin
description: Privacy plugin
sidebar_position: 5
---

# Privacy plugin (Deprecated)

:::caution

Tessera-based privacy is deprecated in Besu version 24.12.0 and later. Please read this [blog post](https://www.lfdecentralizedtrust.org/blog/sunsetting-tessera-and-simplifying-hyperledger-besu) for more context on the rationale behind this decision as well as alternative options.

:::

You can define your own strategy for private transactions by building a plugin that extends Besu functionality.

The plugin can take many forms, but it must provide Besu with a private transaction when required.

:::danger

The privacy plugin is an early access feature and plugin interfaces are subject to change between releases.

:::

## Configuration

Enable the privacy plugin by starting Besu and including the `--Xprivacy-plugin-enabled` command line option. The registered plugin must implement the `PrivacyPluginPayloadProvider` interface.

## Use the payload provider interface

The privacy plugin must define the [privacy marker transaction (PMT)] payload. Use the payload to retrieve the contents of the private transaction which could be a link to a location in an enclave, or an encrypted form of the private payload itself.

Besu doesn't need to know how the private transaction is distributed, it just needs to know what the private transaction for the PMT is.

### Send transactions

When submitting a private transaction using [`eea_sendRawTransaction`](../../reference/api/index.md#eea_sendrawtransaction), the signed transaction must be sent to `0x000000000000000000000000000000000000007a` to indicate which [privacy precompiled contract](private-transactions/processing.md) is being used.

The transaction flow is as follows:

1. The JSON-RPC endpoint passes the private transaction to the private transaction manager (for example Tessera).
2. The private transaction manager sends the private transaction to the privacy plugin.
3. The plugin decides what data to store onchain in the payload, for example the encrypted and serialized private transaction.
4. The plugin returns what needs to be stored in the payload for the PMT.
5. The private transaction handler creates a PMT for the private transaction, and propagates the PMT using devP2P in the same way as a public Ethereum transaction.

### Mine transactions

The process of mining transactions happens in reverse to sending transactions.

1.  The Mainnet transaction processor processes the PMT in the same way as any other public transaction. On nodes containing the [privacy precompile contract](../../reference/api/index.md#priv_getprivacyprecompileaddress) specified in the `to` attribute of the PMT, the Mainnet transaction processor passes the PMT to the privacy precompile contract.

    :::note

    Nodes receiving the PMT that do not contain the specified privacy precompile contract will ignore the PMT.

    :::

1.  The privacy precompile contract queries the plugin for the private transaction using the PMT.
1.  The privacy precompile contract passes the private transaction to the private transaction manager. The privacy group ID specifies the private world state to use.
1.  The private transaction manager executes the transaction. The private transaction manager can read and write to the private world state, and read from the public world state.

## Transaction factory

An additional extension is available to help you define how PMTs are signed. Currently, Besu supports fixed or random key signing for PMTs.

The extension allows you to use a more dynamic approach, for example different keys for different groups.

Your plugin needs to register the `PrivateMarkerTransactionFactory` interface which is called before submitting a PMT to the transaction pool. The responsibility then lies with the plugin to sign and serialize the PMT.

[privacy marker transaction (PMT)]: ../../how-to/use-privacy/access-private-transactions.md

## Register your plugin

To enable Besu to use your privacy plugin, implement the `PrivacyPluginService` interface and call `setPayloadProvider`.

```java
@AutoService(BesuPlugin.class)
public class TestPrivacyPlugin implements BesuPlugin {
  private PrivacyPluginService service;
  @Override
  public void register(BesuContext context) {
    service = context.getService(PrivacyPluginService.class).get();
  }
  @Override
  public void start() {
    service.setPayloadProvider(new PrivacyPluginPayloadProvider() {
      @Override
      public Bytes generateMarkerPayload(PrivateTransaction privateTransaction, String privacyUserId) {
        // perform logic to serialize the payload of the marker transaction
        // in this example we are serialising the private transaction using rlp https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/
        return org.hyperledger.besu.ethereum.privacy.PrivateTransaction.serialize(privateTransaction).encoded();
      }
      @Override
      public Optional<PrivateTransaction> getPrivateTransactionFromPayload(Transaction transaction) {
        // perform logic to deserialize payload from the marker transaction
        final BytesValueRLPInput bytesValueRLPInput =
          new BytesValueRLPInput(transaction.getPayload(), false);
        return Optional.of(org.hyperledger.besu.ethereum.privacy.PrivateTransaction.readFrom(bytesValueRLPInput));
      }
    });
  }
  @Override
  public void stop() {}
}
```
---
title: Privacy groups
sidebar_position: 2
description: Privacy groups
---

# Privacy groups (Deprecated)

:::caution

Tessera-based privacy is deprecated in Besu version 24.12.0 and later. Please read this [blog post](https://www.lfdecentralizedtrust.org/blog/sunsetting-tessera-and-simplifying-hyperledger-besu) for more context on the rationale behind this decision as well as alternative options.

:::

A privacy group is a group of nodes identified by a unique privacy group ID by Tessera. Tessera stores each private transaction with the privacy group ID.

The Besu nodes maintain the public world state for the blockchain and a private state for each privacy group. The private states contain data that is not shared in the globally replicated world state.

:::caution

The privacy group implementations described below are offchain privacy groups and cannot have their group membership updated.

[Flexible privacy groups are an early access feature](flexible-privacy.md).

:::

## Privacy types

Besu implements two types of privacy:

- Enterprise Ethereum Alliance (EEA) privacy, where private transactions include `privateFor` as the recipient.
- Besu-extended privacy, where private transactions include `privacyGroupId` as the recipient.

Both privacy types create privacy groups and store private transactions with their privacy group in Tessera.

<p align="center">

![Privacy Groups](../../../assets/images/PrivacyGroups.png)

</p>

:::note

For clarity, the Tessera nodes are not shown in the previous diagram. To send private transactions, each Besu node must have an associated Tessera node.

:::

### Access between states

A contract in a privacy group:

- Can read or write to a contract in the same privacy group.
- Can read from the public state including public contracts.
- Cannot access contracts from a different privacy group.

A public contract cannot access a private contract.

### Enterprise Ethereum Alliance privacy

In the privacy implementation complying with the [EEA Client Specification](https://entethalliance.org/technical-documents/) the group of nodes specified by `privateFrom` and `privateFor` form a privacy group with a unique privacy group ID provided by Tessera.

The previous diagram illustrates two privacy groups enabling:

- A, B, and C to send transactions that are private from D.
- A, C, and D to send transactions that are private from B.

Using EEA-compliant privacy, to send private transactions between A, B, and C, A initializes a contract in a private transaction with B and C specified as the `privateFor` and A specified as the `privateFrom`. Initializing the contract creates a privacy group consisting of A, B, and C. For the ABC private state to remain consistent, A, B, and C must be included on transactions (as either `privateFrom` or `privateFor`) even if they are between only two of the three parties.

To send private transactions between A, C, and D, C initializes a different contract in a private transaction with A and D specified as the `privateFor` and C specified as the `privateFrom`. Initializing the contract creates a privacy group consisting of A, C, and D. For the ACD private state to remain consistent, A, C, and D must be included on transactions (as either `privateFrom` or `privateFor`) even if they are between only two of the three parties.

### Besu-extended privacy

The Besu-extended privacy implementation creates a privacy group using [`priv_createPrivacyGroup`](../../reference/api/index.md#priv_createprivacygroup) with private transactions sent to the privacy group ID.

Using the same privacy groups as in the previous example.

Using Besu-extended privacy, to send private transactions between A, B, and C, A creates a privacy group consisting of A, B, and C. The privacy group ID is specified when sending private transactions and A, B, and C are recipients of all private transactions sent to the privacy group.

To send private transactions between A, C, and D, A creates a privacy group consisting of A, C, and D. The privacy group ID of this group is specified when sending private transactions with A, C, and D as recipients.

## Multi-tenancy

When using [multi-tenancy](multi-tenancy.md) with privacy groups, each user provides a JSON Web Token (JWT) which allows Besu to check that the user has access to functionality and data associated with a privacy group.
---
description: Private transaction overview
---

# Private transactions (Deprecated)

:::caution

Tessera-based privacy is deprecated in Besu version 24.12.0 and later. Please read this [blog post](https://www.lfdecentralizedtrust.org/blog/sunsetting-tessera-and-simplifying-hyperledger-besu) for more context on the rationale behind this decision as well as alternative options.

:::

Private transactions have the same parameters as public Ethereum transactions, with the following additions:

- `privateFrom` - The Tessera public key of the transaction sender.

- One of the following:

  - `privateFor` - The Tessera public keys of the transaction recipients.
  
  - `privacyGroupId` - [The privacy group to receive the transaction](../privacy-groups.md).
  
- `restriction` - Whether the private transaction is `restricted` or `unrestricted`:

  - `restricted` - Only the nodes participating in the transaction receive and store the payload of the private transaction.
  
  - `unrestricted` - All nodes in the network receive the payload of the private transaction, but only the nodes participating in the transaction can read the transaction.

  :::info

  Besu implements `restricted` private transactions only.

  :::

The `gas` and `gasPrice` are used by the [privacy marker transaction (PMT)](processing.md), not the private transaction itself.

:::info

Because gas isn't required in private transactions, inefficient contracts deployed accidentally or deliberately can cause performance issues in privacy-enabled networks. Ensure your network has a mechanism to [establish trust offchain](../index.md#privacy-enabled-networks).

:::

You can [create and send private transactions](../../../how-to/send-transactions/private-transactions.md).

## Besu and Tessera keys

Besu and Tessera nodes both have public/private key pairs identifying them. A Besu node sending a private transaction to a Tessera node signs the transaction with the Besu node private key. The `privateFrom` and `privateFor` parameters specified in the RLP-encoded transaction string for [`eea_sendRawTransaction`](../../../reference/api/index.md#eea_sendrawtransaction) are the public keys of the Tessera nodes sending and receiving the transaction.

:::info

The mapping of Besu node addresses to Tessera node public keys is offchain. That is, the sender of a private transaction must know the Tessera node public key of the recipient.

:::

## Nonces

A nonce is the number of previous transactions made by the sender.

[Private transaction processing](processing.md) involves two transactions: the private transaction distributed to involved participants, and the privacy marker transaction (PMT) included on the public blockchain. Each of these transactions has its own nonce. Since the PMT is a public transaction, the PMT nonce is the public nonce for the account.

### Private transaction nonce

Besu maintains separate private states for each [privacy group](../privacy-groups.md). The private transaction nonce for an account is specific to the privacy group. That is, the nonce for account A for privacy group ABC is different to the nonce for account A for privacy group AB.

### Private nonce validation

Unlike public transactions, private transactions are not submitted to the [transaction pool](../../../../public-networks/concepts/transactions/pool.md). The private transaction is distributed directly to the participants in the transaction, and the PMT is submitted to the transaction pool.

Unlike [public transaction nonces](../../../../public-networks/concepts/transactions/validation.md), private transaction nonces aren't validated when the private transaction is submitted. If a private transaction has an incorrect nonce, the PMT is still valid and is added to a block. However, in this scenario, the private transaction execution fails when [processing the PMT](processing.md) for the private transaction with the incorrect nonce.

The following private transaction flow illustrates when nonce validation occurs:

1. Submit a private transaction with a [nonce value](#private-transaction-nonce).
1. The private transaction is distributed to all participants in the privacy group.
1. The PMT is created and submitted to the transaction pool with a nonce of `0` if using one-time accounts. If using a specific account with [`--privacy-marker-transaction-signing-key-file`](../../../reference/cli/options.md#privacy-marker-transaction-signing-key-file-deprecated), the public nonce for that account is obtained and used for the PMT.
1. The PMT is mined and included in the block.
1. After the block containing the PMT is imported, and the PMT is processed, the private transaction is retrieved from the private transaction manager and executed.

   If the private transaction was submitted with a correct nonce in step 1, the nonce is validated as correct. If an incorrect nonce was submitted, the private transaction execution fails.

### Private nonce management

In Besu, you call [`eth_getTransactionCount`](../../../../public-networks/reference/api/index.md#eth_gettransactioncount) to get a nonce, then use that nonce with [`eea_sendRawTransaction`](../../../reference/api/index.md#eea_sendrawtransaction) to send a private transaction.

However, when you send multiple transactions in row, if a subsequent call to `getTransactionCount` happens before a previous transaction is processed, you can get the same nonce again.

You can manage private nonces in multiple ways:

- Let Besu handle it. You just need to wait long enough between calls to `sendRawTransaction` for the transactions to process. The current window is around 1.5 seconds, depending on block time.

  Public transactions deal with this issue, but the window is shorter, since you can use the transaction pool to take into account pending transactions (by using `eth_getTransactionCount("pending")`).

  For private transactions, the window is longer because private transactions aren't submitted to the transaction pool. You must wait until the private transaction's corresponding PMT is included in a block.

- Manage the nonce yourself, by keeping track of and providing the nonce at each call. We recommend this if you're [sending many transactions that are independent of each other](../../../how-to/send-transactions/concurrent-private-transactions.md).

  :::note

  You can use [`priv_getTransactionCount`](../../../reference/api/index.md#priv_gettransactioncount) or [`priv_getEeaTransactionCount`](../../../reference/api/index.md#priv_geteeatransactioncount) to get the nonce for an account for the specified privacy group or participants.

  :::

:::tip

The [web3js-quorum library includes an example](https://github.com/ConsenSys/web3js-quorum/blob/9a0f9eb1b91a4a0d93801f77782b509ae2e7314c/example/concurrentPrivateTransactions/concurrentPrivateTransactions.js) of nonce management when [sending concurrent private transactions](../../../how-to/send-transactions/concurrent-private-transactions.md). The example calculates the correct nonces for the private transactions and PMTs outside of Besu.

:::
---
title: Private transaction processing
sidebar_position: 1
description: Private transaction processing
---

# Private transaction processing (Deprecated)

:::caution

Tessera-based privacy is deprecated in Besu version 24.12.0 and later. Please read this [blog post](https://www.lfdecentralizedtrust.org/blog/sunsetting-tessera-and-simplifying-hyperledger-besu) for more context on the rationale behind this decision as well as alternative options.

:::

Processing [private transactions](index.md) involves the following:

- **Precompiled contract**: A smart contract compiled from the source language to EVM bytecode and stored by an Ethereum node for later execution.

- **Privacy marker transaction (PMT)**: A public Ethereum transaction with a payload of the enclave key. The enclave key is a pointer to the private transaction in Tessera. The `to` attribute of the PMT is the [address of the privacy precompiled contract](../../../reference/api/index.md#priv_getprivacyprecompileaddress).

  The PMT is [signed with a random key or the key specified on the command line].

Private transaction processing is illustrated and described in the following diagram.

![Processing Private Transactions](../../../../assets/images/PrivateTransactionProcessing.png)

1.  Submit a private transaction using [`eea_sendRawTransaction`](../../../reference/api/index.md#eea_sendrawtransaction). The signed transaction includes transaction parameters specific to private transactions, including:

    - `privateFor` or `privacyGroupId`, which specifies the list of recipients.
    - `privateFrom`, which specifies the sender.
    - `restriction`, which specifies the transaction is restricted to the transaction participants.

1.  The JSON-RPC endpoint passes the private transaction to the Private Transaction Handler.

1.  The Private Transaction Handler sends the private transaction to Tessera.

1.  Tessera distributes the private transaction directly (that is, point-to-point) to the Tessera nodes specified in `privateFor` or belonging to the privacy group identified by `privacyGroupId`. All recipient Tessera nodes store the transaction. Tessera associates the stored transaction with the transaction hash and privacy group ID.

1.  Tessera returns the transaction hash to the Private Transaction Handler.

1.  The Private Transaction Handler creates a PMT for the private transaction. The Private Transaction Handler propagates the PMT using devP2P in the same way as any other public Ethereum transaction.

    :::tip

    If you want to sign the PMT outside of Besu, use [`priv_distributeRawTransaction`](../../../how-to/send-transactions/private-transactions.md#priv_distributerawtransaction) instead of [`eea_sendRawTransaction`](../../../reference/api/index.md#eea_sendrawtransaction).

    :::

1.  Besu mines the PMT into a block and the PMT is distributed to all Ethereum nodes in the network.

1.  The Mainnet Transaction Processor processes the PMT in the same way as any other public transaction. On nodes containing the [privacy precompile contract](../../../reference/api/index.md#priv_getprivacyprecompileaddress) specified in the `to` attribute of the PMT, the Mainnet Transaction Processor passes the PMT to the privacy precompile contract.

    :::note

    Nodes receiving the PMT that don't contain the privacy precompile contract ignore the PMT.

    :::

1.  The privacy precompile contract queries Tessera for the private transaction and privacy group ID using the transaction hash.

1.  The privacy precompile contract passes the private transaction to the Private Transaction Processor. The privacy group ID specifies the private world state to use.

1.  The Private Transaction Processor executes the transaction. The Private Transaction Processor can read and write to the private world state, and read from the public world state.

:::danger Recommendations

- We recommend using a network with a consensus mechanism supporting transaction finality. For example, [IBFT 2.0](../../../how-to/configure/consensus/ibft.md).
- Tessera must be [highly available and run in a separate instance to Besu](../../../how-to/use-privacy/tessera.md).

Using private transactions with [fast sync](../../../../public-networks/reference/cli/options.md#sync-mode) is not supported.

:::

<!-- Links -->

[signed with a random key or the key specified on the command line]: ../../../how-to/use-privacy/sign-pmts.md
[highly available and run in a separate instance to Besu]: ../../../how-to/use-privacy/tessera.md

---
title: Start Besu
description: Start Besu on a private Ethereum network.
sidebar_position: 3
tags:
  - private networks
---

# Start Besu

Use the [`besu`](../reference/cli/options.md) command with the required command line options to start a node.

## Prerequisites

[Besu installed](install/binary-distribution.md)

## Local block data

When connecting to a network other than the network previously connected to, you must either delete the local block data or use the [`--data-path`](../../public-networks/reference/cli/options.md#data-path) option to specify a different data directory.

To delete the local block data, delete the `database` directory in the `besu/build/distribution/besu-<version>` directory.

## Genesis configuration

To define a genesis configuration, create a [genesis file](../../public-networks/concepts/genesis-file.md) (for example, `genesis.json`) and specify the file using the [`--genesis-file`](../../public-networks/reference/cli/options.md#genesis-file) option.

When you specify [`--network=dev`](../../public-networks/reference/cli/options.md#network), Besu uses the development mode genesis configuration with a fixed low difficulty. A node started with [`--network=dev`](../../public-networks/reference/cli/options.md#network) has an empty bootnodes list by default.

Predefined genesis configurations for named networks are in the [Besu source files](https://github.com/hyperledger/besu/tree/master/config/src/main/resources).

## Confirm node is running

If you started Besu with the [`--rpc-http-enabled`](../../public-networks/reference/cli/options.md#rpc-http-enabled) option, use [cURL](https://curl.haxx.se/) to call [JSON-RPC API methods](../reference/api/index.md) to confirm the node is running.

- `eth_chainId` returns the chain ID of the network.

  ```bash
  curl -X POST --data '{"jsonrpc":"2.0","method":"eth_chainId","params":[],"id":1}' localhost:8545/ -H "Content-Type: application/json"
  ```

- `eth_syncing` returns the starting, current, and highest block.

  ```bash
  curl -X POST --data '{"jsonrpc":"2.0","method":"eth_syncing","params":[],"id":1}' localhost:8545/ -H "Content-Type: application/json"
  ```

  For example, after connecting to Mainnet, `eth_syncing` will return something similar to:

  ```json
  {
    "jsonrpc": "2.0",
    "id": 1,
    "result": {
      "startingBlock": "0x0",
      "currentBlock": "0x2d0",
      "highestBlock": "0x66c0"
    }
  }
  ```

## Run a node for testing

To run a node that mines blocks at a rate suitable for testing purposes:

```bash
besu --network=dev --miner-enabled --miner-coinbase=0xfe3b557e8fb62b89f4916b721be55ceb828dbd73 --rpc-http-cors-origins="all" --host-allowlist="*" --rpc-ws-enabled --rpc-http-enabled --data-path=/tmp/tmpDatdir
```

You can also use the following [configuration file](../../public-networks/how-to/configure-besu/index.md) on the command line to start a node with the same options as above:

```toml
network="dev"
miner-enabled=true
miner-coinbase="0xfe3b557e8fb62b89f4916b721be55ceb828dbd73"
rpc-http-cors-origins=["all"]
host-allowlist=["*"]
rpc-ws-enabled=true
rpc-http-enabled=true
data-path="/tmp/tmpdata-path"
```

:::caution

The following settings are a security risk in production environments:

- Enabling the HTTP JSON-RPC service ([`--rpc-http-enabled`](../../public-networks/reference/cli/options.md#rpc-http-enabled)) and setting [`--rpc-http-host`](../../public-networks/reference/cli/options.md#rpc-http-host) to 0.0.0.0 exposes the RPC connection on your node to any remote connection.
- Setting [`--host-allowlist`](../../public-networks/reference/cli/options.md#host-allowlist) to `"*"` allows JSON-RPC API access from any host.
- Setting [`--rpc-http-cors-origins`](../../public-networks/reference/cli/options.md#rpc-http-cors-origins) to `"all"` or `"*"` allows cross-origin resource sharing (CORS) access from any domain.

:::

## Run a node on a private network

To run a node on your private network specifying a genesis file and data directory:

```bash
besu --genesis-file=<path>/genesis.json --data-path=<data-path> --rpc-http-enabled --bootnodes=<bootnodes>
```

Where `<data-path>` is the path to the directory to save the chain data to. Ensure you configure a peer discovery method, such as [bootnodes](../how-to/configure/bootnodes.md).

:::note

You might need to set [`--tx-pool-limit-by-account-percentage`](../../public-networks/reference/cli/options.md#tx-pool-limit-by-account-percentage) to 1. The default value is suitable for Mainnet, but may cause issues on private networks.

:::

:::note Sync nodes for BFT

If you're running a node on a [QBFT](../how-to/configure/consensus/qbft.md) or [IBFT 2.0](../how-to/configure/consensus/ibft.md) network, your node must use [fast sync](../../public-networks/concepts/node-sync.md#fast-synchronization-deprecated) or [full sync](../../public-networks/concepts/node-sync.md#full-synchronization). 

Full sync is set by default.

:::

---
title: System requirements
description: Ensure you meet the system requirements to sync and run Besu.
sidebar_position: 1
tags:
  - private networks
---

# System requirements

Private network system requirements depend on many factors, including:

- Size of the world state for the network.
- Number of transactions submitted to the network.
- [Block gas limit](../../public-networks/reference/genesis-items.md#genesis-block-parameters).
- Number and complexity of [JSON-RPC](../../public-networks/how-to/use-besu-api/json-rpc.md), [PubSub](../../public-networks/how-to/use-besu-api/rpc-pubsub.md), or [GraphQL](../../public-networks/how-to/use-besu-api/graphql.md) queries handled by the node.

Participation in private networks is typically restricted in some way, so the volume of traffic is much lower than on Mainnet, resulting in lower system requirements.

## Determining system requirements

To determine system requirements, check CPU and disk space requirements using [Prometheus](../../public-networks/how-to/monitor/metrics.md). Grafana provides a [sample dashboard](https://grafana.com/grafana/dashboards/10273) for Besu.

## Java Virtual Machine size

Depending on your environment and network setup, the minimum Java Virtual Machine (JVM) memory requirement for private networks is 4 GB.

JVM memory requirements are highest when syncing, but will reduce after the node is synchronized to the chain head. Monitor your system to determine your actual JVM memory needs.

## VM requirements

If you set up your own VM locally using a VM manager such as [VirtualBox](https://www.oracle.com/virtualization/virtualbox/):

- Ensure you enable Intel Virtualization Technology (VTx) and Virtualization Technology for Directed I/O (VT-d) in the BIOS settings.
- On Windows, you might need to disable Hyper-V in the Windows Feature list.

We recommend you create a VM with the following attributes:

- Memory size: Set to 6 GB (recommended)
- Create a virtual hard disk with at least 10 GB (20 GB recommended)
- Virtual hard disk file type: VDI (if you need to share it with other apps, use VHD)
- (Optional) You can create a shared directory to copy block files or genesis files from the host computer to the VM. For details on how to create a shared directory, see "Share Folders" in the [Oracle VirtualBox documentation].

## Disk type

Use [local SSD storage](https://cloud.google.com/compute/docs/disks) for high throughput nodes (validators and RPC nodes). Read-only nodes can use a lower performance setup.

You can use local SSDs through [SCSI interfaces](https://en.wikipedia.org/wiki/SCSI). For higher performance in production settings, we recommend upgrading to [NVMe interfaces](https://cloud.google.com/compute/docs/disks/local-ssd#performance).

<!-- Links -->

[Oracle VirtualBox documentation]: https://docs.oracle.com/en/virtualization/virtualbox/6.1/user/

---
title: Installation options
description: Options for getting started with Besu
sidebar_position: 1
tags:
  - private networks
---

# Installation options

Get started with the [Developer Quickstart](../../../private-networks/tutorials/quickstart.md). Use the quickstart to rapidly generate local blockchain networks.

You can also install the following:

- [Docker image](run-docker-image.md)
- [Binaries](binary-distribution.md)

## Build from source

If you want to use the latest development version of Besu or a specific commit, build from source. Otherwise, use the [binary] or [Docker image] for more stable versions.

View the [Wiki] for instructions to install Besu from source.

<!-- link -->

[Wiki]: https://wiki.hyperledger.org/display/BESU/Building+from+source
[binary]: binary-distribution.md
[Docker image]: run-docker-image.md

---
title: Install binary distribution
description: Install or upgrade Besu from binary distribution
sidebar_position: 3
tags:
  - private networks
---

# Install binary distribution

## MacOS with Homebrew

### Prerequisites

- [Homebrew](https://brew.sh/)
- Java JDK

:::caution

Besu supports:

- MacOS High Sierra 10.13 or later versions.
- Java 21+. You can install Java using `brew install openjdk@21`. Alternatively, you can manually install the [Java JDK](https://www.oracle.com/java/technologies/downloads).

:::

### Install (or upgrade) using Homebrew

To install Besu using Homebrew:

```bash
brew tap hyperledger/besu
brew install hyperledger/besu/besu
```

To upgrade an existing Besu installation using Homebrew:

```bash
brew upgrade hyperledger/besu/besu
```

:::note

If you've upgraded your MacOS version between installing and upgrading Besu, when running `brew upgrade hyperledger/besu/besu` you may be prompted to reinstall command line tools with `xcode-select --install`.

:::

:::note

When upgrading Besu, you might be prompted to fix the remote branch names in Homebrew by using the command `brew tap --repair`.

:::

To display the Besu version and confirm installation:

```bash
besu --version
```

To display Besu command line help:

```bash
besu --help
```

## Linux / Unix

### Prerequisites

- [Java JDK 17+](https://www.oracle.com/java/technologies/downloads/)

:::note Linux open file limit

If synchronizing to Mainnet on Linux or other chains with large data requirements, increase the maximum number of open files allowed using `ulimit`. If the open files limit is not high enough, a `Too many open files` RocksDB exception occurs.

:::

:::tip

We recommend installing [jemalloc](https://jemalloc.net/) to reduce memory usage. If using Ubuntu, you can install it with the command: `apt install libjemalloc-dev`.

:::

### Install from packaged binaries

Download the Besu [packaged binaries](https://github.com/hyperledger/besu/releases).

Unpack the downloaded files and change into the `besu-<release>` directory.

Display Besu command line help to confirm installation:

```bash
bin/besu --help
```

## Upgrade Besu

See the [Upgrade Besu](../../../public-networks/how-to/upgrade-node.md#upgrade-on-linux) guide for instructions on upgrading Besu on Linux.

---
title: Run Besu from Docker image
description: Run Besu using the official docker image
sidebar_position: 2
tags:
  - private networks
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Run Besu from a Docker image

Besu provides a Docker image to run a Besu node in a Docker container.

Use this Docker image to run a single Besu node without installing Besu.

## Prerequisites

- [Docker](https://docs.docker.com/install/)

- MacOS or Linux

  :::caution

  The Docker image does not run on Windows.

  :::

## Expose ports

Expose ports for P2P discovery, GraphQL, metrics, and HTTP and WebSocket JSON-RPC. You need to expose the ports to use the default ports or the ports specified using [`--rpc-http-port`](../../../public-networks/reference/cli/options.md#rpc-http-port), [`--p2p-port`](../../../public-networks/reference/cli/options.md#p2p-port), [`--rpc-ws-port`](../../../public-networks/reference/cli/options.md#rpc-ws-port), [`--metrics-port`](../../../public-networks/reference/cli/options.md#metrics-port), [`--graphql-http-port`](../../../public-networks/reference/cli/options.md#graphql-http-port), and [`--metrics-push-port`](../../../public-networks/reference/cli/options.md#metrics-push-port) options.

To run Besu exposing local ports for access:

```bash
docker run -p <localportJSON-RPC>:8545 -p <localportWS>:8546 -p <localportP2P>:30303 hyperledger/besu:latest --rpc-http-enabled --rpc-ws-enabled
```

:::note

The examples on this page expose TCP ports only. To expose UDP ports, specify `/udp` at the end of the argument for the `-p` Docker subcommand option:

```bash
docker run -p <port>:<port>/udp
```

See the [`docker run -p` documentation](https://docs.docker.com/engine/reference/commandline/run/#publish-or-expose-port--p---expose).

:::

To enable JSON-RPC HTTP calls to `127.0.0.1:8545` and P2P discovery on `127.0.0.1:13001`:

```bash
docker run -p 8545:8545 -p 13001:30303 hyperledger/besu:latest --rpc-http-enabled
```

## Start Besu

:::danger

Don't mount a volume at the default data path (`/opt/besu`). Mounting a volume at the default data path interferes with the operation of Besu and prevents Besu from safely launching.

To run a node that maintains the node state (key and database), [`--data-path`](../../../public-networks/reference/cli/options.md#data-path) must be set to a location other than `/opt/besu` and a storage volume mounted at that location.

When running in a Docker container, [`--nat-method`](../../../public-networks/how-to/connect/specify-nat.md) must be set to `DOCKER` or `AUTO` (default). Don't set [`--nat-method`](../../../public-networks/how-to/connect/specify-nat.md) to `NONE` or `UPNP`.

:::

You can specify [Besu environment variables](../../../public-networks/reference/cli/options.md#specify-options) with the Docker image instead of the command line options.

<Tabs>
  <TabItem value="Holesky" label="Holesky">

  ```bash
  docker run -p 30303:30303 -p 8545:8545 -e BESU_RPC_HTTP_ENABLED=true -e BESU_NETWORK=holesky hyperledger/besu:latest
  ```
  </TabItem>

  <TabItem value="Ephemery" label="Ephemery">
  
  ```bash
  docker run -p 30303:30303 -p 8545:8545 -e BESU_RPC_HTTP_ENABLED=true -e BESU_NETWORK=ephemery hyperledger/besu:latest
  ```
  </TabItem>
</Tabs>

:::caution "Unsupported address type exception"

When running Besu from a Docker image, you might get the following exception:

```bash
Unsupported address type exception when connecting to peer {}, this is likely due to ipv6 not being enabled at runtime.
```

This happens when the IPv6 support in Docker is disabled while connecting to an IPv6 peer, preventing outbound communication. IPv6 is disabled by default in Docker.

[Enable IPv6 support in Docker](https://docs.docker.com/config/daemon/ipv6/) to allow outbound IPv6 traffic and allow connection with IPv6 peers.

:::

### Run a node for testing

To run a node that mines blocks at a rate suitable for testing purposes with WebSocket enabled:

```bash
docker run -p 8546:8546 --mount type=bind,source=/<myvolume/besu/testnode>,target=/var/lib/besu hyperledger/besu:latest --miner-enabled --miner-coinbase fe3b557e8fb62b89f4916b721be55ceb828dbd73 --rpc-ws-enabled --network=dev --data-path=/var/lib/besu
```

## Stop Besu and clean up resources

When done running nodes, you can shut down the node container without deleting resources or you can delete the container after stopping it. Run `docker container ls` and `docker volume ls` to get the container and volume names.

To stop a container:

```bash
docker stop <container-name>
```

To delete a container:

```bash
docker rm <container-name>
```

## Upgrade Besu

See the [Upgrade Besu](../../../public-networks/how-to/upgrade-node.md#upgrade-on-docker) guide for instructions on upgrading Besu on Docker.
